#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@file-thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python
#@+all
#@+node:ekr.20031218072017.1135: Bindings
#@+node:ekr.20031218072017.1136:(up-down arrows )
#@+node:ekr.20031218072017.1137: Original proc moveUpDown
@nocolor
Here is the above code in a function, with definitions for missing functions min/max and with missing function lset replaced with calls to scan. The code has also been modified to correctly handle more than a screenful of text. This code still lacks the feature found in the default tkTextUpDownLine where the original column is maintained across repeated operations even though some lines passed through don't have enough columns -- Brian Theado:
@color
@language tcltk

 proc min args {lindex [lsort -real $args] 0}
 proc max args {lindex [lsort -real $args] end}
 
 proc moveUpDown {textWidget upOrDown} {
     # Make the insertion cursor visible so bbox doesn't return empty list
     $textWidget see insert

     # Find the coordinates of the cursor and set the new height
     # manually. Note: errors rounding off, since
     # coordinates don't match character positions exactly.
     scan [$textWidget index insert] {%d.%d} lines char
     scan [$textWidget bbox [$textWidget index insert]] {%d %d %d %d} x y textWidth textHeight
     scan [$textWidget bbox @[winfo width $textWidget],[winfo height $textWidget]] {%*d %d %*d %*d} maxy
     # When updating position, make sure y is within text boundaries
     switch -- $upOrDown {
       "up" {
           if {$y <= $textHeight} {
               $textWidget yview scroll -1 units
           } else {
               set y [max [expr $y-$textHeight] 0]
           }
       }
       "down" {
           if {$y >= $maxy} {
                $textWidget yview scroll 1 units
           } else {
                set y [min [expr $y+$textHeight] $maxy]
           }
       }
     }
     scan [$textWidget bbox [$textWidget index @$x,$y]] {%d %d %d %*d} newx newy width

     # Test on which side of the character
     # we should position the cursor
     if {$x>[expr $newx+$width/2]} {
       set x [expr $newx+$width+1]
     }
     return [$textWidget index @$x,$y]
 }

 # Replace the default Text widget bindings to try it out
 bind Text <Up> {
    tkTextSetCursor %W [moveUpDown %W up]
 }
 bind Text <Down> {
    tkTextSetCursor %W [moveUpDown %W down]
 }
#@nonl
#@-node:ekr.20031218072017.1137: Original proc moveUpDown
#@+node:ekr.20031218072017.1138: New notes from Brian
@nocolor

>Drat. There is some interaction between the new moveUpDown code and previous bindings... 

Note the code at http://wiki.tcl.tk/3082 is passing the result of moveUpDown to the function tkTextSetCursor, which both moves the insertion cursor and removes the selection (see lib/tk8.3/text.tcl in the Tcl/Tk distribution for the definition of this function). I notice in the leo code just moves the insertion cursor. 

Also, I just realized that Shift-Up and Shift-Down should probably rebound to use the new up/down code so stroking the selection is consistent with moving up and down. I updated the above referenced web page with this change. 

In Python the Shift-Up and Shift-Down is probably harder to incorporate in Python because it uses tkTextKeySelect which does more than tkTextSetCursor (have a look at text.tcl). I guess either more transliteration of Tcl ("greek") would be needed or maybe the tkTextKeySelect can be called from Python. 

Brian Theado 
#@nonl
#@-node:ekr.20031218072017.1138: New notes from Brian
#@+node:ekr.20031218072017.1139: Request
@nocolor

https://sourceforge.net/forum/message.php?msg_id=1796317
By: nobody

I am a newbie to Leo, and not a programmer.
I intend to use it to write plain text, not code. I believe Leo is an ideal
writer's tool as well.

But there is one behaviour of the TkText widget that I find hard to swallow:
not to be able to move through a paragraph of text with the cursor keys.

To quote from the Leo documentation: 
"Line movement is by text lines terminated by hard returns (newlines), not by
displayed lines; if a text line is long and wraps across more than one display
line, then the Up and Down movement will skip the extra wrapped display lines."

This is probably fine for programming where a code line is usually shorter than
a screen line and so all lines are terminated by hard returns. But for plain
text in ordinary writing, most paragraphs are longer than a screen line. So
I am forced to use the mouse for every movement in the text. Unless I want to
go back word-by-word through the whole paragraph. Not very effective for writers
who mostly prefer the keyboard over the mouse.

If this cannot be changed, I would like to see MORE's 'hoist' command implemented:
hoisting the body pane text to a separate, preferrably full screen editor window
with a more navigable editor.
Actually I would like to see a 'hoist' command anyway. Working on my text on
the full screen is just nicer. But being able to bring the body pane size up
to full screen height with one command would be enough (if I could use cursor
keys for movement across screen lines...).

Ulrich
#@-node:ekr.20031218072017.1139: Request
#@+node:ekr.20031218072017.1140: Test
1 aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccccc dddddddddddddddd
2 eeeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff ggggggggggggggggggg hhhhhhhhhhhhh
3 iiiiiiiiiiiiiiiiiiii jjjjjjjjjjjjjjjjjjjjj kkkkkkkkkkkkkkk













4 aaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbb cccccccccccccccccc dddddddddddddddd
5 eeeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff ggggggggggggggggggg hhhhhhhhhhhhh
6 iiiiiiiiiiiiiiiiiiii jjjjjjjjjjjjjjjjjjjjj kkkkkkkkkkkkkkk
#@nonl
#@-node:ekr.20031218072017.1140: Test
#@+node:ekr.20031218072017.1141:tree.moveUpDown
def OnUpKey   (self,event=None): return self.moveUpDown("up")
def OnDownKey (self,event=None): return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
	c = self.c ; body = c.frame.bodyCtrl
	# Make the insertion cursor visible so bbox won't return an empty list.
	body.see("insert")
	# Find the coordinates of the cursor and set the new height.
	# There may be roundoff errors because character postions may not match exactly.
	ins =  body.index("insert")
	lines,char = g.scanf(ins,"%d.%d")
	x,y,junk,textH = body.bbox("insert")
	bodyW,bodyH = body.winfo_width(),body.winfo_height()
	junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
	# Make sure y is within text boundaries.
	if upOrDown == "up":
		if y <= textH:
			body.yview("scroll",-1,"units")
		else: y = max(y-textH,0)
	else:
		if y >= maxy:
			body.yview("scroll",1,"units")
		else: y = min(y+textH,maxy)
	# Position the cursor on the proper side of the characters.
	newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
	if x > newx + width/2:
		x = newx + width + 1
	result = body.index("@%d,%d" % (x,y))
	body.mark_set("insert",result)
	# g.trace("entry:  %s.%s" % (lines,char))
	# g.trace("result:",result)
	# g.trace("insert:",body.index("insert"))
	return "break" # Inhibit further bindings.
#@nonl
#@-node:ekr.20031218072017.1141:tree.moveUpDown
#@-node:ekr.20031218072017.1136:(up-down arrows )
#@-node:ekr.20031218072017.1135: Bindings
#@+node:ekr.20031218072017.1131: Drawing
#@+node:ekr.20031218072017.1132:(Scrollwheel)
@nocolor

This works in the log and body panes, and not in the outline pane.

proc mscroll {bindtag} {
      bind $bindtag <Button-5> [list %W yview scroll 5 units]
      bind $bindtag <Button-4> [list %W yview scroll -5 units]
      bind $bindtag <Shift-Button-5> [list %W yview scroll 1 units]
      bind $bindtag <Shift-Button-4> [list %W yview scroll -1 units]
      bind $bindtag <Control-Button-5> [list %W yview scroll 1 pages]
      bind $bindtag <Control-Button-4> [list %W yview scroll -1 pages]

from Tkinter import *

def roll(event):
    print event.delta

frame = Frame(width=200, height=200)
frame.pack()
frame.focus_set() # wheel events goes to focussed window
frame.bind("<MouseWheel>", roll)
#@nonl
#@-node:ekr.20031218072017.1132:(Scrollwheel)
#@-node:ekr.20031218072017.1131: Drawing
#@+node:ekr.20031218072017.1924: Waiting for help from Linux people
#@+node:ekr.20031218072017.1925:Paste bug (Linux only)
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
	
	"""Queue the body changed idle handler."""
	
	c = self.c

	if not oldSel:
		oldSel = c.frame.body.getTextSelection()

	if not p:
		p = c.currentPosition()

	self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@+node:ekr.20031218072017.843:frame.OnPaste, OnPasteNode, OnPasteFromMenu
def OnPaste (self,event=None):
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	# Activate the body key handler by hand.
	frame.body.forceFullRecolor()
	frame.body.onBodyWillChange(v,"Paste")
	
def OnPasteFromMenu (self):
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	w = self.getFocus()
	w.event_generate(g.virtual_event_name("Paste"))
	
	if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
		frame.tree.onHeadChanged(v)
#@nonl
#@-node:ekr.20031218072017.843:frame.OnPaste, OnPasteNode, OnPasteFromMenu
#@+node:ekr.20031218072017.1321:idle_body_key
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
	
	"""Update the body pane at idle time."""

	# g.trace(ch,ord(ch))
	c = self.c
	if not c: return "break"
	if not p: return "break"
	if p != c.currentPosition(): return "break"
	v = p.v # used only to get p.iconVal.

	if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
		return "break" # The hook claims to have handled the event.
	body = p.bodyString()
	if not newSel:
		newSel = c.frame.body.getTextSelection()
	if oldText != None:
		s = oldText
	else:
		s = c.frame.body.getAllText()
	<< return if nothing has changed >>
	<< set removeTrailing >>
	if ch in ('\n','\r'):
		<< Do auto indent >>
	elif ch == '\t' and c.tab_width < 0:
		<< convert tab to blanks >>
	<< set s to widget text, removing trailing newlines if necessary >>
	if undoType: # 11/6/03: set oldText properly when oldText param exists.
		if not oldText: oldText = body
		newText = s
		c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
	p.v.setTnodeText(s)
	p.v.t.insertSpot = c.frame.body.getInsertionPoint()
	<< recolor the body >>
	if not c.changed:
		c.setChanged(true)
	<< redraw the screen if necessary >>
	g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
	return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# 6/22/03: Make sure we handle delete key properly.

if ch not in ('\n','\r',chr(8)):

	if s == body:
		return "break"
	
	# Do nothing for control characters.
	if (ch == None or len(ch) == 0) and body == s[:-1]:
		return "break"
	
# print repr(ch),len(body),len(s)
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
	# There is no newline to remove.  Probably will never happen.
	# g.trace("false: no newline to remove")
	removeTrailing = false
elif len(old) == 0:
	# Ambigous case.
	# g.trace("false: empty old")
	removeTrailing = ch != '\n' # false
elif old == new[:-1]:
	# A single trailing character has been added.
	# g.trace("false: only changed trailing.")
	removeTrailing = false
else:
	# The text didn't have a newline, and now it does.
	# Moveover, some other change has been made to the text,
	# So at worst we have misreprented the user's intentions slightly.
	# g.trace("true")
	removeTrailing = true
	
# g.trace(ch,removeTrailing)


#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
# Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
	# Get the previous line.
	s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
	# Add the leading whitespace to the present line.
	junk,width = g.skip_leading_ws_with_indent(s,0,c.tab_width)
	if s and len(s) > 0 and s[-1]==':':
		# For Python: increase auto-indent after colons.
		if self.colorizer.scanColorDirectives(p) == "python":
			width += abs(c.tab_width)
	if g.app.config.getBoolWindowPref("smart_auto_indent"):
		# Added Nov 18 by David McNab, david@rebirthing.co.nz
		# Determine if prev line has unclosed parens/brackets/braces
		brackets = [width]
		tabex = 0
		for i in range(0, len(s)):
			if s[i] == '\t':
				tabex += c.tab_width - 1
			if s[i] in '([{':
				brackets.append(i+tabex + 1)
			elif s[i] in '}])' and len(brackets) > 1:
				brackets.pop()
		width = brackets.pop()
		# end patch by David McNab
	ws = g.computeLeadingWhitespace (width,c.tab_width)
	if ws and len(ws) > 0:
		c.frame.bodyCtrl.insert("insert", ws)
		removeTrailing = false # bug fix: 11/18
#@nonl
#@-node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
#@+node:ekr.20031218072017.1325:<< convert tab to blanks >>
# Do nothing if we are executing a Change command.
if undoType != "Change":
	
	# Get the characters preceeding the tab.
	prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
	
	if 1: # 6/26/03: Convert tab no matter where it is.

		w = g.computeWidth(prev,c.tab_width)
		w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
		# g.trace("prev w:",w,"prev chars:",prev)
		c.frame.bodyCtrl.delete("insert -1c")
		c.frame.bodyCtrl.insert("insert",' ' * w2)
	
	else: # Convert only leading tabs.
	
		# Get the characters preceeding the tab.
		prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

		# Do nothing if there are non-whitespace in prev:
		all_ws = true
		for ch in prev:
			if ch != ' ' and ch != '\t':
				all_ws = false
		if all_ws:
			w = g.computeWidth(prev,c.tab_width)
			w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
			# g.trace("prev w:",w,"prev chars:",prev)
			c.frame.bodyCtrl.delete("insert -1c")
			c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20031218072017.1325:<< convert tab to blanks >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
	s = s[:-1]
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = false
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = false

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
	redraw_flag = true
	
# Update icons.
val = p.computeIcon()
if val != v.iconVal:
	v.iconVal = val
	redraw_flag = true

c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1321:idle_body_key
#@-node:ekr.20031218072017.1925:Paste bug (Linux only)
#@+node:ekr.20031218072017.1926:Linux headline bug
@nocolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=2257820
By: wtrenker

When I edit a Headline and select the existing text, then I paste in some other
text, the original selected text remains instead of being overwritten by the
newly pasted text.

Here's a simple, repeatable example.  Start a new Leo file.  As expected, the
new file is initialized with a single node with a headline containing the text
"NewHeadline".  The text is pre-selected, ready to edit.  Now do a copy and
then paste.  The text will now read "NewHeadlineNewHeadline".  The original
text was not overwritten.

Here's my configuration:

Leo Log Window...
Leo 4.0.3, build  1.99 , October 25, 2003
Python 2.3.2, Tk 8.3.3

Linux 2.4.19; libc.so.6 2.2.5; gcc 2.95.3
KDE: 3.0.0 Qt: 3.0.4
GNU ld version 2.13.90.0.4 20020814
GNU Make 3.80
pkg-config 0.14.0
Python 2.3.2 (#1, Oct 27 2003, 10:19:56) [GCC 2.95.3 20010315 (release)]

Regards,
Bill
#@-node:ekr.20031218072017.1926:Linux headline bug
#@-node:ekr.20031218072017.1924: Waiting for help from Linux people
#@+node:ekr.20031218072017.1319:(Key handlers)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
	
	"""Update the body pane at idle time."""

	# g.trace(ch,ord(ch))
	c = self.c
	if not c: return "break"
	if not p: return "break"
	if p != c.currentPosition(): return "break"
	v = p.v # used only to get p.iconVal.

	if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
		return "break" # The hook claims to have handled the event.
	body = p.bodyString()
	if not newSel:
		newSel = c.frame.body.getTextSelection()
	if oldText != None:
		s = oldText
	else:
		s = c.frame.body.getAllText()
	<< return if nothing has changed >>
	<< set removeTrailing >>
	if ch in ('\n','\r'):
		<< Do auto indent >>
	elif ch == '\t' and c.tab_width < 0:
		<< convert tab to blanks >>
	<< set s to widget text, removing trailing newlines if necessary >>
	if undoType: # 11/6/03: set oldText properly when oldText param exists.
		if not oldText: oldText = body
		newText = s
		c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
	p.v.setTnodeText(s)
	p.v.t.insertSpot = c.frame.body.getInsertionPoint()
	<< recolor the body >>
	if not c.changed:
		c.setChanged(true)
	<< redraw the screen if necessary >>
	g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
	return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# 6/22/03: Make sure we handle delete key properly.

if ch not in ('\n','\r',chr(8)):

	if s == body:
		return "break"
	
	# Do nothing for control characters.
	if (ch == None or len(ch) == 0) and body == s[:-1]:
		return "break"
	
# print repr(ch),len(body),len(s)
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
	# There is no newline to remove.  Probably will never happen.
	# g.trace("false: no newline to remove")
	removeTrailing = false
elif len(old) == 0:
	# Ambigous case.
	# g.trace("false: empty old")
	removeTrailing = ch != '\n' # false
elif old == new[:-1]:
	# A single trailing character has been added.
	# g.trace("false: only changed trailing.")
	removeTrailing = false
else:
	# The text didn't have a newline, and now it does.
	# Moveover, some other change has been made to the text,
	# So at worst we have misreprented the user's intentions slightly.
	# g.trace("true")
	removeTrailing = true
	
# g.trace(ch,removeTrailing)


#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
# Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
	# Get the previous line.
	s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
	# Add the leading whitespace to the present line.
	junk,width = g.skip_leading_ws_with_indent(s,0,c.tab_width)
	if s and len(s) > 0 and s[-1]==':':
		# For Python: increase auto-indent after colons.
		if self.colorizer.scanColorDirectives(p) == "python":
			width += abs(c.tab_width)
	if g.app.config.getBoolWindowPref("smart_auto_indent"):
		# Added Nov 18 by David McNab, david@rebirthing.co.nz
		# Determine if prev line has unclosed parens/brackets/braces
		brackets = [width]
		tabex = 0
		for i in range(0, len(s)):
			if s[i] == '\t':
				tabex += c.tab_width - 1
			if s[i] in '([{':
				brackets.append(i+tabex + 1)
			elif s[i] in '}])' and len(brackets) > 1:
				brackets.pop()
		width = brackets.pop()
		# end patch by David McNab
	ws = g.computeLeadingWhitespace (width,c.tab_width)
	if ws and len(ws) > 0:
		c.frame.bodyCtrl.insert("insert", ws)
		removeTrailing = false # bug fix: 11/18
#@nonl
#@-node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
#@+node:ekr.20031218072017.1325:<< convert tab to blanks >>
# Do nothing if we are executing a Change command.
if undoType != "Change":
	
	# Get the characters preceeding the tab.
	prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
	
	if 1: # 6/26/03: Convert tab no matter where it is.

		w = g.computeWidth(prev,c.tab_width)
		w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
		# g.trace("prev w:",w,"prev chars:",prev)
		c.frame.bodyCtrl.delete("insert -1c")
		c.frame.bodyCtrl.insert("insert",' ' * w2)
	
	else: # Convert only leading tabs.
	
		# Get the characters preceeding the tab.
		prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

		# Do nothing if there are non-whitespace in prev:
		all_ws = true
		for ch in prev:
			if ch != ' ' and ch != '\t':
				all_ws = false
		if all_ws:
			w = g.computeWidth(prev,c.tab_width)
			w2 = (abs(c.tab_width) - (w % abs(c.tab_width)))
			# g.trace("prev w:",w,"prev chars:",prev)
			c.frame.bodyCtrl.delete("insert -1c")
			c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20031218072017.1325:<< convert tab to blanks >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
	s = s[:-1]
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = false
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = false

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
	redraw_flag = true
	
# Update icons.
val = p.computeIcon()
if val != v.iconVal:
	v.iconVal = val
	redraw_flag = true

c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1321:idle_body_key
#@+node:ekr.20031218072017.1329:onBodyChanged (called from core)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
	
	"""Handle a change to the body pane."""
	
	c = self.c
	if not p:
		p = c.currentPosition()

	if not oldSel:
		oldSel = c.frame.body.getTextSelection()

	self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (called from core)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event):
	
	"""Handle any key press event in the body pane."""

	c = self.c ; ch = event.char 
	oldSel = c.frame.body.getTextSelection()
	
	p = c.currentPosition()

	# g.trace(repr(ch))

	if 0: # won't work when menu keys are bound.
		self.handleStatusLineKey(event)
		
	# g.trace(p)
		
	# We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
	self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)

#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
	
	c = self.c ; frame = c.frame
	ch = event.char ; keysym = event.keysym
	keycode = event.keycode ; state = event.state

	if 1: # ch and len(ch)>0:
		<< trace the key event >>

	try:
		status = self.keyStatus
	except:
		status = [] ; frame.clearStatusLine()
	
	for sym,name in (
		("Alt_L","Alt"),("Alt_R","Alt"),
		("Control_L","Control"),("Control_R","Control"),
		("Escape","Esc"),
		("Shift_L","Shift"), ("Shift_R","Shift")):
		if keysym == sym:
			if name not in status:
				status.append(name)
				frame.putStatusLine(name + ' ')
			break
	else:
		status = [] ; frame.clearStatusLine()

	self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
	self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
	
	"""Queue the body changed idle handler."""
	
	c = self.c

	if not oldSel:
		oldSel = c.frame.body.getTextSelection()

	if not p:
		p = c.currentPosition()

	self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@+node:ekr.20031218072017.1332:headline key handlers (tree)
@ The <Key> event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1333:onHeadChanged
def onHeadChanged (self,p):
	
	"""Handle a change to headline text."""

	self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p)
#@nonl
#@-node:ekr.20031218072017.1333:onHeadChanged
#@+node:ekr.20031218072017.1334:OnHeadlineKey
def OnHeadlineKey (self,p,event):
	
	"""Handle a key event in a headline."""

	ch = event.char
	self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)

#@-node:ekr.20031218072017.1334:OnHeadlineKey
#@+node:ekr.20031218072017.1335:idle_head_key
def idle_head_key (self,p,ch=None):
	
	"""Update headline text at idle time."""

	c = self.c ; v = p.v

	if not p or not p.edit_text() or p != c.currentPosition():
		return "break"
		
	edit_text = p.edit_text()

	if g.doHook("headkey1",c=c,p=p,ch=ch):
		return "break" # The hook claims to have handled the event.

	<< set s to the widget text >>
	<< set head to vnode text >>
	changed = s != head
	done = ch and (ch == '\r' or ch == '\n')
	if not changed and not done:
		return "break"
	if changed:
		c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
	index = edit_text.index("insert")
	if changed:
		<< update v and all nodes joined to v >>
	<< reconfigure v and all nodes joined to v >>
	<< update the screen >>

	g.doHook("headkey2",c=c,p=p,ch=ch)
	return "break"
#@nonl
#@+node:ekr.20031218072017.1336:<< set s to the widget text >>
s = edit_text.get("1.0","end")
s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03

if not s:
	s = u""
s = s.replace('\n','')
s = s.replace('\r','')
# g.trace(s)
#@-node:ekr.20031218072017.1336:<< set s to the widget text >>
#@+node:ekr.20031218072017.1337:<< set head to vnode text >>
head = p.headString()
if head == None:
	head = u""
head = g.toUnicode(head,"utf-8")
#@-node:ekr.20031218072017.1337:<< set head to vnode text >>
#@+node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
c.beginUpdate()
if 1: # update...
	# Update changed bit.
	if not c.changed:
		c.setChanged(true)
	# Update all dirty bits.
	p.setDirty()
	# Update v.
	v.initHeadString(s)
	edit_text.delete("1.0","end")
	edit_text.insert("end",s)
	edit_text.mark_set("insert",index)
c.endUpdate(false) # do not redraw now.
#@nonl
#@-node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
#@+node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
# Reconfigure v's headline.
if done:
	self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(v))
#@nonl
#@-node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
#@+node:ekr.20031218072017.1340:<< update the screen >>
if done:
	c.beginUpdate()
	self.endEditLabel()
	c.endUpdate()

elif changed:
	# update v immediately.  Joined nodes are redrawn later by endEditLabel.
	# Redrawing the whole screen now messes up the cursor in the headline.
	self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20031218072017.1340:<< update the screen >>
#@-node:ekr.20031218072017.1335:idle_head_key
#@-node:ekr.20031218072017.1332:headline key handlers (tree)
#@-node:ekr.20031218072017.1319:(Key handlers)
#@+node:ekr.20040105210752:(Keystrokes)
#@+node:ekr.20040105214540:Notes
@nocolor

Values for the state field.

No modifiers:  0
Shift: 1
Caps_lock: 2
Control: 4
Alt: 131072

A possible strategy:
	
1.  Only pass keys to body pane if state is 0, 1, 2 or 3.
#@nonl
#@-node:ekr.20040105214540:Notes
#@+node:ekr.20031218072017.3960:Creating the status area
@tabwidth 4
#@+node:ekr.20031218072017.3961:createStatusLine
def createStatusLine (self):
	
	if self.statusFrame and self.statusLabel:
		return
	
	self.statusFrame = statusFrame = Tk.Frame(self.outerFrame,bd=2)
	statusFrame.pack(fill="x",pady=1)
	
	text = "line 0, col 0"
	width = len(text) + 4
	self.statusLabel = Tk.Label(statusFrame,text=text,width=width,anchor="w")
	self.statusLabel.pack(side="left",padx=1)
	
	bg = statusFrame.cget("background")
	self.statusText = Tk.Text(statusFrame,height=1,state="disabled",bg=bg,relief="groove")
	self.statusText.pack(side="left",expand=1,fill="x")

	# Register an idle-time handler to update the row and column indicators.
	self.statusFrame.after_idle(self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.3961:createStatusLine
#@+node:ekr.20031218072017.3962:clearStatusLine
def clearStatusLine (self):
	
	t = self.statusText
	if not t: return
	
	t.configure(state="normal")
	t.delete("1.0","end")
	t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clearStatusLine
#@+node:EKR.20040424153344:enable/disableStatusLine & isEnabled
def disableStatusLine (self):
	
	t = self.statusText
	if t:
		t.configure(state="disabled",background="gray")
	
def enableStatusLine (self):
	
	t = self.statusText
	if t:
		t.configure(state="normal",background="pink")
		t.focus_set()
		
def statusLineIsEnabled(self):
	t = self.statusText
	if t:
		state = t.cget("state")
		return state == "normal"
	else:
		return false
#@nonl
#@-node:EKR.20040424153344:enable/disableStatusLine & isEnabled
#@+node:ekr.20031218072017.3963:putStatusLine
def putStatusLine (self,s,color=None):
	
	t = self.statusText ; tags = self.statusColorTags
	if not t: return

	t.configure(state="normal")
	
	if "black" not in self.log.colorTags:
		tags.append("black")
		
	if color and color not in tags:
		tags.append(color)
		t.tag_config(color,foreground=color)

	if color:
		t.insert("end",s)
		t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
		t.tag_config("black",foreground="black")
		t.tag_add("black","end")
	else:
		t.insert("end",s)
	
	t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3963:putStatusLine
#@+node:EKR.20040424154804:setFocusStatusLine
def setFocusStatusLine (self):
	
	t = self.statusText
	if t:
		t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocusStatusLine
#@+node:ekr.20031218072017.1733:updateStatusRowCol
def updateStatusRowCol (self):
	
	c = self.c ; body = self.bodyCtrl ; lab = self.statusLabel
	gui = g.app.gui
	if not lab: return
	
	# New for Python 2.3: may be called during shutdown.
	if g.app.killed:
		return

	if 0: # New code
		index = c.frame.body.getInsertionPoint()
		row,col = c.frame.body.indexToRowColumn(index)
		index1 = c.frame.body.rowColumnToIndex(row,0)
	else:
		index = body.index("insert")
		row,col = gui.getindex(body,index)
	
	if col > 0:
		if 0: # new code
			s = c.frame.body.getRange(index1,index2)
		else:
			s = body.get("%d.0" % (row),index)
		s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03
		col = g.computeWidth (s,self.tab_width)

	if row != self.lastStatusRow or col != self.lastStatusCol:
		s = "line %d, col %d " % (row,col)
		lab.configure(text=s)
		self.lastStatusRow = row
		self.lastStatusCol = col
		
	# Reschedule this routine 100 ms. later.
	# Don't use after_idle: it hangs Leo.
	self.statusFrame.after(100,self.updateStatusRowCol)
#@nonl
#@-node:ekr.20031218072017.1733:updateStatusRowCol
#@-node:ekr.20031218072017.3960:Creating the status area
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event):
	
	"""Handle any key press event in the body pane."""

	c = self.c ; ch = event.char 
	oldSel = c.frame.body.getTextSelection()
	
	p = c.currentPosition()

	# g.trace(repr(ch))

	if 0: # won't work when menu keys are bound.
		self.handleStatusLineKey(event)
		
	# g.trace(p)
		
	# We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
	self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)

#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
	
	c = self.c ; frame = c.frame
	ch = event.char ; keysym = event.keysym
	keycode = event.keycode ; state = event.state

	if 1: # ch and len(ch)>0:
		<< trace the key event >>

	try:
		status = self.keyStatus
	except:
		status = [] ; frame.clearStatusLine()
	
	for sym,name in (
		("Alt_L","Alt"),("Alt_R","Alt"),
		("Control_L","Control"),("Control_R","Control"),
		("Escape","Esc"),
		("Shift_L","Shift"), ("Shift_R","Shift")):
		if keysym == sym:
			if name not in status:
				status.append(name)
				frame.putStatusLine(name + ' ')
			break
	else:
		status = [] ; frame.clearStatusLine()

	self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
	self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
	
	t = self.bodyCtrl
	
	# Event handlers...
	t.bind("<Button-1>", frame.OnBodyClick)
	t.bind("<Button-3>", frame.OnBodyRClick)
	t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
	t.bind("<Key>", frame.body.onBodyKey)

	# Gui-dependent commands...
	t.bind(g.virtual_event_name("Cut"), frame.OnCut)
	t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
	t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@+node:ekr.20031218072017.1723:createMenuEntries
@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=false,dontBind=false):
	
	for label,accel,command in table:
		if label == None or command == None or label == "-":
			self.add_separator(menu)
		else:
			<< set name to the label for doCommand >>
			<< set accel to the shortcut for name >>
			<< set bind_shortcut and menu_shortcut using accel >>
			<< define callback function >>
			<< set realLabel, amp_index and menu_shortcut >>
	
			self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
				command=callback,underline=amp_index)
				
			if 0: # testing
				dontBind = true

			if bind_shortcut and not dontBind:
				<< handle bind_shorcut >>
#@nonl
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
	if ch in string.ascii_letters or ch in string.digits:
		name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
config = g.app.config
rawKey,accel2 = config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
	pass # Use default shortcut, if any.
elif accel2.lower() == "none":
	accel = None # Remove the default shortcut.
else:
	accel = accel2 # Override the default shortcut.
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
	if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
		bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
	callback = self.defineOpenWithMenuCallback(command)
else:
	callback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# 2/8/04: A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.
if rawKey and rawKey != label:
	amp_index = rawKey.find("&") + 1
else:
	amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
	if realLabel.lower().startswith("sort"):
		g.trace(label,realLabel,rawKey,bind_shortcut)

if not menu_shortcut:
	menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@+node:ekr.20031218072017.1729:<< handle bind_shorcut >>
if bind_shortcut in self.menuShortcuts:
	if not g.app.menuWarningsGiven:
		g.es("duplicate shortcut:", accel, bind_shortcut, label,color="red")
		print "duplicate shortcut:", accel, bind_shortcut, label
else:
	self.menuShortcuts.append(bind_shortcut)
	try:
		self.frame.body.bind(bind_shortcut,callback)
		self.bind(bind_shortcut,callback)
	except: # could be a user error
		if not g.app.menuWarningsGiven:
			print "exception binding menu shortcut..."
			print bind_shortcut
			g.es_exception()
			g.app.menuWarningsGive = true
#@nonl
#@-node:ekr.20031218072017.1729:<< handle bind_shorcut >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.2177:<< create the toplevel frame >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

frame.top.bind("<Activate>", frame.OnActivateLeoEvent) # Doesn't work on windows.
frame.top.bind("<Deactivate>", frame.OnDeactivateLeoEvent) # Doesn't work on windows.

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel frame >>
#@-node:ekr.20040105210752:(Keystrokes)
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20031218072017.1342:atFile.scanAllDirectives (calls writeError on errors)
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node v, no @color or @nocolor directives are examined in any ancestor of v.

This code is similar to Commands::scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,v):
	
	"""Scan vnode v and v's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.commands
	<< Set ivars >>
	<< Set path from @file node >>
	old = {}
	while v:
		s = v.t.bodyString
		dict = get_directives_dict(s)
		<< Test for @path >>
		<< Test for @encoding >>
		<< Test for @comment and @language >>
		<< Test for @header and @noheader >>
		<< Test for @lineending >>
		<< Test for @pagewidth >>
		<< Test for @tabwidth >>
		old.update(dict)
		v = v.parent()
	<< Set current directory >>
	<< Set comment Strings from delims >>
#@nonl
#@+node:ekr.20031218072017.1343:<< Set ivars >>
self.page_width = self.commands.page_width
self.tab_width  = self.commands.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = app().config.default_derived_file_encoding
self.output_newline = getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1343:<< Set ivars >>
#@+node:ekr.20031218072017.1344:<< Set path from @file node >>
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

# Bug fix: 10/16/02
if v.isAtFileNode():
	name = v.atFileNodeName()
elif v.isAtRawFileNode():
	name = v.atRawFileNodeName()
elif v.isAtNoSentinelsFileNode():
	name = v.atNoSentinelsFileNodeName()
else:
	name = ""

dir = choose(name,os.path.dirname(name),None)
if dir and len(dir) > 0 and os.path.isabs(dir):
	if os.path.exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
			
#@-node:ekr.20031218072017.1344:<< Set path from @file node >>
#@+node:ekr.20031218072017.1345:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1345:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1346:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e
#@nonl
#@-node:ekr.20031218072017.1346:<< Test for @encoding >>
#@+node:ekr.20031218072017.1347:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20031218072017.1347:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1348:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
#@-node:ekr.20031218072017.1348:<< Test for @lineending >>
#@+node:ekr.20031218072017.1349:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

loadDir = app().loadDir

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute relative path from s[k:] >>
	if path and len(path) > 0:
		base = getBaseDirectory() # returns "" on error.
		path = os.path.join(base,path)
		if os.path.isabs(path):
			<< handle absolute path >>
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20031218072017.1350:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = os.path.join(loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1350:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.1351:<< handle absolute path >>
# path is an absolute path.

if os.path.exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
#@-node:ekr.20031218072017.1351:<< handle absolute path >>
#@-node:ekr.20031218072017.1349:<< Test for @path >>
#@+node:ekr.20031218072017.1352:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = scanAtPagewidthDirective(s,dict,issue_error_flag=true)
	if w and w > 0:
		self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1352:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1353:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = scanAtTabwidthDirective(s,dict,issue_error_flag=true)
	if w and w != 0:
		self.tab_width = w

#@-node:ekr.20031218072017.1353:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1354:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) > 0:
			dir = os.path.join(base,dir)
			if os.path.isabs(dir): # Errors may result in relative or invalid path.
				if os.path.exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = makeAllNonExistentDirectories(dir)

if not self.default_directory:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""
#@nonl
#@-node:ekr.20031218072017.1354:<< Set current directory >>
#@+node:ekr.20031218072017.1355:<< Set comment Strings from delims >>
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	es("Unknown language: using Python comment delimiters")
	es("c.target_language:"+`c.target_language`)
	es("delim1,delim2,delim3:" + `delim1`+":"+`delim2`+":"+`delim3`)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""
#@nonl
#@-node:ekr.20031218072017.1355:<< Set comment Strings from delims >>
#@-node:ekr.20031218072017.1342:atFile.scanAllDirectives (calls writeError on errors)
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

	c = self.c
	<< init tangle ivars >>
	<< init untangle ivars >>
	
# Called by scanAllDirectives

def init_directive_ivars (self):

	c = self.c
	<< init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = true # true if tangling, false if untangling.
self.path_warning_given = false # true: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
	self.file_name = c.mFileName # The file name (was a bridge function)
else:
	self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
	self.head_root = None
	self.code = None
	self.doc = None
	self.header_name = None
	self.header = None
	self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = false # true if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline()
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
	self.allow_rich_text = default_allow_rich_text
	self.extended_noweb_flag = default_extended_noweb_flag
	self.target_language = default_target_language # uses c.target_lanuage instead
	
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
	self.use_cweb_flag = false
	self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
	self.use_cweb_flag = self.language == "cweb"
	self.raw_cweb_flag = false # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = g.app.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
	
	"""Scan vnode p and p's ancestors looking for directives,
	setting corresponding tangle ivars and globals.
	"""

	c = self.c
	# g.trace(p)
	old = {} ; print_mode_changed = false
	self.init_directive_ivars()
	if p:
		s = p.bodyString()
		<< Collect @first attributes >>
	for p in p.self_and_parents_iter():
		s = p.bodyString()
		dict = g.get_directives_dict(s)
		# g.trace("dict:",dict,p)
		<< Test for @comment and @language >>
		<< Test for @encoding >>
		<< Test for @lineending >>
		<< Test for print modes directives >>
		<< Test for @path >>
		<< Test for @pagewidth >>
		<< Test for @root >>
		<< Test for @tabwidth >>
		<< Test for @header and @noheader >>
		old.update(dict)
	<< Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
	# DTHEIN 13-OCT-2002: directives must start at beginning of a line
	if not g.match_word(s,i,tag):
		i = g.skip_line(s,i)
	else:
		i = i + len(tag)
		j = i = g.skip_ws(s,i)
		i = g.skip_to_end_of_line(s,i)
		if i>j:
			self.first_lines += s[j:i] + '\n'
		i = g.skip_nl(s,i)
	if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
		break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
	 pass # Do nothing more.

elif dict.has_key("comment"):

	i = dict["comment"]
	delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
	if delim1 or delim2:
		self.single_comment_string = delim1
		self.start_comment_string = delim2
		self.end_comment_string = delim3
		# @comment effectively disables Untangle.
		self.language = "unknown"
	else:
		if issue_error_flag:
			g.es("ignoring: " + s[i:])

elif dict.has_key("language"):

	i = dict["language"]
	language,delim1,delim2,delim3 = g.set_language(s,i)
	self.language = language
	self.single_comment_string = delim1
	self.start_comment_string = delim2
	self.end_comment_string = delim3
	if 0:
		g.trace(self.single_comment_string,
			self.start_comment_string,
			self.end_comment_string)

	# 10/30/02: These ivars must be updated here!
	# g.trace(self.language)
	self.use_noweb_flag = true
	self.use_cweb_flag = false # Only raw cweb mode is ever used.
	self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = g.scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = g.scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
	for name in ("verbose","terse","quiet","silent"):
		if dict.has_key(name):
			self.print_mode = name
			print_mode_changed = true
			break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute dir and relative_path from s[k:] >>
	if len(dir) > 0:
		base = g.getBaseDirectory() # May return "".
		if dir and len(dir) > 0:
			dir = g.os_path_join(base,dir)
			if g.os_path_isabs(dir):
				<< handle absolute @path >>
			elif issue_error_flag and not self.path_warning_given:
				self.path_warning_given = true # supress future warnings
				self.error("ignoring relative path in @path:" + dir)
	elif issue_error_flag and not self.path_warning_given:
		self.path_warning_given = true # supress future warnings
		self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

dir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	dir = g.os_path_join(g.app.loadDir,dir)

# g.trace("dir: " + dir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(dir):
	self.tangle_directory = dir
else: # 11/19/02
	self.tangle_directory = g.makeAllNonExistentDirectories(dir)
	if not self.tangle_directory:
		if issue_error_flag and not self.path_warning_given:
			self.path_warning_given = true # supress future warnings
			self.error("@path directory does not exist: " + dir)
			if base and len(base) > 0:
				g.es("relative_path_base_directory: " + base)
			if relative_path and len(relative_path) > 0:
				g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and dict.has_key("pagewidth"):
	
	w = g.scanAtPagewidthDirective(s,dict,issue_error_flag)
	if w and w > 0:
		self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and dict.has_key("root"):

	i = dict["root"]
	# i += len("@root")
	self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and dict.has_key("tabwidth"):
	
	w = g.scanAtTabwidthDirective(s,dict,issue_error_flag)
	if w and w != 0:
		self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
	pass # Do nothing more.
	
elif dict.has_key("header") and dict.has_key("noheader"):
	if issue_error_flag:
		g.es("conflicting @header and @noheader directives")

elif dict.has_key("header"):
	self.use_header_flag = true

elif dict.has_key("noheader"):
	self.use_header_flag = false
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
	if self.root_name and len(self.root_name) > 0:
		root_dir = g.os_path_dirname(self.root_name)
	else:
		root_dir = None
	# print "root_dir:", root_dir

	table = ( # This is a precedence table.
		(root_dir,"@root"), 
		(c.tangle_directory,"default tangle"), # Probably should be eliminated.
		(c.frame.openDirectory,"open"))

	base = g.getBaseDirectory() # May return "".

	for dir2, kind in table:
		if dir2 and len(dir2) > 0:
			# print "base,dir:",base,dir
			dir = g.os_path_join(base,dir2)
			if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
				<< handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
	self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(dir):
	if kind == "@root" and not g.os_path_isabs(root_dir):
		self.tangle_directory = base
	else:
		self.tangle_directory = dir 
	break
else: # 9/25/02
	self.tangle_directory = g.makeAllNonExistentDirectories(dir)
	if not self.tangle_directory:
		# 10/27/02: It is an error for this not to exist now.
		self.error("@root directory does not exist:" + dir)
		if base and len(base) > 0:
			g.es("relative_path_base_directory: " + base)
		if dir2 and len(dir2) > 0:
			g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):
	
	c = self.c ; w = c.tab_width
	
	for p in p.self_and_parents_iter():
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< set w and break on @tabwidth >>

	c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if dict.has_key("tabwidth"):
	
	val = g.scanAtTabwidthDirective(s,dict,issue_error_flag=false)
	if val and val != 0:
		w = val
		break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
	
	"""Scan position p and p's ancestors looking for @color and @nocolor directives,
	setting corresponding colorizer ivars.
	"""

	p = p.copy() ; c = self.c
	if c == None: return # self.c may be None for testing.

	language = c.target_language
	self.language = language # 2/2/03
	self.comment_string = None
	self.rootMode = None # None, "code" or "doc"
	
	for p in p.self_and_parents_iter():
		# g.trace(p)
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< Test for @comment or @language >>
		<< Test for @root, @root-doc or @root-code >>

	return self.language # For use by external routines.
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if dict.has_key("comment"):
	k = dict["comment"]
	self.comment_string = s[k:]

if dict.has_key("language"):
	i = dict["language"]
	language,junk,junk,junk = g.set_language(s,i)
	self.language = language # 2/2/03

if dict.has_key("comment") or dict.has_key("language"):
	break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if dict.has_key("root") and not self.rootMode:

	k = dict["root"]
	if g.match_word(s,k,"@root-code"):
		self.rootMode = "code"
	elif g.match_word(s,k,"@root-doc"):
		self.rootMode = "doc"
	else:
		doc = g.app.config.at_root_bodies_start_in_doc_mode
		self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

	val = app.language_delims_dict.get(language)
	if val:
		delim1,delim2,delim3 = g.set_delims_from_string(val)
		if delim2 and not delim3:
			return None,delim1,delim2
		else: # 0,1 or 3 params.
			return delim1,delim2,delim3
	else:
		return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

	"""Returns (delim1, delim2, delim2), the delims following the @comment directive.
	
	This code can be called from @languge logic, in which case s can point at @comment"""

	# Skip an optional @comment
	tag = "@comment"
	i = 0
	if g.match_word(s,i,tag):
		i += len(tag)
		
	count = 0 ; delims = [None, None, None]
	while count < 3 and i < len(s):
		i = j = g.skip_ws(s,i)
		while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
			i += 1
		if j == i: break
		delims[count] = s[j:i]
		count += 1
		
	# 'rr 09/25/02
	if count == 2: # delims[0] is always the single-line delim.
		delims[2] = delims[1]
		delims[1] = delims[0]
		delims[0] = None

	# 7/8/02: The "REM hack": replace underscores by blanks.
	# 9/25/02: The "perlpod hack": replace double underscores by newlines.
	for i in xrange(0,3):
		if delims[i]:
			delims[i] = string.replace(delims[i],"__",'\n') 
			delims[i] = string.replace(delims[i],'_',' ')

	return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=false):
	
	"""Scan the @language directive that appears at s[i:].

	Returns (language, delim1, delim2, delim3)
	"""

	tag = "@language"
	# g.trace(g.get_line(s,i))
	assert(i != None)
	assert(g.match_word(s,i,tag))
	i += len(tag) ; i = g.skip_ws(s, i)
	# Get the argument.
	j = i ; i = g.skip_c_id(s,i)
	# Allow tcl/tk.
	arg = string.lower(s[j:i])
	if app.language_delims_dict.get(arg):
		language = arg
		delim1, delim2, delim3 = g.set_delims_from_language(language)
		return language, delim1, delim2, delim3
	
	if issue_errors_flag:
		g.es("ignoring: " + g.get_line(s,i))

	return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

	for p in root.subtree_iter():
		assert(p!=root)
		if p.matchHeadline(name) and not p.isAtIgnoreNode():
			return p

	# g.trace("not found:",name,root)
	return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
	
	"""Scans root for @directives found in globalDirectivesList.

	Returns a dict containing pointers to the start of each directive"""

	if root: root_node = root[0]
	dict = {}
	i = 0 ; n = len(s)
	while i < n:
		if s[i] == '@' and i+1 < n:
			<< set dict for @ directives >>
		elif root and g.match(s,i,"<<"):
			<< set dict["root"] for noweb * chunks >>
		i = g.skip_line(s,i)
	return dict
#@nonl
#@+node:ekr.20031218072017.1261:<< set dict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
	dict [word] = i
#@-node:ekr.20031218072017.1261:<< set dict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
	i = g.skip_ws(s,i+1) # Skip the '*'
	if g.match(s,i,">>="):
		# < < * > > = implies that @root should appear in the headline.
		i += 3
		if root_node:
			dict["root"]=0 # value not immportant
		else:
			g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set dict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (lineending = None):
	
	"""Convert the name of a line ending to the line ending itself.
	Use the output_newline configuration option if no lineending is given.
	"""
	
	if lineending:
		s = lineending
	else:
		s = app.config.output_newline

	s = s.lower()
	if s in ( "nl","lf"): s = '\n'
	elif s == "cr": s = '\r'
	elif s == "platform": s = os.linesep  # 12/2/03: emakital
	elif s == "crlf": s = "\r\n"
	else: s = '\n' # Default for erroneous values.
	return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,dict):
	
	"""Scan the @encoding directive at s[dict["encoding"]:].

	Returns the encoding name or None if the encoding name is invalid.
	"""

	k = dict["encoding"]
	i = g.skip_to_end_of_line(s,k)
	j = len("@encoding")
	encoding = s[k+j:i].strip()
	if g.isValidEncoding(encoding):
		# g.trace(encoding)
		return encoding
	else:
		g.es("invalid @encoding:"+encoding,color="red")
		return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,dict):
	
	"""Scan the @lineending directive at s[dict["lineending"]:].

	Returns the actual lineending or None if the name of the lineending is invalid.
	"""

	k = dict["lineending"]
	i = g.skip_to_end_of_line(s,k)
	j = len("@lineending")
	j = g.skip_ws(s,j)
	e = s[k+j:i].strip()

	if e in ("cr","crlf","lf","nl","platform"):
		lineending = g.getOutputNewline(e)
		# g.trace(e,lineending)
		return lineending
	else:
		# g.es("invalid @lineending directive:"+e,color="red")
		return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,dict,issue_error_flag=false):
	
	"""Scan the @pagewidth directive at s[dict["pagewidth"]:].

	Returns the value of the width or None if the width is invalid.
	"""
	
	k = dict["pagewidth"]
	j = i = k + len("@pagewidth")
	i, val = g.skip_long(s,i)
	if val != None and val > 0:
		# g.trace(val)
		return val
	else:
		if issue_error_flag:
			j = g.skip_to_end_of_line(s,k)
			g.es("ignoring " + s[k:j],color="red")
		return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,dict,issue_error_flag=false):
	
	"""Scan the @tabwidth directive at s[dict["tabwidth"]:].

	Returns the value of the width or None if the width is invalid.
	"""
	
	k = dict["tabwidth"]
	i = k + len("@tabwidth")
	i, val = g.skip_long(s, i)
	if val != None and val != 0:
		# g.trace(val)
		return val
	else:
		if issue_error_flag:
			i = g.skip_to_end_of_line(s,k)
			g.es("Ignoring " + s[k:i],color="red")
		return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
	
	"""Scan vnode v and v's ancestors looking for directives.

	Returns a dict containing the results, including defaults."""

	if c == None or g.top() == None:
		return {} # For unit tests.
	if p is None:
		p = c.currentPosition()

	<< Set local vars >>
	old = {}
	pluginsList = [] # 5/17/03: a list of items for use by plugins.
	for p in p.self_and_parents_iter():
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< Test for @comment and @language >>
		<< Test for @encoding >>
		<< Test for @lineending >>
		<< Test for @pagewidth >>
		<< Test for @path >>
		<< Test for @tabwidth >>
		<< Test for @wrap and @nowrap >>
		g.doHook("scan-directives",c=c,v=p,s=s,
			old_dict=old,dict=dict,pluginsList=pluginsList)
		old.update(dict)

	if path == None: path = g.getBaseDirectory()

	return {
		"delims"    : (delim1,delim2,delim3),
		"encoding"  : encoding,
		"language"  : language,
		"lineending": lineending,
		"pagewidth" : page_width,
		"path"      : path,
		"tabwidth"  : tab_width,
		"pluginsList": pluginsList,
		"wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = g.scanAtEncodingDirective(s,dict)
	if e:
		encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	e = g.scanAtLineendingDirective(s,dict)
	if e:
		lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = g.scanAtPagewidthDirective(s,dict)
	if w and w > 0:
		page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute relative path from s[k:] >>
	if path and len(path) > 0:
		base = g.getBaseDirectory() # returns "" on error.
		path = g.os_path_join(base,path)
		
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = g.scanAtTabwidthDirective(s,dict)
	if w and w > 0:
		tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
	
	if dict.has_key("wrap"):
		wrap = true
	elif dict.has_key("nowrap"):
		wrap = false
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20031218072017.1655:(Support for LeoN)
@nocolor

- (done) Created runMainLoop function in leo.py so the call to mainloop() is in a separate function.

- (done) Added flush method to redirect class in leoGlobals.py

@color
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
# To redirect stdout a class only needs to implement a write(self,s) method.
def __init__ (self):
	self.old = None
	
def isRedirected (self):
	return self.old != None
	
def flush(self, *args):
	return # 6/14/03:  For LeoN: just for compatibility.

def redirect (self,stdout=1):
	import sys
	if not self.old:
		if stdout:
			self.old,sys.stdout = sys.stdout,self
		else:
			self.old,sys.stderr = sys.stderr,self

def undirect (self,stdout=1):
	import sys
	if self.old:
		if stdout:
			sys.stdout,self.old = self.old,None
		else:
			sys.stderr,self.old = self.old,None

def write(self,s):
	# g.trace(s)
	if self.old:
		if app.log: app.log.put(s)
		else: self.old.write(s)
	else: print s # Typically will not happen.
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.1657:runMainLoop
def runMainLoop(root):
	
	"""A function that runs root.mainloop()
	
	LeoN may replace this fuction entirely."""
	
	root.mainloop()
#@-node:ekr.20031218072017.1657:runMainLoop
#@-node:ekr.20031218072017.1655:(Support for LeoN)
#@+node:ekr.20031218072017.984:Unfinished projects
#@+node:ekr.20031218072017.985:(Button class)
@ignore
@color
#@nonl
#@+node:ekr.20031218072017.986:Notes to Edward
@nocolor

I have a base window class that I use for all my TK stuff which handles, especially, focus issues between windows.  I have not looked at ButtonQ to see to what extent it depends upon WindowQ, the base class.

Anyway, this might be usefull as-is.  If not, let me know.
#@nonl
#@-node:ekr.20031218072017.986:Notes to Edward
#@+node:ekr.20031218072017.987:@file ButtonQ.py
@ Setup a button so it is handled with a keyboard shortcut like MSWindows tools.  See if there is an ampersand in the string.  If so, we want to underline that character and make that character a hot key for this button.
@c

from Tkinter import *
from string import *

def ButtonQ (master, **kw):
	b = ButtonQ_ (master, kw)
	return b.button

class ButtonQ_ (Button):
@others

## test
"""
from tkMessageBox import *
def buttonqcommand ():
	showinfo ("Title", "Button was pushed")

root = Tk ()
frame = Frame (root)
b = ButtonQ (frame, text = "&Push Me", command = buttonqcommand)
b.grid ()
frame.grid (pady = 15)
"""
#@+node:ekr.20031218072017.988:__init__
def __init__(self, master, kw = {}):

	<< get inputs to this method >>
	<< see if there is an ampersand in the string. >>
	<< make the button with the correct text >>
	<< bind the button >>

	# make the button available to the caller
	self.button = b
#@nonl
#@+node:ekr.20031218072017.989:<< get inputs to this method >>
_master = master
_text = kw['text']
_command = kw['command']
#@-node:ekr.20031218072017.989:<< get inputs to this method >>
#@+node:ekr.20031218072017.990:<< see if there is an ampersand in the string. >>
length = len (_text)
index = 0
text3 = _text

# Show there is no hot key yet
IsHot = 0
HotKey = None

while index < length:
	if _text [index] == '&':
		<< handle an ampersand >>
	index = += 1
#@nonl
#@+node:ekr.20031218072017.991:<< handle an ampersand >>
# if the word ends in an ampersand, we ignore it, and there is no hot key
if index == length - 1:
	break

# we have found a good hot key.  Remove the ampersand.
text1 = _text [0 : index]
text2 = _text [(index + 1) : 10000]
text3 = text1 + text2
IsHot = 1
HotKey = _text [index + 1]
break
#@nonl
#@-node:ekr.20031218072017.991:<< handle an ampersand >>
#@-node:ekr.20031218072017.990:<< see if there is an ampersand in the string. >>
#@+node:ekr.20031218072017.992:<< make the button with the correct text >>
if IsHot:
	kw['text'] = text3
	kw['underline'] = index

b = Button (master, kw)
#@-node:ekr.20031218072017.992:<< make the button with the correct text >>
#@+node:ekr.20031218072017.993:<< bind the button >>
@ If there is a hot key, bind it to the window that owns the button.
Use the alt of both the lower case and upper case of the letter.
@c

if IsHot:
	HotKey = lower(HotKey)
	self.HotKey = HotKey
	s = angleBrackets("Alt-" + HotKey + s)
	_master.master.bind (s, self.callback)

	HotKey = upper(HotKey)
	s = angleBrackets("Alt-" + HotKey + s)
	_master.master.bind (s, self.callback)


#@-node:ekr.20031218072017.993:<< bind the button >>
#@-node:ekr.20031218072017.988:__init__
#@+node:ekr.20031218072017.994:callback
# The hot key has been hit.  Call the button's command.

def callback (self, event):

	self.button.invoke ()
#@-node:ekr.20031218072017.994:callback
#@-node:ekr.20031218072017.987:@file ButtonQ.py
#@-node:ekr.20031218072017.985:(Button class)
#@+node:ekr.20031218072017.995:(Incremental update of screen)
@ignore
@nocolor

To enable incremental allocation of Tk widgets during redraws, set self.allocateOnlyVisibleNodes = true in tree.__init__.

To do:
	
- We might switch to a line-oriented scheme.
	- This might simplify the code and make the code more useful to users.
	- Conceivably this scheme might eliminate the need for the auto-scroll in the redraw code,
	and that might make a single-pass redraw scheme possible.

- The last line isn't always completely visible: this is clearly a bug.

@color
#@nonl
#@+node:ekr.20031218072017.996:From Frame class
#@+node:ekr.20031218072017.997:<< create the tree canvas >>
scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
scrolls = choose(scrolls,1,0)

self.canvas = canvas = Tk.Canvas(split2Pane1,name="canvas",
	bd=0,bg="white",relief="flat")
	
self.setTreeColorsFromConfig()

self.treeBar = treeBar = Tk.Scrollbar(split2Pane1,name="treeBar")

# Bind mouse wheel event to canvas
if sys.platform != "win32": # Works on 98, crashes on XP.
	self.canvas.bind("<MouseWheel>", self.OnMouseWheel)
	
canvas['yscrollcommand'] = self.setCallback
treeBar['command']     = self.yviewCallback

treeBar.pack(side="right", fill="y")
if scrolls: 
	treeXBar = Tk.Scrollbar( 
		split2Pane1,name='treeXBar',orient="horizontal") 
	canvas['xscrollcommand'] = treeXBar.set 
	treeXBar['command'] = canvas.xview 
	treeXBar.pack(side="bottom", fill="x")

canvas.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20031218072017.997:<< create the tree canvas >>
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
	
	"""Callback to adjust the scrollbar.
	
	Args is a tuple of two floats describing the fraction of the visible area."""

	# g.trace(self.tree.redrawCount,args)

	apply(self.treeBar.set,args,keys)

	if self.tree.allocateOnlyVisibleNodes:
		self.tree.setVisibleArea(args)
		
def yviewCallback (self,*args,**keys):
	
	"""Tell the canvas to scroll"""
	
	# g.trace(vyiewCallback",args,keys)

	if self.tree.allocateOnlyVisibleNodes:
		self.tree.allocateNodesBeforeScrolling(args)

	apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20031218072017.996:From Frame class
#@+node:ekr.20031218072017.999:From Tree class
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):

	y += 7 # draw the box at x, y+7
	h = self.line_height

	tree = self
	iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y+self.lineyoffset,image=image)
	
	if 1: # New in 4.2.  Create a frame to catch all clicks.
		id4 = self.canvas.create_rectangle(0,y-7,1000,y-7+h-3)
		color = ""
		self.canvas.itemconfig(id4,fill=color,outline=color)
		self.canvas.lower(id4)
		id3 = self.canvas.tag_bind(id4, "<1>", p.OnBoxClick)
		self.tagBindings.append((id,id3,"<1>"),)

	id1 = self.canvas.tag_bind(id, "<1>", p.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
	
	"""Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

	tree = self
	
	# Make sure the bindings refer to the _present_ position.
	v = p.v

	if x is None and y is None:
		try:
			x,y = v.iconx, v.icony
		except:
			# Inject the ivars.
			x,y = v.iconx, v.icony = 0,0
	else:
		# Inject the ivars.
		v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute v.iconVal.
	# This is an important drawing optimization.
	val = v.iconVal = v.computeIcon()
	assert(0 <= val <= 15)

	# Get the image.
	imagename = "box%02d.GIF" % val
	image = self.getIconImage(imagename)
	id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image)
	self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.

	id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
	id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
	id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
	self.tagBindings.append((id,id3,"<3>"),)

	return 0,icon_width # dummy icon height,width
#@nonl
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

	"""Draw horizontal line from vertical line to icon"""
	
	if 1:
		self.lineyoffset = 0
	else:
		if hasattr(p.v.t,"unknownAttributes"):
			self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
		else:
			self.lineyoffset = 0
		
	self.canvas.create_line(x,y+7+self.lineyoffset,
		x+box_width,y+7+self.lineyoffset,
		tag="lines",fill="gray50") # stipple="gray25")

	if self.inVisibleArea(y):
		return self.force_draw_node(p,x,y)
	else:
		return self.line_height,0
#@nonl
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

	self.allocatedNodes += 1
	h,w = self.drawUserIcons(p,"beforeBox",x,y)
	xw = w # The extra indentation before the icon box.
	if p.hasChildren():
		self.drawBox(p,x+w,y)
	w += box_width # even if box isn't drawn.

	h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
	h = max(h,h2) ; w += w2 ; xw += w2

	h2,w2 = self.drawIcon(p,x+w,y)
	h = max(h,h2) ; w += w2

	h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
	h = max(h,h2) ; w += w2

	h2 = self.drawText(p,x+w,y)
	h = max(h,h2)
	w += self.widthInPixels(p.headString())

	h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
	h = max(h,h2)

	return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040318090335:force_draw_node (old)
def force_draw_nodeOLD(self,p,x,y):

	self.allocatedNodes += 1

	if p.hasChildren():
		self.drawBox(p,x,y)
	w = box_width # Even if the box isn't drawn.

	h2,w2 = self.drawIcon(p,x+w,y)
	w += w2

	h = self.drawText(p,x+w,y)
	
	return h,0
#@-node:ekr.20040318090335:force_draw_node (old)
#@-node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
	
	if self.allocateOnlyVisibleNodes:
		if self.visibleArea:
			vis1,vis2 = self.visibleArea
			y2 = y1 + self.line_height
			return y2 >= vis1 and y1 <= vis2
		else: return false
	else:
		return true # This forces all nodes to be allocated on all redraws.
		
def inExpandedVisibleArea (self,y1):
	
	if self.expandedVisibleArea:
		vis1,vis2 = self.expandedVisibleArea
		y2 = y1 + self.line_height
		return y2 >= vis1 and y1 <= vis2
	else:
		return false
#@nonl
#@-node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20031218072017.1011:Updating routines (tree)...
#@+node:ekr.20031218072017.1012:tree.redraw
# Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
	
	# g.trace(self.updateCount,self.redrawScheduled)
	
	if self.updateCount == 0 and not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
#@nonl
#@-node:ekr.20031218072017.1012:tree.redraw
#@+node:ekr.20040106095546:tkTree.redrawAfterException
@ This is called only from doCommand.  The implicit assumption is that doCommand itself is not contained in a beginUpdate/endUpdate pair.
@c

def redrawAfterException (self):
	
	"""Make sure drawing is enabled following an exception."""
		
	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		self.updateCount = 0 # would not work if we are in a beginUpdate/endUpdate pair.
#@nonl
#@-node:ekr.20040106095546:tkTree.redrawAfterException
#@+node:ekr.20031218072017.1013:force_redraw
# Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
	
	# g.trace(self.redrawScheduled)
	# import traceback ; traceback.print_stack()

	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
#@nonl
#@-node:ekr.20031218072017.1013:force_redraw
#@+node:ekr.20031218072017.1014:redraw_now
# Redraws immediately: used by Find so a redraw doesn't mess up selections.
# It is up to the caller to ensure that no other redraws are pending.

def redraw_now (self,scroll=true):
	
	# g.trace()

	self.idle_redraw(scroll=scroll)
#@-node:ekr.20031218072017.1014:redraw_now
#@+node:ekr.20031218072017.1015:idle_redraw
def idle_redraw (self,scroll=true):
	
	c = self.c ; frame = c.frame

	self.redrawScheduled = false # Always do this here.

	<< return if disabled, or quitting or dragging >>

	# g.print_bindings("canvas",self.canvas)

	self.expandAllAncestors(c.currentPosition())

	oldcursor = self.canvas['cursor']
	self.canvas['cursor'] = "watch"

	if not g.doHook("redraw-entire-outline",c=self.c):
		self.allocatedNodes = 0
		<< Erase and redraw the entire tree >>
		if self.trace:
			self.redrawCount += 1
			print "idle_redraw allocated:",self.redrawCount,self.allocatedNodes
	g.doHook("after-redraw-outline",c=self.c)

	self.canvas['cursor'] = oldcursor
#@+node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
if self.disableRedraw:
	# We have been called as the result of an update_idletasks in the log pane.
	# Don't do anything now.
	return

if frame not in g.app.windowList or g.app.quitting:
	# g.trace("no frame")
	return

if self.drag_p:
	# g.trace("dragging",self.drag_p)
	return
#@-node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
#@+node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
# Delete all widgets.
c.setTopVnode(None)
self.deleteBindings()
self.canvas.delete("all")
self.deleteWidgets()

# Redraw the tree.
self.setVisibleAreaToFullCanvas()
self.drawTopTree()

# Set up the scroll region after the tree has been redrawn.
x0, y0, x1, y1 = self.canvas.bbox("all")
self.canvas.configure(scrollregion=(0, 0, x1, y1))

# g.printGc()

# Do a scrolling operation after the scrollbar is redrawn
if scroll:
	self.canvas.after_idle(self.idle_scrollTo)
#@nonl
#@-node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
#@-node:ekr.20031218072017.1015:idle_redraw
#@+node:ekr.20031218072017.1016:idle_second_redraw
def idle_second_redraw (self):
	
	c = self.c
	
	g.trace()
		
	# Erase and redraw the entire tree the SECOND time.
	# This ensures that all visible nodes are allocated.
	c.setTopVnode(None)
	args = self.canvas.yview()
	self.setVisibleArea(args)
	self.deleteBindings()
	self.canvas.delete("all")
	self.drawTopTree()
	
	if self.trace:
		print "idle_second_redraw allocated:",self.redrawCount, self.allocatedNodes
#@nonl
#@-node:ekr.20031218072017.1016:idle_second_redraw
#@-node:ekr.20031218072017.1011:Updating routines (tree)...
#@+node:ekr.20031218072017.1017:tree.__init__
def __init__(self,c,frame,canvas):
	
	# Init the base class.
	leoFrame.leoTree.__init__(self,frame)

	# Objects associated with this tree.
	self.canvas = canvas

	# Miscellaneous info.
	self.iconimages = {} # Image cache set by getIconImage().
	self.active = false # true if tree is active
	self._editPosition = None
	self.lineyoffset = 0 # y offset for this headline.
	self.disableRedraw = false # True: reschedule a redraw for later.
	
	# Set self.font and self.fontName.
	self.setFontFromConfig()
	
	# Recycling bindings.
	self.bindings = [] # List of bindings to be unbound when redrawing.
	self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
	self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
	self.widgets = [] # Widgets that must be destroyed when redrawing.
	
	# Drag and drop
	self.drag_p = None
	self.controlDrag = false # true: control was down when drag started.
	self.drag_id = None # To reset bindings after drag
	
	# 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
	#                     behavior better on Linux
	# Context menu
	self.popupMenu = None
	
	# Incremental redraws:
	self.allocateOnlyVisibleNodes = false # true: enable incremental redraws.
	self.trace = false # true enabling of various traces.
	self.prevMoveToFrac = None
	self.visibleArea = None
	self.expandedVisibleArea = None
	
	self.allocatedNodes = 0 # A crucial statistic.
		# Incremental drawing allocates visible nodes at most twice.
		# Non-incremetal drawing allocates all visible nodes once.
		
	if self.allocateOnlyVisibleNodes:
		self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw)
	
	if not leoTkinterTree.callbacksInjected: # Class var.
		leoTkinterTree.callbacksInjected = true
		self.injectCallbacks()
#@nonl
#@-node:ekr.20031218072017.1017:tree.__init__
#@+node:ekr.20031218072017.1018:tree.idle_scrollTo
def idle_scrollTo(self,p=None):

	"""Scrolls the canvas so that v is in view.
	
	This is done at idle time after a redraw so that treeBar.get() will return proper values."""

	c = self.c ; frame = c.frame
	if not p: p = self.c.currentPosition()
	if not p: p = self.c.rootPosition() # 4/8/04.
	try:
		last = p.lastVisible()
		nextToLast = last.visBack()
		h1 = self.yoffset(p)
		h2 = self.yoffset(last)
		<< compute approximate line height >>
		<< Compute the fractions to scroll down/up >>
		if frac <= lo:
			if self.prevMoveToFrac != frac:
				self.prevMoveToFrac = frac
				self.canvas.yview("moveto",frac)
		elif frac2 + (hi - lo) >= hi:
			if self.prevMoveToFrac != frac2:
				self.prevMoveToFrac = frac2
				self.canvas.yview("moveto",frac2)

		if self.allocateOnlyVisibleNodes:
			self.canvas.after_idle(self.idle_second_redraw)
			
		c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
		# print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
	except:
		g.es_exception()
#@nonl
#@+node:ekr.20040314092716:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
	lineHeight = h2 - self.yoffset(nextToLast)
else:
	lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040314092716:<< compute approximate line height >>
#@+node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
	frac = float(h1)/float(h2) # For scrolling down.
	frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
	frac2 = frac2 - (hi - lo)
else:
	frac = frac2 = 0.0 # probably any value would work here.
	
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20031218072017.1018:tree.idle_scrollTo
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@-node:ekr.20031218072017.999:From Tree class
#@+node:ekr.20031218072017.1026:Used only for incremental redraws
#@+node:ekr.20031218072017.1027:allocateNodes
def allocateNodes(self,where,lines):
	
	"""Allocate Tk widgets in nodes that will become visible as the result of an upcoming scroll"""
	
	assert(where in ("above","below"))

	# print "allocateNodes: %d lines %s visible area" % (lines,where)
	
	# Expand the visible area: a little extra delta is safer.
	delta = lines * (self.line_height + 4)
	y1,y2 = self.visibleArea

	if where == "below":
		y2 += delta
	else:
		y1 = max(0.0,y1-delta)

	self.expandedVisibleArea=y1,y2
	# print "expandedArea:   %5.1f %5.1f" % (y1,y2)
	
	# Allocate all nodes in expanded visible area.
	self.updatedNodeCount = 0
	self.updateTree(self.c.rootPosition(),root_left,root_top,0,0)
	# if self.updatedNodeCount: print "updatedNodeCount:", self.updatedNodeCount
#@-node:ekr.20031218072017.1027:allocateNodes
#@+node:ekr.20031218072017.1028:allocateNodesBeforeScrolling
def allocateNodesBeforeScrolling (self, args):
	
	"""Calculate the nodes that will become visible as the result of an upcoming scroll.

	args is the tuple passed to the Tk.Canvas.yview method"""

	if not self.allocateOnlyVisibleNodes: return

	# print "allocateNodesBeforeScrolling:",self.redrawCount,args

	assert(self.visibleArea)
	assert(len(args)==2 or len(args)==3)
	kind = args[0] ; n = args[1]
	lines = 2 # Update by 2 lines to account for rounding.
	if len(args) == 2:
		assert(kind=="moveto")
		frac1,frac2 = args
		if float(n) != frac1:
			where = g.choose(n<frac1,"above","below")
			self.allocateNodes(where=where,lines=lines)
	else:
		assert(kind=="scroll")
		linesPerPage = self.canvas.winfo_height()/self.line_height + 2
		n = int(n) ; assert(abs(n)==1)
		where = g.choose(n == 1,"below","above")
		lines = g.choose(args[2] == "pages",linesPerPage,lines)
		self.allocateNodes(where=where,lines=lines)
#@nonl
#@-node:ekr.20031218072017.1028:allocateNodesBeforeScrolling
#@+node:ekr.20031218072017.1029:setVisibleArea
def setVisibleArea (self,args):

	r1,r2 = args
	r1,r2 = float(r1),float(r2)
	# print "scroll ratios:",r1,r2

	try:
		s = self.canvas.cget("scrollregion")
		x1,y1,x2,y2 = g.scanf(s,"%d %d %d %d")
		x1,y1,x2,y2 = int(x1),int(y1),int(x2),int(y2)
	except:
		self.visibleArea = None
		return
		
	scroll_h = y2-y1
	# print "height of scrollregion:", scroll_h

	vy1 = y1 + (scroll_h*r1)
	vy2 = y1 + (scroll_h*r2)
	self.visibleArea = vy1,vy2
	# print "setVisibleArea: %5.1f %5.1f" % (vy1,vy2)
#@-node:ekr.20031218072017.1029:setVisibleArea
#@+node:ekr.20031218072017.1030:setVisibleAreaToFullCanvas
def setVisibleAreaToFullCanvas(self):
	
	if self.visibleArea:
		y1,y2 = self.visibleArea
		y2 = max(y2,y1 + self.canvas.winfo_height())
		self.visibleArea = y1,y2
#@nonl
#@-node:ekr.20031218072017.1030:setVisibleAreaToFullCanvas
#@+node:ekr.20031218072017.1031:tree.updateTree
def updateTree (self,v,x,y,h,level):

	yfirst = ylast = y
	if level==0: yfirst += 10
	while v:
		# g.trace(x,y,v)
		h = self.updateNode(v,x,y)
		y += h ; ylast = y
		if v.isExpanded() and v.firstChild():
			y = self.updateTree(v.firstChild(),x+child_indent,y,h,level+1)
		v = v.next()
	return y
#@-node:ekr.20031218072017.1031:tree.updateTree
#@-node:ekr.20031218072017.1026:Used only for incremental redraws
#@-node:ekr.20031218072017.995:(Incremental update of screen)
#@+node:ekr.20031218072017.1032:(Syntax coloring a la jEdit) (do not delete)
@ To do:

- ** Use a general purpose XML parser to parse the jEdit mode files.
- ** Do incremental syntax coloring
	- Create lines table.
	- Initialize lines table when select new node.
- Use strings for states.
- Define colorizeLine method.
- Create self.state ivar
- Use a keyword lead-in table.
	- Use this for latex keywords and Leo keywords.
	- Add ignore-case ivar.
- Define @language xml.
- Defined syntax coloring for all jEdit token types:
	KEYWORD1,KEYWORD2,KEYWORD3,LABEL,LITERAL1,LITERAL2,MARKUP,OPERATOR
	Where do Leo keywords fit in?

#@+node:ekr.20031218072017.1033:Ideas for dynamic code
@ignore

@ The following gives the general idea.

The self.known_languages dict contains all the data structures for a particular language.  This dict is created dynamically.  Each entry is a tuple of other info:
	"c"      : (dict1,...,dictM,list1,...,listN,etc.),
	"python" : (dict1,...,dictM,list1,...,listN,etc.),
These tuples, i.e., all the data structures, are created by the initialization routine.

@c
data = self.known_languages.get(self.language)
if not data:
	# Create all the data structures for the language.
	data = parse_xml_file(self.language) 
	if data: self.known_languages[language] = data
if data:
	self.dict1,...,self.listN=data

# The subsidiary data structures will be created from the xml files.
# The exact data structures used depends on the format of the xml files.

self.reserved_words1 = {} # Main language keywords: reserved words.
self.reserved_words2 = {} # Functions etc. to be colored separately.
self.keyword_chars1 = {} # Characters that appear as the first character of a keyword.
self.keyword_chars2 = {} # Characters that appear as second or following characters of a keyword.
self.string_start1,self.string.start2 # Opening characters of strings.

# The code might scan for keywords as follows:
n = len(s)
if i < n and self.keywords1.get(s[i]):
	j = i ; i += 1
	while i < n and self.keywords2.get(s[i]):
		i += 1
	word = s[j:i]
	if self.reserved_words1.get(word):
		# colorize the reserved word
	elif self.reserved_words2.get(word):
		# colorize the reserved word
#@-node:ekr.20031218072017.1033:Ideas for dynamic code
#@+node:ekr.20031218072017.1034:New data structures
special_keywords_dict = {
	'\\' : (latex_keywords_dict,"keyword"),
	'@' :  (leo_keywords_dict,"leoKeword") }
	
if << ch is alphabetic >>:
	word = scan_c_word(s,i)
	kind = keywords_dict.get(word)
	if kind:
		<< colorize word using kind >>
else:
	data = special_keywords_dict.get(ch)
	if data:
		dict,kind = data
		word = scan_c_word(s,i+1)
		key = d.get(word)
		if key:
			<< colorize ch and word using kind >>
#@nonl
#@-node:ekr.20031218072017.1034:New data structures
#@+node:ekr.20031218072017.1049:jEdit docs
@nocolor

#@+node:ekr.20031218072017.1050:The Preamble and MODE tag
Each mode definition must begin with the following: 

<?xml version="1.0"?>
<!DOCTYPE MODE SYSTEM "xmode.dtd"> 

Each mode definition must also contain exactly one MODE tag. All other tags (PROPS, RULES) must be placed inside the MODE tag. The MODE tag does not have any defined attributes. Here is an example: 

<MODE>
    ... mode definition goes here ...
</MODE> 
#@-node:ekr.20031218072017.1050:The Preamble and MODE tag
#@+node:ekr.20031218072017.1051:The PROPS Tag (Leo could ignore these)
The PROPS tag and the PROPERTY tags inside it are used to define mode-specific properties. Each PROPERTY tag must have a NAME attribute set to the property's name, and a VALUE attribute with the property's value. 

All buffer-local properties listed in the section called "Buffer-Local Properties" may be given values in edit modes. In addition, the following mode properties have no buffer-local equivalent: 

commentEnd - the comment end string, used by the Range Comment command. 

commentStart - the comment start string, used by the Range Comment command. 

lineComment - the line comment string, used by the Line Comment command. 

doubleBracketIndent - If a line matches the indentPrevLine regular expression and the next line contains an opening bracket, a level of indent will not be added to the next line, unless this property is set to "true". For example, with this property set to "false", Java code will be indented like so: 

while(objects.hasMoreElements())
{
        ((Drawable)objects.nextElement()).draw();
} 

On the other hand, settings this property to "true" will give the following result: 

while(objects.hasMoreElements())
        {
                ((Drawable)objects.nextElement()).draw();
        } 

indentCloseBrackets - A list of characters (usually brackets) that subtract indent from the current line. For example, in Java mode this property is set to "}".

indentOpenBrackets - A list of characters (usually brackets) that add indent to the next line. For example, in Java mode this property is set to "{".

indentPrevLine - When indenting a line, jEdit checks if the previous line matches the regular expression stored in this property. If it does, a level of indent is added. For example, in Java mode this regular expression matches language constructs such as "if", "else", "while", etc.

Here is the complete <PROPS> tag for Java mode: 

<PROPS>
    <PROPERTY NAME="indentOpenBrackets" VALUE="{" />
    <PROPERTY NAME="indentCloseBrackets" VALUE="}" />
    <PROPERTY NAME="indentPrevLine" VALUE="\s*(((if|while)
        \s*\(|else|case|default)[^;]*|for\s*\(.*)" />
    <PROPERTY NAME="doubleBracketIndent" VALUE="false" />
    <PROPERTY NAME="commentStart" VALUE="/*" />
    <PROPERTY NAME="commentEnd" VALUE="*/" />
    <PROPERTY NAME="blockComment" VALUE="//" />
    <PROPERTY NAME="wordBreakChars" VALUE=",+-=<>/?^&*" />
</PROPS> 
#@-node:ekr.20031218072017.1051:The PROPS Tag (Leo could ignore these)
#@+node:ekr.20031218072017.1052:The RULES Tag
RULES tags must be placed inside the MODE tag. Each RULES tag defines a ruleset.

A ruleset consists of a number of parser rules, with each parser rule specifying how to highlight a specific syntax token. There must be at least one ruleset in each edit mode. There can also be more than one, with different rulesets being used to highlight different parts of a buffer (for example, in HTML mode, one rule set highlights HTML tags, and another highlights inline JavaScript). For information about using more than one ruleset, see the section called "The SPAN Rule". 

The RULES tag supports the following attributes, all of which are optional: 

SET - the name of this ruleset. All rulesets other than the first must have a name. 

HIGHLIGHT_DIGITS - if set to TRUE, digits (0-9, as well as hexadecimal literals prefixed with "0x") will be highlighted with the DIGIT token type. Default is FALSE. 

IGNORE_CASE - if set to FALSE, matches will be case sensitive. Otherwise, case will not matter. Default is TRUE. 

DEFAULT - the token type for text which doesn't match any specific rule. Default is NULL. See the section called "Token Types" for a list of token types. 

Here is an example RULES tag: 

<RULES IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE">
    ... parser rules go here ...
</RULES> 

Rule Ordering Requirements

You might encounter this very common pitfall when writing your own modes. 

Since jEdit checks buffer text against parser rules in the order they appear in the ruleset, more specific rules must be placed before generalized ones, otherwise the generalized rules will catch everything. 

This is best demonstrated with an example. The following is incorrect rule ordering: 

<SPAN TYPE="MARKUP">
    <BEGIN>[</BEGIN>
    <END>]</END>
</SPAN>

<SPAN TYPE="KEYWORD1">
    <BEGIN>[!</BEGIN>
    <END>]</END>
</SPAN> 

If you write the above in a rule set, any occurrence of "[" (even things like "[!DEFINE", etc) will be highlighted using the first rule, because it will be the first to match. This is most likely not the intended behavior. 

The problem can be solved by placing the more specific rule before the general one: 

<SPAN TYPE="KEYWORD1">
    <BEGIN>[!</BEGIN>
    <END>]</END>
</SPAN>

<SPAN TYPE="MARKUP">
    <BEGIN>[</BEGIN>
    <END>]</END>
</SPAN> 

Now, if the buffer contains the text "[!SPECIAL]", the rules will be checked in order, and the first rule will be the first to match. However, if you write "[FOO]", it will be highlighted using the second rule, which is exactly what you would expect. 

Per-Ruleset Properties

The PROPS tag (described in the section called "The PROPS Tag") can also be placed inside the RULES tag to define ruleset-specific properties. Only the following properties can be set on a per-ruleset basis: 

commentEnd - the comment end string. 

commentStart - the comment start string. 

lineComment - the line comment string. 

These properties are used by the commenting commands to implement context-sensitive comments; see the section called "Commenting Out Code". 

The TERMINATE Rule

The TERMINATE rule specifies that parsing should stop after the specified number of characters have been read from a line. The number of characters to terminate after should be specified with the AT_CHAR attribute. Here is an example: 

<TERMINATE AT_CHAR="1" /> 

This rule is used in Patch mode, for example, because only the first character of each line affects highlighting. 

The SPAN Rule

The SPAN rule highlights text between a start and end string. The start and end strings are specified inside child elements of the SPAN tag. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start and end sequences will not be highlighted, only the text between them will

NO_LINE_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it spans more than one line

NO_WORD_BREAK - If set to TRUE, the span will be highlighted with the INVALID token type if it includes whitespace

DELEGATE - text inside the span will be highlighted with the specified ruleset. To delegate to a ruleset defined in the current mode, just specify its name. To delegate to a ruleset defined in another mode, specify a name of the form mode::ruleset. Note that the first (unnamed) ruleset in a mode is called "MAIN".

Here is a SPAN that highlights Java string literals, which cannot include line breaks: 

<SPAN TYPE="LITERAL1" NO_LINE_BREAK="TRUE">
   <BEGIN>"</BEGIN>
   <END>"</END>
</SPAN> 

Here is a SPAN that highlights Java documentation comments by delegating to the "JAVADOC" ruleset defined elsewhere in the current mode: 

<SPAN TYPE="COMMENT2" DELEGATE="JAVADOC">
   <BEGIN>/**</BEGIN>
   <END>*/</END>
</SPAN> 

Here is a SPAN that highlights HTML cascading stylesheets inside <STYLE> tags by delegating to the main ruleset in the CSS edit mode: 

<SPAN TYPE="MARKUP" DELEGATE="css::MAIN">
   <BEGIN>&lt;style&gt;</BEGIN>
   <END>&lt;/style&gt;</END>
</SPAN> 

Tip
The <END> tag is optional. If it is not specified, any occurrence of the start string will cause the remainder of the buffer to be highlighted with this rule. 

This can be very useful when combined with delegation. 

The EOL_SPAN Rule
An EOL_SPAN is similar to a SPAN except that highlighting stops at the end of the line, not after the end sequence is found. The text to match is specified between the opening and closing EOL_SPAN tags. The following attributes are supported: 

TYPE - The token type to highlight the span with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the span will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the start sequence will not be highlighted, only the text after it will

Here is an EOL_SPAN that highlights C++ comments: 

<EOL_SPAN TYPE="COMMENT1">//</EOL_SPAN> 

The MARK_PREVIOUS Rule
The MARK_PREVIOUS rule highlights from the end of the previous syntax token to the matched text. The text to match is specified between opening and closing MARK_PREVIOUS tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if it occurs at the beginning of the line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text before it will

Here is a rule that highlights labels in Java mode (for example, "XXX:"): 

<MARK_PREVIOUS AT_LINE_START="TRUE"
    EXCLUDE_MATCH="TRUE">:</MARK_PREVIOUS> 

The MARK_FOLLOWING Rule
The MARK_FOLLOWING rule highlights from the start of the match to the next syntax token. The text to match is specified between opening and closing MARK_FOLLOWING tags. The following attributes are supported: 

TYPE - The token type to highlight the text with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the text will only be highlighted if the start sequence occurs at the beginning of a line

EXCLUDE_MATCH - If set to TRUE, the match will not be highlighted, only the text after it will

Here is a rule that highlights variables in Unix shell scripts ("$CLASSPATH", "$IFS", etc): 

<MARK_FOLLOWING TYPE="KEYWORD2">$</MARK_FOLLOWING> 

The SEQ Rule
The SEQ rule highlights fixed sequences of text. The text to highlight is specified between opening and closing SEQ tags. The following attributes are supported: 

TYPE - the token type to highlight the sequence with. See the section called "Token Types" for a list of token types

AT_LINE_START - If set to TRUE, the sequence will only be highlighted if it occurs at the beginning of a line

The following rules highlight a few Java operators: 

<SEQ TYPE="OPERATOR">+</SEQ>
<SEQ TYPE="OPERATOR">-</SEQ>
<SEQ TYPE="OPERATOR">*</SEQ>
<SEQ TYPE="OPERATOR">/</SEQ> 

The KEYWORDS Rule

There can only be one KEYWORDS tag per ruleset. The KEYWORDS rule defines keywords to highlight. Keywords are similar to SEQs, except that SEQs match anywhere in the text, whereas keywords only match whole words. 

The KEYWORDS tag does not define any attributes. 

Each child element of the KEYWORDS tag should be named after the desired token type, with the keyword text between the start and end tags. For example, the following rule highlights the most common Java keywords: 

<KEYWORDS IGNORE_CASE="FALSE">
   <KEYWORD1>if</KEYWORD1>
   <KEYWORD1>else</KEYWORD1>
   <KEYWORD3>int</KEYWORD3>
   <KEYWORD3>void</KEYWORD3>
</KEYWORDS> 

Token Types

Parser rules can highlight tokens using any of the following token types: 

NULL - no special highlighting is performed on tokens of type NULL 

COMMENT1 

COMMENT2 

FUNCTION 

INVALID - tokens of this type are automatically added if a NO_WORD_BREAK or NO_LINE_BREAK SPAN spans more than one word or line, respectively. 

KEYWORD1 

KEYWORD2 

KEYWORD3 

LABEL 

LITERAL1 

LITERAL2 

MARKUP 

OPERATOR 
#@-node:ekr.20031218072017.1052:The RULES Tag
#@-node:ekr.20031218072017.1049:jEdit docs
#@-node:ekr.20031218072017.1032:(Syntax coloring a la jEdit) (do not delete)
#@+node:ekr.20031218072017.1658:(Using xml parser)
from leoGlobals import *
import os,leoNodes
from xml.sax import saxutils, make_parser
from xml.sax.xmlreader import InputSource

path = os.path.join(app().loadDir,"../","test","test2.leo")
path = os.path.join(app().loadDir,"LeoPy.leo")
path = os.path.normpath(path)

verbose = false
tnodes = vnodes = 0

def clean(s): return toEncodedString(s,"ascii")

class trace_parse(saxutils.XMLGenerator):
@others
	
try:
	f = None
	try:
		print path
		if 1:
			source = f = open(path)
		else: # not needed, and it works.
			source = InputSource(path)
			source.setEncoding(app().tkEncoding) # Not needed.
		parser = make_parser()
		h = trace_parse()
		parser.setContentHandler(h)
		parser.parse(source)
		print "vnodes,tnodes:",`vnodes`,`tnodes`
	except: es_exception()
finally:
	if f: f.close()
#@nonl
#@+node:ekr.20031218072017.1659:characters
def characters(self,content):

	content = content.replace('\r','')

	if verbose and content.strip():
		print clean(content)
#@-node:ekr.20031218072017.1659:characters
#@+node:ekr.20031218072017.1660:endDocument
def endDocument(self):
	trace()


#@-node:ekr.20031218072017.1660:endDocument
#@+node:ekr.20031218072017.1661:endElement
def endElement(self,name):
	if verbose: print '</' + clean(name).strip() + '>'
#@-node:ekr.20031218072017.1661:endElement
#@+node:ekr.20031218072017.1662:other methods
def ignorableWhitespace(self):
	trace()

def processingInstruction (self,target,data):
	trace()

def skippedEntity(self,name):
	trace(name)

def startElementNS(self,name,qname,attrs):
	trace(name)

def endElementNS(self,name,qname):
	trace(name)
#@-node:ekr.20031218072017.1662:other methods
#@+node:ekr.20031218072017.1663:startDocument
def startDocument(self):

	if verbose:
		print ; print ; print '*' * 30 + " dump " + '*' * 30 ; print
	trace()
#@-node:ekr.20031218072017.1663:startDocument
#@+node:ekr.20031218072017.1664:startElement
def startElement(self,name,atts):
	global vnodes,tnodes
	if verbose: print '<' + clean(name).strip() + '>',
	if name == "v":
		vnodes += 1
		v = leoNodes.vnode(top(),leoNodes.tnode())
	elif name == "t":
		tnodes += 1
		t = leoNodes.tnode()
#@nonl
#@-node:ekr.20031218072017.1664:startElement
#@-node:ekr.20031218072017.1658:(Using xml parser)
#@-node:ekr.20031218072017.984:Unfinished projects
#@+node:ekr.20040107064101.1:4.2 Projects
#@+node:ekr.20040326032652: Notes
#@+node:ekr.20040301192211: What I did
@nocolor


- (done) Disable all write logic.
- (done) Test all position code.
- (done) Get drag working.
- (done) Get all menu enablers working
- (done) Get insert/delete/clone working.
- (done) Get write logic working.
- (done) Get copy/paste nodes working.
- (done) Get find command working.
- (done) Get undo/redo working.
- (done) Get read logic working.
- (passes unit tests) Get import/export working.

- (done) Fix bug in createVnode:
	- Don't add parent to v.parents if it is already in the list.
	- This was a bad bug.

- (done) unit test to check p.v.parents
#@nonl
#@+node:ekr.20040311124726:Features of 4.2
@nocolor

- Iterators.
	- Convenient.
	- copy param.
	- c.allNodes_iter a very useful abbreviation.

p.x for most methods v.x.

p.t ivar simulated by p.__getattr__
#@-node:ekr.20040311124726:Features of 4.2
#@+node:ekr.20040302083805.1:Changed ivars
- renamed v._next, v._back, v._parent, v.t._firstChild
- moved _firstChild to tnode for 4.2.
- v.iconVal not defined in 4.2: can be computed easily by drawing code.
- added t.vnodeList in 4.2.
#@nonl
#@-node:ekr.20040302083805.1:Changed ivars
#@+node:ekr.20040302083805.4:Replaced p by p.v in leoNodes.leo
- v.nodeAfterTree
- v.threadNext
- v.moveToNthChildOf
- v.validateOutlineWithParent
- v.exists
- v.linkAsNthChild
- v.createDependents
- v.shouldBeClone (replaced p by vp1)
- v.matchHeadline (replaced p by s)
#@nonl
#@-node:ekr.20040302083805.4:Replaced p by p.v in leoNodes.leo
#@+node:ekr.20040302112717:Created p.getX routines
#@-node:ekr.20040302112717:Created p.getX routines
#@-node:ekr.20040301192211: What I did
#@+node:ekr.20040321104014:  Big picture
@nocolor

4.2 will optimize all aspects of Leo's core:

- (done) Shared tree represent clones.
- (maybe) Drawing code uses minimum number of Tk widgets.
- User can choose undo granularity: word,line,node.
- @file thin makes Leo "nimble".
- Fix biggest configuration bugs.

Will not do for 4.2:

- @root and @file may never be unified.
#@nonl
#@-node:ekr.20040321104014:  Big picture
#@-node:ekr.20040326032652: Notes
#@+node:ekr.20040308151706.1: Fundamental 4.2 Code
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

	def __getattr__ (self,attr):
		
		"""Convert references to p.t into references to p.v.t.
		
		N.B. This automatically keeps p.t in synch with p.v.t."""

		if attr=="t":
			return self.v.t
		else:
			# Only called when normal lookup fails.
			raise AttributeError
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

	# These ivars are the global vars of this program.
	self.afterHandler = None
	self.batchMode = false # true: run in batch mode.
	self.commandName = None # The name of the command being executed.
	self.config = None # The leoConfig instance.
	self.count = 0 # General purpose debugging count.
	self.copies = 0 # Number of calls to position.copy
	self.debug = false # True: enable extra debugging tests (not used at present).
		# WARNING: this could greatly slow things down.
	self.disableSave = false
	self.globalWindows = []
	self.gui = None # The gui class.
	self.hasOpenWithMenu = false # true: open with plugin has been loaded.
	self.hookError = false # true: suppress further calls to hooks.
	self.hookFunction = None # Application wide hook function.
	self.idle_imported = false # true: we have done an import idle
	self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
	self.idleTimeHook = false # true: the global idleTimeHookHandler will reshedule itself.
	self.initing = true # true: we are initiing the app.
	self.killed = false # true: we are about to destroy the root window.
	self.leoID = None # The id part of gnx's.
	self.loadDir = None # The directory from which Leo was loaded.
	self.loadedPlugins = [] # List of loaded plugins that have signed on.
	self.log = None # The LeoFrame containing the present log.
	self.logIsLocked = false # true: no changes to log are allowed.
	self.logWaiting = [] # List of messages waiting to go to a log.
	self.menuWarningsGiven = false # true: supress warnings in menu code.
	self.nodeIndices = None # Singleton node indices instance.
	self.numberOfWindows = 0 # Number of opened windows.
	self.openWithFiles = [] # List of data used by Open With command.
	self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
	self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
	self.quitting = false # true if quitting.  Locks out some events.
	self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
	self.root = None # The hidden main window. Set later.
	self.searchDict = {} # For communication between find/change scripts.
	self.scriptDict = {} # For communication between Execute Script command and scripts.
	self.trace = false # true: enable debugging traces.
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.tkEncoding = "utf-8"
	self.unicodeErrorGiven = true # true: suppres unicode tracebacks.
	self.unitTestDict = {} # For communication between unit tests and code.
	self.use_gnx = true # true: generate gnx's instead of tnode indices.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.

	# Global panels.  Destroyed when Leo ends.
	self.findFrame = None
	self.pythonFrame = None
	
	<< Define global constants >>
	<< Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = true # true: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"csharp" : "// /* */",	# C#
	"css" : "/* */", # 4/1/04
	"cweb" : "@q@ @>", # Use the "cweb hack"
	"elisp" : ";",
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "<!-- -->",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rapidq" : "'", # fil 2004-march-11
	"rebol" : ";",  # jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c",
	"css" : "css", # 4/1/04
	"cweb" : "w",
	"elisp" : "el",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "tex", # 1/8/04
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl",
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rapidq" : "bas", # fil 2004-march-11
	"rebol" : "r",    # jason 2003-07-03
	"shell" : "sh",   # DS 4/1/04
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
	
	"""Initialize and run Leo"""
	
	if not isValidPython(): return
	# Import leoGlobals, but do NOT set g.
	import leoGlobals
	from leoGlobals import true,false
	# Create the application object.
	import leoApp ; leoGlobals.app = leoApp.LeoApp()
	g = leoGlobals ; assert(g.app) # NOW we can set g.
	g.app.loadDir = computeLoadDir() # Depends on g.app.tkEncoding: uses utf-8 for now.
	import leoConfig
	g.app.config = leoConfig.config()
	g.app.setEncoding() # 10/20/03: do this earlier
	script = getBatchScript()
	if script:
		createNullGuiWithScript(script)
		fileName = None
	else:
		<< print encoding info >>
	# Load plugins. Plugins may create g.app.gui.
	g.doHook("start1")
	if g.app.killed: return # Support for g.app.forceShutdown.
	# Create the default gui if needed.
	if g.app.gui == None:
		g.app.createTkGui()
	if g.app.use_gnx:
		if not g.app.leoID: g.app.setLeoID() # Forces the user to set g.app.leoID.
		import leoNodes
		g.app.nodeIndices = leoNodes.nodeIndices()
	# Initialize tracing and statistics.
	g.init_sherlock(args)
	g.clear_stats()
	<< start psycho >>
	# Create the main frame.  Show it and all queued messages.
	c,frame = createFrame(fileName)
	if not frame: return
	if g.app.disableSave:
		g.es("disabling save commands",color="red")
	g.app.writeWaitingLog()
	v = c.currentVnode()
	g.doHook("start2",c=c,v=v,fileName=fileName)
	frame.tree.redraw()
	frame.body.setFocus()
	g.app.initing = false # "idle" hooks may now call g.app.forceShutdown.
	g.app.gui.runMainLoop()
#@+node:ekr.20040411081633:<< start psycho >>
if g.app.config.use_psyco:
	try:
		import psyco
		if 0:
			file = r"c:\prog\test\psycoLog.txt"
			g.es("psyco now logging to",file,color="blue")
			psyco.log(file)
			psyco.profile()
		psyco.full()
		g.es("psyco now running",color="blue")
	except ImportError:
		pass
	except:
		print "unexpected exception importing psyco"
		g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1935:<< print encoding info >>
g.es("leoConfig.txt encoding: " + g.app.config.config_encoding, color="blue")

if 0: # This is just confusing for users.
	g.es("Text encoding: " + g.app.tkEncoding, color="blue")
#@nonl
#@-node:ekr.20031218072017.1935:<< print encoding info >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	message = """\
Leo requires Python 2.2 or higher.
You may download Python 2.2 and Python 2.3 from http://python.org/download/
"""
	try:
		if not g.CheckVersion(sys.version, "2.2"):
			g.app.gui.runAskOkDialog("Python version error",message=message,text="Exit")
			return false
		else:
			return true
	except:
		print "exception getting Python version"
		import traceback ; traceback.print_exc()
		return false
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
	
	"""Returns the directory containing leo.py."""
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	# g.trace(g.app.tkEncoding)
	
	try:
		import leo
		path = g.os_path_abspath(leo.__file__)

		if sys.platform=="win32": # "mbcs" exists only on Windows.
			path = g.toUnicode(path,"mbcs")
		elif sys.platform=="dawwin":
			path = g.toUnicode(path,"utf-8")
		else:
			path = g.toUnicode(path,g.app.tkEncoding)

		if path:
			loadDir = g.os_path_dirname(path)
		else:
			loadDir = None
		if not loadDir:
			loadDir = g.os_path_abspath(os.getcwd())
			print "Using emergency loadDir:",repr(loadDir)

		encoding = g.choose(sys.platform=="dawwin","utf-8",g.app.tkEncoding) # 11/18/03
		loadDir = g.toUnicode(loadDir,encoding) # 10/20/03
		return loadDir
	except:
		print "Exception getting load directory"
		import traceback ; traceback.print_exc()
		return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
	
	"""Create a LeoFrame during Leo's startup process."""
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	# g.trace(g.app.tkEncoding,fileName)
	
	# Try to create a frame for the file.
	if fileName:
		fileName = g.os_path_join(os.getcwd(),fileName)
		fileName = g.os_path_normpath(fileName)
		if g.os_path_exists(fileName):
			ok, frame = g.openWithFileName(fileName,None)
			if ok:
				return frame.c,frame
	
	# Create a new frame & indicate it is the startup window.
	c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
	frame.setInitialWindowGeometry()
	frame.startupWindow = true
	
	# Report the failure to open the file.
	if fileName:
		g.es("File not found: " + fileName)

	return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
	
	import leoGlobals as g
	from leoGlobals import true,false
	import leoGui
	
	g.app.batchMode = true
	g.app.gui = leoGui.nullGui("nullGui")
	g.app.root = g.app.gui.createRootWindow()
	g.app.gui.finishCreate()
	g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	name = None ; i = 1 # Skip the dummy first arg.
	while i + 1 < len(sys.argv):
		arg = sys.argv[i].strip().lower()
		if arg in ("--script","-script"):
			name = sys.argv[i+1].strip() ; break
		i += 1

	if not name: return None	
	name = g.os_path_join(g.app.loadDir,name)
	try:
		f = None
		try:
			f = open(name,'r')
			script = f.read()
			# g.trace("script",script)
		except IOError:
			g.es("can not open script file: " + name, color="red")
			script = None
	finally:
		if f: f.close()
		return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.3341:class vnode
class baseVnode (object):
	"""The base class of the vnode class."""
	<< vnode constants >>
	@others
	
class vnode (baseVnode):
	"""A class that implements vnodes."""
	pass
#@+node:ekr.20031218072017.951:<< vnode constants >>
# Define the meaning of status bits in new vnodes.

# Archived...
clonedBit	  = 0x01 # true: vnode has clone mark.

# not used	 = 0x02
expandedBit = 0x04 # true: vnode is expanded.
markedBit	  = 0x08 # true: vnode is marked
orphanBit	  = 0x10 # true: vnode saved in .leo file, not derived file.
selectedBit = 0x20 # true: vnode is current vnode.
topBit		    = 0x40 # true: vnode was top vnode when saved.

# Not archived...
dirtyBit    =	0x060
richTextBit =	0x080 # Determines whether we use <bt> or <btr> tags.
visitedBit	 = 0x100
#@-node:ekr.20031218072017.951:<< vnode constants >>
#@+node:ekr.20031218072017.3342:Birth & death
#@+node:ekr.20031218072017.3343:v.__cmp__ (not used)
if 0: # not used
	def __cmp__(self,other):
		
		g.trace(self,other)
		return not (self is other) # Must return 0, 1 or -1
#@nonl
#@-node:ekr.20031218072017.3343:v.__cmp__ (not used)
#@+node:ekr.20031218072017.3344:v.__init__
def __init__ (self,c,t):

	assert(t)
	<< initialize vnode data members >>
#@+node:ekr.20031218072017.1968:<< initialize vnode data members >>
self.c = c # The commander for this vnode.
self.t = t # The tnode.
self.statusBits = 0 # status bits

# Structure links.
self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20031218072017.1968:<< initialize vnode data members >>
#@-node:ekr.20031218072017.3344:v.__init__
#@+node:ekr.20031218072017.3345:v.__repr__ & v.__str__
def __repr__ (self):
	
	if self.t:
		return "<vnode %d:'%s'>" % (id(self),self.t.headString)
	else:
		return "<vnode %d:NULL tnode>" % (id(self))
		
__str__ = __repr__
#@nonl
#@-node:ekr.20031218072017.3345:v.__repr__ & v.__str__
#@+node:ekr.20040312145256:v.dump
def dumpLink (self,link):
	return g.choose(link,link,"<none>")

def dump (self,label=""):
	
	v = self

	if label:
		print '-'*10,label,v
	else:
		print "self    ",v.dumpLink(v)
		print "len(vnodeList)",len(v.t.vnodeList)
	print "_back   ",v.dumpLink(v._back)
	print "_next   ",v.dumpLink(v._next)
	print "_parent ",v.dumpLink(v._parent)
	print "t._child",v.dumpLink(v.t._firstChild)
#@nonl
#@-node:ekr.20040312145256:v.dump
#@-node:ekr.20031218072017.3342:Birth & death
#@+node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20040328055931:afterHeadlineFileTypeName
def afterHeadlineFileTypeName(self,s):
	
	h = self.headString()

	if s != "@file" and g.match_word(h,0,s):
		# No options are valid.
		return s,string.strip(h[len(s):])

	elif g.match(h,0,"@file"):
		i,atFileType,junk = g.scanAtFileOptions(h)
		return atFileType,h[i:].strip()

	else:
		return None,None
#@nonl
#@-node:ekr.20040328055931:afterHeadlineFileTypeName
#@+node:ekr.20031218072017.3347:afterHeadlineMatch
def afterHeadlineMatch(self,s):
	
	atFileType,fileName = self.afterHeadlineFileTypeName(s)
	if s == atFileType:
		return fileName
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3347:afterHeadlineMatch
#@+node:ekr.20031218072017.3350:anyAtFileNodeName
def anyAtFileNodeName (self):
	
	"""Return the file name following an @file node or an empty string."""
	
	# New in 4.2: do the fastest possible tests.
	h = self.headString()

	if g.match(h,0,"@file"):
		type,name = self.afterHeadlineFileTypeName("@file")
		if type and name: return name
		else:             return ""
	elif g.match(h,0,"@nosentinelsfile"):
		return self.afterHeadlineMatch("@nosentinelsfile")
	elif g.match(h,0,"@rawfile"):
		return self.afterHeadlineMatch("@rawfile")
	elif g.match(h,0,"@silentfile"):
		return self.afterHeadlineMatch("@silentfile")
	elif g.match(h,0,"@thinfile"):
		return self.afterHeadlineMatch("@thinfile")
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3350:anyAtFileNodeName
#@+node:ekr.20031218072017.3348:at...FileNodeName
@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
	return self.afterHeadlineMatch("@file")

def atNoSentinelsFileNodeName (self):
	return self.afterHeadlineMatch("@nosentinelsfile")

def atRawFileNodeName (self):
	return self.afterHeadlineMatch("@rawfile")
	
def atSilentFileNodeName (self):
	return self.afterHeadlineMatch("@silentfile")
	
def atThinFileNodeName (self):
	return self.afterHeadlineMatch("@thinfile")
	
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@nonl
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:EKR.20040430152000:isAtAllNode
def isAtAllNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@all")
	return flag
#@nonl
#@-node:EKR.20040430152000:isAtAllNode
#@+node:ekr.20040326031436:isAnyAtFileNode
def isAnyAtFileNode (self):
	
	"""Return true if v is any kind of @file or related node."""
	
	# This routine should be as fast as possible.
	# It is called once for every vnode when writing a file.

	h = self.headString()
	return h and h[0] == '@' and self.anyAtFileNodeName()
#@nonl
#@-node:ekr.20040326031436:isAnyAtFileNode
#@+node:ekr.20040325073709:isAt...FileNode
def isAtFileNode (self):
	return g.choose(self.atFileNodeName(),true,false)
	
def isAtNoSentinelsFileNode (self):
	return g.choose(self.atNoSentinelsFileNodeName(),true,false)

def isAtRawFileNode (self): # @file-noref
	return g.choose(self.atRawFileNodeName(),true,false)

def isAtSilentFileNode (self): # @file-asis
	return g.choose(self.atSilentFileNodeName(),true,false)

def isAtThinFileNode (self):
	return g.choose(self.atThinFileNodeName(),true,false)
	
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@nonl
#@-node:ekr.20040325073709:isAt...FileNode
#@+node:ekr.20031218072017.3351:isAtIgnoreNode
def isAtIgnoreNode (self):

	"""Returns true if the receiver contains @ignore in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
	return flag
#@nonl
#@-node:ekr.20031218072017.3351:isAtIgnoreNode
#@+node:ekr.20031218072017.3352:isAtOthersNode
def isAtOthersNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@others")
	return flag
#@nonl
#@-node:ekr.20031218072017.3352:isAtOthersNode
#@+node:ekr.20031218072017.3353:matchHeadline
def matchHeadline (self,pattern):

	"""Returns true if the headline matches the pattern ignoring whitespace and case.
	
	The headline may contain characters following the successfully matched pattern."""

	h = string.lower(self.headString())
	h = string.replace(h,' ','')
	h = string.replace(h,'\t','')

	s = string.lower(pattern)
	s = string.replace(s,' ','')
	s = string.replace(s,'\t','')

	# ignore characters in the headline following the match
	return s == h[0:len(s)]
#@nonl
#@-node:ekr.20031218072017.3353:matchHeadline
#@-node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20031218072017.3359:Getters (vnode)
#@+node:ekr.20040306214240:Tree Traversal getters
# These aren't very useful.
#@nonl
#@+node:ekr.20031218072017.3406:v.back
# Compatibility routine for scripts

def back (self):

	return self._back
#@nonl
#@-node:ekr.20031218072017.3406:v.back
#@+node:ekr.20031218072017.3409:v.next
# Compatibility routine for scripts

def next (self):

	return self._next
#@nonl
#@-node:ekr.20031218072017.3409:v.next
#@-node:ekr.20040306214240:Tree Traversal getters
#@+node:ekr.20031218072017.3360:Children
#@+node:ekr.20040303212445:v.childIndex
def childIndex(self):
	
	v = self

	if not v._back:
		return 0

	n = 0 ; v = v._back
	while v:
		n += 1
		v = v._back
	return n
#@nonl
#@-node:ekr.20040303212445:v.childIndex
#@+node:ekr.20031218072017.3362:v.firstChild (changed for 4.2)
def firstChild (self):
	
	return self.t._firstChild
#@nonl
#@-node:ekr.20031218072017.3362:v.firstChild (changed for 4.2)
#@+node:ekr.20031218072017.3363:v.hasChildren
def hasChildren (self):

	return self.firstChild() != None
#@nonl
#@-node:ekr.20031218072017.3363:v.hasChildren
#@+node:ekr.20040307085922:v.hasChildren & hasFirstChild
def hasChildren (self):
	
	v = self
	return v.firstChild()

hasFirstChild = hasChildren
#@nonl
#@-node:ekr.20040307085922:v.hasChildren & hasFirstChild
#@+node:ekr.20031218072017.3364:v.lastChild
def lastChild (self):

	child = self.firstChild()
	while child and child.next():
		child = child.next()
	return child
#@nonl
#@-node:ekr.20031218072017.3364:v.lastChild
#@+node:ekr.20031218072017.3365:v.nthChild
# childIndex and nthChild are zero-based.

def nthChild (self, n):

	child = self.firstChild()
	if not child: return None
	while n > 0 and child:
		n -= 1
		child = child.next()
	return child
#@nonl
#@-node:ekr.20031218072017.3365:v.nthChild
#@+node:ekr.20031218072017.3366:v.numberOfChildren (n)
def numberOfChildren (self):

	n = 0
	child = self.firstChild()
	while child:
		n += 1
		child = child.next()
	return n
#@nonl
#@-node:ekr.20031218072017.3366:v.numberOfChildren (n)
#@-node:ekr.20031218072017.3360:Children
#@+node:ekr.20031218072017.3367:Status Bits
#@+node:ekr.20031218072017.3368:v.isCloned (4.2)
def isCloned (self):
	
	return len(self.t.vnodeList) > 1
#@nonl
#@-node:ekr.20031218072017.3368:v.isCloned (4.2)
#@+node:ekr.20031218072017.3369:isDirty
def isDirty (self):

	return self.t.isDirty()
#@nonl
#@-node:ekr.20031218072017.3369:isDirty
#@+node:ekr.20031218072017.3370:isExpanded
def isExpanded (self):

	return ( self.statusBits & self.expandedBit ) != 0
#@nonl
#@-node:ekr.20031218072017.3370:isExpanded
#@+node:ekr.20031218072017.3371:isMarked
def isMarked (self):

	return ( self.statusBits & vnode.markedBit ) != 0
#@nonl
#@-node:ekr.20031218072017.3371:isMarked
#@+node:ekr.20031218072017.3372:isOrphan
def isOrphan (self):

	return ( self.statusBits & vnode.orphanBit ) != 0
#@nonl
#@-node:ekr.20031218072017.3372:isOrphan
#@+node:ekr.20031218072017.3373:isSelected
def isSelected (self):

	return ( self.statusBits & vnode.selectedBit ) != 0
#@nonl
#@-node:ekr.20031218072017.3373:isSelected
#@+node:ekr.20031218072017.3374:isTopBitSet
def isTopBitSet (self):

	return ( self.statusBits & self.topBit ) != 0
#@nonl
#@-node:ekr.20031218072017.3374:isTopBitSet
#@+node:ekr.20031218072017.3376:isVisited
def isVisited (self):

	return ( self.statusBits & vnode.visitedBit ) != 0
#@nonl
#@-node:ekr.20031218072017.3376:isVisited
#@+node:ekr.20031218072017.3377:status
def status (self):

	return self.statusBits
#@nonl
#@-node:ekr.20031218072017.3377:status
#@-node:ekr.20031218072017.3367:Status Bits
#@+node:ekr.20031218072017.3378:v.bodyString
# Compatibility routine for scripts

def bodyString (self):

	# This message should never be printed and we want to avoid crashing here!
	if not g.isUnicode(self.t.bodyString):
		s = "Leo internal error: not unicode:" + repr(self.t.bodyString)
		print s ; g.es(s,color="red")

	# Make _sure_ we return a unicode string.
	return g.toUnicode(self.t.bodyString,g.app.tkEncoding)
#@-node:ekr.20031218072017.3378:v.bodyString
#@+node:ekr.20031218072017.3379:v.currentVnode (and c.currentPosition 4.2)
def currentPosition (self):
	return self.c.currentPosition()
		
def currentVnode (self):
	return self.c.currentVnode()
#@nonl
#@-node:ekr.20031218072017.3379:v.currentVnode (and c.currentPosition 4.2)
#@+node:ekr.20031218072017.3380:v.edit_text TO BE DELETED
def edit_text (self):

	v = self ; c = v.c ; p = c.currentPosition()
	
	g.trace("ooooops")
	#import traceback ; traceback.print_stack()
	
	pairs = self.c.frame.tree.getEditTextDict(v)
	for p2,t2 in pairs:
		if p.equal(p2):
			# g.trace("found",t2)
			return t2
			
	return None
#@nonl
#@-node:ekr.20031218072017.3380:v.edit_text TO BE DELETED
#@+node:ekr.20031218072017.3381:v.findRoot (4.2)
def findRoot (self):
	
	return self.c.rootPosition()
#@nonl
#@-node:ekr.20031218072017.3381:v.findRoot (4.2)
#@+node:ekr.20031218072017.1581:v.headString & v.cleanHeadString
def headString (self):
	
	"""Return the headline string."""
	
	# This message should never be printed and we want to avoid crashing here!
	if not g.isUnicode(self.t.headString):
		s = "Leo internal error: not unicode:" + repr(self.t.headString)
		print s ; g.es(s,color="red")
		
	# Make _sure_ we return a unicode string.
	return g.toUnicode(self.t.headString,g.app.tkEncoding)

def cleanHeadString (self):
	
	s = self.headString()
	return g.toEncodedString(s,"ascii") # Replaces non-ascii characters by '?'
#@nonl
#@-node:ekr.20031218072017.1581:v.headString & v.cleanHeadString
#@+node:ekr.20040323100443:v.directParents (new method in 4.2)
def directParents (self):
	
	"""(New in 4.2) Return a list of all direct parent vnodes of a vnode.
	
	This is NOT the same as the list of ancestors of the vnode."""
	
	v = self
	
	if v._parent:
		return v._parent.t.vnodeList
	else:
		return []
#@nonl
#@-node:ekr.20040323100443:v.directParents (new method in 4.2)
#@-node:ekr.20031218072017.3359:Getters (vnode)
#@+node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
# These remain in 4.2: the file read logic calls these before creating positions.
#@nonl
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

	"""Inserts a new vnode after self"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAfter(self)

	return v
#@nonl
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAsNthChild(self,n)

	return v
#@nonl
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20031218072017.2355:v.linkAfter
def linkAfter (self,v):

	"""Link self after v."""
	
	self._parent = v._parent
	self._back = v
	self._next = v._next
	v._next = self
	if self._next:
		self._next._back = self
#@-node:ekr.20031218072017.2355:v.linkAfter
#@+node:ekr.20031218072017.3425:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

	"""Links self as the n'th child of vnode pv"""

	v = self
	# g.trace(v,pv,n)
	v._parent = pv
	if n == 0:
		v._back = None
		v._next = pv.t._firstChild
		if pv.t._firstChild:
			pv.t._firstChild._back = v
		pv.t._firstChild = v
	else:
		prev = pv.nthChild(n-1) # zero based
		assert(prev)
		v._back = prev
		v._next = prev._next
		prev._next = v
		if v._next:
			v._next._back = v
#@nonl
#@-node:ekr.20031218072017.3425:v.linkAsNthChild
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link a vnode as the root node and set the root _position_."""

	v = self ; c = v.c

	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRoot
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot: oldRoot._back = v

	newRoot = position(v,[])
	c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

	"""Moves the receiver to the root position"""

	v = self

	v.unlink()
	v.linkAsRoot(oldRoot)
	
	return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

	"""Unlinks a vnode from the tree."""

	v = self ; c = v.c

	# g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
	
	# Special case the root.
	if v == c.rootPosition().v: # 3/11/04
		assert(v._next)
		newRoot = position(v._next,[])
		c.setRootPosition(newRoot)

	# Clear the links in other nodes.
	if v._back:
		v._back._next = v._next
	if v._next:
		v._next._back = v._back

	if v._parent and v == v._parent.t._firstChild:
		v._parent.t._firstChild = v._next

	# Clear the links in this node.
	v._parent = v._next = v._back = None
	# v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
#@+node:ekr.20031218072017.3384:Setters
#@+node:ekr.20031218072017.3386: v.Status bits
#@+node:ekr.20031218072017.3389:clearClonedBit
def clearClonedBit (self):

	self.statusBits &= ~ self.clonedBit
#@nonl
#@-node:ekr.20031218072017.3389:clearClonedBit
#@+node:ekr.20031218072017.3390:clearDirty & clearDirtyJoined (redundant code)
def clearDirty (self):

	v = self
	v.t.clearDirty()

def clearDirtyJoined (self):

	g.trace()
	v = self ; c = v.c
	c.beginUpdate()
	v.t.clearDirty()
	c.endUpdate() # recomputes all icons
#@nonl
#@-node:ekr.20031218072017.3390:clearDirty & clearDirtyJoined (redundant code)
#@+node:ekr.20031218072017.3391:clearMarked
def clearMarked (self):

	self.statusBits &= ~ self.markedBit
	g.doHook("clear-mark",c=self.c,v=self)
#@-node:ekr.20031218072017.3391:clearMarked
#@+node:ekr.20031218072017.3392:clearOrphan
def clearOrphan (self):

	self.statusBits &= ~ self.orphanBit
#@nonl
#@-node:ekr.20031218072017.3392:clearOrphan
#@+node:ekr.20031218072017.3393:clearVisited
def clearVisited (self):

	self.statusBits &= ~ self.visitedBit
#@nonl
#@-node:ekr.20031218072017.3393:clearVisited
#@+node:ekr.20031218072017.3395:contract & expand & initExpandedBit
def contract(self):

	self.statusBits &= ~ self.expandedBit

def expand(self):

	self.statusBits |= self.expandedBit

def initExpandedBit (self):

	self.statusBits |= self.expandedBit
#@nonl
#@-node:ekr.20031218072017.3395:contract & expand & initExpandedBit
#@+node:ekr.20031218072017.3396:initStatus
def initStatus (self, status):

	self.statusBits = status
#@nonl
#@-node:ekr.20031218072017.3396:initStatus
#@+node:ekr.20031218072017.3397:setClonedBit & initClonedBit
def setClonedBit (self):

	self.statusBits |= self.clonedBit

def initClonedBit (self, val):

	if val:
		self.statusBits |= self.clonedBit
	else:
		self.statusBits &= ~ self.clonedBit
#@nonl
#@-node:ekr.20031218072017.3397:setClonedBit & initClonedBit
#@+node:ekr.20031218072017.3398:setMarked & initMarkedBit
def setMarked (self):

	self.statusBits |= self.markedBit
	g.doHook("set-mark",c=self.c,v=self)

def initMarkedBit (self):

	self.statusBits |= self.markedBit
#@-node:ekr.20031218072017.3398:setMarked & initMarkedBit
#@+node:ekr.20031218072017.3399:setOrphan
def setOrphan (self):

	self.statusBits |= self.orphanBit
#@nonl
#@-node:ekr.20031218072017.3399:setOrphan
#@+node:ekr.20031218072017.3400:setSelected (vnode)
# This only sets the selected bit.

def setSelected (self):

	self.statusBits |= self.selectedBit
#@nonl
#@-node:ekr.20031218072017.3400:setSelected (vnode)
#@+node:ekr.20031218072017.3401:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

	self.statusBits |= self.visitedBit
#@nonl
#@-node:ekr.20031218072017.3401:t.setVisited
#@-node:ekr.20031218072017.3386: v.Status bits
#@+node:ekr.20031218072017.3385:v.computeIcon & setIcon
def computeIcon (self):

	val = 0 ; v = self
	if v.t.hasBody(): val += 1
	if v.isMarked(): val += 2
	if v.isCloned(): val += 4
	if v.isDirty(): val += 8
	return val
	
def setIcon (self):

	pass # Compatibility routine for old scripts
#@nonl
#@-node:ekr.20031218072017.3385:v.computeIcon & setIcon
#@+node:ekr.20040315032144:v.initHeadString
def initHeadString (self,s,encoding="utf-8"):
	
	v = self

	s = g.toUnicode(s,encoding,reportErrors=true)
	v.t.headString = s
#@nonl
#@-node:ekr.20040315032144:v.initHeadString
#@+node:ekr.20031218072017.3402:v.setSelection
def setSelection (self, start, length):

	self.t.setSelection ( start, length )
#@nonl
#@-node:ekr.20031218072017.3402:v.setSelection
#@+node:ekr.20040315042106:v.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
	
	return self.t.setTnodeText(s,encoding)
#@nonl
#@-node:ekr.20040315042106:v.setTnodeText
#@+node:ekr.20031218072017.3404:v.trimTrailingLines
def trimTrailingLines (self):

	"""Trims trailing blank lines from a node.
	
	It is surprising difficult to do this during Untangle."""

	v = self
	body = v.bodyString()
	# g.trace(body)
	lines = string.split(body,'\n')
	i = len(lines) - 1 ; changed = false
	while i >= 0:
		line = lines[i]
		j = g.skip_ws(line,0)
		if j + 1 == len(line):
			del lines[i]
			i -= 1 ; changed = true
		else: break
	if changed:
		body = string.join(body,'') + '\n' # Add back one last newline.
		# g.trace(body)
		v.setBodyStringOrPane(body)
		# Don't set the dirty bit: it would just be annoying.
#@-node:ekr.20031218072017.3404:v.trimTrailingLines
#@-node:ekr.20031218072017.3384:Setters
#@+node:ekr.20031218072017.3358:v.extraAttributes & setExtraAttributes
def extraAttributes (self):

	# New in 4.2: tnode list is in tnode.
	try:    tnodeList = self.t.tnodeList
	except: tnodeList = None
	
	try:    unknownAttributes = self.unknownAttributes
	except: unknownAttributes = None

	return tnodeList, unknownAttributes
	
def setExtraAttributes (self,data):
	
	tnodeList, unknownAttributes = data

	if tnodeList != None:
		self.tnodeList = tnodeList

	if unknownAttributes != None:
		self.unknownAttributes = unknownAttributes
#@nonl
#@-node:ekr.20031218072017.3358:v.extraAttributes & setExtraAttributes
#@-node:ekr.20031218072017.3341:class vnode
#@+node:ekr.20031218072017.889:class position
# Warning: this code implies substantial changes to code that uses them, both core and scripts.

class position (object):
	
	"""A class representing a position in a traversal of a tree containing shared tnodes."""

	<< about the position class >>
	
	@others
#@+node:ekr.20040228094013: ctor & other special methods...
#@+node:ekr.20031218072017.892:p.__init__
def __init__ (self,v,stack):

	"""Create a new position."""
	
	if v: self.c = v.c
	else: self.c = g.top()
	self.v = v
	assert(v is None or v.t)
	self.stack = stack[:] # Creating a copy here is safest and best.
	
	# Note: __getattr__ implements p.t.
#@nonl
#@-node:ekr.20031218072017.892:p.__init__
#@+node:ekr.20031218072017.893:p.__cmp__
def __cmp__(self,p2):

	"""Return 0 if two postions are equivalent."""

	# Use p.equal if speed is crucial.
	p1 = self

	if p2 is None: # Allow tests like "p == None"
		if p1.v: return 1 # not equal
		else:    return 0 # equal

	# Check entire stack quickly.
	# The stack contains vnodes, so this is not a recursive call.
	if p1.v != p2.v or p1.stack != p2.stack:
		return 1 # notEqual

	# This is slow: do this last!
	if p1.childIndex() != p2.childIndex():
		# Disambiguate clones having the same parents.
		return 1 # notEqual

	return 0 # equal
#@nonl
#@-node:ekr.20031218072017.893:p.__cmp__
#@+node:ekr.20040325142015:p.equal
def equal(self,p2):

	"""Return true if two postions are equivalent.
	
	Use this method when the speed comparisons is crucial
	
	N.B. Unlike __cmp__, p2 must not be None."""

	p1 = self
	
	# if g.app.trace: "equal",p1.v,p2.v

	# Check entire stack quickly.
	# The stack contains vnodes, so this does not call p.__cmp__.
	return (
		p1.v == p2.v and
		p1.stack == p2.stack and
		p1.childIndex() == p2.childIndex())
#@nonl
#@-node:ekr.20040325142015:p.equal
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

	def __getattr__ (self,attr):
		
		"""Convert references to p.t into references to p.v.t.
		
		N.B. This automatically keeps p.t in synch with p.v.t."""

		if attr=="t":
			return self.v.t
		else:
			# Only called when normal lookup fails.
			raise AttributeError
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20040117173448:p.__nonzero__
@
The test "if p" is the _only_ correct way to test whether a position p is valid.
In particular, tests like "if p is None" or "if p is not None" will not work properly.
@c

def __nonzero__ ( self):
	
	"""Return true if a position is valid."""
	
	# if g.app.trace: "__nonzero__",self.v

	return self.v is not None
#@nonl
#@-node:ekr.20040117173448:p.__nonzero__
#@+node:ekr.20040301205720:p.__str__ and p.__repr__
def __str__ (self):
	
	p = self
	
	if p.v:
		return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.v.headString())
	else:
		return "<pos %d        [%d] None>" % (id(p),len(p.stack))
		
__repr__ = __str__
#@nonl
#@-node:ekr.20040301205720:p.__str__ and p.__repr__
#@+node:ekr.20040310153624:p.dump & p.vnodeListIds
def dumpLink (self,link):

	return g.choose(link,link,"<none>")

def dump (self,label=""):
	
	p = self

	print '-'*10,label,p

	if p.v:
		p.v.dump() # Don't print a label
		
def vnodeListIds (self):
	
	p = self
	return [id(v) for v in p.v.t.vnodeList]
#@nonl
#@-node:ekr.20040310153624:p.dump & p.vnodeListIds
#@-node:ekr.20040228094013: ctor & other special methods...
#@+node:ekr.20031218072017.890:<< about the position class >>
@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible, p.hasThreadNext and p.vThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.
#@nonl
#@-node:ekr.20031218072017.890:<< about the position class >>
#@+node:ekr.20040306212636:Getters
#@+node:ekr.20040306210951: vnode proxies
#@+node:ekr.20040306211032:p.Comparisons
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@nonl
#@-node:ekr.20040306211032:p.Comparisons
#@+node:ekr.20040306212151:p.Extra Attributes
def extraAttributes (self):
	
	return self.v.extraAttributes()

def setExtraAttributes (self,data):

	return self.v.setExtraAttributes(data)
#@nonl
#@-node:ekr.20040306212151:p.Extra Attributes
#@+node:ekr.20040306220230:p.Headline & body strings
def bodyString (self):
	
	return self.v.bodyString()

def headString (self):
	
	return self.v.headString()
	
def cleanHeadString (self):
	
	return self.v.cleanHeadString()
#@-node:ekr.20040306220230:p.Headline & body strings
#@+node:ekr.20040306214401:p.Status bits
def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()
#@nonl
#@-node:ekr.20040306214401:p.Status bits
#@+node:ekr.20040306220230.1:p.edit_text
def edit_text (self):
	
	p = self
	
	if self.c:
		# New in 4.2: the dictionary is a list of pairs(p,v)
		pairs = self.c.frame.tree.getEditTextDict(p.v)
		for p2,t2 in pairs:
			if p.equal(p2):
				# g.trace("found",t2)
				return t2
		return None
	else:
		return None
#@nonl
#@-node:ekr.20040306220230.1:p.edit_text
#@+node:ekr.20040323160302:p.directParents
def directParents (self):
	
	return self.v.directParents()
#@-node:ekr.20040323160302:p.directParents
#@+node:ekr.20040326064330:p.childIndex
def childIndex(self):
	
	p = self ; v = p.v
	
	# This is time-critical code!
	
	# 3/25/04: Much faster code:
	if not v or not v._back:
		return 0

	n = 0 ; v = v._back
	while v:
		n += 1
		v = v._back

	return n
#@nonl
#@-node:ekr.20040326064330:p.childIndex
#@-node:ekr.20040306210951: vnode proxies
#@+node:ekr.20040306214240.2:children
#@+node:ekr.20040306214240.3:p.hasChildren
def hasChildren(self):
	
	p = self
	# g.trace(p,p.v)
	return p.v and p.v.t and p.v.t._firstChild
#@nonl
#@-node:ekr.20040306214240.3:p.hasChildren
#@+node:ekr.20040306212636.1:p.numberOfChildren
def numberOfChildren (self):
	
	return self.v.numberOfChildren()
#@-node:ekr.20040306212636.1:p.numberOfChildren
#@-node:ekr.20040306214240.2:children
#@+node:ekr.20040307104131.3:p.exists
def exists(self,c):
	
	"""Return true if a position exists in c's tree"""
	
	p = self.copy()
	
	# This code must be fast.
	root = c.rootPosition()
	while p:
		if p == root:
			return true
		if p.hasParent():
			p.moveToParent()
		else:
			p.moveToBack()
		
	return false
#@nonl
#@-node:ekr.20040307104131.3:p.exists
#@+node:ekr.20040306215548:p.findRoot
def findRoot (self):
	
	return self.c.frame.rootPosition()
#@nonl
#@-node:ekr.20040306215548:p.findRoot
#@+node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@nonl
#@-node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
#@+node:ekr.20040227212621:p.hasX
def hasBack(self):
	return self.v and self.v._back

hasFirstChild = hasChildren
	
def hasNext(self):
	return self.v and self.v._next
	
def hasParent(self):
	return self.v and self.v._parent is not None
	
def hasThreadBack(self):
	return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
	
hasVisBack = hasThreadBack
#@nonl
#@+node:ekr.20040227224946:hasThreadNext (the only complex hasX method)
def hasThreadNext(self):

	p = self ; v = p.v
	if not p.v: return false

	if v.t._firstChild or v._next:
		return true
	else:
		n = len(p.stack)-1
		v,n = p.vParentWithStack(v,p.stack,n)
		while v:
			if v._next:
				return true
			v,n = p.vParentWithStack(v,p.stack,n)
		return false

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20040227224946:hasThreadNext (the only complex hasX method)
#@-node:ekr.20040227212621:p.hasX
#@+node:ekr.20040307104131.1:p.isAncestorOf
def isAncestorOf (self, p2):
	
	p = self
	
	if 0: # Avoid the copies made in the iterator.
		for p3 in p2.parents_iter():
			if p3 == p:
				return true

	# Avoid calling p.copy() or copying the stack.
 	v2 = p2.v ; n = len(p.stack)-1
	v2,n = p2.vParentWithStack(v2,p2.stack,n)
	while v2:
		if v2 == p.v:
			return true
		v2,n = p2.vParentWithStack(v2,p2.stack,n)

	return false
#@nonl
#@-node:ekr.20040307104131.1:p.isAncestorOf
#@+node:ekr.20040306215056:p.isCloned
def isCloned (self):
	
	return len(self.v.t.vnodeList) > 1
#@nonl
#@-node:ekr.20040306215056:p.isCloned
#@+node:ekr.20040307104131.2:p.isRoot
def isRoot (self):
	
	p = self

	return not p.hasParent() and not p.hasBack()
#@nonl
#@-node:ekr.20040307104131.2:p.isRoot
#@+node:ekr.20040117162509.16:p.isVisible
def isVisible (self):
	
	"""Return true if all of a position's parents are expanded."""

	# v.isVisible no longer exists.
	p = self

	# Avoid calling p.copy() or copying the stack.
	v = p.v ; n = len(p.stack)-1

	v,n = p.vParentWithStack(v,p.stack,n)
	while v:
		if not v.isExpanded():
			return false
		v,n = p.vParentWithStack(v,p.stack,n)

	return true
#@nonl
#@-node:ekr.20040117162509.16:p.isVisible
#@+node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
def oldLastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	assert(p.isVisible())
	last = p.copy()
	while 1:
		if g.app.debug: g.trace(last)
		p.moveToVisNext()
		if not p: return last
		last = p.copy()
		
def lastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	# Move to the last top-level node.
	while p.hasNext():
		if g.app.debug: g.trace(p)
		p.moveToNext()
	assert(p.isVisible())
	# Move to the last visible child.
	while p.hasChildren() and p.isExpanded():
		if g.app.debug: g.trace(p)
		p.moveToLastChild()
	assert(p.isVisible())
	if g.app.debug: g.trace(p)
	return p
#@nonl
#@-node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
#@+node:ekr.20040227214711:p.level & simpleLevel
def simpleLevel(self):
	
	p = self ; level = 0
	for parent in p.parents_iter():
		level += 1
	return level

def level(self,verbose=false):
	
	# if g.app.debug: simpleLevel = self.simpleLevel()
	
	p = self ; level = 0
	if not p: return level
		
	# Avoid calling p.copy() or copying the stack.
	v = p.v ; n = len(p.stack)-1
	while 1:
		assert(p)
		v,n = p.vParentWithStack(v,p.stack,n)
		if v:
			level += 1
			if verbose: g.trace(level,"level,n: %2d" % (level,n))
		else:
			if verbose: g.trace(level,"level,n: %2d" % (level,n))
			# if g.app.debug: assert(level==simpleLevel)
			return level
#@nonl
#@-node:ekr.20040227214711:p.level & simpleLevel
#@-node:ekr.20040306212636:Getters
#@+node:ekr.20040305222924:Setters
#@+node:ekr.20040306220634:vnode proxies
#@+node:ekr.20040306220634.9: Status bits
# Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self): return self.v.clearMarked()
def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus()
	
def setMarked   (self): return self.v.setMarked()
def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()
#@nonl
#@-node:ekr.20040306220634.9: Status bits
#@+node:ekr.20040306220634.8:p.computeIcon & p.setIcon
def computeIcon (self):
	
	return self.v.computeIcon()
	
def setIcon (self):

	pass # Compatibility routine for old scripts
#@nonl
#@-node:ekr.20040306220634.8:p.computeIcon & p.setIcon
#@+node:ekr.20040306220634.29:p.setSelection
def setSelection (self,start,length):

	return self.v.setSelection(start,length)
#@nonl
#@-node:ekr.20040306220634.29:p.setSelection
#@+node:ekr.20040306220634.31:p.trimTrailingLines
def trimTrailingLines (self):

	return self.v.trimTrailingLines()
#@nonl
#@-node:ekr.20040306220634.31:p.trimTrailingLines
#@+node:ekr.20040315034158:p.setTnodeText
def setTnodeText (self,s,encoding="utf-8"):
	
	return self.v.setTnodeText(s,encoding)
#@nonl
#@-node:ekr.20040315034158:p.setTnodeText
#@-node:ekr.20040306220634:vnode proxies
#@+node:ekr.20040315031401:Head & body text (position)
#@+node:ekr.20040315032503:p.appendStringToBody
def appendStringToBody (self,s,encoding="utf-8"):
	
	p = self
	if not s: return
	
	body = p.bodyString()
	assert(g.isUnicode(body))
	s = g.toUnicode(s,encoding)

	p.setBodyStringOrPane(body + s,encoding)
#@nonl
#@-node:ekr.20040315032503:p.appendStringToBody
#@+node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
def setBodyStringOrPane (self,s,encoding="utf-8"):

	p = self ; v = p.v ; c = p.c
	if not c or not v: return

	s = g.toUnicode(s,encoding)
	if p == c.currentPosition():
		# This code destoys all tags, so we must recolor.
		c.frame.body.setSelectionAreas(s,None,None)
		c.recolor()
		
	# Keep the body text in the tnode up-to-date.
	if v.t.bodyString != s:
		v.setTnodeText(s)
		v.t.setSelection(0,0)
		p.setDirty()
		if not c.isChanged():
			c.setChanged(true)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts
#@nonl
#@-node:ekr.20040305223522:p.setBodyStringOrPane & p.setBodyTextOrPane
#@+node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
def setHeadString (self,s,encoding="utf-8"):
	
	p = self
	p.v.initHeadString(s,encoding)
	p.setDirty()
	
def initHeadString (self,s,encoding="utf-8"):
	
	p = self
	p.v.initHeadString(s,encoding)
#@-node:ekr.20040305222924.1:p.setHeadString & p.initHeadString
#@+node:ekr.20040305223225:p.setHeadStringOrHeadline
def setHeadStringOrHeadline (self,s,encoding="utf-8"):

	p = self

	p.c.endEditing()
	p.v.initHeadString(s,encoding)
	p.setDirty()
#@nonl
#@-node:ekr.20040305223225:p.setHeadStringOrHeadline
#@+node:ekr.20040315031445:p.scriptSetBodyString
def scriptSetBodyString (self,s,encoding="utf-8"):
	
	"""Update the body string for the receiver.
	
	Should be called only from scripts: does NOT update body text."""

	self.v.t.bodyString = g.toUnicode(s,encoding)
#@nonl
#@-node:ekr.20040315031445:p.scriptSetBodyString
#@-node:ekr.20040315031401:Head & body text (position)
#@+node:ekr.20040312015908:Visited bits
#@+node:ekr.20040312015705:p.clearAllVisited
# Compatibility routine for scripts.

def clearAllVisited (self):
	
	for p in self.allNodes_iter():
		p.clearVisited()
#@nonl
#@-node:ekr.20040312015705:p.clearAllVisited
#@+node:ekr.20040306220634.17:p.clearVisitedInTree
# Compatibility routine for scripts.

def clearVisitedInTree (self):
	
	for p in self.self_and_subtree_iter():
		p.clearVisited()
#@-node:ekr.20040306220634.17:p.clearVisitedInTree
#@+node:ekr.20031218072017.3388:p.clearAllVisitedInTree (4.2)
def clearAllVisitedInTree (self):
	
	for p in self.self_and_subtree_iter():
		p.v.clearVisited()
		p.v.t.clearVisited()
		p.v.t.clearWriteBit()
#@nonl
#@-node:ekr.20031218072017.3388:p.clearAllVisitedInTree (4.2)
#@-node:ekr.20040312015908:Visited bits
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

	p = self
	p.v.clearDirty()
#@nonl
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040303163717:p.isDirty
def isDirty (self):
	
	p = self
	return p.v and p.v.isDirty()
#@nonl
#@-node:ekr.20040303163717:p.isDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
	
	p = self
	
	# Start with all nodes in the vnodeList.
	nodes = []
	newNodes = p.v.t.vnodeList[:]

	# Add nodes until no more are added.
	while newNodes:
		# g.trace(len(newNodes))
		addedNodes = []
		nodes.extend(newNodes)
		for v in newNodes:
			for v2 in v.t.vnodeList:
				if v2 not in nodes and v2 not in addedNodes:
					addedNodes.append(v2)
				for v3 in v2.directParents(): # 3/23/04
					if v3 not in nodes and v3 not in addedNodes:
						addedNodes.append(v3)
		newNodes = addedNodes[:]

	# g.trace(nodes)
	return nodes
#@nonl
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self):

	p = self ; c = p.c
	changed = false
	
	# Calculate all nodes that are joined to v or parents of such nodes.
	nodes = p.findAllPotentiallyDirtyNodes()
	
	c.beginUpdate()
	if 1: # update...
		for v in nodes:
			# g.trace(v.isAnyAtFileNode(),v.t.isDirty(),v)
			if not v.t.isDirty() and v.isAnyAtFileNode():
				changed = true
				v.t.setDirty() # Do not call v.setDirty here!
	c.endUpdate(changed)
	return changed
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
# Ensures that all ancestor @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self):

	p = self ; c = p.c

	c.beginUpdate()
	if 1: # update...
		changed = false
		if not p.v.t.isDirty():
			p.v.t.setDirty()
			changed = true
		# This must be called even if p.v is already dirty.
		if p.setAllAncestorAtFileNodesDirty():
			changed = true
	c.endUpdate(changed)

	return changed
#@nonl
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@-node:ekr.20040305222924:Setters
#@+node:ekr.20040315023430:File Conversion
@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
#@+node:ekr.20040315023430.1:convertTreeToString
def convertTreeToString (self):
	
	"""Convert a positions  suboutline to a string in MORE format."""

	p = self ; level1 = p.level()
	
	g.trace()
	
	array = []
	for p in p.self_and_subtree_iter():
		array.append(p.moreHead(level1)+'\n')
		body = p.moreBody()
		if body:
			array.append(body +'\n')

	return ''.join(array)
#@-node:ekr.20040315023430.1:convertTreeToString
#@+node:ekr.20040315023430.2:moreHead
def moreHead (self, firstLevel,useVerticalBar=false):
	
	"""Return the headline string in MORE format."""

	p = self

	level = self.level() - firstLevel
	plusMinus = g.choose(p.hasChildren(), "+", "-")
	
	return "%s%s %s" % ('\t'*level,plusMinus,p.headString())
#@nonl
#@-node:ekr.20040315023430.2:moreHead
#@+node:ekr.20040315023430.3:moreBody
@ 
	+ test line
	- test line
	\ test line
	test line +
	test line -
	test line \
	More lines...
@c

def moreBody (self):

	"""Returns the body string in MORE format.  
	
	Inserts a backslash before any leading plus, minus or backslash."""

	p = self ; array = []
	lines = string.split(p.bodyString(),'\n')
	for s in lines:
		i = g.skip_ws(s,0)
		if i < len(s) and s[i] in ('+','-','\\'):
			s = s[:i] + '\\' + s[i:]
		array.append(s)
	return '\n'.join(array)
#@nonl
#@-node:ekr.20040315023430.3:moreBody
#@-node:ekr.20040315023430:File Conversion
#@+node:ekr.20040305162628.1:p.Iterators
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:ekr.20040305171133:allNodes_iter
class allNodes_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def allNodes_iter (self,copy=false):
	
	return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305171133.1:__init__ & __iter__
def __init__(self,p,copy):

	self.first = p.c.rootPosition().copy()
	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305171133.1:__init__ & __iter__
#@+node:ekr.20040305171133.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:allNodes_iter
#@+node:ekr.20040305173559:subtree_iter
class subtree_iter_class:

	"""Returns a list of positions in a subtree, possibly including the root of the subtree."""

	@others

def subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=false)
	
def self_and_subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
	
	if includeSelf:
		self.first = p.copy()
		self.after = p.nodeAfterTree()
	elif p.hasChildren():
		self.first = p.copy().moveToFirstChild() 
		self.after = p.nodeAfterTree()
	else:
		self.first = None
		self.after = None

	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p and self.p != self.after:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:subtree_iter
#@+node:ekr.20040305172211.1:children_iter
class children_iter_class:

	"""Returns a list of children of a position."""

	@others

def children_iter (self,copy=false):
	
	return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

	if p.hasChildren():
		self.first = p.copy().moveToFirstChild()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:children_iter
#@+node:ekr.20040305172855:parents_iter
class parents_iter_class:

	"""Returns a list of positions of a position."""

	@others

def parents_iter (self,copy=false):
	
	p = self

	return self.parents_iter_class(self,copy,includeSelf=false)
	
def self_and_parents_iter(self,copy=false):
	
	return self.parents_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

	if includeSelf:
		self.first = p.copy()
	elif p.hasParent():
		self.first = p.copy().moveToParent()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):

	return self
#@nonl
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToParent()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:parents_iter
#@+node:ekr.20040305173343:siblings_iter
class siblings_iter_class:

	"""Returns a list of siblings of a position."""

	@others

def siblings_iter (self,copy=false,following=false):
	
	return self.siblings_iter_class(self,copy,following)
	
self_and_siblings_iter = siblings_iter
	
def following_siblings_iter (self,copy=false):
	
	return self.siblings_iter_class(self,copy,following=true)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
	
	# We always include p, even if following is true.
	
	if following:
		self.first = p.copy()
	else:
		p = p.copy()
		while p.hasBack():
			p.moveToBack()
		self.first = p

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20040303175026:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

	"""Deletes position p from the outline.  May be undone.

	Returns newPosition."""

	p = self ; c = p.c

	assert(newPosition != p)
	p.setDirty() # Mark @file nodes dirty!
	p.unlink()
	p.deleteLinksInTree()
	c.selectVnode(newPosition)
	
	return newPosition

#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040303175026.3:p.insertAfter
def insertAfter (self,t=None):

	"""Inserts a new vnode after self.
	
	Returns the newly created position."""
	
	p = self ; c = p.c
	p2 = self.copy()

	if not t:
		t = tnode(headString="NewHeadline")

	p2.v = vnode(c,t)
	p2.v.iconVal = 0
	p2.linkAfter(p)

	return p2
#@nonl
#@-node:ekr.20040303175026.3:p.insertAfter
#@+node:ekr.20040303175026.4:p.insertAsLastChild
def insertAsLastChild (self,t=None):

	"""Inserts a new vnode as the last child of self.
	
	Returns the newly created position."""
	
	p = self
	n = p.numberOfChildren()

	if not t:
		t = tnode(headString="NewHeadline")
	
	return p.insertAsNthChild(n,t)
#@nonl
#@-node:ekr.20040303175026.4:p.insertAsLastChild
#@+node:ekr.20040303175026.5:p.insertAsNthChild
def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of self.
	self must have at least n-1 children.
	
	Returns the newly created position."""
	
	p = self ; c = p.c
	p2 = self.copy()

	if not t:
		t = tnode(headString="NewHeadline")
	
	p2.v = vnode(c,t)
	p2.v.iconVal = 0
	p2.linkAsNthChild(p,n)

	return p2
#@nonl
#@-node:ekr.20040303175026.5:p.insertAsNthChild
#@+node:ekr.20040303175026.6:p.moveToRoot
def moveToRoot (self,oldRoot=None):

	"""Moves a position to the root position."""

	p = self # Do NOT copy the position!
	p.unlink()
	p.linkAsRoot(oldRoot)
	
	return p
#@nonl
#@-node:ekr.20040303175026.6:p.moveToRoot
#@+node:ekr.20040303175026.8:p.clone
def clone (self,back):
	
	"""Create a clone of back.
	
	Returns the newly created position."""
	
	p = self ; c = p.c

	p2 = back.copy()
	p2.v = vnode(c,back.v.t)
	p2.linkAfter(back)

	return p2
#@nonl
#@-node:ekr.20040303175026.8:p.clone
#@+node:ekr.20040303175026.9:p.copyTreeWithNewTnodes: used by unit tests TO DO
if 0: # Not yet.

	def copyTreeWithNewTnodes (self):
		
		"""Return a copy of self with all new tnodes"""
		
		c = self.c
		
		# Create the root node.
		old_v = self
		new_v = vnode(c,tnode())
		new_v.t.headString = old_v.t.headString
		new_v.t.bodyString = old_v.t.bodyString
		
		# Recursively create all descendents.
		old_child = old_v.firstChild() ; n = 0
		while old_child:
			new_child = old_child.copyTreeWithNewTnodes()
			new_child.linkAsNthChild (new_v, n)
			n += 1
			old_child = old_child.next()
			
		# Return the root of the new tree.
		return new_v
#@nonl
#@-node:ekr.20040303175026.9:p.copyTreeWithNewTnodes: used by unit tests TO DO
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

	"""Move a position after position a."""
	
	p = self ; c = p.c # Do NOT copy the position!
	p.unlink()
	p.linkAfter(a)
	
	# Moving a node after another node can create a new root node.
	if not a.hasParent() and not a.hasBack():
		c.setRootPosition(a)

	return p
#@nonl
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20040306060312:p.moveToLastChildOf
def moveToLastChildOf (self,parent):

	"""Move a position to the last child of parent."""

	p = self # Do NOT copy the position!

	p.unlink()
	n = p.numberOfChildren()
	p.linkAsNthChild(parent,n)

	# Moving a node can create a new root node.
	if not parent.hasParent() and not parent.hasBack():
		p.c.setRootPosition(parent)
		
	return p
#@-node:ekr.20040306060312:p.moveToLastChildOf
#@+node:ekr.20040303175026.11:p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

	"""Move a position to the nth child of parent."""

	p = self ; c = p.c # Do NOT copy the position!
	
	# g.trace(p,parent,n)

	p.unlink()
	p.linkAsNthChild(parent,n)
	
	# Moving a node can create a new root node.
	if not parent.hasParent() and not parent.hasBack():
		c.setRootPosition(parent)

	return p
#@-node:ekr.20040303175026.11:p.moveToNthChildOf
#@+node:ekr.20040303175026.12:p.sortChildren
def sortChildren (self):
	
	p = self

	# Create a list of (headline,position) tuples
	pairs = []
	for child in p.children_iter():
		pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

	# Sort the list on the headlines.
	pairs.sort()

	# Move the children.
	index = 0
	for headline,child in pairs:
		child.moveToNthChildOf(p,index)
		index += 1
#@nonl
#@-node:ekr.20040303175026.12:p.sortChildren
#@+node:ekr.20040303175026.13:p.validateOutlineWithParent
# This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
	
	p = self
	result = true # optimists get only unpleasant surprises.
	parent = p.getParent()
	childIndex = p.childIndex()
	
	# g.trace(p,parent,pv)
	<< validate parent ivar >>
	<< validate childIndex ivar >>
	<< validate x ivar >>

	# Recursively validate all the children.
	for child in p.children_iter():
		r = child.validateOutlineWithParent(p)
		if not r: result = false

	return result
#@nonl
#@+node:ekr.20040303175026.14:<< validate parent ivar >>
if parent != pv:
	p.invalidOutline( "Invalid parent link: " + repr(parent))
#@nonl
#@-node:ekr.20040303175026.14:<< validate parent ivar >>
#@+node:ekr.20040303175026.15:<< validate childIndex ivar >>
if pv:
	if childIndex < 0:
		p.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex >= pv.numberOfChildren():
		p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex < 0:
	p.invalidOutline ( "negative childIndex" + childIndex )
#@nonl
#@-node:ekr.20040303175026.15:<< validate childIndex ivar >>
#@+node:ekr.20040303175026.16:<< validate x ivar >>
if not p.v.t and pv:
	self.invalidOutline ( "Empty t" )
#@nonl
#@-node:ekr.20040303175026.16:<< validate x ivar >>
#@-node:ekr.20040303175026.13:p.validateOutlineWithParent
#@+node:ekr.20040303175026.18:p.invalidOutline
def invalidOutline (self, message):

	s = "invalid outline: " + message + "\n"
	parent = self.getParent()

	if parent:
		s += repr(parent)
	else:
		s += repr(self)

	g.alert(s)
#@nonl
#@-node:ekr.20040303175026.18:p.invalidOutline
#@-node:ekr.20040303175026:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20031218072017.928:p.moveToX
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
	after = p.copy().moveToNodeAfterTree()
#@nonl
#@+node:ekr.20031218072017.930:p.moveToBack
def moveToBack (self):
	
	"""Move self to its previous sibling."""
	
	p = self

	p.v = p.v and p.v._back
	
	return p
#@nonl
#@-node:ekr.20031218072017.930:p.moveToBack
#@+node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
def moveToFirstChild (self):

	"""Move a position to it's first child's position."""
	
	p = self

	if p:
		child = p.v.t._firstChild
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
		
	return p

#@-node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
def moveToLastChild (self):
	
	"""Move a position to it's last child's position."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			child = p.v.lastChild()
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@-node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
def moveToLastNode (self):
	
	"""Move a position to last node of its tree.
	
	N.B. Returns p if p has no children."""
	
	p = self
	
	# Huge improvement for 4.2.
	while p.hasChildren():
		p.moveToLastChild()

	return p
#@nonl
#@-node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
#@+node:ekr.20031218072017.934:p.moveToNext
def moveToNext (self):
	
	"""Move a position to its next sibling."""
	
	p = self
	
	p.v = p.v and p.v._next
	
	return p
#@nonl
#@-node:ekr.20031218072017.934:p.moveToNext
#@+node:ekr.20031218072017.935:p.moveToNodeAfterTree
def moveToNodeAfterTree (self):
	
	"""Move a position to the node after the position's tree."""
	
	p = self
	
	while p:
		if p.hasNext():
			p.moveToNext()
			break
		p.moveToParent()

	return p
#@-node:ekr.20031218072017.935:p.moveToNodeAfterTree
#@+node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
def moveToNthChild (self,n):
	
	p = self
	
	if p:
		child = p.v.nthChild(n) # Must call vnode method here!
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@nonl
#@-node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self
	
	# if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

	if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
		# g.trace("pop",p.v,p)
	else:
		p.v = None

	return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20031218072017.938:p.moveToThreadBack
def moveToThreadBack (self):
	
	"""Move a position to it's threadBack position."""

	p = self

	if p.hasBack():
		p.moveToBack()
		p.moveToLastNode()
	else:
		p.moveToParent()

	return p
#@nonl
#@-node:ekr.20031218072017.938:p.moveToThreadBack
#@+node:ekr.20031218072017.939:p.moveToThreadNext
def moveToThreadNext (self):
	
	"""Move a position to the next a position in threading order."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			p.moveToFirstChild()
		elif p.v._next:
			p.moveToNext()
		else:
			p.moveToParent()
			while p:
				if p.v._next:
					p.moveToNext()
					break #found
				p.moveToParent()
			# not found.
				
	return p
#@nonl
#@-node:ekr.20031218072017.939:p.moveToThreadNext
#@+node:ekr.20031218072017.940:p.moveToVisBack
def moveToVisBack (self):
	
	"""Move a position to the position of the previous visible node."""

	p = self
	
	if p:
		p.moveToThreadBack()
		while p and not p.isVisible():
			p.moveToThreadBack()

	assert(not p or p.isVisible())
	return p
#@nonl
#@-node:ekr.20031218072017.940:p.moveToVisBack
#@+node:ekr.20031218072017.941:p.moveToVisNext
def moveToVisNext (self):
	
	"""Move a position to the position of the next visible node."""

	p = self

	p.moveToThreadNext()
	while p and not p.isVisible():
		p.moveToThreadNext()
			
	return p
#@nonl
#@-node:ekr.20031218072017.941:p.moveToVisNext
#@-node:ekr.20031218072017.928:p.moveToX
#@+node:ekr.20040228094013.1:p.utils...
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
	
	""""Return an independent copy of a position."""
	
	g.app.copies += 1

	return position(self.v,self.stack)
#@nonl
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
	
	"""A utility that allows the computation of p.v without calling p.copy().
	
	v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

	Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

	if not v:
		return None,n
	elif v._parent and len(v._parent.t.vnodeList) == 1:
		return v._parent,n # don't change stack.
	elif stack and n >= 0:
		return self.stack[n],n-1 # simulate popping the stack.
	else:
		return None,n
#@nonl
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
	p = p.moveToParent()
	if p: list1.append(p.v)
# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
	list2.append(v)
	v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@+node:ekr.20040409203454:p.restoreLinksInTree
def restoreLinksInTree (self):

	"""Restore links when undoing a delete node operation."""
	
	root = p = self

	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
		
	for p in root.children_iter():
		p.restoreLinksInTree()
#@nonl
#@-node:ekr.20040409203454:p.restoreLinksInTree
#@+node:ekr.20040409203454.1:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
	
	"""Delete and otherwise adjust links when deleting node."""
	
	root = self

	root.deleteLinksInSubtree()
	
	for p in root.children_iter():
		p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20040410170806:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

	root = p = self

	# Delete p.v from the vnodeList
	if p.v in p.v.t.vnodeList:
		p.v.t.vnodeList.remove(p.v)
		assert(p.v not in p.v.t.vnodeList)
		# g.trace("deleted",p.v,p.vnodeListIds())
	else:
		# g.trace("not in vnodeList",p.v,p.vnodeListIds())
		pass

	if len(p.v.t.vnodeList) == 0:
		# This node is not shared by other nodes.
		for p in root.children_iter():
			p.deleteLinksInSubtree()
#@nonl
#@-node:ekr.20040410170806:p.deleteLinksInSubtree
#@+node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):
	
	root = p = self
	
	assert(parent)
	
	if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
		p.v._parent = parent.v.t.vnodeList[0]
		
	for p in root.children_iter():
		p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@-node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
#@-node:ekr.20040409203454.1:p.deleteLinksInTree & allies
#@-node:ekr.20040228094013.1:p.utils...
#@+node:ekr.20040310062332:p.Link/Unlink methods
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@nonl
#@+node:ekr.20040310062332.1:p.invalidOutline
def invalidOutline (self, message):
	
	p = self

	if p.hasParent():
		node = p.parent()
	else:
		node = p

	g.alert("invalid outline: %s\n%s" % (message,node))
#@nonl
#@-node:ekr.20040310062332.1:p.invalidOutline
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

	"""Link self after v."""
	
	p = self
	# g.trace(p,after)
	
	p.stack = after.stack[:] # 3/12/04
	p.v._parent = after.v._parent
	
	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
	
	p.v._back = after.v
	p.v._next = after.v._next
	
	after.v._next = p.v
	
	if p.v._next:
		p.v._next._back = p.v

	if 0:
		g.trace('-'*20,after)
		p.dump(label="p")
		after.dump(label="back")
		if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20040310062332.3:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

	"""Links self as the n'th child of vnode pv"""
	
	# g.trace(self,parent,n)
	p = self

	# Recreate the stack using the parent.
	p.stack = parent.stack[:] 
	if parent.isCloned():
		p.stack.append(parent.v)

	p.v._parent = parent.v

	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)

	if n == 0:
		child1 = parent.v.t._firstChild
		p.v._back = None
		p.v._next = child1
		if child1:
			child1._back = p.v
		parent.v.t._firstChild = p.v
	else:
		prev = parent.nthChild(n-1) # zero based
		assert(prev)
		p.v._back = prev.v
		p.v._next = prev.v._next
		prev.v._next = p.v
		if p.v._next:
			p.v._next._back = p.v
			
	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.3:p.linkAsNthChild
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link self as the root node."""
	
	# g.trace(self,oldRoot)

	p = self ; v = p.v
	if oldRoot: oldRootVnode = oldRoot.v
	else:       oldRootVnode = None
	
	p.stack = [] # Clear the stack.
	
	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRootVnode # Bug fix: 3/12/04
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot:
		oldRoot.v._back = v # Bug fix: 3/12/04

	p.c.setRootPosition(p)
	
	if 0:
		p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

	"""Unlinks a position p from the tree before moving or deleting.
	
	The p.v._fistChild link does NOT change."""

	p = self ; v = p.v ; parent = p.parent()
	
	# Note:  p.parent() is not necessarily the same as v._parent.
	
	if parent:
		assert(p.v and p.v._parent in p.v.directParents())
		assert(parent.v in p.v.directParents())

	# g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
	
	# Special case the root.
	if p == p.c.rootPosition():
		assert(p.v._next)
		p.c.setRootPosition(p.next())
	
	# Remove v from it's tnode's vnodeList.
	vnodeList = v.t.vnodeList
	if v in vnodeList:
		vnodeList.remove(v)
	assert(v not in vnodeList)
	
	# Reset the firstChild link in its direct father.
	if parent and parent.v.t._firstChild == v:
		parent.v.t._firstChild = v._next

	# Do _not_ delete the links in any child nodes.

	# Clear the links in other nodes.
	if v._back: v._back._next = v._next
	if v._next: v._next._back = v._back

	# Unlink _this_ node.
	v._parent = v._next = v._back = None

	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		if parent: parent.dump(label="parent")
#@-node:ekr.20040310062332.5:p.unlink
#@-node:ekr.20040310062332:p.Link/Unlink methods
#@-node:ekr.20031218072017.889:class position
#@+node:ekr.20040305162628.1:p.Iterators
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:ekr.20040305171133:allNodes_iter
class allNodes_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def allNodes_iter (self,copy=false):
	
	return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305171133.1:__init__ & __iter__
def __init__(self,p,copy):

	self.first = p.c.rootPosition().copy()
	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305171133.1:__init__ & __iter__
#@+node:ekr.20040305171133.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:allNodes_iter
#@+node:ekr.20040305173559:subtree_iter
class subtree_iter_class:

	"""Returns a list of positions in a subtree, possibly including the root of the subtree."""

	@others

def subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=false)
	
def self_and_subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
	
	if includeSelf:
		self.first = p.copy()
		self.after = p.nodeAfterTree()
	elif p.hasChildren():
		self.first = p.copy().moveToFirstChild() 
		self.after = p.nodeAfterTree()
	else:
		self.first = None
		self.after = None

	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p and self.p != self.after:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:subtree_iter
#@+node:ekr.20040305172211.1:children_iter
class children_iter_class:

	"""Returns a list of children of a position."""

	@others

def children_iter (self,copy=false):
	
	return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

	if p.hasChildren():
		self.first = p.copy().moveToFirstChild()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:children_iter
#@+node:ekr.20040305172855:parents_iter
class parents_iter_class:

	"""Returns a list of positions of a position."""

	@others

def parents_iter (self,copy=false):
	
	p = self

	return self.parents_iter_class(self,copy,includeSelf=false)
	
def self_and_parents_iter(self,copy=false):
	
	return self.parents_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

	if includeSelf:
		self.first = p.copy()
	elif p.hasParent():
		self.first = p.copy().moveToParent()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):

	return self
#@nonl
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToParent()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:parents_iter
#@+node:ekr.20040305173343:siblings_iter
class siblings_iter_class:

	"""Returns a list of siblings of a position."""

	@others

def siblings_iter (self,copy=false,following=false):
	
	return self.siblings_iter_class(self,copy,following)
	
self_and_siblings_iter = siblings_iter
	
def following_siblings_iter (self,copy=false):
	
	return self.siblings_iter_class(self,copy,following=true)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
	
	# We always include p, even if following is true.
	
	if following:
		self.first = p.copy()
	else:
		p = p.copy()
		while p.hasBack():
			p.moveToBack()
		self.first = p

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
# These remain in 4.2: the file read logic calls these before creating positions.
#@nonl
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

	"""Inserts a new vnode after self"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAfter(self)

	return v
#@nonl
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAsNthChild(self,n)

	return v
#@nonl
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20031218072017.2355:v.linkAfter
def linkAfter (self,v):

	"""Link self after v."""
	
	self._parent = v._parent
	self._back = v
	self._next = v._next
	v._next = self
	if self._next:
		self._next._back = self
#@-node:ekr.20031218072017.2355:v.linkAfter
#@+node:ekr.20031218072017.3425:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

	"""Links self as the n'th child of vnode pv"""

	v = self
	# g.trace(v,pv,n)
	v._parent = pv
	if n == 0:
		v._back = None
		v._next = pv.t._firstChild
		if pv.t._firstChild:
			pv.t._firstChild._back = v
		pv.t._firstChild = v
	else:
		prev = pv.nthChild(n-1) # zero based
		assert(prev)
		v._back = prev
		v._next = prev._next
		prev._next = v
		if v._next:
			v._next._back = v
#@nonl
#@-node:ekr.20031218072017.3425:v.linkAsNthChild
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link a vnode as the root node and set the root _position_."""

	v = self ; c = v.c

	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRoot
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot: oldRoot._back = v

	newRoot = position(v,[])
	c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

	"""Moves the receiver to the root position"""

	v = self

	v.unlink()
	v.linkAsRoot(oldRoot)
	
	return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

	"""Unlinks a vnode from the tree."""

	v = self ; c = v.c

	# g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
	
	# Special case the root.
	if v == c.rootPosition().v: # 3/11/04
		assert(v._next)
		newRoot = position(v._next,[])
		c.setRootPosition(newRoot)

	# Clear the links in other nodes.
	if v._back:
		v._back._next = v._next
	if v._next:
		v._next._back = v._back

	if v._parent and v == v._parent.t._firstChild:
		v._parent.t._firstChild = v._next

	# Clear the links in this node.
	v._parent = v._next = v._back = None
	# v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
#@+node:ekr.20040307091318:(root & current position/vnode)
#@+node:ekr.20031218072017.2983:c.currentPosition & c.setCurrentPosition
def currentPosition (self):
	
	"""Return the presently selected position."""

	return self._currentPosition.copy()
	
def setCurrentPosition (self,p):
	
	"""Set the presently selected position."""

	self._currentPosition = p
	
# Define these for compatibiility with old scripts.
currentVnode = currentPosition
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20031218072017.2983:c.currentPosition & c.setCurrentPosition
#@+node:ekr.20031218072017.2988:c.rootPosition & c.setRootPosition
def rootPosition(self):
	
	"""Return the root position."""
	
	return self._rootPosition.copy()

def setRootPosition(self,p):
	
	"""Set the root positioin."""

	self._rootPosition = p.copy() # Potential bug fix: 5/2/04
	
# Define these for compatibiility with old scripts.
rootVnode = rootPosition
setRootVnode = setRootPosition
#@nonl
#@-node:ekr.20031218072017.2988:c.rootPosition & c.setRootPosition
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def dragging(self):
	return self._dragging

def getEditTextDict(self,v):
	# New in 4.2: the default is an empty list.
	return self.edit_text_dict.get(v,[])

def editPosition(self):
	return self._editPosition
	
def setDragging(self,flag):
	self._dragging = flag

def setEditPosition(self,p):
	self._editPosition = p
#@nonl
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@-node:ekr.20040307091318:(root & current position/vnode)
#@-node:ekr.20040308151706.1: Fundamental 4.2 Code
#@+node:ekr.20040403104315:March 2004
#@+node:ekr.20040325203859:3/11 to 3/20
#@+node:ekr.20040302094109:(p.level bug)
#@+node:ekr.20040227214711:p.level & simpleLevel
def simpleLevel(self):
	
	p = self ; level = 0
	for parent in p.parents_iter():
		level += 1
	return level

def level(self,verbose=false):
	
	# if g.app.debug: simpleLevel = self.simpleLevel()
	
	p = self ; level = 0
	if not p: return level
		
	# Avoid calling p.copy() or copying the stack.
	v = p.v ; n = len(p.stack)-1
	while 1:
		assert(p)
		v,n = p.vParentWithStack(v,p.stack,n)
		if v:
			level += 1
			if verbose: g.trace(level,"level,n: %2d" % (level,n))
		else:
			if verbose: g.trace(level,"level,n: %2d" % (level,n))
			# if g.app.debug: assert(level==simpleLevel)
			return level
#@nonl
#@-node:ekr.20040227214711:p.level & simpleLevel
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
	
	"""A utility that allows the computation of p.v without calling p.copy().
	
	v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

	Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

	if not v:
		return None,n
	elif v._parent and len(v._parent.t.vnodeList) == 1:
		return v._parent,n # don't change stack.
	elif stack and n >= 0:
		return self.stack[n],n-1 # simulate popping the stack.
	else:
		return None,n
#@nonl
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
	p = p.moveToParent()
	if p: list1.append(p.v)
# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
	list2.append(v)
	v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@-node:ekr.20040302094109:(p.level bug)
#@+node:ekr.20040305084926:(clone command)
#@+node:ekr.20031218072017.1762:c.clone
def clone (self):

	c = self
	p = c.currentPosition()
	if not p: return
	
	c.beginUpdate()
	if 1: # update...
		clone = p.clone(p)
		clone.setAllAncestorAtFileNodesDirty()
		c.setChanged(true)
		if c.validateOutline():
			c.selectVnode(clone)
			c.undoer.setUndoParams("Clone Node",clone)
	c.endUpdate() # updates all icons
#@nonl
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20040303175026.8:p.clone
def clone (self,back):
	
	"""Create a clone of back.
	
	Returns the newly created position."""
	
	p = self ; c = p.c

	p2 = back.copy()
	p2.v = vnode(c,back.v.t)
	p2.linkAfter(back)

	return p2
#@nonl
#@-node:ekr.20040303175026.8:p.clone
#@+node:ekr.20031218072017.3424:v.clone
# Creates a clone of back and insert it as the next sibling of back.

def clone (self,back):
	
	"""Create a clone of back."""
	
	clone = self.cloneTree(back)

	# Set the clone bit in all nodes joined to back.
	# This is not nearly enough.
	clone.setClonedBit()
	back.setClonedBit()
	for v in back.t.joinList:
		v.setClonedBit()

	return clone
#@nonl
#@-node:ekr.20031218072017.3424:v.clone
#@+node:ekr.20031218072017.1765:c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self):

	c = self
	
	if not g.app.debug:
		return true

	root = c.rootPosition()
	parent = c.nullPosition()

	if root:
		return root.validateOutlineWithParent(parent)
	else:
		return true
#@nonl
#@-node:ekr.20031218072017.1765:c.validateOutline
#@+node:ekr.20040303175026.13:p.validateOutlineWithParent
# This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
	
	p = self
	result = true # optimists get only unpleasant surprises.
	parent = p.getParent()
	childIndex = p.childIndex()
	
	# g.trace(p,parent,pv)
	<< validate parent ivar >>
	<< validate childIndex ivar >>
	<< validate x ivar >>

	# Recursively validate all the children.
	for child in p.children_iter():
		r = child.validateOutlineWithParent(p)
		if not r: result = false

	return result
#@nonl
#@+node:ekr.20040303175026.14:<< validate parent ivar >>
if parent != pv:
	p.invalidOutline( "Invalid parent link: " + repr(parent))
#@nonl
#@-node:ekr.20040303175026.14:<< validate parent ivar >>
#@+node:ekr.20040303175026.15:<< validate childIndex ivar >>
if pv:
	if childIndex < 0:
		p.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex >= pv.numberOfChildren():
		p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex < 0:
	p.invalidOutline ( "negative childIndex" + childIndex )
#@nonl
#@-node:ekr.20040303175026.15:<< validate childIndex ivar >>
#@+node:ekr.20040303175026.16:<< validate x ivar >>
if not p.v.t and pv:
	self.invalidOutline ( "Empty t" )
#@nonl
#@-node:ekr.20040303175026.16:<< validate x ivar >>
#@-node:ekr.20040303175026.13:p.validateOutlineWithParent
#@-node:ekr.20040305084926:(clone command)
#@+node:ekr.20040307101707:(Read code hangs)
if 0: # find the hang.
	try:    g.debug_count += 1
	except: g.debug_count  = 0
	g.trace(v)
	if g.debug_count > 100: break
#@nonl
#@+node:ekr.20031218072017.2626: top_df.readAll
def readAll(self,root,partialFlag=false):
	
	"""Scan vnodes, looking for @file nodes to read."""

	at = self ; c = at.c
	c.endEditing() # Capture the current headline.
	anyRead = false
	at.initIvars()
	p = root.copy()
	if partialFlag: after = p.nodeAfterTree()
	else: after = c.nullPosition()
	while p and not p.equal(after): # Don't use iterator.
		if p.isAtIgnoreNode():
			p.moveToNodeAfterTree()
		elif p.isAtThinFileNode():
			anyRead = true
			at.read(p,thinFile=true)
			p.moveToNodeAfterTree()
		elif p.isAtFileNode() or p.isAtNorefFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				at.read(p)
			else:
				# if p is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = p.isOrphan()
				ok = at.read(p)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					p.setDirty()
					c.setChanged(true)
			p.moveToNodeAfterTree()
		else: p.moveToThreadNext()
	# Clear all orphan bits.
	for p in c.allNodes_iter():
		p.v.clearOrphan()
		
	if partialFlag and not anyRead:
		g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20031218072017.2626: top_df.readAll
#@+node:ekr.20031218072017.2989:c.setChanged
def setChanged (self,changedFlag):

	c = self
	if not c.frame: return
	# Clear all dirty bits _before_ setting the caption.
	# 9/15/01 Clear all dirty bits except orphaned @file nodes
	if not changedFlag:
		# g.trace("clearing all dirty bits")
		for p in c.allNodes_iter():
			if p.isDirty() and not (p.isAtFileNode() or p.isAtNorefFileNode()):
				p.clearDirty()
	# Update all derived changed markers.
	c.changed = changedFlag
	s = c.frame.getTitle()
	if len(s) > 2 and not c.loading: # don't update while loading.
		if changedFlag:
			# import traceback ; traceback.print_stack()
			if s [0] != '*': c.frame.setTitle("* " + s)
		else:
			if s[0:2]=="* ": c.frame.setTitle(s[2:])
#@nonl
#@-node:ekr.20031218072017.2989:c.setChanged
#@+node:ekr.20031218072017.3368:v.isCloned (4.2)
def isCloned (self):
	
	return len(self.t.vnodeList) > 1
#@nonl
#@-node:ekr.20031218072017.3368:v.isCloned (4.2)
#@+node:ekr.20031218072017.3437:v.shouldBeClone
@ The receiver is a clone if and only it is structurally _dissimilar_ to a node joined to it.

Structurally _similar_ joined nodes have non-null, distinct and joined parents, and have the same child indices.
@c

def shouldBeClone (self):
	
	"""Returns true if the receiver should be a clone"""
	pv1 = self.parent()
	n = self.childIndex()

	for v in self.t.joinList:
		if v != self:
			vp = v.parent()
			# self and v are structurally dissimilar if...
			if( (not pv1 or not vp) or  # they are at the top level, or
				vp == pv1 or  # have the same parent, or
				pv1.t != vp.t or  # have unjoined parents, or
				(v.childIndex() != n)): # have different child indices.

				# g.trace("true",v)
				return true

	# The receiver is structurally similar to all nodes joined to it.
	# g.trace("false",v)
	return false
#@nonl
#@-node:ekr.20031218072017.3437:v.shouldBeClone
#@-node:ekr.20040307101707:(Read code hangs)
#@+node:ekr.20040309041826:(Problems with injected methods)
#@+node:ekr.20040309045858:Notes
@nocolor

The problem was that the calls to tag_bind did not copy the position, and the position changed during the tree traversal in the tree drawing code.  Making a copy of the position for each binding solved the problem.

The draw_box 
#@nonl
#@-node:ekr.20040309045858:Notes
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):

	y += 7 # draw the box at x, y+7
	h = self.line_height

	tree = self
	iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y+self.lineyoffset,image=image)
	
	if 1: # New in 4.2.  Create a frame to catch all clicks.
		id4 = self.canvas.create_rectangle(0,y-7,1000,y-7+h-3)
		color = ""
		self.canvas.itemconfig(id4,fill=color,outline=color)
		self.canvas.lower(id4)
		id3 = self.canvas.tag_bind(id4, "<1>", p.OnBoxClick)
		self.tagBindings.append((id,id3,"<1>"),)

	id1 = self.canvas.tag_bind(id, "<1>", p.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
	
	"""Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

	tree = self
	
	# Make sure the bindings refer to the _present_ position.
	v = p.v

	if x is None and y is None:
		try:
			x,y = v.iconx, v.icony
		except:
			# Inject the ivars.
			x,y = v.iconx, v.icony = 0,0
	else:
		# Inject the ivars.
		v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute v.iconVal.
	# This is an important drawing optimization.
	val = v.iconVal = v.computeIcon()
	assert(0 <= val <= 15)

	# Get the image.
	imagename = "box%02d.GIF" % val
	image = self.getIconImage(imagename)
	id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image)
	self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.

	id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
	id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
	id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
	self.tagBindings.append((id,id3,"<3>"),)

	return 0,icon_width # dummy icon height,width
#@nonl
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.1956:tree.injectCallbacks (class method)
def injectCallbacks(self):
	
	import leoNodes
	
	<< define tkinter callbacks to be injected in the position class >>

	for f in (
		OnBoxClick,OnDrag,OnEndDrag,
		OnHeadlineClick,OnHeadlineRightClick,OnHeadlineKey,
		OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave,
		OnIconClick,OnIconDoubleClick,OnIconRightClick):
		
		g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20031218072017.1957:<< define tkinter callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@nonl
#@+node:ekr.20031218072017.1958:OnBoxClick
# Called when the box is clicked.

def OnBoxClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("boxclick1",c=c,p=p,event=event):
			c.frame.tree.OnBoxClick(p)
		g.doHook("boxclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("boxclick")
#@nonl
#@-node:ekr.20031218072017.1958:OnBoxClick
#@+node:ekr.20031218072017.1959:OnDrag
def OnDrag(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if c.frame.tree.dragging():
			if not g.doHook("dragging1",c=c,p=p,event=event):
				c.frame.tree.OnDrag(p,event)
			g.doHook("dragging2",c=c,p=p,event=event)
		else:
			if not g.doHook("drag1",c=c,p=p,event=event):
				c.frame.tree.OnDrag(p,event)
			g.doHook("drag2",c=c,p=p,event=event)
	except:
		g.es_event_exception("drag")
#@nonl
#@-node:ekr.20031218072017.1959:OnDrag
#@+node:ekr.20031218072017.1960:OnEndDrag
def OnEndDrag(self,event=None):
	
	"""Callback injected into vnode or position class."""
	
	# g.trace()

	try:
		p = self ; c = p.c
		# 7/10/03: Always call frame.OnEndDrag, regardless of state.
		if not g.doHook("enddrag1",c=c,p=p,event=event):
			c.frame.tree.OnEndDrag(p,event)
		g.doHook("enddrag2",c=c,p=p,event=event)
	except:
		g.es_event_exception("enddrag")
#@nonl
#@-node:ekr.20031218072017.1960:OnEndDrag
#@+node:ekr.20031218072017.1961:OnHeadlineClick & OnHeadlineRightClick
def OnHeadlineClick(self,event=None):
	"""Callback injected into vnode or position class."""
	try:
		p = self ; c = p.c
		if not g.doHook("headclick1",c=c,p=p,event=event):
			c.frame.tree.OnActivate(p)
		g.doHook("headclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("headclick")
	
def OnHeadlineRightClick(self,event=None):

	"""Callback injected into vnode or position class."""

	#g.trace()
	try:
		p = self ; c = p.c
		if not g.doHook("headrclick1",c=c,p=p,event=event):
			c.frame.tree.OnActivate(p)
			c.frame.tree.OnPopup(self,event)
		g.doHook("headrclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("headrclick")
#@nonl
#@-node:ekr.20031218072017.1961:OnHeadlineClick & OnHeadlineRightClick
#@+node:ekr.20031218072017.1962:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
	
	"""Callback injected into vnode or position class."""

	# g.trace()
	try:
		p = self ; c = p.c
		if not g.doHook("hypercclick1",c=c,p=p,event=event):
			c.beginUpdate()
			c.selectVnode(p)
			c.endUpdate()
			c.frame.bodyCtrl.mark_set("insert","1.0")
		g.doHook("hypercclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("hypercclick")
#@nonl
#@-node:ekr.20031218072017.1962:OnHyperLinkControlClick
#@+node:ekr.20031218072017.1963:OnHeadlineKey
def OnHeadlineKey (self,event=None):

	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("headkey1",c=c,p=p,event=event):
			c.frame.tree.OnHeadlineKey(p,event)
		g.doHook("headkey2",c=c,p=p,event=event)
	except:
		g.es_event_exception("headkey")
#@nonl
#@-node:ekr.20031218072017.1963:OnHeadlineKey
#@+node:ekr.20031218072017.1964:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("hyperenter1",c=c,p=p,event=event):
			if 0: # This works, and isn't very useful.
				c.frame.bodyCtrl.tag_config(p.tagName,background="green")
		g.doHook("hyperenter2",c=c,p=p,event=event)
	except:
		g.es_event_exception("hyperenter")
#@nonl
#@-node:ekr.20031218072017.1964:OnHyperLinkEnter
#@+node:ekr.20031218072017.1965:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("hyperleave1",c=c,p=p,event=event):
			if 0: # This works, and isn't very useful.
				c.frame.bodyCtrl.tag_config(p.tagName,background="white")
		g.doHook("hyperleave2",c=c,p=p,event=event)
	except:
		g.es_event_exception("hyperleave")
#@nonl
#@-node:ekr.20031218072017.1965:OnHyperLinkLeave
#@+node:ekr.20031218072017.1966:OnIconClick & OnIconRightClick
def OnIconClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("iconclick1",c=c,p=p,event=event):
			c.frame.tree.OnIconClick(p,event)
		g.doHook("iconclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("iconclick")
	
def OnIconRightClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("iconrclick1",c=c,p=p,event=event):
			c.frame.tree.OnIconRightClick(p,event)
		g.doHook("iconrclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("iconrclick")
#@-node:ekr.20031218072017.1966:OnIconClick & OnIconRightClick
#@+node:ekr.20031218072017.1967:OnIconDoubleClick
def OnIconDoubleClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("icondclick1",c=c,p=p,event=event):
			c.frame.tree.OnIconDoubleClick(self)
		g.doHook("icondclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("icondclick")
#@-node:ekr.20031218072017.1967:OnIconDoubleClick
#@-node:ekr.20031218072017.1957:<< define tkinter callbacks to be injected in the position class >>
#@-node:ekr.20031218072017.1956:tree.injectCallbacks (class method)
#@+node:ekr.20031218072017.2336:Event handers (tree)
@ Important note: most hooks are created in the vnode callback routines, _not_ here.
#@+node:ekr.20031218072017.2337:OnActivate
def OnActivate (self,p,event=None):

	try:
		c = self.c ; gui = g.app.gui
		<< activate this window >>
	except:
		g.es_event_exception("activate tree")
#@nonl
#@+node:ekr.20031218072017.2338:<< activate this window >>
current = c.currentPosition()

if p == current:
	if self.active:
		self.editLabel(p)
	else:
		self.undimEditLabel()
		gui.set_focus(c,self.canvas) # Essential for proper editing.
else:
	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	if p.v.t.insertSpot != None: # 9/1/02
		c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
		c.frame.bodyCtrl.see(p.v.t.insertSpot)
	else:
		c.frame.bodyCtrl.mark_set("insert","1.0")
	gui.set_focus(c,c.frame.bodyCtrl)

self.active = true
#@nonl
#@-node:ekr.20031218072017.2338:<< activate this window >>
#@-node:ekr.20031218072017.2337:OnActivate
#@+node:ekr.20031218072017.2339:OnBoxClick
# Called on click in box and double-click in headline.

def OnBoxClick (self,p):
	
	# g.trace(p)

	# Note: "boxclick" hooks handled by vnode callback routine.
	c = self.c ; gui = g.app.gui

	if p.isExpanded(): p.contract()
	else:              p.expand()

	self.active = true
	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	gui.set_focus(c,c.frame.bodyCtrl) # 7/12/03
	self.redraw()
#@nonl
#@-node:ekr.20031218072017.2339:OnBoxClick
#@+node:ekr.20031218072017.2340:tree.OnDeactivate (caused double-click problem)
def OnDeactivate (self,event=None):
	
	"""Deactivate the tree pane, dimming any headline being edited."""

	tree = self ; c = self.c
	focus = g.app.gui.get_focus(c.frame)

	# Bug fix: 7/13/03: Only do this as needed.
	# Doing this on every click would interfere with the double-clicking.
	if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
		try:
			# g.trace(focus)
			tree.endEditLabel()
			tree.dimEditLabel()
		except:
			g.es_event_exception("deactivate tree")
#@nonl
#@-node:ekr.20031218072017.2340:tree.OnDeactivate (caused double-click problem)
#@+node:ekr.20031218072017.2341:tree.findVnodeWithIconId
def findVnodeWithIconId (self,id):
	
	# Due to an old bug, id may be a tuple.
	try:
		return self.icon_id_dict.get(id[0])
	except:
		return self.icon_id_dict.get(id)
#@nonl
#@-node:ekr.20031218072017.2341:tree.findVnodeWithIconId
#@+node:ekr.20031218072017.2342:tree.OnContinueDrag
def OnContinueDrag(self,p,event):

	try:
		<< continue dragging >>
	except:
		g.es_event_exception("continue drag")
#@nonl
#@+node:ekr.20031218072017.2343:<< continue dragging >>
# g.trace(p)
assert(p == self.drag_p)

canvas = self.canvas
frame = self.c.frame

if event:
	x,y = event.x,event.y
else:
	x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
	if x == -1 or y == -1: return # Stop the scrolling if we go outside the entire window.

if 0: # no longer used.
	canvas_x = canvas.canvasx(x)
	canvas_y = canvas.canvasy(y)
	id = self.canvas.find_closest(canvas_x,canvas_y)

# OnEndDrag() halts the scrolling by clearing self.drag_id when the mouse button goes up.
if self.drag_id: # This gets cleared by OnEndDrag()
	<< scroll the canvas as needed >>
#@nonl
#@+node:ekr.20031218072017.2344:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()
if y < 0 or y > h:
	lo, hi = frame.treeBar.get()
	n = self.savedNumberOfVisibleNodes
	line_frac = 1.0 / float(n)
	frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
	frac = min(frac,1.0)
	frac = max(frac,0.0)
	# g.es("lo,hi,frac:",lo,hi,frac)
	canvas.yview("moveto", frac)
	
	# Queue up another event to keep scrolling while the cursor is outside the canvas.
	lo, hi = frame.treeBar.get()
	if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
		canvas.after_idle(self.OnContinueDrag,p,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20031218072017.2344:<< scroll the canvas as needed >>
#@-node:ekr.20031218072017.2343:<< continue dragging >>
#@-node:ekr.20031218072017.2342:tree.OnContinueDrag
#@+node:ekr.20031218072017.2345:tree.OnCtontrolT
# This works around an apparent Tk bug.

def OnControlT (self,event=None):

	# If we don't inhibit further processing the Tx.Text widget switches characters!
	return "break"
#@nonl
#@-node:ekr.20031218072017.2345:tree.OnCtontrolT
#@+node:ekr.20031218072017.1776:tree.OnDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findVnodeWithIconId() should start looking for tree id's.

def OnDrag(self,p,event):

	# Note: "drag" hooks handled by vnode callback routine.

	c = self.c ; v = p.v
	assert(p == self.drag_p)

	if not event:
		return

	if not self.dragging():
		windowPref = g.app.config.getBoolWindowPref
		# Only do this once: greatly speeds drags.
		self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
		self.setDragging(true)
		if windowPref("allow_clone_drags"):
			self.controlDrag = c.frame.controlKeyIsDown
			if windowPref("look_for_control_drag_on_mouse_down"):
				if windowPref("enable_drag_messages"):
					if self.controlDrag:
						g.es("dragged node will be cloned")
					else:
						g.es("dragged node will be moved")
		else: self.controlDrag = false
		self.canvas['cursor'] = "hand2" # "center_ptr"

	self.OnContinueDrag(p,event)
#@nonl
#@-node:ekr.20031218072017.1776:tree.OnDrag
#@+node:ekr.20031218072017.1777:tree.OnEndDrag
def OnEndDrag(self,p,event):
	
	"""Tree end-of-drag handler called from vnode event handler."""
	
	v = p.v
	
	# 7/10/03: Make sure we are still dragging.
	if not self.drag_p:
		return

	assert(p == self.drag_p)
	c = self.c ; canvas = self.canvas ; config = g.app.config

	if event:
		<< set vdrag, childFlag >>
		if config.getBoolWindowPref("allow_clone_drags"):
			if not config.getBoolWindowPref("look_for_control_drag_on_mouse_down"):
				self.controlDrag = c.frame.controlKeyIsDown

		if vdrag and vdrag != p:
			if self.controlDrag: # Clone p and move the clone.
				if childFlag:
					c.dragCloneToNthChildOf(p,vdrag,0)
				else:
					c.dragCloneAfter(p,vdrag)
			else: # Just drag p.
				if childFlag:
					c.dragToNthChildOf(p,vdrag,0)
				else:
					c.dragAfter(p,vdrag)
		else:
			if p and self.dragging():
				pass # g.es("not dragged: " + p.headString())
			if 0: # Don't undo the scrolling we just did!
				self.idle_scrollTo(p)
	
	# 1216/02: Reset the old cursor by brute force.
	self.canvas['cursor'] = "arrow"

	if self.drag_id:
		canvas.tag_unbind(self.drag_id,"<B1-Motion>")
		canvas.tag_unbind(self.drag_id,"<Any-ButtonRelease-1>")
		self.drag_id = None
		
	self.setDragging(false)
	self.drag_p = None
#@nonl
#@+node:ekr.20031218072017.1778:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

id = self.canvas.find_closest(canvas_x,canvas_y)
vdrag = self.findVnodeWithIconId(id)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20031218072017.1778:<< set vdrag, childFlag >>
#@-node:ekr.20031218072017.1777:tree.OnEndDrag
#@+node:ekr.20031218072017.1332:headline key handlers (tree)
@ The <Key> event generates the event before the headline text is changed(!), so we register an idle-event handler to do the work later.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1333:onHeadChanged
def onHeadChanged (self,p):
	
	"""Handle a change to headline text."""

	self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p)
#@nonl
#@-node:ekr.20031218072017.1333:onHeadChanged
#@+node:ekr.20031218072017.1334:OnHeadlineKey
def OnHeadlineKey (self,p,event):
	
	"""Handle a key event in a headline."""

	ch = event.char
	self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)

#@-node:ekr.20031218072017.1334:OnHeadlineKey
#@+node:ekr.20031218072017.1335:idle_head_key
def idle_head_key (self,p,ch=None):
	
	"""Update headline text at idle time."""

	c = self.c ; v = p.v

	if not p or not p.edit_text() or p != c.currentPosition():
		return "break"
		
	edit_text = p.edit_text()

	if g.doHook("headkey1",c=c,p=p,ch=ch):
		return "break" # The hook claims to have handled the event.

	<< set s to the widget text >>
	<< set head to vnode text >>
	changed = s != head
	done = ch and (ch == '\r' or ch == '\n')
	if not changed and not done:
		return "break"
	if changed:
		c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
	index = edit_text.index("insert")
	if changed:
		<< update v and all nodes joined to v >>
	<< reconfigure v and all nodes joined to v >>
	<< update the screen >>

	g.doHook("headkey2",c=c,p=p,ch=ch)
	return "break"
#@nonl
#@+node:ekr.20031218072017.1336:<< set s to the widget text >>
s = edit_text.get("1.0","end")
s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03

if not s:
	s = u""
s = s.replace('\n','')
s = s.replace('\r','')
# g.trace(s)
#@-node:ekr.20031218072017.1336:<< set s to the widget text >>
#@+node:ekr.20031218072017.1337:<< set head to vnode text >>
head = p.headString()
if head == None:
	head = u""
head = g.toUnicode(head,"utf-8")
#@-node:ekr.20031218072017.1337:<< set head to vnode text >>
#@+node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
c.beginUpdate()
if 1: # update...
	# Update changed bit.
	if not c.changed:
		c.setChanged(true)
	# Update all dirty bits.
	p.setDirty()
	# Update v.
	v.initHeadString(s)
	edit_text.delete("1.0","end")
	edit_text.insert("end",s)
	edit_text.mark_set("insert",index)
c.endUpdate(false) # do not redraw now.
#@nonl
#@-node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
#@+node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
# Reconfigure v's headline.
if done:
	self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(v))
#@nonl
#@-node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
#@+node:ekr.20031218072017.1340:<< update the screen >>
if done:
	c.beginUpdate()
	self.endEditLabel()
	c.endUpdate()

elif changed:
	# update v immediately.  Joined nodes are redrawn later by endEditLabel.
	# Redrawing the whole screen now messes up the cursor in the headline.
	self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20031218072017.1340:<< update the screen >>
#@-node:ekr.20031218072017.1335:idle_head_key
#@-node:ekr.20031218072017.1332:headline key handlers (tree)
#@+node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
def OnIconClick (self,p,event):
	
	# g.trace(p)
	
	p = p.copy() # Make sure callbacks use the _present_ position.

	tree = self ; canvas = tree.canvas
	if event:
		canvas_x = canvas.canvasx(event.x)
		canvas_y = canvas.canvasy(event.y)
		id = canvas.find_closest(canvas_x,canvas_y)
		if id != None:
			try: id = id[0]
			except: pass
			self.drag_p = p
			self.drag_id = id
			
			# Create the bindings.
			id4 = canvas.tag_bind(id,"<B1-Motion>", p.OnDrag)
			id5 = canvas.tag_bind(id,"<Any-ButtonRelease-1>", p.OnEndDrag)
			
			# Remember the bindings so deleteBindings can delete them.
			self.tagBindings.append((id,id4,"<B1-Motion>"),)
			self.tagBindings.append((id,id5,"<Any-ButtonRelease-1>"),)
	tree.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	return "break" # disable expanded box handling.
	
def OnIconRightClick (self,p,event):

	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
#@+node:ekr.20031218072017.2348:tree.OnPopup & allies
def OnPopup (self,p,event):
	
	"""Handle right-clicks in the outline."""
	
	# Note: "headrclick" hooks handled by vnode callback routine.

	if event != None:
		c = self.c
		if not g.doHook("create-popup-menu",c=c,p=p,event=event):
			self.createPopupMenu(event)
		if not g.doHook("enable-popup-menu-items",c=c,p=p,event=event):
			self.enablePopupMenuItems(p,event)
		if not g.doHook("show-popup-menu",c=c,p=p,event=event):
			self.showPopupMenu(event)

	return "break"
#@nonl
#@+node:ekr.20031218072017.2349:OnPopupFocusLost
@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the <FocusOut> event and explicitly unpost.  In order to process the <FocusOut> event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):

	self.popupMenu.unpost()
	
#@-node:ekr.20031218072017.2349:OnPopupFocusLost
#@+node:ekr.20031218072017.2249:createPopupMenu
def createPopupMenu (self,event):
	
	c = self.c ; frame = c.frame
	
	# If we are going to recreate it, we had better destroy it.
	if self.popupMenu:
		self.popupMenu.destroy()
		self.popupMenu = None
	
	self.popupMenu = menu = Tkinter.Menu(g.app.root, tearoff=0)
	
	# Add the Open With entries if they exist.
	if g.app.openWithTable:
		frame.menu.createMenuEntries(menu,g.app.openWithTable,openWith=1)
		table = (("-",None,None),)
		frame.menu.createMenuEntries(menu,table)
		
	<< Create the menu table >>
	
	# 11/27/03: Don't actually set binding: it would conflict with previous.
	frame.menu.createMenuEntries(menu,table,dontBind=true)
#@nonl
#@+node:ekr.20031218072017.2250:<< Create the menu table >>
table = (
	("&Read @file Nodes",None,c.readAtFileNodes),
	("&Write @file Nodes",None,c.fileCommands.writeAtFileNodes),
	("-",None,None),
	("&Tangle","Shift+Ctrl+T",c.tangle),
	("&Untangle","Shift+Ctrl+U",c.untangle),
	("-",None,None),
	# 2/16/04: Remove shortcut for Toggle Angle Brackets command.
	("Toggle Angle &Brackets",None,c.toggleAngleBrackets),
	("-",None,None),
	("Cut Node","Shift+Ctrl+X",c.cutOutline),
	("Copy Node","Shift+Ctrl+C",c.copyOutline),
	("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
	("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
	("-",None,None),
	("&Insert Node","Ctrl+I",c.insertHeadline),
	("&Clone Node","Ctrl+`",c.clone),
	("Sort C&hildren",None,c.sortChildren),
	("&Sort Siblings","Alt-A",c.sortSiblings),
	("-",None,None),
	("Contract Parent","Alt+0",c.contractParent))
#@nonl
#@-node:ekr.20031218072017.2250:<< Create the menu table >>
#@-node:ekr.20031218072017.2249:createPopupMenu
#@+node:ekr.20031218072017.2350:enablePopupMenuItems
def enablePopupMenuItems (self,v,event):
	
	"""Enable and disable items in the popup menu."""
	
	c = self.c ; menu = self.popupMenu

	<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
	isAtFile = g.choose(isAtFile,1,0)
	isAtRoot = g.choose(isAtRoot,1,0)
	canContract = v.parent() != None
	canContract = g.choose(canContract,1,0)
	
	enable = self.frame.menu.enableMenu
	
	for name in ("Read @file Nodes", "Write @file Nodes"):
		enable(menu,name,isAtFile)
	for name in ("Tangle", "Untangle"):
		enable(menu,name,isAtRoot)

	enable(menu,"Cut Node",c.canCutOutline())
	enable(menu,"Delete Node",c.canDeleteHeadline())
	enable(menu,"Paste Node",c.canPasteOutline())
	enable(menu,"Sort Children",c.canSortChildren())
	enable(menu,"Sort Siblings",c.canSortSiblings())
	enable(menu,"Contract Parent",c.canContractParent())
#@nonl
#@+node:ekr.20031218072017.2351:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
isAtFile = false
isAtRoot = false

for v2 in v.self_and_subtree_iter():
	if isAtFile and isAtRoot:
		break
	if (v2.isAtFileNode() or
		v2.isAtNorefFileNode() or
		v2.isAtAsisFileNode() or
		v2.isAtNoSentFileNode()
	):
		isAtFile = true
		
	isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
	if isRoot:
		isAtRoot = true
#@nonl
#@-node:ekr.20031218072017.2351:<< set isAtRoot and isAtFile if v's tree contains @root or @file nodes >>
#@-node:ekr.20031218072017.2350:enablePopupMenuItems
#@+node:ekr.20031218072017.2352:showPopupMenu
def showPopupMenu (self,event):
	
	"""Show a popup menu."""
	
	c = self.c ; menu = self.popupMenu ; gui = g.app.gui

	if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
		menu.bind("<FocusOut>",self.OnPopupFocusLost)
	
	menu.post(event.x_root, event.y_root)

	# Make certain we have focus so we know when we lose it.
	# I think this is OK for all OSes.
	gui.set_focus(c,menu)
#@nonl
#@-node:ekr.20031218072017.2352:showPopupMenu
#@-node:ekr.20031218072017.2348:tree.OnPopup & allies
#@-node:ekr.20031218072017.2336:Event handers (tree)
#@-node:ekr.20040309041826:(Problems with injected methods)
#@+node:ekr.20040310062415.1:(Revised p.link/unlink routines)
#@+node:ekr.20040310062332:p.Link/Unlink methods
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@nonl
#@+node:ekr.20040310062332.1:p.invalidOutline
def invalidOutline (self, message):
	
	p = self

	if p.hasParent():
		node = p.parent()
	else:
		node = p

	g.alert("invalid outline: %s\n%s" % (message,node))
#@nonl
#@-node:ekr.20040310062332.1:p.invalidOutline
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

	"""Link self after v."""
	
	p = self
	# g.trace(p,after)
	
	p.stack = after.stack[:] # 3/12/04
	p.v._parent = after.v._parent
	
	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
	
	p.v._back = after.v
	p.v._next = after.v._next
	
	after.v._next = p.v
	
	if p.v._next:
		p.v._next._back = p.v

	if 0:
		g.trace('-'*20,after)
		p.dump(label="p")
		after.dump(label="back")
		if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20040310062332.3:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

	"""Links self as the n'th child of vnode pv"""
	
	# g.trace(self,parent,n)
	p = self

	# Recreate the stack using the parent.
	p.stack = parent.stack[:] 
	if parent.isCloned():
		p.stack.append(parent.v)

	p.v._parent = parent.v

	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)

	if n == 0:
		child1 = parent.v.t._firstChild
		p.v._back = None
		p.v._next = child1
		if child1:
			child1._back = p.v
		parent.v.t._firstChild = p.v
	else:
		prev = parent.nthChild(n-1) # zero based
		assert(prev)
		p.v._back = prev.v
		p.v._next = prev.v._next
		prev.v._next = p.v
		if p.v._next:
			p.v._next._back = p.v
			
	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.3:p.linkAsNthChild
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link self as the root node."""
	
	# g.trace(self,oldRoot)

	p = self ; v = p.v
	if oldRoot: oldRootVnode = oldRoot.v
	else:       oldRootVnode = None
	
	p.stack = [] # Clear the stack.
	
	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRootVnode # Bug fix: 3/12/04
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot:
		oldRoot.v._back = v # Bug fix: 3/12/04

	p.c.setRootPosition(p)
	
	if 0:
		p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

	"""Unlinks a position p from the tree before moving or deleting.
	
	The p.v._fistChild link does NOT change."""

	p = self ; v = p.v ; parent = p.parent()
	
	# Note:  p.parent() is not necessarily the same as v._parent.
	
	if parent:
		assert(p.v and p.v._parent in p.v.directParents())
		assert(parent.v in p.v.directParents())

	# g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
	
	# Special case the root.
	if p == p.c.rootPosition():
		assert(p.v._next)
		p.c.setRootPosition(p.next())
	
	# Remove v from it's tnode's vnodeList.
	vnodeList = v.t.vnodeList
	if v in vnodeList:
		vnodeList.remove(v)
	assert(v not in vnodeList)
	
	# Reset the firstChild link in its direct father.
	if parent and parent.v.t._firstChild == v:
		parent.v.t._firstChild = v._next

	# Do _not_ delete the links in any child nodes.

	# Clear the links in other nodes.
	if v._back: v._back._next = v._next
	if v._next: v._next._back = v._back

	# Unlink _this_ node.
	v._parent = v._next = v._back = None

	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		if parent: parent.dump(label="parent")
#@-node:ekr.20040310062332.5:p.unlink
#@-node:ekr.20040310062332:p.Link/Unlink methods
#@-node:ekr.20040310062415.1:(Revised p.link/unlink routines)
#@+node:ekr.20040305222007:(undo/redo)
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
	leading,trailing, # Number of matching leading & trailing lines.
	oldMidLines,newMidLines, # Lists of unmatched lines.
	oldNewlines,newNewlines, # Number of trailing newlines.
	tag="undo", # "undo" or "redo"
	undoType=None):

	u = self ; c = u.c
	assert(p == c.currentPosition())
	v = p.v

	<< Incrementally update the Tk.Text widget >>
	<< Compute the result using v's body text >>
	# g.trace(v)
	# g.trace("old:",v.bodyString())
	v.setTnodeText(result)
	# g.trace("new:",v.bodyString())
	<< Get textResult from the Tk.Text widget >>
	if textResult == result:
		if undoType in ("Cut","Paste"):
			# g.trace("non-incremental undo")
			c.frame.body.recolor(p,incremental=false)
		else:
			# g.trace("incremental undo:",leading,trailing)
			c.frame.body.recolor_range(p,leading,trailing)
	else: # 11/19/02: # Rewrite the pane and do a full recolor.
		if u.debug_print:
			<< print mismatch trace >>
		# g.trace("non-incremental undo")
		p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
	c.frame.body.deleteLine(leading)
	if leading > 0:
		c.frame.body.insertAtEnd('\n')
	c.frame.body.insertAtEnd(mid_text)
else:
	if new_mid_len > 0:
		c.frame.body.deleteLines(leading,new_mid_len)
	elif leading > 0:
		c.frame.body.insertAtStartOfLine(leading,'\n')
	c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
	newlines += 1 ; i -= 1
while newlines > oldNewlines:
	c.frame.body.deleteLastChar()
	newlines -= 1
if oldNewlines > newlines:
	c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
# Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
	s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
	s.extend(oldMidLines)
if trailing > 0:
	s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
	s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
	s = s + '\n' * oldNewlines
result = s
if u.debug_print:
	print "body:  ",body
	print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using v's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
	# Remove the newline from textResult if that is the only difference.
	if len(textResult) > 0 and textResult[:-1] == result:
		textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@+node:ekr.20031218072017.2030:u.redo
def redo (self):

	u = self ; c = u.c
	if not u.canRedo(): return
	if not u.getBead(u.bead+1): return
	current = c.currentPosition()
	if not current: return
	# g.trace(u.bead+1,len(u.beads),u.peekBead(u.bead+1))
	u.redoing = true ; redrawFlag = true
	redoType = u.undoType # Use the type of the next bead.
	updateSetChangedFlag = true
	c.beginUpdate()
	if 1: # range...
		<< redo clone cases >>
		<< redo hoist cases >>
		<< redo insert cases >>
		<< redo delete cases >>
		<< redo move & drag cases >>
		<< redo promote and demote cases >>
		<< redo replace cases >>
		<< redo sort cases >>
		<< redo typing cases >>
		else: g.trace("Unknown case: ",redoType)
		if updateSetChangedFlag:
			c.setChanged(true)
			if u.p: u.p.setDirty()
	c.endUpdate(redrawFlag) # 11/08/02
	u.redoing = false
	u.bead += 1
	u.setUndoTypes()
#@nonl
#@+node:ekr.20031218072017.2031:<< redo clone cases >>
if redoType in ("Clone Node","Drag & Clone"):
	
	if u.back:
		u.p.linkAfter(u.back)
	elif u.parent:
		u.p.linkAsNthChild(u.parent,0)
	else:
		oldRoot = c.rootPosition()
		u.p.linkAsRoot(oldRoot)

	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2031:<< redo clone cases >>
#@+node:ekr.20031218072017.2032:<< redo delete cases >>
elif redoType == "Delete Node" or redoType == "Cut Node":

	c.selectVnode(u.p)
	c.deleteOutline()
#@nonl
#@-node:ekr.20031218072017.2032:<< redo delete cases >>
#@+node:ekr.20031218072017.2033:<< redo hoist cases >>
elif redoType == "Hoist":
	
	c.selectVnode(u.p)
	c.hoist()
	updateSetChangedFlag = false
	
elif redoType == "De-Hoist":
	
	c.selectVnode(u.p)
	c.dehoist()
	updateSetChangedFlag = false
#@nonl
#@-node:ekr.20031218072017.2033:<< redo hoist cases >>
#@+node:ekr.20031218072017.2034:<< redo insert cases >>
elif redoType in ["Import","Insert Node","Paste Node"]:

	if u.back:
		u.p.linkAfter(u.back)
	elif u.parent:
		u.p.linkAsNthChild(u.parent,0)
	else:
		oldRoot = c.rootPosition()
		u.p.linkAsRoot(oldRoot)
		
	# Restore all vnodeLists (and thus all clone marks).
	u.p.restoreLinksInTree()

	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2034:<< redo insert cases >>
#@+node:ekr.20031218072017.2035:<< redo move & drag cases >>
elif redoType in ["Drag","Move Down","Move Left","Move Right","Move Up"]:

	# g.trace(u.p)
	if u.parent:
		u.p.moveToNthChildOf(u.parent,u.n)
	elif u.back:
		u.p.moveAfter(u.back)
	else:
		oldRoot = c.rootPosition() # Bug fix: 4/9/04
		u.p.moveToRoot(oldRoot)

	c.selectVnode(u.p)
	
elif redoType == "Drag":

	u.p.moveToNthChildOf(u.parent,u.n)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2035:<< redo move & drag cases >>
#@+node:ekr.20031218072017.2036:<< redo promote and demote cases >>
elif redoType == "Demote":

	c.selectVnode(u.p)
	c.demote()
	
elif redoType == "Promote":

	c.selectVnode(u.p)
	c.promote()
#@nonl
#@-node:ekr.20031218072017.2036:<< redo promote and demote cases >>
#@+node:ekr.20031218072017.1713:<< redo replace cases >>
elif redoType in (
	"Convert All Blanks","Convert All Tabs",
	"Extract","Extract Names","Extract Section",
	"Read @file Nodes"):

	u.p = self.undoReplace(u.p,u.oldTree,u.newTree,u.newText)
	c.selectVnode(u.p) # Does full recolor.
	if u.newSel:
		c.frame.body.setTextSelection(u.newSel)
	redrawFlag = redoType in ("Extract","Extract Names","Extract Section","Read @file Nodes")
#@nonl
#@-node:ekr.20031218072017.1713:<< redo replace cases >>
#@+node:ekr.20031218072017.2037:<< redo sort cases >>
elif redoType == "Sort Children":

	c.selectVnode(u.p)
	c.sortChildren()

elif redoType == "Sort Siblings":

	c.selectVnode(u.p)
	c.sortSiblings()
	
elif redoType == "Sort Top Level":
	
	c.selectVnode(u.p)
	c.sortTopLevel()
	u.p = None # don't mark u.p dirty
#@nonl
#@-node:ekr.20031218072017.2037:<< redo sort cases >>
#@+node:ekr.20031218072017.2038:<< redo typing cases >>
elif redoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# g.trace(redoType,u.p)
	# selectVnode causes recoloring, so avoid if possible.
	if current != u.p:
		c.selectVnode(u.p)
	elif redoType in ("Cut","Paste"):
		c.frame.body.forceFullRecolor()

	self.undoRedoText(
		u.p,u.leading,u.trailing,
		u.newMiddleLines,u.oldMiddleLines,
		u.newNewlines,u.oldNewlines,
		tag="redo",undoType=redoType)
	
	if u.newSel:
		c.frame.body.setTextSelection(u.newSel)
	if u.yview:
		c.frame.body.setYScrollPosition(u.yview)
	redrawFlag = (current != u.p)
		
elif redoType == "Change All":

	count = 0
	while 1:
		u.bead += 1
		d = u.getBead(u.bead+1)
		assert(d)
		redoType = u.undoType
		# g.trace(redoType,u.p,u.newText)
		if redoType == "Change All":
			c.selectVnode(u.p)
			break
		elif redoType == "Change":
			u.p.v.setTnodeText(u.newText)
			u.p.setDirty()
			count += 1
		elif redoType == "Change Headline":
			u.p.initHeadString(u.newText)
			count += 1
		else: assert(false)
	g.es("redo %d instances" % count)

elif redoType == "Change Headline":
	
	# g.trace(redoType,u.p,u.newText)
	u.p.setHeadStringOrHeadline(u.newText)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2038:<< redo typing cases >>
#@-node:ekr.20031218072017.2030:u.redo
#@+node:ekr.20031218072017.2039:u.undo
def undo (self):

	"""This function and its allies undo the operation described by the undo parmaters."""
	
	u = self ; c = u.c
	if not u.canUndo(): return
	if not u.getBead(u.bead): return
	current = c.currentPosition()
	if not current: return
	# g.trace(len(u.beads),u.bead,u.peekBead(u.bead))
	c.endEditing()# Make sure we capture the headline for a redo.
	u.undoing = true
	undoType = u.undoType
	redrawFlag = true
	updateSetChangedFlag = true
	c.beginUpdate()
	if 1: # update...
		<< undo clone cases >>
		<< undo delete cases >>
		<< undo hoist cases >>
		<< undo insert cases >>
		<< undo move & drag cases >>
		<< undo promote and demote cases >>
		<< undo replace cases >>
		<< undo sort cases >>
		<< undo typing cases >>
		else: g.trace("Unknown case: ",u.undoType)
		if updateSetChangedFlag:
			c.setChanged(true)
			if u.p: u.p.setDirty()
	c.endUpdate(redrawFlag) # 11/9/02
	u.undoing = false
	u.bead -= 1
	u.setUndoTypes()
	# g.print_stats()
#@+node:ekr.20031218072017.2040:<< undo clone cases >>
# We can immediately delete the clone because clone() can recreate it using only v.

if undoType == "Clone Node":
	
	c.selectVnode(u.p)
	c.deleteOutline()
	c.selectVnode(u.back)

elif undoType == "Drag & Clone":
	
	c.selectVnode(u.p)
	c.deleteOutline()
	c.selectVnode(u.oldV)
#@nonl
#@-node:ekr.20031218072017.2040:<< undo clone cases >>
#@+node:ekr.20031218072017.2041:<< undo delete cases >>
@ Deleting a clone is _not_ the same as undoing a clone:
the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

elif undoType == "Delete Node" or undoType == "Cut Node":
	
	if u.back:
		u.p.linkAfter(u.back)
	elif u.parent:
		u.p.linkAsNthChild(u.parent,0)
	else:
		oldRoot = c.rootPosition()
		u.p.linkAsRoot(oldRoot)
		
	# Restore all vnodeLists (and thus all clone marks).
	u.p.restoreLinksInTree()

	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2041:<< undo delete cases >>
#@+node:ekr.20031218072017.2042:<< undo hoist cases >>
elif undoType == "Hoist":
	
	c.selectVnode(u.p)
	c.dehoist()
	updateSetChangedFlag = false

elif undoType == "De-Hoist":
	
	c.selectVnode(u.p)
	c.hoist()
	updateSetChangedFlag = false
#@-node:ekr.20031218072017.2042:<< undo hoist cases >>
#@+node:ekr.20031218072017.2043:<< undo insert cases >>
elif undoType in ["Import","Insert Node","Paste Node"]:
	
	# g.trace(u.p)
	c.selectVnode(u.p)
	c.deleteOutline()
	if u.select:
		# g.trace("Insert/Paste:",u.select)
		c.selectVnode(u.select)
#@nonl
#@-node:ekr.20031218072017.2043:<< undo insert cases >>
#@+node:ekr.20031218072017.2044:<< undo move  & drag cases >>
elif undoType in ["Drag", "Move Down","Move Left","Move Right","Move Up"]:

	# g.trace("oldParent",u.oldParent)

	if u.oldParent:
		u.p.moveToNthChildOf(u.oldParent,u.oldN)
	elif u.oldBack:
		u.p.moveAfter(u.oldBack)
	else:
		oldRoot = c.rootPosition() # Bug fix: 4/9/04
		u.p.moveToRoot(oldRoot)

	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2044:<< undo move  & drag cases >>
#@+node:ekr.20031218072017.1712:<< undo replace cases >>
elif undoType in (
	"Convert All Blanks","Convert All Tabs",
	"Extract","Extract Names","Extract Section",
	"Read @file Nodes"):

	u.p = self.undoReplace(u.p,u.newTree,u.oldTree,u.oldText)
	c.selectVnode(u.p) # Does full recolor.
	if u.oldSel:
		c.frame.body.setTextSelection(u.oldSel)
	redrawFlag = true
#@nonl
#@-node:ekr.20031218072017.1712:<< undo replace cases >>
#@+node:ekr.20031218072017.2045:<< undo promote and demote cases >>
@ Promote and demote operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Demote":

	u.undoDemote()

elif undoType == "Promote":
	
	u.undoPromote()
#@nonl
#@-node:ekr.20031218072017.2045:<< undo promote and demote cases >>
#@+node:ekr.20031218072017.2046:<< undo sort cases >>
@ Sort operations are the hard to undo, because they involve relinking a list of nodes. We pass the work off to routines dedicated to the task.
@c

elif undoType == "Sort Children":
	
	u.undoSortChildren()

elif undoType == "Sort Siblings":
	
	u.undoSortSiblings()
	
elif undoType == "Sort Top Level":
	
	u.undoSortTopLevel()
	u.p = None # don't mark u.p dirty
#@nonl
#@-node:ekr.20031218072017.2046:<< undo sort cases >>
#@+node:ekr.20031218072017.2047:<< undo typing cases >>
@ When making "large" changes to text, we simply save the old and new text for undo and redo.  This happens rarely, so the expense is minor.

But for typical typing situations, where we are typing a single character, saving both the old and new text wastes a huge amount of space and puts extreme stress on the garbage collector.  This in turn can cause big performance problems.
@c
	
elif undoType in ( "Typing",
	"Change","Convert Blanks","Convert Tabs","Cut",
	"Delete","Indent","Paste","Reformat Paragraph","Undent"):

	# g.trace(undoType,u.p)
	# selectVnode causes recoloring, so don't do this unless needed.
	if current != u.p:
		c.selectVnode(u.p)
	elif undoType in ("Cut","Paste"):
		c.frame.body.forceFullRecolor()

	self.undoRedoText(
		u.p,u.leading,u.trailing,
		u.oldMiddleLines,u.newMiddleLines,
		u.oldNewlines,u.newNewlines,
		tag="undo",undoType=undoType)
	if u.oldSel:
		c.frame.body.setTextSelection(u.oldSel)
	if u.yview:
		c.frame.body.setYScrollPosition(u.yview)
	redrawFlag = (current != u.p)
		
elif undoType == "Change All":

	count = 0
	while 1:
		u.bead -= 1
		d = u.getBead(u.bead)
		assert(d)
		undoType = u.undoType
		# g.trace(undoType,u.p,u.oldText)
		if undoType == "Change All":
			c.selectVnode(u.p)
			break
		elif undoType == "Change":
			u.p.setTnodeText(u.oldText)  # p.setTnodeText
			count += 1
			u.p.setDirty()
		elif undoType == "Change Headline":
			u.p.initHeadString(u.oldText)  # p.initHeadString
			count += 1
		else: assert(false)
	g.es("undo %d instances" % count)
		
elif undoType == "Change Headline":
	
	# g.trace(u.oldText)
	u.p.setHeadStringOrHeadline(u.oldText)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2047:<< undo typing cases >>
#@-node:ekr.20031218072017.2039:u.undo
#@+node:ekr.20031218072017.3612:getBead, peekBead, setBead
def getBead (self,n):
	
	u = self
	if n < 0 or n >= len(u.beads):
		return None
	d = u.beads[n]
	# g.trace(n,len(u.beads),d)
	self.clearIvars()
	u.p = d["v"]
	u.undoType = d["undoType"]

	for ivar in optionalIvars:
		val = d.get(ivar,None)
		setattr(u,ivar,val)

	if not u.new_undo: # Recreate an "oldText" entry if necessary.
		if u.undoType == "Typing" and u.oldText == None:
			assert(n > 0)
			old_d = u.beads[n-1]
			# The user will lose data if these asserts fail.
			assert(old_d["undoType"] == "Typing")
			assert(old_d["v"] == u.p)
			u.oldText = old_d["newText"]
			# g.trace(u.oldText)
	return d
	
def peekBead (self,n):
	
	u = self
	if n < 0 or n >= len(u.beads):
		return None
	d = u.beads[n]
	# g.trace(n,len(u.beads),d)
	return d

def setBead (self,n,keywords=None):

	u = self ; d = {}
	d["undoType"]=u.undoType
	d["v"]=u.p
	# Only enter significant entries into the dictionary.
	# This is an important space optimization for typing.
	for ivar in optionalIvars:
		if getattr(u,ivar) != None:
			d[ivar] = getattr(u,ivar)
	# copy all significant keywords to d.
	if keywords:
		for key in keywords.keys():
			if keywords[key] != None:
				d[key] = keywords[key]
	# Clear the "oldText" entry if the previous entry was a "Typing" entry.
	# This optimization halves the space needed for Undo/Redo Typing.
	if not u.new_undo:
		if u.undoType == "Typing" and n > 0:
			old_d = u.beads[n-1]
			if old_d["undoType"] == "Typing" and old_d["v"] == u.p:
				del d["oldText"] # We can recreate this entry from old_d["newText"]
				# g.trace(u.oldText)
	# g.trace(d)
	return d
#@-node:ekr.20031218072017.3612:getBead, peekBead, setBead
#@+node:ekr.20031218072017.3615:setUndoParams
@ This routine saves enough information so an operation can be undone and redone.  We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoParams (self,undo_type,p,**keywords):
	
	# g.trace(undo_type,p,keywords)

	u = self
	if u.redoing or u.undoing: return None
	if undo_type == None:
		return None
	if undo_type == "Can't Undo":
		u.clearUndoState()
		return None

	# Set the type: set the menu labels later.
	u.undoType = undo_type
	# Calculate the standard derived information.
	u.p = p.copy()
	u.parent = p.parent()
	u.back = p.back()
	u.n = p.childIndex()
	# Push params on undo stack, clearing all forward entries.
	u.bead += 1
	d = u.setBead(u.bead,keywords)
	u.beads[u.bead:] = [d]
	# g.trace(len(u.beads),u.bead,keywords)
	# Recalculate the menu labels.
	u.setUndoTypes()
	return d
#@-node:ekr.20031218072017.3615:setUndoParams
#@-node:ekr.20040305222007:(undo/redo)
#@+node:ekr.20040310104639:(Get move working)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
	
	"""Return false if root or any of root's descedents is a clone of
	parent or any of parents ancestors."""

	message = "Illegal move or drag: no clone may contain a clone of itself"

	# g.trace("root",root,"parent",parent)
	clonedTnodes = {}
	for ancestor in parent.self_and_parents_iter():
		if ancestor.isCloned():
			t = ancestor.v.t
			clonedTnodes[t] = t

	if not clonedTnodes:
		return true

	for p in root.self_and_subtree_iter():
		if p.isCloned() and clonedTnodes.get(p.v.t):
			if warningFlag:
				g.alert(message)
			return false
	return true
#@nonl
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20031218072017.1767:demote
def demote(self):

	c = self ; p = c.currentPosition()
	if not p or not p.hasNext(): return

	last = p.lastChild()
	# Make sure all the moves will be valid.
	for child in p.children_iter():
		if not c.checkMoveWithParentWithWarning(child,p,true):
			return
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		while p.hasNext(): # Do not use iterator here.
			child = p.next()
			child.moveToNthChildOf(p,p.numberOfChildren())
		p.expand()
		c.selectVnode(p)
		p.setAllAncestorAtFileNodesDirty()
		c.setChanged(true)
	c.endUpdate()
	c.undoer.setUndoParams("Demote",p,lastChild=last)
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineDown(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	# Set next to the node after which p will be moved.
	next = p.visNext()
	while next and p.isAncestorOf(next):
		next = next.visNext()
	if not next: return
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		<< Move v down >>
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1769:<< Move v down >>
# Remember both the before state and the after state for undo/redo
oldBack = p.back()
oldParent = p.parent()
oldN = p.childIndex()

if next.hasChildren() and next.isExpanded():
	# Attempt to move p to the first child of next.
	if c.checkMoveWithParentWithWarning(p,next,true):
		p.moveToNthChildOf(next,0)
		c.undoer.setUndoParams("Move Down",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
else:
	# Attempt to move p after next.
	if c.checkMoveWithParentWithWarning(p,next.parent(),true):
		p.moveAfter(next)
		c.undoer.setUndoParams("Move Down",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
#@nonl
#@-node:ekr.20031218072017.1769:<< Move v down >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft(self):
	
	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	
	if not p.hasParent(): return
	# Remember both the before state and the after state for undo/redo
	parent = p.parent()
	oldBack = p.back()
	oldParent = p.parent()
	oldN = p.childIndex()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		p.moveAfter(parent)
		c.undoer.setUndoParams("Move Left",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight(self):
	
	c = self ; p = c.currentPosition()
	if not p: return
	
	if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	
	if not p.hasBack: return
	back = p.back()
	if not c.checkMoveWithParentWithWarning(p,back,true): return

	# Remember both the before state and the after state for undo/redo
	oldBack = back
	oldParent = p.parent()
	oldN = p.childIndex()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		n = back.numberOfChildren()
		p.moveToNthChildOf(back,n)
		c.undoer.setUndoParams("Move Right",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp(self):

	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineUp(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	back = p.visBack()
	if not back: return
	back2 = back.visBack()
	# A weird special case: just select back2.
	if back2 and p.v in back2.v.t.vnodeList:
		# g.trace('-'*20,"no move, selecting visBack")
		c.selectVnode(back2)
		return
	c = self
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		<< Move v up >>
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1773:<< Move v up >>
# Remember both the before state and the after state for undo/redo
oldBack = p.back()
oldParent = p.parent()
oldN = p.childIndex()
if 0:
	g.trace("visBack",back)
	g.trace("visBack2",back2)
	g.trace("oldParent",oldParent)
	g.trace("back2.hasChildren",back2.hasChildren())
	g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
	# p will be the new root node
	p.moveToRoot(c.rootVnode())
	c.undoer.setUndoParams("Move Up",p,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
	if c.checkMoveWithParentWithWarning(p,back2,true):
		p.moveToNthChildOf(back2,0)
		c.undoer.setUndoParams("Move Up",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(p,back2.parent(),true):
	# Insert after back2.
	p.moveAfter(back2)
	c.undoer.setUndoParams("Move Up",p,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
#@nonl
#@-node:ekr.20031218072017.1773:<< Move v up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote(self):

	c = self ; p = c.currentPosition()
	if not p or not p.hasChildren(): return

	last = p.lastChild()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		after = p
		while p.hasChildren(): # Don't use an iterator.
			child = p.firstChild()
			child.moveAfter(after)
			after = child
		p.setAllAncestorAtFileNodesDirty()
		c.setChanged(true)
		c.selectVnode(p)
	c.endUpdate()
	c.undoer.setUndoParams("Promote",p,lastChild=last)
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1774:promote
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@-node:ekr.20040310104639:(Get move working)
#@+node:ekr.20040311081401:(Get write working)
#@+node:ekr.20031218072017.2387:old_df.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=false,importing=false,reading=false):
	
	"""Scan position p and p's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.c
	<< Set ivars >>
	<< Set path from @file node >>
	old = {}
	for p in p.self_and_parents_iter():
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< Test for @path >>
		<< Test for @encoding >>
		<< Test for @comment and @language >>
		<< Test for @header and @noheader >>
		<< Test for @lineending >>
		<< Test for @pagewidth >>
		<< Test for @tabwidth >>
		old.update(dict)
	<< Set current directory >>
	if not importing and not reading:
		# 5/19/04: don't override comment delims when reading!
		<< Set comment strings from delims >>
#@nonl
#@+node:ekr.20031218072017.2388:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = g.app.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.2388:<< Set ivars >>
#@+node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

dir = g.choose(name,g.os_path_dirname(name),None)

if dir and len(dir) > 0 and g.os_path_isabs(dir):
	if g.os_path_exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = g.makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20031218072017.2390:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.2390:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.2391:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = g.scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e
#@nonl
#@-node:ekr.20031218072017.2391:<< Test for @encoding >>
#@+node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.2393:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = g.scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
#@-node:ekr.20031218072017.2393:<< Test for @lineending >>
#@+node:ekr.20031218072017.2394:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute relative path from s[k:] >>
	if path and len(path) > 0:
		base = g.getBaseDirectory() # returns "" on error.
		path = g.os_path_join(base,path)
		if g.os_path_isabs(path):
			<< handle absolute path >>
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.2396:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = g.makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
#@-node:ekr.20031218072017.2396:<< handle absolute path >>
#@-node:ekr.20031218072017.2394:<< Test for @path >>
#@+node:ekr.20031218072017.2397:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = g.scanAtPagewidthDirective(s,dict,issue_error_flag=true)
	if w and w > 0:
		self.page_width = w
#@nonl
#@-node:ekr.20031218072017.2397:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.2398:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = g.scanAtTabwidthDirective(s,dict,issue_error_flag=true)
	if w and w != 0:
		self.tab_width = w

#@-node:ekr.20031218072017.2398:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.2399:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = g.getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) > 0:
			dir = g.os_path_join(base,dir)
			if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
				if g.os_path_exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = g.makeAllNonExistentDirectories(dir)

if not self.default_directory and not scripting:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""
#@nonl
#@-node:ekr.20031218072017.2399:<< Set current directory >>
#@+node:ekr.20031218072017.2400:<< Set comment strings from delims >>
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	g.es("Unknown language: using Python comment delimiters")
	g.es("c.target_language:",c.target_language)
	g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""
	
# g.trace(self.startSentinelComment)
#@nonl
#@-node:ekr.20031218072017.2400:<< Set comment strings from delims >>
#@-node:ekr.20031218072017.2387:old_df.scanAllDirectives
#@+node:ekr.20031218072017.2140:executeScript
def executeScript(self,p=None,script=None):

	"""This executes body text as a Python script.
	
	We execute the selected text, or the entire body text if no text is selected."""
	
	error = false
	c = self ; s = None

	if script:
		s = script
	else:
		<< get script into s >>
	<< redirect output if redirect_execute_script_output_to_log_pane >>
	s = s.strip()
	if s:
		s += '\n' # Make sure we end the script properly.
		try:
			exec s in {} # Use {} to get a pristine environment!
			if not script:
				g.es("end of script",color="purple")
		except:
			g.es("exception executing script")
			g.es_exception(full=false,c=c)
			c.frame.tree.redrawAfterException() # 1/26/04
	elif not error:
		g.es("no script selected",color="blue")
		
	# 4/3/04: The force a redraw _after_ all messages have been output.
	c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2142:<< get script into s >>
try:
	try:
		if not p:
			p = c.currentPosition()
	
		old_body = p.bodyString()

		if c.frame.body.hasTextSelection():
			# Temporarily replace v's body text with just the selected text.
			s = c.frame.body.getSelectedText()
			p.v.setTnodeText(s) 
		else:
			s = c.frame.body.getAllText()
	
		if s.strip():
			g.app.scriptDict["script1"]=s
			df = c.atFileCommands.new_df
			df.scanAllDirectives(p,scripting=true)
			# Force Python comment delims.
			df.startSentinelComment = "#"
			df.endSentinelComment = None
			# Write the "derived file" into fo.
			fo = g.fileLikeObject()
			df.write(p.copy(),nosentinels=true,scriptFile=fo)
			assert(p)
			s = fo.get()
			g.app.scriptDict["script2"]=s
			error = len(s) == 0
	except:
		s = "unexpected exception"
		print s ; g.es(s)
		g.es_exception()
finally:
	p.v.setTnodeText(old_body)
#@nonl
#@-node:ekr.20031218072017.2142:<< get script into s >>
#@+node:ekr.20031218072017.2143:<< redirect output if redirect_execute_script_output_to_log_pane >>
if g.app.config.redirect_execute_script_output_to_log_pane:

	from leoGlobals import redirectStdout,redirectStderr
	g.redirectStdout() # Redirect stdout
	g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output if redirect_execute_script_output_to_log_pane >>
#@-node:ekr.20031218072017.2140:executeScript
#@+node:ekr.20031218072017.1570:assignFileIndices & compactFileIndices
def assignFileIndices (self):
	
	"""Assign a file index to all tnodes"""
	
	c = self.c ; nodeIndices = g.app.nodeIndices

	nodeIndices.setTimestamp() # This call is fairly expensive.

	if g.app.use_gnx:
		<< assign missing gnx's, converting ints to gnx's >>
	else:
		<< reassign all tnode indices >>
		
	if 0: # debugging:
		for p in c.allNodes_iter():
			g.trace(p.v.t.fileIndex)

# Indices are now immutable, so there is no longer any difference between these two routines.
compactFileIndices = assignFileIndices
#@nonl
#@+node:ekr.20031218072017.1571:<< assign missing gnx's, converting ints to gnx's >>
# Always assign an (immutable) index, even if the tnode is empty.

for p in c.allNodes_iter():
	try: # Will fail for None or any pre 4.1 file index.
		id,time,n = p.v.t.fileIndex
	except TypeError:
		# Don't convert to string until the actual write.
		p.v.t.fileIndex = nodeIndices.getNewIndex()
#@nonl
#@-node:ekr.20031218072017.1571:<< assign missing gnx's, converting ints to gnx's >>
#@+node:ekr.20031218072017.1572:<< reassign all tnode indices >>
# Clear out all indices.
for p in c.allNodes_iter():
	p.v.t.fileIndex = None
	
# Recreate integer indices.
self.maxTnodeIndex = 0

for p in c.allNodes_iter():
	if p.v.t.fileIndex == None:
		self.maxTnodeIndex += 1
		p.v.t.fileIndex = self.maxTnodeIndex
#@nonl
#@-node:ekr.20031218072017.1572:<< reassign all tnode indices >>
#@-node:ekr.20031218072017.1570:assignFileIndices & compactFileIndices
#@+node:ekr.20031218072017.1577:putTnode
def putTnode (self,t):

	self.put("<t")
	self.put(" tx=")

	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(t.fileIndex)
		self.put_in_dquotes(gnx)
	else:
		self.put_in_dquotes("T" + str(t.fileIndex))

	if hasattr(t,"unknownAttributes"):
		<< put unknown tnode attributes >>
	self.put(">")

	# g.trace(t)
	if t.bodyString:
		self.putEscapedString(t.bodyString)

	self.put("</t>") ; self.put_nl()
#@nonl
#@+node:ekr.20031218072017.1578:<< put unknown tnode attributes >>
attrDict = t.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 1: # For debugging.
		s = "putting unknown tnode attribute"
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1578:<< put unknown tnode attributes >>
#@-node:ekr.20031218072017.1577:putTnode
#@+node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
def putTnodeList (self,v):
	
	"""Put the tnodeList attribute of a tnode."""
	
	# g.trace(v)
	
	# Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

	fc = self ; nodeIndices = g.app.nodeIndices
	tnodeList = v.t.tnodeList
	if tnodeList:
		# g.trace("%4d" % len(tnodeList),v)
		fc.put(" tnodeList=") ; fc.put_dquote()
		if g.app.use_gnx:
			for t in tnodeList:
				try: # Will fail for None or any pre 4.1 file index.
					id,time,n = t.fileIndex
				except:
					g.trace("assigning gnx for ",v,t)
					gnx = nodeIndices.getNewIndex()
					v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
			s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
		else:
			s = ','.join([str(t.fileIndex) for t in tnodeList])
		fc.put(s) ; fc.put_dquote()
#@nonl
#@-node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):
	
	"""Puts all tnodes as required for copy or save commands"""

	c = self.c

	self.put("<tnodes>") ; self.put_nl()
	<< write only those tnodes that were referenced >>
	self.put("</tnodes>") ; self.put_nl()
#@nonl
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
# Populate tnodes
tnodes = {}

if self.usingClipboard: # write the current tree.
	root = c.currentPosition()
else: # write everything
	root = c.rootPosition()

for p in c.allNodes_iter():
	index = p.v.t.fileIndex
	assert(index)
	tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
	# g.trace(index)
	t = tnodes.get(index)
	assert(t)
	# Write only those tnodes whose vnodes were written.
	if t.isWriteBit(): # 5/3/04
		self.putTnode(t)
#@nonl
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

	"""Puts all <v> elements in the order in which they appear in the outline."""

	c = self.c
	c.clearAllVisited()

	self.put("<vnodes>") ; self.put_nl()

	# Make only one copy for all calls.
	self.currentPosition = c.currentPosition() 
	self.topPosition     = c.topPosition()

	if self.usingClipboard:
		self.putVnode(self.currentPosition) # Write only current tree.
	else:
		for p in c.rootPosition().self_and_siblings_iter():
			self.putVnode(p) # Write the next top-level node.

	self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@-node:ekr.20040311081401:(Get write working)
#@+node:ekr.20040308153521:(Read Leo file to 4.2 format)
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=true):

	c = self.c
	c.setChanged(false) # 10/1/03: May be set when reading @file nodes.
	<< warn on read-only files >>
	self.mFileName = c.mFileName
	self.tnodesDict = {}
	ok = true
	c.loading = true # disable c.changed
	
	try:
		<< scan all the xml elements >>
	except BadLeoFile, message:
		<< raise an alert >>
		ok = false

	c.frame.tree.redraw_now(scroll=false)
	
	if ok and atFileNodesFlag:
		c.atFileCommands.readAll(c.rootVnode(),partialFlag=false)

	if not c.currentPosition():
		c.setCurrentPosition(c.rootPosition())

	c.selectVnode(c.currentPosition()) # load body pane
	c.loading = false # reenable c.changed
	c.setChanged(c.changed) # Refresh the changed marker.
	self.tnodesDict = {}
	return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
try:
	self.read_only = false
	self.read_only = not os.access(fileName,os.W_OK)
	if self.read_only:
		g.es("read only: " + fileName,color="red")
except:
	if 0: # testing only: access may not exist on all platforms.
		g.es("exception getting file access")
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()
self.getTag("<leo_file>")
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self):

	c = self.c

	if self.getOpenTag("<vnodes>"):
		return
		
	if self.usingClipboard:
		oldRoot = c.rootPosition()
		oldCurrent = c.currentPosition()

	back = parent = None # This routine _must_ work on vnodes!
	
	self.currentVnodeStack = []
	self.topVnodeStack = []
	while self.matchTag("<v"):
		append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
		append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip=false,
			appendToCurrentStack=append1,appendToTopStack=append2)

	if self.usingClipboard:
		# Link in the pasted nodes after the current position.
		newRoot = c.rootPosition()
		c.setRootPosition(oldRoot)
		newRoot.v.linkAfter(oldCurrent.v)
		newCurrent = oldCurrent.copy()
		newCurrent.v = newRoot.v
		c.setCurrentPosition(newCurrent)
	else:
		<< set current and top positions >>

	self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
	c.setCurrentPosition(current)
else:
	# g.trace(self.currentVnodeStack)
	c.setCurrentPosition(c.rootPosition())
	
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
	c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

	c = self.c ; v = None
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
	# we have already matched <v.
	while 1:
		if self.matchTag("a=\""):
			<< Handle vnode attribute bits >>
		elif self.matchTag("t="):
			# New for 4.1.  Read either "Tnnn" or "gnx".
			tref = self.getDqString()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList="):
			s = self.getDqString()
			tnodeList = self.getTnodeList(s) # New for 4.0
		elif self.matchTag(">"):
			break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val
	# Headlines are optional.
	if self.matchTag("<vh>"):
		headline = self.getEscapedString() ; self.getTag("</vh>")
	
	# g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
	if skip:
		v = self.getExistingVnode(tref)
	else:
		v,skip = self.createVnode(parent,back,tref,headline,attrDict)
		if tnodeList:
			v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
			# g.trace("%4d" % len(tnodeList),v)

	<< Set the remembered status bits >>

	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("<v"):
		append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
		append2 = appendToTopStack and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip,
			appendToCurrentStack=append1,appendToTopStack=append2)
			
	<< Append to current or top stack >>

	# End this vnode.
	self.getTag("</v>")
	return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
	self.currentVnodeStack = [v]

if setTop:
	self.topVnodeStack = [v]
	
if setExpanded:
	v.initExpandedBit()
	
if setMarked:
	v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
	v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
	#g.trace("append current",v)
	self.currentVnodeStack.append(v)
	
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
	#g.trace("append top",v)
	self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:ekr.20031218072017.1860:createVnode (changed for 4.2)
def createVnode (self,parent,back,tref,headline,attrDict):
	
	# g.trace(parent,headline)
	v = None ; c = self.c
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		tref = self.canonicalTnodeIndex(tref)
		t = self.tnodesDict.get(tref)
		if not t: t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c,t)
		v.moveToRoot()

	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v) # New in 4.2.

	skip = len(v.t.vnodeList) > 1

	v.initHeadString(headline,encoding=self.leo_file_encoding)
	<< handle unknown vnode attributes >>
	return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
	v.unknownAttributes = attrDict

	if 0: # For debugging.
		s = "unknown attributes for " + v.headString()
		print s ; g.es(s,color="blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode (changed for 4.2)
#@+node:ekr.20031218072017.1560:getTnodes
def getTnodes (self):

	# A slight change: we require a tnode element.  But Leo always writes this.
	if self.getOpenTag("<tnodes>"):
		return
		
	while self.matchTag("<t"):
		self.getTnode()

	self.getTag("</tnodes>")
#@-node:ekr.20031218072017.1560:getTnodes
#@+node:ekr.20031218072017.1561:getTnode
def getTnode (self):

	# we have already matched <t.
	index = -1 ; attrDict = {}
	# New in version 1.7: attributes may appear in any order.
	while 1:	
		if self.matchTag("tx="):
			# New for 4.1.  Read either "Tnnn" or "gnx".
			index = self.getDqString()
		elif self.matchTag("rtf=\"1\""): pass # ignored
		elif self.matchTag("rtf=\"0\""): pass # ignored
		elif self.matchTag(">"):         break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val
			
	if g.app.use_gnx:
		# index might be Tnnn, nnn, or gnx.
		id,time,n = g.app.nodeIndices.scanGnx(index,0)
		if time == None: # A pre-4.1 file index.
			if index[0] == "T":
				index = index[1:]

	index = self.canonicalTnodeIndex(index)
	t = self.tnodesDict.get(index)
	# g.trace(t)
	<< handle unknown attributes >>
	if t:
		if self.usingClipboard:
			<< handle read from clipboard >>
		else:
			<< handle read from file >>
	else:
		g.es("no tnode with index: %s.  The text will be discarded" % str(index))
	self.getTag("</t>")
#@+node:ekr.20031218072017.1562:<< handle read from file >>
s = self.getEscapedString()
t.setTnodeText(s,encoding=self.leo_file_encoding)
#@nonl
#@-node:ekr.20031218072017.1562:<< handle read from file >>
#@+node:ekr.20031218072017.1563:<< handle read from clipboard >>
if t:
	s = self.getEscapedString()
	t.setTnodeText(s,encoding=self.leo_file_encoding)
	# g.trace(index,len(s))
#@nonl
#@-node:ekr.20031218072017.1563:<< handle read from clipboard >>
#@+node:ekr.20031218072017.1564:<< handle unknown attributes >>
keys = attrDict.keys()
if keys:
	t.unknownAttributes = attrDict
	if 0: # For debugging.
		s = "unknown attributes for tnode"
		print s ; g.es(s, color = "blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1564:<< handle unknown attributes >>
#@-node:ekr.20031218072017.1561:getTnode
#@-node:ekr.20040308153521:(Read Leo file to 4.2 format)
#@+node:ekr.20040311133449:(Cut/paste outlines)
#@+node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
# This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s):

	self.usingClipboard = true
	self.fileBuffer = s ; self.fileIndex = 0
	self.tnodesDict = {}

	try:
		self.getXmlVersionTag() # leo.py 3.0
		self.getXmlStylesheetTag() # 10/25/02
		self.getTag("<leo_file>")
		self.getClipboardHeader()
		self.getVnodes()
		self.getTnodes()
		self.getTag("</leo_file>")
		v = self.finishPaste()
	except BadLeoFile:
		v = None

	# Clean up.
	self.fileBuffer = None ; self.fileIndex = 0
	self.usingClipboard = false
	self.tnodesDict = {}
	return v
#@nonl
#@-node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self):

	c = self ; current = c.currentPosition()
	
	s = g.app.gui.getTextFromClipboard()

	if not s or not c.canPasteOutline(s):
		return # This should never happen.

	isLeo = g.match(s,0,g.app.prolog_prefix_string)

	if isLeo:
		p = c.fileCommands.getLeoOutline(s)
	else:
		p = c.importCommands.convertMoreStringToOutlineAfter(s,current)
		
	if p:
		c.endEditing()
		c.beginUpdate()
		if 1: # inside update...
			c.validateOutline()
			c.selectVnode(p)
			p.setDirty()
			c.setChanged(true)
			# paste as first child if back is expanded.
			back = p.back()
			if back and back.isExpanded():
				p.moveToNthChildOf(back,0)
			c.undoer.setUndoParams("Paste Node",p)
		c.endUpdate()
		c.recolor()
	else:
		g.es("The clipboard is not a valid " + g.choose(isLeo,"Leo","MORE") + " file")
#@nonl
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1557:finishPaste
# This method finishes pasting the outline from the clipboard.
def finishPaste(self):

	c = self.c
	current = c.currentPosition()
	c.beginUpdate()
	<< reassign tnode indices and clear all clone links >>
	c.selectVnode(current)
	c.endUpdate()
	return current
#@nonl
#@+node:ekr.20031218072017.1558:<< reassign tnode indices and clear all clone links >>
@ putLeoOutline calls assignFileIndices (when copying nodes) so that vnode can be associated with tnodes.
However, we must _reassign_ the indices here so that no "false clones" are created.
@c

current.clearVisitedInTree()

for p in current.self_and_subtree_iter():
	t = p.v.t
	if not t.isVisited():
		t.setVisited()
		self.maxTnodeIndex += 1
		t.setFileIndex(self.maxTnodeIndex)
#@nonl
#@-node:ekr.20031218072017.1558:<< reassign tnode indices and clear all clone links >>
#@-node:ekr.20031218072017.1557:finishPaste
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self):

	c = self.c

	if self.getOpenTag("<vnodes>"):
		return
		
	if self.usingClipboard:
		oldRoot = c.rootPosition()
		oldCurrent = c.currentPosition()

	back = parent = None # This routine _must_ work on vnodes!
	
	self.currentVnodeStack = []
	self.topVnodeStack = []
	while self.matchTag("<v"):
		append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
		append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip=false,
			appendToCurrentStack=append1,appendToTopStack=append2)

	if self.usingClipboard:
		# Link in the pasted nodes after the current position.
		newRoot = c.rootPosition()
		c.setRootPosition(oldRoot)
		newRoot.v.linkAfter(oldCurrent.v)
		newCurrent = oldCurrent.copy()
		newCurrent.v = newRoot.v
		c.setCurrentPosition(newCurrent)
	else:
		<< set current and top positions >>

	self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
	c.setCurrentPosition(current)
else:
	# g.trace(self.currentVnodeStack)
	c.setCurrentPosition(c.rootPosition())
	
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
	c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

	c = self.c ; v = None
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
	# we have already matched <v.
	while 1:
		if self.matchTag("a=\""):
			<< Handle vnode attribute bits >>
		elif self.matchTag("t="):
			# New for 4.1.  Read either "Tnnn" or "gnx".
			tref = self.getDqString()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList="):
			s = self.getDqString()
			tnodeList = self.getTnodeList(s) # New for 4.0
		elif self.matchTag(">"):
			break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val
	# Headlines are optional.
	if self.matchTag("<vh>"):
		headline = self.getEscapedString() ; self.getTag("</vh>")
	
	# g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
	if skip:
		v = self.getExistingVnode(tref)
	else:
		v,skip = self.createVnode(parent,back,tref,headline,attrDict)
		if tnodeList:
			v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
			# g.trace("%4d" % len(tnodeList),v)

	<< Set the remembered status bits >>

	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("<v"):
		append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
		append2 = appendToTopStack and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip,
			appendToCurrentStack=append1,appendToTopStack=append2)
			
	<< Append to current or top stack >>

	# End this vnode.
	self.getTag("</v>")
	return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
	self.currentVnodeStack = [v]

if setTop:
	self.topVnodeStack = [v]
	
if setExpanded:
	v.initExpandedBit()
	
if setMarked:
	v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
	v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
	#g.trace("append current",v)
	self.currentVnodeStack.append(v)
	
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
	#g.trace("append top",v)
	self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:ekr.20031218072017.1860:createVnode (changed for 4.2)
def createVnode (self,parent,back,tref,headline,attrDict):
	
	# g.trace(parent,headline)
	v = None ; c = self.c
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		tref = self.canonicalTnodeIndex(tref)
		t = self.tnodesDict.get(tref)
		if not t: t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c,t)
		v.moveToRoot()

	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v) # New in 4.2.

	skip = len(v.t.vnodeList) > 1

	v.initHeadString(headline,encoding=self.leo_file_encoding)
	<< handle unknown vnode attributes >>
	return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
	v.unknownAttributes = attrDict

	if 0: # For debugging.
		s = "unknown attributes for " + v.headString()
		print s ; g.es(s,color="blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode (changed for 4.2)
#@-node:ekr.20040311133449:(Cut/paste outlines)
#@-node:ekr.20040325203859:3/11 to 3/20
#@+node:ekr.20040325203859.1:3/21
#@+node:ekr.20040312024615:(Fixed bug in sortTopLevel)
@ This was a nasty one.  The problem was in linkAsRoot, not linkAfter.
#@nonl
#@+node:ekr.20040312145256:v.dump
def dumpLink (self,link):
	return g.choose(link,link,"<none>")

def dump (self,label=""):
	
	v = self

	if label:
		print '-'*10,label,v
	else:
		print "self    ",v.dumpLink(v)
		print "len(vnodeList)",len(v.t.vnodeList)
	print "_back   ",v.dumpLink(v._back)
	print "_next   ",v.dumpLink(v._next)
	print "_parent ",v.dumpLink(v._parent)
	print "t._child",v.dumpLink(v.t._firstChild)
#@nonl
#@-node:ekr.20040312145256:v.dump
#@+node:ekr.20040310153624:p.dump & p.vnodeListIds
def dumpLink (self,link):

	return g.choose(link,link,"<none>")

def dump (self,label=""):
	
	p = self

	print '-'*10,label,p

	if p.v:
		p.v.dump() # Don't print a label
		
def vnodeListIds (self):
	
	p = self
	return [id(v) for v in p.v.t.vnodeList]
#@nonl
#@-node:ekr.20040310153624:p.dump & p.vnodeListIds
#@+node:ekr.20031218072017.2029:drawTopTree
def drawTopTree (self):
	
	"""Draws the top-level tree, taking into account the hoist state."""
	
	c = self.c
	
	if c.hoistStack:
		p,junk = c.hoistStack[-1]
		self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=true)
	else:
		self.drawTree(c.rootPosition(),root_left,root_top,0,0)
		
	# g.trace(g.app.copies) ; g.app.copies = 0
	# import traceback ; traceback.print_stack()
#@nonl
#@-node:ekr.20031218072017.2029:drawTopTree
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

	def __getattr__ (self,attr):
		
		"""Convert references to p.t into references to p.v.t.
		
		N.B. This automatically keeps p.t in synch with p.v.t."""

		if attr=="t":
			return self.v.t
		else:
			# Only called when normal lookup fails.
			raise AttributeError
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20040306214240.3:p.hasChildren
def hasChildren(self):
	
	p = self
	# g.trace(p,p.v)
	return p.v and p.v.t and p.v.t._firstChild
#@nonl
#@-node:ekr.20040306214240.3:p.hasChildren
#@+node:ekr.20031218072017.2896:c.sortTopLevel
def sortTopLevel (self):
	
	# Create a list of position, headline tuples
	c = self ; root = c.rootPosition()
	if not root: return
	<< Set the undo info for sortTopLevel >>
	pairs = []
	for p in root.self_and_siblings_iter(copy=true):
		pairs.append((p.headString().lower(),p),)
	# Sort the list on the headlines.
	pairs.sort()
	sortedNodes = pairs
	# Move the nodes
	c.beginUpdate()
	h,p = sortedNodes[0]
	if p != root:
		p.setAllAncestorAtFileNodesDirty()
		p.moveToRoot(oldRoot=root)
		p.setAllAncestorAtFileNodesDirty()
	for h,next in sortedNodes[1:]:
		next.moveAfter(p)
		p = next
	if 0:
		g.trace("-----moving done")
		for p in c.rootPosition().self_and_siblings_iter():
			print p,p.v
	c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.2897:<< Set the undo info for sortTopLevel >>
# Get the present list of children.
sibs = []

for sib in root.self_and_siblings_iter(copy=true):
	sibs.append(sib)
	
c.undoer.setUndoParams("Sort Top Level",root,sort=sibs)
#@nonl
#@-node:ekr.20031218072017.2897:<< Set the undo info for sortTopLevel >>
#@-node:ekr.20031218072017.2896:c.sortTopLevel
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

	"""Move a position after position a."""
	
	p = self ; c = p.c # Do NOT copy the position!
	p.unlink()
	p.linkAfter(a)
	
	# Moving a node after another node can create a new root node.
	if not a.hasParent() and not a.hasBack():
		c.setRootPosition(a)

	return p
#@nonl
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

	"""Link self after v."""
	
	p = self
	# g.trace(p,after)
	
	p.stack = after.stack[:] # 3/12/04
	p.v._parent = after.v._parent
	
	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
	
	p.v._back = after.v
	p.v._next = after.v._next
	
	after.v._next = p.v
	
	if p.v._next:
		p.v._next._back = p.v

	if 0:
		g.trace('-'*20,after)
		p.dump(label="p")
		after.dump(label="back")
		if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link self as the root node."""
	
	# g.trace(self,oldRoot)

	p = self ; v = p.v
	if oldRoot: oldRootVnode = oldRoot.v
	else:       oldRootVnode = None
	
	p.stack = [] # Clear the stack.
	
	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRootVnode # Bug fix: 3/12/04
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot:
		oldRoot.v._back = v # Bug fix: 3/12/04

	p.c.setRootPosition(p)
	
	if 0:
		p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@-node:ekr.20040312024615:(Fixed bug in sortTopLevel)
#@+node:ekr.20040314103754:(Fixed hoist command)
@nocolor

The initial problem was a mistransliteration in drawTree.

While I was at it, I improved the code as follows:
	
- The hoist code now saves and restores the expansion state of outlines.
- The hoist plugin now dims/undims the buttons.

@color
#@nonl
#@+node:ekr.20031218072017.2029:drawTopTree
def drawTopTree (self):
	
	"""Draws the top-level tree, taking into account the hoist state."""
	
	c = self.c
	
	if c.hoistStack:
		p,junk = c.hoistStack[-1]
		self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=true)
	else:
		self.drawTree(c.rootPosition(),root_left,root_top,0,0)
		
	# g.trace(g.app.copies) ; g.app.copies = 0
	# import traceback ; traceback.print_stack()
#@nonl
#@-node:ekr.20031218072017.2029:drawTopTree
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20031218072017.2028:Hoist & dehoist & enablers
def dehoist(self):

	c = self ; p = c.currentPosition()
	g.trace(p)
	if p and c.canDehoist():
		c.undoer.setUndoParams("De-Hoist",p)
		h,expanded = c.hoistStack.pop()
		if expanded: p.expand()
		else:        p.contract()
		c.redraw()
		c.frame.clearStatusLine()
		if c.hoistStack:
			p,junk = c.hoistStack[-1]
			c.frame.putStatusLine("Hoist: " + p.headString())
		else:
			c.frame.putStatusLine("No hoist")

def hoist(self):

	c = self ; p = c.currentPosition()
	if p and c.canHoist():
		c.undoer.setUndoParams("Hoist",p)
		# New in 4.2: remember expansion state.
		c.hoistStack.append((p,p.isExpanded()),)
		p.expand()
		c.redraw()
		c.frame.clearStatusLine()
		c.frame.putStatusLine("Hoist: " + p.headString())
#@nonl
#@-node:ekr.20031218072017.2028:Hoist & dehoist & enablers
#@+node:ekr.20031218072017.1761:c.insertHeadline
# Inserts a vnode after the current vnode.  All details are handled by the vnode class.

def insertHeadline (self,op_name="Insert Node"):

	c = self ; p = c.currentPosition()
	hasChildren = p.hasChildren()
	isExpanded  = p.isExpanded()
	if not p: return

	c.beginUpdate()
	if 1: # inside update...
		if (
			# 1/31/04: Make sure new node is visible when hoisting.
			(hasChildren and isExpanded) or
			(c.hoistStack and p == c.hoistStack[-1][0])
		):
			p = p.insertAsNthChild(0)
		else:
			p = p.insertAfter()
		c.undoer.setUndoParams(op_name,p,select=p)
		c.selectVnode(p)
		c.editPosition(p)
		p.setAllAncestorAtFileNodesDirty()
		c.setChanged(true)
	c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20040131170659:canClone (new for hoist)
def canClone (self):

	c = self
	
	if c.hoistStack:
		current = c.currentPosition()
		p,junk = c.hoistStack[-1]
		return current != p
	else:
		return true
#@nonl
#@-node:ekr.20040131170659:canClone (new for hoist)
#@-node:ekr.20040314103754:(Fixed hoist command)
#@+node:ekr.20040314110927.1:(Got all unit tests working)
@

- All unit tests now pass with p.__getattr__ ON or OFF.

- Moved Head & body text setters from vnode class into position class.
- Added p.setTnodeText and v.setTnodeText as substitutes for p.v.t.setTnodeText.

- Added verbose and unittest params to c.checkOutline:
	- Don't run long tests during unit testing.
#@nonl
#@+node:ekr.20040315031219.1:Flatten outline
#@+node:ekr.20031218072017.1147:flattenOutline
def flattenOutline (self,fileName):

	c = self.c ; nl = self.output_newline
	p = c.currentVnode()
	if not p: return
	self.setEncoding()
	firstLevel = p.level()
	try:
		# 10/14/02: support for output_newline setting.
		mode = g.app.config.output_newline
		mode = g.choose(mode=="platform",'w','wb')
		file = open(fileName,mode)
		
		for p in p.self_and_subtree_iter():
			head = p.moreHead(firstLevel)
			head = g.toEncodedString(head,self.encoding,reportErrors=true)
			file.write(head + nl)
			body = p.moreBody() # Inserts escapes.
			if len(body) > 0:
				body = g.toEncodedString(body,self.encoding,reportErrors=true)
				file.write(body + nl)
		file.close()
	except:
		g.es("exception while flattening outline")
		g.es_exception()
#@-node:ekr.20031218072017.1147:flattenOutline
#@+node:ekr.20040315023430:File Conversion
@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
#@+node:ekr.20040315023430.1:convertTreeToString
def convertTreeToString (self):
	
	"""Convert a positions  suboutline to a string in MORE format."""

	p = self ; level1 = p.level()
	
	g.trace()
	
	array = []
	for p in p.self_and_subtree_iter():
		array.append(p.moreHead(level1)+'\n')
		body = p.moreBody()
		if body:
			array.append(body +'\n')

	return ''.join(array)
#@-node:ekr.20040315023430.1:convertTreeToString
#@+node:ekr.20040315023430.2:moreHead
def moreHead (self, firstLevel,useVerticalBar=false):
	
	"""Return the headline string in MORE format."""

	p = self

	level = self.level() - firstLevel
	plusMinus = g.choose(p.hasChildren(), "+", "-")
	
	return "%s%s %s" % ('\t'*level,plusMinus,p.headString())
#@nonl
#@-node:ekr.20040315023430.2:moreHead
#@+node:ekr.20040315023430.3:moreBody
@ 
	+ test line
	- test line
	\ test line
	test line +
	test line -
	test line \
	More lines...
@c

def moreBody (self):

	"""Returns the body string in MORE format.  
	
	Inserts a backslash before any leading plus, minus or backslash."""

	p = self ; array = []
	lines = string.split(p.bodyString(),'\n')
	for s in lines:
		i = g.skip_ws(s,0)
		if i < len(s) and s[i] in ('+','-','\\'):
			s = s[:i] + '\\' + s[i:]
		array.append(s)
	return '\n'.join(array)
#@nonl
#@-node:ekr.20040315023430.3:moreBody
#@-node:ekr.20040315023430:File Conversion
#@-node:ekr.20040315031219.1:Flatten outline
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=true,unittest=false):
	
	"""Report any possible clone errors in the outline.
	
	Remove any unused tnodeLists."""
	
	c = self ; count = 1 ; errors = 0 ; full = true
	if full and not unittest:
		g.es("all tests enabled: this may take awhile",color="blue")

	try:
		p = c.rootPosition()
		<< assert equivalence of lastVisible methods >>
		for p in c.allNodes_iter():
			count += 1
			<< remove unused tnodeList >>
			if not unittest: # this would be very slow.
				if full: # For testing only.
					<< do full tests >>
			# assert false, "checkFailed" # check of checkFailed itself.
	except AssertionError,message:
		errors += 1
		<< give test failed message >>
	if not unittest:
		<< print summary message >>
	return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
	g.app.debug = true

	p1 = p.oldLastVisible()
	p2 = p.lastVisible()
	
	if p1 != p2:
		print "oldLastVisible",p1
		print "   lastVisible",p2
	
	assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
	assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
	
	g.app.debug = false
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v
# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
	s = "deleting tnodeList for " + repr(v)
	print s ; g.es(s,color="blue")
	delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if count % 100 == 0:
	g.es('.',newline=false)
if count % 2000 == 0:
	g.enl()

@others
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
	assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
	assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
	assert p == back.next(), "p==back.next"
		
if next:
	assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and chiild links
if p.hasParent():
	n = p.childIndex()
	assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
	
for child in p.children_iter():
	assert p == child.parent(), "p==child.parent"

if p.hasNext():
	assert p.next().parent() == p.parent(), "next.parent==parent"
	
if p.hasBack():
	assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and chiild links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
	t = p.parent().v.t
	for v in p.directParents():
		assert(v.t == t)
#@nonl
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
	parents = p.v.t.vnodeList
	for child in p.children_iter():
		vparents = child.directParents()
		assert(len(parents) == len(vparents))
		for parent in parents:
			assert(parent in vparents)
		for parent in vparents:
			assert(parent in parents)
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
	childv = p.firstChild().v
	assert(childv == p.v.t._firstChild)
	assert(id(childv) == id(p.v.t._firstChild))
	for v in p.v.t.vnodeList:
		assert(v.t._firstChild == childv)
		assert(id(v.t._firstChild) == id(childv))
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
	
for v in vnodeList:
	
	assert v.t == p.v.t, "v.t == p.v.t"

	if p.v.isCloned():
		assert v.isCloned(), "v.isCloned"
		assert len(vnodeList) > 1, "len(vnodeList) > 1"
	else:
		assert not v.isCloned(), "not v.isCloned"
		assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
	print
	g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
	print s ; g.es(s,color="red")
elif verbose:
	g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
if errors == 1:
	s = "test failed: %s %s" % (message,repr(p))
	print s
	g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@-node:ekr.20040314110927.1:(Got all unit tests working)
#@+node:ekr.20040312120107:(Fixed move/drawing/level bugs)
#@+node:ekr.20040312213623: Notes
@nocolor

There were several difficult bugs here.

1. There is a potential confusion between these two kinds of methods:

- The p.moveToX methods:  these are internal use routines.

- The externally visible "Moving, Inserting, Deleting, Cloning, Sorting (position)" methods,

especially p.moveToRoot, p.moveAfter and p.moveToNthChildOf.

These routines must NOT create copies of their positions.  They must alter the position "in place".

2. p.linkAsRoot, p.linkAfter and p.linkAsNthChild must _recreate_ the stack.

3. p.level reported the wrong value, sometimes spectacularly wrong, during redraw for nested clones.

This was fixed by clearing the _parent link in linkAsNthChild when pushing the stack.

4. Moved tree.lastVisible to position class where it belongs.  Changed names to getLastVisible and moveToLastVisible.

5. Greatly simplified p.nodeAfter and p.threadNext.

6. Added assertions that the old or simplified versions of routines are equivalent to the new versions.

This is "having my cake and eating it too."
#@nonl
#@-node:ekr.20040312213623: Notes
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

	# These ivars are the global vars of this program.
	self.afterHandler = None
	self.batchMode = false # true: run in batch mode.
	self.commandName = None # The name of the command being executed.
	self.config = None # The leoConfig instance.
	self.count = 0 # General purpose debugging count.
	self.copies = 0 # Number of calls to position.copy
	self.debug = false # True: enable extra debugging tests (not used at present).
		# WARNING: this could greatly slow things down.
	self.disableSave = false
	self.globalWindows = []
	self.gui = None # The gui class.
	self.hasOpenWithMenu = false # true: open with plugin has been loaded.
	self.hookError = false # true: suppress further calls to hooks.
	self.hookFunction = None # Application wide hook function.
	self.idle_imported = false # true: we have done an import idle
	self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
	self.idleTimeHook = false # true: the global idleTimeHookHandler will reshedule itself.
	self.initing = true # true: we are initiing the app.
	self.killed = false # true: we are about to destroy the root window.
	self.leoID = None # The id part of gnx's.
	self.loadDir = None # The directory from which Leo was loaded.
	self.loadedPlugins = [] # List of loaded plugins that have signed on.
	self.log = None # The LeoFrame containing the present log.
	self.logIsLocked = false # true: no changes to log are allowed.
	self.logWaiting = [] # List of messages waiting to go to a log.
	self.menuWarningsGiven = false # true: supress warnings in menu code.
	self.nodeIndices = None # Singleton node indices instance.
	self.numberOfWindows = 0 # Number of opened windows.
	self.openWithFiles = [] # List of data used by Open With command.
	self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
	self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
	self.quitting = false # true if quitting.  Locks out some events.
	self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
	self.root = None # The hidden main window. Set later.
	self.searchDict = {} # For communication between find/change scripts.
	self.scriptDict = {} # For communication between Execute Script command and scripts.
	self.trace = false # true: enable debugging traces.
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.tkEncoding = "utf-8"
	self.unicodeErrorGiven = true # true: suppres unicode tracebacks.
	self.unitTestDict = {} # For communication between unit tests and code.
	self.use_gnx = true # true: generate gnx's instead of tnode indices.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.

	# Global panels.  Destroyed when Leo ends.
	self.findFrame = None
	self.pythonFrame = None
	
	<< Define global constants >>
	<< Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = true # true: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"csharp" : "// /* */",	# C#
	"css" : "/* */", # 4/1/04
	"cweb" : "@q@ @>", # Use the "cweb hack"
	"elisp" : ";",
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "<!-- -->",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rapidq" : "'", # fil 2004-march-11
	"rebol" : ";",  # jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c",
	"css" : "css", # 4/1/04
	"cweb" : "w",
	"elisp" : "el",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "tex", # 1/8/04
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl",
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rapidq" : "bas", # fil 2004-march-11
	"rebol" : "r",    # jason 2003-07-03
	"shell" : "sh",   # DS 4/1/04
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=true,unittest=false):
	
	"""Report any possible clone errors in the outline.
	
	Remove any unused tnodeLists."""
	
	c = self ; count = 1 ; errors = 0 ; full = true
	if full and not unittest:
		g.es("all tests enabled: this may take awhile",color="blue")

	try:
		p = c.rootPosition()
		<< assert equivalence of lastVisible methods >>
		for p in c.allNodes_iter():
			count += 1
			<< remove unused tnodeList >>
			if not unittest: # this would be very slow.
				if full: # For testing only.
					<< do full tests >>
			# assert false, "checkFailed" # check of checkFailed itself.
	except AssertionError,message:
		errors += 1
		<< give test failed message >>
	if not unittest:
		<< print summary message >>
	return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
	g.app.debug = true

	p1 = p.oldLastVisible()
	p2 = p.lastVisible()
	
	if p1 != p2:
		print "oldLastVisible",p1
		print "   lastVisible",p2
	
	assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
	assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
	
	g.app.debug = false
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v
# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
	s = "deleting tnodeList for " + repr(v)
	print s ; g.es(s,color="blue")
	delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if count % 100 == 0:
	g.es('.',newline=false)
if count % 2000 == 0:
	g.enl()

@others
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
	assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
	assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
	assert p == back.next(), "p==back.next"
		
if next:
	assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and chiild links
if p.hasParent():
	n = p.childIndex()
	assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
	
for child in p.children_iter():
	assert p == child.parent(), "p==child.parent"

if p.hasNext():
	assert p.next().parent() == p.parent(), "next.parent==parent"
	
if p.hasBack():
	assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and chiild links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
	t = p.parent().v.t
	for v in p.directParents():
		assert(v.t == t)
#@nonl
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
	parents = p.v.t.vnodeList
	for child in p.children_iter():
		vparents = child.directParents()
		assert(len(parents) == len(vparents))
		for parent in parents:
			assert(parent in vparents)
		for parent in vparents:
			assert(parent in parents)
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
	childv = p.firstChild().v
	assert(childv == p.v.t._firstChild)
	assert(id(childv) == id(p.v.t._firstChild))
	for v in p.v.t.vnodeList:
		assert(v.t._firstChild == childv)
		assert(id(v.t._firstChild) == id(childv))
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
	
for v in vnodeList:
	
	assert v.t == p.v.t, "v.t == p.v.t"

	if p.v.isCloned():
		assert v.isCloned(), "v.isCloned"
		assert len(vnodeList) > 1, "len(vnodeList) > 1"
	else:
		assert not v.isCloned(), "not v.isCloned"
		assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
	print
	g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
	print s ; g.es(s,color="red")
elif verbose:
	g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
if errors == 1:
	s = "test failed: %s %s" % (message,repr(p))
	print s
	g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@+node:ekr.20040313083810:commands stuff...
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20031218072017.1767:demote
def demote(self):

	c = self ; p = c.currentPosition()
	if not p or not p.hasNext(): return

	last = p.lastChild()
	# Make sure all the moves will be valid.
	for child in p.children_iter():
		if not c.checkMoveWithParentWithWarning(child,p,true):
			return
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		while p.hasNext(): # Do not use iterator here.
			child = p.next()
			child.moveToNthChildOf(p,p.numberOfChildren())
		p.expand()
		c.selectVnode(p)
		p.setAllAncestorAtFileNodesDirty()
		c.setChanged(true)
	c.endUpdate()
	c.undoer.setUndoParams("Demote",p,lastChild=last)
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineDown(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	# Set next to the node after which p will be moved.
	next = p.visNext()
	while next and p.isAncestorOf(next):
		next = next.visNext()
	if not next: return
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		<< Move v down >>
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1769:<< Move v down >>
# Remember both the before state and the after state for undo/redo
oldBack = p.back()
oldParent = p.parent()
oldN = p.childIndex()

if next.hasChildren() and next.isExpanded():
	# Attempt to move p to the first child of next.
	if c.checkMoveWithParentWithWarning(p,next,true):
		p.moveToNthChildOf(next,0)
		c.undoer.setUndoParams("Move Down",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
else:
	# Attempt to move p after next.
	if c.checkMoveWithParentWithWarning(p,next.parent(),true):
		p.moveAfter(next)
		c.undoer.setUndoParams("Move Down",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
#@nonl
#@-node:ekr.20031218072017.1769:<< Move v down >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft(self):
	
	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	
	if not p.hasParent(): return
	# Remember both the before state and the after state for undo/redo
	parent = p.parent()
	oldBack = p.back()
	oldParent = p.parent()
	oldN = p.childIndex()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		p.moveAfter(parent)
		c.undoer.setUndoParams("Move Left",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight(self):
	
	c = self ; p = c.currentPosition()
	if not p: return
	
	if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	
	if not p.hasBack: return
	back = p.back()
	if not c.checkMoveWithParentWithWarning(p,back,true): return

	# Remember both the before state and the after state for undo/redo
	oldBack = back
	oldParent = p.parent()
	oldN = p.childIndex()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		n = back.numberOfChildren()
		p.moveToNthChildOf(back,n)
		c.undoer.setUndoParams("Move Right",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp(self):

	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineUp(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	back = p.visBack()
	if not back: return
	back2 = back.visBack()
	# A weird special case: just select back2.
	if back2 and p.v in back2.v.t.vnodeList:
		# g.trace('-'*20,"no move, selecting visBack")
		c.selectVnode(back2)
		return
	c = self
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		<< Move v up >>
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1773:<< Move v up >>
# Remember both the before state and the after state for undo/redo
oldBack = p.back()
oldParent = p.parent()
oldN = p.childIndex()
if 0:
	g.trace("visBack",back)
	g.trace("visBack2",back2)
	g.trace("oldParent",oldParent)
	g.trace("back2.hasChildren",back2.hasChildren())
	g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
	# p will be the new root node
	p.moveToRoot(c.rootVnode())
	c.undoer.setUndoParams("Move Up",p,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
	if c.checkMoveWithParentWithWarning(p,back2,true):
		p.moveToNthChildOf(back2,0)
		c.undoer.setUndoParams("Move Up",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(p,back2.parent(),true):
	# Insert after back2.
	p.moveAfter(back2)
	c.undoer.setUndoParams("Move Up",p,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
#@nonl
#@-node:ekr.20031218072017.1773:<< Move v up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote(self):

	c = self ; p = c.currentPosition()
	if not p or not p.hasChildren(): return

	last = p.lastChild()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		after = p
		while p.hasChildren(): # Don't use an iterator.
			child = p.firstChild()
			child.moveAfter(after)
			after = child
		p.setAllAncestorAtFileNodesDirty()
		c.setChanged(true)
		c.selectVnode(p)
	c.endUpdate()
	c.undoer.setUndoParams("Promote",p,lastChild=last)
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1774:promote
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@-node:ekr.20040313083810:commands stuff...
#@+node:ekr.20040313083810.2:position stuff...
#@+node:ekr.20040310062332:p.Link/Unlink methods
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@nonl
#@+node:ekr.20040310062332.1:p.invalidOutline
def invalidOutline (self, message):
	
	p = self

	if p.hasParent():
		node = p.parent()
	else:
		node = p

	g.alert("invalid outline: %s\n%s" % (message,node))
#@nonl
#@-node:ekr.20040310062332.1:p.invalidOutline
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

	"""Link self after v."""
	
	p = self
	# g.trace(p,after)
	
	p.stack = after.stack[:] # 3/12/04
	p.v._parent = after.v._parent
	
	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
	
	p.v._back = after.v
	p.v._next = after.v._next
	
	after.v._next = p.v
	
	if p.v._next:
		p.v._next._back = p.v

	if 0:
		g.trace('-'*20,after)
		p.dump(label="p")
		after.dump(label="back")
		if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20040310062332.3:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

	"""Links self as the n'th child of vnode pv"""
	
	# g.trace(self,parent,n)
	p = self

	# Recreate the stack using the parent.
	p.stack = parent.stack[:] 
	if parent.isCloned():
		p.stack.append(parent.v)

	p.v._parent = parent.v

	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)

	if n == 0:
		child1 = parent.v.t._firstChild
		p.v._back = None
		p.v._next = child1
		if child1:
			child1._back = p.v
		parent.v.t._firstChild = p.v
	else:
		prev = parent.nthChild(n-1) # zero based
		assert(prev)
		p.v._back = prev.v
		p.v._next = prev.v._next
		prev.v._next = p.v
		if p.v._next:
			p.v._next._back = p.v
			
	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.3:p.linkAsNthChild
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link self as the root node."""
	
	# g.trace(self,oldRoot)

	p = self ; v = p.v
	if oldRoot: oldRootVnode = oldRoot.v
	else:       oldRootVnode = None
	
	p.stack = [] # Clear the stack.
	
	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRootVnode # Bug fix: 3/12/04
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot:
		oldRoot.v._back = v # Bug fix: 3/12/04

	p.c.setRootPosition(p)
	
	if 0:
		p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

	"""Unlinks a position p from the tree before moving or deleting.
	
	The p.v._fistChild link does NOT change."""

	p = self ; v = p.v ; parent = p.parent()
	
	# Note:  p.parent() is not necessarily the same as v._parent.
	
	if parent:
		assert(p.v and p.v._parent in p.v.directParents())
		assert(parent.v in p.v.directParents())

	# g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
	
	# Special case the root.
	if p == p.c.rootPosition():
		assert(p.v._next)
		p.c.setRootPosition(p.next())
	
	# Remove v from it's tnode's vnodeList.
	vnodeList = v.t.vnodeList
	if v in vnodeList:
		vnodeList.remove(v)
	assert(v not in vnodeList)
	
	# Reset the firstChild link in its direct father.
	if parent and parent.v.t._firstChild == v:
		parent.v.t._firstChild = v._next

	# Do _not_ delete the links in any child nodes.

	# Clear the links in other nodes.
	if v._back: v._back._next = v._next
	if v._next: v._next._back = v._back

	# Unlink _this_ node.
	v._parent = v._next = v._back = None

	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		if parent: parent.dump(label="parent")
#@-node:ekr.20040310062332.5:p.unlink
#@-node:ekr.20040310062332:p.Link/Unlink methods
#@+node:ekr.20040303175026:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

	"""Deletes position p from the outline.  May be undone.

	Returns newPosition."""

	p = self ; c = p.c

	assert(newPosition != p)
	p.setDirty() # Mark @file nodes dirty!
	p.unlink()
	p.deleteLinksInTree()
	c.selectVnode(newPosition)
	
	return newPosition

#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20040303175026.3:p.insertAfter
def insertAfter (self,t=None):

	"""Inserts a new vnode after self.
	
	Returns the newly created position."""
	
	p = self ; c = p.c
	p2 = self.copy()

	if not t:
		t = tnode(headString="NewHeadline")

	p2.v = vnode(c,t)
	p2.v.iconVal = 0
	p2.linkAfter(p)

	return p2
#@nonl
#@-node:ekr.20040303175026.3:p.insertAfter
#@+node:ekr.20040303175026.4:p.insertAsLastChild
def insertAsLastChild (self,t=None):

	"""Inserts a new vnode as the last child of self.
	
	Returns the newly created position."""
	
	p = self
	n = p.numberOfChildren()

	if not t:
		t = tnode(headString="NewHeadline")
	
	return p.insertAsNthChild(n,t)
#@nonl
#@-node:ekr.20040303175026.4:p.insertAsLastChild
#@+node:ekr.20040303175026.5:p.insertAsNthChild
def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of self.
	self must have at least n-1 children.
	
	Returns the newly created position."""
	
	p = self ; c = p.c
	p2 = self.copy()

	if not t:
		t = tnode(headString="NewHeadline")
	
	p2.v = vnode(c,t)
	p2.v.iconVal = 0
	p2.linkAsNthChild(p,n)

	return p2
#@nonl
#@-node:ekr.20040303175026.5:p.insertAsNthChild
#@+node:ekr.20040303175026.6:p.moveToRoot
def moveToRoot (self,oldRoot=None):

	"""Moves a position to the root position."""

	p = self # Do NOT copy the position!
	p.unlink()
	p.linkAsRoot(oldRoot)
	
	return p
#@nonl
#@-node:ekr.20040303175026.6:p.moveToRoot
#@+node:ekr.20040303175026.8:p.clone
def clone (self,back):
	
	"""Create a clone of back.
	
	Returns the newly created position."""
	
	p = self ; c = p.c

	p2 = back.copy()
	p2.v = vnode(c,back.v.t)
	p2.linkAfter(back)

	return p2
#@nonl
#@-node:ekr.20040303175026.8:p.clone
#@+node:ekr.20040303175026.9:p.copyTreeWithNewTnodes: used by unit tests TO DO
if 0: # Not yet.

	def copyTreeWithNewTnodes (self):
		
		"""Return a copy of self with all new tnodes"""
		
		c = self.c
		
		# Create the root node.
		old_v = self
		new_v = vnode(c,tnode())
		new_v.t.headString = old_v.t.headString
		new_v.t.bodyString = old_v.t.bodyString
		
		# Recursively create all descendents.
		old_child = old_v.firstChild() ; n = 0
		while old_child:
			new_child = old_child.copyTreeWithNewTnodes()
			new_child.linkAsNthChild (new_v, n)
			n += 1
			old_child = old_child.next()
			
		# Return the root of the new tree.
		return new_v
#@nonl
#@-node:ekr.20040303175026.9:p.copyTreeWithNewTnodes: used by unit tests TO DO
#@+node:ekr.20040303175026.10:p.moveAfter
def moveAfter (self,a):

	"""Move a position after position a."""
	
	p = self ; c = p.c # Do NOT copy the position!
	p.unlink()
	p.linkAfter(a)
	
	# Moving a node after another node can create a new root node.
	if not a.hasParent() and not a.hasBack():
		c.setRootPosition(a)

	return p
#@nonl
#@-node:ekr.20040303175026.10:p.moveAfter
#@+node:ekr.20040306060312:p.moveToLastChildOf
def moveToLastChildOf (self,parent):

	"""Move a position to the last child of parent."""

	p = self # Do NOT copy the position!

	p.unlink()
	n = p.numberOfChildren()
	p.linkAsNthChild(parent,n)

	# Moving a node can create a new root node.
	if not parent.hasParent() and not parent.hasBack():
		p.c.setRootPosition(parent)
		
	return p
#@-node:ekr.20040306060312:p.moveToLastChildOf
#@+node:ekr.20040303175026.11:p.moveToNthChildOf
def moveToNthChildOf (self,parent,n):

	"""Move a position to the nth child of parent."""

	p = self ; c = p.c # Do NOT copy the position!
	
	# g.trace(p,parent,n)

	p.unlink()
	p.linkAsNthChild(parent,n)
	
	# Moving a node can create a new root node.
	if not parent.hasParent() and not parent.hasBack():
		c.setRootPosition(parent)

	return p
#@-node:ekr.20040303175026.11:p.moveToNthChildOf
#@+node:ekr.20040303175026.12:p.sortChildren
def sortChildren (self):
	
	p = self

	# Create a list of (headline,position) tuples
	pairs = []
	for child in p.children_iter():
		pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

	# Sort the list on the headlines.
	pairs.sort()

	# Move the children.
	index = 0
	for headline,child in pairs:
		child.moveToNthChildOf(p,index)
		index += 1
#@nonl
#@-node:ekr.20040303175026.12:p.sortChildren
#@+node:ekr.20040303175026.13:p.validateOutlineWithParent
# This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
	
	p = self
	result = true # optimists get only unpleasant surprises.
	parent = p.getParent()
	childIndex = p.childIndex()
	
	# g.trace(p,parent,pv)
	<< validate parent ivar >>
	<< validate childIndex ivar >>
	<< validate x ivar >>

	# Recursively validate all the children.
	for child in p.children_iter():
		r = child.validateOutlineWithParent(p)
		if not r: result = false

	return result
#@nonl
#@+node:ekr.20040303175026.14:<< validate parent ivar >>
if parent != pv:
	p.invalidOutline( "Invalid parent link: " + repr(parent))
#@nonl
#@-node:ekr.20040303175026.14:<< validate parent ivar >>
#@+node:ekr.20040303175026.15:<< validate childIndex ivar >>
if pv:
	if childIndex < 0:
		p.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex >= pv.numberOfChildren():
		p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex < 0:
	p.invalidOutline ( "negative childIndex" + childIndex )
#@nonl
#@-node:ekr.20040303175026.15:<< validate childIndex ivar >>
#@+node:ekr.20040303175026.16:<< validate x ivar >>
if not p.v.t and pv:
	self.invalidOutline ( "Empty t" )
#@nonl
#@-node:ekr.20040303175026.16:<< validate x ivar >>
#@-node:ekr.20040303175026.13:p.validateOutlineWithParent
#@+node:ekr.20040303175026.18:p.invalidOutline
def invalidOutline (self, message):

	s = "invalid outline: " + message + "\n"
	parent = self.getParent()

	if parent:
		s += repr(parent)
	else:
		s += repr(self)

	g.alert(s)
#@nonl
#@-node:ekr.20040303175026.18:p.invalidOutline
#@-node:ekr.20040303175026:p.Moving, Inserting, Deleting, Cloning, Sorting (position)
#@+node:ekr.20040301205720:p.__str__ and p.__repr__
def __str__ (self):
	
	p = self
	
	if p.v:
		return "<pos %d lvl: %d [%d] %s>" % (id(p),p.level(),len(p.stack),p.v.headString())
	else:
		return "<pos %d        [%d] None>" % (id(p),len(p.stack))
		
__repr__ = __str__
#@nonl
#@-node:ekr.20040301205720:p.__str__ and p.__repr__
#@+node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@nonl
#@-node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
#@+node:ekr.20040227214711:p.level & simpleLevel
def simpleLevel(self):
	
	p = self ; level = 0
	for parent in p.parents_iter():
		level += 1
	return level

def level(self,verbose=false):
	
	# if g.app.debug: simpleLevel = self.simpleLevel()
	
	p = self ; level = 0
	if not p: return level
		
	# Avoid calling p.copy() or copying the stack.
	v = p.v ; n = len(p.stack)-1
	while 1:
		assert(p)
		v,n = p.vParentWithStack(v,p.stack,n)
		if v:
			level += 1
			if verbose: g.trace(level,"level,n: %2d" % (level,n))
		else:
			if verbose: g.trace(level,"level,n: %2d" % (level,n))
			# if g.app.debug: assert(level==simpleLevel)
			return level
#@nonl
#@-node:ekr.20040227214711:p.level & simpleLevel
#@+node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
def oldLastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	assert(p.isVisible())
	last = p.copy()
	while 1:
		if g.app.debug: g.trace(last)
		p.moveToVisNext()
		if not p: return last
		last = p.copy()
		
def lastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	# Move to the last top-level node.
	while p.hasNext():
		if g.app.debug: g.trace(p)
		p.moveToNext()
	assert(p.isVisible())
	# Move to the last visible child.
	while p.hasChildren() and p.isExpanded():
		if g.app.debug: g.trace(p)
		p.moveToLastChild()
	assert(p.isVisible())
	if g.app.debug: g.trace(p)
	return p
#@nonl
#@-node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
#@+node:ekr.20031218072017.928:p.moveToX
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
	after = p.copy().moveToNodeAfterTree()
#@nonl
#@+node:ekr.20031218072017.930:p.moveToBack
def moveToBack (self):
	
	"""Move self to its previous sibling."""
	
	p = self

	p.v = p.v and p.v._back
	
	return p
#@nonl
#@-node:ekr.20031218072017.930:p.moveToBack
#@+node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
def moveToFirstChild (self):

	"""Move a position to it's first child's position."""
	
	p = self

	if p:
		child = p.v.t._firstChild
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
		
	return p

#@-node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
def moveToLastChild (self):
	
	"""Move a position to it's last child's position."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			child = p.v.lastChild()
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@-node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
def moveToLastNode (self):
	
	"""Move a position to last node of its tree.
	
	N.B. Returns p if p has no children."""
	
	p = self
	
	# Huge improvement for 4.2.
	while p.hasChildren():
		p.moveToLastChild()

	return p
#@nonl
#@-node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
#@+node:ekr.20031218072017.934:p.moveToNext
def moveToNext (self):
	
	"""Move a position to its next sibling."""
	
	p = self
	
	p.v = p.v and p.v._next
	
	return p
#@nonl
#@-node:ekr.20031218072017.934:p.moveToNext
#@+node:ekr.20031218072017.935:p.moveToNodeAfterTree
def moveToNodeAfterTree (self):
	
	"""Move a position to the node after the position's tree."""
	
	p = self
	
	while p:
		if p.hasNext():
			p.moveToNext()
			break
		p.moveToParent()

	return p
#@-node:ekr.20031218072017.935:p.moveToNodeAfterTree
#@+node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
def moveToNthChild (self,n):
	
	p = self
	
	if p:
		child = p.v.nthChild(n) # Must call vnode method here!
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@nonl
#@-node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self
	
	# if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

	if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
		# g.trace("pop",p.v,p)
	else:
		p.v = None

	return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20031218072017.938:p.moveToThreadBack
def moveToThreadBack (self):
	
	"""Move a position to it's threadBack position."""

	p = self

	if p.hasBack():
		p.moveToBack()
		p.moveToLastNode()
	else:
		p.moveToParent()

	return p
#@nonl
#@-node:ekr.20031218072017.938:p.moveToThreadBack
#@+node:ekr.20031218072017.939:p.moveToThreadNext
def moveToThreadNext (self):
	
	"""Move a position to the next a position in threading order."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			p.moveToFirstChild()
		elif p.v._next:
			p.moveToNext()
		else:
			p.moveToParent()
			while p:
				if p.v._next:
					p.moveToNext()
					break #found
				p.moveToParent()
			# not found.
				
	return p
#@nonl
#@-node:ekr.20031218072017.939:p.moveToThreadNext
#@+node:ekr.20031218072017.940:p.moveToVisBack
def moveToVisBack (self):
	
	"""Move a position to the position of the previous visible node."""

	p = self
	
	if p:
		p.moveToThreadBack()
		while p and not p.isVisible():
			p.moveToThreadBack()

	assert(not p or p.isVisible())
	return p
#@nonl
#@-node:ekr.20031218072017.940:p.moveToVisBack
#@+node:ekr.20031218072017.941:p.moveToVisNext
def moveToVisNext (self):
	
	"""Move a position to the position of the next visible node."""

	p = self

	p.moveToThreadNext()
	while p and not p.isVisible():
		p.moveToThreadNext()
			
	return p
#@nonl
#@-node:ekr.20031218072017.941:p.moveToVisNext
#@-node:ekr.20031218072017.928:p.moveToX
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
	
	"""A utility that allows the computation of p.v without calling p.copy().
	
	v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

	Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

	if not v:
		return None,n
	elif v._parent and len(v._parent.t.vnodeList) == 1:
		return v._parent,n # don't change stack.
	elif stack and n >= 0:
		return self.stack[n],n-1 # simulate popping the stack.
	else:
		return None,n
#@nonl
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
	p = p.moveToParent()
	if p: list1.append(p.v)
# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
	list2.append(v)
	v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@-node:ekr.20040313083810.2:position stuff...
#@+node:ekr.20040313083810.1:tree stuff...
#@+node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

	"""Draw horizontal line from vertical line to icon"""
	
	if 1:
		self.lineyoffset = 0
	else:
		if hasattr(p.v.t,"unknownAttributes"):
			self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
		else:
			self.lineyoffset = 0
		
	self.canvas.create_line(x,y+7+self.lineyoffset,
		x+box_width,y+7+self.lineyoffset,
		tag="lines",fill="gray50") # stipple="gray25")

	if self.inVisibleArea(y):
		return self.force_draw_node(p,x,y)
	else:
		return self.line_height,0
#@nonl
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

	self.allocatedNodes += 1
	h,w = self.drawUserIcons(p,"beforeBox",x,y)
	xw = w # The extra indentation before the icon box.
	if p.hasChildren():
		self.drawBox(p,x+w,y)
	w += box_width # even if box isn't drawn.

	h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
	h = max(h,h2) ; w += w2 ; xw += w2

	h2,w2 = self.drawIcon(p,x+w,y)
	h = max(h,h2) ; w += w2

	h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
	h = max(h,h2) ; w += w2

	h2 = self.drawText(p,x+w,y)
	h = max(h,h2)
	w += self.widthInPixels(p.headString())

	h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
	h = max(h,h2)

	return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040318090335:force_draw_node (old)
def force_draw_nodeOLD(self,p,x,y):

	self.allocatedNodes += 1

	if p.hasChildren():
		self.drawBox(p,x,y)
	w = box_width # Even if the box isn't drawn.

	h2,w2 = self.drawIcon(p,x+w,y)
	w += w2

	h = self.drawText(p,x+w,y)
	
	return h,0
#@-node:ekr.20040318090335:force_draw_node (old)
#@-node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.4161:tree.expandAllAncestors
def expandAllAncestors (self,p):
	
	redraw_flag = false

	for p in p.parents_iter():
		if not p.isExpanded():
			p.expand()
			redraw_flag = true

	return redraw_flag

#@-node:ekr.20031218072017.4161:tree.expandAllAncestors
#@+node:ekr.20031218072017.4157:Selecting & editing (tree)
#@+node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

	p = self.c.currentPosition()
	self.setDisabledLabelState(p)

def undimEditLabel (self):

	p = self.c.currentPosition()
	self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
#@+node:ekr.20031218072017.4159:editLabel
def editLabel (self,p):
	
	"""Start editing p.edit_text."""
	
	# g.trace(p)

	if self.editPosition() and p != self.editPosition():
		self.endEditLabel()
		self.frame.revertHeadline = None
		
	self.setEditPosition(p)

	# Start editing
	if p and p.edit_text():
		self.setNormalLabelState(p)
		self.frame.revertHeadline = p.headString()
		self.setEditPosition(p)
#@nonl
#@-node:ekr.20031218072017.4159:editLabel
#@+node:ekr.20031218072017.4160:endEditLabel
def endEditLabel (self):
	
	"""End editing for self.editText."""

	c = self.c ; gui = g.app.gui
	
	p = self.editPosition()

	if p and p.edit_text():
		self.setUnselectedLabelState(p)
		self.setEditPosition(None)

		# force a redraw of joined and ancestor headlines.
		self.force_redraw() 

	gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02
#@nonl
#@-node:ekr.20031218072017.4160:endEditLabel
#@+node:ekr.20031218072017.4161:tree.expandAllAncestors
def expandAllAncestors (self,p):
	
	redraw_flag = false

	for p in p.parents_iter():
		if not p.isExpanded():
			p.expand()
			redraw_flag = true

	return redraw_flag

#@-node:ekr.20031218072017.4161:tree.expandAllAncestors
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@+node:ekr.20031218072017.4162:tree.set...LabelState
def setNormalLabelState (self,p): # selected, editing

	# g.trace(p)
	if p and p.edit_text():
		<< set editing headline colors >>
		p.edit_text().tag_remove("sel","1.0","end")
		p.edit_text().tag_add("sel","1.0","end")
		g.app.gui.set_focus(self.c,p.edit_text())

def setDisabledLabelState (self,p): # selected, disabled

	# g.trace(p,g.callerName(2),g.callerName(3))
	if p and p.edit_text():
		<< set selected, disabled headline colors >>

def setSelectedLabelState (self,p): # selected, not editing

	# g.trace(p)
	self.setDisabledLabelState(p)

def setUnselectedLabelState (self,p): # not selected.

	# g.trace(p)
	if p and p.edit_text():
		<< set unselected headline colors >>
#@+node:ekr.20031218072017.4163:<< set editing headline colors >>
config = g.app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	if selfg and selbg:
		p.edit_text().configure(
			selectforeground=selfg,selectbackground=selbg,
			state="normal",highlightthickness=1,fg=fg,bg=bg)
	else:
		p.edit_text().configure(
			state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4163:<< set editing headline colors >>
#@+node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
	fg,bg = "black","gray80"

try:
	p.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
#@+node:ekr.20031218072017.4165:<< set unselected headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	p.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4165:<< set unselected headline colors >>
#@-node:ekr.20031218072017.4162:tree.set...LabelState
#@-node:ekr.20031218072017.4157:Selecting & editing (tree)
#@+node:ekr.20031218072017.1018:tree.idle_scrollTo
def idle_scrollTo(self,p=None):

	"""Scrolls the canvas so that v is in view.
	
	This is done at idle time after a redraw so that treeBar.get() will return proper values."""

	c = self.c ; frame = c.frame
	if not p: p = self.c.currentPosition()
	if not p: p = self.c.rootPosition() # 4/8/04.
	try:
		last = p.lastVisible()
		nextToLast = last.visBack()
		h1 = self.yoffset(p)
		h2 = self.yoffset(last)
		<< compute approximate line height >>
		<< Compute the fractions to scroll down/up >>
		if frac <= lo:
			if self.prevMoveToFrac != frac:
				self.prevMoveToFrac = frac
				self.canvas.yview("moveto",frac)
		elif frac2 + (hi - lo) >= hi:
			if self.prevMoveToFrac != frac2:
				self.prevMoveToFrac = frac2
				self.canvas.yview("moveto",frac2)

		if self.allocateOnlyVisibleNodes:
			self.canvas.after_idle(self.idle_second_redraw)
			
		c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
		# print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
	except:
		g.es_exception()
#@nonl
#@+node:ekr.20040314092716:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
	lineHeight = h2 - self.yoffset(nextToLast)
else:
	lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040314092716:<< compute approximate line height >>
#@+node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
	frac = float(h1)/float(h2) # For scrolling down.
	frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
	frac2 = frac2 - (hi - lo)
else:
	frac = frac2 = 0.0 # probably any value would work here.
	
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20031218072017.1018:tree.idle_scrollTo
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@-node:ekr.20040313083810.1:tree stuff...
#@+node:ekr.20040313083810.3:vnode stuff
#@+node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
# These remain in 4.2: the file read logic calls these before creating positions.
#@nonl
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

	"""Inserts a new vnode after self"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAfter(self)

	return v
#@nonl
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAsNthChild(self,n)

	return v
#@nonl
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20031218072017.2355:v.linkAfter
def linkAfter (self,v):

	"""Link self after v."""
	
	self._parent = v._parent
	self._back = v
	self._next = v._next
	v._next = self
	if self._next:
		self._next._back = self
#@-node:ekr.20031218072017.2355:v.linkAfter
#@+node:ekr.20031218072017.3425:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

	"""Links self as the n'th child of vnode pv"""

	v = self
	# g.trace(v,pv,n)
	v._parent = pv
	if n == 0:
		v._back = None
		v._next = pv.t._firstChild
		if pv.t._firstChild:
			pv.t._firstChild._back = v
		pv.t._firstChild = v
	else:
		prev = pv.nthChild(n-1) # zero based
		assert(prev)
		v._back = prev
		v._next = prev._next
		prev._next = v
		if v._next:
			v._next._back = v
#@nonl
#@-node:ekr.20031218072017.3425:v.linkAsNthChild
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link a vnode as the root node and set the root _position_."""

	v = self ; c = v.c

	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRoot
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot: oldRoot._back = v

	newRoot = position(v,[])
	c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

	"""Moves the receiver to the root position"""

	v = self

	v.unlink()
	v.linkAsRoot(oldRoot)
	
	return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

	"""Unlinks a vnode from the tree."""

	v = self ; c = v.c

	# g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
	
	# Special case the root.
	if v == c.rootPosition().v: # 3/11/04
		assert(v._next)
		newRoot = position(v._next,[])
		c.setRootPosition(newRoot)

	# Clear the links in other nodes.
	if v._back:
		v._back._next = v._next
	if v._next:
		v._next._back = v._back

	if v._parent and v == v._parent.t._firstChild:
		v._parent.t._firstChild = v._next

	# Clear the links in this node.
	v._parent = v._next = v._back = None
	# v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
#@-node:ekr.20040313083810.3:vnode stuff
#@-node:ekr.20040312120107:(Fixed move/drawing/level bugs)
#@+node:ekr.20040314111426:(Fixed @+leo encoding bug)
#@+node:ekr.20040317084001:Notes
@nocolor

Pep 262 says: More precisely, the first or second line must match the regular expression

"coding[:=]\s*([\w-_.]+)"

Therefore, Leo must not use the ".' or '-' character to terminate the encoding field.

For compatibility with previous versions I shall do the following:

1.  Writing:  end the field with ",."

2.  Reading: scan until ',' or '.', whichever comes first.

- If ',' comes first, no problem.

- If '.' comes first, the specification must have been written by an old version of Leo.  In that case, Leo may as well stop there: older versions of Leo could not handle encodings containing '.' anyway.
#@nonl
#@-node:ekr.20040317084001:Notes
#@+node:ekr.20031218072017.2633:top_df.scanHeader
def scanHeader(self,file,fileName):
	
	"""Scan the @+leo sentinel.
	
	Sets self.encoding, and self.start/endSentinelComment.
	
	Returns (firstLines,new_df) where:
	firstLines contains all @first lines,
	new_df is true if we are reading a new-format derived file."""
	
	at = self
	new_df = false # Set default.
	firstLines = [] # The lines before @+leo.
	version_tag = "-ver="
	thin_tag = "-thin"
	tag = "@+leo" ; encoding_tag = "-encoding="
	valid = true
	<< skip any non @+leo lines >>
	<< make sure we have @+leo >>
	<< read optional version param >>
	<< read optional thin param >>
	<< read optional encoding param >>
	<< set the closing comment delim >>
	if not valid:
		at.error("Bad @+leo sentinel in " + fileName)
	# g.trace("start,end",at.startSentinelComment,at.endSentinelComment)
	return firstLines, new_df
#@nonl
#@+node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) > 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = at.readLine(file)
n = len(s)
valid = n > 0
# s contains the tag
i = j = g.skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
	i += 1
if j < i:
	at.startSentinelComment = s[j:i]
	# g.trace(at.startSentinelComment)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
#@+node:ekr.20031218072017.2635:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0:# 7/8/02: make leading whitespace significant.
	i = g.skip_ws(s,i)

if g.match(s,i,tag):
	i += len(tag)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2635:<< make sure we have @+leo >>
#@+node:ekr.20031218072017.2636:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
	# Skip to the next minus sign or end-of-line
	i += len(version_tag)
	j = i
	while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
		i += 1

	if j < i:
		pass # version = s[j:i]
	else:
		valid = false
#@-node:ekr.20031218072017.2636:<< read optional version param >>
#@+node:EKR.20040503105354:<< read optional thin param >>
if g.match(s,i,thin_tag):
	i += len(tag)
#@nonl
#@-node:EKR.20040503105354:<< read optional thin param >>
#@+node:ekr.20031218072017.2637:<< read optional encoding param >>
# Set the default encoding
at.encoding = g.app.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
	# Read optional encoding param, e.g., -encoding=utf-8,
	i += len(encoding_tag)
	# Skip to the next end of the field.
	j = s.find(",.",i)
	if j > -1:
		# The encoding field was written by 4.2 or after:
		encoding = s[i:j]
	else:
		# The encoding field was written before 4.2.
		j = s.find('.',i)
		if j > -1:
			encoding = s[i:j]
		else:
			encoding = None
	# g.trace("encoding:",encoding)
	if encoding:
		if g.isValidEncoding(encoding):
			at.encoding = encoding
		else:
			print "bad encoding in derived file:",encoding
			g.es("bad encoding in derived file:",encoding)
	else:
		valid = false
#@-node:ekr.20031218072017.2637:<< read optional encoding param >>
#@+node:ekr.20031218072017.2638:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
	i += 1
at.endSentinelComment = s[j:i]
#@nonl
#@-node:ekr.20031218072017.2638:<< set the closing comment delim >>
#@-node:ekr.20031218072017.2633:top_df.scanHeader
#@+node:ekr.20031218072017.2789:putOpenLeoSentinel 4.x
def putOpenLeoSentinel(self,s):
	
	"""Write @+leo sentinel."""

	at = self
	
	if not at.sentinels:
		return # Handle @nosentinelsfile.
		
	if at.thinFile:
		s = s + "-thin"

	encoding = at.encoding.lower()
	if encoding != "utf-8":
		# New in 4.2: encoding fields end in ",."
		s = s + "-encoding=%s,." % (encoding)
	
	at.putSentinel(s)
#@nonl
#@-node:ekr.20031218072017.2789:putOpenLeoSentinel 4.x
#@+node:ekr.20031218072017.2695:putOpenLeoSentinel 3.x
# This method is the same as putSentinel except we don't put an opening newline and leading whitespace.

def putOpenLeoSentinel(self,s):
	
	"""Put a +leo sentinel containing s."""
	
	if not self.sentinels:
		return # Handle @nosentinelsfile.

	self.os(self.startSentinelComment)
	self.os(s)
	encoding = self.encoding.lower()
	if encoding != "utf-8":
		self.os("-encoding=")
		self.os(encoding)
		# New in 4.2: encoding fields end in ",."
		# However, there is no point in changing things here.
		# We want to be as compatible as possible with the old versions of Leo.
		self.os(".")
	self.os(self.endSentinelComment)
	if self.suppress_newlines: # 9/27/02
		self.newline_pending = true # Schedule a newline.
	else:
		self.onl() # End of sentinel.
#@-node:ekr.20031218072017.2695:putOpenLeoSentinel 3.x
#@-node:ekr.20040314111426:(Fixed @+leo encoding bug)
#@+node:ekr.20040312092455.2:(Enable and test atFile read logic)
@

What I did:

- Enabled top_df.readAll
- Changed findChild to use p.v.t.vnodeList.
- Changed subtree_iter to c.allNodes_iter in putTnodes.
- Move tnodeList into tnodes. (Change made in getVnode).
#@nonl
#@+node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = false
at.inCode = true
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = false

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
	if hasattr(p.v.t,"tnodeList"):
		g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
	else:
		g.trace("no tnodeList",p.v)
		
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
#@+node:ekr.20040316075317:reading...
#@+node:ekr.20031218072017.2626: top_df.readAll
def readAll(self,root,partialFlag=false):
	
	"""Scan vnodes, looking for @file nodes to read."""

	at = self ; c = at.c
	c.endEditing() # Capture the current headline.
	anyRead = false
	at.initIvars()
	p = root.copy()
	if partialFlag: after = p.nodeAfterTree()
	else: after = c.nullPosition()
	while p and not p.equal(after): # Don't use iterator.
		if p.isAtIgnoreNode():
			p.moveToNodeAfterTree()
		elif p.isAtThinFileNode():
			anyRead = true
			at.read(p,thinFile=true)
			p.moveToNodeAfterTree()
		elif p.isAtFileNode() or p.isAtNorefFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				at.read(p)
			else:
				# if p is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = p.isOrphan()
				ok = at.read(p)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					p.setDirty()
					c.setChanged(true)
			p.moveToNodeAfterTree()
		else: p.moveToThreadNext()
	# Clear all orphan bits.
	for p in c.allNodes_iter():
		p.v.clearOrphan()
		
	if partialFlag and not anyRead:
		g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20031218072017.2626: top_df.readAll
#@+node:ekr.20031218072017.2007:findChild 4.x
def findChild (self,headline):
	
	"""Return the next tnode in at.root.t.tnodeList."""

	at = self ; v = at.root.v

	if not hasattr(v.t,"tnodeList"):
		at.readError("no tnodeList for " + repr(v))
		g.es("Write the @file node or use the Import Derived File command")
		g.trace("no tnodeList for ",v)
		return None
		
	if at.tnodeListIndex >= len(v.t.tnodeList):
		at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
		g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
		return None
		
	t = v.t.tnodeList[at.tnodeListIndex]
	assert(t)
	at.tnodeListIndex += 1

	# Get any vnode joined to t.
	try:
		v = t.vnodeList[0]
	except:
		at.readError("No vnodeList for tnode: %s" % repr(t))
		g.trace(at.tnodeListIndex)
		return None

	# Check the headline.
	if headline.strip() == v.headString().strip():
		t.setVisited() # Supress warning about unvisited node.
		return t
	else:
		at.readError(
			"Mismatched headline.\nExpecting: %s\ngot: %s" %
			(headline,v.headString()))
		g.trace("Mismatched headline",headline,v.headString())
		g.trace(at.tnodeListIndex,len(at.root.v.t.tnodeList))
		return None
#@nonl
#@-node:ekr.20031218072017.2007:findChild 4.x
#@+node:ekr.20031218072017.2008:getTnodeList (4.0,4.2)
def getTnodeList (self,s):

	"""Parse a list of tnode indices in string s."""
	
	# Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
	
	fc = self ; 

	indexList = s.split(',') # The list never ends in a comma.
	tnodeList = []
	for index in indexList:
		index = self.canonicalTnodeIndex(index)
		t = fc.tnodesDict.get(index)
		if not t:
			# Not an error: create a new tnode and put it in fc.tnodesDict.
			# g.trace("not allocated: %s" % index)
			t = self.newTnode(index)
		tnodeList.append(t)
		
	# if tnodeList: g.trace(len(tnodeList))
	return tnodeList
#@-node:ekr.20031218072017.2008:getTnodeList (4.0,4.2)
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

	c = self.c ; v = None
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
	# we have already matched <v.
	while 1:
		if self.matchTag("a=\""):
			<< Handle vnode attribute bits >>
		elif self.matchTag("t="):
			# New for 4.1.  Read either "Tnnn" or "gnx".
			tref = self.getDqString()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList="):
			s = self.getDqString()
			tnodeList = self.getTnodeList(s) # New for 4.0
		elif self.matchTag(">"):
			break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val
	# Headlines are optional.
	if self.matchTag("<vh>"):
		headline = self.getEscapedString() ; self.getTag("</vh>")
	
	# g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
	if skip:
		v = self.getExistingVnode(tref)
	else:
		v,skip = self.createVnode(parent,back,tref,headline,attrDict)
		if tnodeList:
			v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
			# g.trace("%4d" % len(tnodeList),v)

	<< Set the remembered status bits >>

	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("<v"):
		append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
		append2 = appendToTopStack and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip,
			appendToCurrentStack=append1,appendToTopStack=append2)
			
	<< Append to current or top stack >>

	# End this vnode.
	self.getTag("</v>")
	return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
	self.currentVnodeStack = [v]

if setTop:
	self.topVnodeStack = [v]
	
if setExpanded:
	v.initExpandedBit()
	
if setMarked:
	v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
	v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
	#g.trace("append current",v)
	self.currentVnodeStack.append(v)
	
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
	#g.trace("append top",v)
	self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@-node:ekr.20040316075317:reading...
#@+node:ekr.20040316075317.1:writing...
#@+node:ekr.20031218072017.1570:assignFileIndices & compactFileIndices
def assignFileIndices (self):
	
	"""Assign a file index to all tnodes"""
	
	c = self.c ; nodeIndices = g.app.nodeIndices

	nodeIndices.setTimestamp() # This call is fairly expensive.

	if g.app.use_gnx:
		<< assign missing gnx's, converting ints to gnx's >>
	else:
		<< reassign all tnode indices >>
		
	if 0: # debugging:
		for p in c.allNodes_iter():
			g.trace(p.v.t.fileIndex)

# Indices are now immutable, so there is no longer any difference between these two routines.
compactFileIndices = assignFileIndices
#@nonl
#@+node:ekr.20031218072017.1571:<< assign missing gnx's, converting ints to gnx's >>
# Always assign an (immutable) index, even if the tnode is empty.

for p in c.allNodes_iter():
	try: # Will fail for None or any pre 4.1 file index.
		id,time,n = p.v.t.fileIndex
	except TypeError:
		# Don't convert to string until the actual write.
		p.v.t.fileIndex = nodeIndices.getNewIndex()
#@nonl
#@-node:ekr.20031218072017.1571:<< assign missing gnx's, converting ints to gnx's >>
#@+node:ekr.20031218072017.1572:<< reassign all tnode indices >>
# Clear out all indices.
for p in c.allNodes_iter():
	p.v.t.fileIndex = None
	
# Recreate integer indices.
self.maxTnodeIndex = 0

for p in c.allNodes_iter():
	if p.v.t.fileIndex == None:
		self.maxTnodeIndex += 1
		p.v.t.fileIndex = self.maxTnodeIndex
#@nonl
#@-node:ekr.20031218072017.1572:<< reassign all tnode indices >>
#@-node:ekr.20031218072017.1570:assignFileIndices & compactFileIndices
#@+node:ekr.20031218072017.2114:new_df.write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false,scriptFile=None,thinFile=false):
	
	"""Write a 4.x derived file."""
	
	at = self ; c = at.c

	<< open the file; return on error >>
	try:
		self.writeOpenFile(root,nosentinels,scriptFile,thinFile)
		if scriptFile != None:
			at.root.v.t.tnodeList = []
		else:
			at.closeWriteFile()
			<< set dirty and orphan bits on error >>
	except:
		if scriptFile:
			g.es("exception preprocessing script",color="blue")
			g.es_exception(full=false)
			scriptFile.clear()
			at.root.v.t.tnodeList = []
		else:
			at.handleWriteException() # Sets dirty and orphan bits.
#@nonl
#@+node:ekr.20031218072017.2116:<< open the file; return on error >>
if scriptFile:
	at.targetFileName = "<script>"
elif nosentinels:
	at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
	at.targetFileName = root.atThinFileNodeName()
else:
	at.targetFileName = root.atFileNodeName()

if scriptFile:
	ok = true
	at.outputFileName = "<script>"
	at.outputFile = scriptFile
else:
	ok = at.openWriteFile(root)
	
if not ok:
	return
#@nonl
#@-node:ekr.20031218072017.2116:<< open the file; return on error >>
#@+node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
	root.setOrphan()
	root.setDirty() # Make _sure_ we try to rewrite this file.
	os.remove(at.outputFileName) # Delete the temp file.
	g.es("Not written: " + at.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
#@-node:ekr.20031218072017.2114:new_df.write
#@+node:ekr.20031218072017.2322:old_df.write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false,thinFile=false):
	
	if thinFile:
		self.error("@file-thin not supported before 4.2")
		return
	
	# Remove any old tnodeList.
	if hasattr(root.v.t,"tnodeList"):
		# g.trace("removing tnodeList for ",root)
		delattr(root.v.t,"tnodeList")

	c = self.c
	<< initialize >>
	try:
		<< open the file; return on error >>
		root.clearAllVisitedInTree() # 1/28/04: clear both vnode and tnode bits.
		<< write then entire @file tree >>
		self.closeWriteFile()
		if not nosentinels:
			self.warnAboutOrphandAndIgnoredNodes()
		<< finish writing >>
	except:
		self.handleWriteException()
#@+node:ekr.20031218072017.2323:<< initialize >>
self.sentinels = not nosentinels
self.raw = false

self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
c.endEditing() # Capture the current headline.
#@nonl
#@-node:ekr.20031218072017.2323:<< initialize >>
#@+node:ekr.20031218072017.2324:<< open the file; return on error >>
if nosentinels:
	self.targetFileName = root.atNoSentFileNodeName()
else:
	self.targetFileName = root.atFileNodeName()

ok = self.openWriteFile(root)
if not ok: return
#@nonl
#@-node:ekr.20031218072017.2324:<< open the file; return on error >>
#@+node:ekr.20031218072017.2325:<< write then entire @file tree >> (3.x)
next = root.nodeAfterTree()

<< put all @first lines in root >>
<< write the derived file >>
<< put all @last lines in root >>

root.setVisited()
#@nonl
#@+node:ekr.20031218072017.2326:<< put all @first lines in root >> (3.x)
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
	i += len(tag)
	i = g.skip_ws(s,i)
	j = i
	i = g.skip_to_end_of_line(s,i)
	# 21-SEP-2002 DTHEIN: write @first line, whether empty or not
	line = s[j:i]
	self.putBuffered(line) ; self.onl()
	i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20031218072017.2326:<< put all @first lines in root >> (3.x)
#@+node:ekr.20031218072017.2327:<< write the derived file>>
tag1 = "@+leo"

self.putOpenLeoSentinel(tag1)
self.putInitialComment()
self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)
self.putSentinel("@-leo")
#@nonl
#@-node:ekr.20031218072017.2327:<< write the derived file>>
#@+node:ekr.20031218072017.2328:<< put all @last lines in root >> (3.x)
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
	line = lines[j]
	if g.match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = g.skip_ws(line,i)
	self.putBuffered(line[i:]) ; self.onl()
#@nonl
#@-node:ekr.20031218072017.2328:<< put all @last lines in root >> (3.x)
#@-node:ekr.20031218072017.2325:<< write then entire @file tree >> (3.x)
#@+node:ekr.20031218072017.2330:<< finish writing >>
@ We set the orphan and dirty flags if there are problems writing the file to force write_Leo_file to write the tree to the .leo file.
@c

if self.errors > 0 or self.root.isOrphan():
	root.setOrphan()
	root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
	os.remove(self.outputFileName) # Delete the temp file.
	g.es("Not written: " + self.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	self.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20031218072017.2330:<< finish writing >>
#@-node:ekr.20031218072017.2322:old_df.write
#@+node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=false,inAtOthers=false):
	
	"""Write @+node sentinel for p."""
	
	at = self

	if not inAtAll and p.isAtFileNode() and p != at.root:
		at.writeError("@file not valid in: " + p.headString())
		return
		
	# g.trace(at.thinFile,p)
		
	s = at.nodeSentinelText(p)
	at.putSentinel("@+node:" + s)
	
	if not at.thinFile:
		# Append the n'th tnode to the root's tnode list.
		at.root.v.t.tnodeList.append(p.v.t)
#@nonl
#@-node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
#@+node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
def putTnodeList (self,v):
	
	"""Put the tnodeList attribute of a tnode."""
	
	# g.trace(v)
	
	# Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

	fc = self ; nodeIndices = g.app.nodeIndices
	tnodeList = v.t.tnodeList
	if tnodeList:
		# g.trace("%4d" % len(tnodeList),v)
		fc.put(" tnodeList=") ; fc.put_dquote()
		if g.app.use_gnx:
			for t in tnodeList:
				try: # Will fail for None or any pre 4.1 file index.
					id,time,n = t.fileIndex
				except:
					g.trace("assigning gnx for ",v,t)
					gnx = nodeIndices.getNewIndex()
					v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
			s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
		else:
			s = ','.join([str(t.fileIndex) for t in tnodeList])
		fc.put(s) ; fc.put_dquote()
#@nonl
#@-node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):
	
	"""Puts all tnodes as required for copy or save commands"""

	c = self.c

	self.put("<tnodes>") ; self.put_nl()
	<< write only those tnodes that were referenced >>
	self.put("</tnodes>") ; self.put_nl()
#@nonl
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
# Populate tnodes
tnodes = {}

if self.usingClipboard: # write the current tree.
	root = c.currentPosition()
else: # write everything
	root = c.rootPosition()

for p in c.allNodes_iter():
	index = p.v.t.fileIndex
	assert(index)
	tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
	# g.trace(index)
	t = tnodes.get(index)
	assert(t)
	# Write only those tnodes whose vnodes were written.
	if t.isWriteBit(): # 5/3/04
		self.putTnode(t)
#@nonl
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@-node:ekr.20040316075317.1:writing...
#@-node:ekr.20040312092455.2:(Enable and test atFile read logic)
#@-node:ekr.20040325203859.1:3/21
#@+node:ekr.20040325203859.2:3/22
#@+node:ekr.20040318112729:(trace p.copy)
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

	# These ivars are the global vars of this program.
	self.afterHandler = None
	self.batchMode = false # true: run in batch mode.
	self.commandName = None # The name of the command being executed.
	self.config = None # The leoConfig instance.
	self.count = 0 # General purpose debugging count.
	self.copies = 0 # Number of calls to position.copy
	self.debug = false # True: enable extra debugging tests (not used at present).
		# WARNING: this could greatly slow things down.
	self.disableSave = false
	self.globalWindows = []
	self.gui = None # The gui class.
	self.hasOpenWithMenu = false # true: open with plugin has been loaded.
	self.hookError = false # true: suppress further calls to hooks.
	self.hookFunction = None # Application wide hook function.
	self.idle_imported = false # true: we have done an import idle
	self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
	self.idleTimeHook = false # true: the global idleTimeHookHandler will reshedule itself.
	self.initing = true # true: we are initiing the app.
	self.killed = false # true: we are about to destroy the root window.
	self.leoID = None # The id part of gnx's.
	self.loadDir = None # The directory from which Leo was loaded.
	self.loadedPlugins = [] # List of loaded plugins that have signed on.
	self.log = None # The LeoFrame containing the present log.
	self.logIsLocked = false # true: no changes to log are allowed.
	self.logWaiting = [] # List of messages waiting to go to a log.
	self.menuWarningsGiven = false # true: supress warnings in menu code.
	self.nodeIndices = None # Singleton node indices instance.
	self.numberOfWindows = 0 # Number of opened windows.
	self.openWithFiles = [] # List of data used by Open With command.
	self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
	self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
	self.quitting = false # true if quitting.  Locks out some events.
	self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
	self.root = None # The hidden main window. Set later.
	self.searchDict = {} # For communication between find/change scripts.
	self.scriptDict = {} # For communication between Execute Script command and scripts.
	self.trace = false # true: enable debugging traces.
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.tkEncoding = "utf-8"
	self.unicodeErrorGiven = true # true: suppres unicode tracebacks.
	self.unitTestDict = {} # For communication between unit tests and code.
	self.use_gnx = true # true: generate gnx's instead of tnode indices.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.

	# Global panels.  Destroyed when Leo ends.
	self.findFrame = None
	self.pythonFrame = None
	
	<< Define global constants >>
	<< Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = true # true: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"csharp" : "// /* */",	# C#
	"css" : "/* */", # 4/1/04
	"cweb" : "@q@ @>", # Use the "cweb hack"
	"elisp" : ";",
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "<!-- -->",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rapidq" : "'", # fil 2004-march-11
	"rebol" : ";",  # jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c",
	"css" : "css", # 4/1/04
	"cweb" : "w",
	"elisp" : "el",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "tex", # 1/8/04
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl",
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rapidq" : "bas", # fil 2004-march-11
	"rebol" : "r",    # jason 2003-07-03
	"shell" : "sh",   # DS 4/1/04
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
	
	""""Return an independent copy of a position."""
	
	g.app.copies += 1

	return position(self.v,self.stack)
#@nonl
#@-node:ekr.20040117171654:p.copy
#@-node:ekr.20040318112729:(trace p.copy)
#@+node:ekr.20040318112908:(Properly mark @file nodes dirty)
# This is hard to do directly.
# A trick: let the drawing code do it?  That seems too clever.
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

	p = self
	p.v.clearDirty()
#@nonl
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040303163717:p.isDirty
def isDirty (self):
	
	p = self
	return p.v and p.v.isDirty()
#@nonl
#@-node:ekr.20040303163717:p.isDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
	
	p = self
	
	# Start with all nodes in the vnodeList.
	nodes = []
	newNodes = p.v.t.vnodeList[:]

	# Add nodes until no more are added.
	while newNodes:
		# g.trace(len(newNodes))
		addedNodes = []
		nodes.extend(newNodes)
		for v in newNodes:
			for v2 in v.t.vnodeList:
				if v2 not in nodes and v2 not in addedNodes:
					addedNodes.append(v2)
				for v3 in v2.directParents(): # 3/23/04
					if v3 not in nodes and v3 not in addedNodes:
						addedNodes.append(v3)
		newNodes = addedNodes[:]

	# g.trace(nodes)
	return nodes
#@nonl
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self):

	p = self ; c = p.c
	changed = false
	
	# Calculate all nodes that are joined to v or parents of such nodes.
	nodes = p.findAllPotentiallyDirtyNodes()
	
	c.beginUpdate()
	if 1: # update...
		for v in nodes:
			# g.trace(v.isAnyAtFileNode(),v.t.isDirty(),v)
			if not v.t.isDirty() and v.isAnyAtFileNode():
				changed = true
				v.t.setDirty() # Do not call v.setDirty here!
	c.endUpdate(changed)
	return changed
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
# Ensures that all ancestor @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self):

	p = self ; c = p.c

	c.beginUpdate()
	if 1: # update...
		changed = false
		if not p.v.t.isDirty():
			p.v.t.setDirty()
			changed = true
		# This must be called even if p.v is already dirty.
		if p.setAllAncestorAtFileNodesDirty():
			changed = true
	c.endUpdate(changed)

	return changed
#@nonl
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
# These remain in 4.2: the file read logic calls these before creating positions.
#@nonl
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

	"""Inserts a new vnode after self"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAfter(self)

	return v
#@nonl
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAsNthChild(self,n)

	return v
#@nonl
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20031218072017.2355:v.linkAfter
def linkAfter (self,v):

	"""Link self after v."""
	
	self._parent = v._parent
	self._back = v
	self._next = v._next
	v._next = self
	if self._next:
		self._next._back = self
#@-node:ekr.20031218072017.2355:v.linkAfter
#@+node:ekr.20031218072017.3425:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

	"""Links self as the n'th child of vnode pv"""

	v = self
	# g.trace(v,pv,n)
	v._parent = pv
	if n == 0:
		v._back = None
		v._next = pv.t._firstChild
		if pv.t._firstChild:
			pv.t._firstChild._back = v
		pv.t._firstChild = v
	else:
		prev = pv.nthChild(n-1) # zero based
		assert(prev)
		v._back = prev
		v._next = prev._next
		prev._next = v
		if v._next:
			v._next._back = v
#@nonl
#@-node:ekr.20031218072017.3425:v.linkAsNthChild
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link a vnode as the root node and set the root _position_."""

	v = self ; c = v.c

	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRoot
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot: oldRoot._back = v

	newRoot = position(v,[])
	c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

	"""Moves the receiver to the root position"""

	v = self

	v.unlink()
	v.linkAsRoot(oldRoot)
	
	return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

	"""Unlinks a vnode from the tree."""

	v = self ; c = v.c

	# g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
	
	# Special case the root.
	if v == c.rootPosition().v: # 3/11/04
		assert(v._next)
		newRoot = position(v._next,[])
		c.setRootPosition(newRoot)

	# Clear the links in other nodes.
	if v._back:
		v._back._next = v._next
	if v._next:
		v._next._back = v._back

	if v._parent and v == v._parent.t._firstChild:
		v._parent.t._firstChild = v._next

	# Clear the links in this node.
	v._parent = v._next = v._back = None
	# v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
#@+node:ekr.20031218072017.1860:createVnode (changed for 4.2)
def createVnode (self,parent,back,tref,headline,attrDict):
	
	# g.trace(parent,headline)
	v = None ; c = self.c
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		tref = self.canonicalTnodeIndex(tref)
		t = self.tnodesDict.get(tref)
		if not t: t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c,t)
		v.moveToRoot()

	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v) # New in 4.2.

	skip = len(v.t.vnodeList) > 1

	v.initHeadString(headline,encoding=self.leo_file_encoding)
	<< handle unknown vnode attributes >>
	return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
	v.unknownAttributes = attrDict

	if 0: # For debugging.
		s = "unknown attributes for " + v.headString()
		print s ; g.es(s,color="blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode (changed for 4.2)
#@+node:ekr.20040305162628.1:p.Iterators
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:ekr.20040305171133:allNodes_iter
class allNodes_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def allNodes_iter (self,copy=false):
	
	return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305171133.1:__init__ & __iter__
def __init__(self,p,copy):

	self.first = p.c.rootPosition().copy()
	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305171133.1:__init__ & __iter__
#@+node:ekr.20040305171133.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:allNodes_iter
#@+node:ekr.20040305173559:subtree_iter
class subtree_iter_class:

	"""Returns a list of positions in a subtree, possibly including the root of the subtree."""

	@others

def subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=false)
	
def self_and_subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
	
	if includeSelf:
		self.first = p.copy()
		self.after = p.nodeAfterTree()
	elif p.hasChildren():
		self.first = p.copy().moveToFirstChild() 
		self.after = p.nodeAfterTree()
	else:
		self.first = None
		self.after = None

	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p and self.p != self.after:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:subtree_iter
#@+node:ekr.20040305172211.1:children_iter
class children_iter_class:

	"""Returns a list of children of a position."""

	@others

def children_iter (self,copy=false):
	
	return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

	if p.hasChildren():
		self.first = p.copy().moveToFirstChild()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:children_iter
#@+node:ekr.20040305172855:parents_iter
class parents_iter_class:

	"""Returns a list of positions of a position."""

	@others

def parents_iter (self,copy=false):
	
	p = self

	return self.parents_iter_class(self,copy,includeSelf=false)
	
def self_and_parents_iter(self,copy=false):
	
	return self.parents_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

	if includeSelf:
		self.first = p.copy()
	elif p.hasParent():
		self.first = p.copy().moveToParent()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):

	return self
#@nonl
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToParent()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:parents_iter
#@+node:ekr.20040305173343:siblings_iter
class siblings_iter_class:

	"""Returns a list of siblings of a position."""

	@others

def siblings_iter (self,copy=false,following=false):
	
	return self.siblings_iter_class(self,copy,following)
	
self_and_siblings_iter = siblings_iter
	
def following_siblings_iter (self,copy=false):
	
	return self.siblings_iter_class(self,copy,following=true)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
	
	# We always include p, even if following is true.
	
	if following:
		self.first = p.copy()
	else:
		p = p.copy()
		while p.hasBack():
			p.moveToBack()
		self.first = p

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@-node:ekr.20040318112908:(Properly mark @file nodes dirty)
#@+node:ekr.20040318092028:(Big performance bug in selecting/redraw/expand/contract)
@

At first, disabling the call to recolor_now in select speeded things up.  Now it doesn't (!!).

- Should there be a call to p.copy() in drawTree?

- Doing p = p.copy() in the coloring routines _seemed_ to solve this (for a while only!).
	I'm still not sure if this is needed...
#@nonl
#@+node:ekr.20040318100124:Coloringing...
#@+node:ekr.20031218072017.3677:Coloring
# It's weird to have the tree class be responsible for coloring the body pane!

def getColorizer(self):
	
	return self.colorizer

def recolor_now(self,p,incremental=false):

	self.colorizer.colorize(p.copy(),incremental)

def recolor_range(self,p,leading,trailing):
	
	self.colorizer.recolor_range(p.copy(),leading,trailing)

def recolor(self,p,incremental=false):
	
	if 0: # Do immediately
		self.colorizer.colorize(p.copy(),incremental)
	else: # Do at idle time
		self.colorizer.schedule(p.copy(),incremental)
	
def updateSyntaxColorer(self,p):
	
	return self.colorizer.updateSyntaxColorer(p.copy())
#@nonl
#@-node:ekr.20031218072017.3677:Coloring
#@+node:ekr.20031218072017.2801:colorize & recolor_range
# The main colorizer entry point.

def colorize(self,p,incremental=false):

	if self.enabled:
		# g.trace("incremental",incremental)
		self.incremental=incremental
		self.updateSyntaxColorer(p)
		return self.colorizeAnyLanguage(p)
	else:
		return "ok" # For unit testing.
		
# Called from incremental undo code.
# Colorizes the lines between the leading and trailing lines.
		
def recolor_range(self,p,leading,trailing):
	
	if self.enabled:
		# g.trace("leading,trailing",leading,trailing)
		self.incremental=true
		self.updateSyntaxColorer(p)
		return self.colorizeAnyLanguage(p,leading=leading,trailing=trailing)
	else:
		return "ok" # For unit testing.
#@nonl
#@-node:ekr.20031218072017.2801:colorize & recolor_range
#@+node:ekr.20031218072017.2805:useSyntaxColoring
def useSyntaxColoring (self,p):
	
	"""Return true unless p is unambiguously under the control of @nocolor."""
	
	p = p.copy() ; first = p.copy()
	val = true
	for p in p.self_and_parents_iter():
		# g.trace(p)
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		no_color = dict.has_key("nocolor")
		color = dict.has_key("color")
		# A color anywhere in the target enables coloring.
		if color and p == first:
			val = true ; break
		# Otherwise, the @nocolor specification must be unambiguous.
		elif no_color and not color:
			val = false ; break
		elif color and not no_color:
			val = true ; break

	return val
#@-node:ekr.20031218072017.2805:useSyntaxColoring
#@+node:ekr.20031218072017.2804:updateSyntaxColorer
# self.flag is true unless an unambiguous @nocolor is seen.

def updateSyntaxColorer (self,p):

	p = p.copy()
	self.flag = self.useSyntaxColoring(p)
	self.scanColorDirectives(p)
#@-node:ekr.20031218072017.2804:updateSyntaxColorer
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
	
	"""Scan position p and p's ancestors looking for @color and @nocolor directives,
	setting corresponding colorizer ivars.
	"""

	p = p.copy() ; c = self.c
	if c == None: return # self.c may be None for testing.

	language = c.target_language
	self.language = language # 2/2/03
	self.comment_string = None
	self.rootMode = None # None, "code" or "doc"
	
	for p in p.self_and_parents_iter():
		# g.trace(p)
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< Test for @comment or @language >>
		<< Test for @root, @root-doc or @root-code >>

	return self.language # For use by external routines.
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if dict.has_key("comment"):
	k = dict["comment"]
	self.comment_string = s[k:]

if dict.has_key("language"):
	i = dict["language"]
	language,junk,junk,junk = g.set_language(s,i)
	self.language = language # 2/2/03

if dict.has_key("comment") or dict.has_key("language"):
	break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if dict.has_key("root") and not self.rootMode:

	k = dict["root"]
	if g.match_word(s,k,"@root-code"):
		self.rootMode = "code"
	elif g.match_word(s,k,"@root-doc"):
		self.rootMode = "doc"
	else:
		doc = g.app.config.at_root_bodies_start_in_doc_mode
		self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@-node:ekr.20040318100124:Coloringing...
#@+node:ekr.20040318100124.1:Tree select/bindings...
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@+node:ekr.20031218072017.4142:tree.deleteBindings
def deleteBindings (self):
	
	"""Delete all tree bindings and all references to tree widgets."""
	
	# g.trace(len(self.tagBindings),len(self.bindings))

	count = 0
	# Unbind all the tag bindings.
	if 0:  # testing.
		self.tagBindings = []
		self.bindings = []
	else:
		for id,id2,binding in self.tagBindings:
			self.canvas.tag_unbind(id,binding,id2)
			count += 1
		self.tagBindings = []
		# Unbind all the text bindings.
		for t,id,binding in self.bindings:
			t.unbind(binding,id)
			count += 1
		self.bindings = []

		# g.trace("bindings freed:",count)
#@nonl
#@-node:ekr.20031218072017.4142:tree.deleteBindings
#@+node:ekr.20031218072017.4143:tree.deleteWidgets
# canvas.delete("all") does _not_ delete the Tkinter objects associated with those objects!

def deleteWidgets (self):
	
	"""Delete all widgets in the canvas"""
	
	# g.trace(len(self.widgets))
	
	self.icon_id_dict = {} # Delete all references to icons.
	self.edit_text_dict = {} # Delete all references to Tk.Edit widgets.
		
	# Fixes a _huge_ memory leak.
	for w in self.widgets:
		w.destroy() 

	self.widgets = []
	
	# g.trace("done")
#@nonl
#@-node:ekr.20031218072017.4143:tree.deleteWidgets
#@-node:ekr.20040318100124.1:Tree select/bindings...
#@+node:ekr.20040318100124.2:Expand/contract...
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20031218072017.1958:OnBoxClick
# Called when the box is clicked.

def OnBoxClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("boxclick1",c=c,p=p,event=event):
			c.frame.tree.OnBoxClick(p)
		g.doHook("boxclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("boxclick")
#@nonl
#@-node:ekr.20031218072017.1958:OnBoxClick
#@+node:ekr.20031218072017.2339:OnBoxClick
# Called on click in box and double-click in headline.

def OnBoxClick (self,p):
	
	# g.trace(p)

	# Note: "boxclick" hooks handled by vnode callback routine.
	c = self.c ; gui = g.app.gui

	if p.isExpanded(): p.contract()
	else:              p.expand()

	self.active = true
	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	gui.set_focus(c,c.frame.bodyCtrl) # 7/12/03
	self.redraw()
#@nonl
#@-node:ekr.20031218072017.2339:OnBoxClick
#@+node:ekr.20031218072017.3395:contract & expand & initExpandedBit
def contract(self):

	self.statusBits &= ~ self.expandedBit

def expand(self):

	self.statusBits |= self.expandedBit

def initExpandedBit (self):

	self.statusBits |= self.expandedBit
#@nonl
#@-node:ekr.20031218072017.3395:contract & expand & initExpandedBit
#@+node:ekr.20031218072017.4161:tree.expandAllAncestors
def expandAllAncestors (self,p):
	
	redraw_flag = false

	for p in p.parents_iter():
		if not p.isExpanded():
			p.expand()
			redraw_flag = true

	return redraw_flag

#@-node:ekr.20031218072017.4161:tree.expandAllAncestors
#@-node:ekr.20040318100124.2:Expand/contract...
#@-node:ekr.20040318092028:(Big performance bug in selecting/redraw/expand/contract)
#@+node:ekr.20040318161816:(Moving,expanding,contracting nodes can create HUGE numbers of positions)
@

- Moving a node up creates _way_ too many postions!
#@nonl
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp(self):

	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineUp(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	back = p.visBack()
	if not back: return
	back2 = back.visBack()
	# A weird special case: just select back2.
	if back2 and p.v in back2.v.t.vnodeList:
		# g.trace('-'*20,"no move, selecting visBack")
		c.selectVnode(back2)
		return
	c = self
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		<< Move v up >>
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1773:<< Move v up >>
# Remember both the before state and the after state for undo/redo
oldBack = p.back()
oldParent = p.parent()
oldN = p.childIndex()
if 0:
	g.trace("visBack",back)
	g.trace("visBack2",back2)
	g.trace("oldParent",oldParent)
	g.trace("back2.hasChildren",back2.hasChildren())
	g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
	# p will be the new root node
	p.moveToRoot(c.rootVnode())
	c.undoer.setUndoParams("Move Up",p,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif back2.hasChildren() and back2.isExpanded():
	if c.checkMoveWithParentWithWarning(p,back2,true):
		p.moveToNthChildOf(back2,0)
		c.undoer.setUndoParams("Move Up",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
elif c.checkMoveWithParentWithWarning(p,back2.parent(),true):
	# Insert after back2.
	p.moveAfter(back2)
	c.undoer.setUndoParams("Move Up",p,
		oldBack=oldBack,oldParent=oldParent,oldN=oldN)
#@nonl
#@-node:ekr.20031218072017.1773:<< Move v up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
	
	"""Return false if root or any of root's descedents is a clone of
	parent or any of parents ancestors."""

	message = "Illegal move or drag: no clone may contain a clone of itself"

	# g.trace("root",root,"parent",parent)
	clonedTnodes = {}
	for ancestor in parent.self_and_parents_iter():
		if ancestor.isCloned():
			t = ancestor.v.t
			clonedTnodes[t] = t

	if not clonedTnodes:
		return true

	for p in root.self_and_subtree_iter():
		if p.isCloned() and clonedTnodes.get(p.v.t):
			if warningFlag:
				g.alert(message)
			return false
	return true
#@nonl
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self):

	p = self ; c = p.c
	changed = false
	
	# Calculate all nodes that are joined to v or parents of such nodes.
	nodes = p.findAllPotentiallyDirtyNodes()
	
	c.beginUpdate()
	if 1: # update...
		for v in nodes:
			# g.trace(v.isAnyAtFileNode(),v.t.isDirty(),v)
			if not v.t.isDirty() and v.isAnyAtFileNode():
				changed = true
				v.t.setDirty() # Do not call v.setDirty here!
	c.endUpdate(changed)
	return changed
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@-node:ekr.20040318161816:(Moving,expanding,contracting nodes can create HUGE numbers of positions)
#@+node:ekr.20040318164450:(Saving a .leo file created too many positions)
@ The fix was to optimize the iterators so they create no copies if they would return an empty sequence.

There were also several bugs in the iterators that caused to many nodes to be examined.
#@nonl
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
	
	"""Return false if root or any of root's descedents is a clone of
	parent or any of parents ancestors."""

	message = "Illegal move or drag: no clone may contain a clone of itself"

	# g.trace("root",root,"parent",parent)
	clonedTnodes = {}
	for ancestor in parent.self_and_parents_iter():
		if ancestor.isCloned():
			t = ancestor.v.t
			clonedTnodes[t] = t

	if not clonedTnodes:
		return true

	for p in root.self_and_subtree_iter():
		if p.isCloned() and clonedTnodes.get(p.v.t):
			if warningFlag:
				g.alert(message)
			return false
	return true
#@nonl
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

	# These ivars are the global vars of this program.
	self.afterHandler = None
	self.batchMode = false # true: run in batch mode.
	self.commandName = None # The name of the command being executed.
	self.config = None # The leoConfig instance.
	self.count = 0 # General purpose debugging count.
	self.copies = 0 # Number of calls to position.copy
	self.debug = false # True: enable extra debugging tests (not used at present).
		# WARNING: this could greatly slow things down.
	self.disableSave = false
	self.globalWindows = []
	self.gui = None # The gui class.
	self.hasOpenWithMenu = false # true: open with plugin has been loaded.
	self.hookError = false # true: suppress further calls to hooks.
	self.hookFunction = None # Application wide hook function.
	self.idle_imported = false # true: we have done an import idle
	self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
	self.idleTimeHook = false # true: the global idleTimeHookHandler will reshedule itself.
	self.initing = true # true: we are initiing the app.
	self.killed = false # true: we are about to destroy the root window.
	self.leoID = None # The id part of gnx's.
	self.loadDir = None # The directory from which Leo was loaded.
	self.loadedPlugins = [] # List of loaded plugins that have signed on.
	self.log = None # The LeoFrame containing the present log.
	self.logIsLocked = false # true: no changes to log are allowed.
	self.logWaiting = [] # List of messages waiting to go to a log.
	self.menuWarningsGiven = false # true: supress warnings in menu code.
	self.nodeIndices = None # Singleton node indices instance.
	self.numberOfWindows = 0 # Number of opened windows.
	self.openWithFiles = [] # List of data used by Open With command.
	self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
	self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
	self.quitting = false # true if quitting.  Locks out some events.
	self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
	self.root = None # The hidden main window. Set later.
	self.searchDict = {} # For communication between find/change scripts.
	self.scriptDict = {} # For communication between Execute Script command and scripts.
	self.trace = false # true: enable debugging traces.
	self.trace_list = [] # "Sherlock" argument list for tracing().
	self.tkEncoding = "utf-8"
	self.unicodeErrorGiven = true # true: suppres unicode tracebacks.
	self.unitTestDict = {} # For communication between unit tests and code.
	self.use_gnx = true # true: generate gnx's instead of tnode indices.
	self.windowList = [] # Global list of all frames.  Does not include hidden root window.

	# Global panels.  Destroyed when Leo ends.
	self.findFrame = None
	self.pythonFrame = None
	
	<< Define global constants >>
	<< Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = true # true: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"csharp" : "// /* */",	# C#
	"css" : "/* */", # 4/1/04
	"cweb" : "@q@ @>", # Use the "cweb hack"
	"elisp" : ";",
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "<!-- -->",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rapidq" : "'", # fil 2004-march-11
	"rebol" : ";",  # jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c",
	"css" : "css", # 4/1/04
	"cweb" : "w",
	"elisp" : "el",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "tex", # 1/8/04
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl",
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rapidq" : "bas", # fil 2004-march-11
	"rebol" : "r",    # jason 2003-07-03
	"shell" : "sh",   # DS 4/1/04
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@+node:ekr.20040305162628.1:p.Iterators
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:ekr.20040305171133:allNodes_iter
class allNodes_iter_class:

	"""Returns a list of positions in the entire outline."""

	@others

def allNodes_iter (self,copy=false):
	
	return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305171133.1:__init__ & __iter__
def __init__(self,p,copy):

	self.first = p.c.rootPosition().copy()
	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305171133.1:__init__ & __iter__
#@+node:ekr.20040305171133.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:allNodes_iter
#@+node:ekr.20040305173559:subtree_iter
class subtree_iter_class:

	"""Returns a list of positions in a subtree, possibly including the root of the subtree."""

	@others

def subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=false)
	
def self_and_subtree_iter (self,copy=false):
	
	return self.subtree_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
	
	if includeSelf:
		self.first = p.copy()
		self.after = p.nodeAfterTree()
	elif p.hasChildren():
		self.first = p.copy().moveToFirstChild() 
		self.after = p.nodeAfterTree()
	else:
		self.first = None
		self.after = None

	self.p = None
	self.copy = copy
	
def __iter__(self):

	return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToThreadNext()

	if self.p and self.p != self.after:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:subtree_iter
#@+node:ekr.20040305172211.1:children_iter
class children_iter_class:

	"""Returns a list of children of a position."""

	@others

def children_iter (self,copy=false):
	
	return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

	if p.hasChildren():
		self.first = p.copy().moveToFirstChild()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:children_iter
#@+node:ekr.20040305172855:parents_iter
class parents_iter_class:

	"""Returns a list of positions of a position."""

	@others

def parents_iter (self,copy=false):
	
	p = self

	return self.parents_iter_class(self,copy,includeSelf=false)
	
def self_and_parents_iter(self,copy=false):
	
	return self.parents_iter_class(self,copy,includeSelf=true)
#@nonl
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

	if includeSelf:
		self.first = p.copy()
	elif p.hasParent():
		self.first = p.copy().moveToParent()
	else:
		self.first = None

	self.p = None
	self.copy = copy

def __iter__(self):

	return self
#@nonl
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToParent()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else:
		raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:parents_iter
#@+node:ekr.20040305173343:siblings_iter
class siblings_iter_class:

	"""Returns a list of siblings of a position."""

	@others

def siblings_iter (self,copy=false,following=false):
	
	return self.siblings_iter_class(self,copy,following)
	
self_and_siblings_iter = siblings_iter
	
def following_siblings_iter (self,copy=false):
	
	return self.siblings_iter_class(self,copy,following=true)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
	
	# We always include p, even if following is true.
	
	if following:
		self.first = p.copy()
	else:
		p = p.copy()
		while p.hasBack():
			p.moveToBack()
		self.first = p

	self.p = None
	self.copy = copy

def __iter__(self):
	
	return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
	
	if self.first:
		self.p = self.first
		self.first = None

	elif self.p:
		self.p.moveToNext()

	if self.p:
		if self.copy: return self.p.copy()
		else:         return self.p
	else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20031218072017.928:p.moveToX
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
	after = p.copy().moveToNodeAfterTree()
#@nonl
#@+node:ekr.20031218072017.930:p.moveToBack
def moveToBack (self):
	
	"""Move self to its previous sibling."""
	
	p = self

	p.v = p.v and p.v._back
	
	return p
#@nonl
#@-node:ekr.20031218072017.930:p.moveToBack
#@+node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
def moveToFirstChild (self):

	"""Move a position to it's first child's position."""
	
	p = self

	if p:
		child = p.v.t._firstChild
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
		
	return p

#@-node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
def moveToLastChild (self):
	
	"""Move a position to it's last child's position."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			child = p.v.lastChild()
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@-node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
def moveToLastNode (self):
	
	"""Move a position to last node of its tree.
	
	N.B. Returns p if p has no children."""
	
	p = self
	
	# Huge improvement for 4.2.
	while p.hasChildren():
		p.moveToLastChild()

	return p
#@nonl
#@-node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
#@+node:ekr.20031218072017.934:p.moveToNext
def moveToNext (self):
	
	"""Move a position to its next sibling."""
	
	p = self
	
	p.v = p.v and p.v._next
	
	return p
#@nonl
#@-node:ekr.20031218072017.934:p.moveToNext
#@+node:ekr.20031218072017.935:p.moveToNodeAfterTree
def moveToNodeAfterTree (self):
	
	"""Move a position to the node after the position's tree."""
	
	p = self
	
	while p:
		if p.hasNext():
			p.moveToNext()
			break
		p.moveToParent()

	return p
#@-node:ekr.20031218072017.935:p.moveToNodeAfterTree
#@+node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
def moveToNthChild (self,n):
	
	p = self
	
	if p:
		child = p.v.nthChild(n) # Must call vnode method here!
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@nonl
#@-node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self
	
	# if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

	if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
		# g.trace("pop",p.v,p)
	else:
		p.v = None

	return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20031218072017.938:p.moveToThreadBack
def moveToThreadBack (self):
	
	"""Move a position to it's threadBack position."""

	p = self

	if p.hasBack():
		p.moveToBack()
		p.moveToLastNode()
	else:
		p.moveToParent()

	return p
#@nonl
#@-node:ekr.20031218072017.938:p.moveToThreadBack
#@+node:ekr.20031218072017.939:p.moveToThreadNext
def moveToThreadNext (self):
	
	"""Move a position to the next a position in threading order."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			p.moveToFirstChild()
		elif p.v._next:
			p.moveToNext()
		else:
			p.moveToParent()
			while p:
				if p.v._next:
					p.moveToNext()
					break #found
				p.moveToParent()
			# not found.
				
	return p
#@nonl
#@-node:ekr.20031218072017.939:p.moveToThreadNext
#@+node:ekr.20031218072017.940:p.moveToVisBack
def moveToVisBack (self):
	
	"""Move a position to the position of the previous visible node."""

	p = self
	
	if p:
		p.moveToThreadBack()
		while p and not p.isVisible():
			p.moveToThreadBack()

	assert(not p or p.isVisible())
	return p
#@nonl
#@-node:ekr.20031218072017.940:p.moveToVisBack
#@+node:ekr.20031218072017.941:p.moveToVisNext
def moveToVisNext (self):
	
	"""Move a position to the position of the next visible node."""

	p = self

	p.moveToThreadNext()
	while p and not p.isVisible():
		p.moveToThreadNext()
			
	return p
#@nonl
#@-node:ekr.20031218072017.941:p.moveToVisNext
#@-node:ekr.20031218072017.928:p.moveToX
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

	"""Puts all <v> elements in the order in which they appear in the outline."""

	c = self.c
	c.clearAllVisited()

	self.put("<vnodes>") ; self.put_nl()

	# Make only one copy for all calls.
	self.currentPosition = c.currentPosition() 
	self.topPosition     = c.topPosition()

	if self.usingClipboard:
		self.putVnode(self.currentPosition) # Write only current tree.
	else:
		for p in c.rootPosition().self_and_siblings_iter():
			self.putVnode(p) # Write the next top-level node.

	self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20040318164450:(Saving a .leo file created too many positions)
#@+node:ekr.20040317094229:(Draw user icons)
#@+node:ekr.20031218072017.4140:<< drawing constants >>
box_padding = 5 # extra padding between box and icon
box_width = 9 + box_padding
icon_width = 20
icon_padding = 2
text_indent = 4 # extra padding between icon and tex
child_indent = 28 # was 20
hline_y = 7 # Vertical offset of horizontal line
root_left = 7 + box_width
root_top = 2
hiding = true # true if we don't reallocate items
line_height = 17 + 2 # To be replaced by Font height
#@nonl
#@-node:ekr.20031218072017.4140:<< drawing constants >>
#@+node:ekr.20040317184631.2:Changes
@nocolor

"lineHeight"

This key won't be used.

t.unknownAttributes["lineYOffset"] 

An integer y offset for the entire line (except user icons, which are flexible enough).  You can use this to center the following vertically: the plus/minus box, the horizontal line to the plus/minus box, the standard headline box, and the Tk.Text widget for the headline.
#@nonl
#@-node:ekr.20040317184631.2:Changes
#@+node:ekr.20040317184631:Design
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2477913
By: edream

A better design for user icons

Using tuples in t.unknownAttributes["icons"] is too constricted.  Much better
to have t.unknownAttributes["icons"] be a list of Python _dictionaries_ rather
than a list of tuples.  Each of these "subsidiary" dictionaries could have the
following keys:

"type"

"file", "icon" or "url".  At present my prototype code uses "file" to specify
the location of an icon.

"where":

"beforeBox", "beforeIcon", "beforeHeadLine", "afterHeadline".  This specifies
where to put the icon.  The default would be "beforeHeadline".  "beforeBox"
means before the plus/minus box.  "beforeIcon" means before the standard icon.

"height":

the height of the icon to use when calculating the line height.  Default: get
from the icon itself, if possible.

"width":

the width of the icon to use when calculating where to put the following element.
Default: get from the icon, if possible.

"xoffset"

Leo draws the icon at x + xoffset, where x is determined by the where param
above.  Default 0.

"xpad"

The amount of extra space following the icon.  Default 0.

"yoffset"

Leo draws the icon at y + yoffset.  Default 0.

"ypad"

The amount of extra vertical space to add to the line height.  Default 0.

These offset and pad values are integer pixel values and may be positive or
negative.

"lineHeight"  NOT USED.

Overrides any calculated line height.  Default:  lineHeight = yoffset + height + ypad.

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.

Edward

P.S.  Other gui's might not be able to support all these options.  That's ok.
The drawing code in gui plugins should degrade gracefully.

EKR

#@-node:ekr.20040317184631:Design
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):

	y += 7 # draw the box at x, y+7
	h = self.line_height

	tree = self
	iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y+self.lineyoffset,image=image)
	
	if 1: # New in 4.2.  Create a frame to catch all clicks.
		id4 = self.canvas.create_rectangle(0,y-7,1000,y-7+h-3)
		color = ""
		self.canvas.itemconfig(id4,fill=color,outline=color)
		self.canvas.lower(id4)
		id3 = self.canvas.tag_bind(id4, "<1>", p.OnBoxClick)
		self.tagBindings.append((id,id3,"<1>"),)

	id1 = self.canvas.tag_bind(id, "<1>", p.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
	
	"""Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

	tree = self
	
	# Make sure the bindings refer to the _present_ position.
	v = p.v

	if x is None and y is None:
		try:
			x,y = v.iconx, v.icony
		except:
			# Inject the ivars.
			x,y = v.iconx, v.icony = 0,0
	else:
		# Inject the ivars.
		v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute v.iconVal.
	# This is an important drawing optimization.
	val = v.iconVal = v.computeIcon()
	assert(0 <= val <= 15)

	# Get the image.
	imagename = "box%02d.GIF" % val
	image = self.getIconImage(imagename)
	id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image)
	self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.

	id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
	id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
	id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
	self.tagBindings.append((id,id3,"<3>"),)

	return 0,icon_width # dummy icon height,width
#@nonl
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

	"""Draw horizontal line from vertical line to icon"""
	
	if 1:
		self.lineyoffset = 0
	else:
		if hasattr(p.v.t,"unknownAttributes"):
			self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
		else:
			self.lineyoffset = 0
		
	self.canvas.create_line(x,y+7+self.lineyoffset,
		x+box_width,y+7+self.lineyoffset,
		tag="lines",fill="gray50") # stipple="gray25")

	if self.inVisibleArea(y):
		return self.force_draw_node(p,x,y)
	else:
		return self.line_height,0
#@nonl
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

	self.allocatedNodes += 1
	h,w = self.drawUserIcons(p,"beforeBox",x,y)
	xw = w # The extra indentation before the icon box.
	if p.hasChildren():
		self.drawBox(p,x+w,y)
	w += box_width # even if box isn't drawn.

	h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
	h = max(h,h2) ; w += w2 ; xw += w2

	h2,w2 = self.drawIcon(p,x+w,y)
	h = max(h,h2) ; w += w2

	h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
	h = max(h,h2) ; w += w2

	h2 = self.drawText(p,x+w,y)
	h = max(h,h2)
	w += self.widthInPixels(p.headString())

	h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
	h = max(h,h2)

	return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040318090335:force_draw_node (old)
def force_draw_nodeOLD(self,p,x,y):

	self.allocatedNodes += 1

	if p.hasChildren():
		self.drawBox(p,x,y)
	w = box_width # Even if the box isn't drawn.

	h2,w2 = self.drawIcon(p,x+w,y)
	w += w2

	h = self.drawText(p,x+w,y)
	
	return h,0
#@-node:ekr.20040318090335:force_draw_node (old)
#@-node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.2029:drawTopTree
def drawTopTree (self):
	
	"""Draws the top-level tree, taking into account the hoist state."""
	
	c = self.c
	
	if c.hoistStack:
		p,junk = c.hoistStack[-1]
		self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=true)
	else:
		self.drawTree(c.rootPosition(),root_left,root_top,0,0)
		
	# g.trace(g.app.copies) ; g.app.copies = 0
	# import traceback ; traceback.print_stack()
#@nonl
#@-node:ekr.20031218072017.2029:drawTopTree
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20040317095510:drawUserIcon
def drawUserIcon (self,where,x,y,dict):
	
	h,w = 0,0

	if where != dict.get("where","beforeHeadline"):
		return h,w
		
	# g.trace(where,x,y,dict)
	
	<< set offsets and pads >>
	type = dict.get("type")
	if type == "icon":
		s = dict.get("icon")
		<< draw the icon in string s >>
	elif type == "file":
		file = dict.get("file")
		<< draw the icon at file >>
	elif type == "url":
		url = dict.get("url")
		<< draw the icon at url >>
		
	# Allow user to specify height, width explicitly.
	h = dict.get("height",h)
	w = dict.get("width",w)

	return h,w
#@nonl
#@+node:ekr.20040317173849:<< set offsets and pads >>
xoffset = dict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = dict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = dict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = dict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040317173849:<< set offsets and pads >>
#@+node:ekr.20040317095153:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040317095153:<< draw the icon in string s >>
#@+node:ekr.20040317095153.1:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040317095153.1:<< draw the icon at url >>
#@+node:ekr.20040317100702:<< draw the icon at file >>
try:
	image = self.iconimages[file]
	# Get the image from the cache if possible.
except KeyError:
	try:
		fullname = g.os_path_join(g.app.loadDir,"..","Icons",file)
		fullname = g.os_path_normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas,file=fullname)
		self.iconimages[fullname] = image
	except:
		#g.es("Exception loading: " + fullname)
		#g.es_exception()
		image = None
		
if image:
	id = self.canvas.create_image(x+xoffset,y+yoffset,anchor="nw",image=image)
	self.canvas.lift(id)
	h = image.height() + yoffset + ypad
	w = image.width()  + xoffset + xpad
#@nonl
#@-node:ekr.20040317100702:<< draw the icon at file >>
#@-node:ekr.20040317095510:drawUserIcon
#@+node:ekr.20040317094609:drawUserIcons
def drawUserIcons(self,p,where,x,y):
	
	"""Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
	
	h,w = 0,0 ; t = p.v.t
	
	if not hasattr(t,"unknownAttributes"):
		return h,w
	
	iconsList = t.unknownAttributes.get("icons")
	# g.trace(iconsList)
	
	try:
		for dict in iconsList:
			h2,w2 = self.drawUserIcon(where,x+w,y,dict)
			h = max(h,h2) ; w += w2
	except:
		g.es_exception()

	return h,w
#@nonl
#@-node:ekr.20040317094609:drawUserIcons
#@+node:ekr.20040317184631.1:To do
@nocolor

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.
#@nonl
#@-node:ekr.20040317184631.1:To do
#@+node:ekr.20031218072017.4147:tree.getIconImage
def getIconImage (self, name):

	# Return the image from the cache if possible.
	if self.iconimages.has_key(name):
		return self.iconimages[name]
		
	try:
		fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
		fullname = g.os_path_normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
		self.iconimages[name] = image
		return image
	except:
		g.es("Exception loading: " + fullname)
		g.es_exception()
		return None
#@nonl
#@-node:ekr.20031218072017.4147:tree.getIconImage
#@-node:ekr.20040317094229:(Draw user icons)
#@+node:ekr.20040322074056:(Fixed Go To Line Number command)
#@+node:ekr.20040322121338:Notes
@nocolor

Rewrote logic that finds parent node.  This takes a lot more work because:

1. There are no join lists.
2. p.v.t.vnodeList contains vnodes, not positions.

We must search the entire tree looking for positions that match the vnodes in p.v.t.vnodeList.

Another change:  the tnodeList is a part of tnodes in 4.2.
#@nonl
#@-node:ekr.20040322121338:Notes
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self):

	c = self ; p = c.currentPosition()
	<< set root to the nearest @file, @silentfile or @rawfile ancestor node >>
	<< read the file into lines >>
	<< get n, the line number, from a dialog >>
	# g.trace(n)
	if n==1:
		p = root ; n2 = 1 ; found = true
	elif n >= len(lines):
		p = root ; found = false
		n2 = p.bodyString().count('\n')
	elif root.isAtAsisFileNode():
		<< count outline lines, setting p,n2,found >>
	else:
		vnodeName,childIndex,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root)
		found = true
		if not vnodeName:
			g.es("invalid derived file: " + fileName)
			return
		<< set p to the node given by vnodeName and childIndex or n >>
	<< select p and make it visible >>
	<< put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root to the nearest @file, @silentfile or @rawfile ancestor node >>
fileName = None
for p in p.self_and_parents_iter():
	fileName = self.getGoToFileName(p)
	if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
	p1 = c.currentPosition()
	for p in c.allNodes_iter():
		if p.v.t == p1.v.t and p != p1:
			# Found a joined position.
			for p in p.self_and_parents_iter():
				fileName = self.getGoToFileName(p)
				if fileName: break
		if fileName: break
	
if fileName:
	g.trace(fileName,p)
	root = p.copy()
else:
	g.es("Go to line number: ancestor must be @file node", color="blue")
	return
#@nonl
#@-node:ekr.20031218072017.2865:<< set root to the nearest @file, @silentfile or @rawfile ancestor node >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >> in OnGoToLineNumber
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
	file=open(fileName)
	lines = file.readlines()
	file.close()
except:
	g.es("not found: " + fileName)
	return
	
#@-node:ekr.20031218072017.2866:<< read the file into lines >> in OnGoToLineNumber
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog("Enter Line Number","Line number:")
if n == -1:
	return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = false
for p in p.self_and_subtree_iter():
	lastv = p.copy()
	s = p.bodyString()
	lines = s.count('\n')
	if len(s) > 0 and s[-1] != '\n':
		lines += 1
	# print lines,prev,p
	if prev + lines >= n:
		found = true ; break
	prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName and childIndex or n >>
after = root.nodeAfterTree()

if childIndex == -1:
	<< 4.x: scan for the node using tnodeList and n >>
else:
	<< 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = true

if not hasattr(root.v.t,"tnodeList"):
	s = "no child index for " + root.headString()
	print s ; g.es(s, color="red")
	ok = false

if ok:
	tnodeList = root.v.t.tnodeList
	<< set tnodeIndex to the number of +node sentinels before line n >>
	tnodeIndex = max(0,tnodeIndex)
	<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
			
if not ok:
	# Fall back to the old logic.
	<< set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
	if scanned >= n:
		break
	i = g.skip_ws(s,0)
	if g.match(s,i,delim):
		i += len(delim)
		if g.match(s,i,"+node"):
			# g.trace(tnodeIndex,s.rstrip())
			tnodeIndex += 1
	scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
	t = tnodeList[tnodeIndex]
	# Find the first vnode whose tnode is t.
	found = false
	for p in root.self_and_subtree_iter():
		if p.v.t == t:
			found = true ; break
	if not found:
		s = "tnode not found for " + vnodeName
		print s ; g.es(s, color="red") ; ok = false
	elif p.headString().strip() != vnodeName:
		if 0: # Apparently this error doesn't prevent a later scan for working properly.
			s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
			print s ; g.es(s, color="red")
		ok = false
else:
	s = "Invalid computed tnodeIndex: %d" % tnodeIndex
	print s ; g.es(s, color = "red") ; ok = false
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = false
for p in root.self_and_subtree_iter():
	if p.matchHeadline(vnodeName):
		found = true ; break

if not found:
	s = "not found: " + vnodeName
	print s ; g.es(s, color="red")
	return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = false
for p in root.self_and_subtree_iter():
	if p.matchHeadline(vnodeName):
		if childIndex <= 0 or p.childIndex() + 1 == childIndex:
			found = true ; break

if not found:
	g.es("not found: " + vnodeName, color="red")
	return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName and childIndex or n >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
	c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
	c.frame.body.setInsertionPointToEnd()
	g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root):
	
	"""Convert a line number n to a vnode name, child index and line number."""
	
	childIndex = 0 ; newDerivedFile = false
	<< set delim, leoLine from the @+leo line >>
	if not delim:
		g.es("bad @+leo sentinel")
		return None,None,None,None
	<< scan back to @+node, setting offset,nodeSentinelLine >>
	if nodeSentinelLine == -1:
		# The line precedes the first @+node sentinel
		# g.trace("before first line")
		return root.headString(),0,1,delim # 10/13/03
	s = lines[nodeSentinelLine]
	# g.trace(s)
	<< set vnodeName and childIndex from s >>
	# g.trace("childIndex,offset",childIndex,offset,vnodeName)
	return vnodeName,childIndex,offset,delim
#@nonl
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
	i += 1
leoLine = i # Index of the line containing the leo sentinel
# g.trace("leoLine:",leoLine)

delim = None # All sentinels start with this.
if leoLine < len(lines):
	# The opening comment delim is the initial non-whitespace.
	s = lines[leoLine]
	i = g.skip_ws(s,0)
	j = s.find(tag)
	newDerivedFile = g.match(s,j,"@+leo-ver=4")
	delim = s[i:j]
	if len(delim)==0:
		delim=None
	else:
		delim += '@'
#@nonl
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
	s = lines[line]
	# g.trace(s)
	i = g.skip_ws(s,0)
	if g.match(s,i,delim):
		<< handle delim while scanning backward >>
	else:
		offset += 1 # Assume the line is real.  A dubious assumption.
	line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
	g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
	# The end of a nested section.
	line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
	nodeSentinelLine = line
	break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
	offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and childIndex from s >>
if newDerivedFile:
	# vnode name is everything following the first ':'
	# childIndex is -1 as a flag for later code.
	i = s.find(':')
	if i > -1: vnodeName = s[i+1:].strip()
	else: vnodeName = None
	childIndex = -1
else:
	# vnode name is everything following the third ':'
	i = 0 ; colons = 0
	while i < len(s) and colons < 3:
		if s[i] == ':':
			colons += 1
			if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
				junk,childIndex = g.skip_long(s,i+1)
		i += 1
	vnodeName = s[i:].strip()
	
# g.trace("vnodeName:",vnodeName)
if not vnodeName:
	vnodeName = None
	g.es("bad @+node sentinel")
#@-node:ekr.20031218072017.2881:<< set vnodeName and childIndex from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
	
	s = lines[n]
	i = g.skip_ws(s,0)
	assert(g.match(s,i,delim))
	i += len(delim)
	if g.match(s,i,"+node"):
		start="+node" ; end="-node" ; delta=1
	else:
		assert(g.match(s,i,"-node"))
		start="-node" ; end="+node" ; delta=-1
	# Scan to matching @+-node delim.
	n += delta ; level = 0
	while 0 <= n < len(lines):
		s = lines[n] ; i = g.skip_ws(s,0)
		if g.match(s,i,delim):
			i += len(delim)
			if g.match(s,i,start):
				level += 1
			elif g.match(s,i,end):
				if level == 0: break
				else: level -= 1
		n += delta # bug fix: 1/30/02
		
	# g.trace(n)
	return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@+node:ekr.20040322115523:getGoToFileName
def getGoToFileName (self,p):
	
	return p.anyAtFileNodeName() # 4/28/04
#@nonl
#@-node:ekr.20040322115523:getGoToFileName
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@-node:ekr.20040322074056:(Fixed Go To Line Number command)
#@-node:ekr.20040325203859.2:3/22
#@+node:ekr.20040325203859.3:3/24
#@+node:ekr.20040323072005:(Fixed select headline bug)
# The fix was to call endEditLabel from editLabel only if are in a different node.
# That is possible now that tree.editPosition() is available.
#@nonl
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def dragging(self):
	return self._dragging

def getEditTextDict(self,v):
	# New in 4.2: the default is an empty list.
	return self.edit_text_dict.get(v,[])

def editPosition(self):
	return self._editPosition
	
def setDragging(self,flag):
	self._dragging = flag

def setEditPosition(self,p):
	self._editPosition = p
#@nonl
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@+node:ekr.20031218072017.4157:Selecting & editing (tree)
#@+node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

	p = self.c.currentPosition()
	self.setDisabledLabelState(p)

def undimEditLabel (self):

	p = self.c.currentPosition()
	self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
#@+node:ekr.20031218072017.4159:editLabel
def editLabel (self,p):
	
	"""Start editing p.edit_text."""
	
	# g.trace(p)

	if self.editPosition() and p != self.editPosition():
		self.endEditLabel()
		self.frame.revertHeadline = None
		
	self.setEditPosition(p)

	# Start editing
	if p and p.edit_text():
		self.setNormalLabelState(p)
		self.frame.revertHeadline = p.headString()
		self.setEditPosition(p)
#@nonl
#@-node:ekr.20031218072017.4159:editLabel
#@+node:ekr.20031218072017.4160:endEditLabel
def endEditLabel (self):
	
	"""End editing for self.editText."""

	c = self.c ; gui = g.app.gui
	
	p = self.editPosition()

	if p and p.edit_text():
		self.setUnselectedLabelState(p)
		self.setEditPosition(None)

		# force a redraw of joined and ancestor headlines.
		self.force_redraw() 

	gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02
#@nonl
#@-node:ekr.20031218072017.4160:endEditLabel
#@+node:ekr.20031218072017.4161:tree.expandAllAncestors
def expandAllAncestors (self,p):
	
	redraw_flag = false

	for p in p.parents_iter():
		if not p.isExpanded():
			p.expand()
			redraw_flag = true

	return redraw_flag

#@-node:ekr.20031218072017.4161:tree.expandAllAncestors
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@+node:ekr.20031218072017.4162:tree.set...LabelState
def setNormalLabelState (self,p): # selected, editing

	# g.trace(p)
	if p and p.edit_text():
		<< set editing headline colors >>
		p.edit_text().tag_remove("sel","1.0","end")
		p.edit_text().tag_add("sel","1.0","end")
		g.app.gui.set_focus(self.c,p.edit_text())

def setDisabledLabelState (self,p): # selected, disabled

	# g.trace(p,g.callerName(2),g.callerName(3))
	if p and p.edit_text():
		<< set selected, disabled headline colors >>

def setSelectedLabelState (self,p): # selected, not editing

	# g.trace(p)
	self.setDisabledLabelState(p)

def setUnselectedLabelState (self,p): # not selected.

	# g.trace(p)
	if p and p.edit_text():
		<< set unselected headline colors >>
#@+node:ekr.20031218072017.4163:<< set editing headline colors >>
config = g.app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	if selfg and selbg:
		p.edit_text().configure(
			selectforeground=selfg,selectbackground=selbg,
			state="normal",highlightthickness=1,fg=fg,bg=bg)
	else:
		p.edit_text().configure(
			state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4163:<< set editing headline colors >>
#@+node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
	fg,bg = "black","gray80"

try:
	p.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
#@+node:ekr.20031218072017.4165:<< set unselected headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	p.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4165:<< set unselected headline colors >>
#@-node:ekr.20031218072017.4162:tree.set...LabelState
#@-node:ekr.20031218072017.4157:Selecting & editing (tree)
#@-node:ekr.20040323072005:(Fixed select headline bug)
#@+node:ekr.20040322121338.1:(Fixed bug in setAllAncestorAtFileNodesDirty)
#@+node:ekr.20040323073825:Notes
@nocolor

Moving a node right so that it becomes a child of an @file-thin node doesn't work.

The fix was in findAllPotentiallyDirtyNodes:
	- v.parents is only used if v._parent is None.
	- Added a code to add v._parent to the list of nodes.
#@nonl
#@-node:ekr.20040323073825:Notes
#@+node:ekr.20040323090654:mini test: check consistency of p.v.t.vnodeList, & v.parents for cloned nodes
import leoGlobals as g
from leoGlobals import true,false
c = g.top()

print '-'*20
ok = true ; count = 0
for p in c.allNodes_iter():
	if p.isCloned():
		count += 1
		parents = p.v.t.vnodeList
		for child in p.children_iter():
			vparents = child.v.parents
			if len(parents) != len(vparents):
					print "length mismatch",p,child,
					ok = false
			for parent in parents:
				if parent not in vparents:
					print "not in vparents",p,child
					ok = false
			for parent in vparents:
				if parent not in parents:
					print "not in parents",p,child
					ok = false
			if not ok:
				print "parents"
				for parent in parents: print parent
				print "vparents"
				for parent in vparents: print parent
				break
		if not ok: break
	if not ok: break
s = "checked %d cloned positions" % count
print s ; g.es(s)
#@nonl
#@-node:ekr.20040323090654:mini test: check consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20040311113514:p.clearDirty
def clearDirty (self):

	p = self
	p.v.clearDirty()
#@nonl
#@-node:ekr.20040311113514:p.clearDirty
#@+node:ekr.20040303163717:p.isDirty
def isDirty (self):
	
	p = self
	return p.v and p.v.isDirty()
#@nonl
#@-node:ekr.20040303163717:p.isDirty
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
	
	p = self
	
	# Start with all nodes in the vnodeList.
	nodes = []
	newNodes = p.v.t.vnodeList[:]

	# Add nodes until no more are added.
	while newNodes:
		# g.trace(len(newNodes))
		addedNodes = []
		nodes.extend(newNodes)
		for v in newNodes:
			for v2 in v.t.vnodeList:
				if v2 not in nodes and v2 not in addedNodes:
					addedNodes.append(v2)
				for v3 in v2.directParents(): # 3/23/04
					if v3 not in nodes and v3 not in addedNodes:
						addedNodes.append(v3)
		newNodes = addedNodes[:]

	# g.trace(nodes)
	return nodes
#@nonl
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
def setAllAncestorAtFileNodesDirty (self):

	p = self ; c = p.c
	changed = false
	
	# Calculate all nodes that are joined to v or parents of such nodes.
	nodes = p.findAllPotentiallyDirtyNodes()
	
	c.beginUpdate()
	if 1: # update...
		for v in nodes:
			# g.trace(v.isAnyAtFileNode(),v.t.isDirty(),v)
			if not v.t.isDirty() and v.isAnyAtFileNode():
				changed = true
				v.t.setDirty() # Do not call v.setDirty here!
	c.endUpdate(changed)
	return changed
#@nonl
#@-node:ekr.20040303214038:p.setAllAncestorAtFileNodesDirty
#@+node:ekr.20040303163330:p.setDirty
# Ensures that all ancestor @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self):

	p = self ; c = p.c

	c.beginUpdate()
	if 1: # update...
		changed = false
		if not p.v.t.isDirty():
			p.v.t.setDirty()
			changed = true
		# This must be called even if p.v is already dirty.
		if p.setAllAncestorAtFileNodesDirty():
			changed = true
	c.endUpdate(changed)

	return changed
#@nonl
#@-node:ekr.20040303163330:p.setDirty
#@-node:ekr.20040305162628:p.Dirty bits
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight(self):
	
	c = self ; p = c.currentPosition()
	if not p: return
	
	if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	
	if not p.hasBack: return
	back = p.back()
	if not c.checkMoveWithParentWithWarning(p,back,true): return

	# Remember both the before state and the after state for undo/redo
	oldBack = back
	oldParent = p.parent()
	oldN = p.childIndex()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		n = back.numberOfChildren()
		p.moveToNthChildOf(back,n)
		c.undoer.setUndoParams("Move Right",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@-node:ekr.20040322121338.1:(Fixed bug in setAllAncestorAtFileNodesDirty)
#@+node:ekr.20040323090456.2:(Removed v.parents field)
@nocolor

- (done) Rename v.parents to v.parentsList
- (done) Don't clear _parents link.
- (done) Look at len(_parent.v.t.vnodeList) to see if should pop stack.
- (done) Create v.directParents()
- (done) Use v.directParents in findAllPotentiallyDirtyNodes.
- (done) Created tests to make sure clones actually share subtrees.
	- Full unit tests now pass.

@color

#@+node:ekr.20040227212621:p.hasX
def hasBack(self):
	return self.v and self.v._back

hasFirstChild = hasChildren
	
def hasNext(self):
	return self.v and self.v._next
	
def hasParent(self):
	return self.v and self.v._parent is not None
	
def hasThreadBack(self):
	return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
	
hasVisBack = hasThreadBack
#@nonl
#@+node:ekr.20040227224946:hasThreadNext (the only complex hasX method)
def hasThreadNext(self):

	p = self ; v = p.v
	if not p.v: return false

	if v.t._firstChild or v._next:
		return true
	else:
		n = len(p.stack)-1
		v,n = p.vParentWithStack(v,p.stack,n)
		while v:
			if v._next:
				return true
			v,n = p.vParentWithStack(v,p.stack,n)
		return false

hasVisNext = hasThreadNext
#@nonl
#@-node:ekr.20040227224946:hasThreadNext (the only complex hasX method)
#@-node:ekr.20040227212621:p.hasX
#@+node:ekr.20031218072017.1968:<< initialize vnode data members >>
self.c = c # The commander for this vnode.
self.t = t # The tnode.
self.statusBits = 0 # status bits

# Structure links.
self._parent = self._next = self._back = None
#@nonl
#@-node:ekr.20031218072017.1968:<< initialize vnode data members >>
#@+node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
def findAllPotentiallyDirtyNodes(self):
	
	p = self
	
	# Start with all nodes in the vnodeList.
	nodes = []
	newNodes = p.v.t.vnodeList[:]

	# Add nodes until no more are added.
	while newNodes:
		# g.trace(len(newNodes))
		addedNodes = []
		nodes.extend(newNodes)
		for v in newNodes:
			for v2 in v.t.vnodeList:
				if v2 not in nodes and v2 not in addedNodes:
					addedNodes.append(v2)
				for v3 in v2.directParents(): # 3/23/04
					if v3 not in nodes and v3 not in addedNodes:
						addedNodes.append(v3)
		newNodes = addedNodes[:]

	# g.trace(nodes)
	return nodes
#@nonl
#@-node:ekr.20040318125934:p.findAllPotentiallyDirtyNodes
#@+node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
# These remain in 4.2: the file read logic calls these before creating positions.
#@nonl
#@+node:ekr.20031218072017.3419:v.insertAfter
def insertAfter (self,t=None):

	"""Inserts a new vnode after self"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAfter(self)

	return v
#@nonl
#@-node:ekr.20031218072017.3419:v.insertAfter
#@+node:ekr.20031218072017.3421:v.insertAsNthChild
def insertAsNthChild (self,n,t=None):

	"""Inserts a new node as the the nth child of the receiver.
	The receiver must have at least n-1 children"""

	if not t:
		t = tnode(headString="NewHeadline")

	v = vnode(self.c,t)
	v.linkAsNthChild(self,n)

	return v
#@nonl
#@-node:ekr.20031218072017.3421:v.insertAsNthChild
#@+node:ekr.20031218072017.2355:v.linkAfter
def linkAfter (self,v):

	"""Link self after v."""
	
	self._parent = v._parent
	self._back = v
	self._next = v._next
	v._next = self
	if self._next:
		self._next._back = self
#@-node:ekr.20031218072017.2355:v.linkAfter
#@+node:ekr.20031218072017.3425:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

	"""Links self as the n'th child of vnode pv"""

	v = self
	# g.trace(v,pv,n)
	v._parent = pv
	if n == 0:
		v._back = None
		v._next = pv.t._firstChild
		if pv.t._firstChild:
			pv.t._firstChild._back = v
		pv.t._firstChild = v
	else:
		prev = pv.nthChild(n-1) # zero based
		assert(prev)
		v._back = prev
		v._next = prev._next
		prev._next = v
		if v._next:
			v._next._back = v
#@nonl
#@-node:ekr.20031218072017.3425:v.linkAsNthChild
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link a vnode as the root node and set the root _position_."""

	v = self ; c = v.c

	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRoot
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot: oldRoot._back = v

	newRoot = position(v,[])
	c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.3422:v.moveToRoot
def moveToRoot (self,oldRoot=None):

	"""Moves the receiver to the root position"""

	v = self

	v.unlink()
	v.linkAsRoot(oldRoot)
	
	return v
#@nonl
#@-node:ekr.20031218072017.3422:v.moveToRoot
#@+node:ekr.20031218072017.3438:v.unlink
def unlink (self):

	"""Unlinks a vnode from the tree."""

	v = self ; c = v.c

	# g.trace(v._parent," child: ",v.t._firstChild," back: ", v._back, " next: ", v._next)
	
	# Special case the root.
	if v == c.rootPosition().v: # 3/11/04
		assert(v._next)
		newRoot = position(v._next,[])
		c.setRootPosition(newRoot)

	# Clear the links in other nodes.
	if v._back:
		v._back._next = v._next
	if v._next:
		v._next._back = v._back

	if v._parent and v == v._parent.t._firstChild:
		v._parent.t._firstChild = v._next

	# Clear the links in this node.
	v._parent = v._next = v._back = None
	# v.parentsList = []
#@nonl
#@-node:ekr.20031218072017.3438:v.unlink
#@-node:ekr.20040301071824:v.Link/Unlink/Insert methods (used by file read logic)
#@+node:ekr.20040323100443:v.directParents (new method in 4.2)
def directParents (self):
	
	"""(New in 4.2) Return a list of all direct parent vnodes of a vnode.
	
	This is NOT the same as the list of ancestors of the vnode."""
	
	v = self
	
	if v._parent:
		return v._parent.t.vnodeList
	else:
		return []
#@nonl
#@-node:ekr.20040323100443:v.directParents (new method in 4.2)
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
	
	"""A utility that allows the computation of p.v without calling p.copy().
	
	v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

	Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

	if not v:
		return None,n
	elif v._parent and len(v._parent.t.vnodeList) == 1:
		return v._parent,n # don't change stack.
	elif stack and n >= 0:
		return self.stack[n],n-1 # simulate popping the stack.
	else:
		return None,n
#@nonl
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
	p = p.moveToParent()
	if p: list1.append(p.v)
# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
	list2.append(v)
	v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self
	
	# if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

	if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
		# g.trace("pop",p.v,p)
	else:
		p.v = None

	return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20040310062332:p.Link/Unlink methods
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@nonl
#@+node:ekr.20040310062332.1:p.invalidOutline
def invalidOutline (self, message):
	
	p = self

	if p.hasParent():
		node = p.parent()
	else:
		node = p

	g.alert("invalid outline: %s\n%s" % (message,node))
#@nonl
#@-node:ekr.20040310062332.1:p.invalidOutline
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

	"""Link self after v."""
	
	p = self
	# g.trace(p,after)
	
	p.stack = after.stack[:] # 3/12/04
	p.v._parent = after.v._parent
	
	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
	
	p.v._back = after.v
	p.v._next = after.v._next
	
	after.v._next = p.v
	
	if p.v._next:
		p.v._next._back = p.v

	if 0:
		g.trace('-'*20,after)
		p.dump(label="p")
		after.dump(label="back")
		if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20040310062332.3:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

	"""Links self as the n'th child of vnode pv"""
	
	# g.trace(self,parent,n)
	p = self

	# Recreate the stack using the parent.
	p.stack = parent.stack[:] 
	if parent.isCloned():
		p.stack.append(parent.v)

	p.v._parent = parent.v

	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)

	if n == 0:
		child1 = parent.v.t._firstChild
		p.v._back = None
		p.v._next = child1
		if child1:
			child1._back = p.v
		parent.v.t._firstChild = p.v
	else:
		prev = parent.nthChild(n-1) # zero based
		assert(prev)
		p.v._back = prev.v
		p.v._next = prev.v._next
		prev.v._next = p.v
		if p.v._next:
			p.v._next._back = p.v
			
	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.3:p.linkAsNthChild
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link self as the root node."""
	
	# g.trace(self,oldRoot)

	p = self ; v = p.v
	if oldRoot: oldRootVnode = oldRoot.v
	else:       oldRootVnode = None
	
	p.stack = [] # Clear the stack.
	
	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRootVnode # Bug fix: 3/12/04
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot:
		oldRoot.v._back = v # Bug fix: 3/12/04

	p.c.setRootPosition(p)
	
	if 0:
		p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

	"""Unlinks a position p from the tree before moving or deleting.
	
	The p.v._fistChild link does NOT change."""

	p = self ; v = p.v ; parent = p.parent()
	
	# Note:  p.parent() is not necessarily the same as v._parent.
	
	if parent:
		assert(p.v and p.v._parent in p.v.directParents())
		assert(parent.v in p.v.directParents())

	# g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
	
	# Special case the root.
	if p == p.c.rootPosition():
		assert(p.v._next)
		p.c.setRootPosition(p.next())
	
	# Remove v from it's tnode's vnodeList.
	vnodeList = v.t.vnodeList
	if v in vnodeList:
		vnodeList.remove(v)
	assert(v not in vnodeList)
	
	# Reset the firstChild link in its direct father.
	if parent and parent.v.t._firstChild == v:
		parent.v.t._firstChild = v._next

	# Do _not_ delete the links in any child nodes.

	# Clear the links in other nodes.
	if v._back: v._back._next = v._next
	if v._next: v._next._back = v._back

	# Unlink _this_ node.
	v._parent = v._next = v._back = None

	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		if parent: parent.dump(label="parent")
#@-node:ekr.20040310062332.5:p.unlink
#@-node:ekr.20040310062332:p.Link/Unlink methods
#@+node:ekr.20031218072017.1860:createVnode (changed for 4.2)
def createVnode (self,parent,back,tref,headline,attrDict):
	
	# g.trace(parent,headline)
	v = None ; c = self.c
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		tref = self.canonicalTnodeIndex(tref)
		t = self.tnodesDict.get(tref)
		if not t: t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c,t)
		v.moveToRoot()

	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v) # New in 4.2.

	skip = len(v.t.vnodeList) > 1

	v.initHeadString(headline,encoding=self.leo_file_encoding)
	<< handle unknown vnode attributes >>
	return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
	v.unknownAttributes = attrDict

	if 0: # For debugging.
		s = "unknown attributes for " + v.headString()
		print s ; g.es(s,color="blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode (changed for 4.2)
#@-node:ekr.20040323090456.2:(Removed v.parents field)
#@+node:ekr.20040322123611:(Check Outline command)
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=true,unittest=false):
	
	"""Report any possible clone errors in the outline.
	
	Remove any unused tnodeLists."""
	
	c = self ; count = 1 ; errors = 0 ; full = true
	if full and not unittest:
		g.es("all tests enabled: this may take awhile",color="blue")

	try:
		p = c.rootPosition()
		<< assert equivalence of lastVisible methods >>
		for p in c.allNodes_iter():
			count += 1
			<< remove unused tnodeList >>
			if not unittest: # this would be very slow.
				if full: # For testing only.
					<< do full tests >>
			# assert false, "checkFailed" # check of checkFailed itself.
	except AssertionError,message:
		errors += 1
		<< give test failed message >>
	if not unittest:
		<< print summary message >>
	return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
	g.app.debug = true

	p1 = p.oldLastVisible()
	p2 = p.lastVisible()
	
	if p1 != p2:
		print "oldLastVisible",p1
		print "   lastVisible",p2
	
	assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
	assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
	
	g.app.debug = false
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v
# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
	s = "deleting tnodeList for " + repr(v)
	print s ; g.es(s,color="blue")
	delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if count % 100 == 0:
	g.es('.',newline=false)
if count % 2000 == 0:
	g.enl()

@others
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
	assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
	assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
	assert p == back.next(), "p==back.next"
		
if next:
	assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and chiild links
if p.hasParent():
	n = p.childIndex()
	assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
	
for child in p.children_iter():
	assert p == child.parent(), "p==child.parent"

if p.hasNext():
	assert p.next().parent() == p.parent(), "next.parent==parent"
	
if p.hasBack():
	assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and chiild links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
	t = p.parent().v.t
	for v in p.directParents():
		assert(v.t == t)
#@nonl
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
	parents = p.v.t.vnodeList
	for child in p.children_iter():
		vparents = child.directParents()
		assert(len(parents) == len(vparents))
		for parent in parents:
			assert(parent in vparents)
		for parent in vparents:
			assert(parent in parents)
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
	childv = p.firstChild().v
	assert(childv == p.v.t._firstChild)
	assert(id(childv) == id(p.v.t._firstChild))
	for v in p.v.t.vnodeList:
		assert(v.t._firstChild == childv)
		assert(id(v.t._firstChild) == id(childv))
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
	
for v in vnodeList:
	
	assert v.t == p.v.t, "v.t == p.v.t"

	if p.v.isCloned():
		assert v.isCloned(), "v.isCloned"
		assert len(vnodeList) > 1, "len(vnodeList) > 1"
	else:
		assert not v.isCloned(), "not v.isCloned"
		assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
	print
	g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
	print s ; g.es(s,color="red")
elif verbose:
	g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
if errors == 1:
	s = "test failed: %s %s" % (message,repr(p))
	print s
	g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@-node:ekr.20040322123611:(Check Outline command)
#@+node:ekr.20040323084605:(Speeded up menu enablers)
#@+node:ekr.20040323171453:Notes
@nocolor

The following calls slow down the menu enablers too much:

@color

enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())

enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())

@nocolor

These all scan the entire file.  We have two choices:
	
1. scan the entire file once.

2. Always enable the above 4 commands.
	- Add a log message for these commands if there is no node found.
	
Choice two is plenty good enough.
#@nonl
#@-node:ekr.20040323171453:Notes
#@+node:ekr.20031218072017.3776:Gui-independent menu enablers
#@+node:ekr.20031218072017.3777:updateAllMenus
def updateAllMenus (self):
	
	"""The Tk "postcommand" callback called when a click happens in any menu.
	
	Updates (enables or disables) all menu items."""
	
	# A horrible kludge: set g.app.log to cover for a possibly missing activate event.
	g.app.setLog(self.frame.log,"updateAllMenus")
	
	# Allow the user first crack at updating menus.
	c = self.c ; v = c.currentVnode()

	if not g.doHook("menu2",c=c,v=v):
		self.updateFileMenu()
		self.updateEditMenu()
		self.updateOutlineMenu()
#@nonl
#@-node:ekr.20031218072017.3777:updateAllMenus
#@+node:ekr.20031218072017.3778:updateFileMenu
def updateFileMenu (self):
	
	c = self.c ; frame = c.frame
	if not c: return

	try:
		enable = frame.menu.enableMenu
		menu = frame.menu.getMenu("File")
		enable(menu,"Revert To Saved", c.canRevert())
		enable(menu,"Open With...", g.app.hasOpenWithMenu)
	except:
		g.es("exception updating File menu")
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3778:updateFileMenu
#@+node:ekr.20031218072017.836:updateEditMenu
def updateEditMenu (self):

	c = self.c ; frame = c.frame ; gui = g.app.gui
	if not c: return
	try:
		# Top level Edit menu...
		enable = frame.menu.enableMenu
		menu = frame.menu.getMenu("Edit")
		c.undoer.enableMenuItems()
		<< enable cut/paste >>
		if 0: # Always on for now.
			menu = frame.menu.getMenu("Find...")
			enable(menu,"Find Next",c.canFind())
			flag = c.canReplace()
			enable(menu,"Replace",flag)
			enable(menu,"Replace, Then Find",flag)
		# Edit Body submenu...
		menu = frame.menu.getMenu("Edit Body...")
		enable(menu,"Extract Section",c.canExtractSection())
		enable(menu,"Extract Names",c.canExtractSectionNames())
		enable(menu,"Extract",c.canExtract())
		enable(menu,"Match Brackets",c.canFindMatchingBracket())
	except:
		g.es("exception updating Edit menu")
		g.es_exception()
#@nonl
#@+node:ekr.20040130164211:<< enable cut/paste >>
if frame.body.hasFocus():
	data = frame.body.getSelectedText()
	canCut = data and len(data) > 0
else:
	# This isn't strictly correct, but we can't get the Tk headline selection.
	canCut = true

enable(menu,"Cut",canCut)
enable(menu,"Copy",canCut)

data = gui.getTextFromClipboard()
canPaste = data and len(data) > 0
enable(menu,"Paste",canPaste)
#@nonl
#@-node:ekr.20040130164211:<< enable cut/paste >>
#@-node:ekr.20031218072017.836:updateEditMenu
#@+node:ekr.20031218072017.3779:updateOutlineMenu
def updateOutlineMenu (self):

	c = self.c ; frame = c.frame
	if not c: return

	p = c.currentPosition()
	hasParent = p.hasParent()
	hasBack = p.hasBack()
	hasNext = p.hasNext()
	hasChildren = p.hasChildren()
	isExpanded = p.isExpanded()
	isCloned = p.isCloned()
	isMarked = p.isMarked()

	try:
		enable = frame.menu.enableMenu
		<< enable top level outline menu >>
		<< enable expand/contract submenu >>
		<< enable move submenu >>
		<< enable go to submenu >>
		<< enable mark submenu >>
	except:
		g.es("exception updating Outline menu")
		g.es_exception()
#@nonl
#@+node:ekr.20040131171020:<< enable top level outline menu >>
menu = frame.menu.getMenu("Outline")
enable(menu,"Cut Node",c.canCutOutline())
enable(menu,"Delete Node",c.canDeleteHeadline())
enable(menu,"Paste Node",c.canPasteOutline())
enable(menu,"Clone Node",c.canClone()) # 1/31/04
enable(menu,"Sort Siblings",c.canSortSiblings())
enable(menu,"Hoist",c.canHoist())
enable(menu,"De-Hoist",c.canDehoist())
#@nonl
#@-node:ekr.20040131171020:<< enable top level outline menu >>
#@+node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
menu = frame.menu.getMenu("Expand/Contract...")
enable(menu,"Contract Parent",c.canContractParent())
enable(menu,"Contract Node",hasChildren and isExpanded)
enable(menu,"Expand Node",hasChildren and not isExpanded)
enable(menu,"Expand Prev Level",hasChildren and isExpanded)
enable(menu,"Expand Next Level",hasChildren)
enable(menu,"Expand To Level 1",hasChildren and isExpanded)
for i in xrange(2,9):
	frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)
#@nonl
#@-node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
#@+node:ekr.20040131171020.2:<< enable move submenu >>
menu = frame.menu.getMenu("Move...")
enable(menu,"Move Down",c.canMoveOutlineDown())
enable(menu,"Move Left",c.canMoveOutlineLeft())
enable(menu,"Move Right",c.canMoveOutlineRight())
enable(menu,"Move Up",c.canMoveOutlineUp())
enable(menu,"Promote",c.canPromote())
enable(menu,"Demote",c.canDemote())
#@nonl
#@-node:ekr.20040131171020.2:<< enable move submenu >>
#@+node:ekr.20040131171020.3:<< enable go to submenu >>
menu = frame.menu.getMenu("Go To...")
enable(menu,"Go Back",c.beadPointer > 1)
enable(menu,"Go Forward",c.beadPointer + 1 < len(c.beadList))
enable(menu,"Go To Prev Visible",c.canSelectVisBack())
enable(menu,"Go To Next Visible",c.canSelectVisNext())
if 0: # These are too slow.
	enable(menu,"Go To Next Marked",c.canGoToNextMarkedHeadline())
	enable(menu,"Go To Next Changed",c.canGoToNextDirtyHeadline())
enable(menu,"Go To Next Clone",isCloned)
enable(menu,"Go To Prev Node",c.canSelectThreadBack())
enable(menu,"Go To Next Node",c.canSelectThreadNext())
enable(menu,"Go To Parent",hasParent)
enable(menu,"Go To Prev Sibling",hasBack)
enable(menu,"Go To Next Sibling",hasNext)
#@nonl
#@-node:ekr.20040131171020.3:<< enable go to submenu >>
#@+node:ekr.20040131171020.4:<< enable mark submenu >>
menu = frame.menu.getMenu("Mark/Unmark...")
label = g.choose(isMarked,"Unmark","Mark")
frame.menu.setMenuLabel(menu,0,label)
enable(menu,"Mark Subheads",hasChildren)
if 0: # These are too slow.
	enable(menu,"Mark Changed Items",c.canMarkChangedHeadlines())
	enable(menu,"Mark Changed Roots",c.canMarkChangedRoots())
enable(menu,"Mark Clones",isCloned)
#@nonl
#@-node:ekr.20040131171020.4:<< enable mark submenu >>
#@-node:ekr.20031218072017.3779:updateOutlineMenu
#@+node:ekr.20031218072017.3780:hasSelection
# Returns true if text in the outline or body text is selected.

def hasSelection (self):
	
	body = self.frame.body

	if body:
		first, last = body.getTextSelection()
		return first != last
	else:
		return false
#@nonl
#@-node:ekr.20031218072017.3780:hasSelection
#@-node:ekr.20031218072017.3776:Gui-independent menu enablers
#@+node:ekr.20031218072017.2955:Enabling Menu Items
#@+node:ekr.20040323172420:Slow routines: no longer used
#@+node:ekr.20031218072017.2966:canGoToNextDirtyHeadline (slow)
def canGoToNextDirtyHeadline (self):
	
	c = self ; current = c.currentPosition()

	for p in c.allNodes_iter():
		if p != current and p.isDirty():
			return true
	
	return false
#@nonl
#@-node:ekr.20031218072017.2966:canGoToNextDirtyHeadline (slow)
#@+node:ekr.20031218072017.2967:canGoToNextMarkedHeadline (slow)
def canGoToNextMarkedHeadline (self):
	
	c = self ; current = c.currentPosition()
		
	for p in c.allNodes_iter():
		if p != current and p.isMarked():
			return true

	return false
#@-node:ekr.20031218072017.2967:canGoToNextMarkedHeadline (slow)
#@+node:ekr.20031218072017.2968:canMarkChangedHeadline (slow)
def canMarkChangedHeadlines (self):
	
	c = self
	
	for p in c.allNodes_iter():
		if p.isDirty():
			return true
	
	return false
#@nonl
#@-node:ekr.20031218072017.2968:canMarkChangedHeadline (slow)
#@+node:ekr.20031218072017.2969:canMarkChangedRoots (slow)
def canMarkChangedRoots (self):
	
	c = self
	
	for p in c.allNodes_iter():
		if p.isDirty and p.isAnyAtFileNode():
			return true

	return false
#@nonl
#@-node:ekr.20031218072017.2969:canMarkChangedRoots (slow)
#@-node:ekr.20040323172420:Slow routines: no longer used
#@+node:ekr.20040131170659:canClone (new for hoist)
def canClone (self):

	c = self
	
	if c.hoistStack:
		current = c.currentPosition()
		p,junk = c.hoistStack[-1]
		return current != p
	else:
		return true
#@nonl
#@-node:ekr.20040131170659:canClone (new for hoist)
#@+node:ekr.20031218072017.2956:canContractAllHeadlines
def canContractAllHeadlines (self):
	
	c = self
	
	for p in c.allNodes_iter():
		if p.isExpanded():
			return true

	return false
#@nonl
#@-node:ekr.20031218072017.2956:canContractAllHeadlines
#@+node:ekr.20031218072017.2957:canContractAllSubheads
def canContractAllSubheads (self):

	c = self ; current = c.currentPosition()
	
	for p in current.subtree_iter():
		if p != current and p.isExpanded():
			return true

	return false
#@nonl
#@-node:ekr.20031218072017.2957:canContractAllSubheads
#@+node:ekr.20031218072017.2958:canContractParent
def canContractParent (self):

	c = self
	return c.currentPosition().parent()
#@nonl
#@-node:ekr.20031218072017.2958:canContractParent
#@+node:ekr.20031218072017.2959:canContractSubheads
def canContractSubheads (self):
	
	c = self ; current = c.currentPosition()

	for child in current.children_iter():
		if child.isExpanded():
			return true
		
	return false
#@nonl
#@-node:ekr.20031218072017.2959:canContractSubheads
#@+node:ekr.20031218072017.2960:canCutOutline & canDeleteHeadline
def canDeleteHeadline (self):
	
	c = self ; p = c.currentPosition()

	return p.hasParent() or p.hasThreadBack() or p.hasNext()

canCutOutline = canDeleteHeadline
#@nonl
#@-node:ekr.20031218072017.2960:canCutOutline & canDeleteHeadline
#@+node:ekr.20031218072017.2961:canDemote
def canDemote (self):

	c = self
	return c.currentPosition().hasNext()
#@nonl
#@-node:ekr.20031218072017.2961:canDemote
#@+node:ekr.20031218072017.2962:canExpandAllHeadlines
def canExpandAllHeadlines (self):
	
	c = self
	
	for p in c.allNodes_iter():
		if not p.isExpanded():
			return true

	return false
#@-node:ekr.20031218072017.2962:canExpandAllHeadlines
#@+node:ekr.20031218072017.2963:canExpandAllSubheads
def canExpandAllSubheads (self):

	c = self
	
	for p in c.currentPosition().subtree_iter():
		if not p.isExpanded():
			return true
		
	return false
#@nonl
#@-node:ekr.20031218072017.2963:canExpandAllSubheads
#@+node:ekr.20031218072017.2964:canExpandSubheads
def canExpandSubheads (self):

	c = self
	
	for p in c.currentPosition().children_iter():
		if p != current and not p.isExpanded():
			return true

	return false
#@nonl
#@-node:ekr.20031218072017.2964:canExpandSubheads
#@+node:ekr.20031218072017.2287:canExtract, canExtractSection & canExtractSectionNames
def canExtract (self):

	c = self ; body = c.frame.body
	return body and body.hasTextSelection()
	
canExtractSectionNames = canExtract
		
def canExtractSection (self):

	c = self ; body = c.frame.body
	if not body: return false
	
	s = body.getSelectedText()
	if not s: return false

	line = g.get_line(s,0)
	i1 = line.find("<<")
	j1 = line.find(">>")
	i2 = line.find("@<")
	j2 = line.find("@>")
	return -1 < i1 < j1 or -1 < i2 < j2
#@nonl
#@-node:ekr.20031218072017.2287:canExtract, canExtractSection & canExtractSectionNames
#@+node:ekr.20031218072017.2965:canFindMatchingBracket
def canFindMatchingBracket (self):
	
	c = self ; brackets = "()[]{}"
	c1 = c.frame.body.getCharAtInsertPoint()
	c2 = c.frame.body.getCharBeforeInsertPoint()
	return (c1 and c1 in brackets) or (c2 and c2 in brackets)
#@nonl
#@-node:ekr.20031218072017.2965:canFindMatchingBracket
#@+node:ekr.20040303165342:canHoist & canDehoist
def canDehoist(self):
	
	return len(self.hoistStack) > 0
		
def canHoist(self):
	
	c = self
	root = c.rootPosition()
	p = c.currentPosition()

	if c.hoistStack:
		p2,junk = c.hoistStack[-1]
		return p2 != p
	elif p == root:
		return p.hasNext()
	else:
		return true
#@nonl
#@-node:ekr.20040303165342:canHoist & canDehoist
#@+node:ekr.20031218072017.2970:canMoveOutlineDown (changed for hoist)
def canMoveOutlineDown (self):

	c = self ; current = c.currentPosition()
		
	p = current.visNext()
	while p and current.isAncestorOf(p):
		p.moveToVisNext()

	if c.hoistStack:
		h,junk = c.hoistStack[-1]
		return p and p != h and h.isAncestorOf(p)
	else:
		return p
#@nonl
#@-node:ekr.20031218072017.2970:canMoveOutlineDown (changed for hoist)
#@+node:ekr.20031218072017.2971:canMoveOutlineLeft (changed for hoist)
def canMoveOutlineLeft (self):

	c = self ; p = c.currentPosition()

	if c.hoistStack:
		h,junk = c.hoistStack[-1]
		if p and p.hasParent():
			p.moveToParent()
			return p != h and h.isAncestorOf(p)
		else:
			return false
	else:
		return p and p.hasParent()
#@nonl
#@-node:ekr.20031218072017.2971:canMoveOutlineLeft (changed for hoist)
#@+node:ekr.20031218072017.2972:canMoveOutlineRight (changed for hoist)
def canMoveOutlineRight (self):

	c = self ; p = c.currentPosition()
	
	if c.hoistStack:
		h,junk = c.hoistStack[-1]
		return p and p.hasBack() and p != h
	else:
		return p and p.hasBack()
#@nonl
#@-node:ekr.20031218072017.2972:canMoveOutlineRight (changed for hoist)
#@+node:ekr.20031218072017.2973:canMoveOutlineUp (changed for hoist)
def canMoveOutlineUp (self):

	c = self ; p = c.currentPosition()
	if not p: return false
	
	pback = p.visBack()
	if not pback: return false

	if c.hoistStack:
		h,junk = c.hoistStack[-1]
		return h != p and h.isAncestorOf(pback)
	else:
		return true
#@nonl
#@-node:ekr.20031218072017.2973:canMoveOutlineUp (changed for hoist)
#@+node:ekr.20031218072017.2974:canPasteOutline
def canPasteOutline (self,s=None):

	c = self
	if s == None:
		s = g.app.gui.getTextFromClipboard()
	if not s:
		return false

	# g.trace(s)
	if g.match(s,0,g.app.prolog_prefix_string):
		return true
	elif len(s) > 0:
		return c.importCommands.stringIsValidMoreFile(s)
	else:
		return false
#@nonl
#@-node:ekr.20031218072017.2974:canPasteOutline
#@+node:ekr.20031218072017.2975:canPromote
def canPromote (self):

	c = self ; v = c.currentVnode()
	return v and v.hasChildren()
#@nonl
#@-node:ekr.20031218072017.2975:canPromote
#@+node:ekr.20031218072017.2976:canRevert
def canRevert (self):

	# c.mFileName will be "untitled" for unsaved files.
	c = self
	return (c.frame and c.mFileName and c.isChanged())
#@nonl
#@-node:ekr.20031218072017.2976:canRevert
#@+node:ekr.20031218072017.2977:canSelect....
# 7/29/02: The shortcuts for these commands are now unique.

def canSelectThreadBack (self):
	c = self ; p = c.currentPosition()
	return p.hasThreadBack()
	
def canSelectThreadNext (self):
	c = self ; p = c.currentPosition()
	return p.hasThreadNext()

def canSelectVisBack (self):
	c = self ; p = c.currentPosition()
	return p.hasVisBack()
	
def canSelectVisNext (self):
	c = self ; p = c.currentPosition()
	return p.hasVisNext()
#@nonl
#@-node:ekr.20031218072017.2977:canSelect....
#@+node:ekr.20031218072017.2978:canShiftBodyLeft/Right
def canShiftBodyLeft (self):

	c = self ; body = c.frame.body
	return body and body.getAllText()

canShiftBodyRight = canShiftBodyLeft
#@nonl
#@-node:ekr.20031218072017.2978:canShiftBodyLeft/Right
#@+node:ekr.20031218072017.2979:canSortChildren, canSortSiblings
def canSortChildren (self):
	
	c = self ; p = c.currentPosition()
	return p and p.hasChildren()

def canSortSiblings (self):

	c = self ; p = c.currentPosition()
	return p and (p.hasNext() or p.hasBack())
#@nonl
#@-node:ekr.20031218072017.2979:canSortChildren, canSortSiblings
#@+node:ekr.20031218072017.2980:canUndo & canRedo
def canUndo (self):

	c = self
	return c.undoer.canUndo()
	
def canRedo (self):

	c = self
	return c.undoer.canRedo()
#@nonl
#@-node:ekr.20031218072017.2980:canUndo & canRedo
#@+node:ekr.20031218072017.2981:canUnmarkAll
def canUnmarkAll (self):
	
	c = self
	
	for p in c.allNodes_iter():
		if p.isMarked():
			return true

	return false
#@nonl
#@-node:ekr.20031218072017.2981:canUnmarkAll
#@-node:ekr.20031218072017.2955:Enabling Menu Items
#@-node:ekr.20040323084605:(Speeded up menu enablers)
#@+node:ekr.20040323194538:(Speeded up Contract All command)
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self):

	c = self
	
	c.beginUpdate()
	if 1: # update...
		for p in c.allNodes_iter():
			p.contract()
		# Select the topmost ancestor of the presently selected node.
		p = c.currentPosition()
		while p and p.hasParent():
			p.moveToParent()
		c.selectVnode(p)
	c.endUpdate()

	c.expansionLevel = 1 # Reset expansion level.
#@nonl
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20031218072017.2910:contractSubtree
def contractSubtree (self,p):

	for p in p.subtree_iter():
		p.contract()
#@nonl
#@-node:ekr.20031218072017.2910:contractSubtree
#@-node:ekr.20040323194538:(Speeded up Contract All command)
#@-node:ekr.20040325203859.3:3/24
#@+node:ekr.20040325203859.4:3/25
#@+node:ekr.20040325104344:(Optimized drawing and saving recursions)
#@+node:ekr.20031218072017.4144:Drawing (tkTree)
#@+node:ekr.20031218072017.4145:About drawing and updating
@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(false) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
#@-node:ekr.20031218072017.4145:About drawing and updating
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):

	y += 7 # draw the box at x, y+7
	h = self.line_height

	tree = self
	iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y+self.lineyoffset,image=image)
	
	if 1: # New in 4.2.  Create a frame to catch all clicks.
		id4 = self.canvas.create_rectangle(0,y-7,1000,y-7+h-3)
		color = ""
		self.canvas.itemconfig(id4,fill=color,outline=color)
		self.canvas.lower(id4)
		id3 = self.canvas.tag_bind(id4, "<1>", p.OnBoxClick)
		self.tagBindings.append((id,id3,"<1>"),)

	id1 = self.canvas.tag_bind(id, "<1>", p.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
	
	"""Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

	tree = self
	
	# Make sure the bindings refer to the _present_ position.
	v = p.v

	if x is None and y is None:
		try:
			x,y = v.iconx, v.icony
		except:
			# Inject the ivars.
			x,y = v.iconx, v.icony = 0,0
	else:
		# Inject the ivars.
		v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute v.iconVal.
	# This is an important drawing optimization.
	val = v.iconVal = v.computeIcon()
	assert(0 <= val <= 15)

	# Get the image.
	imagename = "box%02d.GIF" % val
	image = self.getIconImage(imagename)
	id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image)
	self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.

	id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
	id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
	id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
	self.tagBindings.append((id,id3,"<3>"),)

	return 0,icon_width # dummy icon height,width
#@nonl
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

	"""Draw horizontal line from vertical line to icon"""
	
	if 1:
		self.lineyoffset = 0
	else:
		if hasattr(p.v.t,"unknownAttributes"):
			self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
		else:
			self.lineyoffset = 0
		
	self.canvas.create_line(x,y+7+self.lineyoffset,
		x+box_width,y+7+self.lineyoffset,
		tag="lines",fill="gray50") # stipple="gray25")

	if self.inVisibleArea(y):
		return self.force_draw_node(p,x,y)
	else:
		return self.line_height,0
#@nonl
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

	self.allocatedNodes += 1
	h,w = self.drawUserIcons(p,"beforeBox",x,y)
	xw = w # The extra indentation before the icon box.
	if p.hasChildren():
		self.drawBox(p,x+w,y)
	w += box_width # even if box isn't drawn.

	h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
	h = max(h,h2) ; w += w2 ; xw += w2

	h2,w2 = self.drawIcon(p,x+w,y)
	h = max(h,h2) ; w += w2

	h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
	h = max(h,h2) ; w += w2

	h2 = self.drawText(p,x+w,y)
	h = max(h,h2)
	w += self.widthInPixels(p.headString())

	h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
	h = max(h,h2)

	return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040318090335:force_draw_node (old)
def force_draw_nodeOLD(self,p,x,y):

	self.allocatedNodes += 1

	if p.hasChildren():
		self.drawBox(p,x,y)
	w = box_width # Even if the box isn't drawn.

	h2,w2 = self.drawIcon(p,x+w,y)
	w += w2

	h = self.drawText(p,x+w,y)
	
	return h,0
#@-node:ekr.20040318090335:force_draw_node (old)
#@-node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.2029:drawTopTree
def drawTopTree (self):
	
	"""Draws the top-level tree, taking into account the hoist state."""
	
	c = self.c
	
	if c.hoistStack:
		p,junk = c.hoistStack[-1]
		self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=true)
	else:
		self.drawTree(c.rootPosition(),root_left,root_top,0,0)
		
	# g.trace(g.app.copies) ; g.app.copies = 0
	# import traceback ; traceback.print_stack()
#@nonl
#@-node:ekr.20031218072017.2029:drawTopTree
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20040317095510:drawUserIcon
def drawUserIcon (self,where,x,y,dict):
	
	h,w = 0,0

	if where != dict.get("where","beforeHeadline"):
		return h,w
		
	# g.trace(where,x,y,dict)
	
	<< set offsets and pads >>
	type = dict.get("type")
	if type == "icon":
		s = dict.get("icon")
		<< draw the icon in string s >>
	elif type == "file":
		file = dict.get("file")
		<< draw the icon at file >>
	elif type == "url":
		url = dict.get("url")
		<< draw the icon at url >>
		
	# Allow user to specify height, width explicitly.
	h = dict.get("height",h)
	w = dict.get("width",w)

	return h,w
#@nonl
#@+node:ekr.20040317173849:<< set offsets and pads >>
xoffset = dict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = dict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = dict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = dict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040317173849:<< set offsets and pads >>
#@+node:ekr.20040317095153:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040317095153:<< draw the icon in string s >>
#@+node:ekr.20040317095153.1:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040317095153.1:<< draw the icon at url >>
#@+node:ekr.20040317100702:<< draw the icon at file >>
try:
	image = self.iconimages[file]
	# Get the image from the cache if possible.
except KeyError:
	try:
		fullname = g.os_path_join(g.app.loadDir,"..","Icons",file)
		fullname = g.os_path_normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas,file=fullname)
		self.iconimages[fullname] = image
	except:
		#g.es("Exception loading: " + fullname)
		#g.es_exception()
		image = None
		
if image:
	id = self.canvas.create_image(x+xoffset,y+yoffset,anchor="nw",image=image)
	self.canvas.lift(id)
	h = image.height() + yoffset + ypad
	w = image.width()  + xoffset + xpad
#@nonl
#@-node:ekr.20040317100702:<< draw the icon at file >>
#@-node:ekr.20040317095510:drawUserIcon
#@+node:ekr.20040317094609:drawUserIcons
def drawUserIcons(self,p,where,x,y):
	
	"""Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
	
	h,w = 0,0 ; t = p.v.t
	
	if not hasattr(t,"unknownAttributes"):
		return h,w
	
	iconsList = t.unknownAttributes.get("icons")
	# g.trace(iconsList)
	
	try:
		for dict in iconsList:
			h2,w2 = self.drawUserIcon(where,x+w,y,dict)
			h = max(h,h2) ; w += w2
	except:
		g.es_exception()

	return h,w
#@nonl
#@-node:ekr.20040317094609:drawUserIcons
#@+node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
	
	if self.allocateOnlyVisibleNodes:
		if self.visibleArea:
			vis1,vis2 = self.visibleArea
			y2 = y1 + self.line_height
			return y2 >= vis1 and y1 <= vis2
		else: return false
	else:
		return true # This forces all nodes to be allocated on all redraws.
		
def inExpandedVisibleArea (self,y1):
	
	if self.expandedVisibleArea:
		vis1,vis2 = self.expandedVisibleArea
		y2 = y1 + self.line_height
		return y2 >= vis1 and y1 <= vis2
	else:
		return false
#@nonl
#@-node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20031218072017.4147:tree.getIconImage
def getIconImage (self, name):

	# Return the image from the cache if possible.
	if self.iconimages.has_key(name):
		return self.iconimages[name]
		
	try:
		fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
		fullname = g.os_path_normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
		self.iconimages[name] = image
		return image
	except:
		g.es("Exception loading: " + fullname)
		g.es_exception()
		return None
#@nonl
#@-node:ekr.20031218072017.4147:tree.getIconImage
#@+node:ekr.20040322122232:tree.scrollTo
def scrollTo (self,p):
	
	def scrollToCallback(event=None,self=self,p=p):
		g.trace(event,self,p)
		self.idle_scrollTo(p)
	
	self.canvas.after_idle(scrollToCallback)
#@nonl
#@-node:ekr.20040322122232:tree.scrollTo
#@+node:ekr.20031218072017.1018:tree.idle_scrollTo
def idle_scrollTo(self,p=None):

	"""Scrolls the canvas so that v is in view.
	
	This is done at idle time after a redraw so that treeBar.get() will return proper values."""

	c = self.c ; frame = c.frame
	if not p: p = self.c.currentPosition()
	if not p: p = self.c.rootPosition() # 4/8/04.
	try:
		last = p.lastVisible()
		nextToLast = last.visBack()
		h1 = self.yoffset(p)
		h2 = self.yoffset(last)
		<< compute approximate line height >>
		<< Compute the fractions to scroll down/up >>
		if frac <= lo:
			if self.prevMoveToFrac != frac:
				self.prevMoveToFrac = frac
				self.canvas.yview("moveto",frac)
		elif frac2 + (hi - lo) >= hi:
			if self.prevMoveToFrac != frac2:
				self.prevMoveToFrac = frac2
				self.canvas.yview("moveto",frac2)

		if self.allocateOnlyVisibleNodes:
			self.canvas.after_idle(self.idle_second_redraw)
			
		c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
		# print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
	except:
		g.es_exception()
#@nonl
#@+node:ekr.20040314092716:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
	lineHeight = h2 - self.yoffset(nextToLast)
else:
	lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040314092716:<< compute approximate line height >>
#@+node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
	frac = float(h1)/float(h2) # For scrolling down.
	frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
	frac2 = frac2 - (hi - lo)
else:
	frac = frac2 = 0.0 # probably any value would work here.
	
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20031218072017.1018:tree.idle_scrollTo
#@+node:ekr.20031218072017.4148:tree.numberOfVisibleNodes
def numberOfVisibleNodes(self):
	
	n = 0 ; p = self.c.rootPosition()
	while p:
		n += 1
		p.moveToVisNext()
	return n
#@nonl
#@-node:ekr.20031218072017.4148:tree.numberOfVisibleNodes
#@+node:ekr.20031218072017.4149:tree.yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

	# if not v1.isVisible(): print "yoffset not visible:",v1
	root = self.c.rootPosition()
	h, flag = self.yoffsetTree(root,v1)
	# flag can be false during initialization.
	# if not flag: print "yoffset fails:",h,v1
	return h

# Returns the visible height of the tree and all sibling trees, stopping at p1

def yoffsetTree(self,p,p1):

	h = 0
	for p in p.siblings_iter():
		# print "yoffsetTree:", p
		if p == p1:
			return h, true
		h += self.line_height
		if p.isExpanded() and p.hasChildren():
			child = p.firstChild()
			h2, flag = self.yoffsetTree(child,p1)
			h += h2
			if flag: return h, true
	
	return h, false
#@nonl
#@-node:ekr.20031218072017.4149:tree.yoffset
#@-node:ekr.20031218072017.4144:Drawing (tkTree)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20040325104344:(Optimized drawing and saving recursions)
#@+node:ekr.20040325111920:(Drastically reduced positions created by Read Outline Only)
#@+node:ekr.20040325115038:Notes
@nocolor

The problem was setMarked.  This calls:
	
g.doHook("set-mark",c=self.c,v=self)

I'm not sure why this generated go many positions, but it did.
#@nonl
#@-node:ekr.20040325115038:Notes
#@+node:ekr.20031218072017.3398:setMarked & initMarkedBit
def setMarked (self):

	self.statusBits |= self.markedBit
	g.doHook("set-mark",c=self.c,v=self)

def initMarkedBit (self):

	self.statusBits |= self.markedBit
#@-node:ekr.20031218072017.3398:setMarked & initMarkedBit
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self):

	c = self.c

	if self.getOpenTag("<vnodes>"):
		return
		
	if self.usingClipboard:
		oldRoot = c.rootPosition()
		oldCurrent = c.currentPosition()

	back = parent = None # This routine _must_ work on vnodes!
	
	self.currentVnodeStack = []
	self.topVnodeStack = []
	while self.matchTag("<v"):
		append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
		append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip=false,
			appendToCurrentStack=append1,appendToTopStack=append2)

	if self.usingClipboard:
		# Link in the pasted nodes after the current position.
		newRoot = c.rootPosition()
		c.setRootPosition(oldRoot)
		newRoot.v.linkAfter(oldCurrent.v)
		newCurrent = oldCurrent.copy()
		newCurrent.v = newRoot.v
		c.setCurrentPosition(newCurrent)
	else:
		<< set current and top positions >>

	self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
	c.setCurrentPosition(current)
else:
	# g.trace(self.currentVnodeStack)
	c.setCurrentPosition(c.rootPosition())
	
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
	c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1860:createVnode (changed for 4.2)
def createVnode (self,parent,back,tref,headline,attrDict):
	
	# g.trace(parent,headline)
	v = None ; c = self.c
	# Shared tnodes are placed in the file even if empty.
	if tref == -1:
		t = leoNodes.tnode()
	else:
		tref = self.canonicalTnodeIndex(tref)
		t = self.tnodesDict.get(tref)
		if not t: t = self.newTnode(tref)
	if back: # create v after back.
		v = back.insertAfter(t)
	elif parent: # create v as the parent's first child.
		v = parent.insertAsNthChild(0,t)
	else: # create a root vnode
		v = leoNodes.vnode(c,t)
		v.moveToRoot()

	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v) # New in 4.2.

	skip = len(v.t.vnodeList) > 1

	v.initHeadString(headline,encoding=self.leo_file_encoding)
	<< handle unknown vnode attributes >>
	return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
	v.unknownAttributes = attrDict

	if 0: # For debugging.
		s = "unknown attributes for " + v.headString()
		print s ; g.es(s,color="blue")
		for key in keys:
			s = "%s = %s" % (key,attrDict.get(key))
			print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode (changed for 4.2)
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

	c = self.c ; v = None
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
	# we have already matched <v.
	while 1:
		if self.matchTag("a=\""):
			<< Handle vnode attribute bits >>
		elif self.matchTag("t="):
			# New for 4.1.  Read either "Tnnn" or "gnx".
			tref = self.getDqString()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList="):
			s = self.getDqString()
			tnodeList = self.getTnodeList(s) # New for 4.0
		elif self.matchTag(">"):
			break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val
	# Headlines are optional.
	if self.matchTag("<vh>"):
		headline = self.getEscapedString() ; self.getTag("</vh>")
	
	# g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
	if skip:
		v = self.getExistingVnode(tref)
	else:
		v,skip = self.createVnode(parent,back,tref,headline,attrDict)
		if tnodeList:
			v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
			# g.trace("%4d" % len(tnodeList),v)

	<< Set the remembered status bits >>

	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("<v"):
		append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
		append2 = appendToTopStack and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip,
			appendToCurrentStack=append1,appendToTopStack=append2)
			
	<< Append to current or top stack >>

	# End this vnode.
	self.getTag("</v>")
	return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
	self.currentVnodeStack = [v]

if setTop:
	self.topVnodeStack = [v]
	
if setExpanded:
	v.initExpandedBit()
	
if setMarked:
	v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
	v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
	#g.trace("append current",v)
	self.currentVnodeStack.append(v)
	
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
	#g.trace("append top",v)
	self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@-node:ekr.20040325111920:(Drastically reduced positions created by Read Outline Only)
#@+node:ekr.20040324080004:(Improved speed of Save command)
#@+node:ekr.20040324085927:Notes
@nocolor

Most of the time is spent in putVnode.  It's taking 4 times as long to put the vnodes as the tnodes!

It's time to clean up isAnyAtFileNode, but I doubt this is a significant factor.

I changed p.x() to p.v.x() to reduce several function calls.
	- Hard to believe this could make a difference: it didn't.

** Amazingly, the code that puts the attribute bits is the bottleneck!!

The following tests are the bottleneck (!!!)

if p == self.topPosition:     attr += "T"
if p == self.currentPosition: attr += "V"

The call to p.childIndex was the bottleneck.  I did the following:

- Put the check against childIndex last.
- At leaset doubled the speed of p.childIndex.

** But the calls to p.__cmp__ are still too slow!!!
	- Would an explicit call to an p.equal routine work?
		- Yes !!!!! There is a huge performance bug in p.__cmp__ !!!!!!

#@-node:ekr.20040324085927:Notes
#@+node:ekr.20031218072017.3137:Timing
# pychecker bug: pychecker complains that there is no attribute time.clock

def getTime():
	return time.clock()
	
def esDiffTime(message, start):
	g.es("%s %6.3f" % (message,(time.clock()-start)))
	return time.clock()
	
def printDiffTime(message, start):
	print "%s %6.3f" % (message,(time.clock()-start))
	return time.clock()
#@nonl
#@-node:ekr.20031218072017.3137:Timing
#@+node:ekr.20031218072017.893:p.__cmp__
def __cmp__(self,p2):

	"""Return 0 if two postions are equivalent."""

	# Use p.equal if speed is crucial.
	p1 = self

	if p2 is None: # Allow tests like "p == None"
		if p1.v: return 1 # not equal
		else:    return 0 # equal

	# Check entire stack quickly.
	# The stack contains vnodes, so this is not a recursive call.
	if p1.v != p2.v or p1.stack != p2.stack:
		return 1 # notEqual

	# This is slow: do this last!
	if p1.childIndex() != p2.childIndex():
		# Disambiguate clones having the same parents.
		return 1 # notEqual

	return 0 # equal
#@nonl
#@-node:ekr.20031218072017.893:p.__cmp__
#@+node:ekr.20040325142015:p.equal
def equal(self,p2):

	"""Return true if two postions are equivalent.
	
	Use this method when the speed comparisons is crucial
	
	N.B. Unlike __cmp__, p2 must not be None."""

	p1 = self
	
	# if g.app.trace: "equal",p1.v,p2.v

	# Check entire stack quickly.
	# The stack contains vnodes, so this does not call p.__cmp__.
	return (
		p1.v == p2.v and
		p1.stack == p2.stack and
		p1.childIndex() == p2.childIndex())
#@nonl
#@-node:ekr.20040325142015:p.equal
#@+node:ekr.20031218072017.1765:c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self):

	c = self
	
	if not g.app.debug:
		return true

	root = c.rootPosition()
	parent = c.nullPosition()

	if root:
		return root.validateOutlineWithParent(parent)
	else:
		return true
#@nonl
#@-node:ekr.20031218072017.1765:c.validateOutline
#@+node:ekr.20040303175026.13:p.validateOutlineWithParent
# This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
	
	p = self
	result = true # optimists get only unpleasant surprises.
	parent = p.getParent()
	childIndex = p.childIndex()
	
	# g.trace(p,parent,pv)
	<< validate parent ivar >>
	<< validate childIndex ivar >>
	<< validate x ivar >>

	# Recursively validate all the children.
	for child in p.children_iter():
		r = child.validateOutlineWithParent(p)
		if not r: result = false

	return result
#@nonl
#@+node:ekr.20040303175026.14:<< validate parent ivar >>
if parent != pv:
	p.invalidOutline( "Invalid parent link: " + repr(parent))
#@nonl
#@-node:ekr.20040303175026.14:<< validate parent ivar >>
#@+node:ekr.20040303175026.15:<< validate childIndex ivar >>
if pv:
	if childIndex < 0:
		p.invalidOutline ( "missing childIndex" + childIndex )
	elif childIndex >= pv.numberOfChildren():
		p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex < 0:
	p.invalidOutline ( "negative childIndex" + childIndex )
#@nonl
#@-node:ekr.20040303175026.15:<< validate childIndex ivar >>
#@+node:ekr.20040303175026.16:<< validate x ivar >>
if not p.v.t and pv:
	self.invalidOutline ( "Empty t" )
#@nonl
#@-node:ekr.20040303175026.16:<< validate x ivar >>
#@-node:ekr.20040303175026.13:p.validateOutlineWithParent
#@+node:ekr.20040303212445:v.childIndex
def childIndex(self):
	
	v = self

	if not v._back:
		return 0

	n = 0 ; v = v._back
	while v:
		n += 1
		v = v._back
	return n
#@nonl
#@-node:ekr.20040303212445:v.childIndex
#@+node:ekr.20031218072017.2985:c.clearAllVisited
def clearAllVisited (self):

	c = self

	for p in c.allNodes_iter():
		p.v.clearVisited()
		p.v.t.clearVisited()
		p.v.t.clearWriteBit()
#@-node:ekr.20031218072017.2985:c.clearAllVisited
#@+node:ekr.20031218072017.3401:t.setVisited
# Compatibility routine for scripts

def setVisited (self):

	self.statusBits |= self.visitedBit
#@nonl
#@-node:ekr.20031218072017.3401:t.setVisited
#@+node:ekr.20031218072017.1999:toString
def toString (self,index,removeDefaultId=false):
	
	"""Convert a gnx (a tuple) to its string representation"""

	id,t,n = index

	if removeDefaultId and id == self.defaultId:
		id = ""

	if not n: # None or ""
		return "%s.%s" % (id,t)
	else:
		return "%s.%s.%d" % (id,t,n)
#@nonl
#@-node:ekr.20031218072017.1999:toString
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

	c = self.c ; config = g.app.config

	self.assignFileIndices()
	if not outlineOnlyFlag:
		<< write all @file nodes >>
	<< return if the .leo file is read-only >>
	try:
		<< create backup file >>
		self.mFileName = fileName
		<< create the output file >>
		<< update leoConfig.txt >>
		<< put the .leo file >>
	except:
		<< report the exception >>
		<< erase filename and rename backupName to fileName >>
		return false
	if self.outputFile:
		<< close the output file >>
		<< delete backup file >>
		return true
	else: # This probably will never happen because errors should raise exceptions.
		<< erase filename and rename backupName to fileName >>
		return false
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
	# Write all @file nodes and set orphan bits.
	c.atFileCommands.writeAll()
except:
	g.es_error("exception writing derived files")
	g.es_exception()
	return false
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
	try:
		if not os.access(fileName,os.W_OK):
			self.writeError("can not create: read only: " + self.targetFileName)
			return false
	except:
		pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
	try:
		backupName = g.os_path_join(g.app.loadDir,fileName)
		backupName = fileName + ".bak"
		if g.os_path_exists(backupName):
			os.unlink(backupName)
		# os.rename(fileName,backupName)
		g.utils_rename(fileName,backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception creating backup file: " + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception creating backup file: " + backupName)
		g.es_exception()
		backupName = None
		return false
else:
	backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080359.2:<< create the output file >>
self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
	g.es("can not open " + fileName)
	<< delete backup file >>
	return false
#@nonl
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
	try:
		os.unlink(backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting backup file:" + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception deleting backup file:" + backupName)
		g.es_exception()
		return false
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20040324080359.2:<< create the output file >>
#@+node:ekr.20040324080819:<< update leoConfig.txt >>
c.setIvarsFromFind()
config.setConfigFindIvars(c)
c.setIvarsFromPrefs()
config.setCommandsIvars(c)
config.update()
#@nonl
#@-node:ekr.20040324080819:<< update leoConfig.txt >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20040324080819.2:<< report the exception >>
g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
	try:
		self.outputFile.close()
		self.outputFile = None
	except:
		g.es("exception closing: " + fileName)
		g.es_exception()
#@nonl
#@-node:ekr.20040324080819.2:<< report the exception >>
#@+node:ekr.20040324080819.3:<< close the output file >>
try:
	self.outputFile.close()
	self.outputFile = None
except:
	g.es("exception closing: " + fileName)
	g.es_exception()
#@nonl
#@-node:ekr.20040324080819.3:<< close the output file >>
#@+node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
	try:
		os.unlink(fileName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting: " + fileName)
			g.es_exception()
	except:
		g.es("exception deleting: " + fileName)
		g.es_exception()
		
if backupName:
	g.es("restoring " + fileName + " from " + backupName)
	try:
		g.utils_rename(backupName, fileName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception renaming " + backupName + " to " + fileName)
			g.es_exception()
	except:
		g.es("exception renaming " + backupName + " to " + fileName)
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
	try:
		os.unlink(backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting backup file:" + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception deleting backup file:" + backupName)
		g.es_exception()
		return false
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
def putTnodeList (self,v):
	
	"""Put the tnodeList attribute of a tnode."""
	
	# g.trace(v)
	
	# Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

	fc = self ; nodeIndices = g.app.nodeIndices
	tnodeList = v.t.tnodeList
	if tnodeList:
		# g.trace("%4d" % len(tnodeList),v)
		fc.put(" tnodeList=") ; fc.put_dquote()
		if g.app.use_gnx:
			for t in tnodeList:
				try: # Will fail for None or any pre 4.1 file index.
					id,time,n = t.fileIndex
				except:
					g.trace("assigning gnx for ",v,t)
					gnx = nodeIndices.getNewIndex()
					v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
			s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
		else:
			s = ','.join([str(t.fileIndex) for t in tnodeList])
		fc.put(s) ; fc.put_dquote()
#@nonl
#@-node:ekr.20031218072017.2002:putTnodeList (4.0,4.2)
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

	"""Puts all <v> elements in the order in which they appear in the outline."""

	c = self.c
	c.clearAllVisited()

	self.put("<vnodes>") ; self.put_nl()

	# Make only one copy for all calls.
	self.currentPosition = c.currentPosition() 
	self.topPosition     = c.topPosition()

	if self.usingClipboard:
		self.putVnode(self.currentPosition) # Write only current tree.
	else:
		for p in c.rootPosition().self_and_siblings_iter():
			self.putVnode(p) # Write the next top-level node.

	self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20040324080004:(Improved speed of Save command)
#@+node:ekr.20040323084434.1:(reduced calls to drawTopTree)
#@+node:ekr.20040323191536:Notes
@nocolor

The call to idle_redraw happens as the result of the call to update_idletasks in tkLog.put.

To fix this I added the disableRedraw lockout ivar to the tk tree class.

This prevents the outline from being redrawn initially, so I added a call to redraw in the fileCommands read code.

endEditLabel calls force_redraw:
	- I changed this so that force_redraw gets called only if there was really some editing going on.

The call to update_idledraw in get_window_info is harder to disable: it is a dialog util.
#@nonl
#@-node:ekr.20040323191536:Notes
#@+node:ekr.20031218072017.1017:tree.__init__
def __init__(self,c,frame,canvas):
	
	# Init the base class.
	leoFrame.leoTree.__init__(self,frame)

	# Objects associated with this tree.
	self.canvas = canvas

	# Miscellaneous info.
	self.iconimages = {} # Image cache set by getIconImage().
	self.active = false # true if tree is active
	self._editPosition = None
	self.lineyoffset = 0 # y offset for this headline.
	self.disableRedraw = false # True: reschedule a redraw for later.
	
	# Set self.font and self.fontName.
	self.setFontFromConfig()
	
	# Recycling bindings.
	self.bindings = [] # List of bindings to be unbound when redrawing.
	self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
	self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
	self.widgets = [] # Widgets that must be destroyed when redrawing.
	
	# Drag and drop
	self.drag_p = None
	self.controlDrag = false # true: control was down when drag started.
	self.drag_id = None # To reset bindings after drag
	
	# 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
	#                     behavior better on Linux
	# Context menu
	self.popupMenu = None
	
	# Incremental redraws:
	self.allocateOnlyVisibleNodes = false # true: enable incremental redraws.
	self.trace = false # true enabling of various traces.
	self.prevMoveToFrac = None
	self.visibleArea = None
	self.expandedVisibleArea = None
	
	self.allocatedNodes = 0 # A crucial statistic.
		# Incremental drawing allocates visible nodes at most twice.
		# Non-incremetal drawing allocates all visible nodes once.
		
	if self.allocateOnlyVisibleNodes:
		self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw)
	
	if not leoTkinterTree.callbacksInjected: # Class var.
		leoTkinterTree.callbacksInjected = true
		self.injectCallbacks()
#@nonl
#@-node:ekr.20031218072017.1017:tree.__init__
#@+node:ekr.20031218072017.4061:get_window_info
# WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
	
	top.update_idletasks() # Required to get proper info.

	# Get the information about top and the screen.
	geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
	dim,x,y = string.split(geom,'+')
	w,h = string.split(dim,'x')
	w,h,x,y = int(w),int(h),int(x),int(y)
	
	return w,h,x,y
#@nonl
#@-node:ekr.20031218072017.4061:get_window_info
#@+node:ekr.20031218072017.2029:drawTopTree
def drawTopTree (self):
	
	"""Draws the top-level tree, taking into account the hoist state."""
	
	c = self.c
	
	if c.hoistStack:
		p,junk = c.hoistStack[-1]
		self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=true)
	else:
		self.drawTree(c.rootPosition(),root_left,root_top,0,0)
		
	# g.trace(g.app.copies) ; g.app.copies = 0
	# import traceback ; traceback.print_stack()
#@nonl
#@-node:ekr.20031218072017.2029:drawTopTree
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=true):

	c = self.c
	c.setChanged(false) # 10/1/03: May be set when reading @file nodes.
	<< warn on read-only files >>
	self.mFileName = c.mFileName
	self.tnodesDict = {}
	ok = true
	c.loading = true # disable c.changed
	
	try:
		<< scan all the xml elements >>
	except BadLeoFile, message:
		<< raise an alert >>
		ok = false

	c.frame.tree.redraw_now(scroll=false)
	
	if ok and atFileNodesFlag:
		c.atFileCommands.readAll(c.rootVnode(),partialFlag=false)

	if not c.currentPosition():
		c.setCurrentPosition(c.rootPosition())

	c.selectVnode(c.currentPosition()) # load body pane
	c.loading = false # reenable c.changed
	c.setChanged(c.changed) # Refresh the changed marker.
	self.tnodesDict = {}
	return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
try:
	self.read_only = false
	self.read_only = not os.access(fileName,os.W_OK)
	if self.read_only:
		g.es("read only: " + fileName,color="red")
except:
	if 0: # testing only: access may not exist on all platforms.
		g.es("exception getting file access")
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()
self.getTag("<leo_file>")
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
	
	if g.app.quitting: return
	elif self.logCtrl:
		<< put s to log control >>
	else:
		<< put s to logWaiting and print s >>

def putnl (self):
	if g.app.quitting: return
	elif self.logCtrl:
		<< put newline to log control >>
	else:
		<< put newline to logWaiting and print newline >>
		
def forceLogUpdate (self):
	if sys.platform != "darwin": # Does not work on darwin.
		self.frame.tree.disableRedraw = true
		self.logCtrl.update_idletasks()
		#self.frame.outerFrame.update_idletasks() # 4/23/04
		#self.frame.top.update_idletasks()
		self.frame.tree.disableRedraw = false
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if type(s) == type(u""): # 3/18/03
	s = g.toEncodedString(s,g.app.tkEncoding)
	
if sys.platform == "darwin":
	print s,

if color:
	if color not in self.colorTags:
		self.colorTags.append(color)
		self.logCtrl.tag_config(color,foreground=color)
	self.logCtrl.insert("end",s)
	self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
	if "black" not in self.colorTags:
		self.colorTags.append("black")
		self.logCtrl.tag_config("black",foreground="black")
	self.logCtrl.tag_add("black","end")
else:
	self.logCtrl.insert("end",s)

self.logCtrl.see("end")
	
self.forceLogUpdate()
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"
if type(s) == type(u""): # 3/18/03
	s = g.toEncodedString(s,"ascii")
print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
if sys.platform == "darwin":
	print
	
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")

self.frame.tree.disableRedraw = true
self.logCtrl.update_idletasks()
#self.frame.outerFrame.update_idletasks() # 4/23/04
#self.frame.top.update_idletasks()
self.frame.tree.disableRedraw = false
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@+node:ekr.20031218072017.4160:endEditLabel
def endEditLabel (self):
	
	"""End editing for self.editText."""

	c = self.c ; gui = g.app.gui
	
	p = self.editPosition()

	if p and p.edit_text():
		self.setUnselectedLabelState(p)
		self.setEditPosition(None)

		# force a redraw of joined and ancestor headlines.
		self.force_redraw() 

	gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02
#@nonl
#@-node:ekr.20031218072017.4160:endEditLabel
#@+node:ekr.20031218072017.1011:Updating routines (tree)...
#@+node:ekr.20031218072017.1012:tree.redraw
# Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
	
	# g.trace(self.updateCount,self.redrawScheduled)
	
	if self.updateCount == 0 and not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
#@nonl
#@-node:ekr.20031218072017.1012:tree.redraw
#@+node:ekr.20040106095546:tkTree.redrawAfterException
@ This is called only from doCommand.  The implicit assumption is that doCommand itself is not contained in a beginUpdate/endUpdate pair.
@c

def redrawAfterException (self):
	
	"""Make sure drawing is enabled following an exception."""
		
	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
		self.updateCount = 0 # would not work if we are in a beginUpdate/endUpdate pair.
#@nonl
#@-node:ekr.20040106095546:tkTree.redrawAfterException
#@+node:ekr.20031218072017.1013:force_redraw
# Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
	
	# g.trace(self.redrawScheduled)
	# import traceback ; traceback.print_stack()

	if not self.redrawScheduled:
		self.redrawScheduled = true
		self.canvas.after_idle(self.idle_redraw)
#@nonl
#@-node:ekr.20031218072017.1013:force_redraw
#@+node:ekr.20031218072017.1014:redraw_now
# Redraws immediately: used by Find so a redraw doesn't mess up selections.
# It is up to the caller to ensure that no other redraws are pending.

def redraw_now (self,scroll=true):
	
	# g.trace()

	self.idle_redraw(scroll=scroll)
#@-node:ekr.20031218072017.1014:redraw_now
#@+node:ekr.20031218072017.1015:idle_redraw
def idle_redraw (self,scroll=true):
	
	c = self.c ; frame = c.frame

	self.redrawScheduled = false # Always do this here.

	<< return if disabled, or quitting or dragging >>

	# g.print_bindings("canvas",self.canvas)

	self.expandAllAncestors(c.currentPosition())

	oldcursor = self.canvas['cursor']
	self.canvas['cursor'] = "watch"

	if not g.doHook("redraw-entire-outline",c=self.c):
		self.allocatedNodes = 0
		<< Erase and redraw the entire tree >>
		if self.trace:
			self.redrawCount += 1
			print "idle_redraw allocated:",self.redrawCount,self.allocatedNodes
	g.doHook("after-redraw-outline",c=self.c)

	self.canvas['cursor'] = oldcursor
#@+node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
if self.disableRedraw:
	# We have been called as the result of an update_idletasks in the log pane.
	# Don't do anything now.
	return

if frame not in g.app.windowList or g.app.quitting:
	# g.trace("no frame")
	return

if self.drag_p:
	# g.trace("dragging",self.drag_p)
	return
#@-node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
#@+node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
# Delete all widgets.
c.setTopVnode(None)
self.deleteBindings()
self.canvas.delete("all")
self.deleteWidgets()

# Redraw the tree.
self.setVisibleAreaToFullCanvas()
self.drawTopTree()

# Set up the scroll region after the tree has been redrawn.
x0, y0, x1, y1 = self.canvas.bbox("all")
self.canvas.configure(scrollregion=(0, 0, x1, y1))

# g.printGc()

# Do a scrolling operation after the scrollbar is redrawn
if scroll:
	self.canvas.after_idle(self.idle_scrollTo)
#@nonl
#@-node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
#@-node:ekr.20031218072017.1015:idle_redraw
#@+node:ekr.20031218072017.1016:idle_second_redraw
def idle_second_redraw (self):
	
	c = self.c
	
	g.trace()
		
	# Erase and redraw the entire tree the SECOND time.
	# This ensures that all visible nodes are allocated.
	c.setTopVnode(None)
	args = self.canvas.yview()
	self.setVisibleArea(args)
	self.deleteBindings()
	self.canvas.delete("all")
	self.drawTopTree()
	
	if self.trace:
		print "idle_second_redraw allocated:",self.redrawCount, self.allocatedNodes
#@nonl
#@-node:ekr.20031218072017.1016:idle_second_redraw
#@-node:ekr.20031218072017.1011:Updating routines (tree)...
#@-node:ekr.20040323084434.1:(reduced calls to drawTopTree)
#@+node:ekr.20040325125426:(Fixed problem with first screen draw)
#@+node:ekr.20040325203859.5:Notes
@nocolor

The first screen draw got messed up if there was a scrollling operation.
This happened as the result of the call to idle_scrollTo.
To fix this, I added the scroll arg to redraw_now and idle_redraw.
#@nonl
#@-node:ekr.20040325203859.5:Notes
#@+node:ekr.20031218072017.1015:idle_redraw
def idle_redraw (self,scroll=true):
	
	c = self.c ; frame = c.frame

	self.redrawScheduled = false # Always do this here.

	<< return if disabled, or quitting or dragging >>

	# g.print_bindings("canvas",self.canvas)

	self.expandAllAncestors(c.currentPosition())

	oldcursor = self.canvas['cursor']
	self.canvas['cursor'] = "watch"

	if not g.doHook("redraw-entire-outline",c=self.c):
		self.allocatedNodes = 0
		<< Erase and redraw the entire tree >>
		if self.trace:
			self.redrawCount += 1
			print "idle_redraw allocated:",self.redrawCount,self.allocatedNodes
	g.doHook("after-redraw-outline",c=self.c)

	self.canvas['cursor'] = oldcursor
#@+node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
if self.disableRedraw:
	# We have been called as the result of an update_idletasks in the log pane.
	# Don't do anything now.
	return

if frame not in g.app.windowList or g.app.quitting:
	# g.trace("no frame")
	return

if self.drag_p:
	# g.trace("dragging",self.drag_p)
	return
#@-node:ekr.20040324090957:<< return if disabled, or quitting or dragging >>
#@+node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
# Delete all widgets.
c.setTopVnode(None)
self.deleteBindings()
self.canvas.delete("all")
self.deleteWidgets()

# Redraw the tree.
self.setVisibleAreaToFullCanvas()
self.drawTopTree()

# Set up the scroll region after the tree has been redrawn.
x0, y0, x1, y1 = self.canvas.bbox("all")
self.canvas.configure(scrollregion=(0, 0, x1, y1))

# g.printGc()

# Do a scrolling operation after the scrollbar is redrawn
if scroll:
	self.canvas.after_idle(self.idle_scrollTo)
#@nonl
#@-node:ekr.20040324090957.1:<< Erase and redraw the entire tree >>
#@-node:ekr.20031218072017.1015:idle_redraw
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=true):

	c = self.c
	c.setChanged(false) # 10/1/03: May be set when reading @file nodes.
	<< warn on read-only files >>
	self.mFileName = c.mFileName
	self.tnodesDict = {}
	ok = true
	c.loading = true # disable c.changed
	
	try:
		<< scan all the xml elements >>
	except BadLeoFile, message:
		<< raise an alert >>
		ok = false

	c.frame.tree.redraw_now(scroll=false)
	
	if ok and atFileNodesFlag:
		c.atFileCommands.readAll(c.rootVnode(),partialFlag=false)

	if not c.currentPosition():
		c.setCurrentPosition(c.rootPosition())

	c.selectVnode(c.currentPosition()) # load body pane
	c.loading = false # reenable c.changed
	c.setChanged(c.changed) # Refresh the changed marker.
	self.tnodesDict = {}
	return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
try:
	self.read_only = false
	self.read_only = not os.access(fileName,os.W_OK)
	if self.read_only:
		g.es("read only: " + fileName,color="red")
except:
	if 0: # testing only: access may not exist on all platforms.
		g.es("exception getting file access")
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()
self.getTag("<leo_file>")
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20040325125426:(Fixed problem with first screen draw)
#@-node:ekr.20040325203859.4:3/25
#@+node:ekr.20040326040442.1:3/26
#@+node:ekr.20040326033431:(Made sure second argument to p.__cmp__ is always a position)
#@+node:ekr.20040326035757:Notes
@nocolor

- Changed readAll so it uses c.nullPosition by default.
- Test p is None in scanDirectives.

These two changes _might_ be enough to ensure the arg to p.__cmp__ is always a position in Leo's _core_.  However, user code is a different matter!

The coding style is to use: "if p is None:" rather than "if p == None:".  However, there is no way to enforce that style, so I have left the test against None in p.__cmp__.

Use the p.equal method when speed is crucial.
#@nonl
#@-node:ekr.20040326035757:Notes
#@+node:ekr.20031218072017.893:p.__cmp__
def __cmp__(self,p2):

	"""Return 0 if two postions are equivalent."""

	# Use p.equal if speed is crucial.
	p1 = self

	if p2 is None: # Allow tests like "p == None"
		if p1.v: return 1 # not equal
		else:    return 0 # equal

	# Check entire stack quickly.
	# The stack contains vnodes, so this is not a recursive call.
	if p1.v != p2.v or p1.stack != p2.stack:
		return 1 # notEqual

	# This is slow: do this last!
	if p1.childIndex() != p2.childIndex():
		# Disambiguate clones having the same parents.
		return 1 # notEqual

	return 0 # equal
#@nonl
#@-node:ekr.20031218072017.893:p.__cmp__
#@+node:ekr.20031218072017.928:p.moveToX
@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
	after = p.copy().moveToNodeAfterTree()
#@nonl
#@+node:ekr.20031218072017.930:p.moveToBack
def moveToBack (self):
	
	"""Move self to its previous sibling."""
	
	p = self

	p.v = p.v and p.v._back
	
	return p
#@nonl
#@-node:ekr.20031218072017.930:p.moveToBack
#@+node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
def moveToFirstChild (self):

	"""Move a position to it's first child's position."""
	
	p = self

	if p:
		child = p.v.t._firstChild
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
		
	return p

#@-node:ekr.20031218072017.931:p.moveToFirstChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
def moveToLastChild (self):
	
	"""Move a position to it's last child's position."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			child = p.v.lastChild()
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@-node:ekr.20031218072017.932:p.moveToLastChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
def moveToLastNode (self):
	
	"""Move a position to last node of its tree.
	
	N.B. Returns p if p has no children."""
	
	p = self
	
	# Huge improvement for 4.2.
	while p.hasChildren():
		p.moveToLastChild()

	return p
#@nonl
#@-node:ekr.20031218072017.933:p.moveToLastNode (Big improvement for 4.2)
#@+node:ekr.20031218072017.934:p.moveToNext
def moveToNext (self):
	
	"""Move a position to its next sibling."""
	
	p = self
	
	p.v = p.v and p.v._next
	
	return p
#@nonl
#@-node:ekr.20031218072017.934:p.moveToNext
#@+node:ekr.20031218072017.935:p.moveToNodeAfterTree
def moveToNodeAfterTree (self):
	
	"""Move a position to the node after the position's tree."""
	
	p = self
	
	while p:
		if p.hasNext():
			p.moveToNext()
			break
		p.moveToParent()

	return p
#@-node:ekr.20031218072017.935:p.moveToNodeAfterTree
#@+node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
def moveToNthChild (self,n):
	
	p = self
	
	if p:
		child = p.v.nthChild(n) # Must call vnode method here!
		if child:
			if p.isCloned():
				p.stack.append(p.v)
				# g.trace("push",p.v,p)
			p.v = child
		else:
			p.v = None
			
	return p
#@nonl
#@-node:ekr.20031218072017.936:p.moveToNthChild (pushes stack for cloned nodes)
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self
	
	# if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

	if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
		# g.trace("pop",p.v,p)
	else:
		p.v = None

	return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20031218072017.938:p.moveToThreadBack
def moveToThreadBack (self):
	
	"""Move a position to it's threadBack position."""

	p = self

	if p.hasBack():
		p.moveToBack()
		p.moveToLastNode()
	else:
		p.moveToParent()

	return p
#@nonl
#@-node:ekr.20031218072017.938:p.moveToThreadBack
#@+node:ekr.20031218072017.939:p.moveToThreadNext
def moveToThreadNext (self):
	
	"""Move a position to the next a position in threading order."""
	
	p = self

	if p:
		if p.v.t._firstChild:
			p.moveToFirstChild()
		elif p.v._next:
			p.moveToNext()
		else:
			p.moveToParent()
			while p:
				if p.v._next:
					p.moveToNext()
					break #found
				p.moveToParent()
			# not found.
				
	return p
#@nonl
#@-node:ekr.20031218072017.939:p.moveToThreadNext
#@+node:ekr.20031218072017.940:p.moveToVisBack
def moveToVisBack (self):
	
	"""Move a position to the position of the previous visible node."""

	p = self
	
	if p:
		p.moveToThreadBack()
		while p and not p.isVisible():
			p.moveToThreadBack()

	assert(not p or p.isVisible())
	return p
#@nonl
#@-node:ekr.20031218072017.940:p.moveToVisBack
#@+node:ekr.20031218072017.941:p.moveToVisNext
def moveToVisNext (self):
	
	"""Move a position to the position of the next visible node."""

	p = self

	p.moveToThreadNext()
	while p and not p.isVisible():
		p.moveToThreadNext()
			
	return p
#@nonl
#@-node:ekr.20031218072017.941:p.moveToVisNext
#@-node:ekr.20031218072017.928:p.moveToX
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
	
	"""Scan vnode v and v's ancestors looking for directives.

	Returns a dict containing the results, including defaults."""

	if c == None or g.top() == None:
		return {} # For unit tests.
	if p is None:
		p = c.currentPosition()

	<< Set local vars >>
	old = {}
	pluginsList = [] # 5/17/03: a list of items for use by plugins.
	for p in p.self_and_parents_iter():
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< Test for @comment and @language >>
		<< Test for @encoding >>
		<< Test for @lineending >>
		<< Test for @pagewidth >>
		<< Test for @path >>
		<< Test for @tabwidth >>
		<< Test for @wrap and @nowrap >>
		g.doHook("scan-directives",c=c,v=p,s=s,
			old_dict=old,dict=dict,pluginsList=pluginsList)
		old.update(dict)

	if path == None: path = g.getBaseDirectory()

	return {
		"delims"    : (delim1,delim2,delim3),
		"encoding"  : encoding,
		"language"  : language,
		"lineending": lineending,
		"pagewidth" : page_width,
		"path"      : path,
		"tabwidth"  : tab_width,
		"pluginsList": pluginsList,
		"wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = g.scanAtEncodingDirective(s,dict)
	if e:
		encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	e = g.scanAtLineendingDirective(s,dict)
	if e:
		lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = g.scanAtPagewidthDirective(s,dict)
	if w and w > 0:
		page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute relative path from s[k:] >>
	if path and len(path) > 0:
		base = g.getBaseDirectory() # returns "" on error.
		path = g.os_path_join(base,path)
		
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = g.scanAtTabwidthDirective(s,dict)
	if w and w > 0:
		tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
	
	if dict.has_key("wrap"):
		wrap = true
	elif dict.has_key("nowrap"):
		wrap = false
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@+node:ekr.20031218072017.2626: top_df.readAll
def readAll(self,root,partialFlag=false):
	
	"""Scan vnodes, looking for @file nodes to read."""

	at = self ; c = at.c
	c.endEditing() # Capture the current headline.
	anyRead = false
	at.initIvars()
	p = root.copy()
	if partialFlag: after = p.nodeAfterTree()
	else: after = c.nullPosition()
	while p and not p.equal(after): # Don't use iterator.
		if p.isAtIgnoreNode():
			p.moveToNodeAfterTree()
		elif p.isAtThinFileNode():
			anyRead = true
			at.read(p,thinFile=true)
			p.moveToNodeAfterTree()
		elif p.isAtFileNode() or p.isAtNorefFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				at.read(p)
			else:
				# if p is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = p.isOrphan()
				ok = at.read(p)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					p.setDirty()
					c.setChanged(true)
			p.moveToNodeAfterTree()
		else: p.moveToThreadNext()
	# Clear all orphan bits.
	for p in c.allNodes_iter():
		p.v.clearOrphan()
		
	if partialFlag and not anyRead:
		g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20031218072017.2626: top_df.readAll
#@-node:ekr.20040326033431:(Made sure second argument to p.__cmp__ is always a position)
#@+node:ekr.20040324093353:(Restore current and top nodes)
#@+node:ekr.20040326061545:Notes
@nocolor

At present, setting the top position simply scrolls to that position.

However, selecting a node also does that, so there is nothing to be gained by "restoring" this bogus setting.
#@nonl
#@-node:ekr.20040326061545:Notes
#@+node:ekr.20031218072017.3019:leoFileCommands._init_
def __init__(self,c):

	# g.trace("__init__", "fileCommands.__init__")
	self.c = c
	self.frame = c.frame
	self.initIvars()

def initIvars(self):

	# General
	self.maxTnodeIndex = 0
	self.numberOfTnodes = 0
	self.topPosition = None
	self.mFileName = ""
	self.fileDate = -1
	self.leo_file_encoding = g.app.config.new_leo_file_encoding
	# For reading
	self.fileFormatNumber = 0
	self.ratio = 0.5
	self.fileBuffer = None ; self.fileIndex = 0
	self.currentVnodeStack = [] # A stack of vnodes giving the current position.
	self.topVnodeStack     = [] # A stack of vnodes giving the top position.
	# For writing
	self.read_only = false
	self.outputFile = None # File for normal writing
	self.outputList = None # List of strings for pasting
	self.openDirectory = None
	self.topVnode = None
	self.usingClipboard = false
	self.currentPosition = None
	# New in 3.12
	self.copiedTree = None
	self.tnodesDict = {}  # keys are gnx strings as returned by canonicalTnodeIndex.
#@nonl
#@-node:ekr.20031218072017.3019:leoFileCommands._init_
#@+node:ekr.20040326052245:convertStackToPosition
def convertStackToPosition (self,stack):

	c = self.c ; p2 = None
	if not stack: return None

	for p in c.allNodes_iter():
		if p.v == stack[0]:
			p2 = p.copy()
			for n in xrange(len(stack)):
				if not p2: break
				# g.trace("compare",n,p2.v,stack[n])
				if p2.v != stack[n]:
					p2 = None
				elif n + 1 == len(stack):
					break
				else:
					p2.moveToParent()
			if p2: return p

	return None
#@nonl
#@-node:ekr.20040326052245:convertStackToPosition
#@+node:ekr.20040326063413:getExistingVnode
def getExistingVnode (self,tref):

	assert(tref > -1)
	tref = self.canonicalTnodeIndex(tref)
	t = self.tnodesDict.get(tref)
	return t.vnodeList[0]
#@nonl
#@-node:ekr.20040326063413:getExistingVnode
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self):

	c = self.c

	if self.getOpenTag("<vnodes>"):
		return
		
	if self.usingClipboard:
		oldRoot = c.rootPosition()
		oldCurrent = c.currentPosition()

	back = parent = None # This routine _must_ work on vnodes!
	
	self.currentVnodeStack = []
	self.topVnodeStack = []
	while self.matchTag("<v"):
		append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
		append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip=false,
			appendToCurrentStack=append1,appendToTopStack=append2)

	if self.usingClipboard:
		# Link in the pasted nodes after the current position.
		newRoot = c.rootPosition()
		c.setRootPosition(oldRoot)
		newRoot.v.linkAfter(oldCurrent.v)
		newCurrent = oldCurrent.copy()
		newCurrent.v = newRoot.v
		c.setCurrentPosition(newCurrent)
	else:
		<< set current and top positions >>

	self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
	c.setCurrentPosition(current)
else:
	# g.trace(self.currentVnodeStack)
	c.setCurrentPosition(c.rootPosition())
	
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
	c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

	c = self.c ; v = None
	setCurrent = setExpanded = setMarked = setOrphan = setTop = false
	tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
	# we have already matched <v.
	while 1:
		if self.matchTag("a=\""):
			<< Handle vnode attribute bits >>
		elif self.matchTag("t="):
			# New for 4.1.  Read either "Tnnn" or "gnx".
			tref = self.getDqString()
		elif self.matchTag("vtag=\"V"):
			self.getIndex() ; self.getDquote() # ignored
		elif self.matchTag("tnodeList="):
			s = self.getDqString()
			tnodeList = self.getTnodeList(s) # New for 4.0
		elif self.matchTag(">"):
			break
		else: # New for 4.0: allow unknown attributes.
			attr,val = self.getUnknownTag()
			attrDict[attr] = val
	# Headlines are optional.
	if self.matchTag("<vh>"):
		headline = self.getEscapedString() ; self.getTag("</vh>")
	
	# g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
	if skip:
		v = self.getExistingVnode(tref)
	else:
		v,skip = self.createVnode(parent,back,tref,headline,attrDict)
		if tnodeList:
			v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
			# g.trace("%4d" % len(tnodeList),v)

	<< Set the remembered status bits >>

	# Recursively create all nested nodes.
	parent = v ; back = None
	while self.matchTag("<v"):
		append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
		append2 = appendToTopStack and len(self.topVnodeStack) == 0
		back = self.getVnode(parent,back,skip,
			appendToCurrentStack=append1,appendToTopStack=append2)
			
	<< Append to current or top stack >>

	# End this vnode.
	self.getTag("</v>")
	return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
	if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
	elif self.matchChar('D'): pass # Not used.
	elif self.matchChar('E'): setExpanded = true
	elif self.matchChar('M'): setMarked = true
	elif self.matchChar('O'): setOrphan = true
	elif self.matchChar('T'): setTop = true
	elif self.matchChar('V'): setCurrent = true
	else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
	self.currentVnodeStack = [v]

if setTop:
	self.topVnodeStack = [v]
	
if setExpanded:
	v.initExpandedBit()
	
if setMarked:
	v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
	v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
	#g.trace("append current",v)
	self.currentVnodeStack.append(v)
	
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
	#g.trace("append top",v)
	self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

	"""Puts all <v> elements in the order in which they appear in the outline."""

	c = self.c
	c.clearAllVisited()

	self.put("<vnodes>") ; self.put_nl()

	# Make only one copy for all calls.
	self.currentPosition = c.currentPosition() 
	self.topPosition     = c.topPosition()

	if self.usingClipboard:
		self.putVnode(self.currentPosition) # Write only current tree.
	else:
		for p in c.rootPosition().self_and_siblings_iter():
			self.putVnode(p) # Write the next top-level node.

	self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@-node:ekr.20040324093353:(Restore current and top nodes)
#@+node:ekr.20040326063733:(Disambiguated clones when selecting)
#@+node:ekr.20040326072847:Notes
@nocolor

What I did:

- Replaced v.edit_text() with p.edit_text()>
	** v.edit_text still remains for testing; it will soon be removed.
- tree.edit_text_dict still has vnodes as keys, but now has list of pairs (p,widget) for values.
- p.edit_text searches this list looking for a match.
- Added the following code to tree.select to unselect the old selection:
@color
if old_p and old_p != p:
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)
@nocolor
- Changed the configuration code in drawText to test p and not p.v

That's _all_ !!  This is extremely clever code, and clever in a good way.
#@nonl
#@-node:ekr.20040326072847:Notes
#@+node:ekr.20040326101817:Birth & death...
#@+node:ekr.20031218072017.3705:  tree.__init__ (base class)
def __init__ (self,frame):
	
	self.frame = frame
	self.c = c = frame.c

	self.edit_text_dict = {}
		# New in 3.12: keys vnodes, values are edit_text (Tk.Text widgets)
		# New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).
	
	# "public" ivars: correspond to setters & getters.
	self._dragging = false
	self._editPosition = None

	# Controlling redraws
	self.updateCount = 0 # self.redraw does nothing unless this is zero.
	self.redrawCount = 0 # For traces
	self.redrawScheduled = false # true if redraw scheduled.
#@nonl
#@-node:ekr.20031218072017.3705:  tree.__init__ (base class)
#@+node:ekr.20031218072017.4141:tree.Birth & death (Tkinter)
#@+node:ekr.20031218072017.1017:tree.__init__
def __init__(self,c,frame,canvas):
	
	# Init the base class.
	leoFrame.leoTree.__init__(self,frame)

	# Objects associated with this tree.
	self.canvas = canvas

	# Miscellaneous info.
	self.iconimages = {} # Image cache set by getIconImage().
	self.active = false # true if tree is active
	self._editPosition = None
	self.lineyoffset = 0 # y offset for this headline.
	self.disableRedraw = false # True: reschedule a redraw for later.
	
	# Set self.font and self.fontName.
	self.setFontFromConfig()
	
	# Recycling bindings.
	self.bindings = [] # List of bindings to be unbound when redrawing.
	self.tagBindings = [] # List of tag bindings to be unbound when redrawing.
	self.icon_id_dict = {} # New in 3.12: keys are icon id's, values are vnodes.
	self.widgets = [] # Widgets that must be destroyed when redrawing.
	
	# Drag and drop
	self.drag_p = None
	self.controlDrag = false # true: control was down when drag started.
	self.drag_id = None # To reset bindings after drag
	
	# 20-SEP-2002 DTHEIN: keep track of popup menu so we can handle
	#                     behavior better on Linux
	# Context menu
	self.popupMenu = None
	
	# Incremental redraws:
	self.allocateOnlyVisibleNodes = false # true: enable incremental redraws.
	self.trace = false # true enabling of various traces.
	self.prevMoveToFrac = None
	self.visibleArea = None
	self.expandedVisibleArea = None
	
	self.allocatedNodes = 0 # A crucial statistic.
		# Incremental drawing allocates visible nodes at most twice.
		# Non-incremetal drawing allocates all visible nodes once.
		
	if self.allocateOnlyVisibleNodes:
		self.frame.bar1.bind("<B1-ButtonRelease>", self.redraw)
	
	if not leoTkinterTree.callbacksInjected: # Class var.
		leoTkinterTree.callbacksInjected = true
		self.injectCallbacks()
#@nonl
#@-node:ekr.20031218072017.1017:tree.__init__
#@+node:ekr.20031218072017.4142:tree.deleteBindings
def deleteBindings (self):
	
	"""Delete all tree bindings and all references to tree widgets."""
	
	# g.trace(len(self.tagBindings),len(self.bindings))

	count = 0
	# Unbind all the tag bindings.
	if 0:  # testing.
		self.tagBindings = []
		self.bindings = []
	else:
		for id,id2,binding in self.tagBindings:
			self.canvas.tag_unbind(id,binding,id2)
			count += 1
		self.tagBindings = []
		# Unbind all the text bindings.
		for t,id,binding in self.bindings:
			t.unbind(binding,id)
			count += 1
		self.bindings = []

		# g.trace("bindings freed:",count)
#@nonl
#@-node:ekr.20031218072017.4142:tree.deleteBindings
#@+node:ekr.20031218072017.4143:tree.deleteWidgets
# canvas.delete("all") does _not_ delete the Tkinter objects associated with those objects!

def deleteWidgets (self):
	
	"""Delete all widgets in the canvas"""
	
	# g.trace(len(self.widgets))
	
	self.icon_id_dict = {} # Delete all references to icons.
	self.edit_text_dict = {} # Delete all references to Tk.Edit widgets.
		
	# Fixes a _huge_ memory leak.
	for w in self.widgets:
		w.destroy() 

	self.widgets = []
	
	# g.trace("done")
#@nonl
#@-node:ekr.20031218072017.4143:tree.deleteWidgets
#@+node:ekr.20031218072017.1956:tree.injectCallbacks (class method)
def injectCallbacks(self):
	
	import leoNodes
	
	<< define tkinter callbacks to be injected in the position class >>

	for f in (
		OnBoxClick,OnDrag,OnEndDrag,
		OnHeadlineClick,OnHeadlineRightClick,OnHeadlineKey,
		OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave,
		OnIconClick,OnIconDoubleClick,OnIconRightClick):
		
		g.funcToMethod(f,leoNodes.position)
#@nonl
#@+node:ekr.20031218072017.1957:<< define tkinter callbacks to be injected in the position class >>
# N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others
#@nonl
#@+node:ekr.20031218072017.1958:OnBoxClick
# Called when the box is clicked.

def OnBoxClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("boxclick1",c=c,p=p,event=event):
			c.frame.tree.OnBoxClick(p)
		g.doHook("boxclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("boxclick")
#@nonl
#@-node:ekr.20031218072017.1958:OnBoxClick
#@+node:ekr.20031218072017.1959:OnDrag
def OnDrag(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if c.frame.tree.dragging():
			if not g.doHook("dragging1",c=c,p=p,event=event):
				c.frame.tree.OnDrag(p,event)
			g.doHook("dragging2",c=c,p=p,event=event)
		else:
			if not g.doHook("drag1",c=c,p=p,event=event):
				c.frame.tree.OnDrag(p,event)
			g.doHook("drag2",c=c,p=p,event=event)
	except:
		g.es_event_exception("drag")
#@nonl
#@-node:ekr.20031218072017.1959:OnDrag
#@+node:ekr.20031218072017.1960:OnEndDrag
def OnEndDrag(self,event=None):
	
	"""Callback injected into vnode or position class."""
	
	# g.trace()

	try:
		p = self ; c = p.c
		# 7/10/03: Always call frame.OnEndDrag, regardless of state.
		if not g.doHook("enddrag1",c=c,p=p,event=event):
			c.frame.tree.OnEndDrag(p,event)
		g.doHook("enddrag2",c=c,p=p,event=event)
	except:
		g.es_event_exception("enddrag")
#@nonl
#@-node:ekr.20031218072017.1960:OnEndDrag
#@+node:ekr.20031218072017.1961:OnHeadlineClick & OnHeadlineRightClick
def OnHeadlineClick(self,event=None):
	"""Callback injected into vnode or position class."""
	try:
		p = self ; c = p.c
		if not g.doHook("headclick1",c=c,p=p,event=event):
			c.frame.tree.OnActivate(p)
		g.doHook("headclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("headclick")
	
def OnHeadlineRightClick(self,event=None):

	"""Callback injected into vnode or position class."""

	#g.trace()
	try:
		p = self ; c = p.c
		if not g.doHook("headrclick1",c=c,p=p,event=event):
			c.frame.tree.OnActivate(p)
			c.frame.tree.OnPopup(self,event)
		g.doHook("headrclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("headrclick")
#@nonl
#@-node:ekr.20031218072017.1961:OnHeadlineClick & OnHeadlineRightClick
#@+node:ekr.20031218072017.1962:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
	
	"""Callback injected into vnode or position class."""

	# g.trace()
	try:
		p = self ; c = p.c
		if not g.doHook("hypercclick1",c=c,p=p,event=event):
			c.beginUpdate()
			c.selectVnode(p)
			c.endUpdate()
			c.frame.bodyCtrl.mark_set("insert","1.0")
		g.doHook("hypercclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("hypercclick")
#@nonl
#@-node:ekr.20031218072017.1962:OnHyperLinkControlClick
#@+node:ekr.20031218072017.1963:OnHeadlineKey
def OnHeadlineKey (self,event=None):

	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("headkey1",c=c,p=p,event=event):
			c.frame.tree.OnHeadlineKey(p,event)
		g.doHook("headkey2",c=c,p=p,event=event)
	except:
		g.es_event_exception("headkey")
#@nonl
#@-node:ekr.20031218072017.1963:OnHeadlineKey
#@+node:ekr.20031218072017.1964:OnHyperLinkEnter
def OnHyperLinkEnter (self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("hyperenter1",c=c,p=p,event=event):
			if 0: # This works, and isn't very useful.
				c.frame.bodyCtrl.tag_config(p.tagName,background="green")
		g.doHook("hyperenter2",c=c,p=p,event=event)
	except:
		g.es_event_exception("hyperenter")
#@nonl
#@-node:ekr.20031218072017.1964:OnHyperLinkEnter
#@+node:ekr.20031218072017.1965:OnHyperLinkLeave
def OnHyperLinkLeave (self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("hyperleave1",c=c,p=p,event=event):
			if 0: # This works, and isn't very useful.
				c.frame.bodyCtrl.tag_config(p.tagName,background="white")
		g.doHook("hyperleave2",c=c,p=p,event=event)
	except:
		g.es_event_exception("hyperleave")
#@nonl
#@-node:ekr.20031218072017.1965:OnHyperLinkLeave
#@+node:ekr.20031218072017.1966:OnIconClick & OnIconRightClick
def OnIconClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("iconclick1",c=c,p=p,event=event):
			c.frame.tree.OnIconClick(p,event)
		g.doHook("iconclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("iconclick")
	
def OnIconRightClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("iconrclick1",c=c,p=p,event=event):
			c.frame.tree.OnIconRightClick(p,event)
		g.doHook("iconrclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("iconrclick")
#@-node:ekr.20031218072017.1966:OnIconClick & OnIconRightClick
#@+node:ekr.20031218072017.1967:OnIconDoubleClick
def OnIconDoubleClick(self,event=None):
	
	"""Callback injected into vnode or position class."""

	try:
		p = self ; c = p.c
		if not g.doHook("icondclick1",c=c,p=p,event=event):
			c.frame.tree.OnIconDoubleClick(self)
		g.doHook("icondclick2",c=c,p=p,event=event)
	except:
		g.es_event_exception("icondclick")
#@-node:ekr.20031218072017.1967:OnIconDoubleClick
#@-node:ekr.20031218072017.1957:<< define tkinter callbacks to be injected in the position class >>
#@-node:ekr.20031218072017.1956:tree.injectCallbacks (class method)
#@-node:ekr.20031218072017.4141:tree.Birth & death (Tkinter)
#@-node:ekr.20040326101817:Birth & death...
#@+node:ekr.20040326101817.1:edit_text mods...
#@+node:ekr.20031218072017.3380:v.edit_text TO BE DELETED
def edit_text (self):

	v = self ; c = v.c ; p = c.currentPosition()
	
	g.trace("ooooops")
	#import traceback ; traceback.print_stack()
	
	pairs = self.c.frame.tree.getEditTextDict(v)
	for p2,t2 in pairs:
		if p.equal(p2):
			# g.trace("found",t2)
			return t2
			
	return None
#@nonl
#@-node:ekr.20031218072017.3380:v.edit_text TO BE DELETED
#@+node:ekr.20040306220230.1:p.edit_text
def edit_text (self):
	
	p = self
	
	if self.c:
		# New in 4.2: the dictionary is a list of pairs(p,v)
		pairs = self.c.frame.tree.getEditTextDict(p.v)
		for p2,t2 in pairs:
			if p.equal(p2):
				# g.trace("found",t2)
				return t2
		return None
	else:
		return None
#@nonl
#@-node:ekr.20040306220230.1:p.edit_text
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def dragging(self):
	return self._dragging

def getEditTextDict(self,v):
	# New in 4.2: the default is an empty list.
	return self.edit_text_dict.get(v,[])

def editPosition(self):
	return self._editPosition
	
def setDragging(self,flag):
	self._dragging = flag

def setEditPosition(self,p):
	self._editPosition = p
#@nonl
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@-node:ekr.20040326101817.1:edit_text mods...
#@+node:ekr.20031218072017.1335:idle_head_key
def idle_head_key (self,p,ch=None):
	
	"""Update headline text at idle time."""

	c = self.c ; v = p.v

	if not p or not p.edit_text() or p != c.currentPosition():
		return "break"
		
	edit_text = p.edit_text()

	if g.doHook("headkey1",c=c,p=p,ch=ch):
		return "break" # The hook claims to have handled the event.

	<< set s to the widget text >>
	<< set head to vnode text >>
	changed = s != head
	done = ch and (ch == '\r' or ch == '\n')
	if not changed and not done:
		return "break"
	if changed:
		c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
	index = edit_text.index("insert")
	if changed:
		<< update v and all nodes joined to v >>
	<< reconfigure v and all nodes joined to v >>
	<< update the screen >>

	g.doHook("headkey2",c=c,p=p,ch=ch)
	return "break"
#@nonl
#@+node:ekr.20031218072017.1336:<< set s to the widget text >>
s = edit_text.get("1.0","end")
s = g.toUnicode(s,g.app.tkEncoding) # 2/25/03

if not s:
	s = u""
s = s.replace('\n','')
s = s.replace('\r','')
# g.trace(s)
#@-node:ekr.20031218072017.1336:<< set s to the widget text >>
#@+node:ekr.20031218072017.1337:<< set head to vnode text >>
head = p.headString()
if head == None:
	head = u""
head = g.toUnicode(head,"utf-8")
#@-node:ekr.20031218072017.1337:<< set head to vnode text >>
#@+node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
c.beginUpdate()
if 1: # update...
	# Update changed bit.
	if not c.changed:
		c.setChanged(true)
	# Update all dirty bits.
	p.setDirty()
	# Update v.
	v.initHeadString(s)
	edit_text.delete("1.0","end")
	edit_text.insert("end",s)
	edit_text.mark_set("insert",index)
c.endUpdate(false) # do not redraw now.
#@nonl
#@-node:ekr.20031218072017.1338:<< update v and all nodes joined to v >>
#@+node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
# Reconfigure v's headline.
if done:
	self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(v))
#@nonl
#@-node:ekr.20031218072017.1339:<< reconfigure v and all nodes joined to v >>
#@+node:ekr.20031218072017.1340:<< update the screen >>
if done:
	c.beginUpdate()
	self.endEditLabel()
	c.endUpdate()

elif changed:
	# update v immediately.  Joined nodes are redrawn later by endEditLabel.
	# Redrawing the whole screen now messes up the cursor in the headline.
	self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20031218072017.1340:<< update the screen >>
#@-node:ekr.20031218072017.1335:idle_head_key
#@+node:ekr.20031218072017.4144:Drawing (tkTree)
#@+node:ekr.20031218072017.4145:About drawing and updating
@ About drawing and updating strategy.

This version of Leo draws the outline "by hand" using the Tk canvas widget.  Surprisingly, this is not only easy, but simplifies the vnode and Commands classes.

1.  Updating and redraw.  The tree.redraw() method is called automatically from the "outermost" call to tree.endUpdate.  Moreover, calling .tree.redraw() inside a tree.beginUpdate/tree.endUpdate pair does nothing.  c.redraw(), c.beginUpdate() and c.endUpdate() just call the corresponding tree methods.  Finally, beginUpdate()/endUpdate(false) can be used to suppress redrawing entirely.

Therefore, the Commands class never needs to worry about extra calls to tree.redraw() provided all code that draws to the tree is enclosed in a tree.beginUpdate/tree.endUpdate pair.  The tree.idle_body_key event handler manages redrawing "by hand" by maintaining a redraw_flag and then calling endUpdate(redraw_flag).

2.  The tree.redraw() method deletes all old canvas items and recomputes all data, including v.iconVal.  This means that v.doDelete need not actually delete vnodes for them to disappear from the screen.  Indeed, vnode are never actually deleted, only unlinked.  It would be valid for "dependent" vnodes to be deleted, but there really is no need to do so.
#@-node:ekr.20031218072017.4145:About drawing and updating
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):

	y += 7 # draw the box at x, y+7
	h = self.line_height

	tree = self
	iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y+self.lineyoffset,image=image)
	
	if 1: # New in 4.2.  Create a frame to catch all clicks.
		id4 = self.canvas.create_rectangle(0,y-7,1000,y-7+h-3)
		color = ""
		self.canvas.itemconfig(id4,fill=color,outline=color)
		self.canvas.lower(id4)
		id3 = self.canvas.tag_bind(id4, "<1>", p.OnBoxClick)
		self.tagBindings.append((id,id3,"<1>"),)

	id1 = self.canvas.tag_bind(id, "<1>", p.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
	
	"""Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

	tree = self
	
	# Make sure the bindings refer to the _present_ position.
	v = p.v

	if x is None and y is None:
		try:
			x,y = v.iconx, v.icony
		except:
			# Inject the ivars.
			x,y = v.iconx, v.icony = 0,0
	else:
		# Inject the ivars.
		v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute v.iconVal.
	# This is an important drawing optimization.
	val = v.iconVal = v.computeIcon()
	assert(0 <= val <= 15)

	# Get the image.
	imagename = "box%02d.GIF" % val
	image = self.getIconImage(imagename)
	id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image)
	self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.

	id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
	id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
	id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
	self.tagBindings.append((id,id3,"<3>"),)

	return 0,icon_width # dummy icon height,width
#@nonl
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@+node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):

	"""Draw horizontal line from vertical line to icon"""
	
	if 1:
		self.lineyoffset = 0
	else:
		if hasattr(p.v.t,"unknownAttributes"):
			self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
		else:
			self.lineyoffset = 0
		
	self.canvas.create_line(x,y+7+self.lineyoffset,
		x+box_width,y+7+self.lineyoffset,
		tag="lines",fill="gray50") # stipple="gray25")

	if self.inVisibleArea(y):
		return self.force_draw_node(p,x,y)
	else:
		return self.line_height,0
#@nonl
#@+node:ekr.20040317171729:force_draw_node (new)
def force_draw_node(self,p,x,y):

	self.allocatedNodes += 1
	h,w = self.drawUserIcons(p,"beforeBox",x,y)
	xw = w # The extra indentation before the icon box.
	if p.hasChildren():
		self.drawBox(p,x+w,y)
	w += box_width # even if box isn't drawn.

	h2,w2 = self.drawUserIcons(p,"beforeIcon",x+w,y)
	h = max(h,h2) ; w += w2 ; xw += w2

	h2,w2 = self.drawIcon(p,x+w,y)
	h = max(h,h2) ; w += w2

	h2,w2 = self.drawUserIcons(p,"beforeHeadline",x+w,y)
	h = max(h,h2) ; w += w2

	h2 = self.drawText(p,x+w,y)
	h = max(h,h2)
	w += self.widthInPixels(p.headString())

	h2,w2 = self.drawUserIcons(p,"afterHeadline",x+w,y)
	h = max(h,h2)

	return h,xw
#@nonl
#@-node:ekr.20040317171729:force_draw_node (new)
#@+node:ekr.20040318090335:force_draw_node (old)
def force_draw_nodeOLD(self,p,x,y):

	self.allocatedNodes += 1

	if p.hasChildren():
		self.drawBox(p,x,y)
	w = box_width # Even if the box isn't drawn.

	h2,w2 = self.drawIcon(p,x+w,y)
	w += w2

	h = self.drawText(p,x+w,y)
	
	return h,0
#@-node:ekr.20040318090335:force_draw_node (old)
#@-node:ekr.20031218072017.1004:drawNode & force_draw_node (good trace)
#@+node:ekr.20031218072017.1005:drawText (bind)
def drawText(self,p,x,y):
	
	"""draw text for v at nominal coordinates x,y."""

	tree = self ; c = self.c ; v = p.v
	x += text_indent

	t = Tkinter.Text(self.canvas,
		font=self.font,bd=0,relief="flat",width=self.headWidth(v),height=1)

	# New in 4.2: entries a pairs (p,t) indexed by v.
	# Remember which text widget belongs to v.
	d = self.edit_text_dict
	val = d.get(v,[])
	val.append((p,t),)
	d[v] = val
	# g.trace("entry",d[p.v])

	# Remember the widget so deleteBindings can delete it.
	self.widgets.append(t) # Fixes a _huge_ memory leak.

	t.insert("end", v.headString())
	<< configure the text depending on state >>

	# Use vnode or postion callbacks.
	id1 = t.bind("<1>",p.OnHeadlineClick)
	id2 = t.bind("<3>",p.OnHeadlineRightClick)
	
	if 0: # 6/15/02: Bill Drissel objects to this binding.
		t.bind("<Double-1>", p.OnBoxClick)
	id3 = t.bind("<Key>", p.OnHeadlineKey)
	id4 = t.bind("<Control-t>",self.OnControlT)
		# 10/16/02: Stamp out the erroneous control-t binding.
		
	# Remember the bindings so deleteBindings can delete them.
	self.bindings.append((t,id1,"<1>"),)
	self.bindings.append((t,id2,"<3>"),)
	self.bindings.append((t,id3,"<Key>"),)
	self.bindings.append((t,id4,"<Control-t>"),)

	id = self.canvas.create_window(x,y+self.lineyoffset,anchor="nw",window=t)
	self.canvas.tag_lower(id)
	
	# This doesn't work: must call update_idletasks first, and that's hard here.
	# g.trace(t,t.winfo_height(),t.winfo_width())
	
	return self.line_height
#@nonl
#@+node:ekr.20031218072017.1006:<< configure the text depending on state >>
if p and p == c.currentPosition():
	if p == self.editPosition():
		self.setNormalLabelState(p)
	else:
		self.setDisabledLabelState(p) # selected, disabled
else:
	self.setUnselectedLabelState(p) # unselected
#@nonl
#@-node:ekr.20031218072017.1006:<< configure the text depending on state >>
#@-node:ekr.20031218072017.1005:drawText (bind)
#@+node:ekr.20031218072017.2029:drawTopTree
def drawTopTree (self):
	
	"""Draws the top-level tree, taking into account the hoist state."""
	
	c = self.c
	
	if c.hoistStack:
		p,junk = c.hoistStack[-1]
		self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=true)
	else:
		self.drawTree(c.rootPosition(),root_left,root_top,0,0)
		
	# g.trace(g.app.copies) ; g.app.copies = 0
	# import traceback ; traceback.print_stack()
#@nonl
#@-node:ekr.20031218072017.2029:drawTopTree
#@+node:ekr.20031218072017.1008:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=false):

	yfirst = ylast = y
	if level==0: yfirst += 10
	w = 0
	
	# We must make copies for drawText and drawBox and drawIcon,
	# So making copies here actually reduces the total number of copies.
	### This will change for incremental redraw.
	p = p.copy()
	while p: # Do not use iterator.
		h,w = self.drawNode(p,x,y)
		y += h ; ylast = y
		if p.isExpanded() and p.hasFirstChild():
			# Must make an additional copy here by calling firstChild.
			y,w2 = self.drawTree(p.firstChild(),x+child_indent+w,y,h,level+1)
			x += w2 ; w += w2
		if hoistFlag: break
		else:         p = p.next()
	<< draw vertical line >>
	return y,w
#@nonl
#@+node:ekr.20031218072017.1009:<< draw vertical line >>
id = self.canvas.create_line(
	x, yfirst-hline_y,
	x, ylast+hline_y-h,
	fill="gray50", # stipple="gray50"
	tag="lines")

self.canvas.tag_lower(id)
#@nonl
#@-node:ekr.20031218072017.1009:<< draw vertical line >>
#@-node:ekr.20031218072017.1008:drawTree
#@+node:ekr.20040317095510:drawUserIcon
def drawUserIcon (self,where,x,y,dict):
	
	h,w = 0,0

	if where != dict.get("where","beforeHeadline"):
		return h,w
		
	# g.trace(where,x,y,dict)
	
	<< set offsets and pads >>
	type = dict.get("type")
	if type == "icon":
		s = dict.get("icon")
		<< draw the icon in string s >>
	elif type == "file":
		file = dict.get("file")
		<< draw the icon at file >>
	elif type == "url":
		url = dict.get("url")
		<< draw the icon at url >>
		
	# Allow user to specify height, width explicitly.
	h = dict.get("height",h)
	w = dict.get("width",w)

	return h,w
#@nonl
#@+node:ekr.20040317173849:<< set offsets and pads >>
xoffset = dict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = dict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = dict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = dict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040317173849:<< set offsets and pads >>
#@+node:ekr.20040317095153:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040317095153:<< draw the icon in string s >>
#@+node:ekr.20040317095153.1:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040317095153.1:<< draw the icon at url >>
#@+node:ekr.20040317100702:<< draw the icon at file >>
try:
	image = self.iconimages[file]
	# Get the image from the cache if possible.
except KeyError:
	try:
		fullname = g.os_path_join(g.app.loadDir,"..","Icons",file)
		fullname = g.os_path_normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas,file=fullname)
		self.iconimages[fullname] = image
	except:
		#g.es("Exception loading: " + fullname)
		#g.es_exception()
		image = None
		
if image:
	id = self.canvas.create_image(x+xoffset,y+yoffset,anchor="nw",image=image)
	self.canvas.lift(id)
	h = image.height() + yoffset + ypad
	w = image.width()  + xoffset + xpad
#@nonl
#@-node:ekr.20040317100702:<< draw the icon at file >>
#@-node:ekr.20040317095510:drawUserIcon
#@+node:ekr.20040317094609:drawUserIcons
def drawUserIcons(self,p,where,x,y):
	
	"""Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
	
	h,w = 0,0 ; t = p.v.t
	
	if not hasattr(t,"unknownAttributes"):
		return h,w
	
	iconsList = t.unknownAttributes.get("icons")
	# g.trace(iconsList)
	
	try:
		for dict in iconsList:
			h2,w2 = self.drawUserIcon(where,x+w,y,dict)
			h = max(h,h2) ; w += w2
	except:
		g.es_exception()

	return h,w
#@nonl
#@-node:ekr.20040317094609:drawUserIcons
#@+node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
def inVisibleArea (self,y1):
	
	if self.allocateOnlyVisibleNodes:
		if self.visibleArea:
			vis1,vis2 = self.visibleArea
			y2 = y1 + self.line_height
			return y2 >= vis1 and y1 <= vis2
		else: return false
	else:
		return true # This forces all nodes to be allocated on all redraws.
		
def inExpandedVisibleArea (self,y1):
	
	if self.expandedVisibleArea:
		vis1,vis2 = self.expandedVisibleArea
		y2 = y1 + self.line_height
		return y2 >= vis1 and y1 <= vis2
	else:
		return false
#@nonl
#@-node:ekr.20031218072017.1010:inVisibleArea & inExpandedVisibleArea
#@+node:ekr.20031218072017.4147:tree.getIconImage
def getIconImage (self, name):

	# Return the image from the cache if possible.
	if self.iconimages.has_key(name):
		return self.iconimages[name]
		
	try:
		fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
		fullname = g.os_path_normpath(fullname)
		image = Tkinter.PhotoImage(master=self.canvas, file=fullname)
		self.iconimages[name] = image
		return image
	except:
		g.es("Exception loading: " + fullname)
		g.es_exception()
		return None
#@nonl
#@-node:ekr.20031218072017.4147:tree.getIconImage
#@+node:ekr.20040322122232:tree.scrollTo
def scrollTo (self,p):
	
	def scrollToCallback(event=None,self=self,p=p):
		g.trace(event,self,p)
		self.idle_scrollTo(p)
	
	self.canvas.after_idle(scrollToCallback)
#@nonl
#@-node:ekr.20040322122232:tree.scrollTo
#@+node:ekr.20031218072017.1018:tree.idle_scrollTo
def idle_scrollTo(self,p=None):

	"""Scrolls the canvas so that v is in view.
	
	This is done at idle time after a redraw so that treeBar.get() will return proper values."""

	c = self.c ; frame = c.frame
	if not p: p = self.c.currentPosition()
	if not p: p = self.c.rootPosition() # 4/8/04.
	try:
		last = p.lastVisible()
		nextToLast = last.visBack()
		h1 = self.yoffset(p)
		h2 = self.yoffset(last)
		<< compute approximate line height >>
		<< Compute the fractions to scroll down/up >>
		if frac <= lo:
			if self.prevMoveToFrac != frac:
				self.prevMoveToFrac = frac
				self.canvas.yview("moveto",frac)
		elif frac2 + (hi - lo) >= hi:
			if self.prevMoveToFrac != frac2:
				self.prevMoveToFrac = frac2
				self.canvas.yview("moveto",frac2)

		if self.allocateOnlyVisibleNodes:
			self.canvas.after_idle(self.idle_second_redraw)
			
		c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
		# print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
	except:
		g.es_exception()
#@nonl
#@+node:ekr.20040314092716:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
	lineHeight = h2 - self.yoffset(nextToLast)
else:
	lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040314092716:<< compute approximate line height >>
#@+node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
	frac = float(h1)/float(h2) # For scrolling down.
	frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
	frac2 = frac2 - (hi - lo)
else:
	frac = frac2 = 0.0 # probably any value would work here.
	
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20031218072017.1018:tree.idle_scrollTo
#@+node:ekr.20031218072017.4148:tree.numberOfVisibleNodes
def numberOfVisibleNodes(self):
	
	n = 0 ; p = self.c.rootPosition()
	while p:
		n += 1
		p.moveToVisNext()
	return n
#@nonl
#@-node:ekr.20031218072017.4148:tree.numberOfVisibleNodes
#@+node:ekr.20031218072017.4149:tree.yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.  For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self, v1):

	# if not v1.isVisible(): print "yoffset not visible:",v1
	root = self.c.rootPosition()
	h, flag = self.yoffsetTree(root,v1)
	# flag can be false during initialization.
	# if not flag: print "yoffset fails:",h,v1
	return h

# Returns the visible height of the tree and all sibling trees, stopping at p1

def yoffsetTree(self,p,p1):

	h = 0
	for p in p.siblings_iter():
		# print "yoffsetTree:", p
		if p == p1:
			return h, true
		h += self.line_height
		if p.isExpanded() and p.hasChildren():
			child = p.firstChild()
			h2, flag = self.yoffsetTree(child,p1)
			h += h2
			if flag: return h, true
	
	return h, false
#@nonl
#@-node:ekr.20031218072017.4149:tree.yoffset
#@-node:ekr.20031218072017.4144:Drawing (tkTree)
#@+node:ekr.20031218072017.4157:Selecting & editing (tree)
#@+node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
# Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):

	p = self.c.currentPosition()
	self.setDisabledLabelState(p)

def undimEditLabel (self):

	p = self.c.currentPosition()
	self.setSelectedLabelState(p)
#@nonl
#@-node:ekr.20031218072017.4158:dimEditLabel, undimEditLabel
#@+node:ekr.20031218072017.4159:editLabel
def editLabel (self,p):
	
	"""Start editing p.edit_text."""
	
	# g.trace(p)

	if self.editPosition() and p != self.editPosition():
		self.endEditLabel()
		self.frame.revertHeadline = None
		
	self.setEditPosition(p)

	# Start editing
	if p and p.edit_text():
		self.setNormalLabelState(p)
		self.frame.revertHeadline = p.headString()
		self.setEditPosition(p)
#@nonl
#@-node:ekr.20031218072017.4159:editLabel
#@+node:ekr.20031218072017.4160:endEditLabel
def endEditLabel (self):
	
	"""End editing for self.editText."""

	c = self.c ; gui = g.app.gui
	
	p = self.editPosition()

	if p and p.edit_text():
		self.setUnselectedLabelState(p)
		self.setEditPosition(None)

		# force a redraw of joined and ancestor headlines.
		self.force_redraw() 

	gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02
#@nonl
#@-node:ekr.20031218072017.4160:endEditLabel
#@+node:ekr.20031218072017.4161:tree.expandAllAncestors
def expandAllAncestors (self,p):
	
	redraw_flag = false

	for p in p.parents_iter():
		if not p.isExpanded():
			p.expand()
			redraw_flag = true

	return redraw_flag

#@-node:ekr.20031218072017.4161:tree.expandAllAncestors
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@+node:ekr.20031218072017.4162:tree.set...LabelState
def setNormalLabelState (self,p): # selected, editing

	# g.trace(p)
	if p and p.edit_text():
		<< set editing headline colors >>
		p.edit_text().tag_remove("sel","1.0","end")
		p.edit_text().tag_add("sel","1.0","end")
		g.app.gui.set_focus(self.c,p.edit_text())

def setDisabledLabelState (self,p): # selected, disabled

	# g.trace(p,g.callerName(2),g.callerName(3))
	if p and p.edit_text():
		<< set selected, disabled headline colors >>

def setSelectedLabelState (self,p): # selected, not editing

	# g.trace(p)
	self.setDisabledLabelState(p)

def setUnselectedLabelState (self,p): # not selected.

	# g.trace(p)
	if p and p.edit_text():
		<< set unselected headline colors >>
#@+node:ekr.20031218072017.4163:<< set editing headline colors >>
config = g.app.config
fg   = config.getWindowPref("headline_text_editing_foreground_color")
bg   = config.getWindowPref("headline_text_editing_background_color")
selfg = config.getWindowPref("headline_text_editing_selection_foreground_color")
selbg = config.getWindowPref("headline_text_editing_selection_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	if selfg and selbg:
		p.edit_text().configure(
			selectforeground=selfg,selectbackground=selbg,
			state="normal",highlightthickness=1,fg=fg,bg=bg)
	else:
		p.edit_text().configure(
			state="normal",highlightthickness=1,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4163:<< set editing headline colors >>
#@+node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_selected_foreground_color")
bg = config.getWindowPref("headline_text_selected_background_color")

if not fg or not bg:
	fg,bg = "black","gray80"

try:
	p.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4164:<< set selected, disabled headline colors >>
#@+node:ekr.20031218072017.4165:<< set unselected headline colors >>
config = g.app.config
fg = config.getWindowPref("headline_text_unselected_foreground_color")
bg = config.getWindowPref("headline_text_unselected_background_color")

if not fg or not bg:
	fg,bg = "black","white"

try:
	p.edit_text().configure(
		state="disabled",highlightthickness=0,fg=fg,bg=bg)
except:
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.4165:<< set unselected headline colors >>
#@-node:ekr.20031218072017.4162:tree.set...LabelState
#@-node:ekr.20031218072017.4157:Selecting & editing (tree)
#@-node:ekr.20040326063733:(Disambiguated clones when selecting)
#@-node:ekr.20040326040442.1:3/26
#@+node:ekr.20040327132739.2:3/27
#@+node:ekr.20031218072017.862:(Added useNullUndoer option to nullFrame class)
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):
	
	"""A null frame class for tests and batch execution."""
	
	@others
#@nonl
#@+node:ekr.20040327105706:__init__
def __init__ (self,title,useNullUndoer=false):

	leoFrame.__init__(self) # Init the base class.
	assert(self.c is None)
	self.title = title
	self.useNullUndoer = useNullUndoer
#@nonl
#@-node:ekr.20040327105706:__init__
#@+node:ekr.20040327105706.1:__getattr__ NOT USED
if 0: # This causes no end of problems.

	def __getattr__(self,attr):
		g.trace("nullFrame",attr)
		return nullObject()
#@nonl
#@-node:ekr.20040327105706.1:__getattr__ NOT USED
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

	self.c = c
	# Create do-nothing component objects.
	self.tree = nullTree(frame=self)
	self.body = nullBody(frame=self,parentFrame=None)
	self.log  = nullLog (frame=self,parentFrame=None)
	self.menu = leoMenu.nullMenu(frame=self)
	
	assert(c.undoer)
	if self.useNullUndoer:
		c.undoer = leoUndo.nullUndoer(c)
#@nonl
#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20040327105706.3:oops
def oops(self):
	
	# g.trace("nullFrame:", g.callerName(2))

	pass # This is NOT an error.
#@nonl
#@-node:ekr.20040327105706.3:oops
#@-node:ekr.20031218072017.2222:class nullFrame
#@-node:ekr.20031218072017.862:(Added useNullUndoer option to nullFrame class)
#@-node:ekr.20040327132739.2:3/27
#@+node:ekr.20040328082044:3/28
#@+node:ekr.20040323090456.1:(Fixed bugs in up isAnyAtFileNode & related routines)
#@+node:ekr.20031218072017.3152:g.scanAtFileOptions
def scanAtFileOptions (h,err_flag=false):
	
	assert(g.match(h,0,"@file"))
	i = len("@file")
	atFileType = "@file"
	optionsList = []

	while g.match(h,i,'-'):
		<< scan another @file option >>
		
	# Convert atFileType to a list of options.
	for fileType,option in (
		("@silentfile","asis"),
		("@nosentinelsfile","nosent"),
		("@rawfile","noref"),
		("@thinfile","thin")
	):
		if atFileType == fileType and option not in optionsList:
			optionsList.append(option)
			
	# g.trace(atFileType,optionsList)

	return i,atFileType,optionsList
#@nonl
#@+node:ekr.20031218072017.3153:<< scan another @file option >>
i += 1 ; err = -1

if g.match_word(h,i,"asis"):
	if atFileType == "@file":
		atFileType = "@silentfile"
	elif err_flag:
		g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@rawfile"
	elif atFileType == "@nosentinelsfile":
		atFileType = "@silentfile"
	elif err_flag:
		g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@nosentinelsfile"
	elif atFileType == "@rawfile":
		atFileType = "@silentfile"
	elif err_flag:
		g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
	if atFileType == "@file":
		atFileType = "@thinfile"
	elif err_flag:
		g.es("using -thin option in:" + h)
else:
	if 0: # doesn't work
		for option in ("fat","new","now","old","thin","wait"):
			if g.match_word(h,i,option):
				optionsList.append(option)
		if len(option) == 0:
			err = i-1
# Scan to the next minus sign.
while i < len(h) and h[i] not in (' ','\t','-'):
	i += 1
if err > -1:
	g.es("unknown option:" + h[err:i] + " in " + h)
#@nonl
#@-node:ekr.20031218072017.3153:<< scan another @file option >>
#@-node:ekr.20031218072017.3152:g.scanAtFileOptions
#@+node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20040328055931:afterHeadlineFileTypeName
def afterHeadlineFileTypeName(self,s):
	
	h = self.headString()

	if s != "@file" and g.match_word(h,0,s):
		# No options are valid.
		return s,string.strip(h[len(s):])

	elif g.match(h,0,"@file"):
		i,atFileType,junk = g.scanAtFileOptions(h)
		return atFileType,h[i:].strip()

	else:
		return None,None
#@nonl
#@-node:ekr.20040328055931:afterHeadlineFileTypeName
#@+node:ekr.20031218072017.3347:afterHeadlineMatch
def afterHeadlineMatch(self,s):
	
	atFileType,fileName = self.afterHeadlineFileTypeName(s)
	if s == atFileType:
		return fileName
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3347:afterHeadlineMatch
#@+node:ekr.20031218072017.3350:anyAtFileNodeName
def anyAtFileNodeName (self):
	
	"""Return the file name following an @file node or an empty string."""
	
	# New in 4.2: do the fastest possible tests.
	h = self.headString()

	if g.match(h,0,"@file"):
		type,name = self.afterHeadlineFileTypeName("@file")
		if type and name: return name
		else:             return ""
	elif g.match(h,0,"@nosentinelsfile"):
		return self.afterHeadlineMatch("@nosentinelsfile")
	elif g.match(h,0,"@rawfile"):
		return self.afterHeadlineMatch("@rawfile")
	elif g.match(h,0,"@silentfile"):
		return self.afterHeadlineMatch("@silentfile")
	elif g.match(h,0,"@thinfile"):
		return self.afterHeadlineMatch("@thinfile")
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3350:anyAtFileNodeName
#@+node:ekr.20031218072017.3348:at...FileNodeName
@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
	return self.afterHeadlineMatch("@file")

def atNoSentinelsFileNodeName (self):
	return self.afterHeadlineMatch("@nosentinelsfile")

def atRawFileNodeName (self):
	return self.afterHeadlineMatch("@rawfile")
	
def atSilentFileNodeName (self):
	return self.afterHeadlineMatch("@silentfile")
	
def atThinFileNodeName (self):
	return self.afterHeadlineMatch("@thinfile")
	
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@nonl
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:EKR.20040430152000:isAtAllNode
def isAtAllNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@all")
	return flag
#@nonl
#@-node:EKR.20040430152000:isAtAllNode
#@+node:ekr.20040326031436:isAnyAtFileNode
def isAnyAtFileNode (self):
	
	"""Return true if v is any kind of @file or related node."""
	
	# This routine should be as fast as possible.
	# It is called once for every vnode when writing a file.

	h = self.headString()
	return h and h[0] == '@' and self.anyAtFileNodeName()
#@nonl
#@-node:ekr.20040326031436:isAnyAtFileNode
#@+node:ekr.20040325073709:isAt...FileNode
def isAtFileNode (self):
	return g.choose(self.atFileNodeName(),true,false)
	
def isAtNoSentinelsFileNode (self):
	return g.choose(self.atNoSentinelsFileNodeName(),true,false)

def isAtRawFileNode (self): # @file-noref
	return g.choose(self.atRawFileNodeName(),true,false)

def isAtSilentFileNode (self): # @file-asis
	return g.choose(self.atSilentFileNodeName(),true,false)

def isAtThinFileNode (self):
	return g.choose(self.atThinFileNodeName(),true,false)
	
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@nonl
#@-node:ekr.20040325073709:isAt...FileNode
#@+node:ekr.20031218072017.3351:isAtIgnoreNode
def isAtIgnoreNode (self):

	"""Returns true if the receiver contains @ignore in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
	return flag
#@nonl
#@-node:ekr.20031218072017.3351:isAtIgnoreNode
#@+node:ekr.20031218072017.3352:isAtOthersNode
def isAtOthersNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@others")
	return flag
#@nonl
#@-node:ekr.20031218072017.3352:isAtOthersNode
#@+node:ekr.20031218072017.3353:matchHeadline
def matchHeadline (self,pattern):

	"""Returns true if the headline matches the pattern ignoring whitespace and case.
	
	The headline may contain characters following the successfully matched pattern."""

	h = string.lower(self.headString())
	h = string.replace(h,' ','')
	h = string.replace(h,'\t','')

	s = string.lower(pattern)
	s = string.replace(s,' ','')
	s = string.replace(s,'\t','')

	# ignore characters in the headline following the match
	return s == h[0:len(s)]
#@nonl
#@-node:ekr.20031218072017.3353:matchHeadline
#@-node:ekr.20031218072017.3346:v.Comparisons
#@-node:ekr.20040323090456.1:(Fixed bugs in up isAnyAtFileNode & related routines)
#@+node:ekr.20040328093126:(Cleaned up using @file type names)
#@+node:ekr.20040322115523:getGoToFileName
def getGoToFileName (self,p):
	
	return p.anyAtFileNodeName() # 4/28/04
#@nonl
#@-node:ekr.20040322115523:getGoToFileName
#@+node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

dir = g.choose(name,g.os_path_dirname(name),None)

if dir and len(dir) > 0 and g.os_path_isabs(dir):
	if g.os_path_exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = g.makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20031218072017.2628:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
	
dir = g.choose(name,g.os_path_dirname(name),None)

if dir and g.os_path_isabs(dir):
	if g.os_path_exists(dir):
		at.default_directory = dir
	else:
		at.default_directory = g.makeAllNonExistentDirectories(dir)
		if not at.default_directory:
			at.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2628:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@-node:ekr.20040328093126:(Cleaned up using @file type names)
#@+node:ekr.20040328063421:(Converted to less confusing @file type names)
#@+node:ekr.20040306211032:p.Comparisons
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@nonl
#@-node:ekr.20040306211032:p.Comparisons
#@+node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20040328055931:afterHeadlineFileTypeName
def afterHeadlineFileTypeName(self,s):
	
	h = self.headString()

	if s != "@file" and g.match_word(h,0,s):
		# No options are valid.
		return s,string.strip(h[len(s):])

	elif g.match(h,0,"@file"):
		i,atFileType,junk = g.scanAtFileOptions(h)
		return atFileType,h[i:].strip()

	else:
		return None,None
#@nonl
#@-node:ekr.20040328055931:afterHeadlineFileTypeName
#@+node:ekr.20031218072017.3347:afterHeadlineMatch
def afterHeadlineMatch(self,s):
	
	atFileType,fileName = self.afterHeadlineFileTypeName(s)
	if s == atFileType:
		return fileName
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3347:afterHeadlineMatch
#@+node:ekr.20031218072017.3350:anyAtFileNodeName
def anyAtFileNodeName (self):
	
	"""Return the file name following an @file node or an empty string."""
	
	# New in 4.2: do the fastest possible tests.
	h = self.headString()

	if g.match(h,0,"@file"):
		type,name = self.afterHeadlineFileTypeName("@file")
		if type and name: return name
		else:             return ""
	elif g.match(h,0,"@nosentinelsfile"):
		return self.afterHeadlineMatch("@nosentinelsfile")
	elif g.match(h,0,"@rawfile"):
		return self.afterHeadlineMatch("@rawfile")
	elif g.match(h,0,"@silentfile"):
		return self.afterHeadlineMatch("@silentfile")
	elif g.match(h,0,"@thinfile"):
		return self.afterHeadlineMatch("@thinfile")
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3350:anyAtFileNodeName
#@+node:ekr.20031218072017.3348:at...FileNodeName
@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
	return self.afterHeadlineMatch("@file")

def atNoSentinelsFileNodeName (self):
	return self.afterHeadlineMatch("@nosentinelsfile")

def atRawFileNodeName (self):
	return self.afterHeadlineMatch("@rawfile")
	
def atSilentFileNodeName (self):
	return self.afterHeadlineMatch("@silentfile")
	
def atThinFileNodeName (self):
	return self.afterHeadlineMatch("@thinfile")
	
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@nonl
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:EKR.20040430152000:isAtAllNode
def isAtAllNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@all")
	return flag
#@nonl
#@-node:EKR.20040430152000:isAtAllNode
#@+node:ekr.20040326031436:isAnyAtFileNode
def isAnyAtFileNode (self):
	
	"""Return true if v is any kind of @file or related node."""
	
	# This routine should be as fast as possible.
	# It is called once for every vnode when writing a file.

	h = self.headString()
	return h and h[0] == '@' and self.anyAtFileNodeName()
#@nonl
#@-node:ekr.20040326031436:isAnyAtFileNode
#@+node:ekr.20040325073709:isAt...FileNode
def isAtFileNode (self):
	return g.choose(self.atFileNodeName(),true,false)
	
def isAtNoSentinelsFileNode (self):
	return g.choose(self.atNoSentinelsFileNodeName(),true,false)

def isAtRawFileNode (self): # @file-noref
	return g.choose(self.atRawFileNodeName(),true,false)

def isAtSilentFileNode (self): # @file-asis
	return g.choose(self.atSilentFileNodeName(),true,false)

def isAtThinFileNode (self):
	return g.choose(self.atThinFileNodeName(),true,false)
	
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@nonl
#@-node:ekr.20040325073709:isAt...FileNode
#@+node:ekr.20031218072017.3351:isAtIgnoreNode
def isAtIgnoreNode (self):

	"""Returns true if the receiver contains @ignore in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
	return flag
#@nonl
#@-node:ekr.20031218072017.3351:isAtIgnoreNode
#@+node:ekr.20031218072017.3352:isAtOthersNode
def isAtOthersNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@others")
	return flag
#@nonl
#@-node:ekr.20031218072017.3352:isAtOthersNode
#@+node:ekr.20031218072017.3353:matchHeadline
def matchHeadline (self,pattern):

	"""Returns true if the headline matches the pattern ignoring whitespace and case.
	
	The headline may contain characters following the successfully matched pattern."""

	h = string.lower(self.headString())
	h = string.replace(h,' ','')
	h = string.replace(h,'\t','')

	s = string.lower(pattern)
	s = string.replace(s,' ','')
	s = string.replace(s,'\t','')

	# ignore characters in the headline following the match
	return s == h[0:len(s)]
#@nonl
#@-node:ekr.20031218072017.3353:matchHeadline
#@-node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20031218072017.2626: top_df.readAll
def readAll(self,root,partialFlag=false):
	
	"""Scan vnodes, looking for @file nodes to read."""

	at = self ; c = at.c
	c.endEditing() # Capture the current headline.
	anyRead = false
	at.initIvars()
	p = root.copy()
	if partialFlag: after = p.nodeAfterTree()
	else: after = c.nullPosition()
	while p and not p.equal(after): # Don't use iterator.
		if p.isAtIgnoreNode():
			p.moveToNodeAfterTree()
		elif p.isAtThinFileNode():
			anyRead = true
			at.read(p,thinFile=true)
			p.moveToNodeAfterTree()
		elif p.isAtFileNode() or p.isAtNorefFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				at.read(p)
			else:
				# if p is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = p.isOrphan()
				ok = at.read(p)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					p.setDirty()
					c.setChanged(true)
			p.moveToNodeAfterTree()
		else: p.moveToThreadNext()
	# Clear all orphan bits.
	for p in c.allNodes_iter():
		p.v.clearOrphan()
		
	if partialFlag and not anyRead:
		g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20031218072017.2626: top_df.readAll
#@+node:ekr.20031218072017.2122:new_df.norefWrite
def norefWrite(self,root):

	at = self
	
	g.trace(root)

	c = at.c ; at.root = root
	at.errors = 0
	at.root.t.tnodeList = [] # 9/26/03: after beta 1 release.
	at.sentinels = true # 10/1/03
	at.scripting = false # 1/30/04
	at.thinFile = false # 5/17/04
	c.endEditing() # Capture the current headline.
	try:
		at.targetFileName = root.atNorefFileNodeName()
		ok = at.openWriteFile(root)
		if not ok: return
		<< write root's tree >>
		at.closeWriteFile()
		at.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		at.handleWriteException(root)
		
rawWrite = norefWrite
#@+node:ekr.20031218072017.2123:<< write root's tree >>
<< put all @first lines in root >>
at.putOpenLeoSentinel("@+leo-ver=4")
<< put optional @comment sentinel lines >>

for p in root.self_and_subtree_iter():
	<< Write p's node >>

at.putSentinel("@-leo")
<< put all @last lines in root >>
#@nonl
#@+node:ekr.20031218072017.2124:<< put all @first lines in root >>
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
	i += len(tag)
	i = g.skip_ws(s,i)
	j = i
	i = g.skip_to_end_of_line(s,i)
	# Write @first line, whether empty or not
	line = s[j:i]
	at.putBuffered(line) ; at.onl()
	i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20031218072017.2124:<< put all @first lines in root >>
#@+node:ekr.20031218072017.2125:<< put optional @comment sentinel lines >>
s2 = g.app.config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = line.replace("@date",time.asctime())
		if len(line)> 0:
			at.putSentinel("@comment " + line)
#@-node:ekr.20031218072017.2125:<< put optional @comment sentinel lines >>
#@+node:ekr.20031218072017.2126:<< Write p's node >>
at.putOpenNodeSentinel(p,inAtOthers=true)

s = p.bodyString()
if s and len(s) > 0:
	s = g.toEncodedString(s,at.encoding,reportErrors=true) # 3/7/03
	at.outputStringWithLineEndings(s)
	
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
	at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=true)
#@nonl
#@-node:ekr.20031218072017.2126:<< Write p's node >>
#@+node:ekr.20031218072017.2127:<< put all @last lines in root >>
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
	line = lines[j]
	if g.match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = g.skip_ws(line,i)
	at.putBuffered(line[i:]) ; at.onl()
#@nonl
#@-node:ekr.20031218072017.2127:<< put all @last lines in root >>
#@-node:ekr.20031218072017.2123:<< write root's tree >>
#@-node:ekr.20031218072017.2122:new_df.norefWrite
#@+node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=false,inAtOthers=false):
	
	"""Write @+node sentinel for p."""
	
	at = self

	if not inAtAll and p.isAtFileNode() and p != at.root:
		at.writeError("@file not valid in: " + p.headString())
		return
		
	# g.trace(at.thinFile,p)
		
	s = at.nodeSentinelText(p)
	at.putSentinel("@+node:" + s)
	
	if not at.thinFile:
		# Append the n'th tnode to the root's tnode list.
		at.root.v.t.tnodeList.append(p.v.t)
#@nonl
#@-node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
#@-node:ekr.20040328063421:(Converted to less confusing @file type names)
#@-node:ekr.20040328082044:3/28
#@+node:ekr.20040331080343:3/31
#@+node:ekr.20040331074940:(Fixed bug in hoist)
#@+node:ekr.20031218072017.2028:Hoist & dehoist & enablers
def dehoist(self):

	c = self ; p = c.currentPosition()
	g.trace(p)
	if p and c.canDehoist():
		c.undoer.setUndoParams("De-Hoist",p)
		h,expanded = c.hoistStack.pop()
		if expanded: p.expand()
		else:        p.contract()
		c.redraw()
		c.frame.clearStatusLine()
		if c.hoistStack:
			p,junk = c.hoistStack[-1]
			c.frame.putStatusLine("Hoist: " + p.headString())
		else:
			c.frame.putStatusLine("No hoist")

def hoist(self):

	c = self ; p = c.currentPosition()
	if p and c.canHoist():
		c.undoer.setUndoParams("Hoist",p)
		# New in 4.2: remember expansion state.
		c.hoistStack.append((p,p.isExpanded()),)
		p.expand()
		c.redraw()
		c.frame.clearStatusLine()
		c.frame.putStatusLine("Hoist: " + p.headString())
#@nonl
#@-node:ekr.20031218072017.2028:Hoist & dehoist & enablers
#@+node:ekr.20031218072017.2029:drawTopTree
def drawTopTree (self):
	
	"""Draws the top-level tree, taking into account the hoist state."""
	
	c = self.c
	
	if c.hoistStack:
		p,junk = c.hoistStack[-1]
		self.drawTree(p.copy(),root_left,root_top,0,0,hoistFlag=true)
	else:
		self.drawTree(c.rootPosition(),root_left,root_top,0,0)
		
	# g.trace(g.app.copies) ; g.app.copies = 0
	# import traceback ; traceback.print_stack()
#@nonl
#@-node:ekr.20031218072017.2029:drawTopTree
#@-node:ekr.20040331074940:(Fixed bug in hoist)
#@-node:ekr.20040331080343:3/31
#@-node:ekr.20040403104315:March 2004
#@+node:ekr.20040403104315.1:April 2004
#@+node:ekr.20040403104315.2:4/2
#@+node:ekr.20040206075634.1:Colorizing additions
#@+node:ekr.20031218072017.367:How to add support for a new language
@nocolor

- Add a new entries in << define global data structures >> app

- Add a new Tk.Radiobutton in <<create the Target Language frame>>

- Add an entry to the languages list in <<configure language-specific settings>>

- Add a list of the keywords of the language to << define colorizer keywords >>

  N.B.: the name of this list must be x_keywords, where x is the entry in language in step a.

- Add any language-specifig code to leoColor.colorizeAnyLanguage.
  For most languages nothing need be done in this step.

TESTS

- Test the syntax coloring for the new language by using the @language directive.

- Test workings of the Preferences Panel by choosing the language in the panel and by looking at code that is _not_ under control of an @language directive.

- Test the leoConfig.txt by setting default_target_language to the name of the new language.  When you restart Leo, the new language should be selected in the Prefs panel.

- Remove leoConfig.txt, select the new language in the Prefs panel, and save the .leo file.  Open the file with a text editor and check to make sure that the <preferences> tag (near the top) contains an entry like this:

<preferences allow_rich_text="0" defaultTargetLanguage="Python">
</preferences>

but with the name of your new language instead of "Python".

- Create an @root node and verify that you can Tangle it.

@color
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
	"actionscript" : "// /* */", #jason 2003-07-03
	"c" : "// /* */", # C, C++ or objective C.
	"csharp" : "// /* */",	# C#
	"css" : "/* */", # 4/1/04
	"cweb" : "@q@ @>", # Use the "cweb hack"
	"elisp" : ";",
	"forth" : "_\\_ _(_ _)_", # Use the "REM hack"
	"fortran" : "C",
	"fortran90" : "!",
	"html" : "<!-- -->",
	"java" : "// /* */",
	"latex" : "%",
	"pascal" : "// { }",
	"perl" : "#",
	"perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
	"php" : "//",
	"plain" : "#", # We must pick something.
	"python" : "#",
	"rapidq" : "'", # fil 2004-march-11
	"rebol" : ";",  # jason 2003-07-03
	"shell" : "#",  # shell scripts
	"tcltk" : "#",
	"unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
	"actionscript" : "as", #jason 2003-07-03
	"c" : "c",
	"css" : "css", # 4/1/04
	"cweb" : "w",
	"elisp" : "el",
	"forth" : "forth",
	"fortran" : "f",
	"fortran90" : "f",
	"html" : "html",
	"java" : "java",
	"latex" : "tex", # 1/8/04
	"noweb" : "nw",
	"pascal" : "p",
	"perl" : "perl",
	"perlpod" : "perl",
	"php" : "php",
	"plain" : "txt",
	"python" : "py",
	"rapidq" : "bas", # fil 2004-march-11
	"rebol" : "r",    # jason 2003-07-03
	"shell" : "sh",   # DS 4/1/04
	"tex" : "tex",
	"tcltk" : "tcl",
	"unknown" : "txt" } # Set when @comment is seen.
#@nonl
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
	("ActionScript", "actionscript"),
	("C#",    "csharp"),
	("C/C++", "c"),
	("CSS",   "css"),
	("CWEB",  "cweb"),
	("elisp", "elisp"),
	("HTML",  "html"),
	("Java",  "java"),
	("LaTeX", "latex"),
	("Pascal","pascal")]

for text,value in left_data:
	button = Tk.Radiobutton(lt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")

# Right column of radio buttons.
right_data = [
	("Perl", "perl"),
	("Perl+POD",   "perlpod"),
	("PHP",        "php"),
	("Plain Text", "plain"),
	("Python",     "python"),
	("RapidQ",     "rapidq"),
	("Rebol",      "rebol"),
	("Shell",      "shell"),
	("tcl/tk",     "tcltk")]

for text,value in right_data:
	button = Tk.Radiobutton(rt,anchor="w",text=text,
		variable=self.lang_var,value=value,command=self.set_lang)
	button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
	delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
	delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
	delim1,delim2,delim3 = None,None,None
else:
	delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.has_string = self.language != "plain"
if self.language == "plain":
	self.string_delims = ()
elif self.language in ("elisp","html"):
	self.string_delims = ('"')
else:
	self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
	"actionscript","c","csharp","css","cweb","elisp","html","java","latex",
	"pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
	for i in self.c_keywords:
		self.keywords.append(i)
	for i in self.cweb_keywords:
		self.keywords.append(i)
else:
	for name in languages:
		if self.language==name: 
			# g.trace("setting keywords for",name)
			self.keywords = getattr(self, name + "_keywords")

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
	self.lb = "<<"
	self.rb = ">>"
else:
	self.lb = g.choose(self.language == "cweb","@<","<<")
	self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords
#@nonl
#@+node:ekr.20031218072017.372:actionscript keywords
actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]
#@nonl
#@-node:ekr.20031218072017.372:actionscript keywords
#@+node:ekr.20040206072057:c# keywords
csharp_keywords = [
	"abstract","as",
	"base","bool","break","byte",
	"case","catch","char","checked","class","const","continue",
	"decimal","default","delegate","do","double",
	"else","enum","event","explicit","extern",
	"false","finally","fixed","float","for","foreach",
	"get","goto",
	"if","implicit","in","int","interface","internal","is",
	"lock","long",
	"namespace","new","null",
	"object","operator","out","override",
	"params","partial","private","protected","public",
	"readonly","ref","return",
	"sbyte","sealed","set","short","sizeof","stackalloc",
	"static","string","struct","switch",
	"this","throw","true","try","typeof",
	"uint","ulong","unchecked","unsafe","ushort","using",
	"value","virtual","void","volatile",
	"where","while",
	"yield"]
#@nonl
#@-node:ekr.20040206072057:c# keywords
#@+node:ekr.20031218072017.373:c/c++ keywords
c_keywords = [
	# C keywords
	"auto","break","case","char","continue",
	"default","do","double","else","enum","extern",
	"float","for","goto","if","int","long","register","return",
	"short","signed","sizeof","static","struct","switch",
	"typedef","union","unsigned","void","volatile","while",
	# C++ keywords
	"asm","bool","catch","class","const","const_cast",
	"delete","dynamic_cast","explicit","false","friend",
	"inline","mutable","namespace","new","operator",
	"private","protected","public","reinterpret_cast","static_cast",
	"template","this","throw","true","try",
	"typeid","typename","using","virtual","wchar_t"]
#@nonl
#@-node:ekr.20031218072017.373:c/c++ keywords
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@nonl
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.374:elisp keywords
# EKR: needs more work.
elisp_keywords = [
	# Maybe...
	"error","princ",
	# More typical of other lisps...
	"apply","eval",
	"t","nil",
	"and","or","not",
	"cons","car","cdr",
	"cond",
	"defconst","defun","defvar",
	"eq","ne","equal","gt","ge","lt","le",
	"if",
	"let",
	"mapcar",
	"prog","progn",
	"set","setq",
	"type-of",
	"unless",
	"when","while"]
#@nonl
#@-node:ekr.20031218072017.374:elisp keywords
#@+node:ekr.20031218072017.375:html keywords
# No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
	unused_keywords = [
		# html constructs.
		"a","body","cf",
		"h1","h2","h3","h4","h5","h6",
		"head","html","hr",
		"i","img","li","lu","meta",
		"p","title","ul",
		# Common tags
		"caption","col","colgroup",
		"table","tbody","td","tfoot","th","thead","tr",
		"script","style"]

	html_specials = [ "<%","%>" ]
#@nonl
#@-node:ekr.20031218072017.375:html keywords
#@+node:ekr.20031218072017.376:java keywords
java_keywords = [
	"abstract","boolean","break","byte","byvalue",
	"case","cast","catch","char","class","const","continue",
	"default","do","double","else","extends",
	"false","final","finally","float","for","future",
	"generic","goto","if","implements","import","inner",
	"instanceof","int","interface","long","native",
	"new","null","operator","outer",
	"package","private","protected","public","rest","return",
	"short","static","super","switch","synchronized",
	"this","throw","transient","true","try",
	"var","void","volatile","while"]
#@nonl
#@-node:ekr.20031218072017.376:java keywords
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
	#special keyworlds
	"\\%", # 11/9/03
	"\\@", "\\(", "\\)", "\\{", "\\}",
	#A
	"\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
	"\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
	"\\appendix", 
	"\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
	#B
	"\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
	"\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
	"\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
	"\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
	#C
	"\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
	"\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
	"\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
	"\\cot", "\\coth",	"csc",
	#D
	"\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
	"\\deg", "\\Delta", 
	"\\delta", "\\depthits", "\\det", 
	"\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
	"\\documentclass", "\\documentstyle", 
	"\\dot", "\\dotfil", "\\downarrow",
	#E
	"\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
	"\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
	"\\eta", "\\example", "\\exists", "\\exp",
	#F
	"\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
	"\\footnotemark", "\\fotenotesize", 
	"\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
	"\\frontmatter",
	#G
	"\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
	"\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
	#H
	"\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
	"\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
	#I
	"\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
	"\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
	#J
	"\\jmath", "\\Join",
	#K
	"\\k", "\\kappa", "\\ker", "\\kill",
	#L
	"\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
	"\\LaTeX", "\\LaTeXe", 
	"\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
	"\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
	"\\linethickness", "\\linewidth",	"\\listfiles",
	"\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
	"\\Longrightarrow",	"longrightarrow",
	#M
	"\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
	"\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
	"\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
	"\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
	#N
	"\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
	"\\newenvironment", "\\newfont",
	"\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
	"\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
	"\\not", "\\nu", "nwarrow",
	#O
	"\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
	"\\overbrace", "\\overline",
	#P
	"\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
	"\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
	"\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
	"\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
	"\\providecomamnd", "\\Psi",	"\\psi", "\\put",
	#Q
	"\\qbezier", "\\quoteblbase", "\\quotesinglbase",
	#R
	"\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
	"\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
	"\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
	"\\Roman", "\\roman", "\\rule", 
	#S
	"\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
	"\\searrow",	"\\sec", "\\section",
	"\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
	"\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
	"\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
	"\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
	"\\sqsupset", "\\SS",
	"\\stackrel", "\\star", "\\subsection", "\\subset", 
	"\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
	#T
	"\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
	"\\tau", "\\telephone",	"\\TeX", "\\textbf",
	"\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
	"\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
	"\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
	"\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
	"\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
	"\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
	"\\Theta", "theta", 
	"\\tilde", "\\thinlines", 
	"\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
	"\\triangle", "\\tt", 
	"\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
	#U
	"\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
	"\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
	"\\usecounter", "\\usepackage", 
	#V
	"\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
	"\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
	"\\vline", "\\vphantom", "\\vspace",
	#W
	"\\widehat", "\\widetilde", "\\widthits", "\\wp",
	#X
	"\\Xi", "\\xi",
	#Z
	"\\zeta" ]
#@nonl
#@-node:ekr.20031218072017.377:latex keywords
#@+node:ekr.20031218072017.378:pascal keywords
pascal_keywords = [
	"and","array","as","begin",
	"case","const","class","constructor","cdecl"
	"div","do","downto","destructor","dispid","dynamic",
	"else","end","except","external",
	"false","file","for","forward","function","finally",
	"goto","if","in","is","label","library",
	"mod","message","nil","not","nodefault""of","or","on",
	"procedure","program","packed","pascal",
	"private","protected","public","published",
	"record","repeat","raise","read","register",
	"set","string","shl","shr","stdcall",
	"then","to","true","type","try","until","unit","uses",
	"var","virtual","while","with","xor"
	# object pascal
	"asm","absolute","abstract","assembler","at","automated",
	"finalization",
	"implementation","inherited","initialization","inline","interface",
	"object","override","resident","resourcestring",
	"threadvar",
	# limited contexts
	"exports","property","default","write","stored","index","name" ]
#@nonl
#@-node:ekr.20031218072017.378:pascal keywords
#@+node:ekr.20031218072017.379:perl keywords
perl_keywords = [
	"continue","do","else","elsif","format","for","format","for","foreach",
	"if","local","package","sub","tr","unless","until","while","y",
	# Comparison operators
	"cmp","eq","ge","gt","le","lt","ne",
	# Matching ooperators
	"m","s",
	# Unary functions
	"alarm","caller","chdir","cos","chroot","exit","eval","exp",
	"getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
	"hex","int","length","localtime","log","ord","oct",
	"require","reset","rand","rmdir","readlink",
	"scalar","sin","sleep","sqrt","srand","umask",
	# Transfer ops
	"next","last","redo","go","dump",
	# File operations...
	"select","open",
	# FL ops
	"binmode","close","closedir","eof",
	"fileno","getc","getpeername","getsockname","lstat",
	"readdir","rewinddir","stat","tell","telldir","write",
	# FL2 ops
	"bind","connect","flock","listen","opendir",
	"seekdir","shutdown","truncate",
	# FL32 ops
	"accept","pipe",
	# FL3 ops
	"fcntl","getsockopt","ioctl","read",
	"seek","send","sysread","syswrite",
	# FL4 & FL5 ops
	"recv","setsocket","socket","socketpair",
	# Array operations
	"pop","shift","split","delete",
	# FLIST ops
	"sprintf","grep","join","pack",
	# LVAL ops
	"chop","defined","study","undef",
	# f0 ops
	"endhostent","endnetent","endservent","endprotoent",
	"endpwent","endgrent","fork",
	"getgrent","gethostent","getlogin","getnetent","getppid",
	"getprotoent","getpwent","getservent",
	"setgrent","setpwent","time","times","wait","wantarray",
	# f1 ops
	"getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
	"sethostent","setnetent","setprotoent","setservent",
	# f2 ops
	"atan2","crypt",
	"gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
	"index","link","mkdir","msgget","rename",
	"semop","setpgrp","symlink","unpack","waitpid",
	# f2 or 3 ops
	"index","rindex","substr",
	# f3 ops
	"msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
	# f4 & f5 ops
	"semctl","shmread","shmwrite","msgrcv",
	# Assoc ops
	"dbmclose","each","keys","values",
	# List ops
	"chmod","chown","die","exec","kill",
	"print","printf","return","reverse",
	"sort","system","syscall","unlink","utime","warn"]
#@nonl
#@-node:ekr.20031218072017.379:perl keywords
#@+node:ekr.20031218072017.380:php keywords
php_keywords = [ # 08-SEP-2002 DTHEIN
	"__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
	"and", "as", "break",
	"case", "cfunction", "class", "const", "continue",
	"declare", "default", "do",
	"else", "elseif", "enddeclare", "endfor", "endforeach",
	"endif", "endswitch",  "endwhile", "eval", "extends",
	"for", "foreach", "function", "global", "if",
	"new", "old_function", "or", "static", "switch",
	"use", "var", "while", "xor" ]
	
# The following are supposed to be followed by ()
php_paren_keywords = [
	"array", "die", "echo", "empty", "exit",
	"include", "include_once", "isset", "list",
	"print", "require", "require_once", "return",
	"unset" ]
	
# The following are handled by special case code:
# "<?php", "?>"
#@-node:ekr.20031218072017.380:php keywords
#@+node:ekr.20031218072017.381:python keywords
python_keywords = [
	"and",       "del",       "for",       "is",        "raise",    
	"assert",    "elif",      "from",      "lambda",    "return",   
	"break",     "else",      "global",    "not",       "try",      
	"class",     "except",    "if",        "or",        "yield",   
	"continue",  "exec",      "import",    "pass",      "while",
	"def",       "finally",   "in",        "print"]
#@nonl
#@-node:ekr.20031218072017.381:python keywords
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@nonl
#@-node:ekr.20040331145826:rapidq keywords
#@+node:ekr.20031218072017.382:rebol keywords
rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]
#@nonl
#@-node:ekr.20031218072017.382:rebol keywords
#@+node:ekr.20040401111125:shell keywords
shell_keywords = [
	# reserved keywords
	"case","do","done","elif","else","esac","fi",
	"for","if","in","then",
	"until","while",
	"break","cd","chdir","continue","eval","exec",
	"exit","kill","newgrp","pwd","read","readonly",
	"return","shift","test","trap","ulimit",
	"umask","wait" ]
#@nonl
#@-node:ekr.20040401111125:shell keywords
#@+node:ekr.20031218072017.383:tcl/tk keywords
tcltk_keywords = [ # Only the tcl keywords are here.
	"after",     "append",    "array",
	"bgerror",   "binary",    "break",
	"catch",     "cd",        "clock",
	"close",     "concat",    "continue",
	"dde",
	"encoding",  "eof",       "eval",
	"exec",      "exit",      "expr",
	"fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
	"filename",  "flush",     "for",       "foreach",   "format",
	"gets",      "glob",      "global",
	"history",
	"if",        "incr",      "info",      "interp",
	"join",
	"lappend",   "lindex",    "linsert",   "list",      "llength",
	"load",      "lrange",    "lreplace",  "lsearch",   "lsort",
	"memory",    "msgcat",
	"namespace",
	"open",
	"package",   "parray",    "pid",
	"proc",      "puts",      "pwd",
	"read",      "regexp",    "registry",   "regsub",
	"rename",    "resource",  "return",
	"scan",      "seek",      "set",        "socket",   "source",
	"split",     "string",    "subst",      "switch",
	"tell",      "time",      "trace",
	"unknown",   "unset",     "update",     "uplevel",   "upvar",
	"variable",  "vwait",
	"while" ]
#@nonl
#@-node:ekr.20031218072017.383:tcl/tk keywords
#@-node:ekr.20031218072017.371:<< define colorizer keywords >> colorizer
#@-node:ekr.20031218072017.367:How to add support for a new language
#@+node:ekr.20040331145826.1:(done) RapidQ support
#@+node:ekr.20040331145826:rapidq keywords
rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]
#@nonl
#@-node:ekr.20040331145826:rapidq keywords
#@-node:ekr.20040331145826.1:(done) RapidQ support
#@+node:ekr.20040117111755:(done) css support
#@+node:ekr.20040401104931:Notes
@nocolor

By: grayrest ( Karl Guertin ) 
 diff: css support   
2004-01-09 23:42  

 I got frustrated at leo's lack of support for CSS. The main difficulty I was having is that CSS only specifies the /* and */ comment delimiters and not any single line delimeter. Trying the depricated @comment /* */ doesn't work because it produces the output

/* @@comment /* */ */

which fails because the first */ on the line ends the comment, leaving the second */ as a syntax error in the file.

Anyway, while looking into it I figured I'd just add CSS as a supported language. It took longer than expected (there are a LOT of keywords in css) but the only hangup was that css keywords include dashes (e.g. margin-top). Diff against 4.1RC3 release is below.


In case it gets mangled, the diff can also be found at http://r39h92.res.gatech.edu:8788/leon_files/css.diff
#@nonl
#@-node:ekr.20040401104931:Notes
#@+node:ekr.20040401103539:css keywords
css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]
#@nonl
#@-node:ekr.20040401103539:css keywords
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
	<< handle possible latex keyword >>
elif self.language == "html":
	<< handle possible html keyword >>
else:
	<< handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
	j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
	word = s[i:j]
	if word in self.latex_keywords:
		self.tag("latexKeyword",i,j)
	else:
		self.tag("latexBackground",i,j)
else:
	self.tag("latexBackground",i,i+1)
	j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
	if g.match(s,i,"<!---"): k = 5
	else: k = 4
	self.tag("comment",i,i+k)
	j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
	if g.match(s,i,"</"): k = 2
	else: k = 1
	j = self.skip_id(s,i+k)
	self.tag("keyword",i,j)
elif g.match(s,i,"&"):
	j = self.skip_id(s,i+1,';')
	self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
	j = i + 2
	self.tag("keyword",i,j)
elif g.match(s,i,">"):
	j = i + 1
	self.tag("keyword",i,j)
else:
	j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
	j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
	j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
	j = self.skip_id(s,i+1,chars="-")
else:
	j = self.skip_id(s,i)

word = s[i:j]
if word in self.keywords:
	self.tag("keyword",i,j)
elif self.language == "php":
	if word in self.php_paren_keywords and g.match(s,j,"()"):
		self.tag("keyword",i,j+2)
		j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@-node:ekr.20040117111755:(done) css support
#@+node:ekr.20040117113539.1:(done) Coloring for Shell Scripts (Davide)
#@+node:ekr.20040401111308:Notes
@nocolor

I recently wrote a few shell scripts (on linux) with leo, and I noticed
there was no colorizer support for shell (apart from comments), so I added
it: see the attached leo file. Note that this only adds colorizer support
for vanilla /bin/sh keywords -- one could customize it to add support for
all the different shell flavors out there (bash, ksh, etc), although I
think this is better left out for when we have a more flexible way of
specifying language grammars. Note that I changed the default extension
type for shell scripts from "txt" to "sh" (much more common for shell
scripts, I think).

In addition to what's specified in "How to add support for a new language"
(in LeoPy.leo), I also had to modify the << handle single-line comment >>
block in colorizer.doNormalState to avoid that the built-in shell variable
'$#' starts a single-line comment.

As usual, feel free to modify at will.

Last thing: if I try to "Import to @file" a file with no extension, it
fails saying "<filename>.py does not exist" (where <filename> is the file I
want to load), i.e. Leo always tries to add a ".py" extension to files to
be imported if they don't have one. This is with Leo 4.1rc3 CVS version,
Python 2.3.2 on Linux.
#@nonl
#@-node:ekr.20040401111308:Notes
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.tag("comment",i,j)
	self.doLatexLine(s,j,len(s))
	i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
	i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
	j = len(s)
	if not g.doHook("color-optional-markup",
		colorer=self,v=self.p,s=s,i=i,j=j,colortag="comment"):
		self.tag("comment",i,j)
	i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@-node:ekr.20040117113539.1:(done) Coloring for Shell Scripts (Davide)
#@+node:ekr.20040106145421:(not yet) PHP syntax coloring
#@+node:ekr.20040401110507:Notes
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2361052
By: sbeards

It would be nice if [doNormalState] could also catch the following all of which should be valid when the language is PHP.

<?_    (Note: replace the '_' with whitespace)
<?=
<?[pP][hH][pP] (Note: regex/mixed case is OK)

Can't we use the following regex to catch these cases?

"<?(\s|=|[pP][hH][pP])"

Scott

EKR: This doesn't seem to work.  I did add code so that all cases of PHP get recoginized.
#@nonl
#@-node:ekr.20040401110507:Notes
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
	self.tag("keyword",i,i+5)
	i += 5
elif g.match(s,i,"?>"):
	self.tag("keyword",i,i+2)
	i += 2
else:
	i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1896:doNormalState
## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):

	ch = s[i] ; state = "normal"
	assert(type(ch)==type(u""))

	if ch in string.ascii_letters or ch == '_' or (
		(ch == '\\' and self.language=="latex") or
		(ch in '/&<>' and self.language=="html") or
		(ch == '$' and self.language=="rapidq")
	):
		<< handle possible keyword >>
	elif g.match(s,i,self.lb):
		i = self.doNowebSecRef(s,i)
	elif ch == '@':
		<< handle at keyword >>
	elif g.match(s,i,self.single_comment_start):
		<< handle single-line comment >>
	elif g.match(s,i,self.block_comment_start):
		<< start block comment >>
	elif ch == '%' and self.language=="cweb":
		<< handle latex line >>
	elif self.language=="latex":
		<< handle latex normal character >>
	# ---- From here on self.language != "latex" -----
	elif ch in self.string_delims:
		<< handle string >>
	elif ch == '#' and self.has_pp_directives:
		<< handle C preprocessor line >>
	elif self.language == "php" and (g.match(s,i,"<") or g.match(s,i,"?")):
		# g.trace("%3d" % i,php_re.match(s,i),s)
		<< handle special php keywords >>
	elif ch == ' ':
		<< handle blank >>
	elif ch == '\t':
		<< handle tab >>
	else:
		<< handle normal character >>

	if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
		g.trace(self.progress,i,state)
		assert(self.progress < i)
	return i,state


#@+node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
	<< handle possible latex keyword >>
elif self.language == "html":
	<< handle possible html keyword >>
else:
	<< handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
	j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
	word = s[i:j]
	if word in self.latex_keywords:
		self.tag("latexKeyword",i,j)
	else:
		self.tag("latexBackground",i,j)
else:
	self.tag("latexBackground",i,i+1)
	j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
	if g.match(s,i,"<!---"): k = 5
	else: k = 4
	self.tag("comment",i,i+k)
	j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
	if g.match(s,i,"</"): k = 2
	else: k = 1
	j = self.skip_id(s,i+k)
	self.tag("keyword",i,j)
elif g.match(s,i,"&"):
	j = self.skip_id(s,i+1,';')
	self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
	j = i + 2
	self.tag("keyword",i,j)
elif g.match(s,i,">"):
	j = i + 1
	self.tag("keyword",i,j)
else:
	j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
	j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
	j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
	j = self.skip_id(s,i+1,chars="-")
else:
	j = self.skip_id(s,i)

word = s[i:j]
if word in self.keywords:
	self.tag("keyword",i,j)
elif self.language == "php":
	if word in self.php_paren_keywords and g.match(s,j,"()"):
		self.tag("keyword",i,j+2)
		j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
	if g.match(s,i,"@(") or g.match(s,i,"@<"):
		<< handle cweb ref or def >>
	else:
		word = self.getCwebWord(s,i)
		if word:
			<< Handle cweb control word >>
		else:
			i,state = self.doAtKeyword(s,i)
else:
	i,state = self.doAtKeyword(s,i)
#@nonl
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
	state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
	state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
	j = s.find("@>",i)
	if j > -1:
		self.tag("cwebName",i,j)
		self.tag("nameBrackets",j,j+2)
		i = j + 2
#@nonl
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
	j = s.find("@>",i+2)

if j == -1:
	i += 2
else:
	self.tag("cwebName",i+2,j)
	self.tag("nameBrackets",j,j+k)
	i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.tag("comment",i,j)
	self.doLatexLine(s,j,len(s))
	i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
	i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
	j = len(s)
	if not g.doHook("color-optional-markup",
		colorer=self,v=self.p,s=s,i=i,j=j,colortag="comment"):
		self.tag("comment",i,j)
	i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
	colorer=self,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
	self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@nonl
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@nonl
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@-node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
	self.tag("latexModeBackground",i,i+1)
else:
	self.tag("latexBackground",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@-node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1612:<< handle string >>
if self.language == "python":

	delim = s[i:i+3]
	j, state = self.skip_python_string(s,i)
	if delim == '"""':
		# Only handle wiki items in """ strings.
		if not g.doHook("color-optional-markup",
			colorer=self,v=self.p,s=s,i=i,j=j,colortag="string"):
			self.tag("string",i,j)
	else:
		self.tag("string",i,j)
	i = j

else:
	j, state = self.skip_string(s,i)
	self.tag("string",i,j)
	i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
	if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
		break
	else: i += 1

self.tag("pp",j,i)
#@nonl
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
	self.tag("keyword",i,i+5)
	i += 5
elif g.match(s,i,"?>"):
	self.tag("keyword",i,i+2)
	i += 2
else:
	i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
	self.tag("blank",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
	self.tag("tab",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
	<< handle possible latex keyword >>
elif self.language == "html":
	<< handle possible html keyword >>
else:
	<< handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
	j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03
	word = s[i:j]
	if word in self.latex_keywords:
		self.tag("latexKeyword",i,j)
	else:
		self.tag("latexBackground",i,j)
else:
	self.tag("latexBackground",i,i+1)
	j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
	if g.match(s,i,"<!---"): k = 5
	else: k = 4
	self.tag("comment",i,i+k)
	j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
	if g.match(s,i,"</"): k = 2
	else: k = 1
	j = self.skip_id(s,i+k)
	self.tag("keyword",i,j)
elif g.match(s,i,"&"):
	j = self.skip_id(s,i+1,';')
	self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
	j = i + 2
	self.tag("keyword",i,j)
elif g.match(s,i,">"):
	j = i + 1
	self.tag("keyword",i,j)
else:
	j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
	j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
	j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
	j = self.skip_id(s,i+1,chars="-")
else:
	j = self.skip_id(s,i)

word = s[i:j]
if word in self.keywords:
	self.tag("keyword",i,j)
elif self.language == "php":
	if word in self.php_paren_keywords and g.match(s,j,"()"):
		self.tag("keyword",i,j+2)
		j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
	if g.match(s,i,"@(") or g.match(s,i,"@<"):
		<< handle cweb ref or def >>
	else:
		word = self.getCwebWord(s,i)
		if word:
			<< Handle cweb control word >>
		else:
			i,state = self.doAtKeyword(s,i)
else:
	i,state = self.doAtKeyword(s,i)
#@nonl
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
	state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
	state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
	j = s.find("@>",i)
	if j > -1:
		self.tag("cwebName",i,j)
		self.tag("nameBrackets",j,j+2)
		i = j + 2
#@nonl
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
	j = s.find("@>",i+2)

if j == -1:
	i += 2
else:
	self.tag("cwebName",i+2,j)
	self.tag("nameBrackets",j,j+k)
	i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
	j = i + len(self.single_comment_start)
	self.tag("comment",i,j)
	self.doLatexLine(s,j,len(s))
	i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
	i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
	j = len(s)
	if not g.doHook("color-optional-markup",
		colorer=self,v=self.p,s=s,i=i,j=j,colortag="comment"):
		self.tag("comment",i,j)
	i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
	colorer=self,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
	self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@nonl
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@nonl
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
	self.tag("latexModeBackground",i,i+1)
else:
	self.tag("latexBackground",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@+node:ekr.20031218072017.1612:<< handle string >>
if self.language == "python":

	delim = s[i:i+3]
	j, state = self.skip_python_string(s,i)
	if delim == '"""':
		# Only handle wiki items in """ strings.
		if not g.doHook("color-optional-markup",
			colorer=self,v=self.p,s=s,i=i,j=j,colortag="string"):
			self.tag("string",i,j)
	else:
		self.tag("string",i,j)
	i = j

else:
	j, state = self.skip_string(s,i)
	self.tag("string",i,j)
	i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
	if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
		break
	else: i += 1

self.tag("pp",j,i)
#@nonl
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
	self.tag("keyword",i,i+5)
	i += 5
elif g.match(s,i,"?>"):
	self.tag("keyword",i,i+2)
	i += 2
else:
	i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
	self.tag("blank",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
	self.tag("tab",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1896:doNormalState
#@-node:ekr.20040106145421:(not yet) PHP syntax coloring
#@+node:ekr.20031218072017.3195:splitLines & joinLines
def splitLines (s):
	
	"""Split s into lines, preserving the number of lines and the ending of the last line."""
	
	if s:
		return s.splitlines(true) # This is a Python string function!
	else:
		return []

	if 0:# Rewritten: 4/2/04.  This works, but why bother?
		if s:
			lines = s.split('\n')
			result = [line + '\n' for line in lines[:-1]]
			if s[-1] != '\n':
				result.append(lines[-1])
			return result
		else:
			return []

def joinLines (aList):
	
	return ''.join(aList)
#@nonl
#@-node:ekr.20031218072017.3195:splitLines & joinLines
#@-node:ekr.20040206075634.1:Colorizing additions
#@-node:ekr.20040403104315.2:4/2
#@+node:ekr.20040403104315.3:4/3
#@+node:ekr.20040403091954:(Problems with marking nodes in a script)
#@+node:ekr.20040403095129:Notes
@nocolor

The problem was that the calls to put in execute script were disabling the redraw.

The solution is for the execute script command always to redraw the screen.
#@nonl
#@-node:ekr.20040403095129:Notes
#@+node:ekr.20031218072017.2140:executeScript
def executeScript(self,p=None,script=None):

	"""This executes body text as a Python script.
	
	We execute the selected text, or the entire body text if no text is selected."""
	
	error = false
	c = self ; s = None

	if script:
		s = script
	else:
		<< get script into s >>
	<< redirect output if redirect_execute_script_output_to_log_pane >>
	s = s.strip()
	if s:
		s += '\n' # Make sure we end the script properly.
		try:
			exec s in {} # Use {} to get a pristine environment!
			if not script:
				g.es("end of script",color="purple")
		except:
			g.es("exception executing script")
			g.es_exception(full=false,c=c)
			c.frame.tree.redrawAfterException() # 1/26/04
	elif not error:
		g.es("no script selected",color="blue")
		
	# 4/3/04: The force a redraw _after_ all messages have been output.
	c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2142:<< get script into s >>
try:
	try:
		if not p:
			p = c.currentPosition()
	
		old_body = p.bodyString()

		if c.frame.body.hasTextSelection():
			# Temporarily replace v's body text with just the selected text.
			s = c.frame.body.getSelectedText()
			p.v.setTnodeText(s) 
		else:
			s = c.frame.body.getAllText()
	
		if s.strip():
			g.app.scriptDict["script1"]=s
			df = c.atFileCommands.new_df
			df.scanAllDirectives(p,scripting=true)
			# Force Python comment delims.
			df.startSentinelComment = "#"
			df.endSentinelComment = None
			# Write the "derived file" into fo.
			fo = g.fileLikeObject()
			df.write(p.copy(),nosentinels=true,scriptFile=fo)
			assert(p)
			s = fo.get()
			g.app.scriptDict["script2"]=s
			error = len(s) == 0
	except:
		s = "unexpected exception"
		print s ; g.es(s)
		g.es_exception()
finally:
	p.v.setTnodeText(old_body)
#@nonl
#@-node:ekr.20031218072017.2142:<< get script into s >>
#@+node:ekr.20031218072017.2143:<< redirect output if redirect_execute_script_output_to_log_pane >>
if g.app.config.redirect_execute_script_output_to_log_pane:

	from leoGlobals import redirectStdout,redirectStderr
	g.redirectStdout() # Redirect stdout
	g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output if redirect_execute_script_output_to_log_pane >>
#@-node:ekr.20031218072017.2140:executeScript
#@-node:ekr.20040403091954:(Problems with marking nodes in a script)
#@-node:ekr.20040403104315.3:4/3
#@+node:ekr.20040409081506:4/8
#@+node:ekr.20040106115311:* Expanding the +- box
#@+node:ekr.20040409074345:Notes
@nocolor

https://sourceforge.net/forum/message.php?msg_id=2361036
By: jasonic

I just had a great user interface idea to improve Leo tree behavior. 

The most common tree node clicking task people do is expand or contract by clicking
on the little +/- squares.

But why should one have such a small target?
HCI research studies have all shown one can improve interfaces just  by making
target areas as large as possible in ebery case. Preceise hand eye skills shoudl
not be squandered especially for repetitive tasks.

So in Leo's case one could make the target for each node exactly one line high,
and as wide as the entire pane. This could be an active rollover with a highlight
color. then single clicking would expand/contract that node.

The exception would be when you want to rename a node. Then clicking directly
on the name itself would only affect the name to make it editable as now.

Enhancements would be use of modifier Keys to alter the expand/contract nodeclick
behavior.

Ctrl+click would apply expand/contract one nested level down in that node.

Shift+click would apply expand/contract to all nested levels in that node.

Holding a number keyclick wouldapply/contract to the same number of nested levelsin
that node.
3+node click would affect 3 nested levels 
5+node click would affect  5 nested levels
etc.

I've mocked up a tiny flash version to help you explore the rollover idea yourselves.
In my minimal demo, the only active node "4.1 final".

Click on it and you can se how they could all work. Rollover the text and you
can see how that area could catch focus into editing. Colors are a little dull,
but they would be set all by preferences anyway.
[Also, complex clicking is not enabled in the this demo either. I'll play more
with it later when I have time and after some feedback. This direction is prelim
to my LeoFlashJabber project for 2004

http://tranzilla.net/leo/swf/tree_ui_idea_000.html

#@-node:ekr.20040409074345:Notes
#@+node:ekr.20031218072017.2339:OnBoxClick
# Called on click in box and double-click in headline.

def OnBoxClick (self,p):
	
	# g.trace(p)

	# Note: "boxclick" hooks handled by vnode callback routine.
	c = self.c ; gui = g.app.gui

	if p.isExpanded(): p.contract()
	else:              p.expand()

	self.active = true
	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	gui.set_focus(c,c.frame.bodyCtrl) # 7/12/03
	self.redraw()
#@nonl
#@-node:ekr.20031218072017.2339:OnBoxClick
#@+node:ekr.20031218072017.1019:tree.select
# Warning: do not try to "optimize" this by returning if v==tree.currentVnode.

def select (self,p,updateBeadList=true):

	if not p: return
	
	<< define vars and stop editing >>
	
	# g.trace(p)

	if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
		<< unselect the old node >>
	else: old_body = u""

	g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
	
	if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
		<< select the new node >>
		if p and p != old_p: # 3/26/03: Suppress duplicate call.
			try: # may fail during initialization
				self.idle_scrollTo(p)
			except: pass
		<< update c.beadList or c.beadPointer >>
		<< update c.visitedList >>

	<< set the current node >>
	
	g.doHook("select2",c=c,new_v=p,old_v=old_p)
	g.doHook("select3",c=c,new_v=p,old_v=old_p)
#@nonl
#@+node:ekr.20031218072017.1020:<< define vars and stop editing >>
c = self.c
frame = c.frame ; body = frame.bodyCtrl

old_p = c.currentPosition()

# Unselect any previous selected but unedited label.
self.endEditLabel()
self.setUnselectedLabelState(old_p)
#@nonl
#@-node:ekr.20031218072017.1020:<< define vars and stop editing >>
#@+node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

# Remember the old body text
old_body = body.get("1.0","end")

if old_p and old_p != p:
	# g.trace("different node")
	self.endEditLabel()
	self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
	old_p.v.t.scrollBarSpot = yview
	old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20031218072017.1021:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20031218072017.1022:<< select the new node >>
frame.setWrap(p)

# Delete only if necessary: this may reduce flicker slightly.
s = p.v.t.bodyString
s = g.toUnicode(s,"utf-8")
old_body = g.toUnicode(old_body,"utf-8")
if old_body != s:
	body.delete("1.0","end")
	body.insert("1.0",s)
	
# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p)

if p.v and p.v.t.scrollBarSpot != None:
	first,last = p.v.t.scrollBarSpot
	body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
	c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
	c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
	c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20031218072017.1022:<< select the new node >>
#@+node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
if updateBeadList:
	
	if c.beadPointer > -1:
		present_p = c.beadList[c.beadPointer]
	else:
		present_p = c.nullPosition()
	
	if p != present_p:
		# Replace the tail of c.beadList by c and make c the present node.
		# print "updating c.beadList"
		c.beadPointer += 1
		c.beadList[c.beadPointer:] = []
		c.beadList.append(p)
		
	# g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20031218072017.1023:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20031218072017.1024:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
	c.visitedList.remove(p)

c.visitedList.insert(0,p)
#@nonl
#@-node:ekr.20031218072017.1024:<< update c.visitedList >>
#@+node:ekr.20031218072017.1025:<< set the current node >>
self.c.setCurrentPosition(p)
self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.1025:<< set the current node >>
#@-node:ekr.20031218072017.1019:tree.select
#@+node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
def OnIconClick (self,p,event):
	
	# g.trace(p)
	
	p = p.copy() # Make sure callbacks use the _present_ position.

	tree = self ; canvas = tree.canvas
	if event:
		canvas_x = canvas.canvasx(event.x)
		canvas_y = canvas.canvasy(event.y)
		id = canvas.find_closest(canvas_x,canvas_y)
		if id != None:
			try: id = id[0]
			except: pass
			self.drag_p = p
			self.drag_id = id
			
			# Create the bindings.
			id4 = canvas.tag_bind(id,"<B1-Motion>", p.OnDrag)
			id5 = canvas.tag_bind(id,"<Any-ButtonRelease-1>", p.OnEndDrag)
			
			# Remember the bindings so deleteBindings can delete them.
			self.tagBindings.append((id,id4,"<B1-Motion>"),)
			self.tagBindings.append((id,id5,"<Any-ButtonRelease-1>"),)
	tree.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	return "break" # disable expanded box handling.
	
def OnIconRightClick (self,p,event):

	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
#@+node:ekr.20031218072017.1000:drawBox (tag_bind)
def drawBox (self,p,x,y):

	y += 7 # draw the box at x, y+7
	h = self.line_height

	tree = self
	iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
	image = self.getIconImage(iconname)
	id = self.canvas.create_image(x,y+self.lineyoffset,image=image)
	
	if 1: # New in 4.2.  Create a frame to catch all clicks.
		id4 = self.canvas.create_rectangle(0,y-7,1000,y-7+h-3)
		color = ""
		self.canvas.itemconfig(id4,fill=color,outline=color)
		self.canvas.lower(id4)
		id3 = self.canvas.tag_bind(id4, "<1>", p.OnBoxClick)
		self.tagBindings.append((id,id3,"<1>"),)

	id1 = self.canvas.tag_bind(id, "<1>", p.OnBoxClick)
	id2 = self.canvas.tag_bind(id, "<Double-1>", lambda x: None)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
#@-node:ekr.20031218072017.1000:drawBox (tag_bind)
#@+node:ekr.20031218072017.1002:drawIcon (tag_bind)
def drawIcon(self,p,x=None,y=None):
	
	"""Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

	tree = self
	
	# Make sure the bindings refer to the _present_ position.
	v = p.v

	if x is None and y is None:
		try:
			x,y = v.iconx, v.icony
		except:
			# Inject the ivars.
			x,y = v.iconx, v.icony = 0,0
	else:
		# Inject the ivars.
		v.iconx, v.icony = x,y

	y += 2 # draw icon at y + 2

	# Always recompute v.iconVal.
	# This is an important drawing optimization.
	val = v.iconVal = v.computeIcon()
	assert(0 <= val <= 15)

	# Get the image.
	imagename = "box%02d.GIF" % val
	image = self.getIconImage(imagename)
	id = self.canvas.create_image(x,y+self.lineyoffset,anchor="nw",image=image)
	self.icon_id_dict[id] = p # Remember which vnode belongs to the icon.

	id1 = self.canvas.tag_bind(id,"<1>",p.OnIconClick)
	id2 = self.canvas.tag_bind(id,"<Double-1>",p.OnIconDoubleClick)
	id3 = self.canvas.tag_bind(id,"<3>",p.OnIconRightClick)
	
	# Remember the bindings so deleteBindings can delete them.
	self.tagBindings.append((id,id1,"<1>"),)
	self.tagBindings.append((id,id2,"<Double-1>"),)
	self.tagBindings.append((id,id3,"<3>"),)

	return 0,icon_width # dummy icon height,width
#@nonl
#@-node:ekr.20031218072017.1002:drawIcon (tag_bind)
#@-node:ekr.20040106115311:* Expanding the +- box
#@+node:ekr.20040409080127:(Fixed failed assert in undo)
@nocolor

I dragged the root node down, then did undo.

exception executing command
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 135, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 800, in undo
    assert(u.p.hasParent())

AssertionError

C:\prog\leoCVS\leo>

@color
#@nonl
#@+node:ekr.20031218072017.2035:<< redo move & drag cases >>
elif redoType in ["Drag","Move Down","Move Left","Move Right","Move Up"]:

	# g.trace(u.p)
	if u.parent:
		u.p.moveToNthChildOf(u.parent,u.n)
	elif u.back:
		u.p.moveAfter(u.back)
	else:
		oldRoot = c.rootPosition() # Bug fix: 4/9/04
		u.p.moveToRoot(oldRoot)

	c.selectVnode(u.p)
	
elif redoType == "Drag":

	u.p.moveToNthChildOf(u.parent,u.n)
	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2035:<< redo move & drag cases >>
#@+node:ekr.20031218072017.2044:<< undo move  & drag cases >>
elif undoType in ["Drag", "Move Down","Move Left","Move Right","Move Up"]:

	# g.trace("oldParent",u.oldParent)

	if u.oldParent:
		u.p.moveToNthChildOf(u.oldParent,u.oldN)
	elif u.oldBack:
		u.p.moveAfter(u.oldBack)
	else:
		oldRoot = c.rootPosition() # Bug fix: 4/9/04
		u.p.moveToRoot(oldRoot)

	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2044:<< undo move  & drag cases >>
#@-node:ekr.20040409080127:(Fixed failed assert in undo)
#@+node:ekr.20040409081506.1:(Assert failed in lastVisible)
#@+node:ekr.20040409081716:Traceback
@nocolor

goToLineNumber: u'leoUndo.py' <pos 38659536 lvl: 2 [0] @file leoUndo.py>
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 965, in idle_scrollTo

  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1780, in lastVisible
    assert(p.isVisible())

AssertionError

--------

I'm not sure what caused this.  I added some defensive code in idle_scrollTo.
#@nonl
#@-node:ekr.20040409081716:Traceback
#@+node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
def oldLastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	assert(p.isVisible())
	last = p.copy()
	while 1:
		if g.app.debug: g.trace(last)
		p.moveToVisNext()
		if not p: return last
		last = p.copy()
		
def lastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	# Move to the last top-level node.
	while p.hasNext():
		if g.app.debug: g.trace(p)
		p.moveToNext()
	assert(p.isVisible())
	# Move to the last visible child.
	while p.hasChildren() and p.isExpanded():
		if g.app.debug: g.trace(p)
		p.moveToLastChild()
	assert(p.isVisible())
	if g.app.debug: g.trace(p)
	return p
#@nonl
#@-node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
#@+node:ekr.20040117162509.16:p.isVisible
def isVisible (self):
	
	"""Return true if all of a position's parents are expanded."""

	# v.isVisible no longer exists.
	p = self

	# Avoid calling p.copy() or copying the stack.
	v = p.v ; n = len(p.stack)-1

	v,n = p.vParentWithStack(v,p.stack,n)
	while v:
		if not v.isExpanded():
			return false
		v,n = p.vParentWithStack(v,p.stack,n)

	return true
#@nonl
#@-node:ekr.20040117162509.16:p.isVisible
#@+node:ekr.20031218072017.1018:tree.idle_scrollTo
def idle_scrollTo(self,p=None):

	"""Scrolls the canvas so that v is in view.
	
	This is done at idle time after a redraw so that treeBar.get() will return proper values."""

	c = self.c ; frame = c.frame
	if not p: p = self.c.currentPosition()
	if not p: p = self.c.rootPosition() # 4/8/04.
	try:
		last = p.lastVisible()
		nextToLast = last.visBack()
		h1 = self.yoffset(p)
		h2 = self.yoffset(last)
		<< compute approximate line height >>
		<< Compute the fractions to scroll down/up >>
		if frac <= lo:
			if self.prevMoveToFrac != frac:
				self.prevMoveToFrac = frac
				self.canvas.yview("moveto",frac)
		elif frac2 + (hi - lo) >= hi:
			if self.prevMoveToFrac != frac2:
				self.prevMoveToFrac = frac2
				self.canvas.yview("moveto",frac2)

		if self.allocateOnlyVisibleNodes:
			self.canvas.after_idle(self.idle_second_redraw)
			
		c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
		# print "%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi)
	except:
		g.es_exception()
#@nonl
#@+node:ekr.20040314092716:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
	lineHeight = h2 - self.yoffset(nextToLast)
else:
	lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040314092716:<< compute approximate line height >>
#@+node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
	frac = float(h1)/float(h2) # For scrolling down.
	frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
	frac2 = frac2 - (hi - lo)
else:
	frac = frac2 = 0.0 # probably any value would work here.
	
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040314092716.1:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20031218072017.1018:tree.idle_scrollTo
#@-node:ekr.20040409081506.1:(Assert failed in lastVisible)
#@-node:ekr.20040409081506:4/8
#@+node:ekr.20040411091047:4/11
#@+node:ekr.20040411081633.1:(Installed psyco & added use_psyco option)
#@+node:ekr.20031218072017.2140:executeScript
def executeScript(self,p=None,script=None):

	"""This executes body text as a Python script.
	
	We execute the selected text, or the entire body text if no text is selected."""
	
	error = false
	c = self ; s = None

	if script:
		s = script
	else:
		<< get script into s >>
	<< redirect output if redirect_execute_script_output_to_log_pane >>
	s = s.strip()
	if s:
		s += '\n' # Make sure we end the script properly.
		try:
			exec s in {} # Use {} to get a pristine environment!
			if not script:
				g.es("end of script",color="purple")
		except:
			g.es("exception executing script")
			g.es_exception(full=false,c=c)
			c.frame.tree.redrawAfterException() # 1/26/04
	elif not error:
		g.es("no script selected",color="blue")
		
	# 4/3/04: The force a redraw _after_ all messages have been output.
	c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2142:<< get script into s >>
try:
	try:
		if not p:
			p = c.currentPosition()
	
		old_body = p.bodyString()

		if c.frame.body.hasTextSelection():
			# Temporarily replace v's body text with just the selected text.
			s = c.frame.body.getSelectedText()
			p.v.setTnodeText(s) 
		else:
			s = c.frame.body.getAllText()
	
		if s.strip():
			g.app.scriptDict["script1"]=s
			df = c.atFileCommands.new_df
			df.scanAllDirectives(p,scripting=true)
			# Force Python comment delims.
			df.startSentinelComment = "#"
			df.endSentinelComment = None
			# Write the "derived file" into fo.
			fo = g.fileLikeObject()
			df.write(p.copy(),nosentinels=true,scriptFile=fo)
			assert(p)
			s = fo.get()
			g.app.scriptDict["script2"]=s
			error = len(s) == 0
	except:
		s = "unexpected exception"
		print s ; g.es(s)
		g.es_exception()
finally:
	p.v.setTnodeText(old_body)
#@nonl
#@-node:ekr.20031218072017.2142:<< get script into s >>
#@+node:ekr.20031218072017.2143:<< redirect output if redirect_execute_script_output_to_log_pane >>
if g.app.config.redirect_execute_script_output_to_log_pane:

	from leoGlobals import redirectStdout,redirectStderr
	g.redirectStdout() # Redirect stdout
	g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output if redirect_execute_script_output_to_log_pane >>
#@-node:ekr.20031218072017.2140:executeScript
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
	
	"""Initialize and run Leo"""
	
	if not isValidPython(): return
	# Import leoGlobals, but do NOT set g.
	import leoGlobals
	from leoGlobals import true,false
	# Create the application object.
	import leoApp ; leoGlobals.app = leoApp.LeoApp()
	g = leoGlobals ; assert(g.app) # NOW we can set g.
	g.app.loadDir = computeLoadDir() # Depends on g.app.tkEncoding: uses utf-8 for now.
	import leoConfig
	g.app.config = leoConfig.config()
	g.app.setEncoding() # 10/20/03: do this earlier
	script = getBatchScript()
	if script:
		createNullGuiWithScript(script)
		fileName = None
	else:
		<< print encoding info >>
	# Load plugins. Plugins may create g.app.gui.
	g.doHook("start1")
	if g.app.killed: return # Support for g.app.forceShutdown.
	# Create the default gui if needed.
	if g.app.gui == None:
		g.app.createTkGui()
	if g.app.use_gnx:
		if not g.app.leoID: g.app.setLeoID() # Forces the user to set g.app.leoID.
		import leoNodes
		g.app.nodeIndices = leoNodes.nodeIndices()
	# Initialize tracing and statistics.
	g.init_sherlock(args)
	g.clear_stats()
	<< start psycho >>
	# Create the main frame.  Show it and all queued messages.
	c,frame = createFrame(fileName)
	if not frame: return
	if g.app.disableSave:
		g.es("disabling save commands",color="red")
	g.app.writeWaitingLog()
	v = c.currentVnode()
	g.doHook("start2",c=c,v=v,fileName=fileName)
	frame.tree.redraw()
	frame.body.setFocus()
	g.app.initing = false # "idle" hooks may now call g.app.forceShutdown.
	g.app.gui.runMainLoop()
#@+node:ekr.20040411081633:<< start psycho >>
if g.app.config.use_psyco:
	try:
		import psyco
		if 0:
			file = r"c:\prog\test\psycoLog.txt"
			g.es("psyco now logging to",file,color="blue")
			psyco.log(file)
			psyco.profile()
		psyco.full()
		g.es("psyco now running",color="blue")
	except ImportError:
		pass
	except:
		print "unexpected exception importing psyco"
		g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1935:<< print encoding info >>
g.es("leoConfig.txt encoding: " + g.app.config.config_encoding, color="blue")

if 0: # This is just confusing for users.
	g.es("Text encoding: " + g.app.tkEncoding, color="blue")
#@nonl
#@-node:ekr.20031218072017.1935:<< print encoding info >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	message = """\
Leo requires Python 2.2 or higher.
You may download Python 2.2 and Python 2.3 from http://python.org/download/
"""
	try:
		if not g.CheckVersion(sys.version, "2.2"):
			g.app.gui.runAskOkDialog("Python version error",message=message,text="Exit")
			return false
		else:
			return true
	except:
		print "exception getting Python version"
		import traceback ; traceback.print_exc()
		return false
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
	
	"""Returns the directory containing leo.py."""
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	# g.trace(g.app.tkEncoding)
	
	try:
		import leo
		path = g.os_path_abspath(leo.__file__)

		if sys.platform=="win32": # "mbcs" exists only on Windows.
			path = g.toUnicode(path,"mbcs")
		elif sys.platform=="dawwin":
			path = g.toUnicode(path,"utf-8")
		else:
			path = g.toUnicode(path,g.app.tkEncoding)

		if path:
			loadDir = g.os_path_dirname(path)
		else:
			loadDir = None
		if not loadDir:
			loadDir = g.os_path_abspath(os.getcwd())
			print "Using emergency loadDir:",repr(loadDir)

		encoding = g.choose(sys.platform=="dawwin","utf-8",g.app.tkEncoding) # 11/18/03
		loadDir = g.toUnicode(loadDir,encoding) # 10/20/03
		return loadDir
	except:
		print "Exception getting load directory"
		import traceback ; traceback.print_exc()
		return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
	
	"""Create a LeoFrame during Leo's startup process."""
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	# g.trace(g.app.tkEncoding,fileName)
	
	# Try to create a frame for the file.
	if fileName:
		fileName = g.os_path_join(os.getcwd(),fileName)
		fileName = g.os_path_normpath(fileName)
		if g.os_path_exists(fileName):
			ok, frame = g.openWithFileName(fileName,None)
			if ok:
				return frame.c,frame
	
	# Create a new frame & indicate it is the startup window.
	c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
	frame.setInitialWindowGeometry()
	frame.startupWindow = true
	
	# Report the failure to open the file.
	if fileName:
		g.es("File not found: " + fileName)

	return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
	
	import leoGlobals as g
	from leoGlobals import true,false
	import leoGui
	
	g.app.batchMode = true
	g.app.gui = leoGui.nullGui("nullGui")
	g.app.root = g.app.gui.createRootWindow()
	g.app.gui.finishCreate()
	g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
	
	import leoGlobals as g
	from leoGlobals import true,false
	
	name = None ; i = 1 # Skip the dummy first arg.
	while i + 1 < len(sys.argv):
		arg = sys.argv[i].strip().lower()
		if arg in ("--script","-script"):
			name = sys.argv[i+1].strip() ; break
		i += 1

	if not name: return None	
	name = g.os_path_join(g.app.loadDir,name)
	try:
		f = None
		try:
			f = open(name,'r')
			script = f.read()
			# g.trace("script",script)
		except IOError:
			g.es("can not open script file: " + name, color="red")
			script = None
	finally:
		if f: f.close()
		return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@-node:ekr.20031218072017.1934:run & allies
#@-node:ekr.20040411081633.1:(Installed psyco & added use_psyco option)
#@-node:ekr.20040411091047:4/11
#@+node:ekr.20040412061129:4/12
#@+node:ekr.20040412061129.1:Created Dump Outline command
#@-node:ekr.20040412061129.1:Created Dump Outline command
#@+node:ekr.20040409083211:(Fixed problems deleting cloned nodes & trees)
#@+node:ekr.20040409083211.1:tracebacks
@nocolor

This happened when deleting a clone (the first child of its parent)

  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1861, in write_Leo_file
    self.putVnodes()

  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1683, in putVnodes
    self.putVnode(p) # Write the next top-level node.

  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1660, in putVnode
    p.moveToParent()

  File "C:\prog\leoCVS\leo\src\leoNodes.py", line 2762, in moveToParent
    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:

AttributeError: 'NoneType' object has no attribute '_parent'

>>>

----  Deleted (@file-thin) clone, then did Check Outline.

7536 nodes checked, 0 errors
test failed: oldLastVisible==lastVisible <pos 29196336 lvl: 0 [0]  Diary>

1 nodes checked, 1 errors
>>>
#@nonl
#@-node:ekr.20040409083211.1:tracebacks
#@+node:ekr.20040409160021:Notes
@nocolor

This was a tricky one.  Normally, when a node is unlinked it is immediately relinked, so the _parent field of all its children need not change.  The exception is when we are actually deleting a cloned node.  In that case:

a) Another node (it was a clone, it may still be a clone) will refer to the shared tree.
b) We must reassign the _parent field of all children of the deleted node.

Rather than mess with unlink, I put the new code in p.doDelete.

While I was at it, I improved the p.dump method.

By luck I realized that unlinking a tree leaves most vnodeLists unchanged.  They must be cleared by doDelete and restored in the corresponding undo/redo methods.

----

Most code now works.  However, moving a node right destroyed part of the outline...
#@nonl
#@-node:ekr.20040409160021:Notes
#@+node:ekr.20040409130322:commands & fileCommands methods...
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,op_name="Delete Node"):
	
	"""Deletes the current position.
	
	Does nothing if the outline would become empty."""

	c = self ; p = c.currentPosition()
	if not p: return
	# If vBack is NULL we are at the top level,
	# the next node should be v.next(), _not_ v.visNext();
	if p.hasVisBack(): newNode = p.visBack()
	else:              newNode = p.next()
	if not newNode: return

	c.endEditing() # Make sure we capture the headline for Undo.
	c.beginUpdate()
	if 1: # update...
		p.setAllAncestorAtFileNodesDirty()
		c.undoer.setUndoParams(op_name,p,select=newNode)
		p.doDelete(newNode)
		c.setChanged(true)
	c.endUpdate()
	c.validateOutline()
#@nonl
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=true,unittest=false):
	
	"""Report any possible clone errors in the outline.
	
	Remove any unused tnodeLists."""
	
	c = self ; count = 1 ; errors = 0 ; full = true
	if full and not unittest:
		g.es("all tests enabled: this may take awhile",color="blue")

	try:
		p = c.rootPosition()
		<< assert equivalence of lastVisible methods >>
		for p in c.allNodes_iter():
			count += 1
			<< remove unused tnodeList >>
			if not unittest: # this would be very slow.
				if full: # For testing only.
					<< do full tests >>
			# assert false, "checkFailed" # check of checkFailed itself.
	except AssertionError,message:
		errors += 1
		<< give test failed message >>
	if not unittest:
		<< print summary message >>
	return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
	g.app.debug = true

	p1 = p.oldLastVisible()
	p2 = p.lastVisible()
	
	if p1 != p2:
		print "oldLastVisible",p1
		print "   lastVisible",p2
	
	assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
	assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
	
	g.app.debug = false
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v
# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
	s = "deleting tnodeList for " + repr(v)
	print s ; g.es(s,color="blue")
	delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if count % 100 == 0:
	g.es('.',newline=false)
if count % 2000 == 0:
	g.enl()

@others
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
	assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
	assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
	assert p == back.next(), "p==back.next"
		
if next:
	assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and chiild links
if p.hasParent():
	n = p.childIndex()
	assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
	
for child in p.children_iter():
	assert p == child.parent(), "p==child.parent"

if p.hasNext():
	assert p.next().parent() == p.parent(), "next.parent==parent"
	
if p.hasBack():
	assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and chiild links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
	t = p.parent().v.t
	for v in p.directParents():
		assert(v.t == t)
#@nonl
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
	parents = p.v.t.vnodeList
	for child in p.children_iter():
		vparents = child.directParents()
		assert(len(parents) == len(vparents))
		for parent in parents:
			assert(parent in vparents)
		for parent in vparents:
			assert(parent in parents)
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
	childv = p.firstChild().v
	assert(childv == p.v.t._firstChild)
	assert(id(childv) == id(p.v.t._firstChild))
	for v in p.v.t.vnodeList:
		assert(v.t._firstChild == childv)
		assert(id(v.t._firstChild) == id(childv))
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
	
for v in vnodeList:
	
	assert v.t == p.v.t, "v.t == p.v.t"

	if p.v.isCloned():
		assert v.isCloned(), "v.isCloned"
		assert len(vnodeList) > 1, "len(vnodeList) > 1"
	else:
		assert not v.isCloned(), "not v.isCloned"
		assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
	print
	g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
	print s ; g.es(s,color="red")
elif verbose:
	g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@+node:ekr.20040314044652:<< give test failed message >>
if errors == 1:
	s = "test failed: %s %s" % (message,repr(p))
	print s
	g.es(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@+node:ekr.20040412060927:c.dumpOutline
def dumpOutline (self):
	
	""" Dump all nodes in the outline."""
	
	c = self

	for p in c.allNodes_iter():
		p.dump()
#@nonl
#@-node:ekr.20040412060927:c.dumpOutline
#@-node:ekr.20040409130322:commands & fileCommands methods...
#@+node:ekr.20040312145256:v.dump
def dumpLink (self,link):
	return g.choose(link,link,"<none>")

def dump (self,label=""):
	
	v = self

	if label:
		print '-'*10,label,v
	else:
		print "self    ",v.dumpLink(v)
		print "len(vnodeList)",len(v.t.vnodeList)
	print "_back   ",v.dumpLink(v._back)
	print "_next   ",v.dumpLink(v._next)
	print "_parent ",v.dumpLink(v._parent)
	print "t._child",v.dumpLink(v.t._firstChild)
#@nonl
#@-node:ekr.20040312145256:v.dump
#@+node:ekr.20040409130322.2:position methods ...
#@+node:ekr.20040310062332:p.Link/Unlink methods
# These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.
#@nonl
#@+node:ekr.20040310062332.1:p.invalidOutline
def invalidOutline (self, message):
	
	p = self

	if p.hasParent():
		node = p.parent()
	else:
		node = p

	g.alert("invalid outline: %s\n%s" % (message,node))
#@nonl
#@-node:ekr.20040310062332.1:p.invalidOutline
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

	"""Link self after v."""
	
	p = self
	# g.trace(p,after)
	
	p.stack = after.stack[:] # 3/12/04
	p.v._parent = after.v._parent
	
	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
	
	p.v._back = after.v
	p.v._next = after.v._next
	
	after.v._next = p.v
	
	if p.v._next:
		p.v._next._back = p.v

	if 0:
		g.trace('-'*20,after)
		p.dump(label="p")
		after.dump(label="back")
		if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20040310062332.3:p.linkAsNthChild
def linkAsNthChild (self,parent,n):

	"""Links self as the n'th child of vnode pv"""
	
	# g.trace(self,parent,n)
	p = self

	# Recreate the stack using the parent.
	p.stack = parent.stack[:] 
	if parent.isCloned():
		p.stack.append(parent.v)

	p.v._parent = parent.v

	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)

	if n == 0:
		child1 = parent.v.t._firstChild
		p.v._back = None
		p.v._next = child1
		if child1:
			child1._back = p.v
		parent.v.t._firstChild = p.v
	else:
		prev = parent.nthChild(n-1) # zero based
		assert(prev)
		p.v._back = prev.v
		p.v._next = prev.v._next
		prev.v._next = p.v
		if p.v._next:
			p.v._next._back = p.v
			
	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.3:p.linkAsNthChild
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link self as the root node."""
	
	# g.trace(self,oldRoot)

	p = self ; v = p.v
	if oldRoot: oldRootVnode = oldRoot.v
	else:       oldRootVnode = None
	
	p.stack = [] # Clear the stack.
	
	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRootVnode # Bug fix: 3/12/04
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot:
		oldRoot.v._back = v # Bug fix: 3/12/04

	p.c.setRootPosition(p)
	
	if 0:
		p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

	"""Unlinks a position p from the tree before moving or deleting.
	
	The p.v._fistChild link does NOT change."""

	p = self ; v = p.v ; parent = p.parent()
	
	# Note:  p.parent() is not necessarily the same as v._parent.
	
	if parent:
		assert(p.v and p.v._parent in p.v.directParents())
		assert(parent.v in p.v.directParents())

	# g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
	
	# Special case the root.
	if p == p.c.rootPosition():
		assert(p.v._next)
		p.c.setRootPosition(p.next())
	
	# Remove v from it's tnode's vnodeList.
	vnodeList = v.t.vnodeList
	if v in vnodeList:
		vnodeList.remove(v)
	assert(v not in vnodeList)
	
	# Reset the firstChild link in its direct father.
	if parent and parent.v.t._firstChild == v:
		parent.v.t._firstChild = v._next

	# Do _not_ delete the links in any child nodes.

	# Clear the links in other nodes.
	if v._back: v._back._next = v._next
	if v._next: v._next._back = v._back

	# Unlink _this_ node.
	v._parent = v._next = v._back = None

	if 0:
		g.trace('-'*20)
		p.dump(label="p")
		if parent: parent.dump(label="parent")
#@-node:ekr.20040310062332.5:p.unlink
#@-node:ekr.20040310062332:p.Link/Unlink methods
#@+node:ekr.20040303175026.2:p.doDelete
@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

	"""Deletes position p from the outline.  May be undone.

	Returns newPosition."""

	p = self ; c = p.c

	assert(newPosition != p)
	p.setDirty() # Mark @file nodes dirty!
	p.unlink()
	p.deleteLinksInTree()
	c.selectVnode(newPosition)
	
	return newPosition

#@-node:ekr.20040303175026.2:p.doDelete
#@+node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
def oldLastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	assert(p.isVisible())
	last = p.copy()
	while 1:
		if g.app.debug: g.trace(last)
		p.moveToVisNext()
		if not p: return last
		last = p.copy()
		
def lastVisible(self):
	"""Move to the last visible node of the entire tree."""
	p = self.c.rootPosition()
	# Move to the last top-level node.
	while p.hasNext():
		if g.app.debug: g.trace(p)
		p.moveToNext()
	assert(p.isVisible())
	# Move to the last visible child.
	while p.hasChildren() and p.isExpanded():
		if g.app.debug: g.trace(p)
		p.moveToLastChild()
	assert(p.isVisible())
	if g.app.debug: g.trace(p)
	return p
#@nonl
#@-node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
#@+node:ekr.20040310153624:p.dump & p.vnodeListIds
def dumpLink (self,link):

	return g.choose(link,link,"<none>")

def dump (self,label=""):
	
	p = self

	print '-'*10,label,p

	if p.v:
		p.v.dump() # Don't print a label
		
def vnodeListIds (self):
	
	p = self
	return [id(v) for v in p.v.t.vnodeList]
#@nonl
#@-node:ekr.20040310153624:p.dump & p.vnodeListIds
#@+node:ekr.20040228094013.1:p.utils...
#@+node:ekr.20040117171654:p.copy
# Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
	
	""""Return an independent copy of a position."""
	
	g.app.copies += 1

	return position(self.v,self.stack)
#@nonl
#@-node:ekr.20040117171654:p.copy
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
	
	"""A utility that allows the computation of p.v without calling p.copy().
	
	v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

	Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

	if not v:
		return None,n
	elif v._parent and len(v._parent.t.vnodeList) == 1:
		return v._parent,n # don't change stack.
	elif stack and n >= 0:
		return self.stack[n],n-1 # simulate popping the stack.
	else:
		return None,n
#@nonl
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
	p = p.moveToParent()
	if p: list1.append(p.v)
# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
	list2.append(v)
	v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@+node:ekr.20040409203454:p.restoreLinksInTree
def restoreLinksInTree (self):

	"""Restore links when undoing a delete node operation."""
	
	root = p = self

	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
		
	for p in root.children_iter():
		p.restoreLinksInTree()
#@nonl
#@-node:ekr.20040409203454:p.restoreLinksInTree
#@+node:ekr.20040409203454.1:p.deleteLinksInTree & allies
def deleteLinksInTree (self):
	
	"""Delete and otherwise adjust links when deleting node."""
	
	root = self

	root.deleteLinksInSubtree()
	
	for p in root.children_iter():
		p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@+node:ekr.20040410170806:p.deleteLinksInSubtree
def deleteLinksInSubtree (self):

	root = p = self

	# Delete p.v from the vnodeList
	if p.v in p.v.t.vnodeList:
		p.v.t.vnodeList.remove(p.v)
		assert(p.v not in p.v.t.vnodeList)
		# g.trace("deleted",p.v,p.vnodeListIds())
	else:
		# g.trace("not in vnodeList",p.v,p.vnodeListIds())
		pass

	if len(p.v.t.vnodeList) == 0:
		# This node is not shared by other nodes.
		for p in root.children_iter():
			p.deleteLinksInSubtree()
#@nonl
#@-node:ekr.20040410170806:p.deleteLinksInSubtree
#@+node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
def adjustParentLinksInSubtree (self,parent):
	
	root = p = self
	
	assert(parent)
	
	if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
		p.v._parent = parent.v.t.vnodeList[0]
		
	for p in root.children_iter():
		p.adjustParentLinksInSubtree(parent=root)
#@nonl
#@-node:ekr.20040410170806.1:p.adjustParentLinksInSubtree
#@-node:ekr.20040409203454.1:p.deleteLinksInTree & allies
#@-node:ekr.20040228094013.1:p.utils...
#@-node:ekr.20040409130322.2:position methods ...
#@+node:ekr.20040409163052:Undo
#@+node:ekr.20031218072017.2034:<< redo insert cases >>
elif redoType in ["Import","Insert Node","Paste Node"]:

	if u.back:
		u.p.linkAfter(u.back)
	elif u.parent:
		u.p.linkAsNthChild(u.parent,0)
	else:
		oldRoot = c.rootPosition()
		u.p.linkAsRoot(oldRoot)
		
	# Restore all vnodeLists (and thus all clone marks).
	u.p.restoreLinksInTree()

	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2034:<< redo insert cases >>
#@+node:ekr.20031218072017.2041:<< undo delete cases >>
@ Deleting a clone is _not_ the same as undoing a clone:
the clone may have been moved, so there is no necessary relationship between the two nodes.
@c

elif undoType == "Delete Node" or undoType == "Cut Node":
	
	if u.back:
		u.p.linkAfter(u.back)
	elif u.parent:
		u.p.linkAsNthChild(u.parent,0)
	else:
		oldRoot = c.rootPosition()
		u.p.linkAsRoot(oldRoot)
		
	# Restore all vnodeLists (and thus all clone marks).
	u.p.restoreLinksInTree()

	c.selectVnode(u.p)
#@nonl
#@-node:ekr.20031218072017.2041:<< undo delete cases >>
#@-node:ekr.20040409163052:Undo
#@-node:ekr.20040409083211:(Fixed problems deleting cloned nodes & trees)
#@-node:ekr.20040412061129:4/12
#@+node:ekr.20040414073612:4/14
#@+node:ekr.20040414073612.1:Fixed several minor bugs in Tangle logic
#@-node:ekr.20040414073612.1:Fixed several minor bugs in Tangle logic
#@-node:ekr.20040414073612:4/14
#@+node:EKR.20040422101256:4/22
#@+node:EKR.20040422101256.1:changed v=v to p=v in some calls to scanDirectives
#@-node:EKR.20040422101256.1:changed v=v to p=v in some calls to scanDirectives
#@+node:EKR.20040422130619.1:(Added ResizeToScreen command)
#@+node:ekr.20031218072017.3979:Gui-dependent commands
#@+node:ekr.20031218072017.3980:Edit Menu...
#@+node:ekr.20031218072017.3981:abortEditLabelCommand
def abortEditLabelCommand (self):
	
	frame = self ; c = frame.c ; v = c.currentVnode() ; tree = frame.tree
	
	if g.app.batchMode:
		c.notValidInBatchMode("Abort Edit Headline")
		return

	if self.revertHeadline and v.edit_text() and v == tree.editPosition():
	
		v.edit_text().delete("1.0","end")
		v.edit_text().insert("end",self.revertHeadline)
		tree.idle_head_key(v) # Must be done immediately.
		tree.revertHeadline = None
		tree.select(v)
		if v and len(v.t.vnodeList) > 0:
			tree.force_redraw() # force a redraw of joined headlines.
#@nonl
#@-node:ekr.20031218072017.3981:abortEditLabelCommand
#@+node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
def OnCut (self,event=None):
	
	"""The handler for the virtual Cut event."""

	frame = self ; c = frame.c ; v = c.currentVnode()
	
	# This is probably being subverted by Tk.
	if g.app.gui.win32clipboard:
		data = frame.body.getSelectedText()
		if data:
			g.app.gui.replaceClipboardWith(data)

	# Activate the body key handler by hand.
	frame.body.forceFullRecolor()
	frame.body.onBodyWillChange(v,"Cut")

def OnCutFromMenu (self):
	
	w = self.getFocus()
	w.event_generate(g.virtual_event_name("Cut"))
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
		frame.tree.onHeadChanged(v)




#@-node:ekr.20031218072017.841:frame.OnCut, OnCutFrom Menu
#@+node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
def OnCopy (self,event=None):
	
	frame = self

	if g.app.gui.win32clipboard:
		data = frame.body.getSelectedText()
		if data:
			g.app.gui.replaceClipboardWith(data)
		
	# Copy never changes dirty bits or syntax coloring.
	
def OnCopyFromMenu (self):

	frame = self
	w = frame.getFocus()
	w.event_generate(g.virtual_event_name("Copy"))

#@-node:ekr.20031218072017.842:frame.OnCopy, OnCopyFromMenu
#@+node:ekr.20031218072017.843:frame.OnPaste, OnPasteNode, OnPasteFromMenu
def OnPaste (self,event=None):
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	# Activate the body key handler by hand.
	frame.body.forceFullRecolor()
	frame.body.onBodyWillChange(v,"Paste")
	
def OnPasteFromMenu (self):
	
	frame = self ; c = frame.c ; v = c.currentVnode()

	w = self.getFocus()
	w.event_generate(g.virtual_event_name("Paste"))
	
	if not frame.body.hasFocus(): # 1/30/04: Make sure the event sticks.
		frame.tree.onHeadChanged(v)
#@nonl
#@-node:ekr.20031218072017.843:frame.OnPaste, OnPasteNode, OnPasteFromMenu
#@-node:ekr.20031218072017.840:Cut/Copy/Paste body text
#@+node:ekr.20031218072017.3982:endEditLabelCommand
def endEditLabelCommand (self):

	frame = self ; c = frame.c ; tree = frame.tree ; gui = g.app.gui
	
	if g.app.batchMode:
		c.notValidInBatchMode("End Edit Headline")
		return
	
	v = frame.tree.editPosition()

	# g.trace(v)
	if v and v.edit_text():
		tree.select(v)
	if v: # Bug fix 10/9/02: also redraw ancestor headlines.
		tree.force_redraw() # force a redraw of joined headlines.

	gui.set_focus(c,c.frame.bodyCtrl) # 10/14/02
#@nonl
#@-node:ekr.20031218072017.3982:endEditLabelCommand
#@+node:ekr.20031218072017.3983:insertHeadlineTime
def insertHeadlineTime (self):

	frame = self ; c = frame.c ; v = c.currentVnode()
	h = v.headString() # Remember the old value.
	
	if g.app.batchMode:
		c.notValidInBatchMode("Insert Headline Time")
		return

	if v.edit_text():
		sel1,sel2 = g.app.gui.getTextSelection(v.edit_text())
		if sel1 and sel2 and sel1 != sel2: # 7/7/03
			v.edit_text().delete(sel1,sel2)
		v.edit_text().insert("insert",c.getTime(body=false))
		frame.tree.idle_head_key(v)

	# A kludge to get around not knowing whether we are editing or not.
	if h.strip() == v.headString().strip():
		g.es("Edit headline to append date/time")
#@nonl
#@-node:ekr.20031218072017.3983:insertHeadlineTime
#@-node:ekr.20031218072017.3980:Edit Menu...
#@+node:ekr.20031218072017.3984:Window Menu...
#@+node:ekr.20031218072017.3985:toggleActivePane
def toggleActivePane(self):
	
	c = self.c ; gui = g.app.gui
	if gui.get_focus(self) == self.bodyCtrl:
		gui.set_focus(c,self.canvas)
	else:
		gui.set_focus(c,self.bodyCtrl)
#@nonl
#@-node:ekr.20031218072017.3985:toggleActivePane
#@+node:ekr.20031218072017.3986:cascade
def cascade(self):

	x,y,delta = 10,10,10
	for frame in g.app.windowList:
		top = frame.top

		# Compute w,h
		top.update_idletasks() # Required to get proper info.
		geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
		dim,junkx,junky = string.split(geom,'+')
		w,h = string.split(dim,'x')
		w,h = int(w),int(h)

		# Set new x,y and old w,h
		frame.setTopGeometry(w,h,x,y,adjustSize=false)

		# Compute the new offsets.
		x += 30 ; y += 30
		if x > 200:
			x = 10 + delta ; y = 40 + delta
			delta += 10
#@-node:ekr.20031218072017.3986:cascade
#@+node:ekr.20031218072017.3987:equalSizedPanes
def equalSizedPanes(self):

	frame = self
	frame.resizePanesToRatio(0.5,frame.secondary_ratio)
#@-node:ekr.20031218072017.3987:equalSizedPanes
#@+node:ekr.20031218072017.3988:hideLogWindow
def hideLogWindow (self):
	
	frame = self
	frame.divideLeoSplitter2(0.99, not frame.splitVerticalFlag)
#@nonl
#@-node:ekr.20031218072017.3988:hideLogWindow
#@+node:ekr.20031218072017.3989:minimizeAll
def minimizeAll(self):

	self.minimize(g.app.findFrame)
	self.minimize(g.app.pythonFrame)
	for frame in g.app.windowList:
		self.minimize(frame)
	
def minimize(self, frame):

	if frame and frame.top.state() == "normal":
		frame.top.iconify()
#@nonl
#@-node:ekr.20031218072017.3989:minimizeAll
#@+node:ekr.20031218072017.3990:toggleSplitDirection
# The key invariant: self.splitVerticalFlag tells the alignment of the main splitter.
def toggleSplitDirection(self):
	# Abbreviations.
	frame = self
	bar1 = self.bar1 ; bar2 = self.bar2
	split1Pane1,split1Pane2 = self.split1Pane1,self.split1Pane2
	split2Pane1,split2Pane2 = self.split2Pane1,self.split2Pane2
	# Switch directions.
	verticalFlag = self.splitVerticalFlag = not self.splitVerticalFlag
	orientation = g.choose(verticalFlag,"vertical","horizontal")
	g.app.config.setWindowPref("initial_splitter_orientation",orientation)
	# Reconfigure the bars.
	bar1.place_forget()
	bar2.place_forget()
	self.configureBar(bar1,verticalFlag)
	self.configureBar(bar2,not verticalFlag)
	# Make the initial placements again.
	self.placeSplitter(bar1,split1Pane1,split1Pane2,verticalFlag)
	self.placeSplitter(bar2,split2Pane1,split2Pane2,not verticalFlag)
	# Adjust the log and body panes to give more room around the bars.
	self.reconfigurePanes()
	# Redraw with an appropriate ratio.
	vflag,ratio,secondary_ratio = frame.initialRatios()
	self.resizePanesToRatio(ratio,secondary_ratio)
#@nonl
#@-node:ekr.20031218072017.3990:toggleSplitDirection
#@+node:EKR.20040422130619:resizeToScreen
def resizeToScreen (self):
	
	top = self.top
	
	w = top.winfo_screenwidth()
	h = top.winfo_screenheight()
	
	geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)

	top.geometry(geom)
#@nonl
#@-node:EKR.20040422130619:resizeToScreen
#@-node:ekr.20031218072017.3984:Window Menu...
#@+node:ekr.20031218072017.3991:Help Menu...
#@+node:ekr.20031218072017.3992:leoHelp
def leoHelp (self):
	
	file = g.os_path_join(g.app.loadDir,"..","doc","sbooks.chm")

	if g.os_path_exists(file):
		os.startfile(file)
	else:	
		answer = g.app.gui.runAskYesNoDialog(
			"Download Tutorial?",
			"Download tutorial (sbooks.chm) from SourceForge?")

		if answer == "yes":
			try:
				if 0: # Download directly.  (showProgressBar needs a lot of work)
					url = "http://umn.dl.sourceforge.net/sourceforge/leo/sbooks.chm"
					import urllib
					self.scale = None
					urllib.urlretrieve(url,file,self.showProgressBar)
					if self.scale:
						self.scale.destroy()
						self.scale = None
				else:
					url = "http://prdownloads.sourceforge.net/leo/sbooks.chm?download"
					import webbrowser
					os.chdir(g.app.loadDir)
					webbrowser.open_new(url)
			except:
				g.es("exception dowloading sbooks.chm")
				g.es_exception()
#@nonl
#@+node:ekr.20031218072017.3993:showProgressBar
def showProgressBar (self,count,size,total):

	# g.trace("count,size,total:",count,size,total)
	if self.scale == None:
		<< create the scale widget >>
	self.scale.set(count*size)
	self.scale.update_idletasks()
#@nonl
#@+node:ekr.20031218072017.3994:<< create the scale widget >>
Tk = Tkinter
top = Tk.Toplevel()
top.title("Download progress")
self.scale = scale = Tk.Scale(top,state="normal",orient="horizontal",from_=0,to=total)
scale.pack()
top.lift()
#@nonl
#@-node:ekr.20031218072017.3994:<< create the scale widget >>
#@-node:ekr.20031218072017.3993:showProgressBar
#@-node:ekr.20031218072017.3992:leoHelp
#@-node:ekr.20031218072017.3991:Help Menu...
#@-node:ekr.20031218072017.3979:Gui-dependent commands
#@-node:EKR.20040422130619.1:(Added ResizeToScreen command)
#@+node:EKR.20040422131742:(Improved Find dialog)
@nocolor

What I did:
	
- Put frame around find/change text areas:  added relief setting.
- Reduced height and width of find/change text areas.
- Reduced padding around buttons and checkboxes.
- It turns out that _clover_ v and p work in checkboxes.
- Bring outline to front after sucessful search.

@color
#@nonl
#@+node:EKR.20040422131742.1:Linux bug: paste does not work in find panel
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2355852
By: rodrigo_b

On Linux, if you copy some leo headline or body text, and try to paste it in
the Find/Change panel (as a string to search), it does not work.

I suspect the problem is due that Ctrl+V (paste) is not define in the Find panel.

RodrigoB.
#@nonl
#@-node:EKR.20040422131742.1:Linux bug: paste does not work in find panel
#@+node:EKR.20040422131742.2:double-paste in searchbox
@nocolor

By: dthein ( Dave Hein ) 
 BUG: double-paste in searchbox.py plugin   
2004-02-06 16:59  

 Leo 4.1 rc4, build 1.76 , February 3, 2004
Python 2.3.3, Tk 8.4.2, linux2

When I Ctrl-C copy a string from a body and Ctlr-V paste it into the searchbox it gets pasted twice (e.g. the string "image" gets pasted as "imageimage").

I'll try to track this down, but if anyone has a clue right away, please post the solution.

--
Dave Hein  
#@-node:EKR.20040422131742.2:double-paste in searchbox
#@+node:ekr.20031218072017.3082:Initing & finalizing
#@+node:ekr.20031218072017.3083:checkArgs
def checkArgs (self):

	c = self.c
	val = true
	if not c.search_headline_flag and not c.search_body_flag:
		g.es("not searching headline or body")
		val = false
	if len(c.find_text) == 0:
		g.es("empty find patttern")
		val = false
	return val
#@nonl
#@-node:ekr.20031218072017.3083:checkArgs
#@+node:ekr.20031218072017.3084:initBatchCommands
# Initializes for the Find All and Change All commands.

def initBatchCommands (self):

	c = self.c
	self.in_headline = c.search_headline_flag # Search headlines first.
	self.errors = 0

	# Select the first node.
	if c.suboutline_only_flag or c.node_only_flag or c.selection_only_flag: # 11/9/03
		self.v = c.currentVnode()
		if c.selection_only_flag: self.selStart,self.selEnd = c.frame.body.getTextSelection()
		else:                     self.selStart,self.selEnd = None,None
	else:
		v = c.rootVnode()
		if c.reverse_flag:
			while v and v.next():
				v = v.next()
			v = v.lastNode()
		self.v = v

	# Set the insert point.
	self.initBatchText()
#@nonl
#@-node:ekr.20031218072017.3084:initBatchCommands
#@+node:ekr.20031218072017.3085:initBatchText & initNextText
# Returns s_text with "insert" point set properly for batch searches.
def initBatchText(self):
	v = self.v
	self.wrapping = false # Only interactive commands allow wrapping.
	s = g.choose(self.in_headline,v.headString(), v.bodyString())
	return self.init_s_text(s)

# Call this routine when moving to the next node when a search fails.
# Same as above except we don't reset wrapping flag.
def initNextText(self):
	v = self.v
	s = g.choose(self.in_headline,v.headString(), v.bodyString())
	return self.init_s_text(s)
#@nonl
#@-node:ekr.20031218072017.3085:initBatchText & initNextText
#@+node:ekr.20031218072017.3086:initInHeadline
# Guesses which pane to start in for incremental searches and changes.
# This must not alter the current "insert" or "sel" marks.

def initInHeadline (self):

	c = self.c ; v = self.v

	if c.search_headline_flag and c.search_body_flag:
		# Do not change this line without careful thought and extensive testing!
		self.in_headline = (v == c.frame.tree.editPosition())
	else:
		self.in_headline = c.search_headline_flag
#@nonl
#@-node:ekr.20031218072017.3086:initInHeadline
#@+node:ekr.20031218072017.3087:initInteractiveCommands
# For incremental searches

def initInteractiveCommands(self):

	c = self.c ; v = self.v ; gui = g.app.gui

	self.errors = 0
	if self.in_headline:
		c.frame.tree.setEditPosition(v)
		t = v.edit_text()
		sel = None
	else:
		t = c.frame.bodyCtrl
		sel = gui.getTextSelection(t)
	pos = gui.getInsertPoint(t)
	st = self.initNextText()
	gui.set_focus(c,t)
	gui.setInsertPoint(st,pos)
	if sel:
		self.selStart,self.selEnd = sel
	else:
		self.selStart,self.selEnd = None,None
	self.wrapping = c.wrap_flag
	if c.wrap_flag and self.wrapVnode == None:
		self.wrapPos = pos
		# Do not set self.wrapVnode here: that must be done after the first search.
#@nonl
#@-node:ekr.20031218072017.3087:initInteractiveCommands
#@+node:ekr.20031218072017.3088:printLine
def printLine (self,line,allFlag=false):

	c = self.c
	both = c.search_body_flag and c.search_headline_flag
	context = c.batch_flag # "batch" now indicates context

	if allFlag and both and context:
		g.es(self.v)
		type = g.choose(self.in_headline,"head: ","body: ")
		g.es(type + line)
	elif allFlag and context and not self.v.isVisited():
		# We only need to print the context once.
		g.es(self.v)
		g.es(line)
		self.v.setVisited()
	else:
		g.es(line)
#@nonl
#@-node:ekr.20031218072017.3088:printLine
#@+node:ekr.20031218072017.3089:restore
# Restores the screen after a search fails

def restore (self,data):

	c = self.c ; gui = g.app.gui
	in_headline,v,t,insert,start,end = data
	
	c.frame.bringToFront() # Needed on the Mac

	# Don't try to reedit headline.
	c.selectVnode(v)
	if not in_headline:

		if 0: # Looks bad.
			gui.setSelectionRange(t,start,end)
		else: # Looks good and provides clear indication of failure or termination.
			gui.setSelectionRange(t,insert,insert)

		gui.setInsertPoint(t,insert)
		gui.makeIndexVisible(t,insert)
		gui.set_focus(c,t)

	
#@nonl
#@-node:ekr.20031218072017.3089:restore
#@+node:ekr.20031218072017.3090:save
def save (self):

	c = self.c ; v = self.v ; gui = g.app.gui
	t = g.choose(self.in_headline,v.edit_text(),c.frame.bodyCtrl)
	insert = gui.getInsertPoint(t)
	sel = gui.getSelectionRange(t)
	if len(sel) == 2:
		start,end = sel
	else:
		start,end = None,None
	return (self.in_headline,v,t,insert,start,end)
#@nonl
#@-node:ekr.20031218072017.3090:save
#@+node:ekr.20031218072017.3091:showSuccess
def showSuccess(self,pos,newpos):

	"""Displays the final result.

	Returns self.dummy_vnode, v.edit_text() or c.frame.bodyCtrl with
	"insert" and "sel" points set properly."""

	c = self.c ; v = self.v ; gui = g.app.gui
	
	c.frame.bringToFront() # Needed on the Mac

	c.beginUpdate()
	if 1: # range of update...
		c.selectVnode(v)
		c.frame.tree.redraw_now() # Redraw now so selections are not destroyed.
		# Select the found vnode again after redraw.
		if self.in_headline:
			c.editPosition(v)
			c.frame.tree.setNormalLabelState(v)
			assert(v.edit_text())
		else:
			c.selectVnode(v)
	c.endUpdate(false) # Do not draw again!

	t = g.choose(self.in_headline,v.edit_text(),c.frame.bodyCtrl)
	# g.trace(self.in_headline,t)
	insert = g.choose(c.reverse_flag,pos,newpos)
	gui.setInsertPoint(t,insert)
	gui.setSelectionRange(t,pos,newpos)
	if not self.in_headline:
		gui.makeIndexVisible(t,insert)
	gui.set_focus(c,t)
	if c.wrap_flag and not self.wrapVnode:
		self.wrapVnode = self.v
	
#@nonl
#@-node:ekr.20031218072017.3091:showSuccess
#@-node:ekr.20031218072017.3082:Initing & finalizing
#@+node:ekr.20031218072017.3902:find.createFrame
def createFrame (self):

	# Create the find panel...
	outer = Tk.Frame(self.frame,relief="groove",bd=2)
	outer.pack(padx=2,pady=2)

	<< Create the Find and Change panes >>
	<< Create four columns of radio and checkboxes >>
	<< Create two rows of buttons >>
	
	for widget in (self.find_text, self.change_text):
		widget.bind ("<1>",  self.resetWrap)
		widget.bind("<Key>", self.resetWrap)
	
	for widget in (outer, self.find_text, self.change_text):
		widget.bind("<Key-Return>", self.findButton)
		widget.bind("<Key-Escape>", self.onCloseWindow)
	
	self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
#@nonl
#@+node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_text   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_text = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
	txt['yscrollcommand'] = bar.set
	bar['command'] = txt.yview
	bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")
#@nonl
#@-node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
	columns.append(Tk.Frame(columnsFrame,bd=1))
	radioLists.append([])
	checkLists.append([])

for i in xrange(numberOfColumns):
	columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = [
	(self.dict["radio-find-type"],"Plain Search","plain-search"),  
	(self.dict["radio-find-type"],"Pattern Match Search","pattern-search"),
	(self.dict["radio-find-type"],"Script Search","script-search")]
checkLists[0] = [
	("Script Change",self.dict["script_change"])]
checkLists[1] = [
	("Whole Word",  self.dict["whole_word"]),
	("Ignore Case", self.dict["ignore_case"]),
	("Wrap Around", self.dict["wrap"]),
	("Reverse",     self.dict["reverse"])]
radioLists[2] = [
	(self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
	(self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
	(self.dict["radio-search-scope"],"Node Only","node-only"),    
	(self.dict["radio-search-scope"],"Selection Only","selection-only")] # 11/9/03
checkLists[2] = []
checkLists[3] = [
	("Search Headline Text", self.dict["search_headline"]),
	("Search Body Text",     self.dict["search_body"]),
	("Mark Finds",           self.dict["mark_finds"]),
	("Mark Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
	for var,name,val in radioLists[i]:
		box = Tk.Radiobutton(columns[i],anchor="w",text=name,variable=var,value=val)
		box.pack(fill="x")
		box.bind("<1>", self.resetWrap)
		if val == None: box.configure(state="disabled")
	for name, var in checkLists[i]:
		box = Tk.Checkbutton(columns[i],anchor="w",text=name,variable=var)
		box.pack(fill="x")
		box.bind("<1>", self.resetWrap)
		if var == None: box.configure(state="disabled")
#@-node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
#@+node:ekr.20031218072017.3905:<< Create two rows of buttons >>
# Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# Create the first row of buttons
findButton=Tk.Button(buttons,width=8,text="Find",bd=4,command=self.findButton) # The default.
contextBox=Tk.Checkbutton(buttons,anchor="w",text="Show Context",variable=self.dict["batch"])
findAllButton=Tk.Button(buttons,width=8,text="Find All",command=self.findAllButton)

findButton.pack   (pady="1p",padx="25p",side="left")
contextBox.pack   (pady="1p",           side="left",expand=1)
findAllButton.pack(pady="1p",padx="25p",side="right",fill="x",)

# Create the second row of buttons
changeButton    =Tk.Button(buttons2,width=8,text="Change",command=self.changeButton)
changeFindButton=Tk.Button(buttons2,        text="Change, Then Find",command=self.changeThenFindButton)
changeAllButton =Tk.Button(buttons2,width=8,text="Change All",command=self.changeAllButton)

changeButton.pack    (pady="1p",padx="25p",side="left")
changeFindButton.pack(pady="1p",           side="left",expand=1)
changeAllButton.pack (pady="1p",padx="25p",side="right")
#@nonl
#@-node:ekr.20031218072017.3905:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.3902:find.createFrame
#@-node:EKR.20040422131742:(Improved Find dialog)
#@+node:EKR.20040422131023:(Force update of log pane when reading derived files)
Make sure beginUpdate inhibits redraw!
#@nonl
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
	
	if g.app.quitting: return
	elif self.logCtrl:
		<< put s to log control >>
	else:
		<< put s to logWaiting and print s >>

def putnl (self):
	if g.app.quitting: return
	elif self.logCtrl:
		<< put newline to log control >>
	else:
		<< put newline to logWaiting and print newline >>
		
def forceLogUpdate (self):
	if sys.platform != "darwin": # Does not work on darwin.
		self.frame.tree.disableRedraw = true
		self.logCtrl.update_idletasks()
		#self.frame.outerFrame.update_idletasks() # 4/23/04
		#self.frame.top.update_idletasks()
		self.frame.tree.disableRedraw = false
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if type(s) == type(u""): # 3/18/03
	s = g.toEncodedString(s,g.app.tkEncoding)
	
if sys.platform == "darwin":
	print s,

if color:
	if color not in self.colorTags:
		self.colorTags.append(color)
		self.logCtrl.tag_config(color,foreground=color)
	self.logCtrl.insert("end",s)
	self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
	if "black" not in self.colorTags:
		self.colorTags.append("black")
		self.logCtrl.tag_config("black",foreground="black")
	self.logCtrl.tag_add("black","end")
else:
	self.logCtrl.insert("end",s)

self.logCtrl.see("end")
	
self.forceLogUpdate()
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"
if type(s) == type(u""): # 3/18/03
	s = g.toEncodedString(s,"ascii")
print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
if sys.platform == "darwin":
	print
	
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")

self.frame.tree.disableRedraw = true
self.logCtrl.update_idletasks()
#self.frame.outerFrame.update_idletasks() # 4/23/04
#self.frame.top.update_idletasks()
self.frame.tree.disableRedraw = false
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:EKR.20040422131023:(Force update of log pane when reading derived files)
#@+node:EKR.20040422132037.1:(Use clover keys for Mac)
#@+node:ekr.20031218072017.2098:canonicalizeShortcut
@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
	
	if shortcut == None or len(shortcut) == 0:
		return None,None
	s = shortcut.strip().lower()
	
	has_cmd   = s.find("cmd") >= 0     or s.find("command") >= 0 # 11/18/03
	has_ctrl  = s.find("control") >= 0 or s.find("ctrl") >= 0
	has_alt   = s.find("alt") >= 0
	has_shift = s.find("shift") >= 0   or s.find("shft") >= 0
	if sys.platform == "darwin":
		if has_ctrl and not has_cmd:
			has_cmd = true ; has_ctrl = false

	<< set the last field, preserving case >>
	<< canonicalize the last field >>
	<< synthesize the shortcuts from the information >>
	# print shortcut,bind_shortcut,menu_shortcut
	return bind_shortcut,menu_shortcut
#@nonl
#@+node:ekr.20031218072017.2099:<< canonicalize the last field >>
bind_last = menu_last = last
if len(last) == 1:
	ch = last[0]
	if ch in string.ascii_letters:
		menu_last = string.upper(last)
		if has_shift:
			bind_last = string.upper(last)
		else:
			bind_last = string.lower(last)
	elif ch in string.digits:
		bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
	else:
		<< define dict of Tk bind names >>
		if ch in dict.keys():
			bind_last = dict[ch]
elif len(last) > 0:
	<< define dict of special names >>
	last2 = string.lower(last)
	if last2 in dict.keys():
		bind_last,menu_last = dict[last2]
#@nonl
#@+node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
# These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
dict = {
	"!" : "exclam",
	'"' : "quotedbl",
	"#" : "numbersign",
	"$" : "dollar",
	"%" : "percent",
	"&" : "ampersand",
	"'" : "quoteright",
	"(" : "parenleft",
	")" : "parenright",
	"*" : "asterisk",
	"+" : "plus",
	"," : "comma",
	"-" : "minus",
	"." : "period",
	"/" : "slash",
	":" : "colon",
	";" : "semicolon",
	"<" : "less",
	"=" : "equal",
	">" : "greater",
	"?" : "question",
	"@" : "at",
	"[" : "bracketleft",
	"\\": "backslash",
	"]" : "bracketright",
	"^" : "asciicircum",
	"_" : "underscore",
	"`" : "quoteleft",
	"{" : "braceleft",
	"|" : "bar",
	"}" : "braceright",
	"~" : "asciitilde" }
#@nonl
#@-node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
#@+node:ekr.20031218072017.2101:<< define dict of special names >>
# These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

dict = {
	"bksp"    : ("BackSpace","BkSp"),
	"esc"     : ("Escape","Esc"),
	# Arrow keys...
	"dnarrow" : ("Down", "DnArrow"),
	"ltarrow" : ("Left", "LtArrow"),
	"rtarrow" : ("Right","RtArrow"),
	"uparrow" : ("Up",   "UpArrow"),
	# Page up/down keys...
	"pageup"  : ("Prior","PgUp"),
	"pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
#@-node:ekr.20031218072017.2101:<< define dict of special names >>
#@-node:ekr.20031218072017.2099:<< canonicalize the last field >>
#@+node:ekr.20031218072017.2102:<< set the last field, preserving case >>
s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) > 0 and s2[-1] == "-":
	s2 = string.replace(s2,"-","+")
	s2 = s2[:-1] + "-"
else:
	s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
	if not g.app.menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None

last = fields[-1]
if last == None or len(last) == 0:
	if not g.app.menuWarningsGiven:
		print "bad shortcut specifier:", s
	return None,None
#@nonl
#@-node:ekr.20031218072017.2102:<< set the last field, preserving case >>
#@+node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
bind_head = menu_head = ""

if has_shift:
	menu_head = "Shift+"
	if len(last) > 1 or (len(last)==1 and last[0] not in string.ascii_letters):
		bind_head = "Shift-"
if has_alt:
	bind_head = bind_head + "Alt-"
	menu_head = menu_head + "Alt+"

if has_ctrl:
	bind_head = bind_head + "Control-"
	menu_head = menu_head + "Ctrl+"
	
if has_cmd: # 11/18/03
	bind_head = bind_head + "Command-"
	menu_head = menu_head + "Command+"
	
bind_shortcut = "<" + bind_head + bind_last + ">"
menu_shortcut = menu_head + menu_last
#@nonl
#@-node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
#@-node:ekr.20031218072017.2098:canonicalizeShortcut
#@-node:EKR.20040422132037.1:(Use clover keys for Mac)
#@-node:EKR.20040422101256:4/22
#@+node:EKR.20040424151409:4/22
#@+node:EKR.20040424091902:(Ignore line endings when comparing derived files while writing)
#@+node:ekr.20031218072017.2023:atFile.replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
	
	assert(self.outputFile is None)
	
	self.fileChangedFlag = false
	if g.os_path_exists(self.targetFileName):
		# if filecmp.cmp(self.outputFileName,self.targetFileName):
		if self.compareFilesIgnoringLineEndings(
			self.outputFileName,self.targetFileName):
			<< delete the output file >>
		else:
			<< replace the target file with the output file >>
	else:
		<< rename the output file to be the target file >>
#@nonl
#@+node:ekr.20031218072017.2024:<< delete the output file >>
try: # Just delete the temp file.
	os.remove(self.outputFileName)
except:
	g.es("exception deleting:" + self.outputFileName)
	g.es_exception()

g.es("unchanged: " + self.shortFileName)
#@nonl
#@-node:ekr.20031218072017.2024:<< delete the output file >>
#@+node:ekr.20031218072017.2025:<< replace the target file with the output file >>
try:
	# 10/6/02: retain the access mode of the previous file,
	# removing any setuid, setgid, and sticky bits.
	mode = (os.stat(self.targetFileName))[0] & 0777
except:
	mode = None

try: # Replace target file with temp file.
	os.remove(self.targetFileName)
	try:
		g.utils_rename(self.outputFileName,self.targetFileName)
		if mode != None: # 10/3/02: retain the access mode of the previous file.
			try:
				os.chmod(self.targetFileName,mode)
			except:
				g.es("exception in os.chmod(%s)" % (self.targetFileName))
		g.es("writing: " + self.shortFileName)
		self.fileChangedFlag = true
	except:
		# 6/28/03
		self.writeError("exception renaming: %s to: %s" % (self.outputFileName,self.targetFileName))
		g.es_exception()
except:
	self.writeError("exception removing:" + self.targetFileName)
	g.es_exception()
	try: # Delete the temp file when the deleting the target file fails.
		os.remove(self.outputFileName)
	except:
		g.es("exception deleting:" + self.outputFileName)
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2025:<< replace the target file with the output file >>
#@+node:ekr.20031218072017.2026:<< rename the output file to be the target file >>
try:
	g.utils_rename(self.outputFileName,self.targetFileName)
	g.es("creating: " + self.targetFileName)
	self.fileChangedFlag = true
except:
	self.writeError("exception renaming:" + self.outputFileName +
		" to " + self.targetFileName)
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2026:<< rename the output file to be the target file >>
#@-node:ekr.20031218072017.2023:atFile.replaceTargetFileIfDifferent
#@+node:EKR.20040424085407:atFile.compareFilesIgnoringLineEndings
# This routine is needed to handle cvs stupidities.

def compareFilesIgnoringLineEndings (self,path1,path2):

	"""Compare two text files ignoring line endings."""
	
	try:
		# Opening both files in text mode converts all line endings to '\n'.
		f1 = open(path1) ; f2 = open(path2)
		equal = f1.read() == f2.read()
		f1.close() ; f2.close()
		return equal
	except:
		return false
#@nonl
#@-node:EKR.20040424085407:atFile.compareFilesIgnoringLineEndings
#@-node:EKR.20040424091902:(Ignore line endings when comparing derived files while writing)
#@-node:EKR.20040424151409:4/22
#@-node:ekr.20040403104315.1:April 2004
#@+node:EKR.20040517090500:May 2004
#@+node:EKR.20040519080820:In 4.2 a2
#@+node:ekr.20040319104735:(@file-thin)
#@+node:EKR.20040428060432:Theory of operation
@nocolor

- Existing fileCommands.write logic assigns tnode indices (gnx's) for all nodes to be written.
- New atFile.write logic writes tnode gnx's in all node headers.
- Existing fileCommands.read logic creates fc.tnodeList dictionary associating gnx's with tnodes.
	- The atFile.read logic can use this to associate newly created vnodes with shared tnodes.
#@nonl
#@-node:EKR.20040428060432:Theory of operation
#@+node:ekr.20040321064134.1:To do
@nocolor

Transition to @file-thin
	*** Is the present code always correct?
		What about a reference to a grandchild node?
	- Change @+leo sentinel for thin files.
	- Better warning when @file-thin overrides existing code?
		- Dialog warning about thin derived file:
			- Do you want outline version or derived file version.
	- Option for minimal @-node sentinel.

Design:
	- What to do about cloned siblings in thin trees?

Other commands:
	- Make Import Derived File command work with thin derived files.
	- Make Go To Line number command work with thin derived files.
#@nonl
#@-node:ekr.20040321064134.1:To do
#@+node:EKR.20040427145035:What I did
@nocolor

Recognizers

- Added vnode recognizers for @file-thin option.
- Added position proxies for vnode recognizers.

Directives & sentinels
- Added support for @all.

Writing

- Added top-level atFile code to write @file-thin tree.
- DO write @file-thin vnodes if there was an error writing the derived file.
	- No autosave for @file-thin.
 	- Leo writes @file nodes first, so this is not a problem.
	- putVnode checks orphan bit, which gets set if there was an error.
- Don't write vnodes (or related tnodes) for @file-thin trees. (fileCommands).
- Do write empty nodes in @thin trees.
- Don't generate close node sentinels until all children have been generated.

Reading

- Set at.thinFile when reading thin files.
- Suppressed changed message and related items for thin files.
- Modified scanText4 and allies to read thin derived files.
	- Don't look for tnodeList for thin files.
	- Initially, at.lastThinNode is at.root.v
	- readStartNode calls createThinChild
	- createThinChild makes a child of at.lastThinNode if needed and sets at.lastThinNode.
- Updated fc.tnodesDict in at.createThinChild.
	Otherwise clones existing only in two thin files won't be linked properly.
#@nonl
#@-node:EKR.20040427145035:What I did
#@+node:EKR.20040427073852:fileCommands
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=true):

	c = self.c
	c.setChanged(false) # 10/1/03: May be set when reading @file nodes.
	<< warn on read-only files >>
	self.mFileName = c.mFileName
	self.tnodesDict = {}
	ok = true
	c.loading = true # disable c.changed
	
	try:
		<< scan all the xml elements >>
	except BadLeoFile, message:
		<< raise an alert >>
		ok = false

	c.frame.tree.redraw_now(scroll=false)
	
	if ok and atFileNodesFlag:
		c.atFileCommands.readAll(c.rootVnode(),partialFlag=false)

	if not c.currentPosition():
		c.setCurrentPosition(c.rootPosition())

	c.selectVnode(c.currentPosition()) # load body pane
	c.loading = false # reenable c.changed
	c.setChanged(c.changed) # Refresh the changed marker.
	self.tnodesDict = {}
	return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
try:
	self.read_only = false
	self.read_only = not os.access(fileName,os.W_OK)
	if self.read_only:
		g.es("read only: " + fileName,color="red")
except:
	if 0: # testing only: access may not exist on all platforms.
		g.es("exception getting file access")
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()
self.getTag("<leo_file>")
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

	c = self.c ; config = g.app.config

	self.assignFileIndices()
	if not outlineOnlyFlag:
		<< write all @file nodes >>
	<< return if the .leo file is read-only >>
	try:
		<< create backup file >>
		self.mFileName = fileName
		<< create the output file >>
		<< update leoConfig.txt >>
		<< put the .leo file >>
	except:
		<< report the exception >>
		<< erase filename and rename backupName to fileName >>
		return false
	if self.outputFile:
		<< close the output file >>
		<< delete backup file >>
		return true
	else: # This probably will never happen because errors should raise exceptions.
		<< erase filename and rename backupName to fileName >>
		return false
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
	# Write all @file nodes and set orphan bits.
	c.atFileCommands.writeAll()
except:
	g.es_error("exception writing derived files")
	g.es_exception()
	return false
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
	try:
		if not os.access(fileName,os.W_OK):
			self.writeError("can not create: read only: " + self.targetFileName)
			return false
	except:
		pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
	try:
		backupName = g.os_path_join(g.app.loadDir,fileName)
		backupName = fileName + ".bak"
		if g.os_path_exists(backupName):
			os.unlink(backupName)
		# os.rename(fileName,backupName)
		g.utils_rename(fileName,backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception creating backup file: " + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception creating backup file: " + backupName)
		g.es_exception()
		backupName = None
		return false
else:
	backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080359.2:<< create the output file >>
self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
	g.es("can not open " + fileName)
	<< delete backup file >>
	return false
#@nonl
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
	try:
		os.unlink(backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting backup file:" + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception deleting backup file:" + backupName)
		g.es_exception()
		return false
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20040324080359.2:<< create the output file >>
#@+node:ekr.20040324080819:<< update leoConfig.txt >>
c.setIvarsFromFind()
config.setConfigFindIvars(c)
c.setIvarsFromPrefs()
config.setCommandsIvars(c)
config.update()
#@nonl
#@-node:ekr.20040324080819:<< update leoConfig.txt >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20040324080819.2:<< report the exception >>
g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
	try:
		self.outputFile.close()
		self.outputFile = None
	except:
		g.es("exception closing: " + fileName)
		g.es_exception()
#@nonl
#@-node:ekr.20040324080819.2:<< report the exception >>
#@+node:ekr.20040324080819.3:<< close the output file >>
try:
	self.outputFile.close()
	self.outputFile = None
except:
	g.es("exception closing: " + fileName)
	g.es_exception()
#@nonl
#@-node:ekr.20040324080819.3:<< close the output file >>
#@+node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
	try:
		os.unlink(fileName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting: " + fileName)
			g.es_exception()
	except:
		g.es("exception deleting: " + fileName)
		g.es_exception()
		
if backupName:
	g.es("restoring " + fileName + " from " + backupName)
	try:
		g.utils_rename(backupName, fileName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception renaming " + backupName + " to " + fileName)
			g.es_exception()
	except:
		g.es("exception renaming " + backupName + " to " + fileName)
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
	try:
		os.unlink(backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting backup file:" + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception deleting backup file:" + backupName)
		g.es_exception()
		return false
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20031218072017.1579:putVnodes
def putVnodes (self):

	"""Puts all <v> elements in the order in which they appear in the outline."""

	c = self.c
	c.clearAllVisited()

	self.put("<vnodes>") ; self.put_nl()

	# Make only one copy for all calls.
	self.currentPosition = c.currentPosition() 
	self.topPosition     = c.topPosition()

	if self.usingClipboard:
		self.putVnode(self.currentPosition) # Write only current tree.
	else:
		for p in c.rootPosition().self_and_siblings_iter():
			self.putVnode(p) # Write the next top-level node.

	self.put("</vnodes>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1579:putVnodes
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):
	
	"""Puts all tnodes as required for copy or save commands"""

	c = self.c

	self.put("<tnodes>") ; self.put_nl()
	<< write only those tnodes that were referenced >>
	self.put("</tnodes>") ; self.put_nl()
#@nonl
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
# Populate tnodes
tnodes = {}

if self.usingClipboard: # write the current tree.
	root = c.currentPosition()
else: # write everything
	root = c.rootPosition()

for p in c.allNodes_iter():
	index = p.v.t.fileIndex
	assert(index)
	tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
	# g.trace(index)
	t = tnodes.get(index)
	assert(t)
	# Write only those tnodes whose vnodes were written.
	if t.isWriteBit(): # 5/3/04
		self.putTnode(t)
#@nonl
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@-node:EKR.20040427073852:fileCommands
#@+node:ekr.20040321095547:Comparisons
#@+node:ekr.20031218072017.3152:g.scanAtFileOptions
def scanAtFileOptions (h,err_flag=false):
	
	assert(g.match(h,0,"@file"))
	i = len("@file")
	atFileType = "@file"
	optionsList = []

	while g.match(h,i,'-'):
		<< scan another @file option >>
		
	# Convert atFileType to a list of options.
	for fileType,option in (
		("@silentfile","asis"),
		("@nosentinelsfile","nosent"),
		("@rawfile","noref"),
		("@thinfile","thin")
	):
		if atFileType == fileType and option not in optionsList:
			optionsList.append(option)
			
	# g.trace(atFileType,optionsList)

	return i,atFileType,optionsList
#@nonl
#@+node:ekr.20031218072017.3153:<< scan another @file option >>
i += 1 ; err = -1

if g.match_word(h,i,"asis"):
	if atFileType == "@file":
		atFileType = "@silentfile"
	elif err_flag:
		g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@rawfile"
	elif atFileType == "@nosentinelsfile":
		atFileType = "@silentfile"
	elif err_flag:
		g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
	if atFileType == "@file":
		atFileType = "@nosentinelsfile"
	elif atFileType == "@rawfile":
		atFileType = "@silentfile"
	elif err_flag:
		g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
	if atFileType == "@file":
		atFileType = "@thinfile"
	elif err_flag:
		g.es("using -thin option in:" + h)
else:
	if 0: # doesn't work
		for option in ("fat","new","now","old","thin","wait"):
			if g.match_word(h,i,option):
				optionsList.append(option)
		if len(option) == 0:
			err = i-1
# Scan to the next minus sign.
while i < len(h) and h[i] not in (' ','\t','-'):
	i += 1
if err > -1:
	g.es("unknown option:" + h[err:i] + " in " + h)
#@nonl
#@-node:ekr.20031218072017.3153:<< scan another @file option >>
#@-node:ekr.20031218072017.3152:g.scanAtFileOptions
#@+node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20040328055931:afterHeadlineFileTypeName
def afterHeadlineFileTypeName(self,s):
	
	h = self.headString()

	if s != "@file" and g.match_word(h,0,s):
		# No options are valid.
		return s,string.strip(h[len(s):])

	elif g.match(h,0,"@file"):
		i,atFileType,junk = g.scanAtFileOptions(h)
		return atFileType,h[i:].strip()

	else:
		return None,None
#@nonl
#@-node:ekr.20040328055931:afterHeadlineFileTypeName
#@+node:ekr.20031218072017.3347:afterHeadlineMatch
def afterHeadlineMatch(self,s):
	
	atFileType,fileName = self.afterHeadlineFileTypeName(s)
	if s == atFileType:
		return fileName
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3347:afterHeadlineMatch
#@+node:ekr.20031218072017.3350:anyAtFileNodeName
def anyAtFileNodeName (self):
	
	"""Return the file name following an @file node or an empty string."""
	
	# New in 4.2: do the fastest possible tests.
	h = self.headString()

	if g.match(h,0,"@file"):
		type,name = self.afterHeadlineFileTypeName("@file")
		if type and name: return name
		else:             return ""
	elif g.match(h,0,"@nosentinelsfile"):
		return self.afterHeadlineMatch("@nosentinelsfile")
	elif g.match(h,0,"@rawfile"):
		return self.afterHeadlineMatch("@rawfile")
	elif g.match(h,0,"@silentfile"):
		return self.afterHeadlineMatch("@silentfile")
	elif g.match(h,0,"@thinfile"):
		return self.afterHeadlineMatch("@thinfile")
	else:
		return ""
#@nonl
#@-node:ekr.20031218072017.3350:anyAtFileNodeName
#@+node:ekr.20031218072017.3348:at...FileNodeName
@ Returns the filename following @file or @rawfile, in the receivers's headline, or the empty string if the receiver is not an @file node.
@c

def atFileNodeName (self):
	return self.afterHeadlineMatch("@file")

def atNoSentinelsFileNodeName (self):
	return self.afterHeadlineMatch("@nosentinelsfile")

def atRawFileNodeName (self):
	return self.afterHeadlineMatch("@rawfile")
	
def atSilentFileNodeName (self):
	return self.afterHeadlineMatch("@silentfile")
	
def atThinFileNodeName (self):
	return self.afterHeadlineMatch("@thinfile")
	
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName
#@nonl
#@-node:ekr.20031218072017.3348:at...FileNodeName
#@+node:EKR.20040430152000:isAtAllNode
def isAtAllNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@all")
	return flag
#@nonl
#@-node:EKR.20040430152000:isAtAllNode
#@+node:ekr.20040326031436:isAnyAtFileNode
def isAnyAtFileNode (self):
	
	"""Return true if v is any kind of @file or related node."""
	
	# This routine should be as fast as possible.
	# It is called once for every vnode when writing a file.

	h = self.headString()
	return h and h[0] == '@' and self.anyAtFileNodeName()
#@nonl
#@-node:ekr.20040326031436:isAnyAtFileNode
#@+node:ekr.20040325073709:isAt...FileNode
def isAtFileNode (self):
	return g.choose(self.atFileNodeName(),true,false)
	
def isAtNoSentinelsFileNode (self):
	return g.choose(self.atNoSentinelsFileNodeName(),true,false)

def isAtRawFileNode (self): # @file-noref
	return g.choose(self.atRawFileNodeName(),true,false)

def isAtSilentFileNode (self): # @file-asis
	return g.choose(self.atSilentFileNodeName(),true,false)

def isAtThinFileNode (self):
	return g.choose(self.atThinFileNodeName(),true,false)
	
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode
#@nonl
#@-node:ekr.20040325073709:isAt...FileNode
#@+node:ekr.20031218072017.3351:isAtIgnoreNode
def isAtIgnoreNode (self):

	"""Returns true if the receiver contains @ignore in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
	return flag
#@nonl
#@-node:ekr.20031218072017.3351:isAtIgnoreNode
#@+node:ekr.20031218072017.3352:isAtOthersNode
def isAtOthersNode (self):

	"""Returns true if the receiver contains @others in its body at the start of a line."""

	flag, i = g.is_special(self.t.bodyString,0,"@others")
	return flag
#@nonl
#@-node:ekr.20031218072017.3352:isAtOthersNode
#@+node:ekr.20031218072017.3353:matchHeadline
def matchHeadline (self,pattern):

	"""Returns true if the headline matches the pattern ignoring whitespace and case.
	
	The headline may contain characters following the successfully matched pattern."""

	h = string.lower(self.headString())
	h = string.replace(h,' ','')
	h = string.replace(h,'\t','')

	s = string.lower(pattern)
	s = string.replace(s,' ','')
	s = string.replace(s,'\t','')

	# ignore characters in the headline following the match
	return s == h[0:len(s)]
#@nonl
#@-node:ekr.20031218072017.3353:matchHeadline
#@-node:ekr.20031218072017.3346:v.Comparisons
#@+node:ekr.20040306211032:p.Comparisons
def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)
#@nonl
#@-node:ekr.20040306211032:p.Comparisons
#@-node:ekr.20040321095547:Comparisons
#@+node:EKR.20040427075250:Top level atFile
#@+node:EKR.20040429081306:Read
#@+node:ekr.20031218072017.2626: top_df.readAll
def readAll(self,root,partialFlag=false):
	
	"""Scan vnodes, looking for @file nodes to read."""

	at = self ; c = at.c
	c.endEditing() # Capture the current headline.
	anyRead = false
	at.initIvars()
	p = root.copy()
	if partialFlag: after = p.nodeAfterTree()
	else: after = c.nullPosition()
	while p and not p.equal(after): # Don't use iterator.
		if p.isAtIgnoreNode():
			p.moveToNodeAfterTree()
		elif p.isAtThinFileNode():
			anyRead = true
			at.read(p,thinFile=true)
			p.moveToNodeAfterTree()
		elif p.isAtFileNode() or p.isAtNorefFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				at.read(p)
			else:
				# if p is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = p.isOrphan()
				ok = at.read(p)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					p.setDirty()
					c.setChanged(true)
			p.moveToNodeAfterTree()
		else: p.moveToThreadNext()
	# Clear all orphan bits.
	for p in c.allNodes_iter():
		p.v.clearOrphan()
		
	if partialFlag and not anyRead:
		g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20031218072017.2626: top_df.readAll
#@+node:ekr.20031218072017.2757:new_df.readOpenFile
def readOpenFile(self,root,file,firstLines):
	
	"""Read an open 4.x thick or thin derived file."""
	
	at = self

	# Scan the 4.x file.
	at.tnodeListIndex = 0
	# 4/27/04: at.thinFile tells scanText4 whether this is a thin file or not.
	lastLines = at.scanText4(file,root)
	root.v.t.setVisited() # Disable warning about set nodes.
	
	# Handle first and last lines.
	try: body = root.v.t.tempBodyString
	except: body = ""
	lines = body.split('\n')
	at.completeFirstDirectives(lines,firstLines)
	at.completeLastDirectives(lines,lastLines)
	s = '\n'.join(lines).replace('\r', '')
	root.v.t.tempBodyString = s
#@-node:ekr.20031218072017.2757:new_df.readOpenFile
#@+node:ekr.20031218072017.1812:top_df.read
# The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=false):
	
	"""Common read logic for any derived file."""
	
	at = self ; c = at.c
	at.errors = 0
	at.scanDefaultDirectory(root)
	if at.errors: return
	<< set fileName from root and importFileName >>
	<< open file or return false >>
	g.es("reading: " + root.headString())
	firstLines,read_new = at.scanHeader(file,fileName)
	df = g.choose(read_new,at.new_df,at.old_df)
	# g.trace(g.choose(df==at.new_df,"new","old"))
	# import traceback ; traceback.print_stack()
	<< copy ivars to df >>
	root.clearVisitedInTree()
	try:
		# 1/28/04: Don't set comment delims when importing.
		# 1/28/04: Call scanAllDirectives here, not in readOpenFile.
		importing = importFileName is not None
		df.scanAllDirectives(root,importing=importing,reading=true)
		df.readOpenFile(root,file,firstLines)
	except:
		at.error("Unexpected exception while reading derived file")
		g.es_exception()
	file.close()
	root.clearDirty() # May be set dirty below.
	after = root.nodeAfterTree()
	<< warn about non-empty unvisited nodes >>
	if df.errors == 0:
		if not df.importing:
			<< copy all tempBodyStrings to tnodes >>
	<< delete all tempBodyStrings >>
	return df.errors == 0
#@nonl
#@+node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
if importFileName:
	fileName = importFileName
elif root.isAnyAtFileNode():
	fileName = root.anyAtFileNodeName()
else:
	fileName = None

if not fileName:
	at.error("Missing file name.  Restoring @file tree from .leo file.")
	return false
#@nonl
#@-node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
#@+node:ekr.20031218072017.1814:<< open file or return false >>
fn = g.os_path_join(at.default_directory,fileName)
fn = g.os_path_normpath(fn)

try:
	# 11/4/03: open the file in binary mode to allow 0x1a in bodies & headlines.
	file = open(fn,'rb')
	if file:
		<< warn on read-only file >>
	else: return false
except:
	at.error("Can not open: " + '"@file ' + fn + '"')
	root.setDirty()
	return false
#@nonl
#@+node:ekr.20031218072017.1815:<< warn on read-only file >>
try:
	read_only = not os.access(fn,os.W_OK)
	if read_only:
		g.es("read only: " + fn,color="red")
except:
	pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20031218072017.1815:<< warn on read-only file >>
#@-node:ekr.20031218072017.1814:<< open file or return false >>
#@+node:ekr.20031218072017.1816:<< copy ivars to df >>
# Telling what kind of file we are reading.
df.importing = importFileName != None
df.raw = false
df.thinFile = thinFile

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = file
df.importRootSeen = false
df.indent = 0
df.targetFileName = fileName
df.root = root
df.root_seen = false
#@nonl
#@-node:ekr.20031218072017.1816:<< copy ivars to df >>
#@+node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

	# g.trace(p)
	try: s = p.v.t.tempBodyString
	except: s = ""
	if s and not p.v.t.isVisited():
		at.error("Not in derived file:" + p.headString())
		p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
	try: s = p.v.t.tempBodyString
	except: s = ""
	if s != p.bodyString():
		if 0: # For debugging.
			print ; print "changed: " + p.headString()
			print ; print "new:",s
			print ; print "old:",p.bodyString()
		if thinFile:
			p.v.setTnodeText(s)
		else:
			g.es("changed: " + p.headString(),color="blue")
			p.setMarked()
			p.setBodyStringOrPane(s) # Sets v and v.c dirty.
#@nonl
#@-node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
	if hasattr(p.v.t,"tempBodyString"):
		delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
#@-node:ekr.20031218072017.1812:top_df.read
#@+node:ekr.20031218072017.2633:top_df.scanHeader
def scanHeader(self,file,fileName):
	
	"""Scan the @+leo sentinel.
	
	Sets self.encoding, and self.start/endSentinelComment.
	
	Returns (firstLines,new_df) where:
	firstLines contains all @first lines,
	new_df is true if we are reading a new-format derived file."""
	
	at = self
	new_df = false # Set default.
	firstLines = [] # The lines before @+leo.
	version_tag = "-ver="
	thin_tag = "-thin"
	tag = "@+leo" ; encoding_tag = "-encoding="
	valid = true
	<< skip any non @+leo lines >>
	<< make sure we have @+leo >>
	<< read optional version param >>
	<< read optional thin param >>
	<< read optional encoding param >>
	<< set the closing comment delim >>
	if not valid:
		at.error("Bad @+leo sentinel in " + fileName)
	# g.trace("start,end",at.startSentinelComment,at.endSentinelComment)
	return firstLines, new_df
#@nonl
#@+node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) > 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = at.readLine(file)
n = len(s)
valid = n > 0
# s contains the tag
i = j = g.skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
	i += 1
if j < i:
	at.startSentinelComment = s[j:i]
	# g.trace(at.startSentinelComment)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
#@+node:ekr.20031218072017.2635:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0:# 7/8/02: make leading whitespace significant.
	i = g.skip_ws(s,i)

if g.match(s,i,tag):
	i += len(tag)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2635:<< make sure we have @+leo >>
#@+node:ekr.20031218072017.2636:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
	# Skip to the next minus sign or end-of-line
	i += len(version_tag)
	j = i
	while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
		i += 1

	if j < i:
		pass # version = s[j:i]
	else:
		valid = false
#@-node:ekr.20031218072017.2636:<< read optional version param >>
#@+node:EKR.20040503105354:<< read optional thin param >>
if g.match(s,i,thin_tag):
	i += len(tag)
#@nonl
#@-node:EKR.20040503105354:<< read optional thin param >>
#@+node:ekr.20031218072017.2637:<< read optional encoding param >>
# Set the default encoding
at.encoding = g.app.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
	# Read optional encoding param, e.g., -encoding=utf-8,
	i += len(encoding_tag)
	# Skip to the next end of the field.
	j = s.find(",.",i)
	if j > -1:
		# The encoding field was written by 4.2 or after:
		encoding = s[i:j]
	else:
		# The encoding field was written before 4.2.
		j = s.find('.',i)
		if j > -1:
			encoding = s[i:j]
		else:
			encoding = None
	# g.trace("encoding:",encoding)
	if encoding:
		if g.isValidEncoding(encoding):
			at.encoding = encoding
		else:
			print "bad encoding in derived file:",encoding
			g.es("bad encoding in derived file:",encoding)
	else:
		valid = false
#@-node:ekr.20031218072017.2637:<< read optional encoding param >>
#@+node:ekr.20031218072017.2638:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
	i += 1
at.endSentinelComment = s[j:i]
#@nonl
#@-node:ekr.20031218072017.2638:<< set the closing comment delim >>
#@-node:ekr.20031218072017.2633:top_df.scanHeader
#@-node:EKR.20040429081306:Read
#@+node:EKR.20040429081306.1:Write
#@+node:ekr.20031218072017.2720:atFile.openWriteFile
# Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root):
	
	# g.trace(root)

	try:
		self.scanAllDirectives(root)
		valid = self.errors == 0
	except:
		self.writeError("exception in atFile.scanAllDirectives")
		g.es_exception()
		valid = false

	if valid:
		try:
			fn = self.targetFileName
			self.shortFileName = fn # name to use in status messages.
			self.targetFileName = g.os_path_join(self.default_directory,fn)
			self.targetFileName = g.os_path_normpath(self.targetFileName)
			path = g.os_path_dirname(self.targetFileName)
			if not path or not g.os_path_exists(path):
				self.writeError("path does not exist: " + path)
				valid = false
		except:
			self.writeError("exception creating path:" + fn)
			g.es_exception()
			valid = false

	if valid and g.os_path_exists(self.targetFileName):
		try:
			if not os.access(self.targetFileName,os.W_OK):
				self.writeError("can not create: read only: " + self.targetFileName)
				valid = false
		except:
			pass # os.access() may not exist on all platforms.
		
	if valid:
		try:
			self.outputFileName = self.targetFileName + ".tmp"
			self.outputFile = open(self.outputFileName,'wb')
			if self.outputFile is None:
				self.writeError("can not create " + self.outputFileName)
				valid = false
		except:
			g.es("exception creating:" + self.outputFileName)
			g.es_exception()
			valid = false
			self.outputFile = None # 3/22/04

	if not valid:
		root.setOrphan()
		root.setDirty()
		self.outputFile = None # 1/29/04
	
	return valid
#@nonl
#@-node:ekr.20031218072017.2720:atFile.openWriteFile
#@+node:ekr.20031218072017.2114:new_df.write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=false,scriptFile=None,thinFile=false):
	
	"""Write a 4.x derived file."""
	
	at = self ; c = at.c

	<< open the file; return on error >>
	try:
		self.writeOpenFile(root,nosentinels,scriptFile,thinFile)
		if scriptFile != None:
			at.root.v.t.tnodeList = []
		else:
			at.closeWriteFile()
			<< set dirty and orphan bits on error >>
	except:
		if scriptFile:
			g.es("exception preprocessing script",color="blue")
			g.es_exception(full=false)
			scriptFile.clear()
			at.root.v.t.tnodeList = []
		else:
			at.handleWriteException() # Sets dirty and orphan bits.
#@nonl
#@+node:ekr.20031218072017.2116:<< open the file; return on error >>
if scriptFile:
	at.targetFileName = "<script>"
elif nosentinels:
	at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
	at.targetFileName = root.atThinFileNodeName()
else:
	at.targetFileName = root.atFileNodeName()

if scriptFile:
	ok = true
	at.outputFileName = "<script>"
	at.outputFile = scriptFile
else:
	ok = at.openWriteFile(root)
	
if not ok:
	return
#@nonl
#@-node:ekr.20031218072017.2116:<< open the file; return on error >>
#@+node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
	root.setOrphan()
	root.setDirty() # Make _sure_ we try to rewrite this file.
	os.remove(at.outputFileName) # Delete the temp file.
	g.es("Not written: " + at.outputFileName)
else:
	root.clearOrphan()
	root.clearDirty()
	at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20031218072017.2121:<< set dirty and orphan bits on error >>
#@-node:ekr.20031218072017.2114:new_df.write
#@+node:ekr.20031218072017.2015:top_df.writeAll
def writeAll(self,writeAtFileNodesFlag=false,writeDirtyAtFileNodesFlag=false):
	
	"""Write @file nodes in all or part of the outline"""

	at = self ; c = at.c
	write_new = not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	df.initIvars()
	writtenFiles = [] # Files that might be written again.
	mustAutoSave = false

	if writeAtFileNodesFlag:
		# Write all nodes in the selected tree.
		p = c.currentPosition()
		after = p.nodeAfterTree()
	else:
		# Write dirty nodes in the entire outline.
		p =  c.rootPosition()
		after = c.nullPosition()

	<< Clear all orphan bits >>
	while p and p != after:
		if p.isAnyAtFileNode() or p.isAtIgnoreNode():
			<< handle v's tree >>
			p.moveToNodeAfterTree()
		else:
			p.moveToThreadNext()

	<< say the command is finished >>
	return mustAutoSave
#@nonl
#@+node:ekr.20031218072017.2016:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
	
for v2 in p.self_and_subtree_iter():
	v2.clearOrphan()
#@nonl
#@-node:ekr.20031218072017.2016:<< Clear all orphan bits >>
#@+node:ekr.20031218072017.2017:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

	df.fileChangedFlag = false # 1/9/04
	autoSave = false
	
	# Tricky: @ignore not recognised in @silentfile nodes.
	if p.isAtAsisFileNode():
		at.asisWrite(p)
		writtenFiles.append(p.v.t) ; autoSave = true
	elif p.isAtIgnoreNode():
		pass
	elif p.isAtNorefFileNode():
		at.norefWrite(p)
		writtenFiles.append(p.v.t) ; autoSave = true
	elif p.isAtNoSentFileNode():
		at.write(p,nosentinels=true)
		writtenFiles.append(p.v.t) # No need for autosave
	elif p.isAtThinFileNode():
		at.write(p,thinFile=true)
		writtenFiles.append(p.v.t) # No need for autosave.
	elif p.isAtFileNode():
		at.write(p)
		writtenFiles.append(p.v.t) ; autoSave = true

	if df.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
		mustAutoSave = true
#@nonl
#@-node:ekr.20031218072017.2017:<< handle v's tree >>
#@+node:ekr.20031218072017.2018:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
	if len(writtenFiles) > 0:
		g.es("finished")
	elif writeAtFileNodesFlag:
		g.es("no @file nodes in the selected tree")
	else:
		g.es("no dirty @file nodes")
#@nonl
#@-node:ekr.20031218072017.2018:<< say the command is finished >>
#@-node:ekr.20031218072017.2015:top_df.writeAll
#@+node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles
def writeOldDerivedFiles (self):
	
	self.writeDerivedFiles(write_old=true)

def writeNewDerivedFiles (self):

	self.writeDerivedFiles(write_old=false)
	
def writeDerivedFiles (self,write_old):
	
	config = g.app.config
	old = config.write_old_format_derived_files
	config.write_old_format_derived_files = write_old
	self.writeAll(writeAtFileNodesFlag=true)
	config.write_old_format_derived_files = old
#@nonl
#@-node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles
#@-node:EKR.20040429081306.1:Write
#@-node:EKR.20040427075250:Top level atFile
#@+node:EKR.20040427180451:commands, position & vnode methods...
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft(self):
	
	c = self ; p = c.currentPosition()
	if not p: return

	if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
		if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
		return
	
	if not p.hasParent(): return
	# Remember both the before state and the after state for undo/redo
	parent = p.parent()
	oldBack = p.back()
	oldParent = p.parent()
	oldN = p.childIndex()
	c.beginUpdate()
	if 1: # update...
		c.endEditing()
		p.setAllAncestorAtFileNodesDirty()
		p.moveAfter(parent)
		c.undoer.setUndoParams("Move Left",p,
			oldBack=oldBack,oldParent=oldParent,oldN=oldN)
		p.setAllAncestorAtFileNodesDirty()
		c.selectVnode(p)
		c.setChanged(true)
	c.endUpdate()
	c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20040323100443:v.directParents (new method in 4.2)
def directParents (self):
	
	"""(New in 4.2) Return a list of all direct parent vnodes of a vnode.
	
	This is NOT the same as the list of ancestors of the vnode."""
	
	v = self
	
	if v._parent:
		return v._parent.t.vnodeList
	else:
		return []
#@nonl
#@-node:ekr.20040323100443:v.directParents (new method in 4.2)
#@+node:ekr.20031218072017.3425:v.linkAsNthChild
def linkAsNthChild (self,pv,n):

	"""Links self as the n'th child of vnode pv"""

	v = self
	# g.trace(v,pv,n)
	v._parent = pv
	if n == 0:
		v._back = None
		v._next = pv.t._firstChild
		if pv.t._firstChild:
			pv.t._firstChild._back = v
		pv.t._firstChild = v
	else:
		prev = pv.nthChild(n-1) # zero based
		assert(prev)
		v._back = prev
		v._next = prev._next
		prev._next = v
		if v._next:
			v._next._back = v
#@nonl
#@-node:ekr.20031218072017.3425:v.linkAsNthChild
#@+node:ekr.20040310062332.2:p.linkAfter
def linkAfter (self,after):

	"""Link self after v."""
	
	p = self
	# g.trace(p,after)
	
	p.stack = after.stack[:] # 3/12/04
	p.v._parent = after.v._parent
	
	# Add v to it's tnode's vnodeList.
	if p.v not in p.v.t.vnodeList:
		p.v.t.vnodeList.append(p.v)
	
	p.v._back = after.v
	p.v._next = after.v._next
	
	after.v._next = p.v
	
	if p.v._next:
		p.v._next._back = p.v

	if 0:
		g.trace('-'*20,after)
		p.dump(label="p")
		after.dump(label="back")
		if p.hasNext(): p.next().dump(label="next")
#@nonl
#@-node:ekr.20040310062332.2:p.linkAfter
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self
	
	# if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

	if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
		# g.trace("pop",p.v,p)
	else:
		p.v = None

	return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@-node:EKR.20040427180451:commands, position & vnode methods...
#@+node:EKR.20040429082121:4.2 Code Gen Read
#@+node:ekr.20031218072017.2758:scanText4 & allies
def scanText4 (self,file,p):
	
	"""Scan a 4.x derived file non-recursively."""

	at = self
	<< init ivars for scanText4 >>
	while at.errors == 0 and not at.done:
		s = at.readLine(file)
		if len(s) == 0: break
		kind = at.sentinelKind(s)
		# g.trace(at.sentinelName(kind),s.strip())
		if kind == noSentinel:
			i = 0
		else:
			i = at.skipSentinelStart(s,0)
		func = at.dispatch_dict[kind]
		func(s,i)

	if at.errors == 0 and not at.done:
		<< report unexpected end of text >>

	return at.lastLines
#@+node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = false
at.inCode = true
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = false

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
	if hasattr(p.v.t,"tnodeList"):
		g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
	else:
		g.trace("no tnodeList",p.v)
		
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
#@+node:ekr.20031218072017.2760:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
	"Unexpected end of file. Expecting %s sentinel" %
	at.sentinelName(at.endSentinelStack[-1]))
#@nonl
#@-node:ekr.20031218072017.2760:<< report unexpected end of text >>
#@+node:ekr.20031218072017.2761:readNormalLine
def readNormalLine (self,s,i):

	at = self
	
	if at.inCode:
		if not at.raw:
			s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
		at.out.append(s)
	else:
		<< Skip the leading stuff >>
		<< Append s to docOut >>
#@nonl
#@+node:ekr.20031218072017.2762:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
	# Skip the single comment delim and a blank.
	i = g.skip_ws(s,0)
	if g.match(s,i,at.startSentinelComment):
		i += len(at.startSentinelComment)
		if g.match(s,i," "): i += 1
else:
	i = at.skipIndent(s,0,at.indent)

#@-node:ekr.20031218072017.2762:<< Skip the leading stuff >>
#@+node:ekr.20031218072017.2763:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
	# no trailing whitespace: the newline is real.
	at.docOut.append(line + '\n')
else:
	# trailing whitespace: the newline is fake.
	at.docOut.append(line)
#@nonl
#@-node:ekr.20031218072017.2763:<< Append s to docOut >>
#@-node:ekr.20031218072017.2761:readNormalLine
#@+node:ekr.20031218072017.2764:start sentinels
#@+node:EKR.20040430081719:readStartAll (4.2)
def readStartAll (self,s,i):
	
	"""Read an @+all sentinel."""

	at = self
	j = g.skip_ws(s,i)
	leadingWs = s[i:j]
	if leadingWs:
		assert(g.match(s,j,"@+all"))
	else:
		assert(g.match(s,j,"+all"))

	# Make sure that the generated at-all is properly indented.
	at.out.append(leadingWs + "@all\n")
	
	at.endSentinelStack.append(endAll)
#@nonl
#@-node:EKR.20040430081719:readStartAll (4.2)
#@+node:ekr.20031218072017.1752:readStartAt & readStartDoc
def readStartAt (self,s,i):
	"""Read an @+at sentinel."""
	at = self ; assert(g.match(s,i,"+at"))
	if 0:# new code: append whatever follows the sentinel.
		i += 3 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
		at.out.append('@' + follow) ; at.docOut = []
	else:
		i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
		at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
	at.inCode = false
	at.endSentinelStack.append(endAt)
	
def readStartDoc (self,s,i):
	"""Read an @+doc sentinel."""
	at = self ; assert(g.match(s,i,"+doc"))
	if 0: # new code: append whatever follows the sentinel.
		i += 4 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
		at.out.append('@' + follow) ; at.docOut = []
	else:
		i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
		at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
	at.inCode = false
	at.endSentinelStack.append(endDoc)
	
def skipToEndSentinel(self,s,i):
	end = self.endSentinelComment
	if end:
		j = s.find(end,i)
		if j == -1:
			return g.skip_to_end_of_line(s,i)
		else:
			return j
	else:
		return g.skip_to_end_of_line(s,i)
#@nonl
#@-node:ekr.20031218072017.1752:readStartAt & readStartDoc
#@+node:ekr.20031218072017.2765:readStartLeo
def readStartLeo (self,s,i):
	
	"""Read an unexpected @+leo sentinel."""

	at = self
	assert(g.match(s,i,"+leo"))
	at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20031218072017.2765:readStartLeo
#@+node:ekr.20031218072017.2766:readStartNode
def readStartNode (self,s,i):
	
	"""Read an @+node sentinel."""
	
	at = self ; assert(g.match(s,i,"+node:"))
	i += 6
	
	if at.thinFile:
		<< set gnx and bump i >>
	<< Set headline, undoing the CWEB hack >>
	if not at.root_seen:
		at.root_seen = true
		<< Check the filename in the sentinel >>

	i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
	at.indentStack.append(at.indent) ; at.indent = newIndent
	
	at.outStack.append(at.out) ; at.out = []
	at.tStack.append(at.t)

	if at.importing:
		p = at.createImportedNode(at.root,at.c,headline)
		at.t = p.v.t
	elif at.thinFile:
		at.thinNodeStack.append(at.lastThinNode)
		at.lastThinNode = v = at.createThinChild(gnx,headline)
		at.t = v.t
	else:
		at.t = at.findChild(headline)
	
	at.endSentinelStack.append(endNode)
#@nonl
#@+node:EKR.20040427105350:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
	g.trace("no closing colon",g.get_line(s,i))
	at.readError("Expecting gnx in @+node sentinel")
	return # 5/17/04
else:
	gnx = s[i:j]
	i = j + 1 # Skip the i
#@nonl
#@-node:EKR.20040427105350:<< set gnx and bump i >>
#@+node:ekr.20031218072017.2767:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
	headline = s[i:-1].rstrip()
else:
	k = s.rfind(at.endSentinelComment,i)
	headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
	headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20031218072017.2767:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20031218072017.2768:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
	if not at.importing:

		h = headline.strip()
		
		if h[:5] == "@file":
			i,junk,junk = g.scanAtFileOptions(h)
			fileName = string.strip(h[i:])
			if fileName != at.targetFileName:
				at.readError("File name in @node sentinel does not match file's name")
		elif h[:8] == "@rawfile":
			fileName = string.strip(h[8:])
			if fileName != at.targetFileName:
				at.readError("File name in @node sentinel does not match file's name")
		else:
			at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20031218072017.2768:<< Check the filename in the sentinel >>
#@-node:ekr.20031218072017.2766:readStartNode
#@+node:ekr.20031218072017.2769:readStartOthers
def readStartOthers (self,s,i):
	
	"""Read an @+others sentinel."""

	at = self
	j = g.skip_ws(s,i)
	leadingWs = s[i:j]
	if leadingWs:
		assert(g.match(s,j,"@+others"))
	else:
		assert(g.match(s,j,"+others"))

	# Make sure that the generated at-others is properly indented.
	at.out.append(leadingWs + "@others\n")
	
	at.endSentinelStack.append(endOthers)
#@nonl
#@-node:ekr.20031218072017.2769:readStartOthers
#@-node:ekr.20031218072017.2764:start sentinels
#@+node:ekr.20031218072017.2770:end sentinels
#@+node:EKR.20040430081719.1:readEndAll (4.2)
def readEndAll (self,s,i):
	
	"""Read an @-all sentinel."""
	
	at = self
	at.popSentinelStack(endAll)
#@nonl
#@-node:EKR.20040430081719.1:readEndAll (4.2)
#@+node:ekr.20031218072017.1954:readEndAt & readEndDoc
def readEndAt (self,s,i):
	
	"""Read an @-at sentinel."""

	at = self
	at.readLastDocLine("@")
	at.popSentinelStack(endAt)
	at.inCode = true
		
def readEndDoc (self,s,i):
	
	"""Read an @-doc sentinel."""

	at = self
	at.readLastDocLine("@doc")
	at.popSentinelStack(endDoc)
	at.inCode = true
#@nonl
#@-node:ekr.20031218072017.1954:readEndAt & readEndDoc
#@+node:ekr.20031218072017.2771:readEndLeo
def readEndLeo (self,s,i):
	
	"""Read an @-leo sentinel."""
	
	at = self

	# Ignore everything after @-leo.
	# Such lines were presumably written by @last.
	while 1:
		s = at.readLine(at.file)
		if len(s) == 0: break
		at.lastLines.append(s) # Capture all trailing lines, even if empty.

	at.done = true
#@nonl
#@-node:ekr.20031218072017.2771:readEndLeo
#@+node:ekr.20031218072017.2772:readEndNode
def readEndNode (self,s,i):
	
	"""Handle end-of-node processing for @-others and @-ref sentinels."""

	at = self
	
	# End raw mode.
	at.raw = false
	
	# Set the temporary body text.
	s = ''.join(at.out)
	s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

	if at.importing:
		at.t.bodyString = s
	else:
		at.t.tempBodyString = s
			
	# Indicate that the tnode has been set in the derived file.
	at.t.setVisited()

	# End the previous node sentinel.
	at.indent = at.indentStack.pop()
	at.out = at.outStack.pop()
	at.t = at.tStack.pop()
	if at.thinFile:
		at.lastThinNode = at.thinNodeStack.pop()

	at.popSentinelStack(endNode)
#@nonl
#@-node:ekr.20031218072017.2772:readEndNode
#@+node:ekr.20031218072017.2773:readEndOthers
def readEndOthers (self,s,i):
	
	"""Read an @-others sentinel."""
	
	at = self
	at.popSentinelStack(endOthers)
#@nonl
#@-node:ekr.20031218072017.2773:readEndOthers
#@+node:ekr.20031218072017.1753:readLastDocLine
def readLastDocLine (self,tag):
	
	"""Read the @c line that terminates the doc part.
	tag is @doc or @."""
	
	at = self
	end = at.endSentinelComment
	start = at.startSentinelComment
	s = ''.join(at.docOut)
	
	if 0: # new code.
		<< new code >>
	else:
		<< old code >>
#@nonl
#@+node:ekr.20031218072017.1754:<< new code >>
if end:
	# Remove opening block delim.
	if g.match(s,0,start):
		s = s[len(start):]
	else:
		at.readError("Missing open block comment")
		g.trace(s)
		return
		
	# Remove trailing newline.
	if s[-1] == '\n':
		s = s[:-1]

	# Remove closing block delim.
	if s[-len(end):] == end:
		s = s[:-len(end)]
	else:
		at.readError("Missing close block comment")
		return

at.out.append(s) # The tag has already been removed.
at.docOut = []
#@nonl
#@-node:ekr.20031218072017.1754:<< new code >>
#@+node:ekr.20031218072017.1755:<< old code >>
# Remove the @doc or @space.  We'll add it back at the end.
if g.match(s,0,tag):
	s = s[len(tag):]
else:
	at.readError("Missing start of doc part")
	return

if end:
	# Remove opening block delim.
	if g.match(s,0,start):
		s = s[len(start):]
	else:
		at.readError("Missing open block comment")
		g.trace(s)
		return
		
	# Remove trailing newline.
	if s[-1] == '\n':
		s = s[:-1]

	# Remove closing block delim.
	if s[-len(end):] == end:
		s = s[:-len(end)]
	else:
		at.readError("Missing close block comment")
		return

at.out.append(tag + s)
at.docOut = []
#@nonl
#@-node:ekr.20031218072017.1755:<< old code >>
#@-node:ekr.20031218072017.1753:readLastDocLine
#@-node:ekr.20031218072017.2770:end sentinels
#@+node:ekr.20031218072017.2774:Unpaired sentinels
#@+node:ekr.20031218072017.2775:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):
	
	"""Ignore an 3.x sentinel."""
	
	g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@nonl
#@-node:ekr.20031218072017.2775:ignoreOldSentinel
#@+node:ekr.20031218072017.2776:readAfterRef
def  readAfterRef (self,s,i):
	
	"""Read an @afterref sentinel."""
	
	at = self
	assert(g.match(s,i,"afterref"))
	
	# Append the next line to the text.
	s = at.readLine(at.file)
	at.out.append(s)
#@nonl
#@-node:ekr.20031218072017.2776:readAfterRef
#@+node:EKR.20040520093903:readClone
def readClone (self,s,i):
	
	at = self ; tag = "clone"

	assert(g.match(s,i,tag))
	
	# Skip the tag and whitespace.
	i = g.skip_ws(s,i+len(tag))
	
	# Get the clone count.
	junk,val = g.skip_long(s,i)
	
	if val == None:
		at.readError("Invalid count in @clone sentinel")
	else:
		at.cloneSibCount	 = val
#@nonl
#@-node:EKR.20040520093903:readClone
#@+node:ekr.20031218072017.2777:readComment
def readComment (self,s,i):
	
	"""Read an @comment sentinel."""

	assert(g.match(s,i,"comment"))

	# Just ignore the comment line!
#@-node:ekr.20031218072017.2777:readComment
#@+node:ekr.20031218072017.2778:readDelims
def readDelims (self,s,i):
	
	"""Read an @delims sentinel."""
	
	at = self
	assert(g.match(s,i-1,"@delims"));

	# Skip the keyword and whitespace.
	i0 = i-1
	i = g.skip_ws(s,i-1+7)
		
	# Get the first delim.
	j = i
	while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
		i += 1
	
	if j < i:
		at.startSentinelComment = s[j:i]
		# print "delim1:", at.startSentinelComment
	
		# Get the optional second delim.
		j = i = g.skip_ws(s,i)
		while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
			i += 1
		end = g.choose(j<i,s[j:i],"")
		i2 = g.skip_ws(s,i)
		if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
			at.endSentinelComment = "" # Not really two params.
			line = s[i0:j]
			line = line.rstrip()
			at.out.append(line+'\n')
		else:
			at.endSentinelComment = end
			# print "delim2:",end
			line = s[i0:i]
			line = line.rstrip()
			at.out.append(line+'\n')
	else:
		at.readError("Bad @delims")
		# Append the bad @delims line to the body text.
		at.out.append("@delims")
#@nonl
#@-node:ekr.20031218072017.2778:readDelims
#@+node:ekr.20031218072017.2779:readDirective
def readDirective (self,s,i):
	
	"""Read an @@sentinel."""
	
	at = self
	assert(g.match(s,i,"@")) # The first '@' has already been eaten.
	
	if g.match_word(s,i,"@raw"):
		at.raw = true
	elif g.match_word(s,i,"@end_raw"):
		at.raw = false
	
	e = at.endSentinelComment
	s2 = s[i:]
	if len(e) > 0:
		k = s.rfind(e,i)
		if k != -1:
			s2 = s[i:k] + '\n'
		
	start = at.startSentinelComment
	if start and len(start) > 0 and start[-1] == '@':
		s2 = s2.replace('@@','@')

	at.out.append(s2)
#@nonl
#@-node:ekr.20031218072017.2779:readDirective
#@+node:ekr.20031218072017.2780:readNl
def readNl (self,s,i):
	
	"""Handle an @nonl sentinel."""
	
	at = self
	assert(g.match(s,i,"nl"))
	
	if at.inCode:
		at.out.append('\n')
	else:
		at.docOut.append('\n')
#@nonl
#@-node:ekr.20031218072017.2780:readNl
#@+node:ekr.20031218072017.2781:readNonl
def readNonl (self,s,i):
	
	"""Handle an @nonl sentinel."""
	
	at = self
	assert(g.match(s,i,"nonl"))
	
	if at.inCode:
		s = ''.join(at.out)
		if s and s[-1] == '\n':
			at.out = [s[:-1]]
		else:
			g.trace("out:",s)
			at.readError("unexpected @nonl directive in code part")	
	else:
		s = ''.join(at.pending)
		if s:
			if s and s[-1] == '\n':
				at.pending = [s[:-1]]
			else:
				g.trace("docOut:",s)
				at.readError("unexpected @nonl directive in pending doc part")
		else:
			s = ''.join(at.docOut)
			if s and s[-1] == '\n':
				at.docOut = [s[:-1]]
			else:
				g.trace("docOut:",s)
				at.readError("unexpected @nonl directive in doc part")
#@nonl
#@-node:ekr.20031218072017.2781:readNonl
#@+node:ekr.20031218072017.2782:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
	
	"""Handle an @<< sentinel."""
	
	at = self
	j = g.skip_ws(s,i)
	assert(g.match(s,j,"<<"))
	
	if len(at.endSentinelComment) == 0:
		line = s[i:-1] # No trailing newline
	else:
		k = s.find(at.endSentinelComment,i)
		line = s[i:k] # No trailing newline, whatever k is.
			
	# Undo the cweb hack.
	start = at.startSentinelComment
	if start and len(start) > 0 and start[-1] == '@':
		line = line.replace('@@','@')

	at.out.append(line)
#@-node:ekr.20031218072017.2782:readRef
#@+node:ekr.20031218072017.2783:readVerbatim
def readVerbatim (self,s,i):
	
	"""Read an @verbatim sentinel."""
	
	at = self
	assert(g.match(s,i,"verbatim"))
	
	# Append the next line to the text.
	s = at.readLine(at.file) 
	i = at.skipIndent(s,0,at.indent)
	at.out.append(s[i:])
#@nonl
#@-node:ekr.20031218072017.2783:readVerbatim
#@-node:ekr.20031218072017.2774:Unpaired sentinels
#@+node:ekr.20031218072017.2784:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):
	
	"""Handle a mismatched ending sentinel."""

	at = self
	assert(at.endSentinelStack)
	at.readError("Ignoring %s sentinel.  Expecting %s" %
		(at.sentinelName(at.endSentinelStack[-1]),
		 at.sentinelName(expectedKind)))
		 
def popSentinelStack (self,expectedKind):
	
	"""Pop an entry from endSentinelStack and check it."""
	
	at = self
	if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
		at.endSentinelStack.pop()
	else:
		at.badEndSentinel(expectedKind)
#@nonl
#@-node:ekr.20031218072017.2784:badEndSentinel, push/popSentinelStack
#@-node:ekr.20031218072017.2758:scanText4 & allies
#@+node:ekr.20040321064134.5:createThinChild (4.2)
def createThinChild (self,gnxString,headline):

	"""Find or create a new vnode whose parent is at.lastThinNode."""

	at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
	last = at.lastThinNode ; lastIndex = last.t.fileIndex
	gnx = indices.scanGnx(gnxString,0)
	#g.trace("last",last,last.t.fileIndex)
	#g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
	
	# See if there is already a child with the proper index.
	child = at.lastThinNode.firstChild()
	while child and not indices.areEqual(gnx,child.t.fileIndex):
		child = child.next()

	if at.cloneSibCount > 1:
		n = at.cloneSibCount ; at.cloneSibCount = 0
		if child: clonedSibs,junk = at.scanForClonedSibs(child)
		else: clonedSibs = 0
		copies = n - clonedSibs
		# g.trace(copies,headline)
	else:
		if indices.areEqual(gnx,lastIndex):
			return last
		if child:
			return child
		copies = 1 # Create exactly one copy.

	while copies > 0:
		copies -= 1
		# Create the tnode only if it does not already exist.
		tnodesDict = c.fileCommands.tnodesDict
		t = tnodesDict.get(gnxString)
		if t:
			assert(indices.areEqual(t.fileIndex,gnx))
		else:
			t = leoNodes.tnode(bodyString=None,headString=headline)
			t.fileIndex = gnx
			tnodesDict[gnxString] = t
		parent = at.lastThinNode
		child = leoNodes.vnode(c,t)
		t.vnodeList.append(child)
		child.linkAsNthChild(parent,parent.numberOfChildren())
		# g.trace("creating node",child,gnx)

	return child
#@nonl
#@-node:ekr.20040321064134.5:createThinChild (4.2)
#@+node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = false
at.inCode = true
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = false

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
	if hasattr(p.v.t,"tnodeList"):
		g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
	else:
		g.trace("no tnodeList",p.v)
		
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20031218072017.2759:<< init ivars for scanText4 >>
#@+node:ekr.20031218072017.2766:readStartNode
def readStartNode (self,s,i):
	
	"""Read an @+node sentinel."""
	
	at = self ; assert(g.match(s,i,"+node:"))
	i += 6
	
	if at.thinFile:
		<< set gnx and bump i >>
	<< Set headline, undoing the CWEB hack >>
	if not at.root_seen:
		at.root_seen = true
		<< Check the filename in the sentinel >>

	i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
	at.indentStack.append(at.indent) ; at.indent = newIndent
	
	at.outStack.append(at.out) ; at.out = []
	at.tStack.append(at.t)

	if at.importing:
		p = at.createImportedNode(at.root,at.c,headline)
		at.t = p.v.t
	elif at.thinFile:
		at.thinNodeStack.append(at.lastThinNode)
		at.lastThinNode = v = at.createThinChild(gnx,headline)
		at.t = v.t
	else:
		at.t = at.findChild(headline)
	
	at.endSentinelStack.append(endNode)
#@nonl
#@+node:EKR.20040427105350:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
	g.trace("no closing colon",g.get_line(s,i))
	at.readError("Expecting gnx in @+node sentinel")
	return # 5/17/04
else:
	gnx = s[i:j]
	i = j + 1 # Skip the i
#@nonl
#@-node:EKR.20040427105350:<< set gnx and bump i >>
#@+node:ekr.20031218072017.2767:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
	headline = s[i:-1].rstrip()
else:
	k = s.rfind(at.endSentinelComment,i)
	headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
	headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20031218072017.2767:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20031218072017.2768:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
	if not at.importing:

		h = headline.strip()
		
		if h[:5] == "@file":
			i,junk,junk = g.scanAtFileOptions(h)
			fileName = string.strip(h[i:])
			if fileName != at.targetFileName:
				at.readError("File name in @node sentinel does not match file's name")
		elif h[:8] == "@rawfile":
			fileName = string.strip(h[8:])
			if fileName != at.targetFileName:
				at.readError("File name in @node sentinel does not match file's name")
		else:
			at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20031218072017.2768:<< Check the filename in the sentinel >>
#@-node:ekr.20031218072017.2766:readStartNode
#@+node:ekr.20031218072017.2772:readEndNode
def readEndNode (self,s,i):
	
	"""Handle end-of-node processing for @-others and @-ref sentinels."""

	at = self
	
	# End raw mode.
	at.raw = false
	
	# Set the temporary body text.
	s = ''.join(at.out)
	s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

	if at.importing:
		at.t.bodyString = s
	else:
		at.t.tempBodyString = s
			
	# Indicate that the tnode has been set in the derived file.
	at.t.setVisited()

	# End the previous node sentinel.
	at.indent = at.indentStack.pop()
	at.out = at.outStack.pop()
	at.t = at.tStack.pop()
	if at.thinFile:
		at.lastThinNode = at.thinNodeStack.pop()

	at.popSentinelStack(endNode)
#@nonl
#@-node:ekr.20031218072017.2772:readEndNode
#@-node:EKR.20040429082121:4.2 Code Gen Read
#@+node:EKR.20040429080901.1:4.2 Code Gen Write
#@+node:ekr.20031218072017.2136:directiveKind (4.x)
# Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

	at = self
	n = len(s)
	if i >= n or s[i] != '@':
		j = g.skip_ws(s,i)
		if g.match_word(s,j,"@others"):
			return othersDirective
		elif g.match_word(s,j,"@all"):
			return allDirective
		else:
			return noDirective

	table = (
		("@all",allDirective),
		("@c",cDirective),
		("@code",codeDirective),
		("@doc",docDirective),
		("@end_raw",endRawDirective),
		("@others",othersDirective),
		("@raw",rawDirective))

	# This code rarely gets executed, so simple code suffices.
	if i+1 >= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
		# 10/25/02: @space is not recognized in cweb mode.
		# 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
		return g.choose(at.language=="cweb",
			noDirective,atDirective)

	# 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
	# We treat @(nonalpha) separately because @ is in the colorizer table.
	if at.language=="cweb" and (
		g.match_word(s,i,"@c") or
		i+1>= n or s[i+1] not in string.ascii_letters):
		return noDirective

	for name,directive in table:
		if g.match_word(s,i,name):
			return directive

	# 10/14/02: return miscDirective only for real directives.
	for name in leoColor.leoKeywords:
		if g.match_word(s,i,name):
			return miscDirective

	return noDirective
#@nonl
#@-node:ekr.20031218072017.2136:directiveKind (4.x)
#@+node:EKR.20040429083147.3: Sentinels
#@+node:ekr.20031218072017.2786:nodeSentinelText 4.x
def nodeSentinelText(self,p):
	
	"""Return the text of a @+node or @-node sentinel for p."""
	
	at = self ; h = p.headString()
	<< remove comment delims from h if necessary >>
	
	if at.thinFile:
		gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
		return "%s:%s" % (gnx,h)
	else:
		return h
#@nonl
#@+node:ekr.20031218072017.2787:<< remove comment delims from h if necessary >>
@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) > 0:
	h = h.replace(start,"")
	h = h.replace(end,"")
#@nonl
#@-node:ekr.20031218072017.2787:<< remove comment delims from h if necessary >>
#@-node:ekr.20031218072017.2786:nodeSentinelText 4.x
#@+node:EKR.20040427095028:putCloseNodeSentinel 4.x
def putCloseNodeSentinel(self,p,inAtAll=false,inAtOthers=false):
	
	at = self
	
	s = self.nodeSentinelText(p)
	at.putSentinel("@-node:" + s)
#@nonl
#@-node:EKR.20040427095028:putCloseNodeSentinel 4.x
#@+node:ekr.20031218072017.2788:putLeadInSentinel
def putLeadInSentinel (self,s,i,j,delta):
	
	"""Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
	
	Set at.leadingWs as needed for @+others and @+<< sentinels.

	i points at the start of a line.
	j points at @others or a section reference.
	delta is the change in at.indent that is about to happen and hasn't happened yet."""

	at = self
	at.leadingWs = "" # Set the default.
	if i == j:
		return # The @others or ref starts a line.

	k = g.skip_ws(s,i)
	if j == k:
		# Only whitespace before the @others or ref.
		at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
	else:
		# g.trace("indent",self.indent)
		self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
		at.os(s[i:j]) ; at.onl_sent() # 10/21/03
		at.indent += delta # Align the @nonl with the following line.
		at.putSentinel("@nonl")
		at.indent -= delta # Let the caller set at.indent permanently.
#@nonl
#@-node:ekr.20031218072017.2788:putLeadInSentinel
#@+node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=false,inAtOthers=false):
	
	"""Write @+node sentinel for p."""
	
	at = self

	if not inAtAll and p.isAtFileNode() and p != at.root:
		at.writeError("@file not valid in: " + p.headString())
		return
		
	# g.trace(at.thinFile,p)
		
	s = at.nodeSentinelText(p)
	at.putSentinel("@+node:" + s)
	
	if not at.thinFile:
		# Append the n'th tnode to the root's tnode list.
		at.root.v.t.tnodeList.append(p.v.t)
#@nonl
#@-node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
#@-node:EKR.20040429083147.3: Sentinels
#@+node:ekr.20031218072017.2128:putBody (4.x)
def putBody(self,p,putCloseSentinel=true):
	
	""" Generate the body enclosed in sentinel lines."""

	at = self ; s = p.bodyString()
	
	p.v.t.setVisited() # Suppress orphans check.
	p.v.setVisited() # Make sure v is never expanded again.
	if not at.thinFile:
		p.v.t.setWriteBit() # Mark the tnode to be written.
		
	if not at.thinFile and not s: return
	inCode = true
	<< Make sure all lines end in a newline >>
	i = 0
	while i < len(s):
		next_i = g.skip_line(s,i)
		assert(next_i > i)
		kind = at.directiveKind(s,i)
		<< handle line at s[i] >>
		i = next_i
	if not inCode:
		at.putEndDocLine()
	if at.sentinels and not trailingNewlineFlag:
		at.putSentinel("@nonl")
#@nonl
#@+node:EKR.20040429084140:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
	trailingNewlineFlag = s and s[-1] == '\n'
	if (at.sentinels or at.scripting) and not trailingNewlineFlag:
		s = s + '\n'
else:
	trailingNewlineFlag = true # don't need to generate an @nonl
#@nonl
#@-node:EKR.20040429084140:<< Make sure all lines end in a newline >>
#@+node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
if kind == noDirective:
	if inCode:
		hasRef,n1,n2 = at.findSectionName(s,i)
		if hasRef and not at.raw:
			at.putRefLine(s,i,n1,n2,p)
		else:
			at.putCodeLine(s,i)
	else:
		at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
	assert(not at.pending)
	at.putStartDocLine(s,i,kind)
	inCode = false
elif kind in (cDirective,codeDirective):
	# Only @c and @code end a doc part.
	if not inCode:
		at.putEndDocLine() 
	at.putDirective(s,i)
	inCode = true
elif kind == allDirective:
	if inCode: at.putAtAllLine(s,i,p)
	else: at.putDocLine(s,i)
elif kind == othersDirective:
	if inCode: at.putAtOthersLine(s,i,p)
	else: at.putDocLine(s,i) # 12/7/03
elif kind == rawDirective:
	at.raw = true
	at.putSentinel("@@raw")
elif kind == endRawDirective:
	at.raw = false
	at.putSentinel("@@end_raw")
	i = g.skip_line(s,i)
elif kind == miscDirective:
	at.putDirective(s,i)
else:
	assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
#@-node:ekr.20031218072017.2128:putBody (4.x)
#@+node:ekr.20031218072017.2755:newDerivedFile.__init__
def __init__(self,c):
	
	"""Ctor for 4.x atFile class."""
	
	at = self

	# Initialize the base class.
	oldDerivedFile.__init__(self,c) 

	# For 4.x reading & writing...
	at.inCode = true
	at.thinFile = false
	at.cloneSibCount = 0 # n > 1: Make sure n cloned sibs exists at next @+node sentinel

	# For 4.x writing...
	at.docKind = None
	at.pending = [] # Doc part that remains to be written.

	# For 4.x reading...
	at.docOut = [] # The doc part being accumulated.
	at.done = false # true when @-leo seen.
	at.endSentinelStack = []
	at.importing = false
	at.indent = 0 ; at.indentStack = []
	at.lastLines = [] # The lines after @-leo
	at.leadingWs = ""
	at.out = None ; at.outStack = []
	at.root_seen = false # true: root vnode has been handled in this file.
	at.tnodeList = [] ; at.tnodeListIndex = 0
	at.t = None ; at.tStack = []
	
	# For reading thin derived files.
	at.lastThinNode = None ; at.thinNodeStack = [] # Used by createThinChild.

	<< Create the dispatch dictionary used by scanText4 >>
#@nonl
#@+node:EKR.20040427134616:<< Create the dispatch dictionary used by scanText4 >>
at.dispatch_dict = {
	# Plain line.
	noSentinel: at.readNormalLine,
	# Starting sentinels...
	startAll:    at.readStartAll,
	startAt:     at.readStartAt,
	startDoc:    at.readStartDoc,
	startLeo:    at.readStartLeo,
	startNode:   at.readStartNode,
	startOthers: at.readStartOthers,
	# Ending sentinels...
	endAll:    at.readEndAll,
	endAt:     at.readEndAt,
	endDoc:    at.readEndDoc,
	endLeo:    at.readEndLeo,
	endNode:   at.readEndNode,
	endOthers: at.readEndOthers,
	# Non-paired sentinels.
	startAfterRef:  at.readAfterRef,
	startClone:     at.readClone,
	startComment:   at.readComment,
	startDelims:    at.readDelims,
	startDirective: at.readDirective,
	startNl:        at.readNl,
	startNonl:      at.readNonl,
	startRef:       at.readRef,
	startVerbatim:  at.readVerbatim,
	# Ignored 3.x sentinels
	endBody:               at.ignoreOldSentinel,
	startBody:             at.ignoreOldSentinel,
	startVerbatimAfterRef: at.ignoreOldSentinel }
#@nonl
#@-node:EKR.20040427134616:<< Create the dispatch dictionary used by scanText4 >>
#@-node:ekr.20031218072017.2755:newDerivedFile.__init__
#@+node:ekr.20031218072017.2130:code lines... (4.x)
#@+node:EKR.20040430081109.1:@all
#@+node:EKR.20040430080943.1:putAtAllLine
def putAtAllLine (self,s,i,p):
	
	"""Put the expansion of @others."""
	
	at = self
	j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
	at.putLeadInSentinel(s,i,j,delta)

	at.indent += delta
	if at.leadingWs:
		at.putSentinel("@" + at.leadingWs + "@+all")
	else:
		at.putSentinel("@+all")
	
	for child in p.children_iter():
		at.putAtAllChild(child)

	at.putSentinel("@-all")
	at.indent -= delta
#@nonl
#@-node:EKR.20040430080943.1:putAtAllLine
#@+node:EKR.20040430104717:putatAllBody
def putAtAllBody(self,p,putCloseSentinel=true):
	
	""" Generate the body enclosed in sentinel lines."""

	at = self ; s = p.bodyString()
	
	## p.v.setVisited()   # Make sure v is never expanded again.
	p.v.t.setVisited() # Use the tnode for the orphans check.
	if not at.thinFile and not s: return
	inCode = true
	<< Make sure all lines end in a newline >>
	i = 0
	while i < len(s):
		next_i = g.skip_line(s,i)
		assert(next_i > i)
		if inCode:
			# Use verbatim sentinels to write all directives.
			at.putCodeLine(s,i)
		else:
			at.putDocLine(s,i)
		i = next_i

	if not inCode:
		at.putEndDocLine()
	if at.sentinels and not trailingNewlineFlag:
		at.putSentinel("@nonl")
#@nonl
#@+node:EKR.20040430104717.1:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
	trailingNewlineFlag = s and s[-1] == '\n'
	if (at.sentinels or at.scripting) and not trailingNewlineFlag:
		s = s + '\n'
else:
	trailingNewlineFlag = true # don't need to generate an @nonl
#@nonl
#@-node:EKR.20040430104717.1:<< Make sure all lines end in a newline >>
#@-node:EKR.20040430104717:putatAllBody
#@+node:EKR.20040430080943.2:putAtAllChild
@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
	
	at = self
	
	clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
	if clonedSibs > 1:
		if thisClonedSibIndex == 1:
			at.putSentinel("@clone %d" % (clonedSibs))
		else: return # Don't write second or greater trees.

	at.putOpenNodeSentinel(p,inAtAll=true) # Suppress warnings about @file nodes.
	at.putAtAllBody(p) 
	
	for child in p.children_iter():
		at.putAtAllChild(child)

	at.putCloseNodeSentinel(p,inAtAll=true)
#@nonl
#@-node:EKR.20040430080943.2:putAtAllChild
#@-node:EKR.20040430081109.1:@all
#@+node:EKR.20040430081109.2:@others
#@+node:ekr.20031218072017.2131:inAtOthers
def inAtOthers(self,p):
	
	"""Returns true if p should be included in the expansion of the at-others directive
	
	in the body text of p's parent."""

	# Return false if this has been expanded previously.
	if  p.v.isVisited():
		# g.trace("previously visited",p.v)
		return false
	
	# Return false if this is a definition node.
	h = p.headString() ; i = g.skip_ws(h,0)
	isSection,junk = self.isSectionName(h,i)
	if isSection:
		# g.trace("is section",p)
		return false

	# Return false if p's body contains an @ignore directive.
	if p.isAtIgnoreNode():
		# g.trace("is @ignore",p)
		return false
	else:
		# g.trace("ok",p)
		return true
#@nonl
#@-node:ekr.20031218072017.2131:inAtOthers
#@+node:ekr.20031218072017.2132:putAtOthersChild
def putAtOthersChild(self,p):
	
	at = self

	at.putOpenNodeSentinel(p,inAtOthers=true)
	at.putBody(p) 
	
	# Insert expansions of all children.
	for child in p.children_iter():
		if at.inAtOthers(child):
			at.putAtOthersChild(child)
			
	at.putCloseNodeSentinel(p,inAtOthers=true)
#@nonl
#@-node:ekr.20031218072017.2132:putAtOthersChild
#@+node:ekr.20031218072017.2133:putAtOthersLine
def putAtOthersLine (self,s,i,p):
	
	"""Put the expansion of @others."""
	
	at = self
	j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
	at.putLeadInSentinel(s,i,j,delta)

	at.indent += delta
	if at.leadingWs:
		at.putSentinel("@" + at.leadingWs + "@+others")
	else:
		at.putSentinel("@+others")
	
	for child in p.children_iter():
		if at.inAtOthers(child):
			at.putAtOthersChild(child)

	at.putSentinel("@-others")
	at.indent -= delta
#@nonl
#@-node:ekr.20031218072017.2133:putAtOthersLine
#@-node:EKR.20040430081109.2:@others
#@+node:ekr.20031218072017.2134:putCodeLine
def putCodeLine (self,s,i):
	
	"""Put a normal code line."""
	
	at = self
	
	# Put @verbatim sentinel if required.
	k = g.skip_ws(s,i)
	if g.match(s,k,self.startSentinelComment + '@'):
		self.putSentinel("@verbatim")

	j = g.skip_line(s,i)
	line = s[i:j]
	
	# 1/29/04: Don't put leading indent if the line is empty!
	if line and not at.raw:
		at.putIndent(at.indent)

	if line[-1:]=="\n": # 12/2/03: emakital
		at.os(line[:-1])
		at.onl()
	else:
		at.os(line)
#@nonl
#@-node:ekr.20031218072017.2134:putCodeLine
#@+node:ekr.20031218072017.2106:putRefLine & allies
#@+node:EKR.20040430081109:putRefLine
def putRefLine(self,s,i,n1,n2,p):
	
	"""Put a line containing one or more references."""
	
	at = self
	
	# Compute delta only once.
	delta = self.putRefAt(s,i,n1,n2,p,delta=None)
	if delta is None: return # 11/23/03
	
	while 1:
		i = n2 + 2
		hasRef,n1,n2 = at.findSectionName(s,i)
		if hasRef:
			self.putAfterMiddleRef(s,i,n1,delta)
			self.putRefAt(s,n1,n1,n2,p,delta)
		else:
			break
	
	self.putAfterLastRef(s,i,delta)
#@-node:EKR.20040430081109:putRefLine
#@+node:ekr.20031218072017.2107:PutRefAt
def putRefAt (self,s,i,n1,n2,p,delta):
	
	"""Put a reference at s[n1:n2+2] from p."""
	
	at = self ; name = s[n1:n2+2]

	ref = g.findReference(name,p)
	if not ref:
		at.writeError(
			"undefined section: %s\n\treferenced from: %s" %
			( name,p.headString()))
		return None
	
	# Expand the ref.
	if not delta:
		junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

	at.putLeadInSentinel(s,i,n1,delta)

	at.indent += delta
	if at.leadingWs:
		at.putSentinel("@" + at.leadingWs + name)
	else:
		at.putSentinel("@" + name)
		
	at.putOpenNodeSentinel(ref)
	at.putBody(ref)
	at.putCloseNodeSentinel(ref)
	
	at.indent -= delta
	
	return delta
#@nonl
#@-node:ekr.20031218072017.2107:PutRefAt
#@+node:ekr.20031218072017.2108:putAfterLastRef
def putAfterLastRef (self,s,start,delta):
	
	"""Handle whatever follows the last ref of a line."""
	
	at = self
	
	j = g.skip_ws(s,start)
	
	if j < len(s) and s[j] != '\n':
		end = g.skip_line(s,start)
		after = s[start:end] # Ends with a newline only if the line did.
		# Temporarily readjust delta to make @afterref look better.
		at.indent += delta
		at.putSentinel("@afterref")
		at.os(after)
		if at.sentinels and after and after[-1] != '\n':
			at.onl() # Add a newline if the line didn't end with one.
		at.indent -= delta
	else:
		# Temporarily readjust delta to make @nl look better.
		at.indent += delta
		at.putSentinel("@nl")
		at.indent -= delta
#@nonl
#@-node:ekr.20031218072017.2108:putAfterLastRef
#@+node:ekr.20031218072017.2109:putAfterMiddleef
def putAfterMiddleRef (self,s,start,end,delta):
	
	"""Handle whatever follows a ref that is not the last ref of a line."""
	
	at = self
	
	if start < end:
		after = s[start:end]
		at.indent += delta
		at.putSentinel("@afterref")
		at.os(after) ; at.onl_sent() # Not a real newline.
		at.putSentinel("@nonl")
		at.indent -= delta
#@nonl
#@-node:ekr.20031218072017.2109:putAfterMiddleef
#@-node:ekr.20031218072017.2106:putRefLine & allies
#@-node:ekr.20031218072017.2130:code lines... (4.x)
#@+node:ekr.20040128174042:atFile.warnAboutOrpanAndIgnoredNodes
def warnAboutOrphandAndIgnoredNodes (self):
	
	# Always warn, even when language=="cweb"
	at = self ; root = at.root

	for p in root.self_and_subtree_iter():
		if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
			at.writeError("Orphan node:  " + p.headString())
			if p.isCloned() and p.hasParent():
				g.es("parent node: " + p.parent().headString(),color="blue")
			if not at.thinFile and p.isAtIgnoreNode():
				at.writeError("@ignore node: " + p.headString())
				
	if at.thinFile:
		p = root.copy() ; after = p.nodeAfterTree()
		while p and p != after:
			if p.isAtAllNode():
				p.moveToNodeAfterTree()
			else:
				if p.isAtIgnoreNode():
					at.writeError("@ignore node: " + p.headString())
				p.moveToThreadNext()
#@nonl
#@-node:ekr.20040128174042:atFile.warnAboutOrpanAndIgnoredNodes
#@-node:EKR.20040429080901.1:4.2 Code Gen Write
#@-node:ekr.20040319104735:(@file-thin)
#@+node:EKR.20040425130443:(Clone bug)
#@+node:EKR.20040502120243:Report & fix
@nocolor

The fix was to set v.t.vnodeList in p.linkAsRoot and v.linkAsRoot.
While I was at it, I made c.setRootPosition more robust.


Open Discussion
http://sourceforge.net/forum/forum.php?thread_id=1058570&forum_id=10226

By: Maxim Krikun - tws5
 4.2a1 problems   
2004-04-16 07:16  

 I'm using this alpha for two days, and had experienced certain strange behaviour. Probably this is related to the warning above. Anyway, here is a report:

(1) Focus switch instead of moving node when moving clones

Create the following tree (all nodes empty):

ROOT
..clone (1)
..A
	clone (2)
..B
	clone (3)

If i sit in clone(3) and press Ctrl+U, the focus goes to clone(2). Next Ctrl+U sets focus to clone (1).

If i sit in clone(1) and press Ctrl+D, i get (surprising)

ROOT
..clone
..clone

(2) _parent lost somewhere:

in a new file, create 'ROOT' root node
insert 'SUB' node (Ctrl+I)
move right (Ctri+R)
at this point ROOT collapses
trying to move 'SUB' left (Ctrl+L) raises an exception:

exception executing command
Traceback (most recent call last):
File "C:\maxim\leo\leo-4.2-a1\src\leoCommands.py", line 140, in doCommand
command()
File "C:\maxim\leo\leo-4.2-a1\src\leoCommands.py", line 3353, in moveOutlineLeft
p.moveAfter(parent)
File "C:\maxim\leo\leo-4.2-a1\src\leoNodes.py", line 2493, in moveAfter
p.linkAfter(a)
File "C:\maxim\leo\leo-4.2-a1\src\leoNodes.py", line 2987, in linkAfter
p.v._parent = after.v._parent
AttributeError: 'NoneType' object has no attribute '_parent'

Also when sitting at "SUB" cannot move up with 'Alt+Up'  
#@-node:EKR.20040502120243:Report & fix
#@+node:EKR.20040502123721:Changed code
#@+node:ekr.20031218072017.2988:c.rootPosition & c.setRootPosition
def rootPosition(self):
	
	"""Return the root position."""
	
	return self._rootPosition.copy()

def setRootPosition(self,p):
	
	"""Set the root positioin."""

	self._rootPosition = p.copy() # Potential bug fix: 5/2/04
	
# Define these for compatibiility with old scripts.
rootVnode = rootPosition
setRootVnode = setRootPosition
#@nonl
#@-node:ekr.20031218072017.2988:c.rootPosition & c.setRootPosition
#@+node:ekr.20040310062332.4:p.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link self as the root node."""
	
	# g.trace(self,oldRoot)

	p = self ; v = p.v
	if oldRoot: oldRootVnode = oldRoot.v
	else:       oldRootVnode = None
	
	p.stack = [] # Clear the stack.
	
	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRootVnode # Bug fix: 3/12/04
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot:
		oldRoot.v._back = v # Bug fix: 3/12/04

	p.c.setRootPosition(p)
	
	if 0:
		p.dump(label="root")
#@-node:ekr.20040310062332.4:p.linkAsRoot
#@+node:ekr.20031218072017.3426:v.linkAsRoot
def linkAsRoot (self,oldRoot):
	
	"""Link a vnode as the root node and set the root _position_."""

	v = self ; c = v.c

	# Clear all links except the child link.
	v._parent = None
	v._back = None
	v._next = oldRoot
	
	# Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
	if v not in v.t.vnodeList:
		v.t.vnodeList.append(v)

	# Link in the rest of the tree only when oldRoot != None.
	# Otherwise, we are calling this routine from init code and
	# we want to start with a pristine tree.
	if oldRoot: oldRoot._back = v

	newRoot = position(v,[])
	c.setRootPosition(newRoot)
#@nonl
#@-node:ekr.20031218072017.3426:v.linkAsRoot
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
	
	"""Move a position to its parent position."""
	
	p = self
	
	# if p.v._parent: g.trace(len(p.v._parent.t.vnodeList),p.v._parent)

	if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
		p.v = p.v._parent
	elif p.stack:
		p.v = p.stack.pop()
		# g.trace("pop",p.v,p)
	else:
		p.v = None

	return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@-node:EKR.20040502123721:Changed code
#@-node:EKR.20040425130443:(Clone bug)
#@+node:EKR.20040427074150:(Fixed problems with sboutline only option)
#@+node:EKR.20040503071007:Notes
@nocolor

After a match, the find-next command searched only in the suboutline where the first match occured.
To fix this, we call g.app.findFrame.handleUserClick in various Tk event handlers.
This was a long-standing problem.

The call to g.app.findFrame.handleUserClick(p) probably should be in a base class.  How to do this?
#@nonl
#@-node:EKR.20040503071007:Notes
#@+node:EKR.20040503070514:handleUserClick
def handleUserClick (self,p):
	
	"""Reset suboutline-only search when the user clicks a headline."""
	
	try:
		if self.c and self.c.suboutline_only_flag:
			# g.trace(p)
			self.onlyVnode = p
	except: pass
#@nonl
#@-node:EKR.20040503070514:handleUserClick
#@+node:EKR.20040503072338.1:Event handlers
#@+node:ekr.20031218072017.2339:OnBoxClick
# Called on click in box and double-click in headline.

def OnBoxClick (self,p):
	
	# g.trace(p)

	# Note: "boxclick" hooks handled by vnode callback routine.
	c = self.c ; gui = g.app.gui

	if p.isExpanded(): p.contract()
	else:              p.expand()

	self.active = true
	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	gui.set_focus(c,c.frame.bodyCtrl) # 7/12/03
	self.redraw()
#@nonl
#@-node:ekr.20031218072017.2339:OnBoxClick
#@+node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
def OnIconClick (self,p,event):
	
	# g.trace(p)
	
	p = p.copy() # Make sure callbacks use the _present_ position.

	tree = self ; canvas = tree.canvas
	if event:
		canvas_x = canvas.canvasx(event.x)
		canvas_y = canvas.canvasy(event.y)
		id = canvas.find_closest(canvas_x,canvas_y)
		if id != None:
			try: id = id[0]
			except: pass
			self.drag_p = p
			self.drag_id = id
			
			# Create the bindings.
			id4 = canvas.tag_bind(id,"<B1-Motion>", p.OnDrag)
			id5 = canvas.tag_bind(id,"<Any-ButtonRelease-1>", p.OnEndDrag)
			
			# Remember the bindings so deleteBindings can delete them.
			self.tagBindings.append((id,id4,"<B1-Motion>"),)
			self.tagBindings.append((id,id5,"<Any-ButtonRelease-1>"),)
	tree.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	return "break" # disable expanded box handling.
	
def OnIconRightClick (self,p,event):

	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20031218072017.2346:tree.OnIconClick & OnIconRightClick
#@+node:ekr.20031218072017.2337:OnActivate
def OnActivate (self,p,event=None):

	try:
		c = self.c ; gui = g.app.gui
		<< activate this window >>
	except:
		g.es_event_exception("activate tree")
#@nonl
#@+node:ekr.20031218072017.2338:<< activate this window >>
current = c.currentPosition()

if p == current:
	if self.active:
		self.editLabel(p)
	else:
		self.undimEditLabel()
		gui.set_focus(c,self.canvas) # Essential for proper editing.
else:
	self.select(p)
	g.app.findFrame.handleUserClick(p) # 4/3/04
	if p.v.t.insertSpot != None: # 9/1/02
		c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
		c.frame.bodyCtrl.see(p.v.t.insertSpot)
	else:
		c.frame.bodyCtrl.mark_set("insert","1.0")
	gui.set_focus(c,c.frame.bodyCtrl)

self.active = true
#@nonl
#@-node:ekr.20031218072017.2338:<< activate this window >>
#@-node:ekr.20031218072017.2337:OnActivate
#@-node:EKR.20040503072338.1:Event handlers
#@-node:EKR.20040427074150:(Fixed problems with sboutline only option)
#@+node:EKR.20040503090928.1:(Don't write top-level body text in @file-thin nodes)
#@+node:EKR.20040503093407.1:Notes
@nocolor

Ooops.  p.v.t.visitedBit was used for two purposes:

- To mark the nodes to be written.
- To mark nodes that are not orphan.

What I did:

- Added t.is/set/clearWriteBit.
- Call t.setWriteBit in putVnode unless we are in a thin node.
- putTnodes tests for t.writeBit rather than t.visitedBit.
#@nonl
#@-node:EKR.20040503093407.1:Notes
#@+node:ekr.20031218072017.2128:putBody (4.x)
def putBody(self,p,putCloseSentinel=true):
	
	""" Generate the body enclosed in sentinel lines."""

	at = self ; s = p.bodyString()
	
	p.v.t.setVisited() # Suppress orphans check.
	p.v.setVisited() # Make sure v is never expanded again.
	if not at.thinFile:
		p.v.t.setWriteBit() # Mark the tnode to be written.
		
	if not at.thinFile and not s: return
	inCode = true
	<< Make sure all lines end in a newline >>
	i = 0
	while i < len(s):
		next_i = g.skip_line(s,i)
		assert(next_i > i)
		kind = at.directiveKind(s,i)
		<< handle line at s[i] >>
		i = next_i
	if not inCode:
		at.putEndDocLine()
	if at.sentinels and not trailingNewlineFlag:
		at.putSentinel("@nonl")
#@nonl
#@+node:EKR.20040429084140:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
	trailingNewlineFlag = s and s[-1] == '\n'
	if (at.sentinels or at.scripting) and not trailingNewlineFlag:
		s = s + '\n'
else:
	trailingNewlineFlag = true # don't need to generate an @nonl
#@nonl
#@-node:EKR.20040429084140:<< Make sure all lines end in a newline >>
#@+node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
if kind == noDirective:
	if inCode:
		hasRef,n1,n2 = at.findSectionName(s,i)
		if hasRef and not at.raw:
			at.putRefLine(s,i,n1,n2,p)
		else:
			at.putCodeLine(s,i)
	else:
		at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
	assert(not at.pending)
	at.putStartDocLine(s,i,kind)
	inCode = false
elif kind in (cDirective,codeDirective):
	# Only @c and @code end a doc part.
	if not inCode:
		at.putEndDocLine() 
	at.putDirective(s,i)
	inCode = true
elif kind == allDirective:
	if inCode: at.putAtAllLine(s,i,p)
	else: at.putDocLine(s,i)
elif kind == othersDirective:
	if inCode: at.putAtOthersLine(s,i,p)
	else: at.putDocLine(s,i) # 12/7/03
elif kind == rawDirective:
	at.raw = true
	at.putSentinel("@@raw")
elif kind == endRawDirective:
	at.raw = false
	at.putSentinel("@@end_raw")
	i = g.skip_line(s,i)
elif kind == miscDirective:
	at.putDirective(s,i)
else:
	assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20031218072017.2129:<< handle line at s[i]  >> (4.x)
#@-node:ekr.20031218072017.2128:putBody (4.x)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@+node:ekr.20031218072017.1575:putTnodes
def putTnodes (self):
	
	"""Puts all tnodes as required for copy or save commands"""

	c = self.c

	self.put("<tnodes>") ; self.put_nl()
	<< write only those tnodes that were referenced >>
	self.put("</tnodes>") ; self.put_nl()
#@nonl
#@+node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
# Populate tnodes
tnodes = {}

if self.usingClipboard: # write the current tree.
	root = c.currentPosition()
else: # write everything
	root = c.rootPosition()

for p in c.allNodes_iter():
	index = p.v.t.fileIndex
	assert(index)
	tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
	# g.trace(index)
	t = tnodes.get(index)
	assert(t)
	# Write only those tnodes whose vnodes were written.
	if t.isWriteBit(): # 5/3/04
		self.putTnode(t)
#@nonl
#@-node:ekr.20031218072017.1576:<< write only those tnodes that were referenced >>
#@-node:ekr.20031218072017.1575:putTnodes
#@+node:ekr.20040128174042:atFile.warnAboutOrpanAndIgnoredNodes
def warnAboutOrphandAndIgnoredNodes (self):
	
	# Always warn, even when language=="cweb"
	at = self ; root = at.root

	for p in root.self_and_subtree_iter():
		if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
			at.writeError("Orphan node:  " + p.headString())
			if p.isCloned() and p.hasParent():
				g.es("parent node: " + p.parent().headString(),color="blue")
			if not at.thinFile and p.isAtIgnoreNode():
				at.writeError("@ignore node: " + p.headString())
				
	if at.thinFile:
		p = root.copy() ; after = p.nodeAfterTree()
		while p and p != after:
			if p.isAtAllNode():
				p.moveToNodeAfterTree()
			else:
				if p.isAtIgnoreNode():
					at.writeError("@ignore node: " + p.headString())
				p.moveToThreadNext()
#@nonl
#@-node:ekr.20040128174042:atFile.warnAboutOrpanAndIgnoredNodes
#@+node:ekr.20031218072017.2985:c.clearAllVisited
def clearAllVisited (self):

	c = self

	for p in c.allNodes_iter():
		p.v.clearVisited()
		p.v.t.clearVisited()
		p.v.t.clearWriteBit()
#@-node:ekr.20031218072017.2985:c.clearAllVisited
#@+node:ekr.20040312015908:Visited bits
#@+node:ekr.20040312015705:p.clearAllVisited
# Compatibility routine for scripts.

def clearAllVisited (self):
	
	for p in self.allNodes_iter():
		p.clearVisited()
#@nonl
#@-node:ekr.20040312015705:p.clearAllVisited
#@+node:ekr.20040306220634.17:p.clearVisitedInTree
# Compatibility routine for scripts.

def clearVisitedInTree (self):
	
	for p in self.self_and_subtree_iter():
		p.clearVisited()
#@-node:ekr.20040306220634.17:p.clearVisitedInTree
#@+node:ekr.20031218072017.3388:p.clearAllVisitedInTree (4.2)
def clearAllVisitedInTree (self):
	
	for p in self.self_and_subtree_iter():
		p.v.clearVisited()
		p.v.t.clearVisited()
		p.v.t.clearWriteBit()
#@nonl
#@-node:ekr.20031218072017.3388:p.clearAllVisitedInTree (4.2)
#@-node:ekr.20040312015908:Visited bits
#@-node:EKR.20040503090928.1:(Don't write top-level body text in @file-thin nodes)
#@+node:EKR.20040503064147.2:(Added -thin field to @+leo sentinel)
#@+node:EKR.20040503105740:To do: override read logic if -thin seen
#@-node:EKR.20040503105740:To do: override read logic if -thin seen
#@+node:ekr.20031218072017.2633:top_df.scanHeader
def scanHeader(self,file,fileName):
	
	"""Scan the @+leo sentinel.
	
	Sets self.encoding, and self.start/endSentinelComment.
	
	Returns (firstLines,new_df) where:
	firstLines contains all @first lines,
	new_df is true if we are reading a new-format derived file."""
	
	at = self
	new_df = false # Set default.
	firstLines = [] # The lines before @+leo.
	version_tag = "-ver="
	thin_tag = "-thin"
	tag = "@+leo" ; encoding_tag = "-encoding="
	valid = true
	<< skip any non @+leo lines >>
	<< make sure we have @+leo >>
	<< read optional version param >>
	<< read optional thin param >>
	<< read optional encoding param >>
	<< set the closing comment delim >>
	if not valid:
		at.error("Bad @+leo sentinel in " + fileName)
	# g.trace("start,end",at.startSentinelComment,at.endSentinelComment)
	return firstLines, new_df
#@nonl
#@+node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) > 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = at.readLine(file)
n = len(s)
valid = n > 0
# s contains the tag
i = j = g.skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
	i += 1
if j < i:
	at.startSentinelComment = s[j:i]
	# g.trace(at.startSentinelComment)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
#@+node:ekr.20031218072017.2635:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0:# 7/8/02: make leading whitespace significant.
	i = g.skip_ws(s,i)

if g.match(s,i,tag):
	i += len(tag)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2635:<< make sure we have @+leo >>
#@+node:ekr.20031218072017.2636:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
	# Skip to the next minus sign or end-of-line
	i += len(version_tag)
	j = i
	while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
		i += 1

	if j < i:
		pass # version = s[j:i]
	else:
		valid = false
#@-node:ekr.20031218072017.2636:<< read optional version param >>
#@+node:EKR.20040503105354:<< read optional thin param >>
if g.match(s,i,thin_tag):
	i += len(tag)
#@nonl
#@-node:EKR.20040503105354:<< read optional thin param >>
#@+node:ekr.20031218072017.2637:<< read optional encoding param >>
# Set the default encoding
at.encoding = g.app.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
	# Read optional encoding param, e.g., -encoding=utf-8,
	i += len(encoding_tag)
	# Skip to the next end of the field.
	j = s.find(",.",i)
	if j > -1:
		# The encoding field was written by 4.2 or after:
		encoding = s[i:j]
	else:
		# The encoding field was written before 4.2.
		j = s.find('.',i)
		if j > -1:
			encoding = s[i:j]
		else:
			encoding = None
	# g.trace("encoding:",encoding)
	if encoding:
		if g.isValidEncoding(encoding):
			at.encoding = encoding
		else:
			print "bad encoding in derived file:",encoding
			g.es("bad encoding in derived file:",encoding)
	else:
		valid = false
#@-node:ekr.20031218072017.2637:<< read optional encoding param >>
#@+node:ekr.20031218072017.2638:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
	i += 1
at.endSentinelComment = s[j:i]
#@nonl
#@-node:ekr.20031218072017.2638:<< set the closing comment delim >>
#@-node:ekr.20031218072017.2633:top_df.scanHeader
#@+node:ekr.20031218072017.2789:putOpenLeoSentinel 4.x
def putOpenLeoSentinel(self,s):
	
	"""Write @+leo sentinel."""

	at = self
	
	if not at.sentinels:
		return # Handle @nosentinelsfile.
		
	if at.thinFile:
		s = s + "-thin"

	encoding = at.encoding.lower()
	if encoding != "utf-8":
		# New in 4.2: encoding fields end in ",."
		s = s + "-encoding=%s,." % (encoding)
	
	at.putSentinel(s)
#@nonl
#@-node:ekr.20031218072017.2789:putOpenLeoSentinel 4.x
#@-node:EKR.20040503064147.2:(Added -thin field to @+leo sentinel)
#@+node:EKR.20040517084551:(problems with tnodeList)
#@+node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=false,inAtOthers=false):
	
	"""Write @+node sentinel for p."""
	
	at = self

	if not inAtAll and p.isAtFileNode() and p != at.root:
		at.writeError("@file not valid in: " + p.headString())
		return
		
	# g.trace(at.thinFile,p)
		
	s = at.nodeSentinelText(p)
	at.putSentinel("@+node:" + s)
	
	if not at.thinFile:
		# Append the n'th tnode to the root's tnode list.
		at.root.v.t.tnodeList.append(p.v.t)
#@nonl
#@-node:ekr.20031218072017.2001:putOpenNodeSentinel (sets tnodeList) 4.x
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

	c = self.c ; config = g.app.config

	self.assignFileIndices()
	if not outlineOnlyFlag:
		<< write all @file nodes >>
	<< return if the .leo file is read-only >>
	try:
		<< create backup file >>
		self.mFileName = fileName
		<< create the output file >>
		<< update leoConfig.txt >>
		<< put the .leo file >>
	except:
		<< report the exception >>
		<< erase filename and rename backupName to fileName >>
		return false
	if self.outputFile:
		<< close the output file >>
		<< delete backup file >>
		return true
	else: # This probably will never happen because errors should raise exceptions.
		<< erase filename and rename backupName to fileName >>
		return false
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
	# Write all @file nodes and set orphan bits.
	c.atFileCommands.writeAll()
except:
	g.es_error("exception writing derived files")
	g.es_exception()
	return false
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
	try:
		if not os.access(fileName,os.W_OK):
			self.writeError("can not create: read only: " + self.targetFileName)
			return false
	except:
		pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
	try:
		backupName = g.os_path_join(g.app.loadDir,fileName)
		backupName = fileName + ".bak"
		if g.os_path_exists(backupName):
			os.unlink(backupName)
		# os.rename(fileName,backupName)
		g.utils_rename(fileName,backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception creating backup file: " + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception creating backup file: " + backupName)
		g.es_exception()
		backupName = None
		return false
else:
	backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080359.2:<< create the output file >>
self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
	g.es("can not open " + fileName)
	<< delete backup file >>
	return false
#@nonl
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
	try:
		os.unlink(backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting backup file:" + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception deleting backup file:" + backupName)
		g.es_exception()
		return false
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20040324080359.2:<< create the output file >>
#@+node:ekr.20040324080819:<< update leoConfig.txt >>
c.setIvarsFromFind()
config.setConfigFindIvars(c)
c.setIvarsFromPrefs()
config.setCommandsIvars(c)
config.update()
#@nonl
#@-node:ekr.20040324080819:<< update leoConfig.txt >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20040324080819.2:<< report the exception >>
g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
	try:
		self.outputFile.close()
		self.outputFile = None
	except:
		g.es("exception closing: " + fileName)
		g.es_exception()
#@nonl
#@-node:ekr.20040324080819.2:<< report the exception >>
#@+node:ekr.20040324080819.3:<< close the output file >>
try:
	self.outputFile.close()
	self.outputFile = None
except:
	g.es("exception closing: " + fileName)
	g.es_exception()
#@nonl
#@-node:ekr.20040324080819.3:<< close the output file >>
#@+node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
	try:
		os.unlink(fileName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting: " + fileName)
			g.es_exception()
	except:
		g.es("exception deleting: " + fileName)
		g.es_exception()
		
if backupName:
	g.es("restoring " + fileName + " from " + backupName)
	try:
		g.utils_rename(backupName, fileName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception renaming " + backupName + " to " + fileName)
			g.es_exception()
	except:
		g.es("exception renaming " + backupName + " to " + fileName)
		g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3049:<< erase filename and rename backupName to fileName >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):
	try:
		os.unlink(backupName)
	except OSError:
		if self.read_only:
			g.es("read only",color="red")
		else:
			g.es("exception deleting backup file:" + backupName)
			g.es_exception()
		return false
	except:
		g.es("exception deleting backup file:" + backupName)
		g.es_exception()
		return false
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20031218072017.2015:top_df.writeAll
def writeAll(self,writeAtFileNodesFlag=false,writeDirtyAtFileNodesFlag=false):
	
	"""Write @file nodes in all or part of the outline"""

	at = self ; c = at.c
	write_new = not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	df.initIvars()
	writtenFiles = [] # Files that might be written again.
	mustAutoSave = false

	if writeAtFileNodesFlag:
		# Write all nodes in the selected tree.
		p = c.currentPosition()
		after = p.nodeAfterTree()
	else:
		# Write dirty nodes in the entire outline.
		p =  c.rootPosition()
		after = c.nullPosition()

	<< Clear all orphan bits >>
	while p and p != after:
		if p.isAnyAtFileNode() or p.isAtIgnoreNode():
			<< handle v's tree >>
			p.moveToNodeAfterTree()
		else:
			p.moveToThreadNext()

	<< say the command is finished >>
	return mustAutoSave
#@nonl
#@+node:ekr.20031218072017.2016:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
	
for v2 in p.self_and_subtree_iter():
	v2.clearOrphan()
#@nonl
#@-node:ekr.20031218072017.2016:<< Clear all orphan bits >>
#@+node:ekr.20031218072017.2017:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

	df.fileChangedFlag = false # 1/9/04
	autoSave = false
	
	# Tricky: @ignore not recognised in @silentfile nodes.
	if p.isAtAsisFileNode():
		at.asisWrite(p)
		writtenFiles.append(p.v.t) ; autoSave = true
	elif p.isAtIgnoreNode():
		pass
	elif p.isAtNorefFileNode():
		at.norefWrite(p)
		writtenFiles.append(p.v.t) ; autoSave = true
	elif p.isAtNoSentFileNode():
		at.write(p,nosentinels=true)
		writtenFiles.append(p.v.t) # No need for autosave
	elif p.isAtThinFileNode():
		at.write(p,thinFile=true)
		writtenFiles.append(p.v.t) # No need for autosave.
	elif p.isAtFileNode():
		at.write(p)
		writtenFiles.append(p.v.t) ; autoSave = true

	if df.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
		mustAutoSave = true
#@nonl
#@-node:ekr.20031218072017.2017:<< handle v's tree >>
#@+node:ekr.20031218072017.2018:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
	if len(writtenFiles) > 0:
		g.es("finished")
	elif writeAtFileNodesFlag:
		g.es("no @file nodes in the selected tree")
	else:
		g.es("no dirty @file nodes")
#@nonl
#@-node:ekr.20031218072017.2018:<< say the command is finished >>
#@-node:ekr.20031218072017.2015:top_df.writeAll
#@+node:ekr.20031218072017.2641:top_df.write, norefWrite, asisWrite
def norefWrite (self,p):
	at = self
	write_new = not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	try:    df.norefWrite(p)
	except: at.writeException(p)
	
rawWrite = norefWrite # Compatibility with old scripts.
	
def asisWrite (self,p):
	at = self
	try: at.old_df.asisWrite(p) # No new_df.asisWrite method.
	except: at.writeException(p)
	
selentWrite = asisWrite # Compatibility with old scripts.
	
def write (self,p,nosentinels=false,thinFile=false):
	at = self
	write_new = thinFile or not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	try:    df.write(p,nosentinels=nosentinels,thinFile=thinFile)
	except: at.writeException(p)

def writeException(self,p):
	self.error("Unexpected exception while writing " + p.headString())
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2641:top_df.write, norefWrite, asisWrite
#@+node:ekr.20031218072017.2122:new_df.norefWrite
def norefWrite(self,root):

	at = self
	
	g.trace(root)

	c = at.c ; at.root = root
	at.errors = 0
	at.root.t.tnodeList = [] # 9/26/03: after beta 1 release.
	at.sentinels = true # 10/1/03
	at.scripting = false # 1/30/04
	at.thinFile = false # 5/17/04
	c.endEditing() # Capture the current headline.
	try:
		at.targetFileName = root.atNorefFileNodeName()
		ok = at.openWriteFile(root)
		if not ok: return
		<< write root's tree >>
		at.closeWriteFile()
		at.replaceTargetFileIfDifferent()
		root.clearOrphan() ; root.clearDirty()
	except:
		at.handleWriteException(root)
		
rawWrite = norefWrite
#@+node:ekr.20031218072017.2123:<< write root's tree >>
<< put all @first lines in root >>
at.putOpenLeoSentinel("@+leo-ver=4")
<< put optional @comment sentinel lines >>

for p in root.self_and_subtree_iter():
	<< Write p's node >>

at.putSentinel("@-leo")
<< put all @last lines in root >>
#@nonl
#@+node:ekr.20031218072017.2124:<< put all @first lines in root >>
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
	i += len(tag)
	i = g.skip_ws(s,i)
	j = i
	i = g.skip_to_end_of_line(s,i)
	# Write @first line, whether empty or not
	line = s[j:i]
	at.putBuffered(line) ; at.onl()
	i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20031218072017.2124:<< put all @first lines in root >>
#@+node:ekr.20031218072017.2125:<< put optional @comment sentinel lines >>
s2 = g.app.config.output_initial_comment
if s2:
	lines = string.split(s2,"\\n")
	for line in lines:
		line = line.replace("@date",time.asctime())
		if len(line)> 0:
			at.putSentinel("@comment " + line)
#@-node:ekr.20031218072017.2125:<< put optional @comment sentinel lines >>
#@+node:ekr.20031218072017.2126:<< Write p's node >>
at.putOpenNodeSentinel(p,inAtOthers=true)

s = p.bodyString()
if s and len(s) > 0:
	s = g.toEncodedString(s,at.encoding,reportErrors=true) # 3/7/03
	at.outputStringWithLineEndings(s)
	
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
	at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=true)
#@nonl
#@-node:ekr.20031218072017.2126:<< Write p's node >>
#@+node:ekr.20031218072017.2127:<< put all @last lines in root >>
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
	line = lines[j]
	if g.match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = g.skip_ws(line,i)
	at.putBuffered(line[i:]) ; at.onl()
#@nonl
#@-node:ekr.20031218072017.2127:<< put all @last lines in root >>
#@-node:ekr.20031218072017.2123:<< write root's tree >>
#@-node:ekr.20031218072017.2122:new_df.norefWrite
#@-node:EKR.20040517084551:(problems with tnodeList)
#@-node:EKR.20040519080820:In 4.2 a2
#@+node:EKR.20040519073926.1:(Fixed @file-thin copy bug)
# putVnode must test for self.usingClipboard in two places.
#@nonl
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

	"""Write a <v> element corresponding to a vnode."""

	fc = self ; c = fc.c ; v = p.v
	isThin = p.isAtThinFileNode()

	fc.put("<v")
	<< Put tnode index >>
	<< Put attribute bits >>
	<< Put tnodeList and unKnownAttributes >>
	fc.put(">")
	<< Write the head text >>

	# New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
	if p.hasChildren():
		if isThin and not p.isOrphan() and not self.usingClipboard:
			# g.trace("skipping child vnodes for", p.headString())
			pass
		else:
			fc.put_nl()
			# This optimization eliminates all "recursive" copies.
			p.moveToFirstChild()
			while 1:
				fc.putVnode(p)
				if p.hasNext(): p.moveToNext()
				else:           break
			p.moveToParent()

	fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
	if g.app.use_gnx:
		gnx = g.app.nodeIndices.toString(v.t.fileIndex)
		fc.put(" t=") ; fc.put_in_dquotes(gnx)
	else:
		fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
		
	# g.trace(v.t)
	if not isThin or self.usingClipboard:
		v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
	g.trace(v.t.fileIndex,v)
	g.es("error writing file(bad v.t.fileIndex)!")
	g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
	# Almost 30% of the entire writing time came from here!!!
	if p.equal(self.topPosition):     attr += "T" # was a bottleneck
	if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
	if v.isAnyAtFileNode() and not v.isAtThinFileNode():
		if hasattr(v.t,"tnodeList"):
			g.trace(v.headString(),len(v.t.tnodeList))
		else:
			g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
	fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
	<< put unknown vnode attributes >>
#@nonl
#@+node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
attrDict = v.unknownAttributes
keys = attrDict.keys()
for key in keys:
	val = attrDict[key]
	attr = ' %s="%s"' % (key,self.xmlEscape(val))
	self.put(attr)
	if 0: # For debugging.
		s = "putting unknown attribute for " + v.headString()
		print s ;  g.es(s, color="red")
		print attr, g.es(attr)
#@nonl
#@-node:ekr.20031218072017.1867:<< put unknown vnode attributes >>
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
	fc.put("<vh>")
	fc.putEscapedString(headString)
	fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:EKR.20040519073926.1:(Fixed @file-thin copy bug)
#@+node:EKR.20040519083814:(Fixed bug reading leo.nsi)
# The comment delim is ';', and it is not being recognized
#@nonl
#@+node:ekr.20031218072017.2633:top_df.scanHeader
def scanHeader(self,file,fileName):
	
	"""Scan the @+leo sentinel.
	
	Sets self.encoding, and self.start/endSentinelComment.
	
	Returns (firstLines,new_df) where:
	firstLines contains all @first lines,
	new_df is true if we are reading a new-format derived file."""
	
	at = self
	new_df = false # Set default.
	firstLines = [] # The lines before @+leo.
	version_tag = "-ver="
	thin_tag = "-thin"
	tag = "@+leo" ; encoding_tag = "-encoding="
	valid = true
	<< skip any non @+leo lines >>
	<< make sure we have @+leo >>
	<< read optional version param >>
	<< read optional thin param >>
	<< read optional encoding param >>
	<< set the closing comment delim >>
	if not valid:
		at.error("Bad @+leo sentinel in " + fileName)
	# g.trace("start,end",at.startSentinelComment,at.endSentinelComment)
	return firstLines, new_df
#@nonl
#@+node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) > 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = at.readLine(file)
n = len(s)
valid = n > 0
# s contains the tag
i = j = g.skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
	i += 1
if j < i:
	at.startSentinelComment = s[j:i]
	# g.trace(at.startSentinelComment)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
#@+node:ekr.20031218072017.2635:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0:# 7/8/02: make leading whitespace significant.
	i = g.skip_ws(s,i)

if g.match(s,i,tag):
	i += len(tag)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2635:<< make sure we have @+leo >>
#@+node:ekr.20031218072017.2636:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
	# Skip to the next minus sign or end-of-line
	i += len(version_tag)
	j = i
	while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
		i += 1

	if j < i:
		pass # version = s[j:i]
	else:
		valid = false
#@-node:ekr.20031218072017.2636:<< read optional version param >>
#@+node:EKR.20040503105354:<< read optional thin param >>
if g.match(s,i,thin_tag):
	i += len(tag)
#@nonl
#@-node:EKR.20040503105354:<< read optional thin param >>
#@+node:ekr.20031218072017.2637:<< read optional encoding param >>
# Set the default encoding
at.encoding = g.app.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
	# Read optional encoding param, e.g., -encoding=utf-8,
	i += len(encoding_tag)
	# Skip to the next end of the field.
	j = s.find(",.",i)
	if j > -1:
		# The encoding field was written by 4.2 or after:
		encoding = s[i:j]
	else:
		# The encoding field was written before 4.2.
		j = s.find('.',i)
		if j > -1:
			encoding = s[i:j]
		else:
			encoding = None
	# g.trace("encoding:",encoding)
	if encoding:
		if g.isValidEncoding(encoding):
			at.encoding = encoding
		else:
			print "bad encoding in derived file:",encoding
			g.es("bad encoding in derived file:",encoding)
	else:
		valid = false
#@-node:ekr.20031218072017.2637:<< read optional encoding param >>
#@+node:ekr.20031218072017.2638:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
	i += 1
at.endSentinelComment = s[j:i]
#@nonl
#@-node:ekr.20031218072017.2638:<< set the closing comment delim >>
#@-node:ekr.20031218072017.2633:top_df.scanHeader
#@+node:ekr.20031218072017.2387:old_df.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=false,importing=false,reading=false):
	
	"""Scan position p and p's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.c
	<< Set ivars >>
	<< Set path from @file node >>
	old = {}
	for p in p.self_and_parents_iter():
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< Test for @path >>
		<< Test for @encoding >>
		<< Test for @comment and @language >>
		<< Test for @header and @noheader >>
		<< Test for @lineending >>
		<< Test for @pagewidth >>
		<< Test for @tabwidth >>
		old.update(dict)
	<< Set current directory >>
	if not importing and not reading:
		# 5/19/04: don't override comment delims when reading!
		<< Set comment strings from delims >>
#@nonl
#@+node:ekr.20031218072017.2388:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = g.app.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.2388:<< Set ivars >>
#@+node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

dir = g.choose(name,g.os_path_dirname(name),None)

if dir and len(dir) > 0 and g.os_path_isabs(dir):
	if g.os_path_exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = g.makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20031218072017.2390:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.2390:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.2391:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = g.scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e
#@nonl
#@-node:ekr.20031218072017.2391:<< Test for @encoding >>
#@+node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.2393:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = g.scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
#@-node:ekr.20031218072017.2393:<< Test for @lineending >>
#@+node:ekr.20031218072017.2394:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute relative path from s[k:] >>
	if path and len(path) > 0:
		base = g.getBaseDirectory() # returns "" on error.
		path = g.os_path_join(base,path)
		if g.os_path_isabs(path):
			<< handle absolute path >>
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.2396:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = g.makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
#@-node:ekr.20031218072017.2396:<< handle absolute path >>
#@-node:ekr.20031218072017.2394:<< Test for @path >>
#@+node:ekr.20031218072017.2397:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = g.scanAtPagewidthDirective(s,dict,issue_error_flag=true)
	if w and w > 0:
		self.page_width = w
#@nonl
#@-node:ekr.20031218072017.2397:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.2398:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = g.scanAtTabwidthDirective(s,dict,issue_error_flag=true)
	if w and w != 0:
		self.tab_width = w

#@-node:ekr.20031218072017.2398:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.2399:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = g.getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) > 0:
			dir = g.os_path_join(base,dir)
			if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
				if g.os_path_exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = g.makeAllNonExistentDirectories(dir)

if not self.default_directory and not scripting:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""
#@nonl
#@-node:ekr.20031218072017.2399:<< Set current directory >>
#@+node:ekr.20031218072017.2400:<< Set comment strings from delims >>
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	g.es("Unknown language: using Python comment delimiters")
	g.es("c.target_language:",c.target_language)
	g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""
	
# g.trace(self.startSentinelComment)
#@nonl
#@-node:ekr.20031218072017.2400:<< Set comment strings from delims >>
#@-node:ekr.20031218072017.2387:old_df.scanAllDirectives
#@-node:EKR.20040519083814:(Fixed bug reading leo.nsi)
#@-node:EKR.20040517090500:May 2004
#@-node:ekr.20040107064101.1:4.2 Projects
#@+node:EKR.20040512081330:In progress
#@+node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
import difflib,shutil

class mulderUpdateAlgorithm:
	
	"""A class to update derived files using
	diffs in files without sentinels."""
	
	@others
	
def doMulderUpdateAlgorithm(sourcefilename,targetfilename):

	mu = mulderUpdateAlgorithm()

	mu.pull_source(sourcefilename,targetfilename)
	mu.copy_time(targetfilename,sourcefilename)
#@nonl
#@+node:EKR.20040505103527:TO DO
@

- is_sentinel is not strictly correct.  There must be an atFile method that does the job absolutely correctly.

- Similarly, marker_from_extension can probably be replaced by a call to some method in leoGlobals.py.
#@-node:EKR.20040505103527:TO DO
#@+node:EKR.20040504150046.3:__init__
def __init__ (self,testing=false,verbose=false):
	
	self.testing = testing
	self.verbose = false
	self.do_backups = false
#@nonl
#@-node:EKR.20040504150046.3:__init__
#@+node:EKR.20040504150046.9:copy_sentinels
@ This script retains _all_ sentinels.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
	"""
	
	Copy sentinel lines from fat_lines to write_lines.

	Copy all sentinels _after_ the current reader postion up to,
	but not including, mapping[endline].

	"""

	j_last = mapping[startline]
	i = startline + 1
	while i <= endline:
		j = mapping[i]
		if j_last + 1 != j:
			fat_pos = j_last + 1
			# Copy the deleted sentinels that comprise the gap.
			while fat_pos < j:
				line = fat_lines[fat_pos]
				write_lines.append(line)
				if self.testing and self.verbose: print "Copy sentinel:",fat_pos,line,
				fat_pos += 1
		j_last = j ; i += 1

	fat_pos = mapping[endline]
	return fat_pos
#@nonl
#@-node:EKR.20040504150046.9:copy_sentinels
#@+node:EKR.20040504155109:copy_time
def copy_time(self,sourcefilename,targetfilename):
	
	"""
	Set the target file's modification time to
	that of the source file.
	"""

	st = os.stat(sourcefilename)
	if hasattr(os, 'utime'):
		os.utime(targetfilename, (st.st_atime, st.st_mtime))
	elif hasattr(os, 'mtime'):
		os.mtime(targetfilename, st.st_mtime)
	else:
		g.trace("Can not set modification time")
#@nonl
#@-node:EKR.20040504155109:copy_time
#@+node:EKR.20040504150046.6:create_mapping
def create_mapping (self,lines,marker):
	"""

	'lines' is a list of lines of a file with sentinels.
 
	Returns:

	result: lines with all sentinels removed.

	mapping: a list such that result[mapping[i]] == lines[i]
	for all i in range(len(result))

	"""

	mapping = [] ; result = []
	for i in xrange(len(lines)):
		line = lines[i]
		if not self.is_sentinel(line,marker):
			result.append(line)
			mapping.append(i)

	# Create a last mapping entry for copy_sentinels.
	mapping.append(i)

	return result, mapping
#@nonl
#@-node:EKR.20040504150046.6:create_mapping
#@+node:EKR.20040504154039:is_sentinel NOT CORRECT
def is_sentinel (self,line,marker):
	
	"""
	Check if line starts with a sentinel comment.
	"""
	
	return line.lstrip().startswith(marker)
#@-node:EKR.20040504154039:is_sentinel NOT CORRECT
#@+node:EKR.20040504150046.4:marker_from_extension
def marker_from_extension(self,filename):
	"""
	Tries to guess the sentinel leadin
	comment from the filename extension.
	
	This code should probably be shared
	with the main Leo code.
	"""
	root, ext = os.path.splitext(filename)
	if ext == '.tmp':
		root, ext = os.path.splitext(root)
	if ext in ('.h', '.c'):
		marker = "//@"
	elif ext in (".py", ".cfg", ".bat", ".ksh"):
		marker = "#@"
	else:
		g.trace("unknown extension %s" % ext)
		marker = None

	return marker
#@nonl
#@-node:EKR.20040504150046.4:marker_from_extension
#@+node:EKR.20040505080156:Get or remove sentinel lines
# These routines originally were part of push_filter & push_filter_lines.
#@nonl
#@+node:EKR.20040505081121:separateSentinelsFromFile/Lines
def separateSentinelsFromFile (self,filename):
	
	"""Separate the lines of the file into a tuple of two lists,
	containing the sentinel and non-sentinel lines of the file."""
	
	lines = file(filename).readlines()
	marker = self.marker_from_extension(filename)
	
	return self.separateSentinelsFromLines(lines,marker)
	
def separateSentinelsFromLines (self,lines,marker):
	
	"""Separate lines (a list of lines) into a tuple of two lists,
	containing the sentinel and non-sentinel lines of the original list."""
	
	strippedLines = self.removeSentinelsFromLines(lines,marker)
	sentinelLines = self.getSentinelsFromLines(lines,marker)
	
	return strippedLines,sentinelLines
#@nonl
#@-node:EKR.20040505081121:separateSentinelsFromFile/Lines
#@+node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
def removeSentinelsFromFile (self,filename):
	
	"""Return a copy of file with all sentinels removed."""
	
	lines = file(filename).readlines()
	marker = self.marker_from_extension(filename)
	
	return removeSentinelsFromLines(lines,marker)
	
def removeSentinelsFromLines (self,lines,marker):

	"""Return a copy of lines with all sentinels removed."""
	
	return [line for line in lines if not self.is_sentinel(line,marker)]
#@nonl
#@-node:EKR.20040505080156.2:removeSentinelsFromFile/Lines
#@+node:EKR.20040505080156.3:getSentinelsFromFile/Lines
def getSentinelsFromFile (self,filename,marker):
	
	"""Returns all sentinels lines in a file."""
	
	lines = file(filename).readlines()
	marker = self.marker_from_extension(filename)

	return getSentinelsFromLines(lines,marker)
	
def getSentinelsFromLines (self,lines,marker):
	
	"""Returns all sentinels lines in lines."""
	
	return [line for line in lines if self.is_sentinel(line,marker)]
#@nonl
#@-node:EKR.20040505080156.3:getSentinelsFromFile/Lines
#@-node:EKR.20040505080156:Get or remove sentinel lines
#@+node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
def propagateDiffsToSentinelsFile(self,sourcefilename,targetfilename):
	
	<< init propagateDiffsToSentinelsFile vars >>
	
	write_lines = self.propagateDiffsToSentinelsLines(
		i_lines,j_lines,fat_lines,mapping)
		
	# Update _source_ file if it is not the same as write_lines.
	written = self.write_if_changed(write_lines,targetfilename,sourcefilename)
	if written:
		<< paranoia check>>
#@nonl
#@+node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
# Get the sentinel comment marker.
marker = self.marker_from_extension(sourcefilename)
if not marker:
	return

try:
	# Create the readers.
	sfile = file(sourcefilename)
	tfile = file(targetfilename)
	
	fat_lines = sfile.readlines() # Contains sentinels.
	j_lines   = tfile.readlines() # No sentinels.
	
	i_lines,mapping = self.create_mapping(fat_lines,marker)
	
	sfile.close()
	tfile.close()
except:
	g.es_exception("can not open files")
	return
#@nonl
#@-node:EKR.20040504150046.11:<< init propagateDiffsToSentinelsFile vars >>
#@+node:EKR.20040504150046.12:<<paranoia check>>
# Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = self.separateSentinelsFromFile(sourcefilename)

if strippedLines != j_lines:
	self.report_mismatch(strippedLines, j_lines,
		"Propagating diffs did not work as expected",
		"Content of sourcefile:",
		"Content of modified file:")

# Check that no sentinels got lost.
fat_sentinel_lines = self.getSentinelsFromLines(fat_lines,marker)

if sentinel_lines != fat_sentinel_lines:
	self.report_mismatch(sentinel_lines,fat_sentinel_lines,
		"Propagating diffs modified sentinel lines:",
		"Current sentinel lines:",
		"Old sentinel lines:")
#@nonl
#@-node:EKR.20040504150046.12:<<paranoia check>>
#@-node:EKR.20040504150046.10:propagateDiffsToSentinelsFile
#@+node:EKR.20040504145804.1:propagateDiffsToSentinelsLines
def propagateDiffsToSentinelsLines (self,i_lines,j_lines,fat_lines,mapping):
	
	"""Compare the 'i_lines' with 'j_lines' and propagate the diffs back into
	'write_lines' making sure that all sentinels of 'fat_lines' are copied.

	i/j_lines have no sentinels.  fat_lines does."""

	<< init propagateDiffsToSentinelsLines vars >>
	<< copy the sentinels at the beginning of the file >>
	for tag, i1, i2, j1, j2 in matcher.get_opcodes():
		if testing:
			if verbose: print
			print "Opcode %7s %3d %3d %3d %3d" % (tag,i1,i2,j1,j2)
			if verbose: print
		<< update and check the loop invariant >>
		if tag == 'equal':
			<< handle 'equal' tag >>
		elif tag == 'replace':
			<< handle 'replace' tag >>
		elif tag == 'delete':
			<< handle 'delete' tag >>
		elif tag == 'insert':
			<< handle 'insert' tag >>
		else: assert 0,"bad tag"
	<< copy the sentinels at the end of the file >>
	return write_lines
#@nonl
#@+node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
# Indices into i_lines, j_lines & fat_lines.
i_pos = j_pos = fat_pos = 0

# These vars check that all ranges returned by get_opcodes() are contiguous.
i2_old = j2_old = -1

# Create the output lines.
write_lines = []

matcher = difflib.SequenceMatcher(None,i_lines,j_lines)

testing = self.testing
verbose = self.verbose
#@nonl
#@-node:EKR.20040504145804.2:<< init propagateDiffsToSentinelsLines vars >>
#@+node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
while fat_pos < mapping[0]:
	line = fat_lines[fat_pos]
	write_lines.append(line)
	if testing and verbose: print "copy initial line",fat_pos,line,
	fat_pos += 1
#@nonl
#@-node:EKR.20040504145804.3:<< copy the sentinels at the beginning of the file >>
#@+node:EKR.20040504145804.4:<< update and check the loop invariant>>
# We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.

assert(i2_old in (-1,i1))
assert(j2_old in (-1,j1))

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1
assert j_pos == j1
assert fat_pos == mapping[i1]

if 0: # not yet.
	if testing: # A bit costly.
		t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, marker)
		# Check that we have all the modifications so far.
		assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
		# Check that we kept all sentinels so far.
		assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], marker)[1]
#@nonl
#@-node:EKR.20040504145804.4:<< update and check the loop invariant>>
#@+node:EKR.20040504145804.5:<< handle 'equal' tag >>
# Copy the lines, including sentinels.
while fat_pos <= mapping[i2-1]:
	line = fat_lines[fat_pos]
	if 0: # too verbose.
		if testing: print "Equal: copying ", line,
	write_lines.append(line)
	fat_pos += 1

if testing and verbose:
	print "Equal: synch i", i_pos,i2
	print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)
#@nonl
#@-node:EKR.20040504145804.5:<< handle 'equal' tag >>
#@+node:EKR.20040504145804.6:<< handle 'replace' tag >>
@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinel.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line => orignal line.
@c

while j_pos < j2:
	line = j_lines[j_pos]
	if testing:
		print "Replace i:",i_pos,repr(i_lines[i_pos])
		print "Replace j:",j_pos,repr(line)
		i_pos += 1

	write_lines.append(line)
	j_pos += 1

i_pos = i2

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@nonl
#@-node:EKR.20040504145804.6:<< handle 'replace' tag >>
#@+node:EKR.20040504145804.7:<< handle 'delete' tag >>
if testing and verbose:
	print "delete: i",i_pos,i1
	print "delete: j",j_pos,j1

j_pos = j2
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)
#@nonl
#@-node:EKR.20040504145804.7:<< handle 'delete' tag >>
#@+node:EKR.20040504145804.8:<< handle 'insert' tag >>
while j_pos < j2:
	line = j_lines[j_pos]
	if testing: print "Insert:", line,
	write_lines.append(line)
	j_pos += 1

# The input streams are already in synch.
#@nonl
#@-node:EKR.20040504145804.8:<< handle 'insert' tag >>
#@+node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
while fat_pos < len(fat_lines):
	line = fat_lines[fat_pos]
	write_lines.append(line)
	if testing and verbose: print "Append last line",line
	fat_pos += 1
#@nonl
#@-node:EKR.20040504145804.9:<< copy the sentinels at the end of the file >>
#@-node:EKR.20040504145804.1:propagateDiffsToSentinelsLines
#@+node:EKR.20040504150046.5:report_mismatch
def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

	"""
	Generate a report when something goes wrong.
	"""

	print '='*20
	print message
	
	if 0:
		print lines1_message
		print '-'*20
		for line in lines1:
		  print line,
		 
		print '='*20
	
		print lines2_message
		print '-'*20
		for line in lines2:
			print line,
#@nonl
#@-node:EKR.20040504150046.5:report_mismatch
#@+node:EKR.20040504160820:write_if_changed
def write_if_changed(self,lines,sourcefilename,targetfilename):
	"""
	
	Replaces target file if it is not the same as 'lines',
	and makes the modification date of target file the same as the source file.
	
	Optionally backs up the overwritten file.

	"""
	
	copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()
		
	if self.testing:
		if copy:
			print "Writing",targetfilename,"without sentinals"
		else:
			print "Files are identical"

	if copy:
		if self.do_backups:
			<< make backup file >>
		outfile = open(targetfilename, "w")
		for line in lines:
			outfile.write(line)
		outfile.close()
		self.copy_time(sourcefilename,targetfilename)
	return copy
#@+node:EKR.20040504160820.1:<< make backup file >>
if os.path.exists(targetfilename):
	count = 0
	backupname = "%s.~%s~" % (targetfilename,count)
	while os.path.exists(backupname):
		count += 1
		backupname = "%s.~%s~" % (targetfilename,count)
	os.rename(targetfilename, backupname)
	if testing:
		print "backup file in ", backupname
#@nonl
#@-node:EKR.20040504160820.1:<< make backup file >>
#@-node:EKR.20040504160820:write_if_changed
#@-node:EKR.20040504150046:class mulderUpdateAlgorithm (leoGlobals)
#@+node:EKR.20040506075328.3:(Perfect Import)
#@+node:EKR.20040506091116:Notes
@nocolor

2.  Write a _virtual output file_ to a string.  This is easily done:  we pass a file-like-object to Leo's atFile.write routines.  This virtual file will have @file-thin sentinels.  In other words, the virtual file will specify _all_ aspects of the structure of the newly imported outline.

3.  Convert the string got by writing the virtual output file to a list of lines.  This will become the fat_lines argument.

The strategy is simple:  we want to make corrections to fat_lines using Bernhard's algorithm.  If in fact the fat_lines has changed, we will delete root's outline and recreate the outline using the atFile.read code applied to the virtual output file, i.e., fat_lines.

4.  Set i_lines to the contents of the virtual output file (fat_lines) stripped of sentinels.  Set j_lines to the lines of the original imported file.  As stated above, set fat_lines to the lines of the virtual output file.  Call propagateDiffsToSentinelsLines to update fat_lines to make it equivalent to the original imported file.  Replace root's outline if a real change has happened.
#@-node:EKR.20040506091116:Notes
#@+node:ekr.20040331083824.1:fileLikeObject
class fileLikeObject:
	
	"""Define a file-like object for redirecting i/o."""
	
	# Used by Execute Script command and rClick plugin.
	
	def __init__(self): self.s = ""
	def clear (self):   self.s = ""
	def close (self):   pass
	def flush (self):   pass
		
	def get (self):
		return self.s
		
	def write (self,s):
		if s:
			self.s = self.s + s
#@nonl
#@-node:ekr.20040331083824.1:fileLikeObject
#@+node:ekr.20031218072017.3212:importFilesCommand
def importFilesCommand (self,files,treeType):

	c = self.c
	if c == None: return
	v = current = c.currentVnode()
	if current == None: return
	if len(files) < 1: return
	self.treeType = treeType
	c.beginUpdate()
	if 1: # range of update...
		if len(files) == 2:
			<< Create a parent for two files having a common prefix >>
		for i in xrange(len(files)):
			fileName = files[i]
			v = self.createOutline(fileName,current)
			self.perfectImport(fileName,v)
			if v: # 8/11/02: createOutline may fail.
				g.es("imported " + fileName)
				v.contract()
				v.setDirty()
				c.setChanged(true)
		c.validateOutline()
		current.expand()
	c.endUpdate()
	c.selectVnode(current)
#@nonl
#@+node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) > 0 and prefix0 == prefix1:
	current = current.insertAsLastChild()
	junk, nameExt = g.os_path_split(prefix1)
	name,ext = g.os_path_splitext(prefix1)
	current.initHeadString(name)
#@nonl
#@-node:ekr.20031218072017.3213:<< Create a parent for two files having a common prefix >>
#@-node:ekr.20031218072017.3212:importFilesCommand
#@+node:EKR.20040506075328.2:perfectImport
def perfectImport (self,fileName,p):
	
	return ### not ready yet.

	g.trace(fileName,p)
	
	<< write p to a virtual thin derived file s >>
	if not s: return
	
	mu = g.mulderUpdateAlgorithm(testing=true)
	marker = mu.marker_from_extension(fileName)

	fat_lines = s.splitlines(true) # Keep line endings.
	
	i_lines,mapping = mu.create_mapping(fat_lines,marker)
	j_lines = file(fileName).readlines()
	
	if i_lines != j_lines:
		g.trace("correcting import")
		write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
		<< replace root's tree using write_lines >>
	else:
		g.trace("imported lines are perfect")
#@+node:EKR.20040506105049:<< write p to a virtual thin derived file s >>
try:
	df = self.c.atFileCommands.new_df
	df.targetFileName = "<virtual-file>"
	df.outputFile = fo = g.fileLikeObject()
	df.writeOpenFile(p)
	s = fo.get()
except:
	g.es("Exception in Perfect Import (write)")
	g.es_exception()
	s = None
#@-node:EKR.20040506105049:<< write p to a virtual thin derived file s >>
#@+node:EKR.20040506115229:<< replace root's tree using write_lines >>
if 0: # Not ready yet.

	# Remove all of root's tree.
	while p.hasChildren():
		child = p.firstChild()
		child.doDelete(p)
		
	p.setBodyStringOrPane("")

	try:
		df = self.c.atFileCommands.new_df
		df.targetFileName = "<virtual-file>"
		df.inputFile = fo = g.fileLikeObject()
		fo.set(string.join(write_lines))
		df.readOpenFile(p)
	except:
		g.es("Exception in Perfect Import (read)")
		g.es_exception()
		s = None
#@nonl
#@-node:EKR.20040506115229:<< replace root's tree using write_lines >>
#@-node:EKR.20040506075328.2:perfectImport
#@-node:EKR.20040506075328.3:(Perfect Import)
#@+node:EKR.20040507095329.1:(More flexible atFile classes)
#@+node:EKR.20040507100502:about calling scanDirectives
- called by top_df.read just before calling df.readOpenFile.

- called by atFile.openWriteFile
#@nonl
#@-node:EKR.20040507100502:about calling scanDirectives
#@+node:ekr.20031218072017.2622:<< class baseAtFile methods >>
@others
#@nonl
#@+node:ekr.20031218072017.2623:atFile.__init__ & initIvars
def __init__(self,c):
	
	self.c = c
	self.fileCommands = self.c.fileCommands
	
	# Create subcommanders to handler old and new format derived files.
	self.old_df = oldDerivedFile(c)
	self.new_df = newDerivedFile(c)
	
	self.initIvars()
	
def initIvars(self):
	
	# Set by scanDefaultDirectory.
	self.default_directory = None
	self.errors = 0

	# Set by scanHeader when reading. Set by scanAllDirectives...
	self.encoding = g.app.config.default_derived_file_encoding
	self.endSentinelComment = None
	self.startSentinelComment = None
#@nonl
#@-node:ekr.20031218072017.2623:atFile.__init__ & initIvars
#@+node:ekr.20031218072017.2624:top_df.error
def error(self,message):

	g.es(message,color="red")
	print message
	self.errors += 1
#@nonl
#@-node:ekr.20031218072017.2624:top_df.error
#@+node:ekr.20031218072017.2625:Reading
#@+node:ekr.20031218072017.2626: top_df.readAll
def readAll(self,root,partialFlag=false):
	
	"""Scan vnodes, looking for @file nodes to read."""

	at = self ; c = at.c
	c.endEditing() # Capture the current headline.
	anyRead = false
	at.initIvars()
	p = root.copy()
	if partialFlag: after = p.nodeAfterTree()
	else: after = c.nullPosition()
	while p and not p.equal(after): # Don't use iterator.
		if p.isAtIgnoreNode():
			p.moveToNodeAfterTree()
		elif p.isAtThinFileNode():
			anyRead = true
			at.read(p,thinFile=true)
			p.moveToNodeAfterTree()
		elif p.isAtFileNode() or p.isAtNorefFileNode():
			anyRead = true
			if partialFlag:
				# We are forcing the read.
				at.read(p)
			else:
				# if p is an orphan, we don't expect to see a derived file,
				# and we shall read a derived file if it exists.
				wasOrphan = p.isOrphan()
				ok = at.read(p)
				if wasOrphan and not ok:
					# Remind the user to fix the problem.
					p.setDirty()
					c.setChanged(true)
			p.moveToNodeAfterTree()
		else: p.moveToThreadNext()
	# Clear all orphan bits.
	for p in c.allNodes_iter():
		p.v.clearOrphan()
		
	if partialFlag and not anyRead:
		g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20031218072017.2626: top_df.readAll
#@+node:ekr.20031218072017.1812:top_df.read
# The caller has enclosed this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=false):
	
	"""Common read logic for any derived file."""
	
	at = self ; c = at.c
	at.errors = 0
	at.scanDefaultDirectory(root)
	if at.errors: return
	<< set fileName from root and importFileName >>
	<< open file or return false >>
	g.es("reading: " + root.headString())
	firstLines,read_new = at.scanHeader(file,fileName)
	df = g.choose(read_new,at.new_df,at.old_df)
	# g.trace(g.choose(df==at.new_df,"new","old"))
	# import traceback ; traceback.print_stack()
	<< copy ivars to df >>
	root.clearVisitedInTree()
	try:
		# 1/28/04: Don't set comment delims when importing.
		# 1/28/04: Call scanAllDirectives here, not in readOpenFile.
		importing = importFileName is not None
		df.scanAllDirectives(root,importing=importing,reading=true)
		df.readOpenFile(root,file,firstLines)
	except:
		at.error("Unexpected exception while reading derived file")
		g.es_exception()
	file.close()
	root.clearDirty() # May be set dirty below.
	after = root.nodeAfterTree()
	<< warn about non-empty unvisited nodes >>
	if df.errors == 0:
		if not df.importing:
			<< copy all tempBodyStrings to tnodes >>
	<< delete all tempBodyStrings >>
	return df.errors == 0
#@nonl
#@+node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
if importFileName:
	fileName = importFileName
elif root.isAnyAtFileNode():
	fileName = root.anyAtFileNodeName()
else:
	fileName = None

if not fileName:
	at.error("Missing file name.  Restoring @file tree from .leo file.")
	return false
#@nonl
#@-node:ekr.20031218072017.1813:<< set fileName from root and importFileName >>
#@+node:ekr.20031218072017.1814:<< open file or return false >>
fn = g.os_path_join(at.default_directory,fileName)
fn = g.os_path_normpath(fn)

try:
	# 11/4/03: open the file in binary mode to allow 0x1a in bodies & headlines.
	file = open(fn,'rb')
	if file:
		<< warn on read-only file >>
	else: return false
except:
	at.error("Can not open: " + '"@file ' + fn + '"')
	root.setDirty()
	return false
#@nonl
#@+node:ekr.20031218072017.1815:<< warn on read-only file >>
try:
	read_only = not os.access(fn,os.W_OK)
	if read_only:
		g.es("read only: " + fn,color="red")
except:
	pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20031218072017.1815:<< warn on read-only file >>
#@-node:ekr.20031218072017.1814:<< open file or return false >>
#@+node:ekr.20031218072017.1816:<< copy ivars to df >>
# Telling what kind of file we are reading.
df.importing = importFileName != None
df.raw = false
df.thinFile = thinFile

# Set by scanHeader.
df.encoding = at.encoding
df.endSentinelComment = at.endSentinelComment
df.startSentinelComment = at.startSentinelComment

# Set other common ivars.
df.errors = 0
df.file = file
df.importRootSeen = false
df.indent = 0
df.targetFileName = fileName
df.root = root
df.root_seen = false
#@nonl
#@-node:ekr.20031218072017.1816:<< copy ivars to df >>
#@+node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

	# g.trace(p)
	try: s = p.v.t.tempBodyString
	except: s = ""
	if s and not p.v.t.isVisited():
		at.error("Not in derived file:" + p.headString())
		p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20031218072017.1817:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
	try: s = p.v.t.tempBodyString
	except: s = ""
	if s != p.bodyString():
		if 0: # For debugging.
			print ; print "changed: " + p.headString()
			print ; print "new:",s
			print ; print "old:",p.bodyString()
		if thinFile:
			p.v.setTnodeText(s)
		else:
			g.es("changed: " + p.headString(),color="blue")
			p.setMarked()
			p.setBodyStringOrPane(s) # Sets v and v.c dirty.
#@nonl
#@-node:ekr.20031218072017.1818:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
	if hasattr(p.v.t,"tempBodyString"):
		delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20031218072017.1819:<< delete all tempBodyStrings >>
#@-node:ekr.20031218072017.1812:top_df.read
#@+node:ekr.20031218072017.2627:top_df.scanDefaultDirectory
def scanDefaultDirectory(self,p):
	
	"""Set default_directory ivar by looking for @path directives."""

	at = self ; c = at.c
	at.default_directory = None
	<< Set path from @file node >>
	if at.default_directory:
		return
		
	for p in p.self_and_parents_iter():
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		if dict.has_key("path"):
			<< handle @path >>
			return

	<< Set current directory >>
	if not at.default_directory:
		# This should never happen: c.openDirectory should be a good last resort.
		g.trace()
		at.error("No absolute directory specified anywhere.")
		at.default_directory = ""
#@nonl
#@+node:ekr.20031218072017.2628:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
	
dir = g.choose(name,g.os_path_dirname(name),None)

if dir and g.os_path_isabs(dir):
	if g.os_path_exists(dir):
		at.default_directory = dir
	else:
		at.default_directory = g.makeAllNonExistentDirectories(dir)
		if not at.default_directory:
			at.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2628:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20031218072017.2629:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = dict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
	base = g.getBaseDirectory() # returns "" on error.
	path = g.os_path_join(base,path)
	
	if g.os_path_isabs(path):
		<< handle absolute path >>
	else:
		at.error("ignoring bad @path: " + path)
else:
	at.error("ignoring empty @path")

#@+node:ekr.20031218072017.2630:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]

path = path.strip()
#@nonl
#@-node:ekr.20031218072017.2630:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.2631:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
	at.default_directory = path
else:
	at.default_directory = g.makeAllNonExistentDirectories(path)
	if not at.default_directory:
		at.error("invalid @path: " + path)
#@nonl
#@-node:ekr.20031218072017.2631:<< handle absolute path >>
#@-node:ekr.20031218072017.2629:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20031218072017.2632:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
	base = g.getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) > 0:
			dir = g.os_path_join(base,dir)
			if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
				if g.os_path_exists(dir):
					at.default_directory = dir ; break
				else:
					at.default_directory = g.makeAllNonExistentDirectories(dir)
#@-node:ekr.20031218072017.2632:<< Set current directory >>
#@-node:ekr.20031218072017.2627:top_df.scanDefaultDirectory
#@+node:ekr.20031218072017.2633:top_df.scanHeader
def scanHeader(self,file,fileName):
	
	"""Scan the @+leo sentinel.
	
	Sets self.encoding, and self.start/endSentinelComment.
	
	Returns (firstLines,new_df) where:
	firstLines contains all @first lines,
	new_df is true if we are reading a new-format derived file."""
	
	at = self
	new_df = false # Set default.
	firstLines = [] # The lines before @+leo.
	version_tag = "-ver="
	thin_tag = "-thin"
	tag = "@+leo" ; encoding_tag = "-encoding="
	valid = true
	<< skip any non @+leo lines >>
	<< make sure we have @+leo >>
	<< read optional version param >>
	<< read optional thin param >>
	<< read optional encoding param >>
	<< set the closing comment delim >>
	if not valid:
		at.error("Bad @+leo sentinel in " + fileName)
	# g.trace("start,end",at.startSentinelComment,at.endSentinelComment)
	return firstLines, new_df
#@nonl
#@+node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(file)
while len(s) > 0:
	j = s.find(tag)
	if j != -1: break
	firstLines.append(s) # Queue the line
	s = at.readLine(file)
n = len(s)
valid = n > 0
# s contains the tag
i = j = g.skip_ws(s,0)
# The opening comment delim is the initial non-whitespace.
# 7/8/02: The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
	i += 1
if j < i:
	at.startSentinelComment = s[j:i]
	# g.trace(at.startSentinelComment)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2634:<< skip any non @+leo lines >>
#@+node:ekr.20031218072017.2635:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0:# 7/8/02: make leading whitespace significant.
	i = g.skip_ws(s,i)

if g.match(s,i,tag):
	i += len(tag)
else: valid = false
#@nonl
#@-node:ekr.20031218072017.2635:<< make sure we have @+leo >>
#@+node:ekr.20031218072017.2636:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
	# Skip to the next minus sign or end-of-line
	i += len(version_tag)
	j = i
	while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
		i += 1

	if j < i:
		pass # version = s[j:i]
	else:
		valid = false
#@-node:ekr.20031218072017.2636:<< read optional version param >>
#@+node:EKR.20040503105354:<< read optional thin param >>
if g.match(s,i,thin_tag):
	i += len(tag)
#@nonl
#@-node:EKR.20040503105354:<< read optional thin param >>
#@+node:ekr.20031218072017.2637:<< read optional encoding param >>
# Set the default encoding
at.encoding = g.app.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
	# Read optional encoding param, e.g., -encoding=utf-8,
	i += len(encoding_tag)
	# Skip to the next end of the field.
	j = s.find(",.",i)
	if j > -1:
		# The encoding field was written by 4.2 or after:
		encoding = s[i:j]
	else:
		# The encoding field was written before 4.2.
		j = s.find('.',i)
		if j > -1:
			encoding = s[i:j]
		else:
			encoding = None
	# g.trace("encoding:",encoding)
	if encoding:
		if g.isValidEncoding(encoding):
			at.encoding = encoding
		else:
			print "bad encoding in derived file:",encoding
			g.es("bad encoding in derived file:",encoding)
	else:
		valid = false
#@-node:ekr.20031218072017.2637:<< read optional encoding param >>
#@+node:ekr.20031218072017.2638:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
	i += 1
at.endSentinelComment = s[j:i]
#@nonl
#@-node:ekr.20031218072017.2638:<< set the closing comment delim >>
#@-node:ekr.20031218072017.2633:top_df.scanHeader
#@+node:ekr.20031218072017.2639:top_df.readLine
def readLine (self,file):

	"""Reads one line from file using the present encoding"""
	
	s = g.readlineForceUnixNewline(file)
	u = g.toUnicode(s,self.encoding)
	return u
#@nonl
#@-node:ekr.20031218072017.2639:top_df.readLine
#@-node:ekr.20031218072017.2625:Reading
#@+node:ekr.20031218072017.2640:Writing
#@+node:ekr.20031218072017.2015:top_df.writeAll
def writeAll(self,writeAtFileNodesFlag=false,writeDirtyAtFileNodesFlag=false):
	
	"""Write @file nodes in all or part of the outline"""

	at = self ; c = at.c
	write_new = not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	df.initIvars()
	writtenFiles = [] # Files that might be written again.
	mustAutoSave = false

	if writeAtFileNodesFlag:
		# Write all nodes in the selected tree.
		p = c.currentPosition()
		after = p.nodeAfterTree()
	else:
		# Write dirty nodes in the entire outline.
		p =  c.rootPosition()
		after = c.nullPosition()

	<< Clear all orphan bits >>
	while p and p != after:
		if p.isAnyAtFileNode() or p.isAtIgnoreNode():
			<< handle v's tree >>
			p.moveToNodeAfterTree()
		else:
			p.moveToThreadNext()

	<< say the command is finished >>
	return mustAutoSave
#@nonl
#@+node:ekr.20031218072017.2016:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
	
for v2 in p.self_and_subtree_iter():
	v2.clearOrphan()
#@nonl
#@-node:ekr.20031218072017.2016:<< Clear all orphan bits >>
#@+node:ekr.20031218072017.2017:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

	df.fileChangedFlag = false # 1/9/04
	autoSave = false
	
	# Tricky: @ignore not recognised in @silentfile nodes.
	if p.isAtAsisFileNode():
		at.asisWrite(p)
		writtenFiles.append(p.v.t) ; autoSave = true
	elif p.isAtIgnoreNode():
		pass
	elif p.isAtNorefFileNode():
		at.norefWrite(p)
		writtenFiles.append(p.v.t) ; autoSave = true
	elif p.isAtNoSentFileNode():
		at.write(p,nosentinels=true)
		writtenFiles.append(p.v.t) # No need for autosave
	elif p.isAtThinFileNode():
		at.write(p,thinFile=true)
		writtenFiles.append(p.v.t) # No need for autosave.
	elif p.isAtFileNode():
		at.write(p)
		writtenFiles.append(p.v.t) ; autoSave = true

	if df.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
		mustAutoSave = true
#@nonl
#@-node:ekr.20031218072017.2017:<< handle v's tree >>
#@+node:ekr.20031218072017.2018:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
	if len(writtenFiles) > 0:
		g.es("finished")
	elif writeAtFileNodesFlag:
		g.es("no @file nodes in the selected tree")
	else:
		g.es("no dirty @file nodes")
#@nonl
#@-node:ekr.20031218072017.2018:<< say the command is finished >>
#@-node:ekr.20031218072017.2015:top_df.writeAll
#@+node:ekr.20031218072017.2641:top_df.write, norefWrite, asisWrite
def norefWrite (self,p):
	at = self
	write_new = not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	try:    df.norefWrite(p)
	except: at.writeException(p)
	
rawWrite = norefWrite # Compatibility with old scripts.
	
def asisWrite (self,p):
	at = self
	try: at.old_df.asisWrite(p) # No new_df.asisWrite method.
	except: at.writeException(p)
	
selentWrite = asisWrite # Compatibility with old scripts.
	
def write (self,p,nosentinels=false,thinFile=false):
	at = self
	write_new = thinFile or not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	try:    df.write(p,nosentinels=nosentinels,thinFile=thinFile)
	except: at.writeException(p)

def writeException(self,p):
	self.error("Unexpected exception while writing " + p.headString())
	g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2641:top_df.write, norefWrite, asisWrite
#@+node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles
def writeOldDerivedFiles (self):
	
	self.writeDerivedFiles(write_old=true)

def writeNewDerivedFiles (self):

	self.writeDerivedFiles(write_old=false)
	
def writeDerivedFiles (self,write_old):
	
	config = g.app.config
	old = config.write_old_format_derived_files
	config.write_old_format_derived_files = write_old
	self.writeAll(writeAtFileNodesFlag=true)
	config.write_old_format_derived_files = old
#@nonl
#@-node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles
#@+node:ekr.20031218072017.2019:top_df.writeMissing
def writeMissing(self,p):

	at = self

	write_new = not g.app.config.write_old_format_derived_files
	df = g.choose(write_new,at.new_df,at.old_df)
	df.initIvars()
	writtenFiles = false ; changedFiles = false

	p = p.copy()
	after = p.nodeAfterTree()
	while p and p != after: # Don't use iterator.
		if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
			missing = false ; valid = true
			df.targetFileName = p.anyAtFileNodeName()
			<< set missing if the file does not exist >>
			if valid and missing:
				<< create df.outputFile >>
				if at.outputFile:
					<< write the @file node >>
			p.moveToNodeAfterTree()
		elif p.isAtIgnoreNode():
			p.moveToNodeAfterTree()
		else:
			p.moveToThreadNext()
	
	if writtenFiles > 0:
		g.es("finished")
	else:
		g.es("no missing @file node in the selected tree")
		
	return changedFiles # So caller knows whether to do an auto-save.
#@nonl
#@+node:ekr.20031218072017.2020:<< set missing if the file does not exist >>
# This is similar, but not the same as, the logic in openWriteFile.

valid = df.targetFileName and len(df.targetFileName) > 0

if valid:
	try:
		# Creates missing directives if option is enabled.
		df.scanAllDirectives(p)
		valid = df.errors == 0
	except:
		g.es("exception in atFile.scanAllDirectives")
		g.es_exception()
		valid = false

if valid:
	try:
		fn = df.targetFileName
		df.shortFileName = fn # name to use in status messages.
		df.targetFileName = g.os_path_join(df.default_directory,fn)
		df.targetFileName = g.os_path_normpath(df.targetFileName)

		path = df.targetFileName # Look for the full name, not just the directory.
		valid = path and len(path) > 0
		if valid:
			missing = not g.os_path_exists(path)
	except:
		g.es("exception creating path:" + fn)
		g.es_exception()
		valid = false
#@nonl
#@-node:ekr.20031218072017.2020:<< set missing if the file does not exist >>
#@+node:ekr.20031218072017.2021:<< create df.outputFile >>
try:
	df.outputFileName = df.targetFileName + ".leotmp"
	df.outputFile = open(df.outputFileName,'wb')
	if df.outputFile is None:
		g.es("can not open " + df.outputFileName)
except:
	g.es("exception opening:" + df.outputFileName)
	g.es_exception()
	df.outputFile = None
#@nonl
#@-node:ekr.20031218072017.2021:<< create df.outputFile >>
#@+node:ekr.20031218072017.2022:<< write the @file node >>
if p.isAtAsisFileNode():
	at.asisWrite(p)
elif p.isAtNorefFileNode():
	at.norefWrite(p)
elif p.isAtNoSentFileNode():
	at.write(p,nosentinels=true)
elif p.isAtFileNode():
	at.write(p)
else: assert(0)

writtenFiles = true

if df.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
	changedFiles = true
#@nonl
#@-node:ekr.20031218072017.2022:<< write the @file node >>
#@-node:ekr.20031218072017.2019:top_df.writeMissing
#@+node:EKR.20040507095329:top_df.writeToString
def writeToString (self,p,nosentinels=false,thinFile=false):
	
	at = self ; df = at.new_df
	
	### Can this be correct?  what about scanAllDirectives?  what about comment delims?

	# From perfect import
	df.targetFileName = "<string-file>"
	df.outputFile = fo = g.fileLikeObject()
	df.writeOpenFile(p)
	return fo.get()
	
	if 0: # From execute script:
		
		df.scanAllDirectives(p,scripting=true)
		# Force Python comment delims.
		df.startSentinelComment = "#"
		df.endSentinelComment = None
		# Write the "derived file" into fo.
		fo = g.fileLikeObject()
		df.write(p.copy(),nosentinels=true,scriptFile=fo)
		assert(p)
		s = fo.get()
#@nonl
#@-node:EKR.20040507095329:top_df.writeToString
#@-node:ekr.20031218072017.2640:Writing
#@-node:ekr.20031218072017.2622:<< class baseAtFile methods >>
#@+node:ekr.20031218072017.2387:old_df.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=false,importing=false,reading=false):
	
	"""Scan position p and p's ancestors looking for directives,
	setting corresponding atFile ivars.
	"""

	c = self.c
	<< Set ivars >>
	<< Set path from @file node >>
	old = {}
	for p in p.self_and_parents_iter():
		s = p.v.t.bodyString
		dict = g.get_directives_dict(s)
		<< Test for @path >>
		<< Test for @encoding >>
		<< Test for @comment and @language >>
		<< Test for @header and @noheader >>
		<< Test for @lineending >>
		<< Test for @pagewidth >>
		<< Test for @tabwidth >>
		old.update(dict)
	<< Set current directory >>
	if not importing and not reading:
		# 5/19/04: don't override comment delims when reading!
		<< Set comment strings from delims >>
#@nonl
#@+node:ekr.20031218072017.2388:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = g.app.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline() # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.2388:<< Set ivars >>
#@+node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

dir = g.choose(name,g.os_path_dirname(name),None)

if dir and len(dir) > 0 and g.os_path_isabs(dir):
	if g.os_path_exists(dir):
		self.default_directory = dir
	else: # 9/25/02
		self.default_directory = g.makeAllNonExistentDirectories(dir)
		if not self.default_directory:
			self.error("Directory \"" + dir + "\" does not exist")
#@nonl
#@-node:ekr.20031218072017.2389:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20031218072017.2390:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
	k = dict["comment"]
	# 11/14/02: Similar to fix below.
	delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
	k = dict["language"]
	# 11/14/02: Fix bug reported by J.M.Gilligan.
	self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.2390:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.2391:<< Test for @encoding >>
if not old.has_key("encoding") and dict.has_key("encoding"):
	
	e = g.scanAtEncodingDirective(s,dict)
	if e:
		self.encoding = e
#@nonl
#@-node:ekr.20031218072017.2391:<< Test for @encoding >>
#@+node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if dict.has_key("header") and dict.has_key("noheader"):
	g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20031218072017.2392:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.2393:<< Test for @lineending >>
if not old.has_key("lineending") and dict.has_key("lineending"):
	
	lineending = g.scanAtLineendingDirective(s,dict)
	if lineending:
		self.output_newline = lineending
#@-node:ekr.20031218072017.2393:<< Test for @lineending >>
#@+node:ekr.20031218072017.2394:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and dict.has_key("path"):

	k = dict["path"]
	<< compute relative path from s[k:] >>
	if path and len(path) > 0:
		base = g.getBaseDirectory() # returns "" on error.
		path = g.os_path_join(base,path)
		if g.os_path_isabs(path):
			<< handle absolute path >>
		else:
			self.error("ignoring bad @path: " + path)
	else:
		self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
	(path[0]=='<' and path[-1] == '>') or
	(path[0]=='"' and path[-1] == '"') ):
	path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
	path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.2395:<< compute relative path from s[k:] >>
#@+node:ekr.20031218072017.2396:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
	self.default_directory = path
else: # 9/25/02
	self.default_directory = g.makeAllNonExistentDirectories(path)
	if not self.default_directory:
		self.error("invalid @path: " + path)
#@-node:ekr.20031218072017.2396:<< handle absolute path >>
#@-node:ekr.20031218072017.2394:<< Test for @path >>
#@+node:ekr.20031218072017.2397:<< Test for @pagewidth >>
if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
	
	w = g.scanAtPagewidthDirective(s,dict,issue_error_flag=true)
	if w and w > 0:
		self.page_width = w
#@nonl
#@-node:ekr.20031218072017.2397:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.2398:<< Test for @tabwidth >>
if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
	
	w = g.scanAtTabwidthDirective(s,dict,issue_error_flag=true)
	if w and w != 0:
		self.tab_width = w

#@-node:ekr.20031218072017.2398:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.2399:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
	base = g.getBaseDirectory() # returns "" on error.
	for dir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
		if dir and len(dir) > 0:
			dir = g.os_path_join(base,dir)
			if g.os_path_isabs(dir): # Errors may result in relative or invalid path.
				if g.os_path_exists(dir):
					self.default_directory = dir ; break
				else: # 9/25/02
					self.default_directory = g.makeAllNonExistentDirectories(dir)

if not self.default_directory and not scripting:
	# This should never happen: c.openDirectory should be a good last resort.
	self.error("No absolute directory specified anywhere.")
	self.default_directory = ""
#@nonl
#@-node:ekr.20031218072017.2399:<< Set current directory >>
#@+node:ekr.20031218072017.2400:<< Set comment strings from delims >>
# Use single-line comments if we have a choice.
# 8/2/01: delim1,delim2,delim3 now correspond to line,start,end
if delim1:
	self.startSentinelComment = delim1
	self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
	self.startSentinelComment = delim2
	self.endSentinelComment = delim3
else: # Emergency!
	# assert(0)
	g.es("Unknown language: using Python comment delimiters")
	g.es("c.target_language:",c.target_language)
	g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
	self.startSentinelComment = "#" # This should never happen!
	self.endSentinelComment = ""
	
# g.trace(self.startSentinelComment)
#@nonl
#@-node:ekr.20031218072017.2400:<< Set comment strings from delims >>
#@-node:ekr.20031218072017.2387:old_df.scanAllDirectives
#@+node:EKR.20040507095329.2:To do
@nocolor

- Reading and writing to/from strings.
	- Use these routines in perfectImport and Execute Script command.

- User alterable reading/writing (tangling/untangling)
#@nonl
#@-node:EKR.20040507095329.2:To do
#@+node:ekr.20031218072017.2647:old_df.readOpenFile
def readOpenFile(self,root,file,firstLines):
	
	"""Read an open 3.x derived file."""
	
	at = self

	# Scan the file buffer
	lastLines = at.scanText(file,root,[],endLeo)
	root.v.t.setVisited() # Disable warning about set nodes.

	# Handle first and last lines.
	try: body = root.v.t.tempBodyString
	except: body = ""
	lines = body.split('\n')
	at.completeFirstDirectives(lines,firstLines)
	at.completeLastDirectives(lines,lastLines)
	s = '\n'.join(lines).replace('\r', '')
	root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20031218072017.2647:old_df.readOpenFile
#@+node:ekr.20031218072017.2757:new_df.readOpenFile
def readOpenFile(self,root,file,firstLines):
	
	"""Read an open 4.x thick or thin derived file."""
	
	at = self

	# Scan the 4.x file.
	at.tnodeListIndex = 0
	# 4/27/04: at.thinFile tells scanText4 whether this is a thin file or not.
	lastLines = at.scanText4(file,root)
	root.v.t.setVisited() # Disable warning about set nodes.
	
	# Handle first and last lines.
	try: body = root.v.t.tempBodyString
	except: body = ""
	lines = body.split('\n')
	at.completeFirstDirectives(lines,firstLines)
	at.completeLastDirectives(lines,lastLines)
	s = '\n'.join(lines).replace('\r', '')
	root.v.t.tempBodyString = s
#@-node:ekr.20031218072017.2757:new_df.readOpenFile
#@+node:EKR.20040507095329:top_df.writeToString
def writeToString (self,p,nosentinels=false,thinFile=false):
	
	at = self ; df = at.new_df
	
	### Can this be correct?  what about scanAllDirectives?  what about comment delims?

	# From perfect import
	df.targetFileName = "<string-file>"
	df.outputFile = fo = g.fileLikeObject()
	df.writeOpenFile(p)
	return fo.get()
	
	if 0: # From execute script:
		
		df.scanAllDirectives(p,scripting=true)
		# Force Python comment delims.
		df.startSentinelComment = "#"
		df.endSentinelComment = None
		# Write the "derived file" into fo.
		fo = g.fileLikeObject()
		df.write(p.copy(),nosentinels=true,scriptFile=fo)
		assert(p)
		s = fo.get()
#@nonl
#@-node:EKR.20040507095329:top_df.writeToString
#@+node:EKR.20040506075328:new_df.writeOpenFile
def writeOpenFile(self,root,nosentinels=false,scriptFile=None,thinFile=false):
	
	at = self ; c = at.c
	
	<< init atFile ivars for writing >>
	root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
	root.clearVisitedInTree()

	<< put all @first lines in root >>

	# Put the main part of the file.
	at.putOpenLeoSentinel("@+leo-ver=4")
	at.putInitialComment()
	at.putOpenNodeSentinel(root)
	at.putBody(root)
	at.putCloseNodeSentinel(root)
	at.putSentinel("@-leo")
	root.setVisited()
	
	<< put all @last lines in root >>
	
	if not scriptFile and not nosentinels:
		at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@+node:EKR.20040506075328.1:<< init atFile ivars for writing >>
# Set flags telling what kind of writing we are doing.
at.sentinels = not nosentinels
at.thinFile = thinFile
at.scripting = scriptFile is not None
at.raw = false

# Init other ivars.
at.errors = 0
c.setIvarsFromPrefs()
at.root = root
at.root.v.t.tnodeList = []

c.endEditing() # Capture the current headline.
#@nonl
#@-node:EKR.20040506075328.1:<< init atFile ivars for writing >>
#@+node:ekr.20031218072017.2118:<< put all @first lines in root >> (4.x)
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
	i += len(tag)
	i = g.skip_ws(s,i)
	j = i
	i = g.skip_to_end_of_line(s,i)
	# Write @first line, whether empty or not
	line = s[j:i]
	self.os(line) ; self.onl()
	i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20031218072017.2118:<< put all @first lines in root >> (4.x)
#@+node:ekr.20031218072017.2119:<< put all @last lines in root >> (4.x)
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = root.v.t.bodyString.split('\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
	j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
	line = lines[j]
	if g.match(line,0,tag): j -= 1
	else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
	i = len(tag) ; i = g.skip_ws(line,i)
	self.os(line[i:]) ; self.onl()
#@nonl
#@-node:ekr.20031218072017.2119:<< put all @last lines in root >> (4.x)
#@-node:EKR.20040506075328:new_df.writeOpenFile
#@-node:EKR.20040507095329.1:(More flexible atFile classes)
#@+node:EKR.20040512084028:Plugin generalizing marks (mulder)
#@+node:EKR.20040512084028.1:@url http://home.pacbell.net/bwmulder/python/Leo/mod_label.leo
#@-node:EKR.20040512084028.1:@url http://home.pacbell.net/bwmulder/python/Leo/mod_label.leo
#@+node:EKR.20040512084134:Crash
@nocolor

getUnknownTag: labels <long string>

exceptions opening: C:\Documents and Settings\default\Desktop\mod_label.leo
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 670, in openWithFileName
    frame.c.fileCommands.open(file,fileName) # closes file.
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 1121, in open
    ok, ratio = self.getLeoFile(fileName,atFileNodesFlag=true)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 525, in getLeoFile
    self.getVnodes()
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 927, in getVnodes
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 864, in getVnode
    appendToCurrentStack=append1,appendToTopStack=append2)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 833, in getVnode
    v,skip = self.createVnode(parent,back,tref,headline,attrDict)
  File "c:\prog\leoCVS\leo\src\leoFileCommands.py", line 145, in createVnode
    p.v.unknownAttributes = attrDict
NameError: global name 'p' is not defined
#@nonl
#@-node:EKR.20040512084134:Crash
#@-node:EKR.20040512084028:Plugin generalizing marks (mulder)
#@+node:EKR.20040512085700:Dynabutton script
#@+node:EKR.20040512085700.1:Description
@nocolor
https://sourceforge.net/forum/message.php?msg_id=2556085
By: nobody

@
exec this script, then select some text and hit dynabuttton
its perfect! no plugin to bother with.
and re-editing the code is simple.
leverage Leo to keep a collection of macro scripts.
just switch in new dosomething nodes as needed.

#w04505p01:22:22 add a button works!
I can have a script that acts on selected text
usable from the button.
how to get the button in an exact position?
toolbar is getting crowded.
why did noone think of this before?
you could give it other commands once its up,
like soakup the current selected text as a script.
anything you like. a poor mans macro.
more than one active button easily possible.

use it wisely and test everything fully.
works at least on Leo 4.1final & win9x

replace leading dots with spaces
enjoy
@c

#@-node:EKR.20040512085700.1:Description
#@+node:EKR.20040512090213:Description 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2560787
By: nobody

I've uploaded a new version which includes a few sample "macro's" and a node
structure that lends itself to better work out the bugs in new scripts. and
a rightclick menu for the button to select from the script samples.
the menu is built from nodes cloned in the macro node which you drag into the
dynamenu node.
also a better way to copy the XML of the node off the html page so you can paste
it into a leo.
http://rclick.netfirms.com/rCpython.htm

you can now toggle a menu item to either print selected text transformed by
whichever item or to paste over the selected text.
there is a dump selected text or body in hex form, good for debugging char related
problems.
one to put a triple double quote around the selected text.
one that isnt quite ready to output python in txt or html prettyprint form.
one that deletes the first char of each line in selected text.
one to sort the selected text line by line.

of course, it is easy enough to add your own and be up and running with it in
under a minute.
I will post more examples as they are contributed here or in the comments page
there.
#@nonl
#@-node:EKR.20040512090213:Description 2
#@+node:EKR.20040512090213.1:@url http://rclick.netfirms.com/rCpython.htm
#@-node:EKR.20040512090213.1:@url http://rclick.netfirms.com/rCpython.htm
#@+node:EKR.20040512085700.2:Install script
import leoGlobals as g
c = g.top()
cf = c.frame
 
#used first for changing Tk pack options to dict's
#side=Tk.LEFT, expand=1, fill=Tk.BOTH
#{'side':'left', 'expand':'1', 'fill':'both'}
#this might have been ok as a find/change script as too...

@others

deldyna()

cf.dynacb = cf.addIconButton(text="dyna", command= dynaclick)

#later can add its own menu and options
#bind double right click button3 to make dynaclick dissapear
cf.dynacb.bind('<Double-3>', deldyna)
#more likely use, rclick to select different functions
cf.dynacb.bind('<3>', dynaclick)

#bind Alt+1 to dosomething, needs work
cf.dynacb.bind('<'+'<Key-Alt-1>>', dynaclick)

cf.clearStatusLine() 
for msg, color in (('dyn',"red"),('a',"orange"),('click',"blue")):
	cf.putStatusLine("%s"%(msg,),color= color)

print "dynaclick button installed"
#@nonl
#@+node:EKR.20040512085700.3:dosomething
def dosomething(c):

	if c.frame.body.hasTextSelection():
		newSel = str(c.frame.body.getSelectedText() )
		so = '{'
		print 'text is', newSel
		for x in newSel.split():
			s = x.replace('"', "'").replace("'", "")
			s = s.replace("=", "':'")
			s = s.replace('Tk.', "").replace(",", "', ")
			so += "'%s"%(s.lower(),)
			#idealy it wouldn't add SQ around plain numbers
			#split on , maybe or resplit later, 
			#good enough for now
		print so + "'}"

	else:
		g.es("no text selected", color= 'red' )


#@-node:EKR.20040512085700.3:dosomething
#@+node:EKR.20040512085700.4:dynaclick
def dynaclick(*a, **k):
	
	import leoGlobals as g

	c = g.top()
	c.frame.clearStatusLine()
	c.frame.putStatusLine('Dyna Click Active')
	dosomething(c)
	print 'add your own code here to dosomething'
#@nonl
#@-node:EKR.20040512085700.4:dynaclick
#@+node:EKR.20040512085700.5:deldyna
def deldyna(*a, **k):

	try:
		cf.dynacb.destroy()
	except:
		print "no dyna button active"
#@nonl
#@-node:EKR.20040512085700.5:deldyna
#@-node:EKR.20040512085700.2:Install script
#@-node:EKR.20040512085700:Dynabutton script
#@+node:EKR.20040512090759:Leo.app for MacOS X
@nocolor

Hi Ed,


I've created a Leo.app that I'm using reasonably successfully. Hopefully 
you'll be able to take the pattern for a Mac OS X binary download option!


http://idisk.mac.com/genthaler-Public/Leo.zip
(WebDAV)

Regards,

Gnther
#@nonl
#@-node:EKR.20040512090759:Leo.app for MacOS X
#@-node:EKR.20040512081330:In progress
#@-all
#@nonl
#@-node:EKR.20040429143933:@file-thin leoProjects.txt
#@-leo
