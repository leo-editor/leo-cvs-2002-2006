#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.1319:(Key handlers)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            << Do auto indent >>
        elif ch == '\t' and tab_width < 0:
            << convert tab to blanks >>
        elif ch in (chr(8)) and tab_width < 0:
            << handle backspace with negative tab_width >>
    << set s to widget text, removing trailing newlines if necessary >>
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
# Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18
#@nonl
#@-node:ekr.20031218072017.1324:<< Do auto indent >> (David McNab)
#@+node:ekr.20031218072017.1325:<< convert tab to blanks >>
# Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20031218072017.1325:<< convert tab to blanks >>
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@-node:ekr.20031218072017.1321:idle_body_key
#@+node:ekr.20031218072017.1329:onBodyChanged (tkTree)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (tkTree)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char
    
    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@+node:ekr.20040803072955.91:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; u = c.undoer

    if not p or not p.isCurrentPosition():
        return "break"

    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    << set head to vnode text >>
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        undoData = u.beforeChangeNodeContents(p)
        << update p >>
        u.afterChangeNodeContents(p,'Change Headline',undoData,dirtyVnodeList=dirtyVnodeList)
    if done or changed:
        << reconfigure p and all nodes joined to p >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20040803072955.92:<< set head to vnode text >>
head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")
#@nonl
#@-node:ekr.20040803072955.92:<< set head to vnode text >>
#@+node:ekr.20040803072955.93:<< set the widget text to head >>
self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)
#@nonl
#@-node:ekr.20040803072955.93:<< set the widget text to head >>
#@+node:ekr.20040803072955.94:<< set s to the widget text >>
s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) > limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20040803072955.94:<< set s to the widget text >>
#@+node:ekr.20040803072955.95:<< update p >>
c.beginUpdate()
if 1: # In update...

    # Update changed bit.
    if not c.changed:
        c.setChanged(True)

    # We must call p.setDirty even if p is dirty!
    dirtyVnodeList = p.setDirty()

    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)

c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20040803072955.95:<< update p >>
#@+node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
# Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))
#@nonl
#@-node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
#@+node:ekr.20040803072955.97:<< update the screen >>
if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20040803072955.97:<< update the screen >>
#@-node:ekr.20040803072955.91:idle_head_key
#@-node:ekr.20031218072017.1319:(Key handlers)
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """
    
    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    language = c.target_language
    self.language = language # 2/2/03
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language # 2/2/03

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 Ã
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20040803100035:Run Pychecker
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@-node:ekr.20040803100035:Run Pychecker
#@+node:ekr.20040929081120:4.3 a1 projects
#@+node:ekr.20041228052527:Bug fixes...
#@+node:ekr.20050123151628:Code
#@+node:ekr.20050106032427:(g.import wrappers return module if it is in sys.modules)
#@+node:ekr.20041219095213:import wrappers
@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
#@nonl
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
            except Exception:
                g.es("unexpected exception in g.import",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally:
            if theFile: theFile.close()
    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@-node:ekr.20050106032427:(g.import wrappers return module if it is in sys.modules)
#@+node:ekr.20040226094105:(Put the scrollWheel workaround in createTkTreeCanvas)
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20040226094105:(Put the scrollWheel workaround in createTkTreeCanvas)
#@-node:ekr.20050123151628:Code
#@+node:ekr.20050104122244:Commands
#@+node:ekr.20041013061250:(Fixed hyperlink bug)
#@+node:ekr.20041013061250.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2802138
By: rogererens

Using Leo4.2 on WinXP, control-clicking on a section reference:
instead of going to the section definition, I get the following log message:

exception handling , hypercclick,  event
AttributeError

and in the console:

unknown position attribute: redraw
Traceback (most recent call last):
  File "C:\Leo\src\leoTkinterTree.py", line 351, in OnHyperLinkControlClick
    self.redraw()
  File "C:\Leo\src\leoNodes.py", line 1534, in __getattr__
    raise AttributeError
AttributeError

Commenting out the line
self.redraw
in onHyperLinkControlClick
seems to work, but the comment above puts some doubts on the correctness of
this adaptation.

Also, the documentation w.r.t. hyperlinks seems outdated to me, since with the
'Recent' button one can quite easily navigate backward and forward like in web
browsers.
#@-node:ekr.20041013061250.1:Report
#@+node:ekr.20040803072955.23:OnHyperLinkControlClick
def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            # New in recycled nodes code:
            # Call self.redraw to inhibit calls to setLabelState.
            c.frame.tree.redraw()
            c.beginUpdate()
            c.selectVnode(p)
            c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")
#@nonl
#@-node:ekr.20040803072955.23:OnHyperLinkControlClick
#@-node:ekr.20041013061250:(Fixed hyperlink bug)
#@+node:ekr.20041018190736:(Fixed problems with spawnv option of openWith)
#@+node:ekr.20041018190736.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2805807
By: Ivan

In baseCommands.openWith(), the case for "openType == 'os.spawnv'" appears to
be broken. The two problems I see are that it actually invokes os.spawnl, and
that it does not allow the passing of a variable length list of parameters.

@color

# Replace the body of the os.spawnv case:

filename = g.os_path_basename(arg)
command = "os.spawnv("+arg+",("+filename+','+ shortPath+"))"
apply(os.spawnl,(os.P_NOWAIT,arg,filename,path)))
 
# with:
    
filename = os.path.basename(arg[0])
vtuple = arg[1:]
vtuple.append(path)
command = "os.spawnv("+arg[0]+","+`vtuple`+")"
apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))

# This requires calls on openWith like
openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
#@nonl
#@-node:ekr.20041018190736.1:Report
#@+node:ekr.20031218072017.4116:createOpenWithMenuFromTable
@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the "Open With..." menu.
    openWithMenu = Tk.Menu(parent,tearoff=0)
    self.setMenu("Open With...",openWithMenu)
    parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
    # Populate the "Open With..." menu.
    shortcut_table = []
    for triple in table:
        if len(triple) == 3: # 6/22/03
            shortcut_table.append(triple)
        else:
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
            
    # for i in shortcut_table: print i
    self.createMenuItemsFromTable("Open &With...",shortcut_table,openWith=True)
#@nonl
#@-node:ekr.20031218072017.4116:createOpenWithMenuFromTable
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:] 
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(os.path.abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20041018190736:(Fixed problems with spawnv option of openWith)
#@+node:ekr.20041020104517:(Fixed bug in  Remove Sentinels command)
#@+node:ekr.20041020104517.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2807391
By: spboulet

Running the File->Export->Remove Sentinels command on a file derived from an
@file node, I get "Can not open D" in the log window (the file is on my D partition).
I do have permission to write the file; tangling works fine.

-------

The fix was to add multiple=True in the call to g.app.gui.runOpenFileDialog in removeSentinels.

Apparently there is a Python bug in askopenfilename, but this fix avoids that.
#@nonl
#@-node:ekr.20041020104517.1:Report
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    if multiple:
        # askopenfilenames requires Pythone 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(title=title,filetypes=filetypes)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(title=title,filetypes=filetypes)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(title=title, filetypes=filetypes)

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)
#@nonl
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.3300:removeSentinelsCommand
def removeSentinelsCommand (self,paths):
    
    c = self.c

    self.setEncoding()

    for fileName in paths:

        path, self.fileName = g.os_path_split(fileName)
        << Read file into s >>
        << set delims from the header line >>
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = c.config.remove_sentinels_extension
        if not ext:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        << Write s into newFileName >>
#@nonl
#@+node:ekr.20031218072017.3301:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@nonl
#@-node:ekr.20031218072017.3301:<< Read file into s >>
#@+node:ekr.20031218072017.3302:<< set delims from the header line >>
# Skip any non @+leo lines.
i = 0
while i < len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim,derivedFileIsThin = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None
#@nonl
#@-node:ekr.20031218072017.3302:<< set delims from the header line >>
#@+node:ekr.20031218072017.1149:<< Write s into newFileName >>
try:
    mode = c.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    theFile = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    theFile.write(s)
    theFile.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1149:<< Write s into newFileName >>
#@-node:ekr.20031218072017.3300:removeSentinelsCommand
#@-node:ekr.20041020104517:(Fixed bug in  Remove Sentinels command)
#@+node:ekr.20041023055452:(Fixed bug re Paste Retaining Clones)
#@+node:ekr.20041023055452.1:Report
From Leo User

I forgot to mention that I had this happen twice today:
1. Copy node.
2. Paste Retaining Clone

...seemed to enter endless node creation loop.
#@-node:ekr.20041023055452.1:Report
#@+node:ekr.20041023055452.2:What I did
@killcolor

1. In << recreate tnodesDict >>

    - Set self.tnodesDict ={}
    - Changed all_tnodes_iter to all_unique_tnodes_iter.

2. Set self.forbiddenTnodes in get_vnodes.  Also added reassignIndices keyword param.

3. Raise invalidPaste in get_vnode if the tnode (to be generated later) would be in self.forbiddenTnodes.

3. Fixed bugs:  tnodes_iter and unique_tnodes_iter were returning vnodes, not tnodes!

4. Report exceptions in getLeoOutline rather than pasteOutline.
#@nonl
#@-node:ekr.20041023055452.2:What I did
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self):
    
    c = self

    return c.pasteOutline(reassignIndices=False)
#@nonl
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return
    
    copiedBunchList = []
    if pasteAsClone:
        << put only needed info in copiedBunchList >>
    
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.beginUpdate()
    c.endEditing()
    if 1: # inside update...
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    c.endUpdate()
    c.recolor()
#@nonl
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
#@nonl
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@nonl
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
# This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s,reassignIndices=True):

    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.tnodesDict = {}
    self.descendentUnknownAttributesDictList = []

    if not reassignIndices:
        << recreate tnodesDict >>

    try:
        self.getXmlVersionTag() # leo.py 3.0
        self.getXmlStylesheetTag() # 10/25/02
        self.getTag("<leo_file>") # <leo_file/> is not valid.
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        v = self.finishPaste(reassignIndices)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    # Clean up.
    self.fileBuffer = None ; self.fileIndex = 0
    self.usingClipboard = False
    self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@nonl
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)
    else:
        << set current and top positions >>

    self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
top = self.convertStackToPosition(self.topVnodeStack)
if top:
    c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@nonl
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched <v.
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@-node:ekr.20041023055452:(Fixed bug re Paste Retaining Clones)
#@+node:ekr.20050101100208:(Fixed Pretty Printer code for Python 2.4)
# The '@' sign is an operator in Python 2.4, not an error token.
#@nonl
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = [] # List of strings comprising the line being accumulated.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.line = 0 # Same as self.srow
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False

    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine
def doMultiLine (self):
    
    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine
#@+node:ekr.20041021101911.5:doName
def doName(self):

    self.array.append("%s " % self.val)
    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.
    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):
    
    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20050101100208:(Fixed Pretty Printer code for Python 2.4)
#@+node:ekr.20050102181816:(Fixed crasher in Import Derived Files command)
#@+node:ekr.20050103111219:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2918934
By: ktenney

Current CVS, Win2000
When I select leo.py to import, I get the traceback;

exception executing command
Traceback (most recent call last):
  File "C:\Python23\Lib\site-packages\leo\src\leoCommands.py", line 161, in
doCommand
    command()
  File "C:\Python23\Lib\site-packages\leo\src\leoCommands.py", line 811, in
importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\Python23\Lib\site-packages\leo\src\leoImport.py", line 129,
in importDerivedFiles
    junk,read_new,isThin = at.scanHeader(theFile,fileName)
  File "C:\Python23\Lib\site-packages\leo\src\leoAtFile.py", line 2504,
in scanHeader
    s = at.readLine(theFile)
  File "C:\Python23\Lib\site-packages\leo\src\leoAtFile.py", line 2469,
in readLine
    u = g.toUnicode(s,self.encoding)
AttributeError: atFile instance has no attribute 'encoding'
#@nonl
#@-node:ekr.20050103111219:Report
#@+node:ekr.20050103163633:Fix
@killcolor

What I did:
    
- Created a new top-level method: scanHeaderForThin.

This sets self.encoding temporarily. The actual value of self.encoding does not
really matter: no errors will be given by readLine and its helpers even if there
are unicode encoding errors.

- We must _not_ set self.encoding in scanHeader: that would interfere with
normal initialization.
#@nonl
#@-node:ekr.20050103163633:Fix
#@+node:ekr.20041005105605.128:readLine
def readLine (self,theFile):
    
    """Reads one line from file using the present encoding"""

    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    u = g.toUnicode(s,self.encoding)
    return u


#@-node:ekr.20041005105605.128:readLine
#@+node:ekr.20050103163224:scanHeaderForThin
def scanHeaderForThin (self,theFile,fileName):
    
    '''Scan the header of a derived file and return True if it is a thin file.
    
    N.B. We are not interested in @first lines, so any encoding will do.'''
    
    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding
    
    junk,junk,isThin = at.scanHeader(theFile,fileName)
    
    return isThin
#@nonl
#@-node:ekr.20050103163224:scanHeaderForThin
#@+node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
def scanHeader(self,theFile,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.130:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
    
n = len(s)
valid = n > 0
#@-node:ekr.20041005105605.130:<< skip any non @+leo lines >>
#@-node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent,paths):
    
    c = self.c ; u = c.undoer
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    command = 'Import'

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            << set isThin if fileName is a thin derived file >>
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        u.afterChangeGroup(p,command)
    c.endUpdate()
#@nonl
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@nonl
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@-node:ekr.20050102181816:(Fixed crasher in Import Derived Files command)
#@+node:ekr.20050121082447:(Fixed bug in the code that executes Open With command with spawnv)
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:] 
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@-node:ekr.20050121082447:(Fixed bug in the code that executes Open With command with spawnv)
#@+node:ekr.20050121074152:(Fix buged: search in hoisted outline can stop outside the hoisted area)
#@+node:ekr.20050121074152.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2934617
By: bwmulder

According to various notes in the Leo documentation, "hoist" should restrict
you a subtree of the outline.

With the version I am using (CVS, a few days old), searching for strings stops
at nodes outside this subtree. The nodes where the string was found remains
invisible.
#@-node:ekr.20050121074152.1:Report
#@+node:ekr.20031218072017.2028:Hoist & dehoist
def dehoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')

def hoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
#@nonl
#@-node:ekr.20031218072017.2028:Hoist & dehoist
#@+node:ekr.20031218072017.3081:selectNextVnode
# Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(p)
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()
    
    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@nonl
#@-node:ekr.20031218072017.3081:selectNextVnode
#@-node:ekr.20050121074152:(Fix buged: search in hoisted outline can stop outside the hoisted area)
#@+node:ekr.20050122122437:(Fixed bugs handling @language & @comment in atFile.scanAllDirectives & g.scanDirectives)
#@+node:ekr.20050122122437.1:Report
@killcolor

Changed scanDirectives and atFile.scanDirectives so they work like tangle.scanAllDirectives.  Also added a few clarifying words in LeoDocs.leo.

This should have worked, but didn't:

+ Code 
  @language python 
  + @file sql_create.sql 
    @comment -- 
 
So I rearranged the outline (probably more logical anyway) to  
+Code 
  + Python 
  ... 
+ SQL 
  ... 
#@-node:ekr.20050122122437.1:Report
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """
    
    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20050122122437:(Fixed bugs handling @language & @comment in atFile.scanAllDirectives & g.scanDirectives)
#@-node:ekr.20050104122244:Commands
#@+node:ekr.20050123151628.1:Distribution
#@+node:ekr.20041022063506:(Fixed file association in leoDist.leo)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2816347
By: osuchw

I have came upon a small bug related to how *.leo files are registered to be
open with windows.

Currently the command looks like.
<pythondir>\pythonw.exe "<leodir>\src\leo.py" %1
and it should be
"<pythondir>\pythonw.exe" "<leodir>\src\leo.py" "%1"

The difference is in quotes.  Especially quotes around "%1" seem to matter.
For example rst2.py plugin fails if it is called from a leo file that has spaces
in it is path.
#@-node:ekr.20041022063506:(Fixed file association in leoDist.leo)
#@-node:ekr.20050123151628.1:Distribution
#@+node:ekr.20050104122651:Menus
#@+node:ekr.20050102092149:(Fixed problems with Control-E)
#@+node:ekr.20050104084310: Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2918938
By: ktenney

Any idea what might prevent the Control-E shortcut key from working?  Edit -> Execute Script works fine

current cvs, Win2000, Python 2.3
#@nonl
#@-node:ekr.20050104084310: Report
#@+node:ekr.20050104094308.1: What I did
@killcolor

- Restored non Pmw code in resizePanesToRatio.  This code got deleted by mistake.  The Equal Sized Panes works again.

- Added many do-nothing methods to nullMenu class.

This should prevent the startup logic from messing with shortcuts in any way.  It's also the right thing to do.

- Added an entry for EqualSizedPanes to leoSettings.leo.  This overrides the default (Ctrl-E) and thereby prevents the default from overrideing the entry for ExecuteScript!

- Re-enabled code in createMenuEntries that warns when shortcuts have been redefined.  Not sure if this is a wise idea, or indeed if it actually does anything :-)

I am tempted to remove all the default entries entirely.  This would simplify error reporting, but then Leo would hardly work at all if leoSettings.leo were not present.
#@nonl
#@-node:ekr.20050104094308.1: What I did
#@+node:ekr.20031218072017.3811:class nullMenu
class nullMenu(leoMenu):
    
    """A null menu class for testing and batch execution."""
    
    __pychecker__ = '--no-argsused' # This calss has many unused args.
    
    @others
#@nonl
#@+node:ekr.20050104094308:ctor
def __init__ (self,frame):
    
    # Init the base class.
    leoMenu.__init__(self,frame)
#@nonl
#@-node:ekr.20050104094308:ctor
#@+node:ekr.20050104094029:oops
def oops (self):

    g.trace("leoMenu", g.callerName(2))
    pass
#@nonl
#@-node:ekr.20050104094029:oops
#@+node:ekr.20050104093323:Gui-independent menu routines
def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    pass
def createMenuItemsFromTable (self,menuName,table,openWith=False):
    pass
def createMenusFromTables (self):
    pass
def defineMenuTables (self):
    pass
def createNewMenu (self,menuName,parentName="top",before=None):
    pass
def createRecentFilesMenuItems (self):
    pass
def deleteMenu (self,menuName):
    pass
def deleteMenuItem (self,itemName,menuName="top"):
    pass
def destroyMenu (self,menuName):
    pass
def getMenu (self,menuName):
    pass
def setMenu (self,menuName,menu):
    pass
#@nonl
#@-node:ekr.20050104093323:Gui-independent menu routines
#@+node:ekr.20050104092958:Gui-independent menu enablers
def updateAllMenus (self):
    pass
def updateEditMenu (self):
    pass
def updateFileMenu (self):
    pass
def updateOutlineMenu (self):
    pass
#@nonl
#@-node:ekr.20050104092958:Gui-independent menu enablers
#@-node:ekr.20031218072017.3811:class nullMenu
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20031218072017.3752:defineMenuTables
def defineMenuTables (self):
    
    __pychecker__ = 'maxlines=500'
    
    c = self.c ; f = self.frame
    
    # g.trace(c.shortFileName(),self,f)
    
    << define edit menu tables >>
    << define file menu tables >>
    << define outline menu tables >>
    << define window menu tables >>
    << define help menu tables >>
#@nonl
#@+node:ekr.20031218072017.3753:<< define edit menu tables >>
<< define editMenuTopTable >>
<< define editMenuEditBodyTable >>
<< define editMenuEditHeadlineTable >>
<< define editMenuFindMenuTable >>
<< define editMenuTop2Table >>
#@nonl
#@+node:ekr.20031218072017.839:<< define editMenuTopTable >>
self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
    ("-",None,None),
    ("Cu&t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&y","Ctrl+C",f.OnCopyFromMenu),
    ("&Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&Delete",None,c.delete),
    ("Select &All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))
    
# Top-level shortcuts here:  a,d,p,t,u,y,z
# Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:<< define editMenuTopTable >>
#@+node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
self.editMenuEditBodyTable = (
    ("Extract &Section","Shift+Ctrl+E",c.extractSection),
    ("Extract &Names","Shift+Ctrl+N",c.extractSectionNames),
    ("&Extract","Shift+Ctrl+D",c.extract),
    ("-",None,None),
    ("Convert All B&lanks",None,c.convertAllBlanks),
    ("Convert All T&abs",None,c.convertAllTabs),
    ("Convert &Blanks","Shift+Ctrl+B",c.convertBlanks),
    ("Convert &Tabs","Shift+Ctrl+J",c.convertTabs),
    ("Insert Body Time/&Date","Shift+Ctrl+G",c.insertBodyTime),
    ("&Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
    ("-",None,None),
    ("&Indent","Ctrl+]",c.indentBody),
    ("&Unindent","Ctrl+[",c.dedentBody),
    ("&Match Brackets","Ctrl+K",c.findMatchingBracket),
    ("Add Comments",None,c.addComments),
    ("Delete Comments",None,c.deleteComments),
)

# Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@nonl
#@-node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
#@+node:ekr.20031218072017.3755:<< define editMenuEditHeadlineTable >>
self.editMenuEditHeadlineTable = (
    ("Edit &Headline","Ctrl+H",c.editHeadline),
    ("&End Edit Headline","Escape",f.endEditLabelCommand),
    ("&Abort Edit Headline","Shift+Escape",f.abortEditLabelCommand),
    ("Insert Headline Time/&Date","Shift+Ctrl+H",f.insertHeadlineTime),
    # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
    ("Toggle Angle Brackets",None,c.toggleAngleBrackets))
#@nonl
#@-node:ekr.20031218072017.3755:<< define editMenuEditHeadlineTable >>
#@+node:ekr.20031218072017.3756:<< define editMenuFindMenuTable >>
self.editMenuFindMenuTable = (
    ("&Find Panel","Ctrl+F",c.showFindPanel),
    ("-",None,None),
    ("Find &Next","F3",c.findNext),
    ("Find &Previous","F4",c.findPrevious),
    ("&Replace","Ctrl+=",c.replace),
    ("Replace, &Then Find","Ctrl+-",c.replaceThenFind))
#@nonl
#@-node:ekr.20031218072017.3756:<< define editMenuFindMenuTable >>
#@+node:ekr.20031218072017.3757:<< define editMenuTop2Table >>
try:
    show = c.frame.body.getColorizer().showInvisibles
except:
    show = False

label = g.choose(show,"Hide In&visibles","Show In&visibles")
    
self.editMenuTop2Table = (
    ("&Go To Line Number","Alt+G",c.goToLineNumber),
    ("&Execute Script","Alt+Shift+E",c.executeScript),
    # ("Set Fon&t...",None,c.fontPanel), # To be replaced by general settings dialog.
    # ("Set &Colors...",None,c.colorPanel), # To be replaced by general settings dialog.
    (label,"Alt+V",c.viewAllCharacters),
    # ("-",None,None),
    ("Setti&ngs",None,c.preferences)
)

# Top-level shortcuts earlier: a,d,p,t,u,y,z
# Top-level shortcuts here: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.3757:<< define editMenuTop2Table >>
#@-node:ekr.20031218072017.3753:<< define edit menu tables >>
#@+node:ekr.20031218072017.3758:<< define file menu tables >>
<< define fileMenuTopTable >>
<< define fileMenuTop2Table >>
<< define fileMenuReadWriteMenuTable >>
<< define fileMenuTangleMenuTable >>
<< define fileMenuUntangleMenuTable >>
<< define fileMenuImportMenuTable >>
<< define fileMenuExportMenuTable >>
<< define fileMenuTop3MenuTable >>
#@nonl
#@+node:ekr.20031218072017.3759:<< define fileMenuTopTable >>
self.fileMenuTopTable = (
    ("&New","Ctrl+N",c.new),
    ("&Open...","Ctrl+O",c.open))
#@nonl
#@-node:ekr.20031218072017.3759:<< define fileMenuTopTable >>
#@+node:ekr.20031218072017.3760:<< define fileMenuTop2Table >>
self.fileMenuTop2Table = (
    ("-",None,None),
    ("&Close","Ctrl+W",c.close),
    ("&Save","Ctrl+S",c.save),
    ("Save &As","Shift+Ctrl+S",c.saveAs),
    ("Save To",None,c.saveTo), # &Tangle
    ("Re&vert To Saved",None,c.revert)) # &Read/Write
#@nonl
#@-node:ekr.20031218072017.3760:<< define fileMenuTop2Table >>
#@+node:ekr.20031218072017.3761:<< define fileMenuReadWriteMenuTable >>
self.fileMenuReadWriteMenuTable = (
    ("&Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
    ("Read @file &Nodes",None,c.readAtFileNodes),
    ("-",None,None),
    ("Write &Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
    ("Write &Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
    ("Write &Outline Only",None,c.fileCommands.writeOutlineOnly),
    ("&Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes))
#@nonl
#@-node:ekr.20031218072017.3761:<< define fileMenuReadWriteMenuTable >>
#@+node:ekr.20031218072017.3762:<< define fileMenuTangleMenuTable >>
self.fileMenuTangleMenuTable = (
    ("Tangle &All","Shift+Ctrl+A",c.tangleAll),
    ("Tangle &Marked","Shift+Ctrl+M",c.tangleMarked),
    ("&Tangle","Shift+Ctrl+T",c.tangle))
#@nonl
#@-node:ekr.20031218072017.3762:<< define fileMenuTangleMenuTable >>
#@+node:ekr.20031218072017.3763:<< define fileMenuUntangleMenuTable >>
self.fileMenuUntangleMenuTable = (
    ("Untangle &All",None,c.untangleAll),
    ("Untangle &Marked",None,c.untangleMarked),
    ("&Untangle","Shift+Ctrl+U",c.untangle))
#@nonl
#@-node:ekr.20031218072017.3763:<< define fileMenuUntangleMenuTable >>
#@+node:ekr.20031218072017.3764:<< define fileMenuImportMenuTable >>
self.fileMenuImportMenuTable = (
    ("Import Derived File",None,c.importDerivedFile),
    ("Import To @&file","Shift+Ctrl+F",c.importAtFile),
    ("Import To @&root",None,c.importAtRoot),
    ("Import &CWEB Files",None,c.importCWEBFiles),
    
    ("Import &noweb Files",None,c.importNowebFiles),
    ("Import Flattened &Outline",None,c.importFlattenedOutline))
#@nonl
#@-node:ekr.20031218072017.3764:<< define fileMenuImportMenuTable >>
#@+node:ekr.20031218072017.3765:<< define fileMenuExportMenuTable >>
self.fileMenuExportMenuTable = [
    ("Export &Headlines",None,c.exportHeadlines),
    ("Outline To &CWEB",None,c.outlineToCWEB),
    ("Outline To &Noweb",None,c.outlineToNoweb),
    ("&Flatten Outline",None,c.flattenOutline),
    ("&Remove Sentinels",None,c.removeSentinels),
    ("&Weave",None,c.weave)]
#@nonl
#@-node:ekr.20031218072017.3765:<< define fileMenuExportMenuTable >>
#@+node:ekr.20031218072017.3766:<< define fileMenuTop3MenuTable >>
self.fileMenuTop3MenuTable = (
    ("E&xit","Ctrl+Q",g.app.onQuit),)
#@nonl
#@-node:ekr.20031218072017.3766:<< define fileMenuTop3MenuTable >>
#@-node:ekr.20031218072017.3758:<< define file menu tables >>
#@+node:ekr.20031218072017.3767:<< define outline menu tables >>
<< define outlineMenuTopMenuTable >>
<< define outlineMenuCheckOutlineMenuTable >>
<< define outlineMenuExpandContractMenuTable >>
<< define outlineMenuMoveMenuTable >>
<< define outlineMenuMarkMenuTable >>
<< define outlineMenuGoToMenuTable >>
#@nonl
#@+node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
self.outlineMenuTopMenuTable = (
    ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Pas&te Node As Clone",None,c.pasteOutlineRetainingClones),
    ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&Insert Node","Ctrl+I",c.insertHeadline),
    ("&Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
    ("&Sort Siblings","Alt+A",c.sortSiblings),
    ("-",None,None),
    ("&Hoist",None,c.hoist),
    ("D&e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
# Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
#@+node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
self.outlineMenuCheckOutlineMenuTable = (

    ("Check &Outline",None,c.checkOutline),
    ("&Dump Outline",None,c.dumpOutline),
    ("-",None,None),
    ("Check &All Python Code",None,c.checkAllPythonCode),
    ("&Check Python &Code",None,c.checkPythonCode),
    ("-",None,None),
    ("Pretty P&rint All Python Code",None,c.prettyPrintAllPythonCode),
    ("&Pretty Print Python Code",None,c.prettyPrintPythonCode),
    
)

# shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
#@+node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
self.outlineMenuExpandContractMenuTable = (
    ("&Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &Node","Alt+[",c.contractNode),
    ("Contract &Parent","Alt+0",c.contractParent),
    ("Contract Or Go Left","Alt+LtArrow",c.contractNodeOrGoToParent),
    ("-",None,None),
    ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&ext Level","Alt+=",c.expandNextLevel),
    ("Expand Or Go Right","Alt+RtArrow",c.expandNodeOrGoToFirstChild),
    ("-",None,None),
    ("Expand To Level &1","Alt+1",c.expandLevel1),
    ("Expand To Level &2","Alt+2",c.expandLevel2),
    ("Expand To Level &3","Alt+3",c.expandLevel3),
    ("Expand To Level &4","Alt+4",c.expandLevel4),
    ("Expand To Level &5","Alt+5",c.expandLevel5),
    ("Expand To Level &6","Alt+6",c.expandLevel6),
    ("Expand To Level &7","Alt+7",c.expandLevel7),
    ("Expand To Level &8","Alt+8",c.expandLevel8),
    # ("Expand To Level &9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &All","Alt+9",c.expandAllHeadlines),
    ("Expand N&ode","Alt+]",c.expandNode))
#@nonl
#@-node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
#@+node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
self.outlineMenuMoveMenuTable = (
    ("Move &Down", "Ctrl+D",c.moveOutlineDown),
    ("Move &Left", "Ctrl+L",c.moveOutlineLeft),
    ("Move &Right","Ctrl+R",c.moveOutlineRight),
    ("Move &Up",   "Ctrl+U",c.moveOutlineUp),
    ("-",None,None),
    ("&Promote","Ctrl+{",c.promote),
    ("&Demote", "Ctrl+}",c.demote))
#@nonl
#@-node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
#@+node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
self.outlineMenuMarkMenuTable = (
    ("&Mark","Ctrl+M",c.markHeadline),
    ("Mark &Subheads","Alt+S",c.markSubheads),
    ("Mark Changed &Items","Alt+C",c.markChangedHeadlines),
    ("Mark Changed &Roots","Alt+R",c.markChangedRoots),
    ("Mark &Clones","Alt+K",c.markClones),
    ("&Unmark All","Alt+U",c.unmarkAll))
#@nonl
#@-node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
#@+node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
self.outlineMenuGoToMenuTable = (
    ("Go Back",None,c.goPrevVisitedNode), # Usually use buttons for this.
    ("Go Forward",None,c.goNextVisitedNode),
    ("-",None,None),
    ("Go To Next &Marked","Alt+M",c.goToNextMarkedHeadline),
    ("Go To Next C&hanged","Alt+D",c.goToNextDirtyHeadline),
    ("Go To Next &Clone","Alt+N",c.goToNextClone),
    ("-",None,None),
    ("Go To &First Node","Alt+Shift+G",c.goToFirstNode),
    ("Go To &Last Node","Alt+Shift+H",c.goToLastNode),
    ("Go To &Parent","Alt+Shift+P",c.goToParent),
    ("Go To P&rev Sibling","Alt+Shift+R",c.goToPrevSibling),
    ("Go To Next &Sibling","Alt+Shift+S",c.goToNextSibling),
    ("-",None,None),
    ("Go To Prev V&isible","Alt+UpArrow",c.selectVisBack),
    ("Go To Next &Visible","Alt+DnArrow",c.selectVisNext),
    ("Go To Prev Node","Alt+Shift+UpArrow",c.selectThreadBack),
    ("Go To Next Node","Alt+Shift+DnArrow",c.selectThreadNext))
#@nonl
#@-node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
#@-node:ekr.20031218072017.3767:<< define outline menu tables >>
#@+node:ekr.20031218072017.3773:<< define window menu tables >>
self.windowMenuTopTable = (
    ("&Equal Sized Panes","Ctrl+E",f.equalSizedPanes),
    ("Toggle &Active Pane","Ctrl+T",f.toggleActivePane),
    ("Toggle &Split Direction",None,f.toggleSplitDirection),
    ("-",None,None),
    ("Resize To Screen",None,f.resizeToScreen),
    ("Casca&de",None,f.cascade),
    ("&Minimize All",None,f.minimizeAll),
    ("-",None,None),
    ("Open &Compare Window",None,c.openCompareWindow),
    ("Open &Python Window","Alt+P",c.openPythonWindow))
#@nonl
#@-node:ekr.20031218072017.3773:<< define window menu tables >>
#@+node:ekr.20031218072017.3774:<< define help menu tables >>
self.helpMenuTopTable = (
    ("&About Leo...",None,c.about),
    ("Online &Home Page",None,c.leoHome),
    ("Open Online &Tutorial",None,c.leoTutorial),
)
    
self.helpMenuTop2Table = (
    ("Open &Offline Tutorial",None,f.leoHelp),
)
    
self.helpMenuTop3Table = (
    ("-",None,None),
    ("Open Leo&Docs.leo",None,c.leoDocumentation),
    ("Open Leo&Plugins.leo",None,c.leoPlugins),
    ("Open Leo&Settings.leo",None,c.leoConfig),
)
#@nonl
#@-node:ekr.20031218072017.3774:<< define help menu tables >>
#@-node:ekr.20031218072017.3752:defineMenuTables
#@+node:ekr.20031218072017.3781:Gui-independent menu routines
#@+node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
# Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)
    
def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3782:get/setRealMenuName & setRealMenuNamesFromTable
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&'):
        if ch in string.ascii_letters:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20031218072017.2098:canonicalizeShortcut
@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") >= 0     or s.find("command") >= 0 # 11/18/03
    has_ctrl  = s.find("control") >= 0 or s.find("ctrl") >= 0
    has_alt   = s.find("alt") >= 0
    has_shift = s.find("shift") >= 0   or s.find("shft") >= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    << set the last field, preserving case >>
    << canonicalize the last field >>
    << synthesize the shortcuts from the information >>
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut
#@nonl
#@+node:ekr.20031218072017.2102:<< set the last field, preserving case >>
s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) > 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None
#@nonl
#@-node:ekr.20031218072017.2102:<< set the last field, preserving case >>
#@+node:ekr.20031218072017.2099:<< canonicalize the last field >>
bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        << define dict of Tk bind names >>
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) > 0:
    << define dict of special names >>
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]
#@nonl
#@+node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
# These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "<" : "less",
    "=" : "equal",
    ">" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }
#@nonl
#@-node:ekr.20031218072017.2100:<< define dict of Tk bind names >>
#@+node:ekr.20031218072017.2101:<< define dict of special names >>
# These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
#@-node:ekr.20031218072017.2101:<< define dict of special names >>
#@-node:ekr.20031218072017.2099:<< canonicalize the last field >>
#@+node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) > 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "<" + bind_head + bind_last + ">"
menu_shortcut = menu_head + menu_last
#@nonl
#@-node:ekr.20031218072017.2103:<< synthesize the shortcuts from the information >>
#@-node:ekr.20031218072017.2098:canonicalizeShortcut
#@+node:ekr.20031218072017.1723:createMenuEntries
@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    
    c = self.c
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            << set name to the label for doCommand >>
            << set accel to the shortcut for name >>
            << set bind_shortcut and menu_shortcut using accel >>
            << define callback function >>
            << set realLabel, amp_index and menu_shortcut >>
    
            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=callback,underline=amp_index)
                
            if 0: # testing
                dontBind = True

            if bind_shortcut and not dontBind:
                << handle bind_shorcut >>
#@nonl
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
rawKey,accel2 = c.config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
    pass # Use default shortcut, if any.
elif accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
        bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
    callback = self.defineOpenWithMenuCallback(command)
else:
    callback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&")
if amp_index == -1:
    amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@+node:ekr.20031218072017.1729:<< handle bind_shorcut >>
d = self.menuShortcuts
bunch = d.get(bind_shortcut)

if bunch and not g.app.menuWarningsGiven:
    if bunch.init:
        if 0: # Testing only.
            s = 'overriding default shortcut\nnew: %s %s\nold: %s %s' % (
                accel,label,bunch.accel,bunch.label)
            g.es(s,color="red")
            print s
        # Unbind the previous accelerator.
        if menu != bunch.menu or label != bunch.label:
            self.clearAccel(bunch.menu,bunch.label)
    else:
        s = 'duplicate shortcut\nnew: %s %s\nold: %s %s' % (
            accel,label,bunch.accel,bunch.label)
        g.es(s,color="red")
        print s

d[bind_shortcut] = g.Bunch(label=label,accel=accel,init=init,menu=menu)
    
try:
    self.frame.body.bind(bind_shortcut,callback)
    self.bind(bind_shortcut,callback)
except: # could be a user error
    if not g.app.menuWarningsGiven:
        print "exception binding menu shortcut..."
        print bind_shortcut
        g.es_exception()
        g.app.menuWarningsGive = True
#@nonl
#@-node:ekr.20031218072017.1729:<< handle bind_shorcut >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@+node:ekr.20031218072017.3784:createMenuItemsFromTable
def createMenuItemsFromTable (self,menuName,table,openWith=False):
    
    try:
        menu = self.getMenu(menuName)
        if menu == None:
            print "menu does not exist: ",menuName
            g.es("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table,openWith)
    except:
        s = "exception creating items for %s menu" % menuName
        print s ; g.es(s)
        g.es_exception()
        
    g.app.menuWarningsGiven = True
#@nonl
#@-node:ekr.20031218072017.3784:createMenuItemsFromTable
#@+node:ekr.20031218072017.3785:createMenusFromTables
def createMenusFromTables (self):

    c = self.c
    << create the file menu >>
    << create the edit menu >>
    << create the outline menu >>
    g.doHook("create-optional-menus",c=c)
    << create the window menu >>
    << create the help menu >>
#@nonl
#@+node:ekr.20031218072017.3790:<< create the file menu >>
fileMenu = self.createNewMenu("&File")

self.createMenuEntries(fileMenu,self.fileMenuTopTable,init=True)
self.createNewMenu("Open &With...","File")
self.createMenuEntries(fileMenu,self.fileMenuTop2Table,init=True)
<< create the recent files submenu >>
self.add_separator(fileMenu)
<< create the read/write submenu >>
<< create the tangle submenu >>
<< create the untangle submenu >>
<< create the import submenu >>
<< create the export submenu >>
self.add_separator(fileMenu)
self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable,init=True)
#@nonl
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("&Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:<< create the file menu >>
#@+node:ekr.20031218072017.3786:<< create the edit menu >>
editMenu = self.createNewMenu("&Edit")

self.createMenuEntries(editMenu,self.editMenuTopTable,init=True)

<< create the edit body submenu >>
<< create the edit headline submenu >>
<< create the find submenu >>

self.createMenuEntries(editMenu,self.editMenuTop2Table,init=True)
#@nonl
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:<< create the edit menu >>
#@+node:ekr.20031218072017.3797:<< create the outline menu >>
outlineMenu = self.createNewMenu("&Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable,init=True)

<< create check submenu >>
<< create expand/contract submenu >>
<< create move submenu >>
<< create mark submenu >>
<< create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable,init=True)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:<< create the outline menu >>
#@+node:ekr.20031218072017.3802:<< create the window menu >>
windowMenu = self.createNewMenu("&Window")

self.createMenuEntries(windowMenu,self.windowMenuTopTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3802:<< create the window menu >>
#@+node:ekr.20031218072017.3803:<< create the help menu >>
helpMenu = self.createNewMenu("&Help")

self.createMenuEntries(helpMenu,self.helpMenuTopTable,init=True)

if sys.platform=="win32":
    self.createMenuEntries(helpMenu,self.helpMenuTop2Table,init=True)

self.createMenuEntries(helpMenu,self.helpMenuTop3Table,init=True)
#@nonl
#@-node:ekr.20031218072017.3803:<< create the help menu >>
#@-node:ekr.20031218072017.3785:createMenusFromTables
#@+node:ekr.20031218072017.3804:createNewMenu
def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName)
        
        if 0: # 11/13/03: Allow parent to be None.
            if parent == None:
                g.es("unknown parent menu: " + parentName)
                return None

        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&")
            label = label.replace("&","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&")
                index_label = index_label.replace("&","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None
#@nonl
#@-node:ekr.20031218072017.3804:createNewMenu
#@+node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table,init=True)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def callback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=callback,underline=0)
        i += 1
#@nonl
#@-node:ekr.20031218072017.2078:createRecentFilesMenuItems (leoMenu)
#@+node:ekr.20031218072017.3805:deleteMenu
def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu: " + menuName)
    except:
        g.es("exception deleting " + menuName + " menu")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3805:deleteMenu
#@+node:ekr.20031218072017.3806:deleteMenuItem
def deleteMenuItem (self,itemName,menuName="top"):
    
    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found: " + menuName)
    except:
        g.es("exception deleting " + itemName + " from " + menuName + " menu")
        g.es_exception()
#@nonl
#@-node:ekr.20031218072017.3806:deleteMenuItem
#@+node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]
#@nonl
#@-node:ekr.20031218072017.3807:getMenu, setMenu, destroyMenu
#@-node:ekr.20031218072017.3781:Gui-independent menu routines
#@+node:ekr.20041228063406:clearAccel
def clearAccel(self,menu,name):
    
    realName = self.getRealMenuName(name)
    realName = realName.replace("&","")

    menu.entryconfig(realName,accelerator='')
#@nonl
#@-node:ekr.20041228063406:clearAccel
#@-node:ekr.20050102092149:(Fixed problems with Control-E)
#@-node:ekr.20050104122651:Menus
#@+node:ekr.20050104122244.1:Nodes
#@+node:ekr.20040930175654:(Fixed crash after cutting an imported node
#@+node:ekr.20041001075258:Traceback
exception executing command
Traceback (most recent call last):

File "C:\prog\leoCVS\leo\src\leoNodes.py", line 3044, in moveToParent
if p.v._parent and len(p.v._parent.t.vnodeList) == 1:

AttributeError: 'NoneType' object has no attribute '_parent'
#@nonl
#@-node:ekr.20041001075258:Traceback
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p # 10/30/04

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@-node:ekr.20040930175654:(Fixed crash after cutting an imported node
#@+node:ekr.20041215102907:(Removed invalid assert in lastVisible)
# Leo looped after this assert failed.
#@nonl
#@+node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    if 0: # This assert is invalid.
        assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p
#@nonl
#@-node:ekr.20031218072017.4146:p.lastVisible & oldLastVisible
#@-node:ekr.20041215102907:(Removed invalid assert in lastVisible)
#@-node:ekr.20050104122244.1:Nodes
#@+node:ekr.20050104122244.2:Files
#@+node:ekr.20041017044831:(Disabled changes to comment delims in @@language and @@comment sentinels)
#@+node:ekr.20041017050700:This file wasn't being read correctly
@language c

/*@+leo-ver=4*/
/*@+node:@file cat.c*/

/*@@language C*/
#ifdef COMMENT
/*@@comment /* */*/
#endif /* COMMENT */
/*@@path C:\Vlib\Src*/
/*@@tabwidth 4*/
/*@@markup wiki*/


/*@+doc*/
/*
 * Copies STDIN to STDOUT.
 * The basis for all filters.
*/
/*@-doc*/
/*@@code*/
/*@<< Header >>*/
/*@+node:<< Header >>*/

#include <stdio.h>
#include <easy.h>

void filecopy(FILE *fp);
/*@-node:<< Header >>*/
/*@nl*/
/*@<< Main >>*/
/*@+node:<< Main >>*/

void main(int argc, char *argv[])
begin
FILE *fp,
    *fopen();

   if(argc == 1) then
      filecopy(stdin);
   orelse
      while(--argc > 0)
      begin
         if((fp = fopen(*++argv, "r")) == NULL) then
            fprintf( stderr,"cat: can't open %s\n", *argv);
            exit(1);
         orelse
            filecopy(fp);
            fclose(fp);
         endif
      endwhile
   endif
   exit(0);
end
/*@-node:<< Main >>*/
/*@nl*/
/*@<< File Copy >>*/
/*@+node:<< File Copy >>*/

void filecopy(FILE *fp)
begin
int c;
   while( (c = getc(fp)) != EOF)
      putc(c, stdout);
end
/*@-node:<< File Copy >>*/
/*@nl*/
/*@-node:@file cat.c*/
/*@-leo*/
#@-node:ekr.20041017050700:This file wasn't being read correctly
#@+node:ekr.20041017094552:Posting re POSSIBLE fix
@nocolor

I think I have found the problem.   The readDirective method is changing the comment delimiters as the result of seeing the sentinels corresponding to @language or @comment directives.

But in general this makes no sense!  Comment delimiters should be set once and for all in the @+leo sentinel: there is no compiler in the world that tolerates mixed comment delimiters.  BTW, the way to set javascript "inner" comments is to use @delims, not @comment.  N.B.  The @language and @comment delimiters _will_ have an effect, and that effect is in the _write_ logic, not the read logic.  The effect is to set the comment delims in the @+leo sentinel.

The quick fix is to comment out code in readDirective, like this:

@color

if 0: # New in 4.2.1: never change comment delims here...
....if g.match_word(s,i,"@language"):
........<< handle @language >>
....elif g.match_word(s,i,"@comment"):
........<< handle @comment >>

@nocolor

Does anyone have any idea why it may have been useful?

I'm kinda freaked out by this.  The number of file reading and writing options in the various versions of Leo has definitely passed the point at which I can understand them all myself.  Fortunately (I think), the new atFile code has simplified matters.

I just hope that the transition to the new code isn't going to be too painful.  Leo now requires gnx's for all nodes, which is a step in the right direction.  Alas, Leo actually doesn't read thin derived files that were written with gnx's disabled.  My _guess_ is that this has always been a hole in the read logic and that hardly anyone fell into the hole because use_gnx was the default.  The new code plugs this code by making sure all nodes get written with gnx's.

In short, my advice is to comment out the code as shown above and see what happens. This is a _speculative_ fix, although all unit tests pass (so much for unit tests :-)  Please let me know if this "fix" causes problems.  If so, the problems should tell me what, if anything, I was thinking about when I wrote the code above ;-)
#@nonl
#@-node:ekr.20041017094552:Posting re POSSIBLE fix
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041017044831:(Disabled changes to comment delims in @@language and @@comment sentinels)
#@+node:ekr.20041019074759:(Added better messages from g.cantImport)
#@+node:ekr.20041019080519:what I did
@killcolor

- Added g.app.failedPlugins list.
- Added moduleName arg to g.cantImport.
- Removed redundant print from cantImport.
- cantImport only writes one failure message per named plugin.
#@nonl
#@-node:ekr.20041019080519:what I did
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@-node:ekr.20041019074759:(Added better messages from g.cantImport)
#@+node:ekr.20041019085841:(Made sure files that differ only in line ending get written if @lineending is in effect)
#@+node:ekr.20041019085841.1:What I did
@killcolor 

The old code did not honor the @lineending directive if the two files would otherwise be identical.

What I did:

- Added self.explicitLineEnding  to remember whether an explicit @lineending directive is in effect.

- Make sure the user knows why an otherwise identical file was written.

- Changed name of compareFilesIgnoringNewlines to compareFiles.

- Added ignoreLineEndings arg to compareFiles.
#@nonl
#@-node:ekr.20041019085841.1:What I did
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen
#@nonl
#@-node:ekr.20041005105605.197:compareFiles
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@-node:ekr.20041019085841:(Made sure files that differ only in line ending get written if @lineending is in effect)
#@+node:ekr.20041020101401:(Fixed bug:  @nosent writes sentinels!)
#@+node:ekr.20041020101401.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2813280
By: e

@file-nosent has sentinals.

The fix was to add nosentinels=nosentinels in the call to initWriteIvars in atFile.write.

Like this:

at.initWriteIvars(root,at.targetFileName,
    nosentinels=nosentinels,thinFile=thinFile,
    scriptWrite=scriptWrite,toString=toString)
#@-node:ekr.20041020101401.1:Report
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.4:class atFile
class atFile:
    
    << define class constants >>
    << define sentinelDict >>
    
    """The class implementing the atFile subcommander."""

    @others
#@nonl
#@+node:ekr.20041005105605.5:<< define class constants >>
# These constants must be global to this module because they are shared by several classes.

# The kind of at_directives.
noDirective		   =  1 # not an at-directive.
allDirective    =  2 # at-all (4.2)
docDirective	   =  3 # @doc.
atDirective		   =  4 # @<space> or @<newline>
codeDirective	  =  5 # @code
cDirective		    =  6 # @c<space> or @c<newline>
othersDirective	=  7 # at-others
miscDirective	  =  8 # All other directives
rawDirective    =  9 # @raw
endRawDirective = 10 # @end_raw

# The kind of sentinel line.
noSentinel		 = 20 # Not a sentinel
endAt			 = 21 # @-at
endBody			 = 22 # @-body
# not used   = 23
endDoc			 = 24 # @-doc
endLeo			 = 25 # @-leo
endNode			 = 26 # @-node
endOthers		  = 27 # @-others

# not used     = 40
startAt			   = 41 # @+at
startBody		    = 42 # @+body
startDoc		     = 43 # @+doc
startLeo		     = 44 # @+leo
startNode		    = 45 # @+node
startOthers		  = 46 # @+others

startComment   = 60 # @comment
startDelims		  = 61 # @delims
startDirective	= 62 # @@
startRef		     = 63 # @< < ... > >
startVerbatim	 = 64 # @verbatim
startVerbatimAfterRef = 65 # @verbatimAfterRef (3.0 only)

# New in 4.x. Paired
endAll         = 70 # at-all (4.2)
endMiddle      = 71 # at-middle (4.2)
startAll       = 72 # at+all (4.2)
startMiddle    = 73 # at+middle (4.2)

# New in 4.x.  Unpaired.
startAfterRef  = 80 # @afterref (4.0)
startClone     = 81 # @clone (4.2)
startNl        = 82 # @nl (4.0)
startNonl      = 83 # @nonl (4.0)
#@nonl
#@-node:ekr.20041005105605.5:<< define class constants >>
#@+node:ekr.20041005105605.6:<< define sentinelDict >>
sentinelDict = {

    # Unpaired sentinels: 3.x and 4.x.
    "@comment" : startComment,
    "@delims" :  startDelims,
    "@verbatim": startVerbatim,

    # Unpaired sentinels: 3.x only.
    "@verbatimAfterRef": startVerbatimAfterRef,

    # Unpaired sentinels: 4.x only.
    "@afterref" : startAfterRef,
    "@clone"    : startClone,
    "@nl"       : startNl,
    "@nonl"     : startNonl,

    # Paired sentinels: 3.x only.
    "@+body":   startBody,   "@-body":   endBody,

    # Paired sentinels: 3.x and 4.x.
    "@+all":    startAll,    "@-all":    endAll,
    "@+at":     startAt,     "@-at":     endAt,
    "@+doc":    startDoc,    "@-doc":    endDoc,
    "@+leo":    startLeo,    "@-leo":    endLeo,
    "@+middle": startMiddle, "@-middle": endMiddle,
    "@+node":   startNode,   "@-node":   endNode,
    "@+others": startOthers, "@-others": endOthers,
}
#@nonl
#@-node:ekr.20041005105605.6:<< define sentinelDict >>
#@+node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.8:atFile.__init__ & initIvars
def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.

    << define the dispatch dictionary used by scanText4 >>
#@nonl
#@+node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }
#@nonl
#@-node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
#@-node:ekr.20041005105605.8:atFile.__init__ & initIvars
#@+node:ekr.20041005105605.10:initCommonIvars
def initCommonIvars (self):
    
    """Init ivars common to both reading and writing.
    
    The defaults set here may be changed later."""
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    
    c = self.c
    
    if self.testing:
        # Save "permanent" ivars
        fileCommands = self.fileCommands
        dispatch_dict = self.dispatch_dict
        # Clear all ivars.
        g.clearAllIvars(self)
        # Restore permanent ivars
        self.testing = True
        self.c = c
        self.fileCommands = fileCommands
        self.dispatch_dict = dispatch_dict

    << set defaults for arguments and options >>
    << init common ivars >>
#@nonl
#@+node:ekr.20041005105605.11:<< set defaults for arguments and options >>
# These may be changed in initReadIvars or initWriteIvars.

# Support of output_newline option.
self.output_newline = g.getOutputNewline(c=c)

# Set by scanHeader when reading and scanAllDirectives when writing.
self.encoding = c.config.default_derived_file_encoding
self.endSentinelComment = ""
self.startSentinelComment = ""

# Set by scanAllDirectives when writing.
self.default_directory = None
self.page_width = None
self.tab_width  = None
self.startSentinelComment = ""
self.endSentinelComment = ""
self.language = None
#@nonl
#@-node:ekr.20041005105605.11:<< set defaults for arguments and options >>
#@+node:ekr.20041005105605.12:<< init common ivars >>
# These may be set by initReadIvars or initWriteIvars.

self.errors = 0
self.inCode = True
self.indent = 0  # The unit of indentation is spaces, not tabs.
self.pending = []
self.raw = False # True: in @raw mode
self.root = None # The root of tree being read or written.
self.root_seen = False # True: root vnode has been handled in this file.
self.toString = False # True: sring-oriented read or write.
#@nonl
#@-node:ekr.20041005105605.12:<< init common ivars >>
#@-node:ekr.20041005105605.10:initCommonIvars
#@+node:ekr.20041005105605.13:initReadIvars
def initReadIvars(self,root,fileName,
    importFileName=None,
    perfectImportRoot=None,
    thinFile=False):
        
    importing = importFileName is not None

    self.initCommonIvars()
    
    << init ivars for reading >>
    
    self.scanDefaultDirectory(root,importing=importing)
    if self.errors: return

    # Init state from arguments.
    self.perfectImportRoot = perfectImportRoot
    self.importing = importing
    self.root = root
    self.targetFileName = fileName
    self.thinFile = thinFile
#@+node:ekr.20041005105605.14:<< init ivars for reading >>
self.cloneSibCount = 0 # n > 1: Make sure n cloned sibs exists at next @+node sentinel
self.docOut = [] # The doc part being accumulated.
self.done = False # True when @-leo seen.
self.endSentinelStack = []
self.importing = False
self.importRootSeen = False
self.indentStack = []
self.inputFile = None
self.lastLines = [] # The lines after @-leo
self.lastThinNode = None # Used by createThinChild4.
self.leadingWs = ""
self.out = None
self.outStack = []
self.tnodeList = []
self.tnodeListIndex = 0
self.t = None
self.tStack = []
self.thinNodeStack = [] # Used by createThinChild4.
self.updateWarningGiven = False
#@-node:ekr.20041005105605.14:<< init ivars for reading >>
#@-node:ekr.20041005105605.13:initReadIvars
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    << init ivars for writing >>
    
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)
    
    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)
    
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'
    
    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005105605.7:Birth & init
#@+node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.18:Reading (top level)
@

All reading happens in the readOpenFile logic, so plugins should need to
override only this method.
#@nonl
#@+node:ekr.20041005105605.19:openFileForReading
def openFileForReading(self,fileName,fromString=False):
    
    at = self
    
    if fromString:
        at.inputFile = g.fileLikeObject(fromString=fromString)
    else:
        fn = g.os_path_join(at.default_directory,fileName)
        fn = g.os_path_normpath(fn)
        try:
            # Open the file in binary mode to allow 0x1a in bodies & headlines.
            at.inputFile = self.openForRead(fn,'rb') #bwm
            << warn on read-only file >>
        except IOError:
            at.error("can not open: '@file %s'" % (fn))
            at.inputFile = None
#@nonl
#@+node:ekr.20041005105605.20:<< warn on read-only file >>
# os.access() may not exist on all platforms.
try:
    read_only = not os.access(fn,os.W_OK)
except AttributeError:
    read_only = False 
    
if read_only:
    g.es("read only: " + fn,color="red")
#@nonl
#@-node:ekr.20041005105605.20:<< warn on read-only file >>
#@-node:ekr.20041005105605.19:openFileForReading
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):
    
    """Read any derived file."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if not at.thinFile:
        << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@nonl
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@+node:ekr.20041005105605.26:readAll
def readAll(self,root,partialFlag=False):
    
    """Scan vnodes, looking for @file nodes to read."""

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    anyRead = False
    p = root.copy()
    if partialFlag: after = p.nodeAfterTree()
    else: after = c.nullPosition()
    while p and not p.equal(after): # Don't use iterator.
        # g.trace(p.headString())
        if p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        elif p.isAtThinFileNode():
            anyRead = True
            at.read(p,thinFile=True)
            p.moveToNodeAfterTree()
        elif p.isAtFileNode() or p.isAtNorefFileNode():
            anyRead = True
            wasOrphan = p.isOrphan()
            ok = at.read(p)
            if wasOrphan and not partialFlag and not ok:
                # Remind the user to fix the problem.
                p.setDirty()
                c.setChanged(True)
            p.moveToNodeAfterTree()
        else: p.moveToThreadNext()
    # Clear all orphan bits.
    for p in c.allNodes_iter():
        p.v.clearOrphan()
        
    if partialFlag and not anyRead:
        g.es("no @file nodes in the selected tree")
#@nonl
#@-node:ekr.20041005105605.26:readAll
#@+node:ekr.20041005105605.27:readOpenFile
def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    << handle first and last lines >>
#@nonl
#@+node:ekr.20041005105605.28:<< handle first and last lines >>
try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s
#@nonl
#@-node:ekr.20041005105605.28:<< handle first and last lines >>
#@-node:ekr.20041005105605.27:readOpenFile
#@+node:bwmulder.20041231170726:openForRead
def openForRead(self, *args, **kw):
    """
    Hook for the mod_shadow plugin.
    """
    return open(*args, **kw)
#@nonl
#@-node:bwmulder.20041231170726:openForRead
#@+node:bwmulder.20050101094804:openForWrite
def openForWrite(self, *args, **kw):
    """
    Hook for the mod_shadow plugin
    """
    return open(*args, **kw)

#@-node:bwmulder.20050101094804:openForWrite
#@+node:ekr.20050103163224:scanHeaderForThin
def scanHeaderForThin (self,theFile,fileName):
    
    '''Scan the header of a derived file and return True if it is a thin file.
    
    N.B. We are not interested in @first lines, so any encoding will do.'''
    
    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding
    
    junk,junk,isThin = at.scanHeader(theFile,fileName)
    
    return isThin
#@nonl
#@-node:ekr.20050103163224:scanHeaderForThin
#@-node:ekr.20041005105605.18:Reading (top level)
#@+node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.30:createNthChild3
@ Sections appear in the derived file in reference order, not tree order.  Therefore, when we insert the nth child of the parent there is no guarantee that the previous n-1 children have already been inserted. And it won't work just to insert the nth child as the last child if there aren't n-1 previous siblings.  For example, if we insert the third child followed by the second child followed by the first child the second and third children will be out of order.

To ensure that nodes are placed in the correct location we create "dummy" children as needed as placeholders.  In the example above, we would insert two dummy children when inserting the third child.  When inserting the other two children we replace the previously inserted dummy child with the actual children.

vnode child indices are zero-based.  Here we use 1-based indices.

With the "mirroring" scheme it is a structure error if we ever have to create dummy vnodes.  Such structure errors cause a second pass to be made, with an empty root.  This second pass will generate other structure errors, which are ignored.
@c
def createNthChild3(self,n,parent,headline):
    
    """Create the nth child of the parent."""

    at = self
    assert(n > 0)
    
    if at.importing:
        return at.createImportedNode(at.root,headline)

    # Create any needed dummy children.
    dummies = n - parent.numberOfChildren() - 1
    if dummies > 0:
        if 0: # CVS produces to many errors for this to be useful.
            g.es("dummy created")
        at.errors += 1
    while dummies > 0:
        dummies -= 1
        dummy = parent.insertAsLastChild(leoNodes.tnode())
        # The user should never see this headline.
        dummy.initHeadString("Dummy")

    if n <= parent.numberOfChildren():
        << check the headlines >>
    else:
        # This is using a dummy; we should already have bumped errors.
        result = parent.insertAsLastChild(leoNodes.tnode())
    result.initHeadString(headline)
    
    result.setVisited() # Suppress all other errors for this node.
    result.t.setVisited() # Suppress warnings about unvisited nodes.
    return result
#@nonl
#@+node:ekr.20041005105605.31:<< check the headlines >>
# 1/24/03: A kludgy fix to the problem of headlines containing comment delims.

result = parent.nthChild(n-1)
resulthead = result.headString()

if headline.strip() != resulthead.strip():
    start = at.startSentinelComment
    end = at.endSentinelComment
    if end and len(end) > 0:
        # 1/25/03: The kludgy fix.
        # Compare the headlines without the delims.
        h1 =   headline.replace(start,"").replace(end,"")
        h2 = resulthead.replace(start,"").replace(end,"")
        if h1.strip() == h2.strip():
            # 1/25/03: Another kludge: use the headline from the outline, not the derived file.
            headline = resulthead
        else:
            at.errors += 1
    else:
        at.errors += 1
#@-node:ekr.20041005105605.31:<< check the headlines >>
#@-node:ekr.20041005105605.30:createNthChild3
#@+node:ekr.20041005105605.32:handleLinesFollowingSentinel
def handleLinesFollowingSentinel (self,lines,sentinel,comments = True):
    
    """convert lines following a sentinel to a single line"""
    
    at = self
    m = " following" + sentinel + " sentinel"
    start = at.startSentinelComment
    end   = at.endSentinelComment
    
    if len(lines) == 1: # The expected case.
        s = lines[0]
    elif len(lines) == 5:
        at.readError("potential cvs conflict" + m)
        s = lines[1]
        g.es("using " + s)
    else:
        at.readError("unexpected lines" + m)
        g.es(len(lines), " lines" + m)
        s = "bad " + sentinel
        if comments: s = start + ' ' + s

    if comments:
        << remove the comment delims from s >>
        
    # Undo the cweb hack: undouble @ signs if the opening comment delim ends in '@'.
    if start[-1:] == '@':
        s = s.replace('@@','@')

    return s
#@nonl
#@+node:ekr.20041005105605.33:<< remove the comment delims from s >>
# Remove the starting comment and the blank.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.
comment = start + '@ '
if g.match(s,0,comment):
    s = s[len(comment):]
else:
    at.readError("expecting comment" + m)

# Remove the trailing comment.
if len(end) == 0:
    s = string.strip(s[:-1])
else:
    k = s.rfind(end)
    s = string.strip(s[:k]) # works even if k == -1
#@nonl
#@-node:ekr.20041005105605.33:<< remove the comment delims from s >>
#@-node:ekr.20041005105605.32:handleLinesFollowingSentinel
#@+node:ekr.20041005105605.34:readLinesToNextSentinel
# We expect only a single line, and more may exist if cvs detects a conflict.
# We accept the first line even if it looks like a sentinel.
# 5/1/03: The starting comment now looks like a sentinel, to warn users from changing it.

def readLinesToNextSentinel (self,theFile):
    
    """	read lines following multiline sentinels"""
    
    at = self
    lines = []
    start = at.startSentinelComment + '@ '
    nextLine = at.readLine(theFile)
    while nextLine and len(nextLine) > 0:
        if len(lines) == 0:
            lines.append(nextLine)
            nextLine = at.readLine(theFile)
        else:
            # 5/1/03: looser test then calling sentinelKind3.
            s = nextLine ; i = g.skip_ws(s,0)
            if g.match(s,i,start):
                lines.append(nextLine)
                nextLine = at.readLine(theFile)
            else: break

    return nextLine,lines
#@nonl
#@-node:ekr.20041005105605.34:readLinesToNextSentinel
#@+node:ekr.20041005105605.35:scanDoc3
# Scans the doc part and appends the text out.
# s,i point to the present line on entry.

def scanDoc3(self,theFile,s,i,out,kind):
    
    at = self
    endKind = g.choose(kind ==at.startDoc,at.endDoc,at.endAt)
    single = len(at.endSentinelComment) == 0
    << Skip the opening sentinel >>
    << Skip an opening block delim >>
    nextLine = None ; kind = at.noSentinel
    while len(s) > 0:
        << set kind, nextLine >>
        if kind == endKind: break
        << Skip the leading stuff >>
        << Append s to out >>
        if nextLine:
            s = nextLine ; nextLine = None
        else: s = at.readLine(theFile)
    if kind != endKind:
        at.readError("Missing " + at.sentinelName(endKind) + " sentinel")
    << Remove a closing block delim from out >>
#@nonl
#@+node:ekr.20041005105605.36:<< Skip the opening sentinel >>
assert(g.match(s,i,g.choose(kind == at.startDoc, "+doc", "+at")))

out.append(g.choose(kind == at.startDoc, "@doc", "@"))
s = at.readLine(theFile)
#@-node:ekr.20041005105605.36:<< Skip the opening sentinel >>
#@+node:ekr.20041005105605.37:<< Skip an opening block delim >>
if not single:
    j = g.skip_ws(s,0)
    if g.match(s,j,at.startSentinelComment):
        s = at.readLine(theFile)
#@nonl
#@-node:ekr.20041005105605.37:<< Skip an opening block delim >>
#@+node:ekr.20041005105605.38:<< set kind, nextLine >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    j = g.skip_ws(s,0)
    blankLine = s[j] == '\n'
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
    if blankLine and nextKind == endKind:
        kind = endKind # stop the scan now
#@-node:ekr.20041005105605.38:<< set kind, nextLine >>
#@+node:ekr.20041005105605.39:<< Skip the leading stuff >>
# Point i to the start of the real line.

if single: # Skip the opening comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0, at.indent)
#@-node:ekr.20041005105605.39:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.40:<< Append s to out >>
# Append the line with a newline if it is real

line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    out.append(line + '\n')
else:
    # trailing whitespace: the newline is not real.
    out.append(line)
#@-node:ekr.20041005105605.40:<< Append s to out >>
#@+node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
# This code will typically only be executed for HTML files.

if not single:

    delim = at.endSentinelComment
    n = len(delim)
    
    # Remove delim and possible a leading newline.
    s = string.join(out,"")
    s = s.rstrip()
    if s[-n:] == delim:
        s = s[:-n]
    if s[-1] == '\n':
        s = s[:-1]
        
    # Rewrite out in place.
    del out[:]
    out.append(s)
#@-node:ekr.20041005105605.41:<< Remove a closing block delim from out >>
#@-node:ekr.20041005105605.35:scanDoc3
#@+node:ekr.20041005105605.42:scanText3
def scanText3 (self,theFile,p,out,endSentinelKind,nextLine=None):
    
    """Scan a 3.x derived file recursively."""
    
    __pychecker__ = '--maxbranches=100 --maxlines=500'

    at = self
    lastLines = [] # The lines after @-leo
    lineIndent = 0 ; linep = 0 # Changed only for sentinels.
    while 1:
        << put the next line into s >>
        << set kind, nextKind >>
        if kind != at.noSentinel:
            << set lineIndent, linep and leading_ws >>
            i = at.skipSentinelStart3(s,0)
        << handle the line in s >>
    << handle unexpected end of text >>
    assert(len(s)==0 and nextLine==None) # We get here only if readline fails.
    return lastLines # We get here only if there are problems.
#@nonl
#@+node:ekr.20041005105605.43:<< put the next line into s >>
if nextLine:
    s = nextLine ; nextLine = None
else:
    s = at.readLine(theFile)
    if len(s) == 0: break
#@nonl
#@-node:ekr.20041005105605.43:<< put the next line into s >>
#@+node:ekr.20041005105605.44:<< set kind, nextKind >>
@ For non-sentinel lines we look ahead to see whether the next line is a sentinel.  If so, the newline that ends a non-sentinel line belongs to the next sentinel.
@c

assert(nextLine==None)

kind = at.sentinelKind3(s)

if kind == at.noSentinel:
    nextLine = at.readLine(theFile)
    nextKind = at.sentinelKind3(nextLine)
else:
    nextLine = nextKind = None

# nextLine != None only if we have a non-sentinel line.
# Therefore, nextLine == None whenever scanText3 returns.
#@nonl
#@-node:ekr.20041005105605.44:<< set kind, nextKind >>
#@+node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
@ lineIndent is the total indentation on a sentinel line.  The first "self.indent" portion of that must be removed when recreating text.  leading_ws is the remainder of the leading whitespace.  linep points to the first "real" character of a line, the character following the "indent" whitespace.
@c

# Point linep past the first self.indent whitespace characters.
if at.raw: # 10/15/02
    linep =0
else:
    linep = at.skipIndent(s,0,at.indent)

# Set lineIndent to the total indentation on the line.
lineIndent = 0 ; i = 0
while i < len(s):
    if s[i] == '\t': lineIndent += (abs(at.tab_width) - (lineIndent % abs(at.tab_width)))
    elif s[i] == ' ': lineIndent += 1
    else: break
    i += 1
# g.trace("lineIndent,s:",lineIndent,s)

# Set leading_ws to the additional indentation on the line.
leading_ws = s[linep:i]
#@nonl
#@-node:ekr.20041005105605.45:<< Set lineIndent, linep and leading_ws >>
#@+node:ekr.20041005105605.46:<< handle the line in s >>
if kind == at.noSentinel:
    << append non-sentinel line >>
<< handle common sentinels >>
<< handle rare sentinels >>
else:
    << warn about unknown sentinel >>
#@nonl
#@+node:ekr.20041005105605.47:<< append non-sentinel line >>
# We don't output the trailing newline if the next line is a sentinel.
if at.raw: # 10/15/02
    i = 0
else:
    i = at.skipIndent(s,0,at.indent)

assert(nextLine != None)

if nextKind == at.noSentinel:
    line = s[i:]
    out.append(line)
else:
    line = s[i:-1] # don't output the newline
    out.append(line)
#@-node:ekr.20041005105605.47:<< append non-sentinel line >>
#@+node:ekr.20041005105605.48:<< handle common sentinels >>
elif kind in (at.endAt, at.endBody,at.endDoc,at.endLeo,at.endNode,at.endOthers):
        << handle an ending sentinel >>
elif kind == at.startBody:
    << scan @+body >>
elif kind == at.startNode:
    << scan @+node >>
elif kind == at.startRef:
    << scan old ref >>
elif kind == at.startAt:
    << scan @+at >>
elif kind == at.startDoc:
    << scan @+doc >>
elif kind == at.startOthers:
    << scan @+others >>
#@nonl
#@+node:ekr.20041005105605.49:<< handle an ending sentinel >>
# g.trace("end sentinel:", at.sentinelName(kind))

if kind == endSentinelKind:
    if kind == at.endLeo:
        # Ignore everything after @-leo.
        # Such lines were presumably written by @last.
        while 1:
            s = at.readLine(theFile)
            if len(s) == 0: break
            lastLines.append(s) # Capture all trailing lines, even if empty.
    elif kind == at.endBody:
        at.raw = False
    # nextLine != None only if we have a non-sentinel line.
    # Therefore, nextLine == None whenever scanText3 returns.
    assert(nextLine==None)
    return lastLines # End the call to scanText3.
else:
    # Tell of the structure error.
    name = at.sentinelName(kind)
    expect = at.sentinelName(endSentinelKind)
    at.readError("Ignoring " + name + " sentinel.  Expecting " + expect)
#@nonl
#@-node:ekr.20041005105605.49:<< handle an ending sentinel >>
#@+node:ekr.20041005105605.50:<< scan @+body >> 3.x
assert(g.match(s,i,"+body"))

child_out = [] ; child = p.copy() # Do not change out or p!
oldIndent = at.indent ; at.indent = lineIndent
at.scanText3(theFile,child,child_out,at.endBody)

# Set the body, removing cursed newlines.
# This must be done here, not in the @+node logic.
body = string.join(child_out, "")
body = body.replace('\r', '')
body = g.toUnicode(body,g.app.tkEncoding) # 9/28/03

if at.importing:
    child.t.bodyString = body
else:
    child.t.tempBodyString = body

at.indent = oldIndent
#@nonl
#@-node:ekr.20041005105605.50:<< scan @+body >> 3.x
#@+node:ekr.20041005105605.51:<< scan @+node >>
assert(g.match(s,i,"+node:"))
i += 6

childIndex = 0 ; cloneIndex = 0
<< Set childIndex >>
<< Set cloneIndex >>
headline = ""
<< Set headline and ref >>

# print childIndex,headline

if childIndex == 0: # The root node.
    if not at.importing:
        << Check the filename in the sentinel >>
    # Put the text of the root node in the current node.
    at.scanText3(theFile,p,out,at.endNode)
    p.v.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("clone index:",cloneIndex,p)
else:
    # NB: this call to createNthChild3 is the bottleneck!
    child = at.createNthChild3(childIndex,p,headline)
    child.t.setCloneIndex(cloneIndex)
    # if cloneIndex > 0: g.trace("cloneIndex,child:"cloneIndex,child)
    at.scanText3(theFile,child,out,at.endNode)

<< look for sentinels that may follow a reference >>
#@nonl
#@+node:ekr.20041005105605.52:<< Set childIndex >>
i = g.skip_ws(s,i) ; j = i
while i < len(s) and s[i] in string.digits:
    i += 1

if j == i:
    at.readError("Implicit child index in @+node")
    childIndex = 0
else:
    childIndex = int(s[j:i])

if g.match(s,i,':'):
    i += 1 # Skip the ":".
else:
    at.readError("Bad child index in @+node")
#@nonl
#@-node:ekr.20041005105605.52:<< Set childIndex >>
#@+node:ekr.20041005105605.53:<< Set cloneIndex >>
while i < len(s) and s[i] != ':' and not g.is_nl(s,i):
    if g.match(s,i,"C="):
        # set cloneIndex from the C=nnn, field
        i += 2 ; j = i
        while i < len(s) and s[i] in string.digits:
            i += 1
        if j < i:
            cloneIndex = int(s[j:i])
    else: i += 1 # Ignore unknown status bits.

if g.match(s,i,":"):
    i += 1
else:
    at.readError("Bad attribute field in @+node")
#@nonl
#@-node:ekr.20041005105605.53:<< Set cloneIndex >>
#@+node:ekr.20041005105605.54:<< Set headline and ref >>
# Set headline to the rest of the line.
# 6/22/03: don't strip leading whitespace.
if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    # 10/24/02: search from the right, not the left.
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1
    
# 10/23/02: The cweb hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')

# Set reference if it exists.
i = g.skip_ws(s,i)

if 0: # no longer used
    if g.match(s,i,"<<"):
        k = s.find(">>",i)
        if k != -1: ref = s[i:k+2]
#@nonl
#@-node:ekr.20041005105605.54:<< Set headline and ref >>
#@+node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
h = headline.strip()

if h[:5] == "@file":
    i,junk,junk = g.scanAtFileOptions(h)
    fileName = string.strip(h[i:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
elif h[:8] == "@rawfile":
    fileName = string.strip(h[8:])
    if fileName != at.targetFileName:
        at.readError("File name in @node sentinel does not match file's name")
else:
    at.readError("Missing @file in root @node sentinel")
#@-node:ekr.20041005105605.55:<< Check the filename in the sentinel >>
#@+node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
s = at.readLine(theFile)
kind = at.sentinelKind3(s)

if len(s) > 1 and kind == at.startVerbatimAfterRef:
    s = at.readLine(theFile)
    # g.trace("verbatim:",repr(s))
    out.append(s)
elif len(s) > 1 and at.sentinelKind3(s) == at.noSentinel:
    out.append(s)
else:
    nextLine = s # Handle the sentinel or blank line later.

#@-node:ekr.20041005105605.56:<< look for sentinels that may follow a reference >>
#@-node:ekr.20041005105605.51:<< scan @+node >>
#@+node:ekr.20041005105605.57:<< scan old ref >> (3.0)
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

assert(g.match(s,i,"<<"))

if len(at.endSentinelComment) == 0:
    line = s[i:-1] # No trailing newline
else:
    k = s.find(at.endSentinelComment,i)
    line = s[i:k] # No trailing newline, whatever k is.
        
# 10/30/02: undo cweb hack here
start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    line = line.replace('@@','@')

out.append(line)
#@nonl
#@-node:ekr.20041005105605.57:<< scan old ref >> (3.0)
#@+node:ekr.20041005105605.58:<< scan @+at >>
assert(g.match(s,i,"+at"))
at.scanDoc3(theFile,s,i,out,kind)
#@nonl
#@-node:ekr.20041005105605.58:<< scan @+at >>
#@+node:ekr.20041005105605.59:<< scan @+doc >>
assert(g.match(s,i,"+doc"))
at.scanDoc3(theFile,s,i,out,kind)
#@nonl
#@-node:ekr.20041005105605.59:<< scan @+doc >>
#@+node:ekr.20041005105605.60:<< scan @+others >>
assert(g.match(s,i,"+others"))

# Make sure that the generated at-others is properly indented.
out.append(leading_ws + "@others")

at.scanText3(theFile,p,out,at.endOthers)
#@nonl
#@-node:ekr.20041005105605.60:<< scan @+others >>
#@-node:ekr.20041005105605.48:<< handle common sentinels >>
#@+node:ekr.20041005105605.61:<< handle rare sentinels >>
elif kind == at.startComment:
    << scan @comment >>
elif kind == at.startDelims:
    << scan @delims >>
elif kind == at.startDirective:
    << scan @@ >>
elif kind == at.startLeo:
    << scan @+leo >>
elif kind == at.startVerbatim:
    << scan @verbatim >>
#@nonl
#@+node:ekr.20041005105605.62:<< scan @comment >>
assert(g.match(s,i,"comment"))

# We need do nothing more to ignore the comment line!
#@-node:ekr.20041005105605.62:<< scan @comment >>
#@+node:ekr.20041005105605.63:<< scan @delims >>
assert(g.match(s,i-1,"@delims"));

# Skip the keyword and whitespace.
i0 = i-1
i = g.skip_ws(s,i-1+7)
    
# Get the first delim.
j = i
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1

if j < i:
    at.startSentinelComment = s[j:i]
    # print "delim1:", at.startSentinelComment

    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    end = g.choose(j<i,s[j:i],"")
    i2 = g.skip_ws(s,i)
    if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
        at.endSentinelComment = "" # Not really two params.
        line = s[i0:j]
        line = line.rstrip()
        out.append(line+'\n')
    else:
        at.endSentinelComment = end
        # print "delim2:",end
        line = s[i0:i]
        line = line.rstrip()
        out.append(line+'\n')
else:
    at.readError("Bad @delims")
    # Append the bad @delims line to the body text.
    out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.63:<< scan @delims >>
#@+node:ekr.20041005105605.64:<< scan @@ >>
# The first '@' has already been eaten.
assert(g.match(s,i,"@"))

if g.match_word(s,i,"@raw"):
    at.raw = True
elif g.match_word(s,i,"@end_raw"):
    at.raw = False

e = at.endSentinelComment
s2 = s[i:]
if len(e) > 0:
    k = s.rfind(e,i)
    if k != -1:
        s2 = s[i:k] + '\n'
    
start = at.startSentinelComment
if start and len(start) > 0 and start[-1] == '@':
    s2 = s2.replace('@@','@')
out.append(s2)
# g.trace(s2)
#@nonl
#@-node:ekr.20041005105605.64:<< scan @@ >>
#@+node:ekr.20041005105605.65:<< scan @+leo >>
assert(g.match(s,i,"+leo"))
at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.65:<< scan @+leo >>
#@+node:ekr.20041005105605.66:<< scan @verbatim >>
assert(g.match(s,i,"verbatim"))

# Skip the sentinel.
s = at.readLine(theFile) 

# Append the next line to the text.
i = at.skipIndent(s,0,at.indent)
out.append(s[i:])
#@-node:ekr.20041005105605.66:<< scan @verbatim >>
#@-node:ekr.20041005105605.61:<< handle rare sentinels >>
#@+node:ekr.20041005105605.67:<< warn about unknown sentinel >>
j = i
i = g.skip_line(s,i)
line = s[j:i]
at.readError("Unknown sentinel: " + line)
#@nonl
#@-node:ekr.20041005105605.67:<< warn about unknown sentinel >>
#@-node:ekr.20041005105605.46:<< handle the line in s >>
#@+node:ekr.20041005105605.68:<< handle unexpected end of text >>
# Issue the error.
name = at.sentinelName(endSentinelKind)
at.readError("Unexpected end of file. Expecting " + name + "sentinel" )
#@-node:ekr.20041005105605.68:<< handle unexpected end of text >>
#@-node:ekr.20041005105605.42:scanText3
#@+node:ekr.20041005105605.69:sentinelKind3
def sentinelKind3(self,s):

    """This method tells what kind of sentinel appears in line s.
    
    Typically s will be an empty line before the actual sentinel,
    but it is also valid for s to be an actual sentinel line.
    
    Returns (kind, s, emptyFlag), where emptyFlag is True if
    kind == at.noSentinel and s was an empty line on entry."""
    
    at = self
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # 10/30/02: locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        # g.trace("found:",key)
        return at.sentinelDict[key]
    else:
        # g.trace("not found:",key)
        return at.noSentinel
#@nonl
#@-node:ekr.20041005105605.69:sentinelKind3
#@+node:ekr.20041005105605.70:skipSentinelStart3
def skipSentinelStart3(self,s,i):
    
    """Skip the start of a sentinel."""
    
    at = self
    start = at.startSentinelComment
    assert(start and len(start)>0)

    if g.is_nl(s,i): i = g.skip_nl(s,i)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.70:skipSentinelStart3
#@-node:ekr.20041005105605.29:Reading (3.x)
#@+node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.72:createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child
#@nonl
#@-node:ekr.20041005105605.72:createThinChild4
#@+node:ekr.20041005105605.73:findChild4
def findChild4 (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""
    
    __pychecker__ = '--no-argsused' # headline might be used for debugging.
    
    # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
    # tnodeLists compensate (a hack) for not having gnx's in derived files! 

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
#@nonl
#@-node:ekr.20041005105605.73:findChild4
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    << init ivars for scanText4 >>
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@nonl
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine
def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@nonl
#@+node:ekr.20041005105605.78:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

#@-node:ekr.20041005105605.78:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@nonl
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@-node:ekr.20041005105605.77:readNormalLine
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:readStartAll (4.2)
def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)
#@nonl
#@-node:ekr.20041005105605.81:readStartAll (4.2)
#@+node:ekr.20041005105605.82:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@nonl
#@-node:ekr.20041005105605.82:readStartAt & readStartDoc
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.85:readStartNode (4.x)
def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)
#@nonl
#@+node:ekr.20041005105605.86:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@nonl
#@-node:ekr.20041005105605.86:<< set gnx and bump i >>
#@+node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
#@-node:ekr.20041005105605.85:readStartNode (4.x)
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll (4.2)
def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)
#@nonl
#@-node:ekr.20041005105605.91:readEndAll (4.2)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@nonl
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@nonl
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@nonl
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@nonl
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
#@nonl
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val
#@nonl
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j < i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@nonl
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@nonl
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.111:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @<< sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"<<"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20041005105605.111:readRef
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])
#@nonl
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@nonl
#@-node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@+node:ekr.20041005105605.114:sentinelKind4
def sentinelKind4(self,s):
    
    """Return the kind of sentinel at s."""
    
    at = self

    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment): 
        i += len(at.startSentinelComment)
    else:
        return at.noSentinel

    # Locally undo cweb hack here
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s = s[:i] + string.replace(s[i:],'@@','@')
        
    # 4.0: Look ahead for @[ws]@others and @[ws]<<
    if g.match(s,i,"@"):
        j = g.skip_ws(s,i+1)
        if j > i+1:
            # g.trace(ws,s)
            if g.match(s,j,"@+others"):
                return at.startOthers
            elif g.match(s,j,"<<"):
                return at.startRef
            else:
                # No other sentinels allow whitespace following the '@'
                return at.noSentinel

    # Do not skip whitespace here!
    if g.match(s,i,"@<<"): return at.startRef
    if g.match(s,i,"@@"):   return at.startDirective
    if not g.match(s,i,'@'): return at.noSentinel
    j = i # start of lookup
    i += 1 # skip the at sign.
    if g.match(s,i,'+') or g.match(s,i,'-'):
        i += 1
    i = g.skip_c_id(s,i)
    key = s[j:i]
    if len(key) > 0 and at.sentinelDict.has_key(key):
        return at.sentinelDict[key]
    else:
        return at.noSentinel
#@nonl
#@-node:ekr.20041005105605.114:sentinelKind4
#@+node:ekr.20041005105605.115:skipSentinelStart4
def skipSentinelStart4(self,s,i):
    
    """Skip the start of a sentinel."""

    start = self.startSentinelComment
    assert(start and len(start)>0)

    i = g.skip_ws(s,i)
    assert(g.match(s,i,start))
    i += len(start)

    # 7/8/02: Support for REM hack
    i = g.skip_ws(s,i)
    assert(i < len(s) and s[i] == '@')
    return i + 1
#@-node:ekr.20041005105605.115:skipSentinelStart4
#@-node:ekr.20041005105605.71:Reading (4.x)
#@+node:ekr.20041005105605.116:Reading utils...
#@+node:ekr.20041005105605.117:completeFirstDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @first directives
# and appends the corresponding line from 'firstLines' to each @first 
# directive found.  NOTE: the @first directives must be the very first
# lines in 'out'.
def completeFirstDirectives(self,out,firstLines):

    tag = "@first"
    foundAtFirstYet = 0
    outRange = range(len(out))
    j = 0
    for k in outRange:
        # skip leading whitespace lines
        if (not foundAtFirstYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @first directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtFirstYet = 1
        # quit if no leading lines to apply
        if j >= len(firstLines): break
        # make the new @first directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @first directive
        leadingLine = " " + firstLines[j]
        out[k] = tag + leadingLine.rstrip() ; j += 1
#@-node:ekr.20041005105605.117:completeFirstDirectives
#@+node:ekr.20041005105605.118:completeLastDirectives
# 14-SEP-2002 DTHEIN: added for use by atFile.read()

# this function scans the lines in the list 'out' for @last directives
# and appends the corresponding line from 'lastLines' to each @last 
# directive found.  NOTE: the @last directives must be the very last
# lines in 'out'.
def completeLastDirectives(self,out,lastLines):

    tag = "@last"
    foundAtLastYet = 0
    outRange = range(-1,-len(out),-1)
    j = -1
    for k in outRange:
        # skip trailing whitespace lines
        if (not foundAtLastYet) and (len(out[k].strip()) == 0): continue
        # quit if something other than @last directive
        i = 0
        if not g.match(out[k],i,tag): break;
        foundAtLastYet = 1
        # quit if no trailing lines to apply
        if j < -len(lastLines): break
        # make the new @last directive
        #18-SEP-2002 DTHEIN: remove trailing newlines because they are inserted later
        # 21-SEP-2002 DTHEIN: no trailing whitespace on empty @last directive
        trailingLine = " " + lastLines[j]
        out[k] = tag + trailingLine.rstrip() ; j -= 1
#@nonl
#@-node:ekr.20041005105605.118:completeLastDirectives
#@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
def  copyAllTempBodyStringsToTnodes (self,root,thinFile):
    
    c = self.c
    for p in root.self_and_subtree_iter():
        try: s = p.v.t.tempBodyString
        except: s = ""
        old_body = p.bodyString()
        if s != old_body:
            if 0: # For debugging.
                print ; print "changed: " + p.headString()
                print ; print "new:",s
                print ; print "old:",p.bodyString()
            if thinFile:
                p.v.setTnodeText(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                p.setBodyStringOrPane(s) # Sets v and v.c dirty.

            if not thinFile or (thinFile and p.v.isDirty()):
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                g.es("changed: " + p.headString(),color="blue")
                p.setMarked()
#@nonl
#@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
#@+node:ekr.20041005105605.119:createImportedNode
def createImportedNode (self,root,headline):
    
    at = self

    if at.importRootSeen:
        p = root.insertAsLastChild()
        p.initHeadString(headline)
    else:
        # Put the text into the already-existing root node.
        p = root
        at.importRootSeen = True
        
    p.v.t.setVisited() # Suppress warning about unvisited node.
    return p
#@nonl
#@-node:ekr.20041005105605.119:createImportedNode
#@+node:ekr.20041005105605.120:parseLeoSentinel
def parseLeoSentinel (self,s):
    
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    return valid,new_df,start,end,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False
#@nonl
#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@nonl
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j < i:
        pass # version = s[j:i]
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@nonl
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@nonl
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@+node:ekr.20050211111552:test_parseLeoSentinel
def test_parseLeoSentinel (self):
    
    s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
    s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.
    
    at=c.atFileCommands # Self is a dummy argument.
    
    for s in (s1,s2):
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
        # g.trace('start',start,'end',repr(end),'len(s)',len(s))
        assert valid, 'not valid'
        assert new_df, 'not new_df'
        assert isThinDerivedFile, 'not thin'
        assert end == '', 'invalid end: %s' % repr(end)
        assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
#@-node:ekr.20050211111552:test_parseLeoSentinel
#@-node:ekr.20041005105605.120:parseLeoSentinel
#@+node:ekr.20041005105605.127:readError
def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
    
    self.error(message)
    
    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.127:readError
#@+node:ekr.20041005105605.128:readLine
def readLine (self,theFile):
    
    """Reads one line from file using the present encoding"""

    s = g.readlineForceUnixNewline(theFile) # calls theFile.readline
    u = g.toUnicode(s,self.encoding)
    return u


#@-node:ekr.20041005105605.128:readLine
#@+node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
def scanHeader(self,theFile,fileName):
    
    """Scan the @+leo sentinel.
    
    Sets self.encoding, and self.start/endSentinelComment.
    
    Returns (firstLines,new_df) where:
    firstLines contains all @first lines,
    new_df is True if we are reading a new-format derived file."""
    
    at = self
    firstLines = [] # The lines before @+leo.
    tag = "@+leo"
    valid = True ; new_df = False ; isThinDerivedFile = False
    << skip any non @+leo lines >>
    if valid:
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
    if valid:
        at.startSentinelComment = start
        at.endSentinelComment = end
    else:
        at.error("Bad @+leo sentinel in: %s" % fileName)
    # g.trace("start,end",repr(at.startSentinelComment),repr(at.endSentinelComment))
    return firstLines,new_df,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.130:<< skip any non @+leo lines >>
@ Queue up the lines before the @+leo.  These will be used to add as parameters to the @first directives, if any.  Empty lines are ignored (because empty @first directives are ignored). NOTE: the function now returns a list of the lines before @+leo.

We can not call sentinelKind here because that depends on the comment delimiters we set here.  @first lines are written "verbatim", so nothing more needs to be done!
@c

s = at.readLine(theFile)
while len(s) > 0:
    j = s.find(tag)
    if j != -1: break
    firstLines.append(s) # Queue the line
    s = at.readLine(theFile)
    
n = len(s)
valid = n > 0
#@-node:ekr.20041005105605.130:<< skip any non @+leo lines >>
#@-node:ekr.20041005105605.129:scanHeader  (3.x and 4.x)
#@+node:ekr.20041005105605.131:skipIndent
# Skip past whitespace equivalent to width spaces.

def skipIndent(self,s,i,width):

    ws = 0 ; n = len(s)
    while i < n and ws < width:
        if   s[i] == '\t': ws += (abs(self.tab_width) - (ws % abs(self.tab_width)))
        elif s[i] == ' ':  ws += 1
        else: break
        i += 1
    return i
#@nonl
#@-node:ekr.20041005105605.131:skipIndent
#@-node:ekr.20041005105605.116:Reading utils...
#@-node:ekr.20041005105605.17:Reading...
#@+node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.134:Don't override in plugins
# Plugins probably should not need to override these methods.
#@nonl
#@+node:ekr.20041005105605.135:closeWriteFile
# 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self

    if at.outputFile:
        at.outputFile.flush()
        if self.toString:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None
#@nonl
#@-node:ekr.20041005105605.135:closeWriteFile
#@+node:ekr.20041005105605.136:norefWrite
def norefWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atNorefFileNodeName()
        at.initWriteIvars(root,targetFileName,nosentinels=False,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString):
            return
        << write root's tree >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
rawWrite = norefWrite
#@+node:ekr.20041005105605.137:<< write root's tree >>
<< put all @first lines in root >>
at.putOpenLeoSentinel("@+leo-ver=4")
<< put optional @comment sentinel lines >>

for p in root.self_and_subtree_iter():
    << Write p's node >>

at.putSentinel("@-leo")
<< put all @last lines in root >>
#@nonl
#@+node:ekr.20041005105605.138:<< put all @first lines in root >>
@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20041005105605.138:<< put all @first lines in root >>
#@+node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
s2 = c.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)> 0:
            at.putSentinel("@comment " + line)
#@-node:ekr.20041005105605.139:<< put optional @comment sentinel lines >>
#@+node:ekr.20041005105605.140:<< Write p's node >>
at.putOpenNodeSentinel(p)

s = p.bodyString()
if s and len(s) > 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p)
#@nonl
#@-node:ekr.20041005105605.140:<< Write p's node >>
#@+node:ekr.20041005105605.141:<< put all @last lines in root >>
@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j >= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j >= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()
#@nonl
#@-node:ekr.20041005105605.141:<< put all @last lines in root >>
#@-node:ekr.20041005105605.137:<< write root's tree >>
#@-node:ekr.20041005105605.136:norefWrite
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None
    
    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName)

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()
    
    return at.outputFile is not None
#@nonl
#@+node:ekr.20041005105605.143:openFileForWritingHelper
def openFileForWritingHelper (self,fileName):
    
    at = self

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            at.writeError("path does not exist: " + path)
            return
    except:
        at.exception("exception creating path:" + path)
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
#@nonl
#@-node:ekr.20041005105605.143:openFileForWritingHelper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20050506084734:writeFromString (new in 4.3 beta2)
# This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    at.initWriteIvars(root,"<string-file>",
        nosentinels=False,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=False,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput
#@nonl
#@-node:ekr.20050506084734:writeFromString (new in 4.3 beta2)
#@+node:ekr.20041005105605.147:writeAll
def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    << Clear all orphan bits >>
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            << handle v's tree >>
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    << say the command is finished >>
    return mustAutoSave
#@nonl
#@+node:ekr.20041005105605.148:<< Clear all orphan bits >>
@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()
#@nonl
#@-node:ekr.20041005105605.148:<< Clear all orphan bits >>
#@+node:ekr.20041005105605.149:<< handle v's tree >>
if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    at.fileChangedFlag = False
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if at.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True
#@nonl
#@-node:ekr.20041005105605.149:<< handle v's tree >>
#@+node:ekr.20041005105605.150:<< say the command is finished >>
if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) > 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")
#@nonl
#@-node:ekr.20041005105605.150:<< say the command is finished >>
#@-node:ekr.20041005105605.147:writeAll
#@+node:ekr.20041005105605.151:writeMissing
def writeMissing(self,p,toString=False):

    at = self
    writtenFiles = False ; changedFiles = False

    p = p.copy()
    after = p.nodeAfterTree()
    while p and p != after: # Don't use iterator.
        if p.isAtAsisFileNode() or (p.isAnyAtFileNode() and not p.isAtIgnoreNode()):
            at.targetFileName = p.anyAtFileNodeName()
            if at.targetFileName:
                at.targetFileName = g.os_path_join(self.default_directory,at.targetFileName)
                at.targetFileName = g.os_path_normpath(at.targetFileName)
                if not g.os_path_exists(at.targetFileName):
                    at.openFileForWriting(p,at.targetFileName,toString)
                    if at.outputFile:
                        << write the @file node >>
                        at.closeWriteFile()
            p.moveToNodeAfterTree()
        elif p.isAtIgnoreNode():
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
    
    if writtenFiles > 0:
        g.es("finished")
    else:
        g.es("no missing @file node in the selected tree")
        
    return changedFiles # So caller knows whether to do an auto-save.
#@nonl
#@+node:ekr.20041005105605.152:<< write the @file node >>
if p.isAtAsisFileNode():
    at.asisWrite(p)
elif p.isAtNorefFileNode():
    at.norefWrite(p)
elif p.isAtNoSentFileNode():
    at.write(p,nosentinels=True)
elif p.isAtFileNode():
    at.write(p)
else: assert(0)

writtenFiles = True

if at.fileChangedFlag: # Set by replaceTargetFileIfDifferent.
    changedFiles = True
#@nonl
#@-node:ekr.20041005105605.152:<< write the @file node >>
#@-node:ekr.20041005105605.151:writeMissing
#@-node:ekr.20041005105605.134:Don't override in plugins
#@+node:ekr.20041005105605.153:Override in plugins...
@

All writing eventually goes through the asisWrite or writeOpenFile methods, so
plugins should need only to override these two methods.

In particular, plugins should not need to override the write, writeAll or
writeMissing methods.
#@nonl
#@+node:ekr.20041005105605.154:asisWrite
def asisWrite(self,root,toString=False):

    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    try:
        targetFileName = root.atAsisFileNodeName()
        at.initWriteIvars(root,targetFileName,toString=toString)
        if at.errors: return
        if not at.openFileForWriting(root,targetFileName,toString): return
        for p in root.self_and_subtree_iter():
            << Write p's headline if it starts with @@ >>
            << Write p's body >>
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.writeException(root)
        
silentWrite = asisWrite # Compatibility with old scripts.
#@nonl
#@+node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
s = p.headString()

if g.match(s,0,"@@"):
    s = s[2:]
    if s and len(s) > 0:
        s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
        at.outputFile.write(s)
#@nonl
#@-node:ekr.20041005105605.155:<< Write p's headline if it starts with @@ >>
#@+node:ekr.20041005105605.156:<< Write p's body >>
s = p.bodyString()

if s:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
#@nonl
#@-node:ekr.20041005105605.156:<< Write p's body >>
#@-node:ekr.20041005105605.154:asisWrite
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""
    
    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@-node:ekr.20041005105605.157:writeOpenFile
#@-node:ekr.20041005105605.153:Override in plugins...
#@-node:ekr.20041005105605.133:Writing (top level)
#@+node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self
    
    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.166:putAtAllLine
def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.166:putAtAllLine
#@+node:ekr.20041005105605.167:putatAllBody
def putAtAllBody(self,p):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.168:<< Make sure all lines end in a newline >>
#@-node:ekr.20041005105605.167:putatAllBody
#@+node:ekr.20041005105605.169:putAtAllChild
@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p)
#@nonl
#@-node:ekr.20041005105605.169:putAtAllChild
#@-node:ekr.20041005105605.165:@all
#@+node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.171:inAtOthers
def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True
#@nonl
#@-node:ekr.20041005105605.171:inAtOthers
#@+node:ekr.20041005105605.172:putAtOthersChild
def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs > 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p)
#@nonl
#@-node:ekr.20041005105605.172:putAtOthersChild
#@+node:ekr.20041005105605.173:putAtOthersLine
def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.173:putAtOthersLine
#@-node:ekr.20041005105605.170:@others
#@+node:ekr.20041005105605.174:putCodeLine
def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # c.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)
#@nonl
#@-node:ekr.20041005105605.174:putCodeLine
#@+node:ekr.20041005105605.175:putRefLine & allies
#@+node:ekr.20041005105605.176:putRefLine
def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
#@-node:ekr.20041005105605.176:putRefLine
#@+node:ekr.20041005105605.177:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta
#@nonl
#@-node:ekr.20041005105605.177:putRefAt
#@+node:ekr.20041005105605.178:putAfterLastRef
def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j < len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.178:putAfterLastRef
#@+node:ekr.20041005105605.179:putAfterMiddleef
def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start < end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta
#@nonl
#@-node:ekr.20041005105605.179:putAfterMiddleef
#@-node:ekr.20041005105605.175:putRefLine & allies
#@-node:ekr.20041005105605.164:writing code lines...
#@+node:ekr.20041005105605.180:writing doc lines...
#@+node:ekr.20041005105605.181:putBlankDocLine
def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()
#@nonl
#@-node:ekr.20041005105605.181:putBlankDocLine
#@+node:ekr.20041005105605.182:putStartDocLine
def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == at.docDirective,"@+doc","@+at")
    directive = g.choose(kind == at.docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)
#@nonl
#@-node:ekr.20041005105605.182:putStartDocLine
#@+node:ekr.20041005105605.183:putDocLine
def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        << append words to pending line, splitting the line if needed >>
#@+node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i < len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i < len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) >= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)
#@nonl
#@-node:ekr.20041005105605.184:<< append words to pending line, splitting the line if needed >>
#@-node:ekr.20041005105605.183:putDocLine
#@+node:ekr.20041005105605.185:putEndDocLine
def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == at.docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)
#@nonl
#@-node:ekr.20041005105605.185:putEndDocLine
#@+node:ekr.20041005105605.186:putPending
def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()
#@nonl
#@-node:ekr.20041005105605.186:putPending
#@-node:ekr.20041005105605.180:writing doc lines...
#@-node:ekr.20041005105605.160:Writing 4.x
#@+node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.188:nodeSentinelText 4.x
def nodeSentinelText(self,p):
    
    """Return the text of a @+node or @-node sentinel for p."""
    
    at = self ; h = p.headString()
    << remove comment delims from h if necessary >>
    
    if at.thinFile:
        gnx = g.app.nodeIndices.toString(p.v.t.fileIndex)
        return "%s:%s" % (gnx,h)
    else:
        return h
#@nonl
#@+node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
@ Bug fix 1/24/03:

If the present @language/@comment settings do not specify a single-line comment we remove all block comment delims from h.  This prevents headline text from interfering with the parsing of node sentinels.
@c

start = at.startSentinelComment
end = at.endSentinelComment

if end and len(end) > 0:
    h = h.replace(start,"")
    h = h.replace(end,"")
#@nonl
#@-node:ekr.20041005105605.189:<< remove comment delims from h if necessary >>
#@-node:ekr.20041005105605.188:nodeSentinelText 4.x
#@+node:ekr.20041005105605.190:putLeadInSentinel 4.x
def putLeadInSentinel (self,s,i,j,delta):
    
    """Generate @nonl sentinels as needed to ensure a newline before a group of sentinels.
    
    Set at.leadingWs as needed for @+others and @+<< sentinels.

    i points at the start of a line.
    j points at @others or a section reference.
    delta is the change in at.indent that is about to happen and hasn't happened yet."""

    at = self
    at.leadingWs = "" # Set the default.
    if i == j:
        return # The @others or ref starts a line.

    k = g.skip_ws(s,i)
    if j == k:
        # Only whitespace before the @others or ref.
        at.leadingWs = s[i:j] # Remember the leading whitespace, including its spelling.
    else:
        # g.trace("indent",self.indent)
        self.putIndent(self.indent) # 1/29/04: fix bug reported by Dan Winkler.
        at.os(s[i:j]) ; at.onl_sent() # 10/21/03
        at.indent += delta # Align the @nonl with the following line.
        at.putSentinel("@nonl")
        at.indent -= delta # Let the caller set at.indent permanently.
#@nonl
#@-node:ekr.20041005105605.190:putLeadInSentinel 4.x
#@+node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
def putCloseNodeSentinel(self,p,middle=False):
    
    at = self
    
    s = self.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@-middle:" + s)
    else:
        at.putSentinel("@-node:" + s)
#@nonl
#@-node:ekr.20041005105605.191:putCloseNodeSentinel 4.x
#@+node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
def putOpenLeoSentinel(self,s):
    
    """Write @+leo sentinel."""

    at = self
    
    if not at.sentinels:
        return # Handle @nosentinelsfile.
        
    if at.thinFile:
        s = s + "-thin"

    encoding = at.encoding.lower()
    if encoding != "utf-8":
        # New in 4.2: encoding fields end in ",."
        s = s + "-encoding=%s,." % (encoding)
    
    at.putSentinel(s)
#@nonl
#@-node:ekr.20041005105605.192:putOpenLeoSentinel 4.x
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try:
            # Pychecker doesn't like so many references in a row...
            t = at.root.v.t
            t.tnodeList.append(p.v.t)
        except AttributeError:
            pass # Do nothing.  We are creating a script.
#@nonl
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@+node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
# This method outputs all sentinels.

def putSentinel(self,s):

    "Write a sentinel whose text is s, applying the CWEB hack if needed."
    
    at = self

    if not at.sentinels:
        return # Handle @file-nosent

    at.putIndent(at.indent)
    at.os(at.startSentinelComment)
    << apply the cweb hack to s >>
    at.os(s)
    if at.endSentinelComment:
        at.os(at.endSentinelComment)
    at.onl()
#@nonl
#@+node:ekr.20041005105605.195:<< apply the cweb hack to s >>
@ The cweb hack:

If the opening comment delim ends in '@', double all '@' signs except the first, which is "doubled" by the trailing '@' in the opening comment delimiter.
@c

start = at.startSentinelComment
if start and start[-1] == '@':
    assert(s and s[0]=='@')
    s = s.replace('@','@@')[1:]
#@nonl
#@-node:ekr.20041005105605.195:<< apply the cweb hack to s >>
#@-node:ekr.20041005105605.194:putSentinel (applies cweb hack) 4.x
#@-node:ekr.20041005105605.187:Writing 4,x sentinels...
#@+node:ekr.20041005105605.196:Writing 4.x utils...
#@+node:ekr.20041005105605.197:compareFiles
# This routine is needed to handle cvs stupidities.

def compareFiles (self,path1,path2,ignoreLineEndings):

    """Compare two text files ignoring line endings."""
    
    try:
        # Opening both files in text mode converts all line endings to '\n'.
        mode = g.choose(ignoreLineEndings,"r","rb")
        f1 = open(path1,mode)
        f2 = open(path2,mode)
        equal = f1.read() == f2.read()
        f1.close() ; f2.close()
        return equal
    except IOError:
        return False # Should never happen
#@nonl
#@-node:ekr.20041005105605.197:compareFiles
#@+node:ekr.20041005105605.198:directiveKind4
def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 >= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            at.noDirective,at.atDirective)

    # @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1>= n or s[i+1] not in string.ascii_letters):
        return at.noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@nonl
#@-node:ekr.20041005105605.198:directiveKind4
#@+node:ekr.20041005105605.199:hasSectionName
def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("<<",i)
        n2 = s.find(">>",i)
    else:
        n1 = s.find("<<",i,end)
        n2 = s.find(">>",i,end)

    return -1 < n1 < n2, n1, n2
#@nonl
#@-node:ekr.20041005105605.199:hasSectionName
#@+node:ekr.20041005105605.200:isSectionName
# returns (flag, end). end is the index of the character after the section name.

def isSectionName(self,s,i):

    if not g.match(s,i,"<<"):
        return False, -1
    i = g.find_on_line(s,i,">>")
    if i:
        return True, i + 2
    else:
        return False, -1
#@nonl
#@-node:ekr.20041005105605.200:isSectionName
#@+node:ekr.20041005105605.201:os and allies
# Note:  self.outputFile may be either a fileLikeObject or a real file.

#@+node:ekr.20041005105605.202:oblank, oblanks & otabs
def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))
#@nonl
#@-node:ekr.20041005105605.202:oblank, oblanks & otabs
#@+node:ekr.20041005105605.203:onl & onl_sent
def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()
#@nonl
#@-node:ekr.20041005105605.203:onl & onl_sent
#@+node:ekr.20041005105605.204:os
def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    at = self
    
    if s and at.outputFile:
        try:
            s = g.toEncodedString(s,at.encoding,reportErrors=True)
            at.outputFile.write(s)
        except:
            at.exception("exception writing:" + s)
#@nonl
#@-node:ekr.20041005105605.204:os
#@-node:ekr.20041005105605.201:os and allies
#@+node:ekr.20041005105605.205:outputStringWithLineEndings
# Write the string s as-is except that we replace '\n' with the proper line ending.

def outputStringWithLineEndings (self,s):

    # Calling self.onl() runs afoul of queued newlines.
    self.os(s.replace('\n',self.output_newline))
#@nonl
#@-node:ekr.20041005105605.205:outputStringWithLineEndings
#@+node:ekr.20050506090446.1:putAtFirstLines (new in 4.3 b2)
def putAtFirstLines (self,s):
    
    '''Write any @firstlines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines preceding the @+leo sentinel.'''

    at = self ; tag = "@first"

    i = 0
    while g.match(s,i,tag):
        i += len(tag)
        i = g.skip_ws(s,i)
        j = i
        i = g.skip_to_end_of_line(s,i)
        # Write @first line, whether empty or not
        line = s[j:i]
        at.os(line) ; at.onl()
        i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20050506090446.1:putAtFirstLines (new in 4.3 b2)
#@+node:ekr.20050506090955:putAtLastLines (new in 4.3 b2)
def putAtLastLines (self,s):
    
    '''Write any @last lines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines following the @-leo sentinel.'''

    at = self ; tag = "@last"
    
    # Use g.splitLines to preserve trailing newlines.
    lines = g.splitLines(s)
    n = len(lines) ; j = k = n - 1
    
    # Scan backwards for @last directives.
    while j >= 0:
        line = lines[j]
        if g.match(line,0,tag): j -= 1
        elif not line.strip():
            j -= 1
        else: break
        
    # Write the @last lines.
    for line in lines[j+1:k+1]:
        if g.match(line,0,tag):
            i = len(tag) ; i = g.skip_ws(line,i)
            at.os(line[i:])
#@nonl
#@-node:ekr.20050506090955:putAtLastLines (new in 4.3 b2)
#@+node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first & @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i < len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        << handle @delims >>
    elif g.match_word(s,k,"@language"):
        << handle @language >>
    elif g.match_word(s,k,"@comment"):
        << handle @comment >>
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
#@nonl
#@+node:ekr.20041005105605.207:<< handle @delims >>
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j < i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j<i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
#@nonl
#@-node:ekr.20041005105605.207:<< handle @delims >>
#@+node:ekr.20041005105605.208:<< handle @language >>
self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.208:<< handle @language >>
#@+node:ekr.20041005105605.209:<< handle @comment >>
self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.209:<< handle @comment >>
#@-node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
#@+node:ekr.20041005105605.210:putIndent
def putIndent(self,n):
    
    """Put tabs and spaces corresponding to n spaces, assuming that we are at the start of a line."""

    if n != 0:
        w = self.tab_width
        if w > 1:
            q,r = divmod(n,w) 
            self.otabs(q) 
            self.oblanks(r)
        else:
            self.oblanks(n)
#@nonl
#@-node:ekr.20041005105605.210:putIndent
#@+node:ekr.20041005105605.211:putInitialComment
def putInitialComment (self):
    
    c = self.c
    s2 = c.config.output_initial_comment
    if s2:
        lines = string.split(s2,"\\n")
        for line in lines:
            line = line.replace("@date",time.asctime())
            if len(line)> 0:
                self.putSentinel("@comment " + line)
#@nonl
#@-node:ekr.20041005105605.211:putInitialComment
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@+node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
def warnAboutOrphandAndIgnoredNodes (self):
    
    # Always warn, even when language=="cweb"
    at = self ; root = at.root

    for p in root.self_and_subtree_iter():
        if not p.v.t.isVisited(): # Check tnode bit, not vnode bit.
            at.writeError("Orphan node:  " + p.headString())
            if p.isCloned() and p.hasParent():
                g.es("parent node: " + p.parent().headString(),color="blue")
            if not at.thinFile and p.isAtIgnoreNode():
                at.writeError("@ignore node: " + p.headString())
                
    if at.thinFile:
        p = root.copy() ; after = p.nodeAfterTree()
        while p and p != after:
            if p.isAtAllNode():
                p.moveToNodeAfterTree()
            else:
                if p.isAtIgnoreNode():
                    at.writeError("@ignore node: " + p.headString())
                p.moveToThreadNext()
#@nonl
#@-node:ekr.20041005105605.216:warnAboutOrpanAndIgnoredNodes
#@+node:ekr.20041005105605.217:writeError
def writeError(self,message=None):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)

    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.217:writeError
#@+node:ekr.20041005105605.218:writeException
def writeException (self,root=None):
    
    g.es("exception writing:" + self.targetFileName,color="red")
    g.es_exception()

    if self.outputFile:
        self.outputFile.flush()
        self.outputFile.close()
        self.outputFile = None
    
    if self.outputFileName != None:
        try: # Just delete the temp file.
            os.remove(self.outputFileName)
        except:
            g.es("exception deleting:" + self.outputFileName,color="red")
            g.es_exception()

    if root:
        # Make sure we try to rewrite this file.
        root.setOrphan()
        root.setDirty()
#@nonl
#@-node:ekr.20041005105605.218:writeException
#@-node:ekr.20041005105605.196:Writing 4.x utils...
#@-node:ekr.20041005105605.132:Writing...
#@+node:ekr.20041005105605.219:Uilites... (atFile)
#@+node:ekr.20050104131929:file operations...
@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.
#@nonl
#@+node:ekr.20050104131820:chmod
def chmod (self,fileName,mode):
    
    # Do _not_ call self.error here.
    return g.utils_chmod(fileName,mode)
#@nonl
#@-node:ekr.20050104131820:chmod
#@+node:ekr.20050104131929.1:rename & test
<< about os.rename >>

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.
    
    Change the mode of the renamed file if mode is given.
    
    Return True if all went well.'''

    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050104131929.2:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104131929.2:<< about os.rename >>
#@+node:ekr.20050107085710:test_atFile_rename
def test_atFile_rename (self):

    __pychecker__ = '--no-reimport'

    import os
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')
    
    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)
    
    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710:test_atFile_rename
#@-node:ekr.20050104131929.1:rename & test
#@+node:ekr.20050104132018:remove & test
def remove (self,fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050107090156:test_atFile_remove
def test_atFile_remove(self):
    
    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not at.remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert at.remove(path)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107090156:test_atFile_remove
#@-node:ekr.20050104132018:remove & test
#@+node:ekr.20050104132026:stat
def stat (self,fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''
    
    # Do _not_ call self.error here.
    return g.utils_stat(fileName)
#@nonl
#@-node:ekr.20050104132026:stat
#@-node:ekr.20050104131929:file operations...
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20050206085258:atFile.printError & test
def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,g.app.tkEncoding)
            
def test_atFile_printError(self):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: Ᾱ(U+1FB9: Greek Capital Letter Alpha With Macron)")
#@nonl
#@-node:ekr.20050206085258:atFile.printError & test
#@+node:ekr.20041005105605.221:exception
def exception (self,message):
    
    self.error(message)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.221:exception
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.236:scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@nonl
#@+node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")

#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@nonl
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:scanDefaultDirectory
#@+node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
def scanForClonedSibs (self,v):
    
    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()
            
    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex
#@nonl
#@-node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
#@+node:ekr.20041005105605.243:sentinelName
# Returns the name of the sentinel for warnings.

def sentinelName(self, kind):
    
    at = self

    sentinelNameDict = {
        at.noSentinel:    "<no sentinel>",
        at.startAt:       "@+at",     at.endAt:     "@-at",
        at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
        at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
        at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
        at.startNode:     "@+node",   at.endNode:   "@-node",
        at.startOthers:   "@+others", at.endOthers: "@-others",
        at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
        at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@<<",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

    return sentinelNameDict.get(kind,"<unknown sentinel!>")
#@nonl
#@-node:ekr.20041005105605.243:sentinelName
#@-node:ekr.20041005105605.219:Uilites... (atFile)
#@-node:ekr.20041005105605.4:class atFile
#@-node:ekr.20041020101401:(Fixed bug:  @nosent writes sentinels!)
#@+node:ekr.20041021064354:(Fixed bug in replaceTargetFileIfDifferent)
#@+node:ekr.20041021072759:What I did
@killcolor

This method should do noting if at.toString is True.
#@nonl
#@-node:ekr.20041021072759:What I did
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@-node:ekr.20041021064354:(Fixed bug in replaceTargetFileIfDifferent)
#@+node:ekr.20041021072818:(Made sure that @ignore forces writing of inner @thin trees)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    # Must check all parents.
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>
    
    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20041021072818:(Made sure that @ignore forces writing of inner @thin trees)
#@+node:ekr.20041231083430:(Fixed crasher with invalid path)
Directory "c:\test" does not exist
exception writing:C:\prog\leoCVS\leo\test
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2756, in write
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3020, in writeOpenFile
    at.putOpenLeoSentinel("@+leo-ver=4")
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 3752, in putOpenLeoSentinel
    if not at.sentinels:
AttributeError: atFile instance has no attribute 'sentinels'
saved: test.leo
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    << init ivars for writing >>
    
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)
    
    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)
    
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'
    
    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041231083430:(Fixed crasher with invalid path)
#@+node:ekr.20041231102453.4:(Fixed double doc part bug)
#@+node:ekr.20041231102453.5:Notes
@killcolor

There is a bug in how Leo writes adjacent @doc parts in @file trees.  This is the first serious bug in the atFile read/write logic reported in several years. As I write this I realize I don't know whether the @thin logic is affected as well.  I suspect it may be.

The bug happens if any node in an @file tree contains adjacent @doc parts, like this:

@  first doc part
...
@ second doc part
...

Leo fails to write the closing #@-at sentinel that would finish the first @doc part.  (Another fix would be not to write the second #@+at sentinel.)  As a result of this bug, Leo fails to read the @file node properly and 'reverts' to the version of the code found in the .leo file.
#@nonl
#@-node:ekr.20041231102453.5:Notes
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self
    
    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@-node:ekr.20041231102453.4:(Fixed double doc part bug)
#@+node:ekr.20050101100920:(Fixed deprecation warning when saving .leo files)
@nocolor

c:\python24\lib\pickle.py:202: DeprecationWarning:
    The 'bin' argument to Pickler() is deprecated

@color
#@nonl
#@+node:ekr.20050101133638:@url http://docs.python.org/lib/module-pickle.html
#@-node:ekr.20050101133638:@url http://docs.python.org/lib/module-pickle.html
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        val = attrDict[key]
        self.putUa(torv,key,val)
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@+node:EKR.20040526204036.1:getUa (changed for 4.3)
def getUa(self,nodeType):
    
    """Parse an unknown attribute in a <v> or <t> element."""
    
    __pychecker__ = '--no-argsused' # nodeType not used: good for debugging.
    
    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    if not attr:
        return None,None
        
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return attr,val
        
    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass
        
    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        # g.trace('4.1 val:',val2)
        return attr,val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return attr,val2
    except (pickle.UnpicklingError,ImportError):
        return attr,val
#@nonl
#@-node:EKR.20040526204036.1:getUa (changed for 4.3)
#@-node:ekr.20050101100920:(Fixed deprecation warning when saving .leo files)
#@+node:ekr.20050112100144:(Fixed bug in how Leo writes thin derived files)
# The fix was simply to reverse the order in which putRefAt puts +middle and -middle sentinels.
#@nonl
#@+node:ekr.20050112100144.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2936140
By: nobody

I have recently stumbled two or three times upon an error,
that causes leo to write  @thin files, that cannont be
untangled (I hope its correct to use this term here) later on.
The resulting Problem is really serious, since opening
the leo file in a new session causes leo immediately to hang.
The only way to recover the leo file I found, was to modify
the appropriate leo sentinels in the broken derived file.

Description:

create a file (must be @thin not @file),
which references a section, that is two levels
below the current level.
f.e.
<< current level>>
  reference to << 3. level>>
    << 1.level>>
        << 2.level >>
            << 3.level>>

Leo does not complain while saving.

Close leo. Opening leo now causes leo to hang while untangling the above
generated @thin file.

To make the file readable the *middle* sentinels surrounding the reference must
be removed.
#@nonl
#@-node:ekr.20050112100144.1:Report
#@+node:ekr.20041005105605.177:putRefAt
def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        at.writeError(
            "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        # Bug fix: reverse the +middle sentinels, not the -middle sentinels.
        inBetween.reverse()
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta
#@nonl
#@-node:ekr.20041005105605.177:putRefAt
#@-node:ekr.20050112100144:(Fixed bug in how Leo writes thin derived files)
#@-node:ekr.20050104122244.2:Files
#@+node:ekr.20050104122244.3:Script bugs
#@+node:ekr.20041007081134.2:(Fixed unbounded recursion with --script)
#@+node:ekr.20041007081134.3:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2792616
By: e

The recursion was happening in nullLog put & write.

EKR:  The problem is that nullLog.write calls print, and if print is redirected we end up calling nullLog.write again.

sys.stdout.write() doesn't work any better than print
but inside g.app.log.disable/enable doesn't error.

redirect_execute_script_output_to_log_pane = 1
is not good in batch mode!

should that should be always zeroed in batch mode?
set to 0 and both sys.stdout.write and print works.
no recursion.
#@-node:ekr.20041007081134.3:Report
#@+node:ekr.20041012082437.6:What I did
@killcolor

- g.redirectClass.redirect does nothing if g.app.batchMode is True.
- added g.rawPrint.
- Changed self.old.write(s) to self.old.write(s+'\n') throughout.
#@nonl
#@-node:ekr.20041012082437.6:What I did
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout
class redirectClass:
    
    """A class to redirect stdout and stderr."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@nonl
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):
    
    self.old = None
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@nonl
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return 

#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@nonl
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@nonl
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@nonl
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@nonl
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@nonl
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@nonl
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@nonl
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@nonl
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@nonl
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout
#@+node:ekr.20031218072017.3695:leoLog.__init__
def __init__ (self,frame,parentFrame):
    
    self.frame = frame
    self.c = frame.c
    self.enabled = True
    self.newlines = 0
    self.isNull = False

    # Note: self.logCtrl is None for nullLog's.
    self.logCtrl = self.createControl(parentFrame)
    self.setFontFromConfig()
    self.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.3695:leoLog.__init__
#@+node:ekr.20031218072017.2232:class nullLog
class nullLog (leoLog):
    
    __pychecker__ = '--no-argsused' # null classes have many unused args.
    
    @others
#@nonl
#@+node:ekr.20041012083237:nullLog.__init__
def __init__ (self,frame=None,parentFrame=None):
        
    # Init the base class.
    leoLog.__init__(self,frame,parentFrame)
    self.isNull = True
#@nonl
#@-node:ekr.20041012083237:nullLog.__init__
#@+node:ekr.20041012083237.1:createControl
def createControl (self,parentFrame):
    
    return None
#@nonl
#@-node:ekr.20041012083237.1:createControl
#@+node:ekr.20041012083237.2:oops
def oops(self):

    g.trace("nullLog:", g.callerName(2))
    
#@-node:ekr.20041012083237.2:oops
#@+node:ekr.20041012083237.3:put and putnl (nullLog)
def put (self,s,color=None):
    if self.enabled:
        # g.trace('nullLog',s)
        g.rawPrint(s)

def putnl (self):
    if self.enabled:
        g.rawPrint("")
#@nonl
#@-node:ekr.20041012083237.3:put and putnl (nullLog)
#@+node:ekr.20041012083237.4:setColorFromConfig & setFontFromConfig
def setFontFromConfig (self):
    pass
    
def setColorFromConfig (self):
    pass
#@nonl
#@-node:ekr.20041012083237.4:setColorFromConfig & setFontFromConfig
#@-node:ekr.20031218072017.2232:class nullLog
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    __pychecker__ = '--no-argsused' # null classes have many unused args.
    
    @others
#@nonl
#@+node:ekr.20040327105706: ctor
def __init__ (self,title,gui,useNullUndoer=False):

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer
    
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
#@nonl
#@-node:ekr.20040327105706: ctor
#@+node:ekr.20041130065921:deiconfy, lift, update
def deiconify (self):
    pass
    
def lift (self):
    pass
    
def update (self):
    pass
#@nonl
#@-node:ekr.20041130065921:deiconfy, lift, update
#@+node:ekr.20041120073824:destroySelf
def destroySelf (self):
    
    pass
#@nonl
#@-node:ekr.20041120073824:destroySelf
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

    self.c = c

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)
#@nonl
#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20041130065718:get_window_info
def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y
#@nonl
#@-node:ekr.20041130065718:get_window_info
#@+node:ekr.20041130065921.1:lift
#@-node:ekr.20041130065921.1:lift
#@+node:ekr.20040327105706.3:oops
def oops(self):
    
    g.trace("nullFrame:", g.callerName(2))
#@nonl
#@-node:ekr.20040327105706.3:oops
#@+node:ekr.20041130090749:setInitialWindowGeometry
def setInitialWindowGeometry (self):
    pass
#@nonl
#@-node:ekr.20041130090749:setInitialWindowGeometry
#@+node:ekr.20041130065718.1:setTopGeometry
def setTopGeometry (self,w,h,x,y,adjustSize=True):
    
    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y
#@nonl
#@-node:ekr.20041130065718.1:setTopGeometry
#@-node:ekr.20031218072017.2222:class nullFrame
#@-node:ekr.20041007081134.2:(Fixed unbounded recursion with --script)
#@+node:ekr.20041013101851:(Use entire script when executing script buttons)
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@-node:ekr.20041013101851:(Use entire script when executing script buttons)
#@+node:ekr.20041004094706:(Fixed error reporting in executeScript when the error happens outside the script)
@

The old code assumed that the error is always in the script itself.  Not true!  The error could happen in methods called by the script.

This code works with Python 2.3.4: it may be version dependent.
#@nonl
#@+node:ekr.20041007080346:Report from e
@killcolor
https://sourceforge.net/forum/message.php?msg_id=2792394

I've narrowed down when the IndexError happens,
probably any similar error would be the same.

import leoGlobals as g
c = g.top() 
p = c.currentPosition()
cv = c.currentVnode()
cv.moveOutlineRight()  #error

gives this error
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------

and this  additional traceback from 
leoCommands.py", line 1171, in executeScript
    s = "line %d: %s" % (n,lines[n-1])
IndexError: list index out of range

when run this script inside a def wrapper,

import leoGlobals as g
def x():
....c = g.top() 
....p = c.currentPosition()
....cv = c.currentVnode()  #insert sets the current node
....cv.moveOutlineRight()  #error
x()

all you get is
unknown position attribute: moveOutlineRight
exception executing script
AttributeError
--------------------
so it appears the frame in the code that determines the 
line number n is off at least one.
in neither case is the line number of the error correct, so no error line
shows.

maybe getLastTracebackLineNumber needs to check for ValueError?
there is still a piece missing, how to tell what frame your in.

in #@+node: getLastTracebackLineNumber leoGlobals.py
data = traceback.extract_tb(tb, 2) seems like a good idea
and seems to fix the IndexError error shown above.
but now with error inside a def you get the function name
instead of the line the error is on. not good enough.

change to:
data = traceback.extract_tb(tb)
item = data[-2] or data[-1] 

this seems to work w/ error code indented 0 from far left, 
or nested inside a def inside another def or another,
I'll leave it in and see if there are additional problems.
the line number still doesn't match with row,col display.
thats confusing if you don't account for the sentinals.
maybe the line number minus a simple count of sentinal lines?

#@-node:ekr.20041007080346:Report from e
#@+node:ekr.20041007080346.1:Report 2 from e
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2792620

not a trivial simple count after all.
if the error is inside a node then would need to 
start count from the previous +node sentinal.
I didn't attempt to fix that,

lets see if the line number is always right first.

item = data[-2] or data[-1]

isn't fixing all cases.

this works better:

item = data[-1]
if not item[-1] is None:
    item = data[-2]
#@-node:ekr.20041007080346.1:Report 2 from e
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20040731204831:getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        # g.trace(data)
        item = data[-1]
        filename = item[0]
        n = item[1]
        return filename,n
#@nonl
#@-node:ekr.20040731204831:getLastTracebackFileAndLineNumber
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@nonl
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@nonl
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@-node:ekr.20041004094706:(Fixed error reporting in executeScript when the error happens outside the script)
#@-node:ekr.20050104122244.3:Script bugs
#@+node:ekr.20050104122244.4:Startup
#@+node:ekr.20040917063309:(Fixed bug re non-existent filename on command line)
#@+node:ekr.20040929100426:Report
@killcolor

When I start leo from the command line (linux) with e.g.

[davides@icarus utilities]$ leodev test.leo

(leodev is an alias to the latest cvs version)

and "test.leo" does not exist, the Log pane says

File not found: /localstore/computer/davides/SW/test/utilities/test.leo

but then I would expect that the current file name were set to "test.leo", so that when I do a save, "test.leo" gets saved. It is set to "untitled" instead, so that in essence in this case Leo ignores my command line argument. I would also change the log message to say something like "New file" or similar. Cf. what happens when you do e.g. "vi newfile.txt" (or "emacs", or even "edit" in ms-dos).

Davide 
#@nonl
#@-node:ekr.20040929100426:Report
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@-node:ekr.20040917063309:(Fixed bug re non-existent filename on command line)
#@+node:ekr.20041228060059:(Better handling of duplicate menu shortcuts)
@nocolor

The code now clears previous shortcut, and tells what the previous entry was.

What I did:
    - Added init keyword param to createMenuEntries.
    - All calls to createMenuEntries from createMenusFromTables set init = True.
    - Changed << handle bind_shorcut >> in createMenuEntries:
        - Changed menuShortcuts to a dict containing g.Bunch items.
    - Added clearAccel methods to leoMenu and leoTkinterMenu classes.

@color
#@nonl
#@+node:ekr.20041228063406:clearAccel
def clearAccel(self,menu,name):
    
    realName = self.getRealMenuName(name)
    realName = realName.replace("&","")

    menu.entryconfig(realName,accelerator='')
#@nonl
#@-node:ekr.20041228063406:clearAccel
#@+node:ekr.20031218072017.1723:createMenuEntries
@ The old, non-user-configurable code bound shortcuts in createMenuBar.  The new user-configurable code binds shortcuts here.

Centralized tables of shortscuts no longer exist as they did in createAccelerators.  To check for duplicates, (possibly arising from leoConfig.txt) we add entries to a central dictionary here, and report duplicates if an entry for a canonicalized shortcut already exists.
@c

def createMenuEntries (self,menu,table,openWith=False,dontBind=False,init=False):
    
    c = self.c
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            << set name to the label for doCommand >>
            << set accel to the shortcut for name >>
            << set bind_shortcut and menu_shortcut using accel >>
            << define callback function >>
            << set realLabel, amp_index and menu_shortcut >>
    
            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=callback,underline=amp_index)
                
            if 0: # testing
                dontBind = True

            if bind_shortcut and not dontBind:
                << handle bind_shorcut >>
#@nonl
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
rawKey,accel2 = c.config.getShortcut(name)

# 7/19/03: Make sure "None" overrides the default shortcut.
if accel2 == None or len(accel2) == 0:
    pass # Use default shortcut, if any.
elif accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
        bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
    callback = self.defineOpenWithMenuCallback(command)
else:
    callback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&")
if amp_index == -1:
    amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@+node:ekr.20031218072017.1729:<< handle bind_shorcut >>
d = self.menuShortcuts
bunch = d.get(bind_shortcut)

if bunch and not g.app.menuWarningsGiven:
    if bunch.init:
        if 0: # Testing only.
            s = 'overriding default shortcut\nnew: %s %s\nold: %s %s' % (
                accel,label,bunch.accel,bunch.label)
            g.es(s,color="red")
            print s
        # Unbind the previous accelerator.
        if menu != bunch.menu or label != bunch.label:
            self.clearAccel(bunch.menu,bunch.label)
    else:
        s = 'duplicate shortcut\nnew: %s %s\nold: %s %s' % (
            accel,label,bunch.accel,bunch.label)
        g.es(s,color="red")
        print s

d[bind_shortcut] = g.Bunch(label=label,accel=accel,init=init,menu=menu)
    
try:
    self.frame.body.bind(bind_shortcut,callback)
    self.bind(bind_shortcut,callback)
except: # could be a user error
    if not g.app.menuWarningsGiven:
        print "exception binding menu shortcut..."
        print bind_shortcut
        g.es_exception()
        g.app.menuWarningsGive = True
#@nonl
#@-node:ekr.20031218072017.1729:<< handle bind_shorcut >>
#@-node:ekr.20031218072017.1723:createMenuEntries
#@-node:ekr.20041228060059:(Better handling of duplicate menu shortcuts)
#@+node:ekr.20050117111810:(Fixed configuration bug)
#@+node:ekr.20050119061300:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2943715
By: nobody

Traceback (most recent call last):
  File "/usr/local/src/leoCVS42/src/leo.py", line 418, in ?
    run()
  File "/usr/local/src/leoCVS42/src/leo.py", line 139, in run
    c,frame = createFrame(fileName)
  File "/usr/local/src/leoCVS42/src/leo.py", line 315, in createFrame
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
  File "/usr/local/src/leoCVS42/src/leoGui.py", line 126, in
newLeoCommanderAndFrame
    c = leoCommands.Commands(frame,fileName)
  File "/usr/local/src/leoCVS42/src/leoCommands.py", line 59, in __init__
    c.importCommands = leoImport.leoImportCommands(c)
  File "/usr/local/src/leoCVS42/src/leoImport.py", line 34, in __init__
    self.output_newline = g.getOutputNewline()
  File "/usr/local/src/leoCVS42/src/leoGlobals.py", line 275,
in getOutputNewline
    s = s.lower()
AttributeError: 'NoneType' object has no attribute 'lower'
#@nonl
#@-node:ekr.20050119061300:Report
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@-node:ekr.20050117111810:(Fixed configuration bug)
#@+node:ekr.20050121075634:(Investigated Control-Q binding)
@nocolor

- It works for me in 4.3.

- fixed crasher:  shortcut entry was not in dispatchDict.

http://sourceforge.net/forum/message.php?msg_id=2944234
By: nobody

I am unable to remap the CTRL+Q keyboard shortcut. It seems to be hardwired
to File > Exit. My attempts to override it have failed.
#@nonl
#@-node:ekr.20050121075634:(Investigated Control-Q binding)
#@-node:ekr.20050104122244.4:Startup
#@+node:ekr.20050123190323:(Simplified and improved shift-click scrolling code)
#@+node:ekr.20050123190323.1:Notes
@killcolor

My attention was brought to this code because pychecker rigthly complained about global vars.

- replaced global way with scrollWay ivar.  This keeps pychecker happy.

- Replaced lambda's with trivial functions.
    - The old code was absurdly and needlessly confusing.

- Disabled code in scrollUpOrDown that returned if find_overlapping was True.
    - The scrolling code works much better without it.
#@nonl
#@-node:ekr.20050123190323.1:Notes
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20050123190323:(Simplified and improved shift-click scrolling code)
#@-node:ekr.20041228052527:Bug fixes...
#@+node:ekr.20041228052527.1:Cleanup...
#@+node:ekr.20040917080403.1:(Cleaned up code in runOpenFileDialog)
@

Replace the try/except code with

    if multiple and g.CheckVersion(sys.version,"2.3") and g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4"):
#@nonl
#@+node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
# We no longer specify default extensions so that we can open and save files without extensions.

def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    if multiple:
        # askopenfilenames requires Pythone 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(title=title,filetypes=filetypes)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(title=title,filetypes=filetypes)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(title=title, filetypes=filetypes)

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
#@nonl
#@-node:ekr.20031218072017.4057:app.gui.Tkinter file dialogs
#@-node:ekr.20040917080403.1:(Cleaned up code in runOpenFileDialog)
#@+node:ekr.20040720073339:Removed use_gnx
#@-node:ekr.20040720073339:Removed use_gnx
#@+node:ekr.20040929102351:Removed write_old_format_derived_files
This implies:
    
- Deprecating old-style file formats.
- Removing commands that write old-style formats.
#@nonl
#@+node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles (no longer used)
def writeOldDerivedFiles (self,toString=False):
    
    self.writeDerivedFiles(write_old=True,toString=toString)

def writeNewDerivedFiles (self,toString=False):

    self.writeDerivedFiles(write_old=False,toString=toString)
    
def writeDerivedFiles (self,write_old,toString=False):
    
    config = g.app.config
    old = config.write_old_format_derived_files
    config.write_old_format_derived_files = write_old
    self.writeAll(writeAtFileNodesFlag=True,toString=toString)
    config.write_old_format_derived_files = old
#@nonl
#@-node:ekr.20031218072017.2642:top_df.writeOld/NewDerivedFiles (no longer used)
#@+node:ekr.20031218072017.2014:writeNew/OldDerivedFiles (no longer used)
def writeNewDerivedFiles (self):
    
    c = self
    autoSave = c.atFileCommands.writeNewDerivedFiles()
    if autoSave:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to preserve tnodeList.
    
def writeOldDerivedFiles (self):
    
    c = self
    c.atFileCommands.writeOldDerivedFiles()
    g.es("auto-saving outline",color="blue")
    c.save() # Must be done to clear tnodeList.
#@nonl
#@-node:ekr.20031218072017.2014:writeNew/OldDerivedFiles (no longer used)
#@-node:ekr.20040929102351:Removed write_old_format_derived_files
#@+node:ekr.20041005110502:(Converted to new leoAtFile code)
#@+node:ekr.20041005112818.2:What I did
@killcolor

- Made sense of initialization:
    - ctor inits only permanent ivars.
    - All initing for reads and writes happens explicitly.
    - Separate initiing for reads and writes.
    - All non-permanent ivars deleted before all reads and writes (when testing).

- Move all constants into class.  No more module-level constants.

- All code is now in a single class.
    - This is _so_ much clearer than before.
    - There were only a few name conflicts:  resolved by renaming x to x3 or x4.

- Use methods rather than sections where possible.

- Removed unused oneNodeOnly args, except for putBody method.

- Tested reading 3.x files.  This passes simple tests.  I doubt if anyone actually using these old files....

- Added fromString arg to g.fileLikeObject ctor.

- Not much new is needed to support read/write from string.
    - Official methods that plugins can override:
        read, asisWrite, writeOpenFile
#@nonl
#@-node:ekr.20041005112818.2:What I did
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    << init ivars for writing >>
    
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)
    
    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)
    
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'
    
    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@-node:ekr.20041005110502:(Converted to new leoAtFile code)
#@+node:ekr.20041019111455:(Improved and repacked pretty printing)
#@+node:ekr.20041019125831:Notes
@killcolor

- (to do) doc parts are reformatted improperly.

    - This is going to be even trickier when Python allows '@' characters.
    - The present code make no attempt to discover @doc parts;
      it simply preserves whitespace after @ signs!

- (fixed) doc strings were messed up.

    - The bug was improperly use a as a synonym for self.array.
#@nonl
#@-node:ekr.20041019125831:Notes
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = [] # List of strings comprising the line being accumulated.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.line = 0 # Same as self.srow
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False

    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine
def doMultiLine (self):
    
    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine
#@+node:ekr.20041021101911.5:doName
def doName(self):

    self.array.append("%s " % self.val)
    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.
    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):
    
    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20041019111455:(Improved and repacked pretty printing)
#@+node:ekr.20041214073833.1:(Removed g.os_path_norm and g.os_path_normabs)
@ 

Save As & Save To are broken with new .leo files

c.mFileName was '.'  That should never happen.

I recently added code that set

c.mFileName = g.os_path_norm(fileName) in the ctor, but this converts an empty name to '.' (!!)

I removed g.os_path_norm and g.os_path_normabs.  These caused more problems than they solved.
#@+node:ekr.20041216060139:Traceback
exception creating backup file: ..bak
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoFileCommands.py", line 2015, in write_Leo_file
    g.utils_rename(fileName,backupName)
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1604, in utils_rename
    os.rename(src,dst)
OSError: [Errno 13] Permission denied

--------------

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 154, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 626, in saveTo
    defaultextension=".leo")
  File "C:\prog\leoCVS\leo\src\leoTkinterGui.py", line 228, in runSaveFileDialog
    filetypes=filetypes)
  File "c:\python23\lib\lib-tk\tkFileDialog.py", line 131, in asksaveasfilename
    return SaveAs(**options).show()
  File "c:\python23\lib\lib-tk\tkCommonDialog.py", line 52, in show
    s = w.tk.call(self.command, *w._options(self.options))
TclError: invalid filename "."
#@-node:ekr.20041216060139:Traceback
#@-node:ekr.20041214073833.1:(Removed g.os_path_norm and g.os_path_normabs)
#@+node:ekr.20040701152235:(Fixed shawdow warnings)
@killcolor

The following are all Python global functions:

(done) cmp -> compare
(done) dict -> theDict
(done) dir -> theDir
(done) file -> theFile
(done) id -> theId
(done) type -> theType
(done) input  (suppressed the warning)
(done) iter -> theIter
#@nonl
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20040701152235.2:leoApp (done)
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:209: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:224: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:368: (dir) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoApp.py:401: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.2:leoApp (done)
#@+node:ekr.20040701152235.3:leoPlugins (done)
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:40: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:53: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:67: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:72: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoPlugins.py:74: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.3:leoPlugins (done)
#@+node:ekr.20040701152235.4:leoColor (done)
(fixed) C:\prog\leoCVS\leo\src\leoColor.py:1948: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoColor.py:2059: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.4:leoColor (done)
#@+node:ekr.20040701152235.5:leoNodes (done)
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:578: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1372: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1394: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1411: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1412: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1419: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1443: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoNodes.py:1446: (id) shadows builtin
#@nonl
#@-node:ekr.20040701152235.5:leoNodes (done)
#@+node:ekr.20040701152235.6:leoCompare (done)
(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:44: (cmp) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:397: (cmp) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCompare.py:468: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.6:leoCompare (done)
#@+node:ekr.20040701152235.8:leoFind (done)
(fixed) c:\prog\leoCVS\leo\src\leoFind.py:864: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.8:leoFind (done)
#@+node:ekr.20040701152235.9:leoMenu (done)
(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:656: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoMenu.py:700: (dict) shadows builtin
#@nonl
#@-node:ekr.20040701152235.9:leoMenu (done)
#@+node:ekr.20040701152235.10:leoTkinterTree (done)
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:949: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:162: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:167: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:586: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:639: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:783: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:844: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:911: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1390: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1588: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:1590: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:883: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterTree.py:893: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.10:leoTkinterTree (done)
#@+node:ekr.20040701152235.11:leoTkinterFrame (done)
(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:807: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:566: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1233: (file) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoFrame.py:522: (type) shadows builtin
#@-node:ekr.20040701152235.11:leoTkinterFrame (done)
#@+node:ekr.20040701152235.12:leoTkinterPrefs (done)
(fixed) c:\prog\leoCVS\leo\src\leoTkinterPrefs.py:295: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.12:leoTkinterPrefs (done)
#@+node:ekr.20040701152235.13:leoTkinterGui (done)
(fixed) c:\prog\leoCVS\leo\src\leoTkinterGui.py:78: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.13:leoTkinterGui (done)
#@+node:ekr.20040701152235.14:leoAtFile (done)
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:336: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:490: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2157: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:473: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:549: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:551: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2142: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2278: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoAtFile.py:2280: (dir) shadows builtin
#@-node:ekr.20040701152235.14:leoAtFile (done)
#@+node:ekr.20040701152235.15:leoFileCommands (done)
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:90: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:866: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1191: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1318: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1756: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:990: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:2018: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1228: (dir) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoFileCommands.py:1269: (dir) shadows builtin
#@nonl
#@-node:ekr.20040701152235.15:leoFileCommands (done)
#@+node:ekr.20040701152235.16:leoImport (done)
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2792: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:52: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:273: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2348: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2371: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2398: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2426: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2476: (file) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:473: (type) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1626: (id) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:1648: (id) shadows builtin
(fixed) :\prog\leoCVS\leo\src\leoImport.py:1650: (id) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2303: (type) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoImport.py:2727: (type) shadows builtin

#@-node:ekr.20040701152235.16:leoImport (done)
#@+node:ekr.20040701152235.17:leoTangle (done)
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:718: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:911: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:924: (dict) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3563: (dict) shadows builtin

c:\prog\leoCVS\leo\src\leoTangle.py:540: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:541: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:666: (dict) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3656: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3667: (dir) shadows builtin
c:\prog\leoCVS\leo\src\leoTangle.py:3780: (dir) shadows builtin

(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:2038: (type) shadows builtin
(fixed) c:\prog\leoCVS\leo\src\leoTangle.py:3865: (type) shadows builtin
#@nonl
#@-node:ekr.20040701152235.17:leoTangle (done)
#@+node:ekr.20040701152235.18:leoCommands (done)
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:324: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:340: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:346: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:468: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:480: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1677: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1721: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1770: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1800: (dict) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:2280: (dict) shadows builtin

(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:465: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:495: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:734: (file) shadows builtin
(fixed) C:\prog\leoCVS\leo\src\leoCommands.py:1238: (file) shadows builtin
#@nonl
#@-node:ekr.20040701152235.18:leoCommands (done)
#@-node:ekr.20040701152235:(Fixed shawdow warnings)
#@+node:ekr.20050101093544:(Always use os.rename in utils_rename)
#@+node:ekr.20050104110100:Notes
@killcolor

Apparently distutils.file_util is not present in all Python distributions!

New approaches:
    - Fall back on code in distutils.file_util if import fails.
    - Make sure the src and dst volumes are the same (so Linux os.rename will always work)
    - Simplify replaceTargetFileIfDifferent by creating new routines.

What I did:
    - Rewrote replaceTargetFileIfDifferent in terms of atFile.rename, atFile.remove, etc.
    - Rewrote update_file_if_changed in terms of g.utils_rename, g.utils_remove, etc.
#@nonl
#@-node:ekr.20050104110100:Notes
#@+node:ekr.20050104135720:Used by tangle code & leoFileCommands
#@+node:ekr.20031218072017.1241:g.update_file_if_changed
# This is part of the tangle code.

def update_file_if_changed(file_name,temp_name):

    """Compares two files.
    
    If they are different, we replace file_name with temp_name.
    Otherwise, we just delete temp_name. Both files should be closed."""

    if g.os_path_exists(file_name):
        if filecmp.cmp(temp_name, file_name):
            kind = 'unchanged'
            ok = g.utils_remove(temp_name)
        else:
            kind = '***updating'
            mode = g.utils_stat(file_name)
            ok = g.utils_rename(temp_name,file_name,mode)
    else:
        kind = 'creating'
        ok = g.utils_rename(temp_name,file_name)
        
    if ok:
        g.es('%12s: %s' % (kind,file_name))
    else:
        g.es("rename failed: no file created!",color="red")
        g.es(file_name," may be read-only or in use")
#@nonl
#@-node:ekr.20031218072017.1241:g.update_file_if_changed
#@+node:ekr.20050104123726.3:g.utils_remove & test
def utils_remove (fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            g.es("exception removing:" + fileName)
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050107084901:test_g_utils_remove
def test_g_utils_remove():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@-node:ekr.20050107084901:test_g_utils_remove
#@-node:ekr.20050104123726.3:g.utils_remove & test
#@+node:ekr.20031218072017.1263:g.utils_rename & test
<< about os.rename >>

def utils_rename(src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''
    
    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
        
    try:
        if 1: # Use rename in all cases.
            os.rename(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True
        else:
            # This isn't a great solution: distutils.file_util may not exist.
            if sys.platform=="win32":
                os.rename(src,dst)
            else:
                from distutils.file_util import move_file
                move_file(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True

    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False
#@nonl
#@+node:ekr.20050104123726.1:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104123726.1:<< about os.rename >>
#@+node:ekr.20050107085710.1:test_g_utils_rename
def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710.1:test_g_utils_rename
#@-node:ekr.20031218072017.1263:g.utils_rename & test
#@+node:ekr.20050104124903:g.utils_chmod
def utils_chmod (fileName,mode,verbose=True):
    
    if mode is None:
        return

    try:
        os.chmod(fileName,mode)
    except:
        if verbose:
            g.es("exception in os.chmod(%s)" % (fileName))
            g.es_exception()
#@nonl
#@-node:ekr.20050104124903:g.utils_chmod
#@+node:ekr.20050104123726.4:g.utils_stat
def utils_stat (fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''

    try:
        mode = (os.stat(fileName))[0] & 0777
    except:
        mode = None
        
    return mode
#@nonl
#@-node:ekr.20050104123726.4:g.utils_stat
#@-node:ekr.20050104135720:Used by tangle code & leoFileCommands
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        theActualFile = None
        << create backup file >>
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        << put the .leo file >>
        theActualFile.write(self.outputFile.getvalue())
        theActualFile.close()
        self.outputFile = None
        << delete backup file >>
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        << delete fileName >>
        << rename backupName to fileName >>
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
#@nonl
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@nonl
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20041005105605.212:replaceTargetFileIfDifferent
def replaceTargetFileIfDifferent (self):
    
    '''Create target file as follows:
    1. If target file does not exist, rename output file to target file.
    2. If target file is identical to output file, remove the output file.
    3. If target file is different from output file,
       remove target file, then rename output file to be target file.'''
    
    assert(self.outputFile is None)
    
    self.fileChangedFlag = False
    
    if self.toString: return self.fileChangedFlag

    if g.os_path_exists(self.targetFileName):
        if (
            << files are identical >>
        ):
            self.remove(self.outputFileName)
            g.es('%-10s %s' % ('unchanged:',self.shortFileName))
            return False
        else:
            << report if the files differ only in line endings >>
            mode = self.stat(self.targetFileName)
            ok = self.rename(self.outputFileName,self.targetFileName,mode)
            if ok:
                g.es('%-10s %s' % ('writing:',self.shortFileName))
                self.fileChangedFlag = True
            return True # bwm
    else:
        # Rename the output file.
        ok = self.rename(self.outputFileName,self.targetFileName)
        if ok:
            g.es('%-10s %s' % ('creating:',self.targetFileName))
            self.fileChangedFlag = True
        return False
#@nonl
#@+node:ekr.20050104131343:<< files are identical >>
self.compareFiles(
    self.outputFileName,
    self.targetFileName,
    not self.explicitLineEnding)
#@nonl
#@-node:ekr.20050104131343:<< files are identical >>
#@+node:ekr.20041019090322:<< report if the files differ only in line endings >>
if (
    self.explicitLineEnding and
    self.compareFiles(
        self.outputFileName,
        self.targetFileName,
        ignoreLineEndings=True)):

    g.es("correcting line endings in: " + self.targetFileName,color="blue")
#@nonl
#@-node:ekr.20041019090322:<< report if the files differ only in line endings >>
#@-node:ekr.20041005105605.212:replaceTargetFileIfDifferent
#@+node:ekr.20041005105605.217:writeError
def writeError(self,message=None):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)

    self.root.setOrphan()
    self.root.setDirty()
#@nonl
#@-node:ekr.20041005105605.217:writeError
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20041005105605.219:Uilites... (atFile)
#@+node:ekr.20050104131929:file operations...
@ The difference, if any, between these methods and the corresponding g.utils_x
functions is that these methods may call self.error.
#@nonl
#@+node:ekr.20050104131820:chmod
def chmod (self,fileName,mode):
    
    # Do _not_ call self.error here.
    return g.utils_chmod(fileName,mode)
#@nonl
#@-node:ekr.20050104131820:chmod
#@+node:ekr.20050104131929.1:rename & test
<< about os.rename >>

def rename (self,src,dst,mode=None,verbose=True):

    '''remove dst if it exists, then rename src to dst.
    
    Change the mode of the renamed file if mode is given.
    
    Return True if all went well.'''

    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not self.remove(dst,verbose=verbose):
            return False

    try:
        os.rename(src,dst)
        if mode != None:
            self.chmod(dst,mode)
        return True
    except Exception:
        if verbose:
            self.error("exception renaming: %s to: %s" % (
                self.outputFileName,self.targetFileName))
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050104131929.2:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104131929.2:<< about os.rename >>
#@+node:ekr.20050107085710:test_atFile_rename
def test_atFile_rename (self):

    __pychecker__ = '--no-reimport'

    import os
    at = c.atFileCommands

    exists = g.os_path_exists
    path = g.os_path_join(g.app.testDir,'xyzzy')
    path2 = g.os_path_join(g.app.testDir,'xyzzy2')
    
    # Create both paths.
    for p in (path,path2):
        if exists(p):
            os.remove(p)
        assert not exists(p)
        f = file(p,'w')
        f.write('test %s' % p)
        f.close()
        assert exists(p)
    
    assert at.rename(path,path2,verbose=True)
    assert exists(path2)
    f = file(path2)
    s = f.read()
    f.close()
    # print 'Contents of %s: %s' % (path2,s)
    assert s == 'test %s' % path
    os.remove(path2)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710:test_atFile_rename
#@-node:ekr.20050104131929.1:rename & test
#@+node:ekr.20050104132018:remove & test
def remove (self,fileName,verbose=True):

    try:
        os.remove(fileName)
        return True
    except:
        if verbose:
            self.error("exception removing: %s" % fileName)
            g.es_exception()
        return False
#@nonl
#@+node:ekr.20050107090156:test_atFile_remove
def test_atFile_remove(self):
    
    __pychecker__ = '--no-reimport'
    import os
    at = c.atFileCommands
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not at.remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert at.remove(path)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107090156:test_atFile_remove
#@-node:ekr.20050104132018:remove & test
#@+node:ekr.20050104132026:stat
def stat (self,fileName):

    '''Return the access mode of named file, removing any setuid, setgid, and sticky bits.'''
    
    # Do _not_ call self.error here.
    return g.utils_stat(fileName)
#@nonl
#@-node:ekr.20050104132026:stat
#@-node:ekr.20050104131929:file operations...
#@+node:ekr.20041005105605.220:atFile.error
def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1
#@-node:ekr.20041005105605.220:atFile.error
#@+node:ekr.20050206085258:atFile.printError & test
def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,g.app.tkEncoding)
            
def test_atFile_printError(self):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: Ᾱ(U+1FB9: Greek Capital Letter Alpha With Macron)")
#@nonl
#@-node:ekr.20050206085258:atFile.printError & test
#@+node:ekr.20041005105605.221:exception
def exception (self,message):
    
    self.error(message)
    g.es_exception()
#@nonl
#@-node:ekr.20041005105605.221:exception
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20041005105605.236:scanDefaultDirectory
def scanDefaultDirectory(self,p,importing=False):
    
    """Set default_directory ivar by looking for @path directives."""

    at = self ; c = at.c
    at.default_directory = None
    << Set path from @file node >>
    if at.default_directory:
        return
        
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        if theDict.has_key("path"):
            << handle @path >>
            return

    << Set current directory >>
    if not at.default_directory and not importing:
        # This should never happen: c.openDirectory should be a good last resort.
        g.trace()
        at.error("No absolute directory specified anywhere.")
        at.default_directory = ""
#@nonl
#@+node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04
    
theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        at.default_directory = theDir
    else:
        at.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not at.default_directory:
            at.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.237:<< Set path from @file node >>  in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
# We set the current director to a path so future writes will go to that directory.

k = theDict["path"]
<< compute relative path from s[k:] >>

if path and len(path) > 0:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    path = g.os_path_join(base,path)
    
    if g.os_path_isabs(path):
        << handle absolute path >>
    else:
        at.error("ignoring bad @path: %s" % path)
else:
    at.error("ignoring empty @path")

#@+node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = path.strip()
#@nonl
#@-node:ekr.20041005105605.239:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.240:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    at.default_directory = path
else:
    at.default_directory = g.makeAllNonExistentDirectories(path)
    if not at.default_directory:
        at.error("invalid @path: %s" % path)
#@nonl
#@-node:ekr.20041005105605.240:<< handle absolute path >>
#@-node:ekr.20041005105605.238:<< handle @path >> in df.scanDeafaultDirectory in leoAtFile.py
#@+node:ekr.20041005105605.241:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

assert(not at.default_directory)

if c.frame :
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    at.default_directory = theDir ; break
                else:
                    at.default_directory = g.makeAllNonExistentDirectories(theDir)
#@-node:ekr.20041005105605.241:<< Set current directory >>
#@-node:ekr.20041005105605.236:scanDefaultDirectory
#@+node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
def scanForClonedSibs (self,v):
    
    """Scan the siblings of vnode v looking for clones of v.
    Return the number of cloned sibs and n where p is the n'th cloned sibling."""

    clonedSibs = 0 # The number of cloned siblings of p, including p.
    thisClonedSibIndex = 0 # Position of p in list of cloned siblings.

    if v and v.isCloned():
        sib = v
        while sib.back():
            sib = sib.back()
        while sib:
            if sib.t == v.t:
                clonedSibs += 1
                if sib == v:
                    thisClonedSibIndex = clonedSibs
            sib = sib.next()
            
    # g.trace(clonedSibs,thisClonedSibIndex)

    return clonedSibs,thisClonedSibIndex
#@nonl
#@-node:ekr.20041005105605.242:scanForClonedSibs (reading & writing)
#@+node:ekr.20041005105605.243:sentinelName
# Returns the name of the sentinel for warnings.

def sentinelName(self, kind):
    
    at = self

    sentinelNameDict = {
        at.noSentinel:    "<no sentinel>",
        at.startAt:       "@+at",     at.endAt:     "@-at",
        at.startBody:     "@+body",   at.endBody:   "@-body", # 3.x only.
        at.startDoc:      "@+doc",    at.endDoc:    "@-doc",
        at.startLeo:      "@+leo",    at.endLeo:    "@-leo",
        at.startNode:     "@+node",   at.endNode:   "@-node",
        at.startOthers:   "@+others", at.endOthers: "@-others",
        at.startAll:      "@+all",    at.endAll:    "@-all", # 4.x
        at.startMiddle:   "@+middle", at.endMiddle: "@-middle", # 4.x
        at.startAfterRef: "@afterref", # 4.x
        at.startComment:  "@comment",
        at.startDelims:   "@delims",
        at.startDirective:"@@",
        at.startNl:       "@nl",   # 4.x
        at.startNonl:     "@nonl", # 4.x
        at.startClone:    "@clone", # 4.2
        at.startRef:      "@<<",
        at.startVerbatim: "@verbatim",
        at.startVerbatimAfterRef: "@verbatimAfterRef" } # 3.x only.

    return sentinelNameDict.get(kind,"<unknown sentinel!>")
#@nonl
#@-node:ekr.20041005105605.243:sentinelName
#@-node:ekr.20041005105605.219:Uilites... (atFile)
#@-node:ekr.20050101093544:(Always use os.rename in utils_rename)
#@+node:ekr.20050123162958:(Fixed Pychecker warnings)
#@+node:ekr.20050123192629:Real bugs in leoConfig.py
@killcolor

C:\prog\leoCVS\leo\src\leoConfig.py:691: No global (encodingName) found

changed encodingName to ivar.
#@nonl
#@-node:ekr.20050123192629:Real bugs in leoConfig.py
#@+node:ekr.20050123184116:Warnings
@killcolor

(wrong warning)
    C:\prog\leoCVS\leo\src\leoCommands.py:33: Imported module (token) not used

(not a real problem: cant be suppressed)
    C:\prog\leoCVS\leo\src\leo.py:210: No module attribute (leo_config_directory) found

C:\prog\leoCVS\leo\src\leoTkinterFrame.py:320: No class attribute (yview) found
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:321: No class attribute (yview) found
#@-node:ekr.20050123184116:Warnings
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@-node:ekr.20050123162958:(Fixed Pychecker warnings)
#@-node:ekr.20041228052527.1:Cleanup...
#@+node:ekr.20041115111203:Config...
# 2004
#@nonl
#@+node:ekr.20041124094427.1: What I did
@nocolor

- leo.py:
    - Create nodeIndices early in starup logic.
    - Set g.app.config early in startup logic.
    
- leoCommands.py:
    - Added class configSettings to hold per-commander settings.

- leoFileCommands.py
    - putFindSettings and putPrefs write empty xml elements.
    - getFindPanelSettings and getPrefs ignore whatever settings they see.

@color
#@nonl
#@-node:ekr.20041124094427.1: What I did
#@+node:ekr.20041228053248:Diary
#@+node:ekr.20041118130101:11/17 Prepared for new code
@killcolor

- Disabled ill-fated Apply Settings command.
- Removed call to config.update from leoFileCommands.write code.
- Write only vestigial <find settings/>
- Write only vestigial <preferences/>
    - Will store prefs in @settings trees.
*** NO changes to the read code.  This ensures compatibility.
- Created computeHomeDir, computeGlobalConfig and startupEncoding in leo.py.
- Set g.app.homeDir and g.app.globalConfigDir in leo.py.
- Generalized g.app.setLeoID()
- Called g.app.setLeoID() _before_ loading plugins.
#@nonl
#@-node:ekr.20041118130101:11/17 Prepared for new code
#@+node:ekr.20041118130101.1:11/18 Modified core for new code
@nocolor

- Create configSettings class in leoCommands.py.

This is needed because the old g.app.ivars won't work with per-file settings.  So now each commander has its own settings.

    - c.config now points to a configSettings instance for each commander.
    - The configSettings class has convenience methods to get and set settings.

- Removed config.update.  One reference still exists.

The code accesses config ivar x via c.config.x

- Removed all section-specific getters from Leo's core and leoPlugins.leo.

- Changed g.app.config to c.config in these plugins: FileActions.py, word_export.py, rst.py, rst2.py

- Remove all references to configExists and configExists itself.

- Removed most references to g.app.config.x:  The main remaining refs are:
    g.app.config.use_plugins
#@nonl
#@+node:ekr.20041118135701:Removed old spellings of config getters
getBoolColorsPref = getBool
getBoolComparePref = getBool
getBoolFindPref = getBool
getBoolPref = getBool
getBoolWindowPref = getBool

getIntComparePref = getInt
getIntPref = getInt
getIntWindowPref = getInt

getFloatWindowPref = getFloat

getStringColorsPref = getString
getStringComparePref = getString
getStringFindPref = getString
getStringPref = getString
getStringWindowPref = getString

# Generic prefs are strings too.
getColorsPref = getString
getComparePref = getString
getFindPref = getString
getPref = getString
getWindowPref = getString
#@nonl
#@-node:ekr.20041118135701:Removed old spellings of config getters
#@-node:ekr.20041118130101.1:11/18 Modified core for new code
#@+node:ekr.20041120134118:11/19 Wrote first draft of new code
#@-node:ekr.20041120134118:11/19 Wrote first draft of new code
#@+node:ekr.20041120072947:11/20 Connected the new code
#@+node:ekr.20041120160454:Added gui param to fram
Not sure this did anything.  However, using g.app.gui in the code should be replaced by c.frame.gui.
#@nonl
#@-node:ekr.20041120160454:Added gui param to fram
#@+node:ekr.20041120160454.1:Added destroySelf method to nullFram
This allows g.app.destroyWindow to work on nullFrame's.
#@nonl
#@-node:ekr.20041120160454.1:Added destroySelf method to nullFram
#@+node:ekr.20041120160454.2:Changed g.app.config.use_psyco to g.app.use_psyco
use_psyco can no longer be a config param:  it is used too early in the load process.
#@nonl
#@-node:ekr.20041120160454.2:Changed g.app.config.use_psyco to g.app.use_psyco
#@+node:ekr.20041120160454.3:created g.app.nodeIndices before initing config class
This is needed because loading .leo files requires g.app.leoID.

To make this work, I had to create an emergency "startup" gui in setLeoID. This in turn creates g.app.root, so I also changed
createNullGuiWithScript so it only creates the Tk root if it doesn't already exist.

Clearly, using g.app.gui is wrong.
#@nonl
#@-node:ekr.20041120160454.3:created g.app.nodeIndices before initing config class
#@+node:ekr.20041120160454.4:Removed use_psycho option
#@-node:ekr.20041120160454.4:Removed use_psycho option
#@+node:ekr.20041120160454.5:Removed config_encoding ivar
#@-node:ekr.20041120160454.5:Removed config_encoding ivar
#@-node:ekr.20041120072947:11/20 Connected the new code
#@+node:ekr.20041121125616.1:11/21 Multiple find panels
@killcolor

- Implemented @if-gui
- Implemented @ratio.
- Fixed bug:  getBool was returning True for both True and False ;-)

- Removed g.app.globalWindows.
- Removed destroyAllGlobalWindows()
- Destroy find panel in frame.destroySelf.
#@nonl
#@-node:ekr.20041121125616.1:11/21 Multiple find panels
#@+node:ekr.20041124094427:11/24 Improved how names get munged
@killcolor

canonicalizeSettingsName (munge) delete whitespace, underscores and '-' in settings names.

dictionary keys are munged names.
#@nonl
#@-node:ekr.20041124094427:11/24 Improved how names get munged
#@+node:ekr.20041211051934:(11/17 to 11/4)
#@+node:ekr.20041122153342:(Translating types)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="<unknown>"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""
    
    __pychecker__ = '--no-argsused' # tag used for debugging.

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@nonl
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@-node:ekr.20041122153342:(Translating types)
#@+node:ekr.20041122180237:(Suppressed over-ride message when loading a leoSettings.leo file)
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20041122180237:(Suppressed over-ride message when loading a leoSettings.leo file)
#@+node:ekr.20041123095026:(Syntax checker ignores @settings nodes)
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.headString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@-node:ekr.20041123095026:(Syntax checker ignores @settings nodes)
#@+node:ekr.20041123074733:(Update recent files in local .leo file when opening another file)
#@+node:ekr.20041123075848:What I did
@killcolor

- Added updateRecentFiles keyword option to newLeoCommanderAndFrame.
    Default is True, but set to false when opening leoSettings.leo files on startup.
    Note: this will be False, then True when opening leoSettings.leo explicitly.

- Removed g.app.config.setRecentFiles.
    All work done in c.config.setRecentFiles.
    moved recentFiles ivar to configParser class.

- Moved call to c.config.setRecentFiles from c.updateRecentFiles to g.openWithFileName.

- settingsRoot, canonicalizeSettingName and findSettingsPosition now defined only in config class.
    These are always accessed via g.app.config.
    These seems better than defining functions in leoGlobals.py
#@nonl
#@-node:ekr.20041123075848:What I did
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    gui = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
    
    frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@nonl
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    __pychecker__ = '--no-argsused' # p not used.
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@-node:ekr.20041123074733:(Update recent files in local .leo file when opening another file)
#@+node:ekr.20041124081632:(Problems overriding defaults)
@nocolor
Problem 1: a simple blunder in settingsParser.set.

Problem 2: use_plugin didn't get changed until after plugins get loaded.

Solution:  Read .leo files specified on the command line twice:
    
- Once before loading plugins, _without_ loading @file nodes.
- Once after (normal load)

What I did:

- Created completeFileName (does not depend on config).
- Added local file to list of files to be scanned in readSettingsFiles.
- Don't don't scan for settings in local file in createFrame.
    - Added readAtFileNodesFlag keyword arg to openWithFileName.
@color
#@nonl
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.2297:open
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # Delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        if not silent:
            << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20041124081632:(Problems overriding defaults)
#@+node:ekr.20041124150138:(Don't munge window title, make sure to munge when comparing c.mFileName)
# The window titel problem was in completeFileName.

# The munging needs was done in doType and settingsParser.set.
#@nonl
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20041124150138:(Don't munge window title, make sure to munge when comparing c.mFileName)
#@+node:ekr.20041124095942:(Create Tix dialog)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        self.root = root = Tk.Tk()

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root
#@nonl
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@nonl
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@-node:ekr.20041124095942:(Create Tix dialog)
#@+node:ekr.20041126035808:(Problems importing Pmw files)
@

- The Pmw source files contain mixed tabs/spaces, which caused most of the problems.
    - A _single_ blank was spanning two indentations.
    - That is always going to be hard for Leo unless heroic measures are taken.

- Created self.tab_width ivar (set by getTabWidth) so import directives honor @tabwidth directives.
#@nonl
#@+node:ekr.20031218072017.3207:import.__init__
def __init__ (self,c):

    self.c = c
    
    # New in 4.3: honor any tabwidth directive in effect when importing files.
    self.tabwidth = c.tab_width

    # Set by ImportFilesFommand.
    self.treeType = "@file" # "@root" or "@file"
    # Set by ImportWebCommand.
    self.webType = "@noweb" # "cweb" or "noweb"

    # Set by create_outline.
    self.fileName = None # The original file name, say x.cpp
    self.methodName = None # x, as in < < x methods > > =
    self.fileType = None # ".py", ".c", etc.
    self.rootLine = "" # Empty or @root + self.fileName

    # Support of output_newline option
    self.output_newline = g.getOutputNewline(c=c)
    
    # Used by Importers.
    self.web_st = []
    self.encoding = g.app.tkEncoding # 2/25/03: was "utf-8"
#@nonl
#@-node:ekr.20031218072017.3207:import.__init__
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@+node:ekr.20031218072017.2256:Python scanners
#@+node:ekr.20031218072017.2257:scanPythonClass
def scanPythonClass (self,s,i,start,parent):

    """Creates a child node c of parent for the class, and children of c for each def in the class."""

    # g.trace("self.tab_width",self.tab_width)
    # g.trace(g.get_line(s,i))
    classIndent = self.getLeadingIndent(s,i)
    << set classname and headline, or return i >>
    i = g.skip_line(s,i) # Skip the class line.
    << create class_vnode >>
    savedMethodName = self.methodName
    self.methodName = headline
    # Create a node for leading declarations of the class.
    i = self.scanPythonDecls(s,i,class_vnode,classIndent,indent_parent_ref_flag=True)
    << create nodes for all defs of the class >>
    << append any other class material >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2258:<< set classname and headline, or return i >>
# Skip to the class name.
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # skip "class"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    classname = s[j:i]
    headline = "class " + classname
else:
    return i
#@nonl
#@-node:ekr.20031218072017.2258:<< set classname and headline, or return i >>
#@+node:ekr.20031218072017.2259:<< create class_vnode  >>
# Create the section name using the old value of self.methodName.
if  self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + self.methodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# i points just after the class line.

# Add a docstring to the class node.
docStringSeen = False
j = g.skip_ws_and_nl(s,i)
if g.match(s,j,'"""') or g.match(s,j,"'''"):
    j = g.skip_python_string(s,j)
    if j != len(s): # No scanning error.
        i = j ; docStringSeen = True

body = s[start:i]
body = self.undentBody(body)
if docStringSeen: body = body + '\n'
class_vnode = self.createHeadline(parent,prefix + body,headline)
#@nonl
#@-node:ekr.20031218072017.2259:<< create class_vnode  >>
#@+node:ekr.20031218072017.2260:<< create nodes for all defs of the class >>
indent =  self.getLeadingIndent(s,i)
start = i = g.skip_blank_lines(s,i)
parent_vnode = None
# g.trace(classIndent)
while i < len(s) and indent > classIndent:
    progress = i
    if g.is_nl(s,i):
        backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
        j = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,j)
            if indent > classIndent: i = j
            else: break
        else: i = j
    elif g.match_c_word(s,i,"def"):
        if not parent_vnode:
            << create parent_vnode >>
        i = start = self.scanPythonDef(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif g.match_c_word(s,i,"class"):
        if not parent_vnode:
            << create parent_vnode >>
        i = start = self.scanPythonClass(s,i,start,parent_vnode)
        indent = self.getLeadingIndent(s,i)
    elif s[i] == '#': i = g.skip_to_end_of_line(s,i)
    elif s[i] == '"' or s[i] == '\'': i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress < i)
#@nonl
#@+node:ekr.20031218072017.2261:<< create parent_vnode >>
# This must be done after the declaration reference is generated.
if self.treeType == "@file":
    class_vnode.appendStringToBody("\t@others\n")
else:
    ref = g.angleBrackets(" class " + classname + " methods ")
    class_vnode.appendStringToBody("\t" + ref + "\n\n")
parent_vnode = class_vnode
#@nonl
#@-node:ekr.20031218072017.2261:<< create parent_vnode >>
#@-node:ekr.20031218072017.2260:<< create nodes for all defs of the class >>
#@+node:ekr.20031218072017.2262:<< append any other class material >>
s2 = s[start:i]
if s2:
    class_vnode.appendStringToBody(s2)
#@nonl
#@-node:ekr.20031218072017.2262:<< append any other class material >>
#@-node:ekr.20031218072017.2257:scanPythonClass
#@+node:ekr.20031218072017.2263:scanPythonDef
def scanPythonDef (self,s,i,start,parent):

    """Creates a node of parent for the def."""

    # g.trace(g.get_line(s,i))
    << set headline or return i >>
    << skip the Python def >>
    # Create the def node.
    savedMethodName = self.methodName
    self.methodName = headline
    << Create def node >>
    self.methodName = savedMethodName
    return i
#@+node:ekr.20031218072017.2264:<< set headline or return i >>
i = g.skip_ws(s,i)
i = g.skip_c_id(s,i) # Skip the "def"
i = g.skip_ws_and_nl(s,i)
if i < len(s) and g.is_c_id(s[i]):
    j = i ; i = g.skip_c_id(s,i)
    headline = s[j:i]
    # g.trace("headline:" + headline)
else: return i
#@nonl
#@-node:ekr.20031218072017.2264:<< set headline or return i >>
#@+node:ekr.20031218072017.2265:<< skip the Python def >>
# Set defIndent to the indentation of the def line.
defIndent = self.getLeadingIndent(s,start)
i = g.skip_line(s,i) # Skip the def line.
indent = self.getLeadingIndent(s,i)
#g.trace(defIndent,indent)
#g.trace(g.get_line(s,i))
while i < len(s) and indent > defIndent:
    progress = i
    ch = s[i]
    if g.is_nl(s,i):
        backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
        i = g.skip_nl(s,i)
        if not backslashNewline:
            indent = self.getLeadingIndent(s,i)
            if indent <= defIndent:
                break
    elif ch == '#':
        i = g.skip_to_end_of_line(s,i) # 7/29/02
    elif ch == '"' or ch == '\'':
        i = g.skip_python_string(s,i)
    else: i += 1
    assert(progress < i)
#@nonl
#@-node:ekr.20031218072017.2265:<< skip the Python def >>
#@+node:ekr.20031218072017.2266:<< Create def node >>
# Create the prefix line for @root trees.
if self.treeType == "@file":
    prefix = ""
else:
    prefix = g.angleBrackets(" " + savedMethodName + " methods ") + "=\n\n"
    self.methodsSeen = True

# Create body.
start = g.skip_blank_lines(s,start)
body = s[start:i]
body = self.undentBody(body)

# Create the node.
self.createHeadline(parent,prefix + body,headline)

#@-node:ekr.20031218072017.2266:<< Create def node >>
#@-node:ekr.20031218072017.2263:scanPythonDef
#@+node:ekr.20031218072017.2267:scanPythonDecls
def scanPythonDecls (self,s,i,parent,indent,indent_parent_ref_flag=True):
    
    done = False ; start = i
    while not done and i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n':
            backslashNewline = i > 0 and g.match(s,i-1,"\\\n")
            i = g.skip_nl(s,i)
            # 2/14/03: break on lesser indention.
            j = g.skip_ws(s,i)
            if not g.is_nl(s,j) and not g.match(s,j,"#") and not backslashNewline:
                lineIndent = self.getLeadingIndent(s,i)
                if lineIndent <= indent:
                    break
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'':
            i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << break on def or class >>
        else: i += 1
        assert(progress < i)
    j = g.skip_blank_lines(s,start)
    if g.is_nl(s,j): j = g.skip_nl(s,j)
    if j < i:
        << Create a child node for declarations >>
    return i
#@nonl
#@+node:ekr.20031218072017.2268:<< break on def or class >>
if g.match_c_word(s,i,"def") or g.match_c_word(s,i,"class"):
    i = g.find_line_start(s,i)
    done = True
    break
else:
    i = g.skip_c_id(s,i)
#@nonl
#@-node:ekr.20031218072017.2268:<< break on def or class >>
#@+node:ekr.20031218072017.2269:<< Create a child node for declarations >>
headline = ref = g.angleBrackets(" " + self.methodName + " declarations ")
leading_tab = g.choose(indent_parent_ref_flag,"\t","")

# Append the reference to the parent's body.
parent.appendStringToBody(leading_tab + ref + "\n") # 7/6/02

# Create the node for the decls.
body = self.undentBody(s[j:i])
if self.treeType == "@root":
    body = "@code\n\n" + body
self.createHeadline(parent,body,headline)
#@nonl
#@-node:ekr.20031218072017.2269:<< Create a child node for declarations >>
#@-node:ekr.20031218072017.2267:scanPythonDecls
#@+node:ekr.20031218072017.2270:scanPythonText
# See the comments for scanCText for what the text looks like.

def scanPythonText (self,s,parent):

    """Creates a child of parent for each Python function definition seen."""

    decls_seen = False ; start = i = 0
    self.methodsSeen = False
    while i < len(s):
        progress = i
        # g.trace(g.get_line(s,i))
        ch = s[i]
        if ch == '\n' or ch == '\r': i = g.skip_nl(s,i)
        elif ch == '#': i = g.skip_to_end_of_line(s,i)
        elif ch == '"' or ch == '\'': i = g.skip_python_string(s,i)
        elif g.is_c_id(ch):
            << handle possible Python function or class >>
        else: i += 1
        assert(progress < i)
    if not decls_seen: # 2/17/03
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
    << Append a reference to the methods of this file >>
    << Append any unused python text to the parent's body text >>
#@nonl
#@+node:ekr.20031218072017.2271:<< handle possible Python function or class >>
if g.match_c_word(s,i,"def") or g.match_word(s,i,"class"):
    isDef = g.match_c_word(s,i,"def")
    if not decls_seen:
        parent.appendStringToBody("@ignore\n" + self.rootLine + "@language python\n")
        i = start = self.scanPythonDecls(s,start,parent,-1,indent_parent_ref_flag=False)
        decls_seen = True
        if self.treeType == "@file": # 7/29/02
            parent.appendStringToBody("@others\n") # 7/29/02
    if isDef:
        i = start = self.scanPythonDef(s,i,start,parent)
    else:
        i = start = self.scanPythonClass(s,i,start,parent)
else:
    i = g.skip_c_id(s,i)
#@nonl
#@-node:ekr.20031218072017.2271:<< handle possible Python function or class >>
#@+node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
if self.treeType == "@root" and self.methodsSeen:
    parent.appendStringToBody(
        g.angleBrackets(" " + self.methodName + " methods ") + "\n\n")
#@nonl
#@-node:ekr.20031218072017.2272:<< Append a reference to the methods of this file >>
#@+node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
# Do nothing if only whitespace is left.
i = start ; i = g.skip_ws_and_nl(s,i)
if i < len(s):
    parent.appendStringToBody(s[start:])
#@nonl
#@-node:ekr.20031218072017.2273:<< Append any unused python text to the parent's body text >>
#@-node:ekr.20031218072017.2270:scanPythonText
#@-node:ekr.20031218072017.2256:Python scanners
#@-node:ekr.20041126035808:(Problems importing Pmw files)
#@+node:ekr.20041124164305:(Eliminated alarming warning message)
@

The fix really should be in putDescendentAttributes and putUnknownAttributes.

These methods shouldn't write gnx's that don't exist.
#@nonl
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@+node:ekr.20040701065235.2:putDescendentAttributes
def putDescendentAttributes (self,p):
    
    nodeIndices = g.app.nodeIndices

    # Create a list of all tnodes whose vnodes are marked or expanded
    marks = [] ; expanded = []
    for p in p.subtree_iter():
        if p.isMarked() and not p in marks:
            marks.append(p.copy())
        if p.hasChildren() and p.isExpanded() and not p in expanded:
            expanded.append(p.copy())

    for theList,tag in ((marks,"marks="),(expanded,"expanded=")):
        if theList:
            sList = []
            for p in theList:
                gnx = p.v.t.fileIndex
                sList.append("%s," % nodeIndices.toString(gnx))
            s = string.join(sList,'')
            # g.trace(tag,[str(p.headString()) for p in theList])
            self.put('\n' + tag)
            self.put_in_dquotes(s)
#@nonl
#@-node:ekr.20040701065235.2:putDescendentAttributes
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        val = attrDict[key]
        self.putUa(torv,key,val)
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@-node:ekr.20041124164305:(Eliminated alarming warning message)
#@+node:ekr.20041127055549:(Don't call plugins for null gui's)
# Added isNullGui ivar to gui classes.
#@nonl
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            print s ; g.es(s,color="blue")
        return None
         
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@-node:ekr.20041127055549:(Don't call plugins for null gui's)
#@+node:ekr.20041127094814:(Mods to drawTopTree)
@

I haven't been able to use the base drawTopTree method.

Don't know just why: some problem with the canvas, probably.
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount,c.rootPosition())

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.53:drawTree
def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y
#@nonl
#@-node:ekr.20040803072955.53:drawTree
#@+node:ekr.20040305162628.1:p.Iterators
@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others
#@nonl
#@+node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v.t
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v.t not in marks:
            marks[p.v.t] = p.v.t
            yield p.v.t
#@nonl
#@-node:EKR.20040529103843:p.tnodes_iter & unique_tnodes_iter
#@+node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v
#@nonl
#@-node:EKR.20040529103945:p.vnodes_iter & unique_vnodes_iter
#@+node:ekr.20040305171133:p.allNodes_iter
class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305171133.1:__init__ & __iter__
def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305171133.1:__init__ & __iter__
#@+node:ekr.20040305171133.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305171133.3:next
#@-node:ekr.20040305171133:p.allNodes_iter
#@+node:ekr.20040305173559:p.subtree_iter
class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040305173559.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
#@-node:ekr.20040305173559.1:__init__ & __iter__
#@+node:ekr.20040305173559.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@nonl
#@-node:ekr.20040305173559.2:next
#@-node:ekr.20040305173559:p.subtree_iter
#@+node:ekr.20040305172211.1:p.children_iter
class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)
#@nonl
#@+node:ekr.20040305172211.2:__init__ & __iter__
def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
#@-node:ekr.20040305172211.2:__init__ & __iter__
#@+node:ekr.20040305172211.3:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305172211.3:next
#@-node:ekr.20040305172211.1:p.children_iter
#@+node:ekr.20040305172855:p.parents_iter
class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)
#@nonl
#@+node:ekr.20040305172855.1:__init__ & __iter__
def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self
#@nonl
#@-node:ekr.20040305172855.1:__init__ & __iter__
#@+node:ekr.20040305172855.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
#@-node:ekr.20040305172855.2:next
#@-node:ekr.20040305172855:p.parents_iter
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@-node:ekr.20040305162628.1:p.Iterators
#@+node:ekr.20040803072955.143:tree.expandAllAncestors
def expandAllAncestors (self,p):
    
    redraw_flag = False
    
    # g.trace(p)

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag

#@-node:ekr.20040803072955.143:tree.expandAllAncestors
#@-node:ekr.20041127094814:(Mods to drawTopTree)
#@+node:ekr.20041130065718.2:(Problems writing to a file with a nullFrame)
#@+node:ekr.20031218072017.2222:class nullFrame
class nullFrame (leoFrame):
    
    """A null frame class for tests and batch execution."""
    
    __pychecker__ = '--no-argsused' # null classes have many unused args.
    
    @others
#@nonl
#@+node:ekr.20040327105706: ctor
def __init__ (self,title,gui,useNullUndoer=False):

    leoFrame.__init__(self,gui) # Init the base class.
    assert(self.c is None)
    self.title = title
    self.useNullUndoer = useNullUndoer
    
    # Default window position.
    self.w = 600
    self.h = 500
    self.x = 40
    self.y = 40
#@nonl
#@-node:ekr.20040327105706: ctor
#@+node:ekr.20041130065921:deiconfy, lift, update
def deiconify (self):
    pass
    
def lift (self):
    pass
    
def update (self):
    pass
#@nonl
#@-node:ekr.20041130065921:deiconfy, lift, update
#@+node:ekr.20041120073824:destroySelf
def destroySelf (self):
    
    pass
#@nonl
#@-node:ekr.20041120073824:destroySelf
#@+node:ekr.20040327105706.2:finishCreate
def finishCreate(self,c):

    self.c = c

    # Create do-nothing component objects.
    self.tree = nullTree(frame=self)
    self.body = nullBody(frame=self,parentFrame=None)
    self.log  = nullLog (frame=self,parentFrame=None)
    self.menu = leoMenu.nullMenu(frame=self)
    
    assert(c.undoer)
    if self.useNullUndoer:
        c.undoer = leoUndo.nullUndoer(c)
#@nonl
#@-node:ekr.20040327105706.2:finishCreate
#@+node:ekr.20041130065718:get_window_info
def get_window_info (self):

    """Return the window information."""
    
    # g.trace(self.w,self.h,self.x,self.y)

    return self.w,self.h,self.x,self.y
#@nonl
#@-node:ekr.20041130065718:get_window_info
#@+node:ekr.20041130065921.1:lift
#@-node:ekr.20041130065921.1:lift
#@+node:ekr.20040327105706.3:oops
def oops(self):
    
    g.trace("nullFrame:", g.callerName(2))
#@nonl
#@-node:ekr.20040327105706.3:oops
#@+node:ekr.20041130090749:setInitialWindowGeometry
def setInitialWindowGeometry (self):
    pass
#@nonl
#@-node:ekr.20041130090749:setInitialWindowGeometry
#@+node:ekr.20041130065718.1:setTopGeometry
def setTopGeometry (self,w,h,x,y,adjustSize=True):
    
    __pychecker__ = '--no-argsused' # adjustSize used in derived classes.
    
    self.w = w
    self.h = h
    self.x = x
    self.y = y
#@nonl
#@-node:ekr.20041130065718.1:setTopGeometry
#@-node:ekr.20031218072017.2222:class nullFrame
#@-node:ekr.20041130065718.2:(Problems writing to a file with a nullFrame)
#@+node:ekr.20041130094657:(Finished g.app.config.set)
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    # initialize the sub-commanders
    self.fileCommands = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@-node:ekr.20041130094657:(Finished g.app.config.set)
#@+node:ekr.20041201075146:(Updated recent files properly)
#@+node:ekr.20041201083311:What I did
@killcolor

- g.openWithFileName now calls:
    frame.c.config.setRecentFiles(g.app.config.recentFiles)

That is, all new files get the global file list.

- Created config.appendToRecentFiles.

- c.ConfigParser.setRecentFiles calls config.appendToRecentFiles.

That is, we never remove files from the recent files list, we only add files.

- Added << update recent files from d >> to config.readSettingsFiles.

This calls config.appendToRecentFiles(files) to actually set the files.
#@nonl
#@-node:ekr.20041201083311:What I did
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    __pychecker__ = '--no-argsused' # p not used.
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041201080436.1:Notes
@killcolor

Leo writes the recent files node correctly, but does not init them correctly.
#@nonl
#@-node:ekr.20041201080436.1:Notes
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20041123092357:config.findSettingsPosition
def findSettingsPosition (self,c,setting):
    
    """Return the position for the setting in the @settings tree for c."""
    
    munge = self.munge
    
    root = self.settingsRoot(c)
    if not root:
        return c.nullPosition()
        
    setting = munge(setting)
        
    for p in root.subtree_iter():
        h = munge(p.headString())
        if h == setting:
            return p.copy()
    
    return c.nullPosition()
#@nonl
#@-node:ekr.20041123092357:config.findSettingsPosition
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:config.readSettingsFiles
#@-node:ekr.20041201075146:(Updated recent files properly)
#@-node:ekr.20041211051934:(11/17 to 11/4)
#@+node:ekr.20041211051934.1:12/11
#@+node:ekr.20041130125213:(Fixed minor bugs in spelling plugin)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2866490

I've noticed that even if the mod_speling.ini is changed, the language is alway
set as en_US !

to Correct this and being able to launch the correct language, i've changed
he following code :

''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir)

by :
''''''Ctor for the Aspell clas.''''''
self.sc = aspell.spell_checker(prefix=aspell_dir, lang=local_language_code)

..................
This seem to work on my install !

BUT
the hardcodding of the aspell_dir in the plugin code is UGLY !!!

It should also be fine to add a directive or a menu under the plugins_menu"
to change the language and reinitialise the spell_checker for spelling multilingual
documents.....
#@-node:ekr.20041130125213:(Fixed minor bugs in spelling plugin)
#@-node:ekr.20041211051934.1:12/11
#@+node:ekr.20041216052925:12/17
#@+node:ekr.20041211043135:(Fix problems with c.ivars)
@

What ivars get changed--local (c) or global(g.app.config) ??

Presently, only g.app.config.page_width and g.app.config.tab_width get changed.
#@nonl
#@+node:ekr.20041211050623:From 4.2
@ignore
#@nonl
#@+node:ekr.20041211050623.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }
#@nonl
#@-node:ekr.20041211050623.1:defaultsDict
#@+node:ekr.20041211050623.2:initialize ivars that may be set by config options
# Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False

# TO BE REMOVED:
self.write_old_format_derived_files = False # Use new format if leoConfig.txt does not exist.
#@nonl
#@-node:ekr.20041211050623.2:initialize ivars that may be set by config options
#@+node:ekr.20041211050623.3:set in c.__init__
# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.
#@nonl
#@-node:ekr.20041211050623.3:set in c.__init__
#@-node:ekr.20041211050623:From 4.2
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@-node:ekr.20041211043135:(Fix problems with c.ivars)
#@+node:ekr.20041216050937:(Support for @font)
#@+node:ekr.20041213082558.1:parseFont
def parseFont (self,p):
    
    d = {
        'comments': [],
        'family': None,
        'size': None,
        'slant': None,
        'weight': None,
    }

    s = p.bodyString()
    lines = g.splitLines(s)

    for line in lines:
        self.parseFontLine(line,d)
        
    comments = d.get('comments')
    d['comments'] = '\n'.join(comments)
        
    return d
#@nonl
#@-node:ekr.20041213082558.1:parseFont
#@+node:ekr.20041213082558.2:parseFontLine
def parseFontLine (self,line,d):
    
    s = line.strip()
    if not s: return
    
    try:
        s = str(s)
    except UnicodeError:
        pass
    
    if g.match(s,0,'#'):
        s = s[1:].strip()
        comments = d.get('comments')
        comments.append(s)
        d['comments'] = comments
    else:
        # name is everything up to '='
        i = s.find('=')
        if i == -1:
            name = s ; val = None
        else:
            name = s[:i].strip() ; val = s[i+1:].strip()

        fontKind = self.fontSettingNameToFontKind(name)
        if fontKind:
            d[fontKind] = name,val # Used only by doFont.
#@nonl
#@-node:ekr.20041213082558.2:parseFontLine
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind not used.
    
    d = self.parseFont(p)
    
    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
#@nonl
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@-node:ekr.20041216050937:(Support for @font)
#@+node:ekr.20041217071057:(Fixed long-standing problem with clashing fonts)
@ It is essential to retain a link to a font.  Otherwise changes to one font may affect other fonts.

This appears to be a bug in Tk or Tkinter.
#@nonl
#@+node:ekr.20031218072017.4046:tkLog.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize, tag = "log")

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
#@nonl
#@-node:ekr.20031218072017.4046:tkLog.setFontFromConfig
#@+node:ekr.20031218072017.2183:tkBody.setFontFromConfig
def setFontFromConfig (self):

    c = self.c ; body = self.bodyCtrl
    
    font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "body")
    
    self.fontRef = font # ESSENTIAL: retain a link to font.
    body.configure(font=font)

    # g.trace("BODY",body.cget("font"),font.cget("family"),font.cget("weight"))
#@nonl
#@-node:ekr.20031218072017.2183:tkBody.setFontFromConfig
#@+node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
def getFont (self):

    return self.font

def setFont (self,font=None, fontName=None):
    
    # ESSENTIAL: retain a link to font.
    if fontName:
        self.fontName = fontName
        self.font = tkFont.Font(font=fontName)
    else:
        self.fontName = None
        self.font = font
        
    self.setLineHeight(self.font)
    
# Called by ctor and when config params are reloaded.
def setFontFromConfig (self):
    c = self.c
    font = c.config.getFontFromParams(
        "headline_text_font_family", "headline_text_font_size",
        "headline_text_font_slant",  "headline_text_font_weight",
        c.config.defaultTreeFontSize, tag = "tree")
    
    self.setFont(font)
#@nonl
#@-node:ekr.20040803072955.27:tree.getFont,setFont,setFontFromConfig
#@+node:ekr.20041117062717.13:getFontFromParams (config)
def getFontFromParams(self,c,family,size,slant,weight,defaultSize=12,tag="<unknown>"):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""
    
    __pychecker__ = '--no-argsused' # tag used for debugging.

    family = self.get(c,family,"family")
    if family in (None,""):
        family = self.defaultFontFamily

    size = self.get(c,size,"size")
    if size in (None,0): size = defaultSize
    
    slant = self.get(c,slant,"slant")
    if slant in (None,""): slant = "roman"

    weight = self.get(c,weight,"weight")
    if weight in (None,""): weight = "normal"
    
    # g.trace(tag,family,size,slant,weight,g.shortFileName(c.mFileName))
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)
#@nonl
#@-node:ekr.20041117062717.13:getFontFromParams (config)
#@+node:ekr.20031218072017.2187:tkGui.getFontFromParams
def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont
#@nonl
#@-node:ekr.20031218072017.2187:tkGui.getFontFromParams
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041217041016:setFontFromConfig
def setFontFromConfig (self):
    
    c = self.c
    
    self.bold_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold")
    
    if self.bold_font:
        self.bold_font.configure(weight="bold")
    
    self.italic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer italic")
        
    if self.italic_font:
        self.italic_font.configure(slant="italic",weight="normal")
    
    self.bolditalic_font = c.config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        c.config.defaultBodyFontSize, tag = "colorer bold italic")
        
    if self.bolditalic_font:
        self.bolditalic_font.configure(weight="bold",slant="italic")
        
    self.color_tags_list = []
    self.image_references = []
#@nonl
#@-node:ekr.20041217041016:setFontFromConfig
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    
    d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        t = Tk.Text(canvas,state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)
            t.bind("<Control-t>",self.onControlT)
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # Bug fix 7/31/04:  We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString(),tag="newText")
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # New in 4.2 b3: entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList

    # g.trace(p,t)
    return t
#@nonl
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@-node:ekr.20041217071057:(Fixed long-standing problem with clashing fonts)
#@+node:ekr.20041217091737:(Changed lookup: added localOptionsList
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@-node:ekr.20041217091737:(Changed lookup: added localOptionsList
#@+node:ekr.20041217135735.3:(Update all colors immediately)
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@+node:ekr.20041217135735.2:tkLog.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20041217135735.2:tkLog.setColorFromConfig
#@+node:ekr.20040803072955.30:tkTree.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c

    bg = c.config.getColor("outline_pane_background_color") or 'white'

    try:
        self.canvas.configure(bg=bg)
    except:
        g.es("exception setting outline pane background color")
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.30:tkTree.setColorFromConfig
#@-node:ekr.20041217135735.3:(Update all colors immediately)
#@-node:ekr.20041216052925:12/17
#@+node:ekr.20041221070525.1:12/18
#@+node:ekr.20041219071407.1:(Used Bunch to clarify config code)
#@+node:ekr.20031218072017.3098:class Bunch (object)
@ From The Python Cookbook:  Often we want to just collect a bunch of stuff together, naming each item of the bunch; a dictionary's OK for that, but a small do-nothing class is even handier, and prettier to use.

Create a Bunch whenever you want to group a few variables:

    point = Bunch(datum=y, squared=y*y, coord=x)

You can read/write the named attributes you just created, add others, del some of them, etc:
    if point.squared > threshold:
        point.isok = True
@c

class Bunch (object):
    
    """A class that represents a colection of things.
    
    Especially useful for representing a collection of related variables."""
    
    def __init__(self,**keywords):
        self.__dict__.update (keywords)
        
    def __repr__(self):
        return self.toString()

    def ivars(self):
        return self.__dict__.keys()
        
    def keys(self):
        return self.__dict__.keys()
        
    def toString(self):
        tag = self.__dict__.get('tag')
        entries = ["%s: %s" % (key,str(self.__dict__.get(key)))
            for key in self.ivars() if key != 'tag']
        if tag:
            return "Bunch(tag=%s)...\n%s\n" % (tag,'\n'.join(entries))
        else:
            return "Bunch...\n%s\n" % '\n'.join(entries)

    # Used by new undo code.
    def __setitem__ (self,key,value):
        '''Support aBunch[key] = val'''
        return operator.setitem(self.__dict__,key,value)
        
    def __getitem__ (self,key):
        '''Support aBunch[key]'''
        return operator.getitem(self.__dict__,key)
        
    def get (self,key,theDefault=None):
        return self.__dict__.get(key,theDefault)
        
bunch = Bunch
#@nonl
#@-node:ekr.20031218072017.3098:class Bunch (object)
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041201081440:<< update recent files from d >>
for key in d.keys():
    
    if munge(key) == "recentfiles":
        # Entries were created by parserBaseClass.set.
        bunch = d.get(key)
        files = bunch.val
        files = [theFile.strip() for theFile in files]
        if 0:
            print "config.readSettingsFiles.  recent files from %s..." % fileName
            for theFile in files:
                print theFile
        self.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041201081440:<< update recent files from d >>
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@-node:ekr.20041219071407.1:(Used Bunch to clarify config code)
#@-node:ekr.20041221070525.1:12/18
#@+node:ekr.20041223154547:(New leoTkinterFrame projects)
#@+node:ekr.20041221181118:(Pane sizes)
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20031218072017.3987:equalSizedPanes
def equalSizedPanes(self):

    frame = self
    frame.resizePanesToRatio(0.5,frame.secondary_ratio)
#@-node:ekr.20031218072017.3987:equalSizedPanes
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3689:initialRatios
def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","orientation")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r < 0.0 or r > 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 < 0.0 or r2 > 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2
#@nonl
#@-node:ekr.20031218072017.3689:initialRatios
#@-node:ekr.20041221181118:(Pane sizes)
#@+node:ekr.20041222092032:(Tried using place to show widgets)
@

This did not work: _tkinter.TclError: can't place

.24597368.24598448.24610776.24610936 relative to
.24597368.24598448.24598768.24599008.24608856.24609096
#@nonl
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@-node:ekr.20041222092032:(Tried using place to show widgets)
#@+node:ekr.20041224100539:(Replacing body pane)
#@+node:ekr.20041223130609:class componentBaseClass
class componentBaseClass:

    @others
#@nonl
#@+node:ekr.20041223154028: ctor
def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    self.c = c
    self.frame = frame    # The Tk.Frame containing the component.
    self.isVisible = False # True if the component is visible.
    self.name = name      # The component's name: the key for c.frame.componentsDict.
    self.obj = obj        # Optional object (typically not a Tk.Frame.)
    self.packer = packer
    self.unpacker = unpacker

    c.frame.componentsDict[name] = self
#@nonl
#@-node:ekr.20041223154028: ctor
#@+node:ekr.20041223124910:__repr__
def __repr__ (self):
    
    return '<component %s>' % self.name
#@nonl
#@-node:ekr.20041223124910:__repr__
#@+node:ekr.20041223154028.1:oops
def oops (self):
    
    print ("componentBaseClass oops:",
        g.callerName(2),
        "must be overridden in subclass")
#@-node:ekr.20041223154028.1:oops
#@+node:ekr.20041223154028.2:getters
# Getters...
def getFrame    (self): return self.frame
def getObject   (self): return self.obj
def getPacker   (self): return self.packer
def getUnpacker (self): return self.unpacker
#@-node:ekr.20041223154028.2:getters
#@+node:ekr.20041223154028.3:must be defined in subclasses
def destroy (self):
    self.oops()
#@nonl
#@-node:ekr.20041223154028.3:must be defined in subclasses
#@+node:ekr.20041224072245:show & hide, pack & unpack
# Pack always packs the widget, which can make it visble in two places.
# Show packs a new widget only if it is not visible.

def hide (self):
    if self.isVisible:
        self.isVisible = False
        self.unpack()

def pack (self):
    self.oops()
    
def show (self):
    if not self.isVisible:
        self.isVisible = True
        self.pack()
    
def unpack (self):
    self.oops()
    
#@-node:ekr.20041224072245:show & hide, pack & unpack
#@-node:ekr.20041223130609:class componentBaseClass
#@+node:ekr.20041223095751:class componentClass (componentBaseClass)
class componentClass (leoFrame.componentBaseClass):
    
    '''A class to manage components of Leo windows'''
    
    @others
#@nonl
#@+node:ekr.20041223095751.1: ctor
def __init__ (self,c,name,frame,obj=None,packer=None,unpacker=None):
    
    # Init the base class.
    leoFrame.componentBaseClass.__init__(
        self,c,name,frame,obj,packer,unpacker)
    
    self.setPacker(packer)
    self.setUnpacker(unpacker)
#@nonl
#@-node:ekr.20041223095751.1: ctor
#@+node:ekr.20041223154028.4:__repr__
def __repr__ (self):
    
    return '<component %s>' % self.name
#@nonl
#@-node:ekr.20041223154028.4:__repr__
#@+node:ekr.20041223124022:destroy
def destroy (self):
    
    try:
        del c.frame.componentsDict[self.name]
    except KeyError:
        g.es("No component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041223124022:destroy
#@+node:ekr.20041223124022.1:getters & setters
# Setters...
def setPacker (self,packer):
    if not packer: # Define default packer.
        def packer():
            if self.frame:
                self.frame.pack(side='top',expand=1,fill='both')
    self.packer = packer

def setUnpacker (self,unpacker):
    if not unpacker: # Define default unpacker.
        def unpacker():
            if self.frame:
                self.frame.pack_forget()
    self.unpacker = unpacker
#@nonl
#@-node:ekr.20041223124022.1:getters & setters
#@+node:ekr.20041223095751.2:pack & unpack
def pack (self):

    self.packer()
    
def unpack (self):

    self.unpacker()
#@nonl
#@-node:ekr.20041223095751.2:pack & unpack
#@-node:ekr.20041223095751:class componentClass (componentBaseClass)
#@+node:ekr.20041222060024:tkFrame.unpack/repack...
#@+node:ekr.20041223160653:pane packers
def placePane1(self,verticalFlag,pane1,frac):
    if verticalFlag:
        pane1.place(relx=0.5,rely=0,anchor="n",relwidth=1.0,relheight=frac)
    else:
        pane1.place(rely=0.5,relx=0,anchor="w",relheight=1.0,relwidth=frac)
        
def placePane2(self,verticalFlag,pane2,frac):
    if verticalFlag:
        pane2.place(relx=0.5,rely=1.0,anchor="s",relwidth=1.0,relheight=1-frac)
    else:
        pane2.place(rely=0.5,relx=1.0,anchor="e",relheight=1.0,relwidth=1-frac)

# These are the packers of the corresponding components.
# These are called from, packComponent('body'), etc.
def packBody (self):
    # Pane 2 of primary splitter.
    self.placePane2(self.splitVerticalFlag,self.split1Pane2,self.ratio)
def packLog (self):
    # Pane 2 of secondary splitter.
    self.placePane2(not self.splitVerticalFlag,self.split2Pane2,self.secondary_ratio)
def packTree (self):
    # Pane 1 of secondary splitter.
    self.placePane1(not self.splitVerticalFlag,self.split2Pane1,self.secondary_ratio)
#@nonl
#@-node:ekr.20041223160653:pane packers
#@+node:ekr.20041224102942:pane replacers
#@+node:ekr.20041224105456.1:replaceBodyPaneWithComponent
def replaceBodyPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packBody)
            component.setUnpacker(self.unpackBody)
            self.unpackComponent('body')
            self.split1Pane2 = f
            self.packBody()
#@nonl
#@-node:ekr.20041224105456.1:replaceBodyPaneWithComponent
#@+node:ekr.20041224105456.3:replaceLogPaneWithComponent
def replaceLogPaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packLog)
            component.setUnpacker(self.unpackLog)
            self.unpackComponent('log')
            self.split2Pane2 = f
            self.packLog()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)
#@nonl
#@-node:ekr.20041224105456.3:replaceLogPaneWithComponent
#@+node:ekr.20041224105456.4:replaceTreePaneWithComponent
def replaceTreePaneWithComponent (self,componentName):
    component = self.component(componentName)
    if component:
        f = component.getFrame()
        if f:
            component.setPacker(self.packTree)
            component.setUnpacker(self.unpackTree)
            self.unpackComponent('tree')
            self.split2Pane1 = f
            self.packTree()
            self.divideLeoSplitter(not self.splitVerticalFlag,self.secondary_ratio)
#@nonl
#@-node:ekr.20041224105456.4:replaceTreePaneWithComponent
#@-node:ekr.20041224102942:pane replacers
#@+node:ekr.20041223162512:pane unpackers
# These are the packers of the corresponding components.

def unpackBody(self):
    self.split1Pane2.place_forget()
    
def unpackLog(self):
    self.split2Pane2.place_forget()

def unpackTree(self):
    self.split2Pane1.place_forget()
#@nonl
#@-node:ekr.20041223162512:pane unpackers
#@+node:ekr.20041222061439:pack/unpackComponent
# Note: the 'packers' for the 'body', 'log' and 'tree' components are actually placers,
# so packing twice does not duplicate those component.

def packComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.pack()
    elif verbose:
        g.es("packComponent: no component named %s" % name,color='blue')

def unpackComponent (self,name,verbose=True):
    component = self.component(name)
    if component:
        component.unpack()
    elif verbose:
        g.es("unpackComponent: no component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041222061439:pack/unpackComponent
#@+node:ekr.20041224072631:show/hideComponent
def hideComponent (self,name):
    component = self.component(name)
    if component:
        component.hide()
    else:
        g.es("hideComponent: no component named %s" % name,color='blue')

def showComponent (self,name):
    component = self.component(name)
    if component:
        component.show()
    else:
        g.es("showComponent: no component named %s" % name,color='blue')
#@nonl
#@-node:ekr.20041224072631:show/hideComponent
#@-node:ekr.20041222060024:tkFrame.unpack/repack...
#@+node:ekr.20041223104933:class statusLineClass
class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@nonl
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove")
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("<Button-1>", self.onActivate)
#@nonl
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='statusLine.disable')
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.frame.statusLineWantsFocus(t,tag='statusLine.ensable')
        t.focus_set()
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
#@nonl
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@nonl
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@nonl
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

        # Register an idle-time handler to update the row and column indicators.
        self.statusFrame.after_idle(self.update)
        
show = pack
#@nonl
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()
#@nonl
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame)
#@+node:EKR.20040424154804:setFocus
if 0: # No longer used in 4.3.  Done as the result of statusLineWantsFocus.

    def setFocus (self):
    
        # Force the focus to the icon area.
        t = self.textWidget
        if t:
            t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocus
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@nonl
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update
def update (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = body.index("insert")
    row,col = g.app.gui.getindex(body,index)

    if col > 0:
        s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col

    self.statusFrame.after(500,self.update)
#@nonl
#@-node:ekr.20031218072017.1733:update
#@-node:ekr.20041223104933:class statusLineClass
#@+node:ekr.20031218072017.3953:Icon area methods (compatibility)
def getIconBarObject(self):
    component = self.component(self.iconBarComponentName)
    if not component: return g.trace("No iconBar component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.iconBarComponentName))
                
def callIconBar(self,name,*args,**keys):
    obj = self.getIconBarObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.iconBarComponentName,name))

def addIconButton (self,*args,**keys):
    return self.callIconBar('add',*args,**keys)

def clearIconBar (self):
    return self.callIconBar('clear')

def createIconBar (self):
    self.callIconBar('show')
    return self.getIconBarObject() # For compatibility.

def hideIconBar (self):
    return self.callIconBar('hide')
#@nonl
#@-node:ekr.20031218072017.3953:Icon area methods (compatibility)
#@+node:ekr.20041223105114.1:Status line methods (compatibility)
def getStatusObject(self):
    component = self.component(self.statusLineComponentName)
    if not component: return g.trace("No statusLine component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.statusLineComponentName))
                
def callStatus(self,name,*args,**keys):
    obj = self.getStatusObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.statusLineComponentName,name))

def createStatusLine (self):
    self.callStatus('show')
    return self.getStatusObject() # For compatibility.

def clearStatusLine (self):
    return self.callStatus('clear')
    
def disableStatusLine (self,background=None):
    return self.callStatus('disable',background)

def enableStatusLine (self,background="white"):
    return self.callStatus('enable',background)

def getStatusLine (self):
    return self.callStatus('get')
    
def putStatusLine (self,s,color=None):
    return self.callStatus('put',s,color)
    
def setFocusStatusLine (self):
    return self.callStatus('setFocus')

def statusLineIsEnabled(self):
    return self.callStatus('isEnabled')
#@nonl
#@-node:ekr.20041223105114.1:Status line methods (compatibility)
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.
    self.iconBar = None

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None 
self.statusFrame = None 
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.revertHeadline = None # Previous headline text for abortEditLabel.
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@-node:ekr.20041224100539:(Replacing body pane)
#@-node:ekr.20041223154547:(New leoTkinterFrame projects)
#@+node:ekr.20041228052058:12/28
#@+node:ekr.20041227065630:(Made shortcuts functional)
#@+node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&'):
        if ch in string.ascii_letters:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
#@-node:ekr.20031218072017.3783:canonicalizeMenuName & cononicalizeTranslatedMenuName
#@+node:ekr.20041122094813:<<  class data >>
@others
    
# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []
    
# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.
#@nonl
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","Python"),
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","orientation","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041118062709:define encodingIvarsDict
encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)
#@nonl
#@-node:ekr.20041118062709:define encodingIvarsDict
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@-node:ekr.20041122094813:<<  class data >>
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    __pychecker__ = '--no-argsused' # p not used.
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@+node:ekr.20041227071423:setShortcut (ParserBaseClass)
def setShortcut (self,name,val):
    
    # g.trace(name,val)
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&','')
    self.set(c,rawKey,"shortcut",val)
#@nonl
#@-node:ekr.20041227071423:setShortcut (ParserBaseClass)
#@+node:ekr.20041120113848:doShortcut
def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)
    self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120113848:doShortcut
#@+node:ekr.20041120105609:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind not used.
    
    #g.trace('*'*10,p.headString())

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseShortcutLine(line)
            # g.trace(name,val)
            if val is not None:
                self.set(p,"shortcut",name,val)
                self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120105609:doShortcuts
#@+node:ekr.20041117062717.14:getShortcut (config)
def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    rawKey = key.replace('&','') # Allow '&' in names.
    val = self.get(c,rawKey,"shortcut")
    if val is None:
         return rawKey,None
    else:
        # g.trace(key,val)
        return rawKey,val
#@nonl
#@-node:ekr.20041117062717.14:getShortcut (config)
#@-node:ekr.20041227065630:(Made shortcuts functional)
#@+node:ekr.20041227081942:(Made ivars functional)
#@+node:ekr.20041228050029:What I did
@killcolor

- Created setIvarsFromSettings.
    - Called from end of readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init commmander ivars.

- leoPrefs.py and leoTkinterPrefs are no longer used.
#@nonl
#@-node:ekr.20041228050029:What I did
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@-node:ekr.20041227081942:(Made ivars functional)
#@-node:ekr.20041228052058:12/28
#@-node:ekr.20041228053248:Diary
#@+node:ekr.20050121062047:(Added scrollbars to settings outline pane)
#@+node:ekr.20041225073207:When replacing body & tree panes...
#@-node:ekr.20041225073207:When replacing body & tree panes...
#@-node:ekr.20050121062047:(Added scrollbars to settings outline pane)
#@+node:ekr.20050121094515:(Improved appearance of settings panel)
#@+node:ekr.20050121094515.1:What I did
@killcolor

What I did:

- Placed comment and setter widgets in a ScrolledCanvas widget.

This is _far_ better than using two separate scrollers.

- Put label on same line as icons.

- All parts of the canvas now use a common background color.

It's surprisingly hard to pick a good color. Neither 'white' nor dark colors look good.
#@nonl
#@-node:ekr.20050121094515.1:What I did
#@-node:ekr.20050121094515:(Improved appearance of settings panel)
#@+node:ekr.20050122104754:(Clear Recent Files now updates @recent_files node properly)
#@+node:ekr.20050122104754.1:What I did
@killcolor

- Fixed latent bug in setBodyStringOrPane.

This method now updates the body pane if any clone of the current node changes.

This is important, the settings node found by findSettingsPosition may be a clone of the current node!

- clearRecentFiles now calls c.config.setRecentFiles.
#@nonl
#@-node:ekr.20050122104754.1:What I did
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer
    
    bunch = u.beforeClearRecentFiles()
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())
    
    g.app.config.appendToRecentFiles(c.recentFiles)
    
    u.afterClearRecentFiles(bunch)
#@nonl
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@-node:ekr.20050122104754:(Clear Recent Files now updates @recent_files node properly)
#@+node:ekr.20041231104531:(Made sure recent files have correct capitalization)
#@+node:ekr.20050122105504:What I did
@killcolor

c.updateRecentFiles now 'munges' all names during the compare, so capitalization difference don't matter:  all files matching the file name get removed.
#@-node:ekr.20050122105504:What I did
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@-node:ekr.20041231104531:(Made sure recent files have correct capitalization)
#@+node:ekr.20050123143229.1:(Print setting changes to log)
#@+node:ekr.20041225063637.65:writeChangedVars & helpers
def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '<none>'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
                print s ; g.es(s,color='blue')
            else:
                s = "write  %10s -> %10s %s" % (str(oldVal),str(newVal),iname)
                print s ; g.es(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList,"write")
#@nonl
#@+node:ekr.20041225063637.66:updateConfig
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Put the values in the body.
                p.initHeadString("@%s %s" % (kind,name))
                body = '\n'.join(val)
                p.setBodyStringOrPane(body)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.69:writeChangedList
def writeChangedList (self,changedList,tag):
    
    __pychecker__ = '--no-argsused' # tag used for debugging.
    
    filesInfoDict = self.filesInfoDict
    if 0:
        << dump all the dicts in filesInfoDict >>

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -> %10s %s" % (tag,kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # Always write the file so as to preserve expansion state.
        self.writeChangesToFile(c,changes,path)
        self.updateConfig(c,changes)
        d['changes'] = []
#@nonl
#@+node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print
#@nonl
#@-node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
#@-node:ekr.20041225063637.69:writeChangedList
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.fileName())
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@-node:ekr.20041225063637.65:writeChangedVars & helpers
#@-node:ekr.20050123143229.1:(Print setting changes to log)
#@+node:ekr.20050123143229:(Disabled all commands while in settings dialog)
#@+node:ekr.20031218072017.2817: doCommand
def doCommand (self,command,label):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self ; p = c.currentPosition()

    # A horrible kludge: set g.app.log to cover for a possibly missing activate event.
    g.app.setLog(c.frame.log,"doCommand")
    
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label == "cantredo": label = "redo"
    if label == "cantundo": label = "undo"
    g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            command()
        except:
            g.es("exception executing command")
            print "exception executing command"
            g.es_exception(c=c)
            c.frame.tree.redrawAfterException() # 1/26/04
    
    c = g.top() # 6/17/04: The command can change the commander.
    if c:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.
#@nonl
#@-node:ekr.20031218072017.2817: doCommand
#@+node:ekr.20041225063637.51:onAnyButton
def onAnyButton(self,name):
    
    c = self.c
    endDialog = name in (None,"OK","Cancel")
    
    # g.trace(name)
    
    dispatchDict = {
        "Apply":    self.writeChangedVars,
        "Cancel":   None, # Do nothing.
        "OK":       self.writeChangedVars,
        "Revert":   self.revert,
    }
    
    f = dispatchDict.get(name)
    if f: f()
        
    if self.replaceBody:
        if endDialog:
            c.frame.replaceTreePaneWithComponent('tree')
            c.frame.replaceBodyPaneWithComponent('body')
            c.disableCommandsMessage = '' # Re-enable all commands.
    else:
        if endDialog:
            self.dialog.destroy()
            c.disableCommandsMessage = '' # Re-enable all commands.
        else:
            self.dialog.withdraw()
            self.dialog.deiconify()
#@nonl
#@-node:ekr.20041225063637.51:onAnyButton
#@-node:ekr.20050123143229:(Disabled all commands while in settings dialog)
#@-node:ekr.20041115111203:Config...
#@+node:ekr.20041228052527.2:New features...
#@+node:ekr.20040930064232.2:(Added new expand/contract or go commands)
#@+node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
self.outlineMenuExpandContractMenuTable = (
    ("&Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &Node","Alt+[",c.contractNode),
    ("Contract &Parent","Alt+0",c.contractParent),
    ("Contract Or Go Left","Alt+LtArrow",c.contractNodeOrGoToParent),
    ("-",None,None),
    ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&ext Level","Alt+=",c.expandNextLevel),
    ("Expand Or Go Right","Alt+RtArrow",c.expandNodeOrGoToFirstChild),
    ("-",None,None),
    ("Expand To Level &1","Alt+1",c.expandLevel1),
    ("Expand To Level &2","Alt+2",c.expandLevel2),
    ("Expand To Level &3","Alt+3",c.expandLevel3),
    ("Expand To Level &4","Alt+4",c.expandLevel4),
    ("Expand To Level &5","Alt+5",c.expandLevel5),
    ("Expand To Level &6","Alt+6",c.expandLevel6),
    ("Expand To Level &7","Alt+7",c.expandLevel7),
    ("Expand To Level &8","Alt+8",c.expandLevel8),
    # ("Expand To Level &9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &All","Alt+9",c.expandAllHeadlines),
    ("Expand N&ode","Alt+]",c.expandNode))
#@nonl
#@-node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
#@+node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
menu = frame.menu.getMenu("Expand/Contract...")
enable(menu,"Contract Parent",c.canContractParent())
enable(menu,"Contract Node",hasChildren and isExpanded)
enable(menu,"Contract Or Go Left",(hasChildren and isExpanded) or hasParent)
enable(menu,"Expand Node",hasChildren and not isExpanded)
enable(menu,"Expand Prev Level",hasChildren and isExpanded)
enable(menu,"Expand Next Level",hasChildren)
enable(menu,"Expand To Level 1",hasChildren and isExpanded)
enable(menu,"Expand Or Go Right",hasChildren)
for i in xrange(2,9):
    frame.menu.enableMenu(menu,"Expand To Level " + str(i), hasChildren)
#@nonl
#@-node:ekr.20040131171020.1:<< enable expand/Contract submenu >>
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent(self):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
 
    if v.hasChildren() and v.isExpanded():
        c.contractNode()
    elif v.hasParent():
        c.goToParent()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20040930064232.1:expandNodeOrGoToFirstChild
def expandNodeOrGoToFirstChild(self):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; v = c.currentVnode()
    if not v.hasChildren(): return

    if v.isExpanded():
        c.beginUpdate()
        c.selectVnode(v.firstChild())
        c.endUpdate()
    else:
        c.expandNode()
#@nonl
#@-node:ekr.20040930064232.1:expandNodeOrGoToFirstChild
#@-node:ekr.20040930064232.2:(Added new expand/contract or go commands)
#@+node:ekr.20041004095703:(Added support for readFromString to fileLikeObject)
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""
    
    @others
#@nonl
#@+node:ekr.20050404151753: ctor
def __init__(self,fromString=None):

    # New in 4.2.1: allow the file to be inited from string s.
    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0
    
# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@nonl
#@-node:ekr.20050404151753: ctor
#@+node:ekr.20050404151753.1:clear
def clear (self):
    
    self.list = []


#@-node:ekr.20050404151753.1:clear
#@+node:ekr.20050404151753.2:close
def close (self):
    
    pass
    
    # The StringIo version free's the memory buffer.
#@nonl
#@-node:ekr.20050404151753.2:close
#@+node:ekr.20050404151753.3:flush
def flush (self):
    
    pass
#@nonl
#@-node:ekr.20050404151753.3:flush
#@+node:ekr.20050404151753.4:get & getvalue
def get (self):

    return ''.join(self.list)
    
getvalue = get # for compatibility with StringIo
#@-node:ekr.20050404151753.4:get & getvalue
#@+node:ekr.20050404151753.5:readline
def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
#@nonl
#@-node:ekr.20050404151753.5:readline
#@+node:ekr.20050404151753.6:write
def write (self,s):
    
    if s:
        self.list.append(s)
#@-node:ekr.20050404151753.6:write
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@-node:ekr.20041004095703:(Added support for readFromString to fileLikeObject)
#@+node:ekr.20041024090552:(Bernhard Mulder: Added support for Ada)
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@+node:bwmulder.20041023131509:ada keywords
ada_keywords = [
    "abort",       "else",       "new",        "return",
    "abs",         "elsif",      "not",        "reverse",
    "abstract",    "end",        "null",
    "accept",      "entry",      "select",
    "access",      "exception",  "separate",
    "aliased",     "exit",       "of",         "subtype",
    "all",                       "or",
    "and",         "for",        "others",     "tagged",
    "array",       "function",   "out",        "task",
    "at",                                      "terminate",
                   "generic",    "package",    "then",
    "begin",       "goto",       "pragma",     "type",
    "body",                      "private",
                   "if",         "procedure",
    "case",        "in",         "protected",  "until",
    "constant",    "is",                       "use",
                                 "raise",
    "declare",                   "range",      "when",
    "delay",       "limited",    "record",     "while",
    "delta",       "loop",       "rem",        "with",
    "digits",                    "renames",
    "do",          "mod",        "requeue",    "xor"
   ]
#@nonl
#@-node:bwmulder.20041023131509:ada keywords
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("Ada", "ada"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("Forth", "forth"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex")
   ]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Pascal","pascal"),
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@-node:ekr.20041024090552:(Bernhard Mulder: Added support for Ada)
#@+node:ekr.20041025145856:(Added keyboard shortcuts to find panel)
#@+node:ekr.20041025145856.1:What I did
@killcolor

- Tab toggles between the Search to the Replace areas.
- Control-Tab inserts a tab.
- Added hot keys for all settings.  Use Alt-x to activate hot key x.
  (The Enter key activates the Find button.)
- As usual, Alt-F4 dismisses the Find panel.

To do next:  allow all search settings and commands to be activated from the status line.
#@nonl
#@-node:ekr.20041025145856.1:What I did
#@+node:ekr.20041025152343:class underlinedTkButton
class underlinedTkButton:
    
    @others
#@nonl
#@+node:ekr.20041025152712:__init__
def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    << set self.hotKey if '&' is in the string >>

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces
#@nonl
#@+node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
index = text.find('&')

if index > -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]
#@nonl
#@-node:ekr.20041025152712.2:<< set self.hotKey if '&' is in the string >>
#@-node:ekr.20041025152712:__init__
#@+node:ekr.20041026080125:bindHotKey
def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("<Alt-%s>" % key,self.callback)
#@-node:ekr.20041026080125:bindHotKey
#@+node:ekr.20041025152717:callback
# The hot key has been hit.  Call the button's command.

def callback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
#@-node:ekr.20041025152717:callback
#@-node:ekr.20041025152343:class underlinedTkButton
#@+node:ekr.20031218072017.3898:Birth & death
#@+node:ekr.20031218072017.3899:__init__
def __init__(self,c,resizeable=False,title=None):

    # g.trace("leoTkinterFind",c)
    
    # Init the base classes...
    leoFind.leoFind.__init__(self,c,title=title)
    leoTkinterDialog.leoTkinterDialog.__init__(self,c,self.title,resizeable)
    
    if g.app.unitTesting:return

    << create the tkinter intVars >>
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    
    self.createTopFrame() # Create the outer tkinter dialog frame.
    self.createFrame()
    self.init(c) # New in 4.3: init only once.
#@nonl
#@+node:ekr.20031218072017.3900:<< create the tkinter intVars >>
self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()
#@nonl
#@-node:ekr.20031218072017.3900:<< create the tkinter intVars >>
#@-node:ekr.20031218072017.3899:__init__
#@+node:ekr.20031218072017.3901:destroySelf
def destroySelf (self):
    
    self.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3901:destroySelf
#@+node:ekr.20031218072017.3902:find.createFrame
def createFrame (self):

    # Create the find panel...
    outer = Tk.Frame(self.frame,relief="groove",bd=2)
    outer.pack(padx=2,pady=2)

    << Create the Find and Change panes >>
    << Create four columns of radio and checkboxes >>
    << Create two rows of buttons >>
    
    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("<1>",  self.resetWrap)
        widget.bind("<Key>", self.resetWrap)
        widget.bind("<Control-a>",self.selectAll)
        #widget.bind(g.virtual_event_name("SelectAll"),self.selectAll)
    
    for widget in (outer, self.find_ctrl, self.change_ctrl):
        widget.bind("<Key-Return>", findButtonCallback)
        widget.bind("<Key-Escape>", self.onCloseWindow)
    
    self.top.protocol("WM_DELETE_WINDOW", self.onCloseWindow)
#@+node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=4,width=20)
self.change_ctrl = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=4,width=20)
<< Bind Tab and control-tab >>

fBar = Tk.Scrollbar(fpane,name='findBar')
cBar = Tk.Scrollbar(cpane,name='changeBar')

# Add scrollbars.
for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
    txt['yscrollcommand'] = bar.set
    bar['command'] = txt.yview
    bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="both")
ftxt.pack(side="right", expand=1, fill="both")
#@nonl
#@+node:ekr.20041026092141:<< Bind Tab and control-tab >>
def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("<Tab>",toChange)
ctxt.bind("<Tab>",toFind)
ftxt.bind("<Control-Tab>",insertFindTab)
ctxt.bind("<Control-Tab>",insertChangeTab)
#@nonl
#@-node:ekr.20041026092141:<< Bind Tab and control-tab >>
#@-node:ekr.20031218072017.3904:<< Create the Find and Change panes >>
#@+node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.dict["radio-find-type"],"P&Lain Search","plain-search"),  
    (self.dict["radio-find-type"],"&Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"&Script Search","script-search")]
checkLists[0] = [
    ("Scrip&t Change",self.dict["script_change"])]
checkLists[1] = [
    ("&Whole Word",  self.dict["whole_word"]),
    ("&Ignore Case", self.dict["ignore_case"]),
    ("Wrap &Around", self.dict["wrap"]),
    ("&Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"&Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &Headline Text", self.dict["search_headline"]),
    ("Search &Body Text",     self.dict["search_body"]),
    ("&Mark Finds",           self.dict["mark_finds"]),
    ("Mark &Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("<1>", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3903:<< Create four columns of radio and checkboxes >>
#@+node:ekr.20031218072017.3905:<< Create two rows of buttons >>
# Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

def findButtonCallback(event=None):
    __pychecker__ = '--no-argsused' # the event param must be present.
    self.findButton()
    return 'break'

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=findButtonCallback) # The default.
findButton.pack(pady="1p",padx="25p",side="left")

contextBox = underlinedTkButton("check",buttons,
    anchor="w",text="Show Conte&xt",variable=self.dict["batch"])
contextBox.button.pack(pady="1p",side="left",expand=1)
contextBox.bindHotKey(ftxt)
contextBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Fin&d All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Chan&Ge",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, &Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)
    
changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)
#@nonl
#@-node:ekr.20031218072017.3905:<< Create two rows of buttons >>
#@-node:ekr.20031218072017.3902:find.createFrame
#@+node:ekr.20031218072017.2059:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:find.init
#@-node:ekr.20031218072017.3898:Birth & death
#@-node:ekr.20041025145856:(Added keyboard shortcuts to find panel)
#@+node:ekr.20041028161201:(Investigated Initing Pmw & Tk)
#@+node:ekr.20031218072017.4049:createRootWindow & allies
def createRootWindow(self):

    """Create a hidden Tk root window."""

    if 0: # Use Tix.
        import Tix
        self.root = root = Tix.Tk()
        << fix problems with menus (XP) >>
    else: # Use Tkinter.
        self.root = root = Tk.Tk()

    root.title("Leo Main Window")
    root.withdraw()
    
    self.setDefaultIcon()
    if g.app.config:
        self.getDefaultConfigFont(g.app.config)
        
    root.withdraw()

    return root
#@nonl
#@+node:ekr.20031218072017.1856:setDefaultIcon
def setDefaultIcon(self):
    
    """Set the icon to be used in all Leo windows.
    
    This code does nothing for Tk versions before 8.4.3."""
    
    gui = self

    try:
        version = gui.root.getvar("tk_patchLevel")
        if g.CheckVersion(version,"8.4.3") and sys.platform == "win32": # 12/2/03
            # tk 8.4.3 or greater: load a 16 by 16 icon.
            path = g.os_path_join(g.app.loadDir,"..","Icons")
            if g.os_path_exists(path):
                theFile = g.os_path_join(path,"LeoApp16.ico")
                if g.os_path_exists(path):
                    self.bitmap = Tk.BitmapImage(theFile)
                else:
                    g.es("LeoApp16.ico not in Icons directory", color="red")
            else:
                g.es("Icons directory not found: "+path, color="red")
    except:
        print "exception setting bitmap"
        import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.1856:setDefaultIcon
#@+node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
def getDefaultConfigFont(self,config):
    
    """Get the default font from a new text widget."""

    if not self.defaultFontFamily:
        # WARNING: retain NO references to widgets or fonts here!
        t = Tk.Text()
        fn = t.cget("font")
        font = tkFont.Font(font=fn) 
        family = font.cget("family")
        self.defaultFontFamily = family[:]
        # print '***** getDefaultConfigFont',repr(family)

    config.defaultFont = None
    config.defaultFontFamily = self.defaultFontFamily
#@nonl
#@-node:ekr.20031218072017.2186:tkGui.getDefaultConfigFont
#@+node:ekr.20041125050302:<< fix problems with menus (XP) >>
try:
    import WmDefault
    WmDefault.setup(root)
    d = {'activebackground':'DarkBlue','activeforeground':'white'} # works
    # d = {'activebackground':'','activeforeground':''} # doesn't work
    WmDefault.addoptions(root,d)
except ImportError:
    g.trace("can not import WMDefault")
#@nonl
#@-node:ekr.20041125050302:<< fix problems with menus (XP) >>
#@-node:ekr.20031218072017.4049:createRootWindow & allies
#@-node:ekr.20041028161201:(Investigated Initing Pmw & Tk)
#@+node:ekr.20041029111407:(Added support for g.app.debugSwitch in es_exception)
@ It's not clear that this support is so useful for debugging scripts...
#@nonl
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@nonl
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@nonl
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@-node:ekr.20041029111407:(Added support for g.app.debugSwitch in es_exception)
#@+node:ekr.20041107093219:(Added support for Forth)
@nocolor

Forth support by David McNab, <david@freenet.org.nz>.

Changes by EKR:
    
- Look for extension files in plugins folder.
- Moved data structures into leoColor class.
- Suppress message about extra words during unit testing and in batch mode.
- Created this project node.

@color
#@nonl
#@+node:ekr.20041107104918:In leoApp.py
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20041107104918:In leoApp.py
#@+node:ekr.20041107103007:In leoColor.py
#@+node:ekr.20041107093834:forth keywords
# Default forth keywords: extended by leo-forthwords.txt.
forth_keywords = [
    "variable", "constant", "code", "end-code",
    "dup", "2dup", "swap", "2swap", "drop", "2drop",
    "r>", ">r", "2r>", "2>r",
    "if", "else", "then",
    "begin", "again", "until", "while", "repeat",
    "v-for", "v-next", "exit",
    "meta", "host", "target", "picasm", "macro",
    "needs", "include",
    "'", "[']",
    ":", ";",
    "@", "!", ",", "1+", "+", "-",
    "<", "<=", "=", ">=", ">",
    "invert", "and", "or", 
    ]

# Forth words which define other words: extended by leo-forthdefwords.txt.
forth_definingwords = [
    ":", "variable", "constant", "code",
    ]

# Forth words which start strings: extended by leo-forthstringwords.txt.
forth_stringwords = [
    's"', '."', '"', '."',
    'abort"',
    ]

# Forth words to be rendered in boldface: extended by leo-forthboldwords.txt.
forth_boldwords = [ ]

# Forth words to be rendered in italics: extended by leo-forthitalicwords.txt.
forth_italicwords = [ ]

# Forth bold-italics words: extemded leo-forthbolditalicwords.txt if present
# Note: on some boxen, bold italics may show in plain bold.
forth_bolditalicwords = [ ]
#@nonl
#@-node:ekr.20041107093834:forth keywords
#@+node:ekr.20041107094252:<< extend forth words from files >>
# Associate files with lists: probably no need to edit this.
forth_items = (
    (self.forth_definingwords, "leo-forthdefwords.txt", "defining words"),
    (self.forth_keywords, "leo-forthwords.txt", "words"),
    (self.forth_stringwords, "leo-forthstringwords.txt", "string words"),
    (self.forth_boldwords, "leo-forthboldwords.txt", "bold words"),
    (self.forth_bolditalicwords, "leo-forthbolditalicwords.txt", "bold-italic words"),
    (self.forth_italicwords, "leo-forthitalicwords.txt", "italic words"),
)

# Add entries from files (if they exist) and to the corresponding wordlists.
for (lst, path, typ) in forth_items:
    try:
        extras = []
        path = g.os_path_join(g.app.loadDir,"..","plugins",path) # EKR.
        for line in file(path).read().strip().split("\n"):
            line = line.strip()
            if line and line[0] != '\\':
                extras.append(line)
        if extras:
            if 0: # I find this annoying.  YMMV.
                if not g.app.unitTesting and not g.app.batchMode:
                    print "Found extra forth %s" % typ + ": " + " ".join(extras)
            lst.extend(extras)
    except IOError:
        # print "Not found",path
        pass
#@nonl
#@-node:ekr.20041107094252:<< extend forth words from files >>
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@+node:ekr.20031218072017.1896:doNormalState
## To do: rewrite using dynamically generated tables.

def doNormalState (self,s,i):
    
    __pychecker__ = 'maxlines=500'

    ch = s[i] ; state = "normal"
    assert(type(ch)==type(u""))

    if ch in string.ascii_letters or ch == '_' or (
        (ch == '\\' and self.language=="latex") or
        (ch in '/&<>' and self.language=="html") or
        (ch == '$' and self.language=="rapidq") or
        (self.language == 'forth' and ch in "`~!@#$%^&*()_+-={}|[];':\",./<>?")
    ):
        << handle possible keyword >>
    elif g.match(s,i,self.lb):
        i = self.doNowebSecRef(s,i)
    elif ch == '@':
        << handle at keyword >>
    elif g.match(s,i,self.single_comment_start):
        << handle single-line comment >>
    elif g.match(s,i,self.block_comment_start):
        << start block comment >>
    elif ch == '%' and self.language=="cweb":
        << handle latex line >>
    elif self.language=="latex":
        << handle latex normal character >>
    # ---- From here on self.language != "latex" -----
    elif ch in self.string_delims:
        << handle string >>
    elif ch == '#' and self.has_pp_directives:
        << handle C preprocessor line >>
    elif self.language == "php" and (g.match(s,i,"<") or g.match(s,i,"?")):
        # g.trace("%3d" % i,php_re.match(s,i),s)
        << handle special php keywords >>
    elif ch == ' ':
        << handle blank >>
    elif ch == '\t':
        << handle tab >>
    else:
        << handle normal character >>

    if 0: # This can fail harmlessly when using wxPython plugin.  Don't know exactly why.
        g.trace(self.progress,i,state)
        assert(self.progress < i)
    return i,state
#@nonl
#@+node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1898:<< handle possible  keyword >>
if self.language == "latex":
    << handle possible latex keyword >>
elif self.language == "html":
    << handle possible html keyword >>
elif self.language == "forth":
    << handle possible forth keyword >>
else:
    << handle general keyword >>
i = j
#@nonl
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
    if i + 1 < len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.1900:<< handle possible html keyword >>
if g.match(s,i,"<!---") or g.match(s,i,"<!--"):
    if g.match(s,i,"<!---"): k = 5
    else: k = 4
    self.tag("comment",i,i+k)
    j = i + k ; state = "blockComment"
elif g.match(s,i,"<"):
    if g.match(s,i,"</"): k = 2
    else: k = 1
    j = self.skip_id(s,i+k)
    self.tag("keyword",i,j)
elif g.match(s,i,"&"):
    j = self.skip_id(s,i+1,';')
    self.tag("keyword",i,j)
elif g.match(s,i,"/>"):
    j = i + 2
    self.tag("keyword",i,j)
elif g.match(s,i,">"):
    j = i + 1
    self.tag("keyword",i,j)
else:
    j = i + 1
#@-node:ekr.20031218072017.1900:<< handle possible html keyword >>
#@+node:ekr.20031218072017.1901:<< handle general keyword >>
if self.language == "rapidq":
    j = self.skip_id(s,i+1,chars="$")
elif self.language == "rebol":
    j = self.skip_id(s,i+1,chars="-~!?")
elif self.language in ("elisp","css"):
    j = self.skip_id(s,i+1,chars="-")
else:
    j = self.skip_id(s,i)

word = s[i:j]
if not self.case_sensitiveLanguage:
    word = word.lower()

if word in self.keywords:
    self.tag("keyword",i,j)
elif self.language == "php":
    if word in self.php_paren_keywords and g.match(s,j,"()"):
        self.tag("keyword",i,j+2)
        j += 2
#@nonl
#@-node:ekr.20031218072017.1901:<< handle general keyword >>
#@+node:ekr.20041107093219.3:<< handle possible forth keyword >>
j = self.skip_id(s,i+1,chars="`~!@#$%^&*()-_=+[]{};:'\\\",./<>?")
word = s[i:j]

#print "word=%s" % repr(word)

if not self.case_sensitiveLanguage:
    word = word.lower()

if self.nextForthWordIsNew:
    #print "trying to bold the defined word '%s'" % word
    self.tag("bold", i, j)
    self.nextForthWordIsNew = False
else:
    if word in self.forth_definingwords:
        self.nextForthWordIsNew = True
    
    if word in self.forth_boldwords:
        self.tag("bold", i, j)
    elif word in self.forth_bolditalicwords:
        self.tag("bolditalic", i, j)
    elif word in self.forth_italicwords:
        self.tag("italic", i, j)
    elif word in self.forth_stringwords:
        self.tag("keyword", i, j-1)
        i = j - 1
        j, state = self.skip_string(s,j-1)
        self.tag("string",i,j)
        word = ''
    elif word in self.keywords:
        self.tag("keyword",i,j)
#@nonl
#@-node:ekr.20041107093219.3:<< handle possible forth keyword >>
#@-node:ekr.20031218072017.1898:<< handle possible  keyword >>
#@+node:ekr.20031218072017.1902:<< handle at keyword >>
if self.language == "cweb":
    if g.match(s,i,"@(") or g.match(s,i,"@<"):
        << handle cweb ref or def >>
    else:
        word = self.getCwebWord(s,i)
        if word:
            << Handle cweb control word >>
        else:
            i,state = self.doAtKeyword(s,i)
else:
    i,state = self.doAtKeyword(s,i)
#@nonl
#@+node:ekr.20031218072017.1904:<< handle cweb ref or def >>
self.tag("nameBrackets",i,i+2)

# See if the line contains the right name bracket.
j = s.find("@>=",i+2)
k = g.choose(j==-1,2,3)
if j == -1:
    j = s.find("@>",i+2)

if j == -1:
    i += 2
else:
    self.tag("cwebName",i+2,j)
    self.tag("nameBrackets",j,j+k)
    i = j + k
#@-node:ekr.20031218072017.1904:<< handle cweb ref or def >>
#@+node:ekr.20031218072017.1903:<< Handle cweb control word >>
# Color and skip the word.
assert(self.language=="cweb")

j = i + len(word)
self.tag("keyword",i,j)
i = j

if word in ("@ ","@\t","@\n","@*","@**"):
    state = "doc"
elif word in ("@<","@(","@c","@d","@f","@p"):
    state = "normal"
elif word in ("@^","@.","@:","@="): # Ended by "@>"
    j = s.find("@>",i)
    if j > -1:
        self.tag("cwebName",i,j)
        self.tag("nameBrackets",j,j+2)
        i = j + 2
#@nonl
#@-node:ekr.20031218072017.1903:<< Handle cweb control word >>
#@-node:ekr.20031218072017.1902:<< handle at keyword >>
#@+node:ekr.20031218072017.1617:<< handle single-line comment >>
# print "single-line comment i,s:",i,s

if self.language == "cweb" and self.latex_cweb_comments:
    j = i + len(self.single_comment_start)
    self.tag("comment",i,j)
    self.doLatexLine(s,j,len(s))
    i = len(s)
elif self.language == "shell" and (i>0 and s[i-1]=='$'):
    i += 1 # '$#' in shell should not start a comment (DS 040113)
else:
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment"):
        self.tag("comment",i,j)
    i = j
#@nonl
#@-node:ekr.20031218072017.1617:<< handle single-line comment >>
#@+node:ekr.20031218072017.1619:<< start block comment >>
k = len(self.block_comment_start)

if not g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=i+k,colortag="comment"):
    self.tag("comment",i,i+k)

i += k ; state = "blockComment"
#@nonl
#@-node:ekr.20031218072017.1619:<< start block comment >>
#@+node:ekr.20031218072017.1905:<< handle latex line >>
self.tag("keyword",i,i+1)
i += 1 # Skip the %
self.doLatexLine(s,i,len(s))
i = len(s)
#@nonl
#@-node:ekr.20031218072017.1905:<< handle latex line >>
#@-node:ekr.20031218072017.1897:Valid regardless of latex mode
#@+node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1907:<< handle latex normal character >>
if self.language=="cweb":
    self.tag("latexModeBackground",i,i+1)
else:
    self.tag("latexBackground",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1907:<< handle latex normal character >>
#@-node:ekr.20031218072017.1906:Vaid only in latex mode
#@+node:ekr.20031218072017.1908:Valid when not in latex_mode
#@+node:ekr.20031218072017.1612:<< handle string >>
# g.trace(self.language)

if self.language == "python":

    delim = s[i:i+3]
    j, state = self.skip_python_string(s,i)
    if delim == '"""':
        # Only handle wiki items in """ strings.
        if not g.doHook("color-optional-markup",
            colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="string"):
            self.tag("string",i,j)
    else:
        self.tag("string",i,j)
    i = j

else:
    j, state = self.skip_string(s,i)
    self.tag("string",i,j)
    i = j
#@-node:ekr.20031218072017.1612:<< handle string >>
#@+node:ekr.20031218072017.1909:<< handle C preprocessor line >>
# 10/17/02: recognize comments in preprocessor lines.
j = i
while i < len(s):
    if g.match(s,i,self.single_comment_start) or g.match(s,i,self.block_comment_start):
        break
    else: i += 1

self.tag("pp",j,i)
#@nonl
#@-node:ekr.20031218072017.1909:<< handle C preprocessor line >>
#@+node:ekr.20031218072017.1910:<< handle special php keywords >>
if g.match(s.lower(),i,"<?php"):
    self.tag("keyword",i,i+5)
    i += 5
elif g.match(s,i,"?>"):
    self.tag("keyword",i,i+2)
    i += 2
else:
    i += 1

#@-node:ekr.20031218072017.1910:<< handle special php keywords >>
#@+node:ekr.20031218072017.1911:<< handle blank >>
if self.showInvisibles:
    self.tag("blank",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1911:<< handle blank >>
#@+node:ekr.20031218072017.1912:<< handle tab >>
if self.showInvisibles:
    self.tag("tab",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1912:<< handle tab >>
#@+node:ekr.20031218072017.1913:<< handle normal character >>
# self.tag("normal",i,i+1)
i += 1
#@nonl
#@-node:ekr.20031218072017.1913:<< handle normal character >>
#@-node:ekr.20031218072017.1908:Valid when not in latex_mode
#@-node:ekr.20031218072017.1896:doNormalState
#@-node:ekr.20041107103007:In leoColor.py
#@+node:ekr.20041107103007.1:In leoImport.py
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent):

    c = self.c ; u = c.undoer
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    << Read file into s >>
    # Create the top-level headline.
    undoData = u.beforeInsertNode(parent)
    p = parent.insertAsLastChild()
    if self.treeType == "@file":
        p.initHeadString("@file " + fileName)
    else:
        p.initHeadString(fileName)
    u.afterInsertNode(p,'Import',undoData)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        p.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p)
    elif ext == ".el":
        self.scanElispText(s,p)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,p)
    elif ext == ".java":
        self.scanJavaText(s,p,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,p)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p)
    elif ext == ".php":
        self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return p
#@nonl
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
#@nonl
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20041107094641:scanForthText
def scanForthText (self,s,parent):
    
    """Minimal forth scanner - leave it to user to create nodes as they see fit."""

    parent.setBodyStringOrPane("@ignore\n" + "@language forth\n" + self.rootLine + s)
#@nonl
#@-node:ekr.20041107094641:scanForthText
#@-node:ekr.20041107103007.1:In leoImport.py
#@+node:ekr.20041107103007.2:In leoTkinterPrefs.py
#@+node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
# Frame and title
w,target = gui.create_labeled_frame (outer,caption="Default Target Language")
w.pack(padx=2,pady=2,expand=1,fill="x")

# Frames for two columns of radio buttons
lt = Tk.Frame(target)
rt = Tk.Frame(target)
lt.pack(side="left")
rt.pack(side="right")

# Left column of radio buttons.
left_data = [
    ("ActionScript", "actionscript"),
    ("Ada", "ada"),
    ("C#",    "csharp"),
    ("C/C++", "c"),
    ("CSS",   "css"),
    ("CWEB",  "cweb"),
    ("elisp", "elisp"),
    ("Forth", "forth"),
    ("HTML",  "html"),
    ("Java",  "java"),
    ("LaTeX", "latex")
   ]

for text,value in left_data:
    button = Tk.Radiobutton(lt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")

# Right column of radio buttons.
right_data = [
    ("Pascal","pascal"),
    ("Perl", "perl"),
    ("Perl+POD",   "perlpod"),
    ("PHP",        "php"),
    ("Plain Text", "plain"),
    ("Python",     "python"),
    ("RapidQ",     "rapidq"),
    ("Rebol",      "rebol"),
    ("Shell",      "shell"),
    ("tcl/tk",     "tcltk")]

for text,value in right_data:
    button = Tk.Radiobutton(rt,anchor="w",text=text,
        variable=self.lang_var,value=value,command=self.set_lang)
    button.pack(fill="x")
#@nonl
#@-node:ekr.20031218072017.369:<< Create the Target Language frame >> frame
#@-node:ekr.20041107103007.2:In leoTkinterPrefs.py
#@-node:ekr.20041107093219:(Added support for Forth)
#@+node:ekr.20041029085429.1:(Improved Go To Line Number and Execute Script commands)
#@+node:ekr.20041111100436:Notes
@killcolor

What I did:

- Go To Line Number command now assumes the presently selected node is a script if there is no ancestor @file node.

- Execute Script command uses this new logic to select the proper node and line in a script if there is an error.

How did we ever live without this?

- Added sciptFind ivar and related logic to goToLineNumber and it allies.
#@nonl
#@-node:ekr.20041111100436:Notes
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@nonl
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@nonl
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,root=None,lines=None,n=None,scriptFind=False):
    
    __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@nonl
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@nonl
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@nonl
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
            
if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@nonl
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@-node:ekr.20041029085429.1:(Improved Go To Line Number and Execute Script commands)
#@+node:ekr.20041018194900:(Restored drawing/event hooks)
#@+node:ekr.20041111114148.1:What I did
Added the following back:
    
"boxclick1"     before click in +- box            c,p,v,event
"boxclick2"     after  click in +- box            c,p,v,event
"drag1"         before start of drag              c,p,v,event
"drag2"         after  start of drag              c,p,v,event
"dragging1"     before continuing to drag         c,p,v,event
"dragging2"     after  continuing to drag         c,p,v,event
"enddrag1"      before end of drag                c,p,v,event
"enddrag2"      after  end of drag                c,p,v,event

The following already existed.  I added v=p keyword params:

"iconclick1"    before single click in icon box   c,p,v,event
"iconclick2"    after  single click in icon box   c,p,v,event
"iconrclick1"   before right click in icon box    c,p,v,event
"iconrclick2"   after  right click in icon box    c,p,v,event
"icondclick1"   before double click in icon box   c,p,v,event
"icondclick2"   after  double click in icon box   c,p,v,event

Added documentation for the following:
    


Added leoPlugins.unregisterHandler and getHandlersFor tag for testing.

#@-node:ekr.20041111114148.1:What I did
#@+node:ekr.20041111125613:New plugins code
#@+node:ekr.20041111124831:getHandlersForTag
def getHandlersForTag(tags):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        result = []
        for tag in tags:
            fn = getHandlersForOneTag(tag) 
            result.append((tag,fn),)
        return result
    else:
        return getHandlersForOneTag(tags)

def getHandlersForOneTag (tag):

    global handlers

    bunch = handlers.get(tag)
    return bunch.fn
#@nonl
#@-node:ekr.20041111124831:getHandlersForTag
#@+node:ekr.20041111123313:unregisterHandler
def unregisterHandler(tags,fn):
    
    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            unregisterOneHandler(tag,fn)
    else:
        unregisterOneHandler(tags,fn)

def unregisterOneHandler (tag,fn):

    global handlers
    
    if 1: # New code
        bunches = handlers.get(tag)
        bunches = [bunch for bunch in bunches if bunch.fn != fn]
        handlers[tag] = bunches
    else:
        fn_list = handlers.get(tag)
        if fn_list:
            while fn in fn_list:
                fn_list.remove(fn)
            handlers[tag] = fn_list
            # g.trace(handlers.get(tag))
#@nonl
#@-node:ekr.20041111123313:unregisterHandler
#@-node:ekr.20041111125613:New plugins code
#@+node:ekr.20041111121907:Changed code
#@+node:ekr.20040803072955.99:Dragging
#@+node:ekr.20041111115908:endDrag
def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""
    
    c = self.c ; p = self.drag_p
    canvas = self.canvas
    if not event: return

    << set vdrag, childFlag >>
    if c.config.getBool("allow_clone_drags"):
        if not c.config.getBool("look_for_control_drag_on_mouse_down"):
            self.controlDrag = c.frame.controlKeyIsDown

    if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
        << drag p to vdrag >>
    elif self.trace and self.verbose:
        g.trace("Cancel drag")
    
    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None
#@+node:ekr.20040803072955.104:<< set vdrag, childFlag >>
x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()
#@nonl
#@-node:ekr.20040803072955.104:<< set vdrag, childFlag >>
#@+node:ekr.20041111114148:<< drag p to vdrag >>
if self.trace and self.verbose:
    g.trace("*** end drag   ***",\
        theId,x,y,p.headString(),vdrag.headString())
if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)
#@nonl
#@-node:ekr.20041111114148:<< drag p to vdrag >>
#@-node:ekr.20041111115908:endDrag
#@+node:ekr.20041111114944:startDrag
# This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    if self.trace and self.verbose:
        g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"
#@nonl
#@-node:ekr.20041111114944:startDrag
#@+node:ekr.20040803072955.100:onContinueDrag
def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            << scroll the canvas as needed >>
    except:
        g.es_event_exception("continue drag")
#@nonl
#@+node:ekr.20040803072955.101:<< scroll the canvas as needed >>
# Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y < 0 or y > h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y < 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y < 0 and lo > 0.1) or (y > h and hi < 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.
#@nonl
#@-node:ekr.20040803072955.101:<< scroll the canvas as needed >>
#@-node:ekr.20040803072955.100:onContinueDrag
#@+node:ekr.20040803072955.102:onDrag
def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.102:onDrag
#@+node:ekr.20040803072955.103:onEndDrag
def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.103:onEndDrag
#@-node:ekr.20040803072955.99:Dragging
#@+node:ekr.20040803072955.79:onClickBoxClick
def onClickBoxClick (self,event):
    
    c = self.c
    
    if self.trace and self.verbose: g.trace()
    p = self.eventToPosition(event)
    if not p: return

    if not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
        if p.isExpanded(): p.contract()
        else:              p.expand()
        self.active = True
        # Schedule the redraw _before_ calling select.
        # This disables any call that would configure old text widgets.
        self.redraw()
        self.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
            
        c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='onClickBoxClick')
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
#@nonl
#@-node:ekr.20040803072955.79:onClickBoxClick
#@+node:ekr.20040803072955.80:Icon Box...
#@+node:ekr.20040803072955.81:onIconBoxClick
def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.
#@nonl
#@-node:ekr.20040803072955.81:onIconBoxClick
#@+node:ekr.20040803072955.89:onIconBoxRightClick
def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivate(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"
#@nonl
#@-node:ekr.20040803072955.89:onIconBoxRightClick
#@+node:ekr.20040803072955.82:onIconBoxDoubleClick
def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")
#@nonl
#@-node:ekr.20040803072955.82:onIconBoxDoubleClick
#@-node:ekr.20040803072955.80:Icon Box...
#@-node:ekr.20041111121907:Changed code
#@-node:ekr.20041018194900:(Restored drawing/event hooks)
#@+node:ekr.20041112062558:Added p=p param to all hooks containing v=v
@killcolor

Changed these hooks:

"bodyclick1", "bodyclick2",
"bodydclick1", "bodydclick2",
"bodyrclick1", "bodyrclick2",
"bodykey1", "bodykey2",
"command1", "command2",
"headclick1", "headclick2",
"headrclick1", "headrclick2",
"headkey1", "headkey2", 
"hyperclick1", "hyperclick2",
"hyperenter1", "hyperenter2",
"hyperleave1", "hyperleave2", 
"openwith1", "openwith2",
"menu1", "menu2", 
"recentfiles1", "recentfiles2",
"save1", "save2",
"select1", "select2", "select3",
"start2",
"unselect1", "unselect2",
"url1", "url2", 

"clear-mark", "set-mark", 
"color-optional-markup",
"create-popup-menu", 
"draw-outline-icon",
"draw-outline-node",
"draw-outline-text-box",
"draw-sub-outline", 
"init-color-markup",
"scan-directives", 
"draw-outline-box",
"enable-popup-menu-items",
"show-popup-menu",
#@nonl
#@-node:ekr.20041112062558:Added p=p param to all hooks containing v=v
#@+node:ekr.20041121092608:(Eliminated global find panel, inited from @settings)
#@+node:ekr.20041121121900:What I did
@killcolor

- Removed createGlobalsWindows: Leo has no more global windows!

- Each commander has its own find window.
    - It's title tells to what commander it applies.

- Ignore all find settings in getFindPanelSettings.  leoFind.init gets these from @settings.

- Removed all c ivars corresponding to leoFind ivars.
    - This eliminates the ugliest code in Leo.
    - Inits all leoFind ivars from @settings in init, an allie of the ctor.
    - Updates all the leoFind ivars in update_ivars, called just before doing any find.

- Removed the _flag suffix from leoFind ivars.
    - Another major mess cleaned up.

- Renamed find/change_text to find/change_ctrl to avoid name conflict.

@color
#@nonl
#@-node:ekr.20041121121900:What I did
#@+node:ekr.20031218072017.2059:find.init
def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    << set find/change widgets >>
    << set radio buttons from ivars >>
#@nonl
#@+node:ekr.20031218072017.2060:<< set find/change widgets >>
self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'<find pattern here>'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)
#@nonl
#@-node:ekr.20031218072017.2060:<< set find/change widgets >>
#@+node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    ("script_search","script-search")):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")
#@nonl
#@-node:ekr.20031218072017.2061:<< set radio buttons from ivars >>
#@-node:ekr.20031218072017.2059:find.init
#@+node:ekr.20031218072017.1460:find.update_ivars
def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s
#@nonl
#@-node:ekr.20031218072017.1460:find.update_ivars
#@+node:ekr.20031218072017.2064:getFindPanelSettings
def getFindPanelSettings (self):
    
    if self.getOpenTag("<find_panel_settings"):
        return # <find_panel_settings/> seen.
    
    # New in 4.3: ignore all pre-4.3 find settings.
    while 1:
        if   self.matchTag("batch="):           self.getDqBool()
        elif self.matchTag("ignore_case="):     self.getDqBool()
        elif self.matchTag("mark_changes="):    self.getDqBool()
        elif self.matchTag("mark_finds="):      self.getDqBool()
        elif self.matchTag("node_only="):       self.getDqBool()
        elif self.matchTag("pattern_match="):   self.getDqBool()
        elif self.matchTag("reverse="):         self.getDqBool()
        elif self.matchTag("script_change="):   self.getDqBool()
        elif self.matchTag("script_search="):   self.getDqBool()
        elif self.matchTag("search_headline="): self.getDqBool()
        elif self.matchTag("search_body="):     self.getDqBool()
        elif self.matchTag("selection_only="):  self.getDqBool()
        elif self.matchTag("suboutline_only="): self.getDqBool()
        elif self.matchTag("whole_word="):      self.getDqBool()
        elif self.matchTag("wrap="):            self.getDqBool()
        elif self.matchTag(">"): break
        else: self.getUnknownTag() # Ignore all other tags.
    # Allow only <find_string> or <find_string/>
    if self.getOpenTag("<find_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</find_string>")
    # Allow only <change_string> or <change_string/>
    if self.getOpenTag("<change_string>"): 
        pass
    else:
        self.getEscapedString() ; self.getTag("</change_string>")
    self.getTag("</find_panel_settings>")
#@nonl
#@-node:ekr.20031218072017.2064:getFindPanelSettings
#@-node:ekr.20041121092608:(Eliminated global find panel, inited from @settings)
#@+node:ekr.20041128172446:(added a 3rd party extension mechanism)
#@+node:ekr.20041219065925:Notes
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2871977

- (done) created g.app.extensionsDir

- (done) created g.importModule and g.importExtension.

Now you can put Pmw into the extensions directory and have Leo easily import it from there.

Doing so gives you a way to add Pmw easily and any other 3rd party libs Leo ever needs.
#@nonl
#@-node:ekr.20041219065925:Notes
#@+node:ekr.20041219095213:import wrappers
@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
#@nonl
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
            except Exception:
                g.es("unexpected exception in g.import",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally:
            if theFile: theFile.close()
    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@-node:ekr.20041128172446:(added a 3rd party extension mechanism)
#@+node:ekr.20041231112215:(Patched computeHomeDir to handle references to other vars)
#@+node:ekr.20041231112215.1:Original posting
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2915750
By: cmbanker

The HOME environment variable on windows machines is often a referrence to yet
another environment variable.  i.e.  %HOME% --> %USERENVIRONMENT% --> "C:\Documents
and Settings\...."

The fix: Patch computeHomeDir() to test the first retrieval of the %HOME% var and grab
it's results if it is infact another enviroment variable.

@color

def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = startupEncoding()
    dotDir = g.os_path_abspath('./',encoding)
    
    home = os.getenv('HOME',default=dotDir)
    
    #verify that we've not got an indirect reference to true home
    if (home[0]=='%') and ( home[-1]=='%'):
	    #yep, must be a win32 machine - get this one
	    home = os.getenv(home[1:-1],default=dotDir)


    home = g.os_path_abspath(home,encoding)
    
    if (
        not home or
        not g.os_path_exists(home,encoding) or
        not g.os_path_isdir(home,encoding)
    ):
        home = None

    return home
#@-node:ekr.20041231112215.1:Original posting
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@-node:ekr.20041231112215:(Patched computeHomeDir to handle references to other vars)
#@+node:ekr.20050111082850:(Changes to plugin handling)
#@+node:ekr.20050111082850.1:What I did
@killcolor

- Used g.Bunch in handlers data structure.
- Use a stack to associate moduleNames with handlers.
    - loadOnePlugin pushes the plugin's short file on the stack.
    - callTagHandler pushes the handler's moduleName on the stack so
      calls to registerHandler, etc. inside handlers get associated with the proper module.

Note: at present unit tests are very difficult to test properly. UnloadOnePlugin
is not enough: simply deactivating all handers is not enough. For example, this
does undo Tk bindings.

- At the least, an 'unload' hook would be required to reverse the effect of the plugin.
- For now, I'll see if having registerHandler do nothing if g.app.unitTesting is in effect suffices.
#@nonl
#@-node:ekr.20050111082850.1:What I did
#@+node:ekr.20050111102926:Bugs fixed
@killcolor

Fixed bug in how iconBar was created that resulted in rowcol plugin working improperly.
#@nonl
#@-node:ekr.20050111102926:Bugs fixed
#@+node:ekr.20031218072017.1318:g.plugin_signon
def plugin_signon(module_name,verbose=False):
    
    # The things we do to keep pychecker happy... 
    m = g.Bunch(__name__='',__version__='')
    
    exec("import %s ; m = %s" % (module_name,module_name))
    
    if verbose: # or g.app.unitTesting:
        g.es("...%s.py v%s: %s" % (
            m.__name__, m.__version__, g.plugin_date(m)))

        print m.__name__, m.__version__
        
    app.loadedPlugins.append(module_name)
#@nonl
#@-node:ekr.20031218072017.1318:g.plugin_signon
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20031218072017.3443:registerHandler
def registerHandler(tags,fn):
    
    """ Register one or more handlers"""

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneHandler(tag,fn)
    else:
        registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):
    
    """Register one handler"""
    
    global handlers, loadingModuleNameStack
    try:
        moduleName = loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '<no module>'
    
    if 0:
        if g.app.unitTesting: print
        print '%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__)

    items = handlers.get(tag,[])
    if fn not in items:
        
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        items.append(bunch)
        
    # g.trace(tag) ; g.printList(items)
    handlers[tag] = items
#@nonl
#@-node:ekr.20031218072017.3443:registerHandler
#@-node:ekr.20050111082850:(Changes to plugin handling)
#@+node:ekr.20050119211822.2:(Added support for Leo-relative files)
#@+node:ekr.20050119211822:@url file:.\..\doc\LeoDocs.leo#Users Guide-->Chapter 8: Customizing Leo
#@-node:ekr.20050119211822:@url file:.\..\doc\LeoDocs.leo#Users Guide-->Chapter 8: Customizing Leo
#@+node:ekr.20050119220219:Notes
@killcolor

Actually, support already existed for them in getBaseDirectly!

What I did.

- Added a c keyword to getBaseDirectory.  It is never a good idea to use g.top().
- Added similar logic to os_path_join.

- Changed some stupid code in g.openWithFileName (called by @url logic):
    changed: fileName = g.os_path_join(os.getcwd(),fileName)
    to:      fileName = g.os_path_abspath(fileName)

MAYBE g.os_path_abspath should force '.' to mean c.openDir, but I kinda doubt
it. This could be asking for trouble.

OTOH, the various flavors of scanAllDirectives already do this.  Hmmmmmm.
#@-node:ekr.20050119220219:Notes
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):
    
    encoding = keys.get("encoding")

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]
    
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            g.trace(c.openDirectory)

    path = os.path.join(*uargs)
    
    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@nonl
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @languge logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1264:getBaseDirectory
# Handles the conventions applying to the "relative_path_base_directory" configuration option.

def getBaseDirectory(c=None):

    base = app.config.relative_path_base_directory

    if base and base == "!":
        base = app.loadDir
    elif base and base == ".":
        base = c.openDirectory

    # g.trace(base)
    if base and len(base) > 0 and g.os_path_isabs(base):
        return base # base need not exist yet.
    else:
        return "" # No relative base given.
#@-node:ekr.20031218072017.1264:getBaseDirectory
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        << stop the url after any whitespace >>
        # g.trace(url)
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,p=p,v=p)
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
    
#@nonl
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20050119211822.2:(Added support for Leo-relative files)
#@+node:ekr.20050122105757:(Implemented 'Undo Clear Recent Files')
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@-node:ekr.20050122105757:(Implemented 'Undo Clear Recent Files')
#@+node:ekr.20050119225135:(Implemented delayed focus scheme)
#@+node:ekr.20050120091434:What I did
@killcolor

The original problem with the UNL plugin not staying on top was that button-1
was bound to OnActivateTree, which called g.app.gui.set_focus.

However, there was another problem, the idle-time code in the status line logic
was also messing with the focus. It turns out that repeatedly calling
g.app.gui.set_focus is a bad idea: it interferes with opening new windows.

To deal with this I basically rewrote all the code that sets focus. The new code
replaces direct calls to g.app.gui.set_focus with calls to frame.bodyWantsFocus,
frame.statusLineWantsFocus, frame.treeWantsFocus and frame.logWantsFocus.
Actually, they all do the same thing, but using different methods improves
traces.

This is an excellent pattern. Rather than setting the focus directly, these
xWantsFocus methods merely signal their intension to set the focus. This allows
very complex logic to be hidden in leoTkinterFrame.set_focus.

leoTkinterFrame.set_focus is indeed complex. It took me several hours to get it
just right. It queues up a 'one-shot' callback. That is, at most one copy of the
callback is ever waiting to be executed. Furthermore, the callback is only
queued for execution at the result of a call to xWantsFocus; it is never run
automatically at idle time. Finally, even when executed, the callback does
nothing if the last requested commander (in the new ivar, g.app.wantedFocus)
does not match the commander to which the callback was bound. These checks allow
the UNL plugin to open a window properly and keep it topmost :-)

This is a big step forward for Leo. Using delayed focus methods ensures that the
body pane always has focus unless the code has a specific, positive reason for
the focus to be elsewhere. This was difficult (or rather impossible) to do with
the old code: there are _many_ Tk calls that can affect the focus. Moreover, it
minimizes calls to g.app.gui.set_focus.

Oh yes, one more thing. All the new methods support a 'tag' keyword argument.
This is typically set to the name of the routine in which the call takes place.
It is a big help in making sense of traces.

More details:
- 'later' keyword arg
- eliminates most calls to g.app.gui.set_focus
- A case could be made for using a single, global one-shot callback in g.app.gui.set_focus.
- Stresses Tk much less.
- A problem with losing data in test.leo.
#@nonl
#@-node:ekr.20050120091434:What I did
#@+node:ekr.20031218072017.2373:set_focus (app.gui)
def set_focus(self,c,widget,tag=''):
    
    __pychecker__ = '--no-argsused' # c and tag not used at present.
    
    """Put the focus on the widget."""
    
    # g.trace(tag,widget)
    
    # g.trace(c.frame.top.wm_stackorder())
    
    if widget:
        widget.focus_set()

    if 0: # Causes a weird problem on some machines.
        if c.frame.top:
            focus = c.frame.top.focus_displayof()
            if focus != widget:
                widget.focus_set()
#@nonl
#@-node:ekr.20031218072017.2373:set_focus (app.gui)
#@+node:ekr.20050120110418:Activation methods
@

N.B. There is NO WAY to keep track reliably of which window is on top!! Leo must
never ever depend on this knowledge!!
#@+node:ekr.20040803072955.105:OnActivate (tkTree)
def OnActivate (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        c = self.c
        << activate this window >>
    except:
        g.es_event_exception("activate tree")
#@nonl
#@+node:ekr.20040803072955.106:<< activate this window >>
current = c.currentPosition()

if p == current:
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus(self.canvas,later=False,tag='OnActivate')
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='OnActivate')

self.active = True
#@nonl
#@-node:ekr.20040803072955.106:<< activate this window >>
#@-node:ekr.20040803072955.105:OnActivate (tkTree)
#@+node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; gui = g.app.gui
        g.app.setLog(frame.log,"OnActivateBody")
        w = gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            self.tree.OnDeactivate()
        self.bodyWantsFocus(self.bodyCtrl,tag='OnActivateBody')
    except:
        g.es_event_exception("activate body")
#@nonl
#@-node:ekr.20031218072017.3975:OnActivateBody (tkFrame)
#@+node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
def OnActivateLeoEvent(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(self.c.shortFileName())

    try:
        g.app.setLog(self.log,"OnActivateLeoEvent")
    except:
        g.es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):
    
    if 0: # This causes problems on the Mac.
        try:
            g.app.setLog(None,"OnDeactivateLeoEvent")
        except:
            g.es_event_exception("deactivate Leo")
#@nonl
#@-node:ekr.20031218072017.2253:OnActivateLeoEvent, OnDeactivateLeoEvent
#@+node:ekr.20031218072017.3976:OnActivateTree
def OnActivateTree (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self
        g.app.setLog(frame.log,"OnActivateTree")
        if 0: # Do NOT do this here!
            # OnActivateTree can get called when the tree gets DE-activated!!
            frame.bodyWantsFocus(frame.bodyCtrl,tag='OnActivateTree')
            
    except:
        g.es_event_exception("activate tree")
#@-node:ekr.20031218072017.3976:OnActivateTree
#@+node:ekr.20031218072017.4045:tkLog.onActivateLog
def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus(self.logCtrl,tag='onActivateLog')
    except:
        g.es_event_exception("activate log")
#@nonl
#@-node:ekr.20031218072017.4045:tkLog.onActivateLog
#@-node:ekr.20050120110418:Activation methods
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        if self.trace and self.verbose:
            g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@

New in 4.3

Rather than calling g.app.gui.set_focus directly, the code calls
self.xWantsFocus. This defers to idle-time code in the status-line class.

N.B.  This code never calls select, so there can be no race condition here that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,self.c.shortFileName())
    self.set_focus(widget,later=later,tag=tag)
    
def logWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def statusLineWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def treeWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
    
def widgetWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
#@nonl
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''
    
    __pychecker__ = '--no-argsused' # tag good for debugging.

    c = self.c
    
    # g.trace(c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                self.outerFrame.after(100,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@+node:ekr.20041223104933:class statusLineClass
class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others
#@nonl
#@+node:ekr.20031218072017.3961: ctor
def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove")
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("<Button-1>", self.onActivate)
#@nonl
#@-node:ekr.20031218072017.3961: ctor
#@+node:ekr.20031218072017.3962:clear
def clear (self):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")
#@nonl
#@-node:ekr.20031218072017.3962:clear
#@+node:EKR.20040424153344:enable, disable & isEnabled
def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.frame.bodyWantsFocus(c.frame.bodyCtrl,tag='statusLine.disable')
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.frame.statusLineWantsFocus(t,tag='statusLine.ensable')
        t.focus_set()
    self.enabled = True
        
def isEnabled(self):
    return self.enabled
#@nonl
#@-node:EKR.20040424153344:enable, disable & isEnabled
#@+node:ekr.20041026132435:get
def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""
#@nonl
#@-node:ekr.20041026132435:get
#@+node:ekr.20041223114744:getFrame
def getFrame (self):
    
    return self.statusFrame
#@nonl
#@-node:ekr.20041223114744:getFrame
#@+node:ekr.20050120093555:onActivate
def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)
#@nonl
#@-node:ekr.20050120093555:onActivate
#@+node:ekr.20041223111916:pack & show
def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)

        # Register an idle-time handler to update the row and column indicators.
        self.statusFrame.after_idle(self.update)
        
show = pack
#@nonl
#@-node:ekr.20041223111916:pack & show
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()
#@nonl
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame)
#@+node:EKR.20040424154804:setFocus
if 0: # No longer used in 4.3.  Done as the result of statusLineWantsFocus.

    def setFocus (self):
    
        # Force the focus to the icon area.
        t = self.textWidget
        if t:
            t.focus_set()
#@nonl
#@-node:EKR.20040424154804:setFocus
#@+node:ekr.20041223111916.1:unpack & hide
def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack
#@nonl
#@-node:ekr.20041223111916.1:unpack & hide
#@+node:ekr.20031218072017.1733:update
def update (self):
    
    c = self.c ; body = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = body.index("insert")
    row,col = g.app.gui.getindex(body,index)

    if col > 0:
        s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col

    self.statusFrame.after(500,self.update)
#@nonl
#@-node:ekr.20031218072017.1733:update
#@-node:ekr.20041223104933:class statusLineClass
#@-node:ekr.20050119225135:(Implemented delayed focus scheme)
#@-node:ekr.20041228052527.2:New features...
#@+node:ekr.20041228052527.3:Plugins...
#@+node:EKR.20040424151321:(Improved status line plugin)
#@+node:ekr.20041002160323:What I did
@

Improved status_line.py in leoPlugins.leo
#@nonl
#@-node:ekr.20041002160323:What I did
#@+node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@+node:ekr.20031218072017.1801:__init__ (tkFrame)
def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title
    leoTkinterFrame.instances += 1
    self.c = None # Set in finishCreate.
    self.iconBar = None

    << set the leoTkinterFrame ivars >>
#@+node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
# "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None 
self.statusFrame = None 
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.revertHeadline = None # Previous headline text for abortEditLabel.
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None
#@nonl
#@-node:ekr.20031218072017.1802:<< set the leoTkinterFrame ivars >>
#@-node:ekr.20031218072017.1801:__init__ (tkFrame)
#@+node:ekr.20031218072017.3942:__repr__ (tkFrame)
def __repr__ (self):

    return "<leoTkinterFrame: %s>" % self.title
#@-node:ekr.20031218072017.3942:__repr__ (tkFrame)
#@+node:ekr.20041221122440:f.component & components
def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()
#@nonl
#@-node:ekr.20041221122440:f.component & components
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3944:f.createCanvas & helpers
def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas
#@nonl
#@+node:ekr.20041221071131:createPmwTreeCanvas
def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas
#@nonl
#@-node:ekr.20041221071131:createPmwTreeCanvas
#@+node:ekr.20041221071131.1:createTkTreeCanvas
def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
        if 1: # New in 4.3.
            << workaround for mouse-wheel problems >>
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("<Button-1>", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("<MouseWheel>", frame.OnMouseWheel)
    if 1:
        << do scrolling by hand in a separate thread >>
    
    # g.print_bindings("canvas",canvas)
    return canvas
    
#@nonl
#@+node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
# Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("<ButtonPress>",mapWheel,add=1)
#@nonl
#@-node:ekr.20050119210541:<< workaround for mouse-wheel problems >>
#@+node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
# New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('<Shift Button-3>',scrollDn)
    canvas.bind_all('<Shift Button-1>',scrollUp)
    canvas.bind_all('<Shift ButtonRelease-1>',off)
    canvas.bind_all('<Shift ButtonRelease-3>',off)
else: # Use plain click.
    canvas.bind_all( '<Button-3>',scrollDn)
    canvas.bind_all( '<Button-1>',scrollUp)
    canvas.bind_all( '<ButtonRelease-1>',off)
    canvas.bind_all( '<ButtonRelease-3>',off)
#@nonl
#@-node:ekr.20040709081208:<< do scrolling by hand in a separate thread >>
#@-node:ekr.20041221071131.1:createTkTreeCanvas
#@-node:ekr.20031218072017.3944:f.createCanvas & helpers
#@+node:ekr.20041221123325:createLeoSplitters & helpers
def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        << create Pmw splitters and their components >>
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2
#@nonl
#@+node:ekr.20041223130032:<< create Pmw splitters and their components >>
# Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')
#@nonl
#@-node:ekr.20041223130032:<< create Pmw splitters and their components >>
#@+node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221073427:createLeoPmwSplitter
def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame
#@nonl
#@-node:ekr.20041221073427:createLeoPmwSplitter
#@+node:ekr.20031218072017.3946:resizePanesToRatio
def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        << resize the Pmw panes >>
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)
#@nonl
#@+node:ekr.20050104084531:<< resize the Pmw panes >>
self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))
#@nonl
#@-node:ekr.20050104084531:<< resize the Pmw panes >>
#@-node:ekr.20031218072017.3946:resizePanesToRatio
#@+node:ekr.20041221075743:onPmwResizeSplitter1/2
@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)
#@nonl
#@-node:ekr.20041221075743:onPmwResizeSplitter1/2
#@-node:ekr.20041221195402:Pmw...
#@+node:ekr.20041221185246:Tk...
@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.
#@nonl
#@+node:ekr.20041221073427.1:createLeoTkSplitter
def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2
#@nonl
#@-node:ekr.20041221073427.1:createLeoTkSplitter
#@+node:ekr.20031218072017.3947:bindBar
def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("<B1-Motion>", self.onDragMainSplitBar)

    else:
        bar.bind("<B1-Motion>", self.onDragSecondarySplitBar)
#@nonl
#@-node:ekr.20031218072017.3947:bindBar
#@+node:ekr.20031218072017.3949:divideAnySplitter
# This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)
#@nonl
#@-node:ekr.20031218072017.3949:divideAnySplitter
#@+node:ekr.20031218072017.3950:divideLeoSplitter
# Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):
    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)
#@nonl
#@-node:ekr.20031218072017.3950:divideLeoSplitter
#@+node:ekr.20031218072017.3951:onDrag...
def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset < 3: offset = 3
    if offset > wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)
#@nonl
#@-node:ekr.20031218072017.3951:onDrag...
#@+node:ekr.20031218072017.3952:placeSplitter
def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)
#@nonl
#@-node:ekr.20031218072017.3952:placeSplitter
#@+node:ekr.20031218072017.998:Scrolling callbacks (frame)
def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)
#@nonl
#@-node:ekr.20031218072017.998:Scrolling callbacks (frame)
#@-node:ekr.20041221185246:Tk...
#@-node:ekr.20041221123325:createLeoSplitters & helpers
#@+node:ekr.20031218072017.3964:Destroying the frame
#@+node:ekr.20031218072017.1975:destroyAllObjects
def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    << clear all vnodes and tnodes in the tree >>

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)
#@nonl
#@+node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
# Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.
#@nonl
#@-node:ekr.20031218072017.1976:<< clear all vnodes and tnodes in the tree>>
#@-node:ekr.20031218072017.1975:destroyAllObjects
#@+node:ekr.20031218072017.3965:destroyAllPanels
def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()
#@nonl
#@-node:ekr.20031218072017.3965:destroyAllPanels
#@+node:ekr.20031218072017.1974:destroySelf
def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()
#@nonl
#@-node:ekr.20031218072017.1974:destroySelf
#@-node:ekr.20031218072017.3964:Destroying the frame
#@-node:ekr.20031218072017.3941: Birth & Death (tkFrame)
#@-node:EKR.20040424151321:(Improved status line plugin)
#@+node:ekr.20041022083005:(More flexible plugin manager)
# See @button Configurator in test.leo for the motivating example.
#@nonl
#@+node:ekr.20041114113029:getPluginModule
def getPluginModule (moduleName):
    
    global loadedModules
    
    return loadedModules.get(moduleName)
#@nonl
#@-node:ekr.20041114113029:getPluginModule
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):
    
    global loadedModules,loadingModuleNameStack
    
    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            print s ; g.es(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)
    
    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        try:
            # Indicate success only if init_result is True.
            init_result = result.init()
            # g.trace('%s.init() returns %s' % (moduleName,init_result))
            if init_result:
                loadedModules[moduleName] = result
            else:
                result = None
        except AttributeError:
            # No top-level init function.
            # Guess that the module was loaded correctly.
            loadedModules[moduleName] = result
        loadingModuleNameStack.pop()
        
    if result is None:
        s = 'can not load enabled %s plugin' % moduleName
        print s ; g.es(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        print s ; g.es(s,color="blue")
    
    return result
#@-node:ekr.20041113113140:loadOnePlugin
#@-node:ekr.20041022083005:(More flexible plugin manager)
#@+node:ekr.20050101065403:(Fixed problems loading plugins)
#@+node:ekr.20050101065403.1:What I did
@killcolor

*** Alas, using g.importExtension does not seem to work properly with Tkinter.

- plugins_menu.py now checks at runtime to see if the plugin has been successfully loaded before calling the topLevelMenu() function.

- Added pluginName keyword arg to g.importX functions.

    - All such functions now have pluginName and verbose keyword args.

- Used g.cantImport to print all messages in g.importX functions.
#@nonl
#@-node:ekr.20050101065403.1:What I did
#@+node:ekr.20041219095213:import wrappers
@ 1/6/05: The problem with Tkinter is that imp.load_module is equivalent to reload.

The solutions is easy: simply return sys.modules.get(moduleName) if moduleName is in sys.modules!
#@nonl
#@+node:ekr.20040917061619:g.cantImport
def cantImport (moduleName,pluginName=None,verbose=True):
    
    """Print a "Can't Import" message and return None."""

    # g.trace(verbose,moduleName,repr(pluginName))
    # if not pluginName: g.printStack()
    
    if verbose and not g.app.unitTesting:
        s = "Can not import %s" % moduleName
        if pluginName: s += " from plugin %s" % pluginName
        print s ; g.es(s,color="blue")

    return None
#@nonl
#@-node:ekr.20040917061619:g.cantImport
#@+node:ekr.20041219095213.1:g.importModule
def importModule (moduleName,pluginName=None,verbose=False):

    '''Try to import a module as Python's import command does.

    moduleName is the module's name, without file extension.'''
    
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)
            except Exception:
                g.es("unexpected exception in g.import",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally:
            if theFile: theFile.close()
    return module
#@nonl
#@-node:ekr.20041219095213.1:g.importModule
#@+node:ekr.20041219071407:g.importExtension
def importExtension (moduleName,pluginName=None,verbose=False):

    '''Try to import a module.  If that fails,
    try to import the module from Leo's extensions directory.

    moduleName is the module's name, without file extension.'''
    
    # g.trace(verbose,moduleName,pluginName)
    
    module = g.importModule(moduleName,pluginName=pluginName,verbose=False)

    if not module:
        module = g.importFromPath(moduleName,g.app.extensionsDir,
            pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20041219071407:g.importExtension
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20041219095213:import wrappers
#@-node:ekr.20050101065403:(Fixed problems loading plugins)
#@+node:ekr.20050101133638.1:(Fixed problem with destroyed ivars)
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 1930, in doHook
    return None # No return value
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 34, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 135, in doHandlersForTag
    ret = handle_fn(tag,keywords)
  File "C:\prog\leoCVS\leo\plugins\at_view.py", line 97, in icondclick2
    hs = self.current.headString()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 5110, in currentPosition
    if c._currentPosition:
AttributeError: Commands instance has no attribute '_currentPosition'
#@nonl
#@+node:ekr.20050101144712:Notes
@killcolor

Created callTagHandler.

This checks 'idle' hooks to make sure that any commander referenced by the 'c','new_c' or 'old_c' keywords still exists.
#@-node:ekr.20050101144712:Notes
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                if not hasattr(c,'frame'): return None
                if c.frame not in g.app.windowList:
                    return None # c has (or will be) destroyed.

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@nonl
#@-node:ekr.20050102094729:callTagHandler
#@+node:ekr.20031218072017.3442:doHandlersForTag
def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order.
    
    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        bunches = handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if handlers.has_key("all"):
        bunches = handlers.get('all')
        for bunch in bunches:
            callTagHandler(bunch,tag,keywords)

    return None
#@nonl
#@-node:ekr.20031218072017.3442:doHandlersForTag
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):
    if g.app.killed:
        return
    if tag == "start1":
        loadHandlers()

    return doHandlersForTag(tag,keywords)
#@nonl
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            print s ; g.es(s,color="blue")
        return None
         
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@-node:ekr.20050101133638.1:(Fixed problem with destroyed ivars)
#@+node:ekr.20041201072431:(Fixed several plugin bugs)
#@+node:ekr.20050104062535:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=2876473

I'm using 4.2 final, build 1.173, on Linux, and experience intermittent lockups
exactly as described here.

I've turned off almost all plugins, except for mod_tempfname, nodenavigator,
plugin_manager, and plugins_menu. It seems that I never experience the lockups
if I disable the hoist plugin, but that I do sometimes experience the lockups
if I enable hoist. Maybe a quick review of hoist might be in order to see if
anything looks suspicious. I believe hoist uses an idle handler, which I vaguely
feel might be able to lead to lockups of this sort.

Anyway, I'm not sure about this, but it is kind of frustrating to have leo lock
up totally, so hopefully this small data tidbit will help flush out this bug.
#@nonl
#@-node:ekr.20050104062535:Report
#@+node:ekr.20050104080957:Fixes
@killcolor

- leoPlugins.registerOneHandler wasn't working properly at all.  In effect, only the last registered hook was ever being remembered!

- leoPlugins.doHandlersForTag now executes the list of hook handlers for a particular tag (hook name) until one of the handlers returns a non-None result.  doHandersForTag no longer tries to "sort" handlers, so the order that the handlers are executed is the order in which they were registered.

I finally understand the concerns people have raised several times about hooks interfering with each other.  If two handlers try to return a non-None result only one of them will ever execute.  doHandlersForTag can't do much about this: a better solution would require more conceptual framework.  Not now...

3.  g.idleTimeHookHandler works for me as it stands.  N.B.  It may have changed since 4.2.  At present the code calls g.doHook('idle',...), which in turn calls doHandlersForTag('idle').  The code then queues itself up for re-execution after a nominal delay of at least 100 msec.  This queuing is done (eventually) by the Tk call g.app.root.after  This works for me on XP.  However, g.app.root.after_idle does tend to hang on XP.
#@-node:ekr.20050104080957:Fixes
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            print s ; g.es(s,color="blue")
        return None
         
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@+node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)
#@nonl
#@-node:ekr.20031218072017.4072:tkinterGui.setIdleTimeHook
#@+node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:EKR.20040602125018:enableIdleTimeHook
@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.
#@nonl
#@-node:EKR.20040602125018:enableIdleTimeHook
#@+node:EKR.20040602125018.1:disableIdleTimeHook
# Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False
#@nonl
#@-node:EKR.20040602125018.1:disableIdleTimeHook
#@+node:EKR.20040602125018.2:idleTimeHookHandler
# An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args & keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # New in 4.2 Beta 3. Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None
#@-node:EKR.20040602125018.2:idleTimeHookHandler
#@-node:ekr.20031218072017.1315:idle time functions (leoGlobals)
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                if not hasattr(c,'frame'): return None
                if c.frame not in g.app.windowList:
                    return None # c has (or will be) destroyed.

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@nonl
#@-node:ekr.20050102094729:callTagHandler
#@+node:ekr.20041001161108:doPlugins
def doPlugins(tag,keywords):
    if g.app.killed:
        return
    if tag == "start1":
        loadHandlers()

    return doHandlersForTag(tag,keywords)
#@nonl
#@-node:ekr.20041001161108:doPlugins
#@+node:ekr.20031218072017.3442:doHandlersForTag
def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order.
    
    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        bunches = handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if handlers.has_key("all"):
        bunches = handlers.get('all')
        for bunch in bunches:
            callTagHandler(bunch,tag,keywords)

    return None
#@nonl
#@-node:ekr.20031218072017.3442:doHandlersForTag
#@+node:ekr.20031218072017.3443:registerHandler
def registerHandler(tags,fn):
    
    """ Register one or more handlers"""

    import types

    if type(tags) in (types.TupleType,types.ListType):
        for tag in tags:
            registerOneHandler(tag,fn)
    else:
        registerOneHandler(tags,fn)

def registerOneHandler(tag,fn):
    
    """Register one handler"""
    
    global handlers, loadingModuleNameStack
    try:
        moduleName = loadingModuleNameStack[-1]
    except IndexError:
        moduleName = '<no module>'
    
    if 0:
        if g.app.unitTesting: print
        print '%6s %15s %25s %s' % (g.app.unitTesting,moduleName,tag,fn.__name__)

    items = handlers.get(tag,[])
    if fn not in items:
        
        bunch = g.Bunch(fn=fn,moduleName=moduleName,tag='handler')
        items.append(bunch)
        
    # g.trace(tag) ; g.printList(items)
    handlers[tag] = items
#@nonl
#@-node:ekr.20031218072017.3443:registerHandler
#@-node:ekr.20041201072431:(Fixed several plugin bugs)
#@+node:ekr.20050121163053:Fixed bug in Plugins Manager plugin: only triple-double quotes work in docstrings
#@-node:ekr.20050121163053:Fixed bug in Plugins Manager plugin: only triple-double quotes work in docstrings
#@+node:ekr.20050119190016.1:(Fixed conflict between settings panel conflicts and chapters plugin)
@
#@nonl
#@+node:ekr.20050121070708:Notes
@killcolor

With the latest CVS on Linux, attempting to access the preferences dialog when
the chapters plugin is enabled causes a blank window to appear in the Leo outline
pane.

Fix:
    
chapters.py requires that the canvas have a name ivar, so 
    
<< replace tree pane with settings tree >> now sets treeCanvas.name = '1'
#@nonl
#@-node:ekr.20050121070708:Notes
#@+node:ekr.20041225090725:<< replace tree pane with settings tree >>
tree = c.frame.component('tree')

# The new frame must be a child of splitter2Frame.
splitter2Frame = c.frame.component('splitter2Frame').getFrame()

# Create a Pmw scrolled canvas.
scrolledTreeCanvas = Pmw.ScrolledCanvas(splitter2Frame,
    hscrollmode='none',borderframe=3)

treeCanvas = scrolledTreeCanvas.component('canvas')
treeCanvas.configure(background='white')

# Set canvas.name ivar for chapters.py plugin.
# This must be a tab number.  The number '1' should work well enough.
treeCanvas.name = '1'

# Create the settingsTree component.
c.frame.componentClass(c,'settingsTree',scrolledTreeCanvas,self,
    tree.getPacker(),tree.getUnpacker())

c.frame.replaceTreePaneWithComponent('settingsTree')

self.tree = settingsTree(c,c.frame,treeCanvas,self)
self.tree.setColorFromConfig()
#@nonl
#@-node:ekr.20041225090725:<< replace tree pane with settings tree >>
#@-node:ekr.20050119190016.1:(Fixed conflict between settings panel conflicts and chapters plugin)
#@-node:ekr.20041228052527.3:Plugins...
#@-node:ekr.20040929081120:4.3 a1 projects
#@+node:ekr.20050125203059:4.3 a2 projects
#@+node:ekr.20050129112109: (Removed unused files)
@killcolor

- Removed following files and corresponding imports.
    - leoColorPanel.py
    - leoFontPanel.py
    - leoPrefs.py
    - leoTkinterColorPanels.py
    - leoTkinterFontPanel.py
    - leoTkinterPrefs.py

- moved colorNamesList from leoTkinterColorPanels.py to leoConfig.py

- Removed unused code from gui.Tkinter panels.
#@nonl
#@-node:ekr.20050129112109: (Removed unused files)
#@+node:ekr.20050125203059.1:Bugs
#@+node:ekr.20050125202008:(Fixed very old bug in Undo Insert Node )
#@+node:ekr.20041011092930:Report
http://sourceforge.net/forum/message.php?msg_id=2795653

By: Paul Paterson - paulpaterson
Bug: minor asymmetry with undo insert node  
2004-10-08 13:49
Very minor hangnail,

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. There is no longer a node selected in the tree so keyboard tree navigation etc commands don't work until you click on something with the mouse

In an ideal world, after #3 it should be as if #2 never happened.

----------------

http://sourceforge.net/forum/message.php?msg_id=2795656
By: paulpaterson

Hmm, there's something interesting here after all.

1. Select a node in the tree
2. Hit CTRL-I to insert a node
3. Hit CTRL-Z to undo the insert
4. Hit Hoist before clicking on anything

Now you are hoisted on the recently removed node! The node is dead but his memory
lives on ...
#@-node:ekr.20041011092930:Report
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    if 1: # In update...
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].current)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.editPosition(p)
        c.selectPosition(p)
    c.endUpdate()
    return p # for mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:EKR.20040526084140:undoInsertNodes
def undoInsertNodes (self):
    
    u = self ; c = u.c
    
    if 0: # Paste retaining clones can't be undone!
        # Remember the previous headline.
        old = c.currentPosition().headString()
    
    c.selectPosition(u.p)
    c.deleteOutline()

    if u.select:
        c.selectPosition(u.select)
        
    # New in 4.3: Support for Paste As Clone.
    if 0: # Paste retaining clones can't be undone!
        if u.headString:
            new = u.headString
            g.trace('old',old,'new',new)
            u.p.setHeadStringOrHeadline(new)
            u.headString=old
#@nonl
#@-node:EKR.20040526084140:undoInsertNodes
#@-node:ekr.20050125202008:(Fixed very old bug in Undo Insert Node )
#@+node:ekr.20050127090959:(Made sure to remove duplicates from recent files)
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@-node:ekr.20050127090959:(Made sure to remove duplicates from recent files)
#@+node:ekr.20050127090442:Fixed indentation problems in leoTkinterFind.py
@killcolor

> leo\src\leoTkinterFind.py:  
inconsistent use of tabs and spaces in indentation.
 
much of PMW has inconsistent use of tabs and spaces in indentation in various files .py 
#@nonl
#@-node:ekr.20050127090442:Fixed indentation problems in leoTkinterFind.py
#@+node:ekr.20050127091201:(Changed Help menu & related code to handle leoSettings.leo instead of leoConfig.leo)
#@+node:ekr.20031218072017.2943:leoConfig
def leoConfig (self):

    c = self
    name = 'leoSettings.leo'
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@nonl
#@-node:ekr.20031218072017.2943:leoConfig
#@-node:ekr.20050127091201:(Changed Help menu & related code to handle leoSettings.leo instead of leoConfig.leo)
#@+node:ekr.20050129114601.1:(Investigated recent files problems)
#@+node:ekr.20050130101623:Report
http://sourceforge.net/forum/message.php?msg_id=2966541
By: jasonic

"Recent Files"  is not remembering files after one closes all open leo sessions.

But it does update the "Recent Files" list while leo is open in the same session.
If one opens more files it adds them to the list. But close all files and Leo
forgets them all.

With chapters 0.66 enabled -- same behavior. 

Jason
#@nonl
#@-node:ekr.20050130101623:Report
#@+node:ekr.20050130101623.1:Added to @recentfile documentation
Warning: The following features of @recentfiles nodes are confusing and probably
will be changed:

- Leo does not save recent file information unless the open .leo file has an
@settings tree and an @recentfiles node within the @settings tree. That is, Leo
does not save recent files information in leoSettings.leo files.

- Changing the @rencentfiles node doesn't mark the Leo file as dirty, so if you
don't save the .leo file the recent files information will not be updated.
#@nonl
#@-node:ekr.20050130101623.1:Added to @recentfile documentation
#@+node:ekr.20041118084146:Setters (g.app.config)
#@+node:ekr.20041118084146.1:set (g.app.config)
def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','<no hash: %s>' % c.hash())
        g.trace(dkind,setting,kind,val)
#@nonl
#@-node:ekr.20041118084146.1:set (g.app.config)
#@+node:ekr.20041118084241:setString
def setString (self,c,setting,val):
    
    self.set(c,setting,"string",val)
#@nonl
#@-node:ekr.20041118084241:setString
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@-node:ekr.20041118084146:Setters (g.app.config)
#@-node:ekr.20050129114601.1:(Investigated recent files problems)
#@+node:ekr.20050126102846.2:(Improved queuing of log messages)
#@+node:ekr.20050130113848.2:What I did
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2960328

Symptom

Can not import messages were not being sent to the console, even though there is a call to es in g.cantImport.

What I did

- The code in g.es now checks for nullLog as well as log == None when deciding when to queue messages.

- g.openWithFileName now calls g.app.writeWaitingLog immediately after enabling the new log.

This writes the queued log messages in the proper order: a major advance in clarity.

- Added silent param to two methods.

This allows the 'reading settings from' message to be sent to the log instead of the default 'reading' message.
#@-node:ekr.20050130113848.2:What I did
#@+node:ekr.20050130134313:es & related logic...
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self):

    if self.log:
        for s,color in self.logWaiting:
            g.es(s,color=color,newline=0) # The caller must write the newlines.
        self.logWaiting = []
    else:
        print 'writeWaitingLog: still no log!'
#@nonl
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@-node:ekr.20050130134313:es & related logic...
#@+node:ekr.20050130133731:Added silent keyword to severl methods
#@+node:ekr.20031218072017.2297:open
def open(self,theFile,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c ; frame = c.frame
    # Read the entire file into the buffer
    self.fileBuffer = theFile.read() ; theFile.close()
    self.fileIndex = 0
    << Set the default directory >>
    self.topPosition = None
    c.beginUpdate()
    ok, ratio = self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
    frame.resizePanesToRatio(ratio,frame.secondary_ratio)
    if 0: # 1/30/04: this is useless.
        if self.topPosition: 
            c.setTopVnode(self.topPosition)
    c.endUpdate()
    # Delete the file buffer
    self.fileBuffer = ""
    return ok
#@nonl
#@+node:ekr.20031218072017.2298:<< Set the default directory >>
@ The most natural default directory is the directory containing the .leo file that we are about to open.  If the user has specified the "Default Directory" preference that will over-ride what we are about to set.
@c

theDir = g.os_path_dirname(fileName)

if len(theDir) > 0:
    c.openDirectory = theDir
#@nonl
#@-node:ekr.20031218072017.2298:<< Set the default directory >>
#@-node:ekr.20031218072017.2297:open
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        if not silent:
            << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20050130133731:Added silent keyword to severl methods
#@-node:ekr.20050126102846.2:(Improved queuing of log messages)
#@+node:ekr.20050130171901:(Fixed crasher in Change All command)
#@-node:ekr.20050130171901:(Fixed crasher in Change All command)
#@+node:ekr.20050201174750:(Fixed crasher in script button)
#@+node:ekr.20050202052911:Traceback
@killcolor

File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 2794, in write        
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 2794, in write    
    at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3060, in writeOpenFile
    at.putOpenNodeSentinel(root)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3060, in writeOpenFile
    at.putOpenNodeSentinel(root)
    
File "/Users/edream/leoCVS/leo/src/leoAtFile.py", line 3830, in putOpenNodeSentinel
    at.root.v.t.tnodeList.append(p.v.t)
    
AttributeError: 'tnode' object has no attribute 'tnodeList'
#@nonl
#@-node:ekr.20050202052911:Traceback
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try:
            # Pychecker doesn't like so many references in a row...
            t = at.root.v.t
            t.tnodeList.append(p.v.t)
        except AttributeError:
            pass # Do nothing.  We are creating a script.
#@nonl
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@-node:ekr.20050201174750:(Fixed crasher in script button)
#@+node:ekr.20050202062110:(Fixed print problems on the Mac)
# The button callback just calls c.executeScript
#@nonl
#@+node:ekr.20050202063852:What I did
@killcolor

The message 'command for widget 5' was a message from Tk saying in effect that no command was bound to the button.

Indeed, this was so: a recent botch in a change in mod_scripting.py prevented the binding.
#@nonl
#@-node:ekr.20050202063852:What I did
#@+node:ekr.20050201175325:(g.es called print on the Mac)
# The problem was simply some extra print statements. No idea why they were there.
#@nonl
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20031218072017.3963:put (leoTkinterFrame)
def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()
#@nonl
#@-node:ekr.20031218072017.3963:put (leoTkinterFrame)
#@+node:ekr.20041012083237.3:put and putnl (nullLog)
def put (self,s,color=None):
    if self.enabled:
        # g.trace('nullLog',s)
        g.rawPrint(s)

def putnl (self):
    if self.enabled:
        g.rawPrint("")
#@nonl
#@-node:ekr.20041012083237.3:put and putnl (nullLog)
#@+node:ekr.20041225063637.11:class logClass
class logClass:
    
    def __init__ (self,textWidget):
        self.textWidget = textWidget
        self.colorTags = []
        
    def put(self,s,color=None):
        w = self.textWidget
        << put s to w >>
        
    def putnl (self):
        w = self.textWidget
        if sys.platform == "darwin": print
        w.insert("end",'\n')
        w.see("end")
        w.update_idletasks()
#@nonl
#@+node:ekr.20041225063637.12:<< put s to w >>
if type(s) == type(u""):
    s = g.toEncodedString(s,g.app.tkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        w.tag_config(color,foreground=color)
    w.insert("end",s)
    w.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        w.tag_config("black",foreground="black")
    w.tag_add("black","end")
else:
    w.insert("end",s)

w.see("end")
w.update_idletasks()
#@nonl
#@-node:ekr.20041225063637.12:<< put s to w >>
#@-node:ekr.20041225063637.11:class logClass
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050201175325:(g.es called print on the Mac)
#@-node:ekr.20050202062110:(Fixed print problems on the Mac)
#@+node:ekr.20050202092849:leoTest.runTests now makes copies of all positions
@killcolor

This makes the test more robust in case of failure.
#@nonl
#@-node:ekr.20050202092849:leoTest.runTests now makes copies of all positions
#@+node:ekr.20050202080802:Fixed problems with unit test file paths
@killcolor

Changed the setup code for the import/export test cases so that it uses os.path.sep when it sees \\ in the test nodes.

With this change all unit tests pass.
#@nonl
#@-node:ekr.20050202080802:Fixed problems with unit test file paths
#@+node:ekr.20050202063852.1:(Made local config settings work again)
#@+node:ekr.20050203084346:Notes
@killcolor

*None* of the local settings were working(!!)

The old init code in the configSettings class had no chance of working. We must
use the full g.app.config.get logic.

Added some very simple unit tests to make sure the basics will never break
again so easily.
#@nonl
#@-node:ekr.20050203084346:Notes
#@+node:ekr.20041122094813:<<  class data >>
@others
    
# List of dictionaries to search.  Order not too important.
dictList = [ivarsDict,encodingIvarsDict,defaultsDict]

# Keys are commanders.  Values are optionsDicts.
localOptionsDict = {}

localOptionsList = []
    
# Keys are setting names, values are type names.
warningsDict = {} # Used by get() or allies.
#@nonl
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","Python"),
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","orientation","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041118062709:define encodingIvarsDict
encodingIvarsDict = {'_hash':'encodingIvarsDict'}

encodingIvarsData = (
    ("default_derived_file_encoding","string","utf-8"),
    ("new_leo_file_encoding","string","UTF-8"),
        # Upper case for compatibility with previous versions.
    ("tkEncoding","string",None),
        # Defaults to None so it doesn't override better defaults.
)
#@nonl
#@-node:ekr.20041118062709:define encodingIvarsDict
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@-node:ekr.20041122094813:<<  class data >>
#@+node:ekr.20041117083141:get & allies (g.app.config)
def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    found = False
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,found = self.getValFromDict(d,setting,kind,found)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,found = self.getValFromDict(d,setting,kind,found)
        if val is not None:
            kind = d.get('_hash','<no hash>')
            # g.trace(kind,setting,val)
            return val
                
    if 0: # Good for debugging leoSettings.leo.  This is NOT an error.
        # Don't warn if None was specified.
        if not found:
            g.trace("Not found:",setting)

    return None
#@nonl
#@+node:ekr.20041121143823:getValFromDict
def getValFromDict (self,d,setting,requestedType,found):
    
    __pychecker__ = '--no-argsused' # reqestedType not used.

    bunch = d.get(self.munge(setting))
    if bunch:
        # g.trace(setting,requestedType,bunch.toString())
        found = True ; val = bunch.val
        if val not in (u'None',u'none','None','none','',None):
            # g.trace(setting,val)
            return val,found

    # Do NOT warn if not found here.  It may be in another dict.
    return None,found
#@nonl
#@-node:ekr.20041121143823:getValFromDict
#@-node:ekr.20041117083141:get & allies (g.app.config)
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout
class redirectClass:
    
    """A class to redirect stdout and stderr."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@nonl
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):
    
    self.old = None
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@nonl
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return 

#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@nonl
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@nonl
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@nonl
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@nonl
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@nonl
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@nonl
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@nonl
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@nonl
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@nonl
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout
#@+node:ekr.20041118104831.1:class configSettings
class configSettings:
    
    """A class to hold config settings for commanders."""
    
    @others
#@nonl
#@+node:ekr.20041118104831.2:configSettings.__init__
def __init__ (self,c):
    
    self.c = c
    
    self.defaultBodyFontSize = g.app.config.defaultBodyFontSize
    self.defaultLogFontSize  = g.app.config.defaultLogFontSize
    self.defaultTreeFontSize = g.app.config.defaultTreeFontSize
    
    for key in g.app.config.encodingIvarsDict.keys():
        if key != '_hash':
            self.initEncoding(key)
        
    for key in g.app.config.ivarsDict.keys():
        if key != '_hash':
            self.initIvar(key)
#@nonl
#@+node:ekr.20041118104240:initIvar
def initIvar(self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.ivarsDict.get(key)
    ivarName = bunch.ivar
    val = g.app.config.get(c,ivarName,kind=None) # kind is ignored anyway.

    if val or not hasattr(self,ivarName):
        # g.trace('c.configSettings',c.shortFileName(),ivarName,val)
        setattr(self,ivarName,val)
#@nonl
#@-node:ekr.20041118104240:initIvar
#@+node:ekr.20041118104414:initEncoding
def initEncoding (self,key):
    
    c = self.c
    
    # N.B. The key is munged.
    bunch = g.app.config.encodingIvarsDict.get(key)
    encodingName = bunch.ivar
    encoding = g.app.config.get(c,encodingName,kind='string')

    if encoding or not hasattr(self,encodingName):
        # g.trace('c.configSettings',c.shortFileName(),encodingName,encoding)
        setattr(self,encodingName,encoding)

    if encoding and not g.isValidEncoding(encoding):
        g.es("bad %s: %s" % (encodingName,encoding))
#@nonl
#@-node:ekr.20041118104414:initEncoding
#@-node:ekr.20041118104831.2:configSettings.__init__
#@+node:ekr.20041118053731:Getters
def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag="configSetting"):
    return g.app.config.getFontFromParams(self.c,
        family,size,slant,weight,defaultSize=defaultSize,tag=tag)

def getRecentFiles (self):
    return g.app.config.getRecentFiles()

def get(self,setting,theType):
    return g.app.config.get(self.c,setting,theType)

def getBool      (self,setting): return g.app.config.getBool     (self.c,setting)
def getColor     (self,setting): return g.app.config.getColor    (self.c,setting)
def getDirectory (self,setting): return g.app.config.getDirectory(self.c,setting)
def getInt       (self,setting): return g.app.config.getInt      (self.c,setting)
def getFloat     (self,setting): return g.app.config.getFloat    (self.c,setting)
def getFontDict  (self,setting): return g.app.config.getFontDict (self.c,setting)
def getLanguage  (self,setting): return g.app.config.getLanguage (self.c,setting)
def getRatio     (self,setting): return g.app.config.getRatio    (self.c,setting)
def getShortcut  (self,setting): return g.app.config.getShortcut (self.c,setting)
def getString    (self,setting): return g.app.config.getString   (self.c,setting)
#@nonl
#@-node:ekr.20041118053731:Getters
#@+node:ekr.20041118195812:Setters...
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041118195812.2:set & setString
def set (self,p,setting,val):
    
    __pychecker__ = '--no-argsused' # p not used.
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set
#@nonl
#@-node:ekr.20041118195812.2:set & setString
#@-node:ekr.20041118195812:Setters...
#@-node:ekr.20041118104831.1:class configSettings
#@-node:ekr.20050202063852.1:(Made local config settings work again)
#@+node:ekr.20050127090442.1:(Investigated redirection from scripts.  All appears well.)
redirect script IO to log pane setting isn't working, 
#@nonl
#@+node:ekr.20031218072017.3121:redirecting stderr and stdout
class redirectClass:
    
    """A class to redirect stdout and stderr."""

    << redirectClass methods >>

# Create two redirection objects, one for each stream.
redirectStdErrObj = redirectClass()
redirectStdOutObj = redirectClass()

<< define convenience methods for redirecting streams >>

if 0: # Test code: may be executed in the child node.
    << test code >>
#@nonl
#@+node:ekr.20031218072017.1656:<< redirectClass methods >>
@others
#@nonl
#@+node:ekr.20041012082437:redirectClass.__init__
def __init__ (self):
    
    self.old = None
#@nonl
#@-node:ekr.20041012082437:redirectClass.__init__
#@+node:ekr.20041012082437.1:isRedirected
def isRedirected (self):

    return self.old != None
#@nonl
#@-node:ekr.20041012082437.1:isRedirected
#@+node:ekr.20041012082437.2:flush
# For LeoN: just for compatibility.

def flush(self, *args):
    return 

#@-node:ekr.20041012082437.2:flush
#@+node:ekr.20041012091252:rawPrint
def rawPrint (self,s):

    if self.old:
        self.old.write(s+'\n')
    else:
        print s
#@nonl
#@-node:ekr.20041012091252:rawPrint
#@+node:ekr.20041012082437.3:redirect
def redirect (self,stdout=1):

    if g.app.batchMode:
        # Redirection is futile in batch mode.
        return

    if not self.old:
        if stdout:
            self.old,sys.stdout = sys.stdout,self
        else:
            self.old,sys.stderr = sys.stderr,self
#@nonl
#@-node:ekr.20041012082437.3:redirect
#@+node:ekr.20041012082437.4:undirect
def undirect (self,stdout=1):

    if self.old:
        if stdout:
            sys.stdout,self.old = self.old,None
        else:
            sys.stderr,self.old = self.old,None
#@nonl
#@-node:ekr.20041012082437.4:undirect
#@+node:ekr.20041012082437.5:write
def write(self,s):

    if self.old:
        if app.log:
            app.log.put(s)
        else:
            self.old.write(s+'\n')
    else:
        # Can happen when g.batchMode is True.
        print s
#@nonl
#@-node:ekr.20041012082437.5:write
#@-node:ekr.20031218072017.1656:<< redirectClass methods >>
#@+node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
@others
#@nonl
#@+node:ekr.20041012090942:redirectStderr & redirectStdout
# Redirect streams to the current log window.
def redirectStderr():
    global redirectStdErrObj
    redirectStdErrObj.redirect(stdout=False)

def redirectStdout():
    global redirectStdOutObj
    redirectStdOutObj.redirect()
#@nonl
#@-node:ekr.20041012090942:redirectStderr & redirectStdout
#@+node:ekr.20041012090942.1:restoreStderr & restoreStdout
# Restore standard streams.
def restoreStderr():
    global redirectStdErrObj
    redirectStdErrObj.undirect(stdout=False)
    
def restoreStdout():
    global redirectStdOutObj
    redirectStdOutObj.undirect()
#@nonl
#@-node:ekr.20041012090942.1:restoreStderr & restoreStdout
#@+node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
def stdErrIsRedirected():
    global redirectStdErrObj
    return redirectStdErrObj.isRedirected()
    
def stdOutIsRedirected():
    global redirectStdOutObj
    return redirectStdOutObj.isRedirected()
#@nonl
#@-node:ekr.20041012090942.2:stdErrIsRedirected & stdOutIsRedirected
#@+node:ekr.20041012090942.3:rawPrint
# Send output to original stdout.

def rawPrint(s):

    global redirectStdOutObj

    redirectStdOutObj.rawPrint(s)
#@nonl
#@-node:ekr.20041012090942.3:rawPrint
#@-node:ekr.20031218072017.3122:<< define convenience methods for redirecting streams >>
#@+node:ekr.20031218072017.3123:<< test code >>
import leoGlobals as g ; import sys
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stderr
import leoGlobals as g ; import sys
g.redirectStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.restoreStderr()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

# stdout
import leoGlobals as g ; import sys
g.restoreStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()

import leoGlobals as g ; import sys
g.redirectStdout()
print >> sys.stdout, "stdout isRedirected:", g.stdOutIsRedirected()
print >> sys.stderr, "stderr isRedirected:", g.stdErrIsRedirected()
#@-node:ekr.20031218072017.3123:<< test code >>
#@-node:ekr.20031218072017.3121:redirecting stderr and stdout
#@-node:ekr.20050127090442.1:(Investigated redirection from scripts.  All appears well.)
#@+node:ekr.20050127083933:(Fix url problems)
#@+node:ekr.20050206045723:Note: it just ran slowly & silently
#@-node:ekr.20050206045723:Note: it just ran slowly & silently
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        << stop the url after any whitespace >>
        # g.trace(url)
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,p=p,v=p)
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
    
#@nonl
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
#@+node:ekr.20031218072017.3060:findAllButton
# The user has pushed the "Find All" button from the find panel.

def findAllButton(self):

    c = self.setup_button()
    c.clearAllVisited() # Clear visited for context reporting.

    if self.script_search:
        self.doFindAllScript()
    elif self.selection_only:
        self.findNext()
    else:
        self.findAll()
#@nonl
#@-node:ekr.20031218072017.3060:findAllButton
#@+node:ekr.20031218072017.3073:findAll
def findAll(self):

    c = self.c ; t = self.s_ctrl ; gui = g.app.gui
    if not self.checkArgs():
        return
    self.initInHeadline()
    data = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    while 1:
        pos, newpos = self.findNextMatch()
        if pos:
            # g.trace(pos,newpos,self.p.headString())
            count += 1
            line = gui.getLineContainingIndex(t,pos)
            self.printLine(line,allFlag=True)
        else: break
    c.endUpdate()
    g.es("found: %d matches" % (count))
    self.restore(data)
#@nonl
#@-node:ekr.20031218072017.3073:findAll
#@+node:ekr.20031218072017.3075:findNextMatch
# Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not self.search_headline and not self.search_body:
        return None, None

    if len(self.find_text) == 0:
        return None, None

    p = self.p
    while p:
        pos, newpos = self.search()
        if pos:
            if self.mark_finds:
                p.setMarked()
                c.frame.tree.drawIcon(p) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif self.node_only:
            return None,None # We are only searching one node.
        else:
            p = self.p = self.selectNextVnode()
    return None, None
#@nonl
#@-node:ekr.20031218072017.3075:findNextMatch
#@+node:ekr.20031218072017.3081:selectNextVnode
# Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; p = self.p

    if self.selection_only:
        return None

    # Start suboutline only searches.
    if self.suboutline_only and not self.onlyPosition:
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.onlyPosition = p 

    # Start wrapped searches.
    if self.wrapping and not self.wrapPosition:
        assert(self.wrapPos != None)
        # p.copy not needed because the find code never calls p.moveToX.
        # Furthermore, p might be None, so p.copy() would be wrong!
        self.wrapPosition = p 

    if self.in_headline and self.search_body:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(p)
        return p

    if self.reverse: p = p.threadBack()
    else:            p = p.threadNext()
    
    # New in 4.3: restrict searches to hoisted area.
    # End searches outside hoisted area.
    if c.hoistStack:
        if not p:
            if self.wrapping:
                g.es('Wrap disabled in hoisted outlines',color='blue')
            return
        bunch = c.hoistStack[-1]
        if not bunch.p.isAncestorOf(p):
            g.es('Found match outside of hoisted outline',color='blue')
            return None

    # Wrap if needed.
    if not p and self.wrapping and not self.suboutline_only:
        p = c.rootPosition()
        if self.reverse:
            # Set search_v to the last node of the tree.
            while p and p.next():
                p = p.next()
            if p: p = p.lastNode()

    # End wrapped searches.
    if self.wrapping and p and p == self.wrapPosition:
        # g.trace("ending wrapped search")
        p = None ; self.resetWrap()

    # End suboutline only searches.
    if (self.suboutline_only and self.onlyPosition and p and
        (p == self.onlyPosition or not self.onlyPosition.isAncestorOf(p))):
        # g.trace("end outline-only")
        p = None ; self.onlyPosition = None

    # p.copy not needed because the find code never calls p.moveToX.
    # Furthermore, p might be None, so p.copy() would be wrong!
    self.p = p # used in initNextText().
    if p: # select p and set the search point within p.
        self.in_headline = self.search_headline
        self.initNextText()
    return p
#@nonl
#@-node:ekr.20031218072017.3081:selectNextVnode
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050127083933:(Fix url problems)
#@+node:ekr.20050128081226:Buttons no longer work in toolbars when settings dialog is open
#@-node:ekr.20050128081226:Buttons no longer work in toolbars when settings dialog is open
#@+node:ekr.20050206120754.1:(Fixed bug: Focus shifted from body to headline
#@+node:ekr.20050206140101:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2958470
By: nobody

From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

I opened a new .leo file, and the cursor was flashing in the text box. I started
typing "@language", and found that the first character is in the text box, and
the rest is in the headline!

What I did:

This was the result of a race condition in the new scheme for setting focus. I
rewrote set_focus so the delayed callback always sets the last requested focus.
The new code also takes care to clear the last request after fulfilling it.
#@nonl
#@-node:ekr.20050206140101:Report
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''
    
    __pychecker__ = '--no-argsused' # tag good for debugging.

    c = self.c
    
    # g.trace(c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                self.outerFrame.after(100,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050206120754.1:(Fixed bug: Focus shifted from body to headline
#@+node:ekr.20050206120954:(Made sure Leo asks for leoID at most once)
#@+node:ekr.20050221091906:Report2
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3006092
Viktor Ransmayr

In Leo-4.3.a2 there is a small problem with the location of the created .leoID.txt
file.

When I installed the new version of Leo, I started Leo
and entered a LeoID, when asked. For whatever reason
this was stored in C:\Programme\Leo\test\.leoID.txt
and not in C:\Programme\Leo\config\.leoID.txt, where
it is expected.

The net-result is that you asked for a new LeoID,
whenever you open an existing Leo-file in any
directory other than C:\Programme\Leo\test.
#@nonl
#@-node:ekr.20050221091906:Report2
#@+node:ekr.20050206150004:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2958470
By: nobody

From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

Opened a new .leo file. It asked for an ID, and said it saved it. Closed the
new leo file & tried opening "Leo\config\leoSettings.leo". _It_ is asking for
a leoID!
#@nonl
#@-node:ekr.20050206150004:Report
#@+node:ekr.20050206152211:What I did
@killcolor

All changes were to g.app.leoID():

- Fixed bug:  set g.app.leoID in << put up a dialog requiring a valid id >>.
- Improved signon message.
- Better error handling and reporting. 
#@nonl
#@-node:ekr.20050206152211:What I did
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    << return if we can set self.leoID from sys.leoID >>
    << return if we can set self.leoID from "leoID.txt" >>

    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@nonl
#@+node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None
#@nonl
#@-node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()
g.app.gui = None

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@nonl
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                print s ; g.es(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@nonl
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@-node:ekr.20050206120954:(Made sure Leo asks for leoID at most once)
#@+node:ekr.20050206201921:(Leo now prints unicode characters properly in the log pane)
# This now works: g.es('ﺻﺱ',color='red')
#@nonl
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050206201921:(Leo now prints unicode characters properly in the log pane)
#@+node:ekr.20050208051804:(Fixed various problems with Unicode filenames)
#@+node:ekr.20050208054635:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2983923
By: tyndal

I tried again with the a2 cvs and it still isnt working correctly, the "reduced"
leo window is still showing up, however the error messages are different:

---------------

Leo Log Window...
Leo 4.3 alpha 2, build  1.217 , January 30, 2005
Python 2.3.4, Tk 8.4.3, win32

exception executing command
Traceback (most recent call last):
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoCommands.py", line 170,
in doCommand
    command()
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoCommands.py", line 328, in open
    ok, frame = g.openWithFileName(fileName,c)
  File "D:\scratch\leo\leo_cvs_2005feb07\src\leoGlobals.py", line 637,
in openWithFileName
    g.es("exceptions opening: %s" % g.toEncodedString(fileName),color="red")
TypeError: toEncodedString() takes at least 2 arguments (1 given)

---------------

However, opening a regular file after failing to open a file now seems to work
correctly.

-Tyndal

#@-node:ekr.20050208054635:Report
#@+node:ekr.20050206085258:atFile.printError & test
def printError (self,message):

    '''Print an error message that may contain non-ascii characters.'''

    if self.errors == 0:
        g.es_error(message)
    else:
        try:
            print message
        except UnicodeError:
            print g.toEncodedString(message,g.app.tkEncoding)
            
def test_atFile_printError(self):

    at = c.atFileCommands
    at.errors = 0
    at.printError(
        "test of printError: Ᾱ(U+1FB9: Greek Capital Letter Alpha With Macron)")
#@nonl
#@-node:ekr.20050206085258:atFile.printError & test
#@+node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20031218072017.1499:isUnicode
def isUnicode(s):
    
    return s is None or type(s) == type(u' ')
#@nonl
#@-node:ekr.20031218072017.1499:isUnicode
#@+node:ekr.20031218072017.1500:isValidEncoding
def isValidEncoding (encoding):
    
    try:
        if len(encoding) == 0:
            return False
        unicode("a",encoding)
        return True
    except:
        return False
#@-node:ekr.20031218072017.1500:isValidEncoding
#@+node:ekr.20031218072017.1501:reportBadChars
def reportBadChars (s,encoding):
    
    errors = 0
    if type(s) == type(u""):
        for ch in s:
            try: ch.encode(encoding,"strict")
            except: errors += 1
        if errors:
            # traceback.print_stack()
            g.es("%d errors converting %s to %s" % 
                (errors, s.encode(encoding,"replace"),encoding))

    elif type(s) == type(""):
        for ch in s:
            try: unicode(ch,encoding,"strict")
            except: errors += 1
        if errors:
            g.es("%d errors converting %s (%s encoding) to unicode" % 
                (errors, unicode(s,encoding,"replace"),encoding)) # 10/23/03
#@nonl
#@-node:ekr.20031218072017.1501:reportBadChars
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20050208093903:toEncodedStringWithErrorCode
def toEncodedStringWithErrorCode (s,encoding):
    
    ok = True

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            s = s.encode(encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208093903:toEncodedStringWithErrorCode
#@+node:ekr.20050208093800.1:toUnicode
def toUnicode (s,encoding,reportErrors=False):
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
    
#@-node:ekr.20050208093800.1:toUnicode
#@+node:ekr.20050208095723:toUnicodeWithErrorCode
def toUnicodeWithErrorCode (s,encoding):
    
    ok = True
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            s = unicode(s,encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208095723:toUnicodeWithErrorCode
#@+node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
def test_round_trip_toUnicode_toEncodedString ():
   
    for s,encoding in (
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('äöü',  'utf-8'),
        ('äöü',  'mbcs'),
        ('炰',   'utf-8'),
        ('炰',   'mbcs'),
    ):
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one failed for %s' %s
            
            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two failed for %s' %s
#@nonl
#@-node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
#@+node:ekr.20050208112123:test_failure_with_ascii_encodings
def test_failure_with_ascii_encodings():

    encoding = 'ascii'
    
    s = '炰'
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s = u'炰'
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
#@nonl
#@-node:ekr.20050208112123:test_failure_with_ascii_encodings
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
# Suppress warning about redefining getpreferredencoding
__pychecker__ = '--no-reuseattr'

try:
    # Use Python's version of getpreferredencoding if it exists.
    # It is new in Python 2.3.
    import locale
    getpreferredencoding = locale.getpreferredencoding
except Exception:
    # Use code copied from locale.py in Python 2.3alpha2.
    if sys.platform in ('win32', 'darwin', 'mac'):
        << define getpreferredencoding using _locale >>
    else:
        << define getpreferredencoding for *nix >>
        
__pychecker__ = '--reuseattr'
#@+node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
# On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = True):
    """Return the charset that the user is likely using."""
    try:
        import _locale
        return _locale._getdefaultlocale()[1]
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
#@+node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
# On Unix, if CODESET is available, use that.

__pychecker__ = '--no-noeffect' # Note: this is at the top level!

try:
    locale.CODESET # Bug fix, 2/12/05
except NameError:
    # Fall back to parsing environment variables :-(
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        by looking at environment variables."""
        try:
            return locale.getdefaultlocale()[1]
        except:
            return None
else:
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        according to the system configuration."""
        try:
            if do_setlocale:
                oldloc = locale.setlocale(LC_CTYPE)
                locale.setlocale(LC_CTYPE, "")
                result = locale.nl_langinfo(CODESET)
                locale.setlocale(LC_CTYPE, oldloc)
                return result
            else:
                return locale.nl_langinfo(CODESET)
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
#@-node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
#@-node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
@ Note: all these methods return Unicode strings. It is up to the user to
convert to an encoded string as needed, say when opening a file.
#@nonl
#@+node:ekr.20031218072017.2146:os_path_abspath
def os_path_abspath(path,encoding=None):
    
    """Convert a path to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.abspath(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2146:os_path_abspath
#@+node:ekr.20031218072017.2147:os_path_basename
def os_path_basename(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.basename(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2147:os_path_basename
#@+node:ekr.20031218072017.2148:os_path_dirname
def os_path_dirname(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.dirname(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2148:os_path_dirname
#@+node:ekr.20031218072017.2149:os_path_exists
def os_path_exists(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.exists(path)
#@nonl
#@-node:ekr.20031218072017.2149:os_path_exists
#@+node:ekr.20031218072017.2150:os_path_getmtime
def os_path_getmtime(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.getmtime(path)
#@nonl
#@-node:ekr.20031218072017.2150:os_path_getmtime
#@+node:ekr.20031218072017.2151:os_path_isabs
def os_path_isabs(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isabs(path)
#@nonl
#@-node:ekr.20031218072017.2151:os_path_isabs
#@+node:ekr.20031218072017.2152:os_path_isdir
def os_path_isdir(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isdir(path)
#@nonl
#@-node:ekr.20031218072017.2152:os_path_isdir
#@+node:ekr.20031218072017.2153:os_path_isfile
def os_path_isfile(path,encoding=None):
    
    """Normalize the path and convert it to an absolute path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    return os.path.isfile(path)
#@nonl
#@-node:ekr.20031218072017.2153:os_path_isfile
#@+node:ekr.20031218072017.2154:os_path_join
def os_path_join(*args,**keys):
    
    encoding = keys.get("encoding")

    uargs = [g.toUnicodeFileEncoding(arg,encoding) for arg in args]
    
    # Note:  This is exactly the same convention as used by getBaseDirectory.
    if uargs and uargs[0] == '!!':
        uargs[0] = g.app.loadDir
    elif uargs and uargs[0] == '.':
        c = keys.get('c')
        if c and c.openDirectory:
            uargs[0] = c.openDirectory
            g.trace(c.openDirectory)

    path = os.path.join(*uargs)
    
    path = g.toUnicodeFileEncoding(path,encoding)

    return path
#@nonl
#@-node:ekr.20031218072017.2154:os_path_join
#@+node:ekr.20031218072017.2155:os_path_norm NOT USED
if 0:  # A bad idea.
    
    def os_path_norm(path,encoding=None):
    
        """Normalize both the path and the case."""
    
        path = g.toUnicodeFileEncoding(path,encoding)
    
        path = os.path.normcase(path)
        path = os.path.normpath(path)
        
        path = g.toUnicodeFileEncoding(path,encoding)
        
        return path
#@nonl
#@-node:ekr.20031218072017.2155:os_path_norm NOT USED
#@+node:ekr.20041115103456:os_path_normabs NOT USED
if 0: # A bad idea.

    def os_path_normabs (path,encoding=None):
    
        """Convert the file name to a fully normalized absolute path.
        
        There is no exact analog to this in os.path"""
        
        path = g.os_path_abspath(path,encoding = encoding)
        path = g.os_path_norm(path,encoding = encoding)
    
        return path
#@nonl
#@-node:ekr.20041115103456:os_path_normabs NOT USED
#@+node:ekr.20031218072017.2156:os_path_normcase
def os_path_normcase(path,encoding=None):
    
    """Normalize the path's case."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normcase(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2156:os_path_normcase
#@+node:ekr.20031218072017.2157:os_path_normpath
def os_path_normpath(path,encoding=None):
    
    """Normalize the path."""

    path = g.toUnicodeFileEncoding(path,encoding)

    path = os.path.normpath(path)
    
    path = g.toUnicodeFileEncoding(path,encoding)
    
    return path
#@nonl
#@-node:ekr.20031218072017.2157:os_path_normpath
#@+node:ekr.20031218072017.2158:os_path_split
def os_path_split(path,encoding=None):
    
    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.split(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@nonl
#@-node:ekr.20031218072017.2158:os_path_split
#@+node:ekr.20031218072017.2159:os_path_splitext
def os_path_splitext(path,encoding=None):

    path = g.toUnicodeFileEncoding(path,encoding)

    head,tail = os.path.splitext(path)

    head = g.toUnicodeFileEncoding(head,encoding)
    tail = g.toUnicodeFileEncoding(tail,encoding)

    return head,tail
#@nonl
#@-node:ekr.20031218072017.2159:os_path_splitext
#@+node:ekr.20031218072017.2160:toUnicodeFileEncoding
def toUnicodeFileEncoding(path,encoding):

    if not encoding:
        if sys.platform == "win32":
            # encoding = "mbcs" # Leo 4.2 and previous.
            encoding = 'utf-8' # New in Leo 4.3
        else:
            encoding = app.tkEncoding

    # Yes, this is correct.  All os_path_x functions return Unicode strings.
    return g.toUnicode(path,encoding)
#@nonl
#@-node:ekr.20031218072017.2160:toUnicodeFileEncoding
#@-node:ekr.20031218072017.2145:os.path wrappers (leoGlobals.py)
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2618:app.setEncoding
@ According to Martin v. Löwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):
    
    """Set g.app.tkEncoding."""

    for (encoding,src) in (
        (self.config.tkEncoding,"config"),
        #(locale.getdefaultlocale()[1],"locale"),
        (g.getpreferredencoding(),"locale"),
        (sys.getdefaultencoding(),"sys"),
        ("utf-8","default")):
    
        if g.isValidEncoding (encoding): # 3/22/03
            self.tkEncoding = encoding
            # g.trace(self.tkEncoding,src)
            break
        elif encoding and len(encoding) > 0:
            color = g.choose(self.tkEncoding=="ascii","red","blue")
            g.trace("ignoring invalid %s encoding: %s" % (src,encoding),color=color)
            
    
#@nonl
#@-node:ekr.20031218072017.2618:app.setEncoding
#@-node:ekr.20050208051804:(Fixed various problems with Unicode filenames)
#@+node:ekr.20050208133438.1:(Fixed unicode problems on the Mac)
#@+node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
# All output to the log stream eventually comes here.
def put (self,s,color=None):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting: return
    elif self.logCtrl:
        << put s to log control >>
    else:
        << put s to logWaiting and print s >>

def putnl (self):
    if g.app.quitting: return
    elif self.logCtrl:
        << put newline to log control >>
    else:
        << put newline to logWaiting and print newline >>
#@nonl
#@+node:EKR.20040423082910:<< put s to log control >>
if 0:
    # Do this later, or not at all.
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    if "black" not in self.colorTags:
        self.colorTags.append("black")
        self.logCtrl.tag_config("black",foreground="black")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)
#@nonl
#@-node:EKR.20040423082910:<< put s to log control >>
#@+node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s
#@nonl
#@-node:EKR.20040423082910.1:<< put s to logWaiting and print s >>
#@+node:EKR.20040423082910.2:<< put newline to log control >>
self.logCtrl.insert("end",'\n')
self.logCtrl.see("end")
self.forceLogUpdate('\n')
#@nonl
#@-node:EKR.20040423082910.2:<< put newline to log control >>
#@+node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
g.app.logWaiting.append(('\n',"black"),)
print "Null tkinter log"
print
#@nonl
#@-node:EKR.20040423082910.3:<< put newline to logWaiting and print newline >>
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@-node:ekr.20031218072017.1473:tkLog.put & putnl & forceLogUpdate
#@-node:ekr.20050208133438.1:(Fixed unicode problems on the Mac)
#@+node:ekr.20050210080438:(Made sure Go To Line Number dialog is brought to the front)
#@+node:ekr.20050210080438.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2987569
By: e

goto linenumber popup gets hidden behind the leo.

EKR: This happens when focus is in body pane.

Arrrrrgh.  The delayed focus logic requires a commander to work.

What I did:

- Added a c argument to all dialogs except runAskLeoIDDialog.
- Added tk.gui.widget_wants_focus.
- Added unit tests to test ctors for all dialogs and panels.
    - All dialog ctors return after initing the base class when unit testing.
#@-node:ekr.20050210080438.1:Report
#@+node:ekr.20050210084744:Added c to all dialog ctors!
#@+node:ekr.20031218072017.3730:app.gui dialogs
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run Leo's About Leo dialog."""
    self.oops()
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    self.oops()

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run an askOK dialog ."""
    self.oops()

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    self.oops()

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    self.oops()

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3730:app.gui dialogs
#@+node:ekr.20031218072017.3744:dialogs (unitTestGui)
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    return self.simulateDialog("aboutLeoDialog")
    
def runAskLeoIDDialog(self):
    return self.simulateDialog("leoIDDialog")

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    return self.simulateDialog("okDialog","Ok")

def runAskOkCancelNumberDialog(self,c,title,message):
    return self.simulateDialog("numberDialog",-1)
    
def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):
    return self.simulateDialog("openFileDialog")

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):
    return self.simulateDialog("saveFileDialog")

def runAskYesNoDialog(self,c,title,message=None):
    return self.simulateDialog("yesNoDialog","no")

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    return self.simulateDialog("yesNoCancelDialog","cancel")
#@nonl
#@-node:ekr.20031218072017.3744:dialogs (unitTestGui)
#@+node:ekr.20031218072017.4056:app.gui.Tkinter dialogs
def runAboutLeoDialog(self,c,version,theCopyright,url,email):
    """Create and run a Tkinter About Leo dialog."""
    d = leoTkinterDialog.tkinterAboutLeo(c,version,theCopyright,url,email)
    return d.run(modal=False)
    
def runAskLeoIDDialog(self):
    """Create and run a dialog to get g.app.LeoID."""
    d = leoTkinterDialog.tkinterAskLeoID()
    return d.run(modal=True)

def runAskOkDialog(self,c,title,message=None,text="Ok"):
    """Create and run a Tkinter an askOK dialog ."""
    d = leoTkinterDialog.tkinterAskOk(c,title,message,text)
    return d.run(modal=True)

def runAskOkCancelNumberDialog(self,c,title,message):
    """Create and run askOkCancelNumber dialog ."""
    d = leoTkinterDialog.tkinterAskOkCancelNumber(c,title,message)
    return d.run(modal=True)

def runAskYesNoDialog(self,c,title,message=None):
    """Create and run an askYesNo dialog."""
    d = leoTkinterDialog.tkinterAskYesNo(c,title,message)
    return d.run(modal=True)

def runAskYesNoCancelDialog(self,c,title,
    message=None,yesMessage="Yes",noMessage="No",defaultButton="Yes"):
    """Create and run an askYesNoCancel dialog ."""
    d = leoTkinterDialog.tkinterAskYesNoCancel(
        c,title,message,yesMessage,noMessage,defaultButton)
    return d.run(modal=True)
#@nonl
#@-node:ekr.20031218072017.4056:app.gui.Tkinter dialogs
#@-node:ekr.20050210084744:Added c to all dialog ctors!
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,root=None,lines=None,n=None,scriptFind=False):
    
    __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@nonl
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@nonl
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@nonl
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
            
if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@nonl
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@+node:ekr.20031218072017.3866:run (tkDialog)
def run (self,modal):
    
    """Run a leoTkinterDialog."""
    
    if g.app.unitTesting: return None

    c = self.c
    self.modal = modal
    
    self.center() # Do this after all packing complete.
    self.top.lift() # 7/31/04

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        if self.focus_widget == None:
            self.focus_widget = self.top
            
        self.focus_widget.focus_set() # Get all keystrokes.
        if c:
             g.app.gui.widget_wants_focus(c,self.focus_widget)
           
        self.root.wait_window(self.top)
        return self.answer
    else:
        self.root.wait_window(self.top)
        return None
#@nonl
#@-node:ekr.20031218072017.3866:run (tkDialog)
#@+node:ekr.20050210082320:widget_wants_focus (tk.gui)
def widget_wants_focus(self,c,widget,tag=''):

    """Indicate that a widget want to get focus."""
    
    if c:
        c.frame.widgetWantsFocus(widget,True,tag=tag)
        
widgetWantsFocus = widget_wants_focus
#@nonl
#@-node:ekr.20050210082320:widget_wants_focus (tk.gui)
#@+node:ekr.20050120083053:Delayed Focus (tkFrame)
@

New in 4.3

Rather than calling g.app.gui.set_focus directly, the code calls
self.xWantsFocus. This defers to idle-time code in the status-line class.

N.B.  This code never calls select, so there can be no race condition here that alters text improperly.
#@nonl
#@+node:ekr.20050120092028:xWantsFocus (tkFrame)
@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,self.c.shortFileName())
    self.set_focus(widget,later=later,tag=tag)
    
def logWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def statusLineWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag)
    self.set_focus(widget,later=later,tag=tag)
    
def treeWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
    
def widgetWantsFocus(self,widget,later=True,tag=''):
    # g.trace(tag,repr(widget))
    self.set_focus(widget,later=later,tag=tag)
#@nonl
#@-node:ekr.20050120092028:xWantsFocus (tkFrame)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''
    
    __pychecker__ = '--no-argsused' # tag good for debugging.

    c = self.c
    
    # g.trace(c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                self.outerFrame.after(100,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@-node:ekr.20050120083053:Delayed Focus (tkFrame)
#@-node:ekr.20050210080438:(Made sure Go To Line Number dialog is brought to the front)
#@+node:ekr.20050211095957:(Fixed newline bug in g.getScript)
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@-node:ekr.20050211095957:(Fixed newline bug in g.getScript)
#@+node:ekr.20050211111552.1:(Fixed bug involving encoding field in derived files)
#@+node:ekr.20041005105605.120:parseLeoSentinel
def parseLeoSentinel (self,s):
    
    at = self ; c = at.c
    new_df = False ; valid = True ; n = len(s)
    isThinDerivedFile = False
    encoding_tag = "-encoding="
    version_tag = "-ver="
    tag = "@+leo"
    thin_tag = "-thin"
    << set the opening comment delim >>
    << make sure we have @+leo >>
    << read optional version param >>
    << read optional thin param >>
    << read optional encoding param >>
    << set the closing comment delim >>
    return valid,new_df,start,end,isThinDerivedFile
#@nonl
#@+node:ekr.20041005105605.121:<< set the opening comment delim >>
# s contains the tag
i = j = g.skip_ws(s,0)

# The opening comment delim is the initial non-tag
while i < n and not g.match(s,i,tag) and not g.is_nl(s,i):
    i += 1

if j < i:
    start = s[j:i]
else:
    valid = False
#@nonl
#@-node:ekr.20041005105605.121:<< set the opening comment delim >>
#@+node:ekr.20041005105605.122:<< make sure we have @+leo >>
@ REM hack: leading whitespace is significant before the @+leo.  We do this so that sentinelKind need not skip whitespace following self.startSentinelComment.  This is correct: we want to be as restrictive as possible about what is recognized as a sentinel.  This minimizes false matches.
@c

if 0: # Make leading whitespace significant.
    i = g.skip_ws(s,i)

if g.match(s,i,tag):
    i += len(tag)
else: valid = False
#@nonl
#@-node:ekr.20041005105605.122:<< make sure we have @+leo >>
#@+node:ekr.20041005105605.123:<< read optional version param >>
new_df = g.match(s,i,version_tag)

if new_df:
    # Skip to the next minus sign or end-of-line
    i += len(version_tag)
    j = i
    while i < len(s) and not g.is_nl(s,i) and s[i] != '-':
        i += 1

    if j < i:
        pass # version = s[j:i]
    else:
        valid = False
#@-node:ekr.20041005105605.123:<< read optional version param >>
#@+node:ekr.20041005105605.124:<< read optional thin param >>
if g.match(s,i,thin_tag):
    i += len(tag)
    isThinDerivedFile = True
#@nonl
#@-node:ekr.20041005105605.124:<< read optional thin param >>
#@+node:ekr.20041005105605.125:<< read optional encoding param >>
# Set the default encoding
at.encoding = c.config.default_derived_file_encoding

if g.match(s,i,encoding_tag):
    # Read optional encoding param, e.g., -encoding=utf-8,
    i += len(encoding_tag)
    # Skip to the next end of the field.
    j = s.find(",.",i)
    if j > -1:
        # The encoding field was written by 4.2 or after:
        encoding = s[i:j]
        i = j + 2 # 6/8/04, 1/11/05 (was i = j + 1)
    else:
        # The encoding field was written before 4.2.
        j = s.find('.',i)
        if j > -1:
            encoding = s[i:j]
            i = j + 1 # 6/8/04
        else:
            encoding = None
    # g.trace("encoding:",encoding)
    if encoding:
        if g.isValidEncoding(encoding):
            at.encoding = encoding
        else:
            print "bad encoding in derived file:",encoding
            g.es("bad encoding in derived file:",encoding)
    else:
        valid = False
#@-node:ekr.20041005105605.125:<< read optional encoding param >>
#@+node:ekr.20041005105605.126:<< set the closing comment delim >>
# The closing comment delim is the trailing non-whitespace.
i = j = g.skip_ws(s,i)
while i < n and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
end = s[j:i]
#@nonl
#@-node:ekr.20041005105605.126:<< set the closing comment delim >>
#@+node:ekr.20050211111552:test_parseLeoSentinel
def test_parseLeoSentinel (self):
    
    s1 = '#@+leo-ver=4-thin-encoding=utf-8,.'  # 4.2 format.
    s2 = '#@+leo-ver=4-thin-encoding=utf-8.' # pre-4.2 format.
    
    at=c.atFileCommands # Self is a dummy argument.
    
    for s in (s1,s2):
        valid,new_df,start,end,isThinDerivedFile = at.parseLeoSentinel(s)
        # g.trace('start',start,'end',repr(end),'len(s)',len(s))
        assert valid, 'not valid'
        assert new_df, 'not new_df'
        assert isThinDerivedFile, 'not thin'
        assert end == '', 'invalid end: %s' % repr(end)
        assert at.encoding == 'utf-8', 'bad encoding: %s' % repr(at.encoding)
#@-node:ekr.20050211111552:test_parseLeoSentinel
#@-node:ekr.20041005105605.120:parseLeoSentinel
#@-node:ekr.20050211111552.1:(Fixed bug involving encoding field in derived files)
#@+node:ekr.20050212144125:Fixed problems found by pychecker
# Bugs fixed 2/12/05
1. (fixed) C:\prog\leoCVS\leo\src\leoCommands.py:4539: No global (loadDir) found
    # Would cause leoSettings.leo in Window menu to crash.
    
2. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:3426: No global (local) found
    
    # Local --> locale
    # Might cause getpreferredencoding to fail on *nix.
    
3. (fixed) C:\prog\leoCVS\leo\src\leoGlobals.py:4152: No global (testing) found
    # Should be self.testing.
    
4. (fixed) mu problems:
    - Changed x to self.x:
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3795: No global (removeSentinelsFromLines) found
        - C:\prog\leoCVS\leo\src\leoGlobals.py:3838: No global (getSentinelsFromLines) found
    - Changed self.x to g.x:
        C:\prog\leoCVS\leo\src\leoGlobals.py:3854: No class attribute (comment_delims_from_extension) found
    - pull_source has been renamed, I don not know to what.
        C:\prog\leoCVS\leo\src\leoGlobals.py:4170: Object (mu) has no attribute (pull_source)
        (commented out the code that contains this)
        
5. (removed code) from << create a node p for  kind & root2 >>
    - last_p is None at first, so last_p.insertAfter does not make sense.
#@nonl
#@-node:ekr.20050212144125:Fixed problems found by pychecker
#@+node:ekr.20050212155600:Rewrote ctor of settingsController to eliminate pychecker warnings
@killcolor

Apparantly pychecker was confused by the complexity of the code in settingsController.__init__.

Created replaceBodyWithDialog and createStandAloneDialog helpers, and this eliminated the warnings(!)
#@nonl
#@-node:ekr.20050212155600:Rewrote ctor of settingsController to eliminate pychecker warnings
#@+node:ekr.20050213065340:(Fixed can't happen message in updateOneNode)
#@+node:ekr.20050213072437:What I did
@killcolor

The problem was with a change I made in createSettingsTree in response to a pychecker complaint.
This change altered the local settings tree...

In spite of what pychecker may say, last_p IS defined properly when it is used.
#@nonl
#@-node:ekr.20050213072437:What I did
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Put the values in the body.
                p.initHeadString("@%s %s" % (kind,name))
                body = '\n'.join(val)
                p.setBodyStringOrPane(body)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.56:findCorrespondingNode
def findCorrespondingNode (self,root1,root2,p1):
    
    """Return the node corresponding to p1 (in root1) in the root2's tree."""
    
    if p1 == root1: return root2

    # Go up tree 1, computing child indices.
    childIndices = []
    for p in p1.self_and_parents_iter():
        #g.trace(p)
        if p == root1: break
        childIndices.append(p.childIndex())
        
    childIndices.reverse()
    # g.trace(childIndices)
    
    # Go down tree 2, moving to the n'th child.
    p2 = root2.copy()
    for n in childIndices:
        # g.trace(p2)
        p2.moveToNthChild(n)

    # g.trace(p2)
    return p2
#@nonl
#@-node:ekr.20041225063637.56:findCorrespondingNode
#@-node:ekr.20050213065340:(Fixed can't happen message in updateOneNode)
#@+node:ekr.20050213072437.1:(Note: local setting for use_plugins can not overriding global setting)
@nocolor

It is surprisingly difficult to give a warning that only the global setting applies.

I added some more documentation to the setting in leoSettings.leo and removed the confusing entry from test.leo.

@color
#@nonl
#@+node:ekr.20041120094940.9:set (parseBaseClass)
def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)
#@nonl
#@-node:ekr.20041120094940.9:set (parseBaseClass)
#@-node:ekr.20050213072437.1:(Note: local setting for use_plugins can not overriding global setting)
#@-node:ekr.20050125203059.1:Bugs
#@+node:ekr.20050125203059.2:New features...
#@+node:ekr.20050125170349:(Added new undo granularities & undo_granularity setting)
#@+node:ekr.20050126095917:Notes
@killcolor

Up until Leo 4.3, Leo's undo-typing mechanism was character-by-character. This
was clunky, to say the least.

leoSettings.leo now contains an 'undo_granularity' setting. There are four
possible value for this setting:

node: start a new undo unit when typing moves to a new node.
line: start a new undo unit when typing moves to new line.
word: start a new undo unit when typing starts a new word.
char: start a new undo unit for each character typed.

'line' granularity is the default used if no valid setting is specified. 'char'
granularity is not recommened: it wastes lots of computer memory.

The definitions of 'node', 'line' and 'char' granularities are straightforward.
However, recognizing the start of a word for the purposes of undo is something
people may want to play with. Therefore, setUndoTypingParams calls the
recognizeStartOfTypingWord helper method to do this.

recognizeStartOfTypingWord is potentially user-modifiable method that should
return True if the typing indicated by the params starts a new 'word' for the
purposes of undo with 'word' granularity.
    
setUndoTypingParams calls this method only when the typing could possibly
continue a previous word. In other words, undo will work safely regardless of
the value returned. See the actual code for recognizeStartOfTypingWord for more
details.
#@nonl
#@-node:ekr.20050126095917:Notes
#@-node:ekr.20050125170349:(Added new undo granularities & undo_granularity setting)
#@+node:ekr.20050127120924:(Plugins manager attempts to call init functions in plugins)
#@+node:ekr.20050128095935:Request
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2963175
By: bwmulder

There have been some postings a while ago about using pydoc to browse Leo source
code.

It seems that pydoc imports modules. Pydoc, at that time, failed on some modules
because of setup code which was executed in some plugins, and which did not
work when some things were not setup.

I am wondering if it would be better to factor out setup code in plugins so
that the setup part (reading config file, etc) will be done only as part of
a function call. This way, imports of the module would always work.

You can currently test leoGlobals.app and such, but it seems to me that this
is more of a hack.

I realize that this would be a change in the plugin interface, but you can not
have improvements without some pain.

[Another lesson I learned recently is to avoid module level variables, and use
classes instead. You can always create new instances, but its hard to create
new instances of modules].

I was just thinking of adding a function in my mock module which would import
a module to figure out what modules are imported in that module. By replacing
the real modules with mock modules, one can be assured to control the total
environment of that module.
#@-node:ekr.20050128095935:Request
#@+node:ekr.20050128091841:Ahas
@killcolor

I just had two Aha's regarding this proposal:

1. The init function can return True if the plugin was, in fact, loaded correctly.  This is information that up until now has not been available, and it is very useful.  For example, the code in the '@button Check spelling...' node would be much simplified if leoPlugins.loadOnePlugin only returned properly inited plugins.

2. There is no need to change all plugins all at once.  The plugin manager can try calling plugin's init code, but can 'guess' that the plugin was correctly loaded if the init method does not exist.  In this way, we can add the init code to plugins that would really benefit from having it, without having to add init functions to all plugins.
#@nonl
#@-node:ekr.20050128091841:Ahas
#@+node:ekr.20050128111043:What I did
@killcolor

The code attempts to call the init method when importing the plugin. If the
top-level init function exits, the plugin manager will record the plugin as
having been loaded successfully only if init returns True (or equivalent). If
the top-level init function does not exist, the plugin manager considers that
the plugin was loaded successfully. This guess is needed for compatibility with
old plugins.

Other changes:

- Added init to the spellpyx plugin.
- Changed the scripts in the '@button Check spelling...' nodes in test.leo and leoPy.leo and leoPyRef.leo.

Edward
#@nonl
#@-node:ekr.20050128111043:What I did
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):
    
    global loadedModules,loadingModuleNameStack
    
    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            print s ; g.es(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)
    
    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        try:
            # Indicate success only if init_result is True.
            init_result = result.init()
            # g.trace('%s.init() returns %s' % (moduleName,init_result))
            if init_result:
                loadedModules[moduleName] = result
            else:
                result = None
        except AttributeError:
            # No top-level init function.
            # Guess that the module was loaded correctly.
            loadedModules[moduleName] = result
        loadingModuleNameStack.pop()
        
    if result is None:
        s = 'can not load enabled %s plugin' % moduleName
        print s ; g.es(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        print s ; g.es(s,color="blue")
    
    return result
#@-node:ekr.20041113113140:loadOnePlugin
#@-node:ekr.20050127120924:(Plugins manager attempts to call init functions in plugins)
#@+node:ekr.20050128081422:(Changed name of Paste Retaining Clones to Paste Node As Clone)
@killcolor

https://sourceforge.net/forum/message.php?msg_id=2963461
By: ktenney

Howdy,

I only just now realized that
Outline -> Paste Retaining Clone
would _create_ a clone from any node on the clipboard.
It's name led me to believe that I had to create a clone, copy it, and use 'Paste
Retaining Clones'

It would make more sense to me if it was called
"Paste As Clone" 
Maybe it could be given a hotkey, such as Shft+Ctrl+Z
#@+node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
self.outlineMenuTopMenuTable = (
    ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Pas&te Node As Clone",None,c.pasteOutlineRetainingClones),
    ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&Insert Node","Ctrl+I",c.insertHeadline),
    ("&Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
    ("&Sort Siblings","Alt+A",c.sortSiblings),
    ("-",None,None),
    ("&Hoist",None,c.hoist),
    ("D&e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
# Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
#@+node:ekr.20040131171020:<< enable top level outline menu >>
menu = frame.menu.getMenu("Outline")
enable(menu,"Cut Node",c.canCutOutline())
enable(menu,"Delete Node",c.canDeleteHeadline())
enable(menu,"Paste Node",c.canPasteOutline())
enable(menu,"Paste Node As Clone",c.canPasteOutline())
enable(menu,"Clone Node",c.canClone()) # 1/31/04
enable(menu,"Sort Siblings",c.canSortSiblings())
enable(menu,"Hoist",c.canHoist())
enable(menu,"De-Hoist",c.canDehoist())
#@nonl
#@-node:ekr.20040131171020:<< enable top level outline menu >>
#@-node:ekr.20050128081422:(Changed name of Paste Retaining Clones to Paste Node As Clone)
#@+node:ekr.20050130152008.1:(Added leoPlugins.leo to Help menu)
#@-node:ekr.20050130152008.1:(Added leoPlugins.leo to Help menu)
#@+node:ekr.20050202074304:Script buttons can request to be removed
@killcolor

A script in an @button node or script node can now request to be removed by
setting g.app.scriptDict['removeMe'] = True.
#@nonl
#@-node:ekr.20050202074304:Script buttons can request to be removed
#@+node:ekr.20050206120754:Improved documentation in leoSettings.leo
@killcolor

Documentation problem in "Leo\config\leoSettings.leo"

- (done) The body text shows 1: & 0: as selections, not True/False.
    - @bool write_strips_blank_lines = True
    - @bool allow_clone_drags = False"
    - @bool enable_drag_messages = False"

- (done) @bool script_change = None
    What's a 'script change'?
    All the nodes under "Checkboxes" could use descriptions.

- (done) @page Syntax colors & options

    It would be nice if there were spaces before & after the "=" to allow easier
    double-click selection of just the colors.
#@nonl
#@-node:ekr.20050206120754:Improved documentation in leoSettings.leo
#@+node:ekr.20050208134526:(Added define_g=True param in executeScript)
#@+node:ekr.20050208133438.2:g.app did not exist during scripts!
#@-node:ekr.20050208133438.2:g.app did not exist during scripts!
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@-node:ekr.20050208134526:(Added define_g=True param in executeScript)
#@+node:ekr.20050209112556:Changed Preferences to Settings in menu, leoSettings.leo & documentation
#@-node:ekr.20050209112556:Changed Preferences to Settings in menu, leoSettings.leo & documentation
#@+node:ekr.20050211105710:Removed definitions of c, g & p from all test routines
@killcolor

These are now defined in the calling environment.

See testRoutineTestCase.runTest in test.leo.
#@-node:ekr.20050211105710:Removed definitions of c, g & p from all test routines
#@+node:ekr.20050211124103:(Several scripting improvements)
#@+node:ekr.20050211134923:What I did
@killcolor

1.  g.getScript calls the new g.removeExtraLws function to remove extra indentation.

This is required to keep Python happy.

2.  g.getScript does not call at.write if there is, in fact, a selection.

This disables handling of directives and section references, but it handles indentation.

This should be improved further, but that would require some hacks to at.write.

N.B. The primary usage of this is to execute test routines immediately by
selecting the text without the def. This eliminates the need to use this
pattern:

def test_whatever():
    stuff

if 0: test_whatever()

BTW, I played around with using:

if g.app.inScript:
    test_whatever()

But there are several problems with this idea. First, it is much more work than
just selecting the body of test_whatever. Worse, it can not be used in
leoGlobals.py because g.app will be None in the initial import of leoGlobals.
This bad special case doomed the entire idea.

3. g.executeScript now just adds a trailing newline to the script.

In particular, it does not call strip!
#@nonl
#@-node:ekr.20050211134923:What I did
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20050211120242.2:g.removeExtraLws & tests
def removeExtraLws (s,tab_width):
    
    '''Remove extra indentation from one or more lines.'''
    
    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s
    
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    
    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            print repr(line)

    return result
#@nonl
#@+node:ekr.20050211120837:test_g_removeExtraLws
def test_g_removeExtraLws():
    
    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
#@nonl
#@-node:ekr.20050211120837:test_g_removeExtraLws
#@-node:ekr.20050211120242.2:g.removeExtraLws & tests
#@-node:ekr.20050211124103:(Several scripting improvements)
#@+node:ekr.20050213112731:(Give better error message when loading an enabled plugin fails)
#@+node:ekr.20041113113140:loadOnePlugin
def loadOnePlugin (moduleOrFileName, verbose=False):
    
    global loadedModules,loadingModuleNameStack
    
    if moduleOrFileName [-3:] == ".py":
        moduleName = moduleOrFileName [:-3]
    else:
        moduleName = moduleOrFileName
    moduleName = g.shortFileName(moduleName)

    if isLoaded(moduleName):
        module = loadedModules.get(moduleName)
        if verbose:
            s = 'plugin %s already loaded' % moduleName
            print s ; g.es(s,color="blue")
        return module

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    moduleName = g.toUnicode(moduleName,g.app.tkEncoding)
    
    # This import will typically result in calls to registerHandler.
    # if the plugin does _not_ use the init top-level function.
    loadingModuleNameStack.append(moduleName)
    result = g.importFromPath(moduleName,plugins_path)
    loadingModuleNameStack.pop()

    if result:
        loadingModuleNameStack.append(moduleName)
        try:
            # Indicate success only if init_result is True.
            init_result = result.init()
            # g.trace('%s.init() returns %s' % (moduleName,init_result))
            if init_result:
                loadedModules[moduleName] = result
            else:
                result = None
        except AttributeError:
            # No top-level init function.
            # Guess that the module was loaded correctly.
            loadedModules[moduleName] = result
        loadingModuleNameStack.pop()
        
    if result is None:
        s = 'can not load enabled %s plugin' % moduleName
        print s ; g.es(s,color="red")
    elif verbose:
        s = 'loaded %s plugin' % moduleName
        print s ; g.es(s,color="blue")
    
    return result
#@-node:ekr.20041113113140:loadOnePlugin
#@+node:ekr.20031218072017.2278:g.importFromPath
def importFromPath (name,path,pluginName=None,verbose=False):
    
    fn = g.shortFileName(name)
    moduleName,ext = g.os_path_splitext(fn)
    path = g.os_path_normpath(path)
    path = g.toEncodedString(path,app.tkEncoding)
    
    # g.trace(verbose,name,pluginName)
    module = sys.modules.get(moduleName)
    if not module:
        try:
            theFile = None
            import imp
            try:
                data = imp.find_module(moduleName,[path]) # This can open the file.
                theFile,pathname,description = data
                module = imp.load_module(moduleName,theFile,pathname,description)
            except ImportError:
                pass
            except Exception:
                g.es("unexpected exception in g.importFromPath",color='blue')
                g.es_exception()
        # Put no return statements before here!
        finally: 
            if theFile: theFile.close()
        
    if not module:
        g.cantImport(moduleName,pluginName=pluginName,verbose=verbose)

    return module
#@nonl
#@-node:ekr.20031218072017.2278:g.importFromPath
#@-node:ekr.20050213112731:(Give better error message when loading an enabled plugin fails)
#@-node:ekr.20050125203059.2:New features...
#@-node:ekr.20050125203059:4.3 a2 projects
#@+node:ekr.20050214092455:4.3 a3 projects
#@+node:ekr.20050214092455.1:Bugs
#@+node:ekr.20050216052031.1:(Fixed crash in Tangle)
#@+node:ekr.20050216052031.2:Report & notes
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2998446
By: djsg

g.create_temp_name() calls tempfile.mktemp or mkstemp(), but these return different values!

mktemp returns the filename(a string); mkstemp returns a tuple (handle,filename)

What I did:

- Changed g.create_temp_name to g.create_temp_file.
- Removed the file open logic in tangle.put_all_roots (now done in g.create_temp_file)
- Rewrote g.create_temp_file so it works in both cases.
- Create test routine for g.create_temp_file
- Created very simple unit tests in test.leo for tangle and untangle.
#@nonl
#@-node:ekr.20050216052031.2:Report & notes
#@+node:ekr.20031218072017.1151:tangle.put_all_roots
@ This is the top level method of the second pass. It creates a separate C file for each @root directive in the outline. As will be seen later,the file is actually written only if the new version of the file is different from the old version,or if the file did not exist previously. If changed_only_flag FLAG is True only changed roots are actually written.
@c

def put_all_roots(self):

    c = self.c ; outline_name = c.mFileName

    for section in self.root_list:
    
        # g.trace(section.name)
        file_name = g.os_path_join(self.tangle_directory,section.name)
        file_name = g.os_path_normpath(file_name)
        mode = c.config.output_newline
        # mode = g.choose(mode=="platform",'w','wb')
        textMode = mode == 'platform'
        self.output_file,temp_name = g.create_temp_file(textMode=textMode)
        if not temp_name:
            g.es("Can not create temp file")
            break
        <<Get root specific attributes>>
        <<Put @first lines>>
        if self.use_header_flag and self.print_mode == "verbose":
            << Write a banner at the start of the output file >>
        for part in section.parts:
            if part.is_root:
                self.tangle_indent = 0 # Initialize global.
                self.put_part_node(part,False) # output first lws
        self.onl() # Make sure the file ends with a cr/lf
        self.output_file.close()
        self.output_file = None
        if self.errors == 0:
            g.update_file_if_changed(file_name,temp_name)
        else:
            g.es("unchanged:  " + file_name)
            << Erase the temporary file >>
#@nonl
#@+node:ekr.20031218072017.1152:<<Get root specific attributes>>
# Stephen Schaefer, 9/2/02
# Retrieve the full complement of state for the root node
self.language = section.root_attributes.language
self.single_comment_string = section.root_attributes.single_comment_string
self.start_comment_string = section.root_attributes.start_comment_string
self.end_comment_string = section.root_attributes.end_comment_string
self.use_header_flag = section.root_attributes.use_header_flag
self.print_mode = section.root_attributes.print_mode
self.path = section.root_attributes.path
self.page_width = section.root_attributes.page_width
self.tab_width = section.root_attributes.tab_width
# Stephen P. Schaefer, 9/13/2002
self.first_lines = section.root_attributes.first_lines
#@nonl
#@-node:ekr.20031218072017.1152:<<Get root specific attributes>>
#@+node:ekr.20031218072017.1153:<<Put @first lines>>
# Stephen P. Schaefer 9/13/2002
if self.first_lines:
    self.os(self.first_lines)
#@nonl
#@-node:ekr.20031218072017.1153:<<Put @first lines>>
#@+node:ekr.20031218072017.1154:<<Write a banner at the start of the output file>>
if self.single_comment_string:
    self.os(self.single_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.onl() ; self.onl()
elif self.start_comment_string and self.end_comment_string:
    self.os(self.start_comment_string)
    self.os(" Created by Leo from: ")
    self.os(outline_name)
    self.oblank() ; self.os(self.end_comment_string)
    self.onl() ; self.onl()
#@-node:ekr.20031218072017.1154:<<Write a banner at the start of the output file>>
#@+node:ekr.20031218072017.1155:<< Erase the temporary file >>
try: # Just delete the temp file.
    os.remove(temp_name)
except: pass
#@-node:ekr.20031218072017.1155:<< Erase the temporary file >>
#@-node:ekr.20031218072017.1151:tangle.put_all_roots
#@+node:ekr.20031218072017.3117:create_temp_file & test
def create_temp_file (textMode=False):
    '''Return a tuple (theFile,theFileName)

    theFile: a file object open for writing.
    theFileName: the name of the temporary file.'''
    
    # mktemp is deprecated, but we can't get rid of it
    # because mkstemp does not exist in Python 2.2.1.
    __pychecker__ = '--no-deprecate'
    try:
        # fd is an handle to an open file as would be returned by os.open()
        fd,theFileName = tempfile.mkstemp(text=textMode)
        mode = g.choose(textMode,'w','wb')
        theFile = os.fdopen(fd,mode)
        # g.trace(fd,theFile)
    except AttributeError:
        # g.trace("mkstemp doesn't exist")
        theFileName = tempfile.mktemp()
        try:
            mode = g.choose(textMode,'w','wb')
            theFile = file(theFileName,mode)
        except IOError:
            theFile,theFileName = None,''
    except Exception:
        g.es('Unexpected exception in g.create_temp_file',color='red')
        g.es_exception()
        theFile,theFileName = None,''

    return theFile,theFileName
#@nonl
#@+node:ekr.20050216052031:test_g_create_temp_file
def test_g_create_temp_file():
    
    __pychecker__ = '--no-reimport'
    import types

    theFile,theFileName = g.create_temp_file()

    assert type(theFile) == types.FileType, 'not file type'
    assert type(theFileName) in (types.StringType, types.UnicodeType), 'not string type'
#@nonl
#@-node:ekr.20050216052031:test_g_create_temp_file
#@-node:ekr.20031218072017.3117:create_temp_file & test
#@-node:ekr.20050216052031.1:(Fixed crash in Tangle)
#@+node:ekr.20050217085134:Applied patch to rst2 plugin
#@+node:ekr.20050217085134.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=2999651
By: nobody

I was pleasantly surprised to discover the reST2 plug-in working under 4.3a2
(this is one the first thing I try as I'd like to use Leo as an editor
for that).

As mentioned in early threads, it still needs @rst for each node to be included
in the reST rendering process. So I put @rst test.html and then a child with
@rst and some reST code and it worked !!

Then I tried to to get a simple rst file using @rst test but the plugin complained:

[snip]

  File "C:\dn_apps\Leo\plugins\rst2.py", line 164, in onIconDoubleClick
    writeTreeAsRst(rstFile,fname,p,c)
TypeError: writeTreeAsRst() takes exactly 5 arguments (4 given)

So I looked at the rst2.py and found a way to get it working but I would need
someone to verify it :

line 164, replaced   writeTreeAsRst(rstFile,fname,p,c)  by

syntax = False
writeTreeAsRst(rstFile,fname,p,c,syntax)

And it worked!
#@-node:ekr.20050217085134.1:Report
#@-node:ekr.20050217085134:Applied patch to rst2 plugin
#@+node:ekr.20050217080914.2:Revised searchbox.py so it works with Leo 4.3
#@-node:ekr.20050217080914.2:Revised searchbox.py so it works with Leo 4.3
#@+node:ekr.20050218022720:(xemacs plugin goes crazy)
# This appears to be a bug in python-mode.el.
#@nonl
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:] 
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(os.path.abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.4116:createOpenWithMenuFromTable
@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &With...")
    amp_index = label.find("&")
    label = label.replace("&","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the "Open With..." menu.
    openWithMenu = Tk.Menu(parent,tearoff=0)
    self.setMenu("Open With...",openWithMenu)
    parent.insert_cascade(index,label=label,menu=openWithMenu,underline=amp_index)
    # Populate the "Open With..." menu.
    shortcut_table = []
    for triple in table:
        if len(triple) == 3: # 6/22/03
            shortcut_table.append(triple)
        else:
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
            
    # for i in shortcut_table: print i
    self.createMenuItemsFromTable("Open &With...",shortcut_table,openWith=True)
#@nonl
#@-node:ekr.20031218072017.4116:createOpenWithMenuFromTable
#@-node:ekr.20050218022720:(xemacs plugin goes crazy)
#@+node:ekr.20050219080830:(Fixed bugs in nav_buttons and nodenavigator plugins)
#@+node:ekr.20050219080830.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3005140
By: ktenney

- perform a search which marks a number of nodes

- select "Outline -> Mark/Unmark -> Unmark All"

- Several marks are still listed in in the nodenavigator "Marks" list.
  (They are not marked in the outline.)
#@nonl
#@-node:ekr.20050219080830.1:Report
#@+node:ekr.20050219174745:What I did
@killcolor

- The p.set/clearMark methods now call the hook _after_ changing the marked status.
  This fixes the apparent bug in nodenavigator.py.

- Rewrote nav_buttons.py.  The old code was a mess; the new code is clean.

- Changed the vnodeList ivar in leoTkinterDialog to positionList.

- Rewrote c.unmarkAll to make clear that it is using positions.
    - Added test_c_unmark_all test routine.
#@nonl
#@-node:ekr.20050219174745:What I did
#@+node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self): 

    c = self
    c.beginUpdate()
    for p in c.allNodes_iter():
        if p.isDirty()and not p.isMarked():
            p.setMarked()
            c.setChanged(True)
    g.es("done",color="blue")
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self):

    c = self
    c.beginUpdate()
    for p in c.allNodes_iter():
        if p.isDirty()and not p.isMarked():
            s = p.bodyString()
            flag, i = g.is_special(s,0,"@root")
            if flag:
                p.setMarked()
                c.setChanged(True)
    g.es("done",color="blue")
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty
def markAllAtFileNodesDirty (self):

    c = self ; v = c.rootVnode()
    c.beginUpdate()
    while v:
        if v.isAtFileNode()and not v.isDirty():
            v.setDirty()
            v = v.nodeAfterTree()
        else: v = v.threadNext()
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty
def markAtFileNodesDirty (self):

    c = self
    v = c.currentVnode()
    if not v: return
    after = v.nodeAfterTree()
    c.beginUpdate()
    while v and v != after:
        if v.isAtFileNode() and not v.isDirty():
            v.setDirty()
            v = v.nodeAfterTree()
        else: v = v.threadNext()
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2926:markAtFileNodesDirty
#@+node:ekr.20031218072017.2927:markClones
def markClones (self):

    c = self ; current = v = c.currentVnode()
    if not v: return
    if not v.isCloned(): return
    
    v = c.rootVnode()
    c.beginUpdate()
    while v:
        if v.t == current.t:
            v.setMarked()
        v = v.threadNext()
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline
def markHeadline (self):

    c = self ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    if p.isMarked():
        p.clearMarked()
    else:
        p.setMarked()
        p.setDirty()
        if 0: # 4/3/04: Marking a headline is a minor operation.
            c.setChanged(True)
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2928:markHeadline
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads(self):

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    while child:
        if not child.isMarked():
            child.setMarked()
            child.setDirty()
            c.setChanged(True)
        child = child.next()
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll & test
def unmarkAll(self):

    c = self
    c.beginUpdate()
    for p in c.allNodes_iter():
        if p.isMarked():
            p.clearMarked()
            p.setDirty()
            c.setChanged(True)
    c.endUpdate()
#@nonl
#@+node:ekr.20050219170523:test_c_unmark_all
def test_c_unmark_all(self):
    
    marked = [p.copy() for p in c.allNodes_iter() if p.isMarked()]
    
    c.unmarkAll()

    for p in c.allNodes_iter():
        assert not p.isMarked(), 'marked after Unmark All %s' % p
        
    # Restore marks.
    c.beginUpdate()
    for p in c.allNodes_iter():
        for p2 in marked:
            if p.isEqual(p2):
                p.setMarked()
    c.endUpdate()
#@nonl
#@-node:ekr.20050219170523:test_c_unmark_all
#@-node:ekr.20031218072017.2930:unmarkAll & test
#@-node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.3391:v.clearMarked
def clearMarked (self):

    self.statusBits &= ~ self.markedBit
#@-node:ekr.20031218072017.3391:v.clearMarked
#@+node:ekr.20031218072017.3398:v.setMarked & initMarkedBit
def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
#@-node:ekr.20031218072017.3398:v.setMarked & initMarkedBit
#@+node:ekr.20040306220634.9: Status bits (position)
# Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    self.v.clearMarked()
    g.doHook("clear-mark",c=self.c,p=self,v=self)

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus(status)
    
def setMarked (self):
    self.v.setMarked()
    g.doHook("set-mark",c=self.c,p=self,v=self)

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()
#@nonl
#@-node:ekr.20040306220634.9: Status bits (position)
#@+node:ekr.20031218072017.1596:g.doHook
@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError or (g.app.gui and g.app.gui.isNullGui):
        return None
        
    if args:
        # A minor error in Leo's core.
        print "***ignoring args param.  tag = %s" % tag

    if not g.app.config.use_plugins:
        if tag == "start1":
            s = "Plugins disabled: use_plugins is 0 in a leoSettings.leo file."
            print s ; g.es(s,color="blue")
        return None
         
    # Get the hook handler function.  Usually this is doPlugins.
    c = keywords.get("c")
    f = (c and c.hookFunction) or g.app.hookFunction
    if not f:
        import leoPlugins
        g.app.hookFunction = f = leoPlugins.doPlugins
        
    try:
        # Pass the hook to the hook handler.
        return f(tag,keywords)
    except Exception:
        g.es_exception()
        g.app.hookError = True # Supress this function.
        g.app.idleTimeHook = False # Supress idle-time hook
        return None # No return value
#@nonl
#@-node:ekr.20031218072017.1596:g.doHook
#@+node:ekr.20031218072017.3442:doHandlersForTag
def doHandlersForTag (tag,keywords):
    
    """Execute all handlers for a given tag, in alphabetical order.
    
    All exceptions are caught by the caller, doHook."""

    global handlers

    if g.app.killed:
        return None

    if handlers.has_key(tag):
        bunches = handlers.get(tag)
        # Execute hooks in some random order.
        # Return if one of them returns a non-None result.
        for bunch in bunches:
            val = callTagHandler(bunch,tag,keywords)
            if val is not None:
                return val

    if handlers.has_key("all"):
        bunches = handlers.get('all')
        for bunch in bunches:
            callTagHandler(bunch,tag,keywords)

    return None
#@nonl
#@-node:ekr.20031218072017.3442:doHandlersForTag
#@-node:ekr.20050219080830:(Fixed bugs in nav_buttons and nodenavigator plugins)
#@+node:ekr.20050206120954:(Made sure Leo asks for leoID at most once)
#@+node:ekr.20050221091906:Report2
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3006092
Viktor Ransmayr

In Leo-4.3.a2 there is a small problem with the location of the created .leoID.txt
file.

When I installed the new version of Leo, I started Leo
and entered a LeoID, when asked. For whatever reason
this was stored in C:\Programme\Leo\test\.leoID.txt
and not in C:\Programme\Leo\config\.leoID.txt, where
it is expected.

The net-result is that you asked for a new LeoID,
whenever you open an existing Leo-file in any
directory other than C:\Programme\Leo\test.
#@nonl
#@-node:ekr.20050221091906:Report2
#@+node:ekr.20050206150004:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=2958470
By: nobody

From: Rich

Leo 4.3 alpha 1, build  1.208 , January 24, 2005
Python 2.3.4, Tk 8.4.3, win32

Opened a new .leo file. It asked for an ID, and said it saved it. Closed the
new leo file & tried opening "Leo\config\leoSettings.leo". _It_ is asking for
a leoID!
#@nonl
#@-node:ekr.20050206150004:Report
#@+node:ekr.20050206152211:What I did
@killcolor

All changes were to g.app.leoID():

- Fixed bug:  set g.app.leoID in << put up a dialog requiring a valid id >>.
- Improved signon message.
- Better error handling and reporting. 
#@nonl
#@-node:ekr.20050206152211:What I did
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    << return if we can set self.leoID from sys.leoID >>
    << return if we can set self.leoID from "leoID.txt" >>

    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@nonl
#@+node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None
#@nonl
#@-node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()
g.app.gui = None

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@nonl
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                print s ; g.es(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@nonl
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@-node:ekr.20050206120954:(Made sure Leo asks for leoID at most once)
#@+node:ekr.20050220024410:(Fixed botch in g.pdb)
#@+node:ekr.20041105091148:g.pdb & test
def pdb ():
    
    """Fall into pdb."""

    import pdb # Required: we have just defined pdb as a function!

    pdb.set_trace()
#@nonl
#@+node:ekr.20050221092824:test_g_pdb
def test_g_pdb():
    
    import sys
    
    # Not a good unit test; it probably will never fail.
    def aFunction(): pass
    assert type(g.pdb)==type(aFunction), 'wrong type for g.pdb: %s' % type(g.pdb)
    
    class myStdout:
        def write(self,s):
            pass # ; g.es('From pdb:',s)
        
    class myStdin:
        def readline (self):
            return 'c' # Return 'c' (continue) for all requests for input.
            
    def restore():
        sys.stdout,sys.stdin = sys.__stdout__,sys.__stdin__
     
    try:
        sys.stdin = myStdin() # Essential
        sys.stdout=myStdout() # Optional
        g.pdb()
        restore()
        # assert False,'test of reraising'
    except Exception:
        restore()
        raise
#@nonl
#@-node:ekr.20050221092824:test_g_pdb
#@-node:ekr.20041105091148:g.pdb & test
#@-node:ekr.20050220024410:(Fixed botch in g.pdb)
#@+node:ekr.20050222050632:(Fixed bug in Execute Script in new window)
#@+node:ekr.20050222050632.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3008045
By: digitig

Um, I must be missing something about how to script in Leo. If I cut-and-paste
that code into a Leo main window, select it and hit ctrl-E the log window kindly
informs me:

exception executing command
Traceback (most recent call last):
  File "C:\Program Files\Leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "C:\Program Files\Leo\src\leoCommands.py", line 1141, in executeScript
    script = g.getScript(c,p,useSelectedText=useSelectedText)
  File "C:\Program Files\Leo\src\leoGlobals.py", line 4357, in getScript
    if c.atFileCommands.output_newline == '\r\n':
AttributeError: atFile instance has no attribute 'output_newline'
#@nonl
#@-node:ekr.20050222050632.1:Report
#@+node:ekr.20050222055118:What I did
@killcolor

- Call g.getOutputNewline(c=c) rather than look at atFile.output_newline.

atFile.output_newline may not exist if a) the file is new and b) g.getScript
doesn't call atfile.write.

- Set scripting=scriptWrite in call to atFile.scanAllDirectives in atFile.write.

This suppresses an erroneous message: "No absolute directory specified anywhere." in scripts.

- Rewrote the unit test for g.getScript and renamed it: test_g_getScript_strips_crlf
#@-node:ekr.20050222055118:What I did
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@-node:ekr.20050222050632:(Fixed bug in Execute Script in new window)
#@-node:ekr.20050214092455.1:Bugs
#@+node:ekr.20050214092455.2:New features
#@+node:ekr.20050214092455.3:Added sets.py to distribution
This allows plugins such as plugin_manager.py to work on Python 2.2.x.
#@nonl
#@-node:ekr.20050214092455.3:Added sets.py to distribution
#@+node:ekr.20050220034952:(Added test for g.exception & added color='suppress' hack to g.es)
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@nonl
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@nonl
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@-node:ekr.20050220034952:(Added test for g.exception & added color='suppress' hack to g.es)
#@-node:ekr.20050214092455.2:New features
#@-node:ekr.20050214092455:4.3 a3 projects
#@+node:ekr.20050225104239:4.3 a4 projects
#@+node:ekr.20050225104239.1:Bugs
#@+node:ekr.20050209094854:(Investigated disappearing node body text)
#@+node:ekr.20050225074932:Original posting: (not correct!)
@killcolor

WARNING: This is not correct!

http://sourceforge.net/forum/forum.php?thread_id=1214682&forum_id=10228

Leo can _appear_ to be losing data after a cvs-update when in fact nothing
serious has happened. This is confusing but it doesn't really lose data. This
issue goes back at least to 4.2.

Here is what is happening:

1. There must be a clone in the outline _outside_ of an @thin node, and a
corresponding clone inside an @thin node.

2. One or more of the cloned nodes are _deleted_ in a checked out copy of the
thin derived file. The change is then committed.

3. The data 'loss' happens when reading the updating the file (on another
machine). Leo's read code 'sees' the deleted node because it exists in the
outline outside of the @thin tree, but there is nothing in the node because Leo
intentionally doesn't write a node if it is cloned in any thin file.

So the node looks as if its data has mysteriously disappeared when in fact the
node itself should have been deleted.

The fix will be to remove all 'unreferenced' nodes. I'm not sure why I didn't do
this a long time ago; it may have been an oversight.
#@nonl
#@-node:ekr.20050225074932:Original posting: (not correct!)
#@+node:ekr.20050225104239.3:What I did
@killcolor

- Removed unused ignored param from putVnode.

- Added, then removed << delete all unvisited nodes >> in atFile.read.
    
    - Thin derived files are completely self contained, only the root node gets saved in the outline.

At present, I have no idea what happened!
#@nonl
#@-node:ekr.20050225104239.3:What I did
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):
    
    """Read any derived file."""

    at = self ; c = at.c
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if not at.thinFile:
        << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@nonl
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@nonl
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.72:createThinChild4
def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount > 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies > 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child
#@nonl
#@-node:ekr.20041005105605.72:createThinChild4
#@+node:ekr.20041005105605.74:scanText4 & allies
def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    << init ivars for scanText4 >>
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        << report unexpected end of text >>

    return at.lastLines
#@+node:ekr.20041005105605.75:<< init ivars for scanText4 >>
# Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)
#@nonl
#@-node:ekr.20041005105605.75:<< init ivars for scanText4 >>
#@+node:ekr.20041005105605.76:<< report unexpected end of text >>
assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))
#@nonl
#@-node:ekr.20041005105605.76:<< report unexpected end of text >>
#@+node:ekr.20041005105605.77:readNormalLine
def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        << Skip the leading stuff >>
        << Append s to docOut >>
#@nonl
#@+node:ekr.20041005105605.78:<< Skip the leading stuff >>
if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

#@-node:ekr.20041005105605.78:<< Skip the leading stuff >>
#@+node:ekr.20041005105605.79:<< Append s to docOut >>
line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)
#@nonl
#@-node:ekr.20041005105605.79:<< Append s to docOut >>
#@-node:ekr.20041005105605.77:readNormalLine
#@+node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.81:readStartAll (4.2)
def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)
#@nonl
#@-node:ekr.20041005105605.81:readStartAll (4.2)
#@+node:ekr.20041005105605.82:readStartAt & readStartDoc
def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)
#@nonl
#@-node:ekr.20041005105605.82:readStartAt & readStartDoc
#@+node:ekr.20041005105605.83:readStartLeo
def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")
#@nonl
#@-node:ekr.20041005105605.83:readStartLeo
#@+node:ekr.20041005105605.84:readStartMiddle
def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.84:readStartMiddle
#@+node:ekr.20041005105605.85:readStartNode (4.x)
def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        << set gnx and bump i >>
    << Set headline, undoing the CWEB hack >>
    if not at.root_seen:
        at.root_seen = True
        << Check the filename in the sentinel >>

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)
#@nonl
#@+node:ekr.20041005105605.86:<< set gnx and bump i >>
# We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i
#@nonl
#@-node:ekr.20041005105605.86:<< set gnx and bump i >>
#@+node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
# Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')
#@nonl
#@-node:ekr.20041005105605.87:<< Set headline, undoing the CWEB hack >>
#@+node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")
#@nonl
#@-node:ekr.20041005105605.88:<< Check the filename in the sentinel >>
#@-node:ekr.20041005105605.85:readStartNode (4.x)
#@+node:ekr.20041005105605.89:readStartOthers
def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.89:readStartOthers
#@-node:ekr.20041005105605.80:start sentinels
#@+node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.91:readEndAll (4.2)
def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)
#@nonl
#@-node:ekr.20041005105605.91:readEndAll (4.2)
#@+node:ekr.20041005105605.92:readEndAt & readEndDoc
def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True
#@nonl
#@-node:ekr.20041005105605.92:readEndAt & readEndDoc
#@+node:ekr.20041005105605.93:readEndLeo
def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True
#@nonl
#@-node:ekr.20041005105605.93:readEndLeo
#@+node:ekr.20041005105605.94:readEndMiddle
def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)
#@nonl
#@-node:ekr.20041005105605.94:readEndMiddle
#@+node:ekr.20041005105605.95:readEndNode (4.x)
def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            << indicate that the node has been changed >>
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)
#@nonl
#@+node:ekr.20041005105605.96:<< indicate that the node has been changed >>
if at.perfectImportRoot:
    << bump at.correctedLines and tell about the correction >>
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)
#@nonl
#@+node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
# Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','< >').replace('\t','<TAB>')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")
#@nonl
#@-node:ekr.20041005105605.97:<< bump at.correctedLines and tell about the correction >>
#@-node:ekr.20041005105605.96:<< indicate that the node has been changed >>
#@-node:ekr.20041005105605.95:readEndNode (4.x)
#@+node:ekr.20041005105605.98:readEndOthers
def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)
#@nonl
#@-node:ekr.20041005105605.98:readEndOthers
#@+node:ekr.20041005105605.99:readLastDocLine
def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    
#@nonl
#@-node:ekr.20041005105605.99:readLastDocLine
#@-node:ekr.20041005105605.90:end sentinels
#@+node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.101:ignoreOldSentinel
def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")
#@nonl
#@-node:ekr.20041005105605.101:ignoreOldSentinel
#@+node:ekr.20041005105605.102:readAfterRef
def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)
#@nonl
#@-node:ekr.20041005105605.102:readAfterRef
#@+node:ekr.20041005105605.103:readClone
def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val
#@nonl
#@-node:ekr.20041005105605.103:readClone
#@+node:ekr.20041005105605.104:readComment
def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
#@-node:ekr.20041005105605.104:readComment
#@+node:ekr.20041005105605.105:readDelims
def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j < i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j<i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 >= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")
#@nonl
#@-node:ekr.20041005105605.105:readDelims
#@+node:ekr.20041005105605.106:readDirective (@@)
def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) > 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            << handle @language >>
        elif g.match_word(s,i,"@comment"):
            << handle @comment >>

    at.out.append(s2)
#@nonl
#@+node:ekr.20041005105605.107:<< handle @language >>
# Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.107:<< handle @language >>
#@+node:ekr.20041005105605.108:<< handle @comment >>
j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")
#@nonl
#@-node:ekr.20041005105605.108:<< handle @comment >>
#@-node:ekr.20041005105605.106:readDirective (@@)
#@+node:ekr.20041005105605.109:readNl
def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')
#@nonl
#@-node:ekr.20041005105605.109:readNl
#@+node:ekr.20041005105605.110:readNonl
def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")
#@nonl
#@-node:ekr.20041005105605.110:readNonl
#@+node:ekr.20041005105605.111:readRef
@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @<< sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"<<"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) > 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
#@-node:ekr.20041005105605.111:readRef
#@+node:ekr.20041005105605.112:readVerbatim
def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])
#@nonl
#@-node:ekr.20041005105605.112:readVerbatim
#@-node:ekr.20041005105605.100:Unpaired sentinels
#@+node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)
#@nonl
#@-node:ekr.20041005105605.113:badEndSentinel, push/popSentinelStack
#@-node:ekr.20041005105605.74:scanText4 & allies
#@-node:ekr.20050209094854:(Investigated disappearing node body text)
#@+node:ekr.20050304072744.1:(Further problems specifying .leoID.txt)
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    << return if we can set self.leoID from sys.leoID >>
    << return if we can set self.leoID from "leoID.txt" >>

    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@nonl
#@+node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None
#@nonl
#@-node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()
g.app.gui = None

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@nonl
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                print s ; g.es(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@nonl
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@+node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
#@nonl
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        encoding = g.startupEncoding()
        path = g.os_path_abspath(leo.__file__,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20050328133444:computeStandardDirectories
def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
#@nonl
#@-node:ekr.20050328133444:computeStandardDirectories
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
#@nonl
#@-node:ekr.20041117151301.1:startupEncoding
#@-node:ekr.20050304072744:Compute directories... (leoGlobals)
#@-node:ekr.20050304072744.1:(Further problems specifying .leoID.txt)
#@+node:ekr.20050308021443:(Fixed crasher in atFile read logic when mod_labels plugin not enabled!)
#@+node:ekr.20050308021443.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3035871
By: e

open leoPy.leo
exceptions opening: C:\c\leo\V43leos\leo\src\LeoPyRef.leo
Traceback (most recent call last):
  File "c:\c\leo\V43leos\leo\src\leoGlobals.py", line 630, in openWithFileName
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "c:\c\leo\V43leos\leo\src\leoFileCommands.py", line 1285, in open
    ok, ratio =
self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
  File "c:\c\leo\V43leos\leo\src\leoFileCommands.py", line 632, in getLeoFile
    c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
  File "c:\c\leo\V43leos\leo\src\leoAtFile.py", line 486, in readAll
    at.read(p,thinFile=True)
  File "c:\c\leo\V43leos\leo\src\leoAtFile.py", line 432, in read
    self.copyAllTempBodyStringsToTnodes(root,thinFile)
  File "c:\c\leo\V43leos\leo\src\leoAtFile.py", line 2382, in
copyAllTempBodyStringsToTnodes
    c.mod_label_controller.add_label(p,"before change:",old_body)
AttributeError: Commands instance has no attribute 'mod_label_controller'

leo stops loading so a save would lose information?
leo is changed but isn't indicated,
on exit you get the save/cancel popup.
#@nonl
#@-node:ekr.20050308021443.1:Report
#@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
def  copyAllTempBodyStringsToTnodes (self,root,thinFile):
    
    c = self.c
    for p in root.self_and_subtree_iter():
        try: s = p.v.t.tempBodyString
        except: s = ""
        old_body = p.bodyString()
        if s != old_body:
            if 0: # For debugging.
                print ; print "changed: " + p.headString()
                print ; print "new:",s
                print ; print "old:",p.bodyString()
            if thinFile:
                p.v.setTnodeText(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                p.setBodyStringOrPane(s) # Sets v and v.c dirty.

            if not thinFile or (thinFile and p.v.isDirty()):
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                g.es("changed: " + p.headString(),color="blue")
                p.setMarked()
#@nonl
#@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
#@-node:ekr.20050308021443:(Fixed crasher in atFile read logic when mod_labels plugin not enabled!)
#@+node:ekr.20050308100508:(Fix colorizer bug for initial @nocolor in @root nodes)
#@+node:ekr.20050308100508.1:Report
@killcolor

in LeoDocs.leo in Tangling @root trees with the Tangle commands

the node starts out with the @nocolor directive, but Python keywords
(e.g. 'is', 'for', etc.) are coloured blue anyway.
#@-node:ekr.20050308100508.1:Report
#@+node:ekr.20031218072017.1614:continueDocPart
def continueDocPart (self,s,i):
    
    state = "doc"
    if self.language == "cweb":
        << handle cweb doc part >>
    else:
        << handle noweb doc part >>
    return i,state
#@nonl
#@+node:ekr.20031218072017.1615:<< handle cweb doc part >>
word = self.getCwebWord(s,i)
if word and len(word) > 0:
    j = i + len(word)
    if word in ("@<","@(","@c","@d","@f","@p"):
        state = "normal" # end the doc part and rescan
    else:
        # The control code does not end the doc part.
        self.tag("keyword",i,j)
        i = j
        if word in ("@^","@.","@:","@="): # Ended by "@>"
            j = s.find("@>",i)
            if j > -1:
                self.tag("cwebName",i,j)
                self.tag("nameBrackets",j,j+2)
                i = j + 2
elif g.match(s,i,self.lb):
    j = self.doNowebSecRef(s,i)
    if j == i + 2: # not a section ref.
        self.tag("docPart",i,j)
    i = j
elif self.latex_cweb_docs:
    # Everything up to the next "@" is latex colored.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.doLatexLine(s,i,j)
    i = j
else:
    # Everthing up to the next "@" is in the doc part.
    j = s.find("@",i+1)
    if j == -1: j = len(s)
    self.tag("docPart",i,j)
    i = j
#@nonl
#@-node:ekr.20031218072017.1615:<< handle cweb doc part >>
#@+node:ekr.20031218072017.1616:<< handle noweb doc part >>
if i == 0 and g.match(s,i,"<<"):
    # Possible section definition line.
    return i,"normal" # rescan the line.

if i == 0 and s[i] == '@':
    j = self.skip_id(s,i+1,chars='-')
    word = s[i:j]
    word = word.lower()
else:
    word = ""
    
if word in ["@c","@code","@unit","@root","@root-code","@root-doc","@color","@nocolor"]:
    # End of the doc part.
    self.body.tag_remove("docPart",self.index(i),self.index(j)) # 10/27/03
    self.tag("leoKeyword",i,j)
    state = "normal"
    if word != '@nocolor': i = j # 3/8/05: Rescan @nocolor.
else:
    # The entire line is in the doc part.
    j = len(s)
    if not g.doHook("color-optional-markup",
        colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="docPart"):
        self.tag("docPart",i,j)
    i = j # skip the rest of the line.
#@-node:ekr.20031218072017.1616:<< handle noweb doc part >>
#@-node:ekr.20031218072017.1614:continueDocPart
#@-node:ekr.20050308100508:(Fix colorizer bug for initial @nocolor in @root nodes)
#@+node:ekr.20050307194326:(Fixed @wrap bug)
#@+node:ekr.20050307194326.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3035471
By: brianvanden

Leo 4.3 alpha 3, build  1.224 , February 24, 2005
Python 2.4.0, Tk 8.4.7, win32
Windows Me.

Open a leo file with an @wrap directive somewhere within it. Visit a node in
an @wrap subtree (it need not be the node which contains the @wrap directive;
a descendant of such a node will do). The horizontal scrollbar disappears.

Now, visit a node without an @wrap, nor within the scope of an @wrap. The horizontal
scrollbar does not come back, even if the text extends past the edge of the
window.

The only way I have found to get it back is to quit leo and relaunch. Then,
the horizontal scrollbar is in place again, but only until an @wrap node is
visited.

The only forum post I found on point was
<http://sourceforge.net/forum/message.php?msg_id=2171987>, which males me wonder
if the behaviour I observe is a bug that has been introduced in the meantime.

Brian vdB
#@nonl
#@-node:ekr.20050307194326.1:Report
#@+node:ekr.20031218072017.1540:f.setWrap
def setWrap (self,p):
    
    c = self.c
    theDict = g.scanDirectives(c,p)
    if not theDict: return
    
    wrap = theDict.get("wrap")
    if self.body.wrapState == wrap: return

    self.body.wrapState = wrap
    # g.trace(wrap)
    if wrap:
        self.bodyCtrl.configure(wrap="word")
        self.bodyXBar.pack_forget()
    else:
        self.bodyCtrl.configure(wrap="none")
        # Bug fix: 3/10/05: We must unpack the text area to make the scrollbar visible.
        self.bodyCtrl.pack_forget()
        self.bodyXBar.pack(side="bottom", fill="x")
        self.bodyCtrl.pack(expand=1,fill="both")
#@nonl
#@-node:ekr.20031218072017.1540:f.setWrap
#@-node:ekr.20050307194326:(Fixed @wrap bug)
#@+node:ekr.20050311100936:(Fixed two change-all bugs)
#@+node:ekr.20050312095900:What I did
@killcolor

The problem was a race condition: writing to the log disabled the next redraw!

The solution is to put calls to c.endUpdate() after all calls to g.es().

This is a global constraint on all calls to c.endUpdate.  I've made a note of it.

Fixed similar problem with the Mark Changed Headlines and Mark Changed Roots
commands. While I was at it, I converted the code to use c.allNodes_iter().

-------------

A second bug: the current headline wasn't being updated.

Fixed this by _removing_ the calls to:

    c.frame.tree.onHeadChanged(v)
    c.frame.body.onBodyChanged(v,"Can't Undo")

in changeAll.  Apparently these were interfering with later redraws.
#@nonl
#@-node:ekr.20050312095900:What I did
#@+node:ekr.20050311100936.1:Report
@killcolor

https://sourceforge.net/forum/message.php?msg_id=3042593
By: brianvanden

Leo 4.3 alpha 3, build  1.224 , February 24, 2005
Python 2.4.0, Tk 8.4.7, win32

I used the find panel to change all occurrences of some string, say "foobar",
within a Leo file to another, say "spamham". The find panel was configured to
process headline titles, and a visible node had a headline containing "foobar";
it did not appear to have been changed. However, if you collapse a parent node
of the "foobar" containing headline and then re-expand it, the headline now
contains "spamham" as desired.

The principle of least surprise suggest that Leo ought not require the
collapse/expand epicycle to reflect the change. Have I overlooked a good reason
for this behaviour? Assuming not:

My naive (I am almost totally ignorant of Tkinter, not an accomplished Python
programmer, and have read little of Leo's code) armchair analysis makes me think
Leo ought keep track of whether any headline text was changed by a change command,
and if so, automatically repaint the tree.

If a fix for this is more than a few minutes (and thus not trivial enough to
leap to near the top of the `todo' list), I would be interested in seeing what
sense I could make of the situation. In that event, given the naivety mentioned
above, any nudging towards the right direction would be most welcome.
#@nonl
#@-node:ekr.20050311100936.1:Report
#@+node:ekr.20050314044242.1:Report 2
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3045823
By: nobody

Running with latest CVS version. Start Leo. It displays an empty outline with
"NewHeader". Press CTRL-F. Replace "e" with "ZZZ". Select "Plain search", unselect
"whole word", select "entire outline", select "search headline text", unselect
"search body text". Click "Change All". The headline remains unchanged  even
though the log window says it changed 3 instances.

Add a new node. Leave the title "NewHeadline". Click on the first node. Do the
same change operation again. The second headline (unmarked) gets changed; the
first headline (the marked current node) remains unchanged, even though the
log window says it changed 6 occurrences (it really only changed 3).
#@nonl
#@-node:ekr.20050314044242.1:Report 2
#@+node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; st = self.s_ctrl ; gui = g.app.gui
    # Replace the selection with self.change_text
    if gui.compareIndices(st,pos1, ">", pos2):
        pos1,pos2=pos2,pos1
    gui.replaceSelectionRangeWithText(st,pos1,pos2,self.change_text)
    s = gui.getAllText(st)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+'+'+str(len(self.change_text))+'c')
    gui.setSelectionRange(st,insert,insert)
    gui.setInsertPoint(st,insert)
    # Update the node
    if self.in_headline:
        << change headline >>
    else:
        << change body >>
#@nonl
#@+node:ekr.20031218072017.2294:<< change headline >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():
    
    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
    
    u.afterChangeNodeContents(p,'Change Headline',undoData)
#@nonl
#@-node:ekr.20031218072017.2294:<< change headline >>
#@+node:ekr.20031218072017.2295:<< change body >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():
    
    undoData = u.beforeChangeNodeContents(p)

    p.setBodyStringOrPane(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
     
    u.afterChangeNodeContents(p,'Change Body',undoData)
#@nonl
#@-node:ekr.20031218072017.2295:<< change body >>
#@-node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
#@+node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
def changeAll(self):

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    st = self.s_ctrl ; gui = g.app.gui
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if not pos1: break
            count += 1
            self.batchChange(pos1,pos2)
            line = gui.getLineContainingIndex(st,pos1)
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
        self.restore(saveData)
    c.endUpdate()
#@-node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
#@+node:ekr.20040803072955.58:redraw_now
# Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):
    
    # Bug fix: Cancel any pending redraw "by hand".
    # Make _sure_ that no other redraws take place after this.
    self.disableRedraw = True
    self.canvas.update_idletasks()
    self.disableRedraw = False
        
    # Now do the actual redraw.
    self.idle_redraw(scroll=scroll)
#@nonl
#@-node:ekr.20040803072955.58:redraw_now
#@+node:ekr.20050208133438:forceLogUpdate
def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False
#@nonl
#@-node:ekr.20050208133438:forceLogUpdate
#@+node:ekr.20031218072017.2952:c.endUpdate
def endUpdate(self, flag=True):
    
    '''End a beginUpdate/endUpdate region.
    
    Redraw the tree if this is the outermost endUpdate.
    
    Note that calls to g.es() will disable redraws, so calls to endUpdate
    should follow all such writes to the log pane.'''
    
    
    self.frame.tree.endUpdate(flag)
    
EndUpdate = endUpdate # Compatibility with old scripts
#@nonl
#@-node:ekr.20031218072017.2952:c.endUpdate
#@+node:ekr.20031218072017.3715:tree.endUpdate
def endUpdate (self,flag=True):
    
    '''Redraw the tree if this is the outermost endUpdate.
    
    Calls to g.es() will disable redraws, so calls to c.endUpdate
    should follow all such writes to the log pane.'''

    assert(self.updateCount > 0)
    self.updateCount -= 1
    # g.trace(self.updateCount, 'disableRedraw',self.disableRedraw)

    if flag and self.updateCount == 0:
        # Bug fix: 3/11/05. Force a redraw here.
        # Writing to the log sets self.disableRedraw.
        self.disableRedraw = False
        self.redraw()
#@nonl
#@-node:ekr.20031218072017.3715:tree.endUpdate
#@+node:ekr.20040803072955.55:tree.redraw
# Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(self.updateCount,self.redrawScheduled)
    
    if self.updateCount == 0 and not self.redrawScheduled:
        self.redrawScheduled = True
        self.canvas.after_idle(self.idle_redraw)
#@nonl
#@-node:ekr.20040803072955.55:tree.redraw
#@+node:ekr.20040803072955.59:idle_redraw
def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    << return if disabled, or quitting or dragging >>

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        # Do a scrolling operation after the scrollbar is redrawn
        if scroll:
            self.canvas.after_idle(self.idle_scrollTo)
        if 0:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@+node:ekr.20040803072955.60:<< return if disabled, or quitting or dragging >>
# g.trace('disableRedraw',self.disableRedraw)

if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return
#@nonl
#@-node:ekr.20040803072955.60:<< return if disabled, or quitting or dragging >>
#@-node:ekr.20040803072955.59:idle_redraw
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self): 

    c = self
    c.beginUpdate()
    for p in c.allNodes_iter():
        if p.isDirty()and not p.isMarked():
            p.setMarked()
            c.setChanged(True)
    g.es("done",color="blue")
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self):

    c = self
    c.beginUpdate()
    for p in c.allNodes_iter():
        if p.isDirty()and not p.isMarked():
            s = p.bodyString()
            flag, i = g.is_special(s,0,"@root")
            if flag:
                p.setMarked()
                c.setChanged(True)
    g.es("done",color="blue")
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2924:markChangedRoots
#@-node:ekr.20050311100936:(Fixed two change-all bugs)
#@-node:ekr.20050225104239.1:Bugs
#@+node:ekr.20050225104239.2:Features
#@+node:ekr.20050309082255:removed all reloads from test.leo
#@-node:ekr.20050309082255:removed all reloads from test.leo
#@+node:ekr.20050311083919:deprecated new_c key in hooks, added c key
#@-node:ekr.20050311083919:deprecated new_c key in hooks, added c key
#@+node:ekr.20050312111805.1:(Added Add/Delete Comments commands)
#@+node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
self.editMenuEditBodyTable = (
    ("Extract &Section","Shift+Ctrl+E",c.extractSection),
    ("Extract &Names","Shift+Ctrl+N",c.extractSectionNames),
    ("&Extract","Shift+Ctrl+D",c.extract),
    ("-",None,None),
    ("Convert All B&lanks",None,c.convertAllBlanks),
    ("Convert All T&abs",None,c.convertAllTabs),
    ("Convert &Blanks","Shift+Ctrl+B",c.convertBlanks),
    ("Convert &Tabs","Shift+Ctrl+J",c.convertTabs),
    ("Insert Body Time/&Date","Shift+Ctrl+G",c.insertBodyTime),
    ("&Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
    ("-",None,None),
    ("&Indent","Ctrl+]",c.indentBody),
    ("&Unindent","Ctrl+[",c.dedentBody),
    ("&Match Brackets","Ctrl+K",c.findMatchingBracket),
    ("Add Comments",None,c.addComments),
    ("Delete Comments",None,c.deleteComments),
)

# Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@nonl
#@-node:ekr.20031218072017.3754:<< define editMenuEditBodyTable >>
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@-node:ekr.20050312111805.1:(Added Add/Delete Comments commands)
#@-node:ekr.20050225104239.2:Features
#@+node:ekr.20050227125015:Plugins & hooks
#@+node:ekr.20050303104141:(Made sure file names get sanitized correctly)
#@+node:ekr.20050303104141.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3028085
By: randomandy

I was unable to get the vim plugin working on my Leo. After digging around I
finally discovered that it was an issue with the openWithTempFilePath() method.

The method tries to create a temp directory using the username. But in Windows
at least, user names may contain special characters which cause the tempdir
mkdir to choke. There may be some way to escape some quotes, but my attempt
at it was unsuccessful. I'm sure the layers of quote nesting there don't help
the odds any.

So what I chose to do instead was to just sanitize the directory name being
created with from the user name. (The base path is already sanitized at the
end.) That solved it for my case.  My user name has a period and spaces.
@color

def openWithTempFilePath (self,v,ext):

    """Return the path to the temp file corresponding to v and ext.

    Replaces the Commands method."""    

    try:
        #This allows a loophole
        #leoTempDir = getpass.getuser() + "_" + "Leo"
                   
        #At least in Windows, user name may contain special characters
        #which would require escaping quotes. Not wanting to deal with
        #layers of nested quotes, I chose to just sanitize the directory
        #name.     
        leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
    except:
        leoTempDir = "LeoTemp"
        g.es("Could not retrieve your user name.")
        g.es("Temporary files will be stored in: %s" % leoTempDir)

    td = os.path.join(os.path.abspath(tempfile.gettempdir()), leoTempDir)
    if not os.path.exists(td):
        os.mkdir(td)

    name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
    path = os.path.join(td,name)
    return path
#@nonl
#@-node:ekr.20050303104141.1:Report
#@+node:ekr.20050304092903:Notes
@killcolor

This is apparently a fix to the mod_tempfname plugin.
#@nonl
#@-node:ekr.20050304092903:Notes
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(os.path.abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20050303104141:(Made sure file names get sanitized correctly)
#@+node:ekr.20050301111302:(Added support for mod_labels plugin)
#@+node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
def  copyAllTempBodyStringsToTnodes (self,root,thinFile):
    
    c = self.c
    for p in root.self_and_subtree_iter():
        try: s = p.v.t.tempBodyString
        except: s = ""
        old_body = p.bodyString()
        if s != old_body:
            if 0: # For debugging.
                print ; print "changed: " + p.headString()
                print ; print "new:",s
                print ; print "old:",p.bodyString()
            if thinFile:
                p.v.setTnodeText(s)
                if p.v.isDirty():
                    p.setAllAncestorAtFileNodesDirty()
            else:
                p.setBodyStringOrPane(s) # Sets v and v.c dirty.

            if not thinFile or (thinFile and p.v.isDirty()):
                # New in Leo 4.3: support for mod_labels plugin:
                try:
                    c.mod_label_controller.add_label(p,"before change:",old_body)
                except Exception:
                    pass
                g.es("changed: " + p.headString(),color="blue")
                p.setMarked()
#@nonl
#@-node:ekr.20050301105854:copyAllTempBodyStringsToTnodes
#@-node:ekr.20050301111302:(Added support for mod_labels plugin)
#@+node:ekr.20050227080938:(Converted cleo.py to 4.3 code base)
#@+node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        else:
            # New in 4.3: _silently_ raise the attribute error.
            # This allows plugin code to use hasattr(p,attr) !
            if 0:
                print "unknown position attribute:",attr
                import traceback ; traceback.print_stack()
            raise AttributeError,attr
#@nonl
#@-node:ekr.20040117170612:p.__getattr__  ON:  must be ON if use_plugins
#@+node:ekr.20031218072017.3126:g.funcToMethod
@ The following is taken from page 188 of the Python Cookbook.

The following method allows you to add a function as a method of any class.  That is, it converts the function to a method of the class.  The method just added is available instantly to all existing instances of the class, and to all instances created in the future.

The function's first argument should be self.

The newly created method has the same name as the function unless the optional name argument is supplied, in which case that name is used as the method name.
@c

def funcToMethod(f,theClass,name=None):

    setattr(theClass,name or f.__name__,f)
    # g.trace(name)
#@nonl
#@-node:ekr.20031218072017.3126:g.funcToMethod
#@+node:ekr.20040803072955.52:drawTopTree
def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        try: self.redrawCount += 1
        except: self.radrawCount = 1
        g.trace(self.redrawCount,c.rootPosition())

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition & findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False
#@nonl
#@-node:ekr.20040803072955.52:drawTopTree
#@+node:ekr.20040803072955.134:tree.set...LabelState
#@+node:ekr.20040803072955.135:setNormalLabelState
def setNormalLabelState (self,p): # selected, editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 
    
    if p and p.edit_text():
        self.setEditHeadlineColors(p)
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        # Set the focus immediately
        self.frame.treeWantsFocus(p.edit_text(),later=False,tag='setNormalLabelState')
#@nonl
#@-node:ekr.20040803072955.135:setNormalLabelState
#@+node:ekr.20040803072955.136:setDisabledLabelState
def setDisabledLabelState (self,p): # selected, disabled

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return

    if p and p.edit_text():
        self.setDisabledHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.136:setDisabledLabelState
#@+node:ekr.20040803072955.137:setSelectedLabelState
def setSelectedLabelState (self,p): # selected, not editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    # g.trace(p)
    self.setDisabledLabelState(p)

#@-node:ekr.20040803072955.137:setSelectedLabelState
#@+node:ekr.20040803072955.138:setUnselectedLabelState
def setUnselectedLabelState (self,p): # not selected.

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    if p and p.edit_text():
        self.setUnselectedHeadlineColors(p)
#@nonl
#@-node:ekr.20040803072955.138:setUnselectedLabelState
#@+node:ekr.20040803072955.139:setDisabledHeadlineColors
def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.139:setDisabledHeadlineColors
#@+node:ekr.20040803072955.140:setEditHeadlineColors
def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.140:setEditHeadlineColors
#@+node:ekr.20040803072955.141:setUnselectedHeadlineColors
def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()
#@nonl
#@-node:ekr.20040803072955.141:setUnselectedHeadlineColors
#@-node:ekr.20040803072955.134:tree.set...LabelState
#@-node:ekr.20050227080938:(Converted cleo.py to 4.3 code base)
#@+node:ekr.20050303061941:(Changes to hooks)
#@+node:ekr.20050303062008:Notes
@killcolor

How it used to work:
    
- openWithFileName called 'open1' and 'open2' hooks.

- newLeoCommanderAndFrame called 'after-create-leo-frame' _after_ calling frame.finishCreate.

mod_scripting plugin doesn't create blue buttons if newLeoCommanderAndFrame always calls open1 and open2 hooks.
    - Changing 'open2' to 'open1' in mod_scripting creates other problems.

Conclusions:

1. 'open1' and 'open2' hooks _must_ stay as they are.
    - That is newLeoCommanderAndFrame must NOT call 'open1' and 'open2' hooks!

2. The 'after-create-leo-frame' hook isn't useful for plugins that want to insert menus.
    - In particular, it can not be used to register a 'create-optional-menus' hook.

What I did:

Warning: All the following items (except the first) have a (slight?) chance of impacting existing code.

- Added 'onCreate' hook in newLeoCommanderAndFrame.  This is called just _before_ calling frame.finishCreate.

- newLeoCommanderAndFrame calls 'onCreate' and 'after-create-leo-frame' hooks only if not g.app.initing.  This ensures that plugins won't be bothered with these hooks being while reading leoSettings.leo files.

- Leo clears g.app.initing before calling createFrame in leo.py.  This ensures that 'open1', 'open2', 'onCreate' and 'after-create-leo-frame' hooks get called for the initial window.  (Hopefully this will fix some problems that 'e' mentioned.)

- createFrame in leo.py calls a 'new' hook if createFrame doesn't call g.openWithFileName.  This ensures that a 'new' hook always gets called if an 'open1' and 'open2' hook doesn't get called.
#@nonl
#@-node:ekr.20050303062008:Notes
#@+node:ekr.20031218072017.1623:new
def new (self):

    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
    
    # 5/16/03: Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    
    c.beginUpdate()
    if 1: # within update
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    c.endUpdate()

    frame.body.setFocus()
    return c # For unit test.
#@nonl
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.es("This window already open")
            return True, frame
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    gui = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
    
    frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@nonl
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.2176:f.finishCreate
def finishCreate (self,c):
    
    frame = self ; frame.c = c ; gui = g.app.gui
    
    # This must be done after creating the commander.
    self.splitVerticalFlag,self.ratio,self.secondary_ratio = frame.initialRatios()
    << create the toplevel and outer frames >>
    << create the icon bar >>
    << create the splitters and their subframes >>
    << create the status line >>
    << create the first tree node >>
    << create the menu bar >>
    g.app.setLog(frame.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(frame)
    c.initVersion()
    c.signOnWithVersion()
    self.body.createBindings(frame)
#@nonl
#@+node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
frame.top = top = Tk.Toplevel()
gui.attachLeoIcon(top)
top.title(frame.title)
top.minsize(30,10) # In grid units.

frame.top.protocol("WM_DELETE_WINDOW", frame.OnCloseLeoEvent)
frame.top.bind("<Button-1>", frame.OnActivateLeoEvent)

# These don't work on Windows. Because of bugs in window managers,
# there is NO WAY to know which window is on top!
frame.top.bind("<Activate>",frame.OnActivateLeoEvent)
frame.top.bind("<Deactivate>",frame.OnDeactivateLeoEvent)

frame.top.bind("<Control-KeyPress>",frame.OnControlKeyDown)
frame.top.bind("<Control-KeyRelease>",frame.OnControlKeyUp)

# Create the outer frame, the 'hull' component.
self.outerFrame = outerFrame = Tk.Frame(top)
self.outerFrame.pack(expand=1,fill="both")
self.componentClass(c,'hull',self.outerFrame)
#@nonl
#@-node:ekr.20031218072017.2177:<< create the toplevel and outer frames >>
#@+node:ekr.20041224120552:<< create the icon bar >>
self.iconBarComponentName = 'iconBar'
iconBar = self.iconBarClass(c,outerFrame)
self.iconFrame = iconBar.iconFrame

self.iconBar = self.componentClass(c,
    self.iconBarComponentName,iconBar.iconFrame,
    iconBar,iconBar.pack,iconBar.unpack)

self.iconBar.show()
#@nonl
#@-node:ekr.20041224120552:<< create the icon bar >>
#@+node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
self.createLeoSplitters(outerFrame)

# Create the canvas, tree, log and body.
frame.canvas = self.createCanvas(self.split2Pane1)
frame.tree   = leoTkinterTree.leoTkinterTree(c,frame,frame.canvas)
frame.log    = leoTkinterLog(frame,self.split2Pane2)
frame.body   = leoTkinterBody(frame,self.split1Pane2)

self.componentClass(c,'tree',self.split2Pane1, frame.tree, self.packTree, self.unpackTree)
self.componentClass(c,'log', self.split2Pane2, frame.log,  self.packLog,  self.unpackLog)
self.componentClass(c,'body',self.split1Pane2, frame.body, self.packBody, self.unpackBody)

# Yes, this an "official" ivar: this is a kludge.
frame.bodyCtrl = frame.body.bodyCtrl

# Configure.
frame.setTabWidth(c.tab_width)
frame.tree.setColorFromConfig()
self.reconfigurePanes()
self.body.setFontFromConfig()
self.body.setColorFromConfig()
#@nonl
#@-node:ekr.20031218072017.2178:<< create the splitters and their subframes >>
#@+node:ekr.20031218072017.2180:<< create the first tree node >>
t = leoNodes.tnode()
v = leoNodes.vnode(c,t)
p = leoNodes.position(v,[])
v.initHeadString("NewHeadline")

p.moveToRoot()
c.beginUpdate()
c.selectVnode(p)
c.redraw()
c.frame.getFocus()
c.editPosition(p)
c.endUpdate(False)
#@-node:ekr.20031218072017.2180:<< create the first tree node >>
#@+node:ekr.20041225103412:<< create the status line >>
self.statusLineComponentName = 'statusLine'
statusLine = self.statusLineClass(c,outerFrame)

# Create offical ivars in the frame class.
self.statusFrame = statusLine.statusFrame
self.statusLabel = statusLine.labelWidget
self.statusText  = statusLine.textWidget

self.statusLine = self.componentClass(c,
    self.statusLineComponentName,
    statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
self.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20041225103412:<< create the status line >>
#@+node:ekr.20041225103412.1:<< create the menu bar >>
self.menu = leoTkinterMenu.leoTkinterMenu(frame)
v = c.currentVnode()
if not g.doHook("menu1",c=c,p=v,v=v):
    frame.menu.createMenuBar(self)
#@nonl
#@-node:ekr.20041225103412.1:<< create the menu bar >>
#@-node:ekr.20031218072017.2176:f.finishCreate
#@+node:ekr.20031218072017.3785:createMenusFromTables
def createMenusFromTables (self):

    c = self.c
    << create the file menu >>
    << create the edit menu >>
    << create the outline menu >>
    g.doHook("create-optional-menus",c=c)
    << create the window menu >>
    << create the help menu >>
#@nonl
#@+node:ekr.20031218072017.3790:<< create the file menu >>
fileMenu = self.createNewMenu("&File")

self.createMenuEntries(fileMenu,self.fileMenuTopTable,init=True)
self.createNewMenu("Open &With...","File")
self.createMenuEntries(fileMenu,self.fileMenuTop2Table,init=True)
<< create the recent files submenu >>
self.add_separator(fileMenu)
<< create the read/write submenu >>
<< create the tangle submenu >>
<< create the untangle submenu >>
<< create the import submenu >>
<< create the export submenu >>
self.add_separator(fileMenu)
self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable,init=True)
#@nonl
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("&Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:<< create the file menu >>
#@+node:ekr.20031218072017.3786:<< create the edit menu >>
editMenu = self.createNewMenu("&Edit")

self.createMenuEntries(editMenu,self.editMenuTopTable,init=True)

<< create the edit body submenu >>
<< create the edit headline submenu >>
<< create the find submenu >>

self.createMenuEntries(editMenu,self.editMenuTop2Table,init=True)
#@nonl
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:<< create the edit menu >>
#@+node:ekr.20031218072017.3797:<< create the outline menu >>
outlineMenu = self.createNewMenu("&Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable,init=True)

<< create check submenu >>
<< create expand/contract submenu >>
<< create move submenu >>
<< create mark submenu >>
<< create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable,init=True)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:<< create the outline menu >>
#@+node:ekr.20031218072017.3802:<< create the window menu >>
windowMenu = self.createNewMenu("&Window")

self.createMenuEntries(windowMenu,self.windowMenuTopTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3802:<< create the window menu >>
#@+node:ekr.20031218072017.3803:<< create the help menu >>
helpMenu = self.createNewMenu("&Help")

self.createMenuEntries(helpMenu,self.helpMenuTopTable,init=True)

if sys.platform=="win32":
    self.createMenuEntries(helpMenu,self.helpMenuTop2Table,init=True)

self.createMenuEntries(helpMenu,self.helpMenuTop3Table,init=True)
#@nonl
#@-node:ekr.20031218072017.3803:<< create the help menu >>
#@-node:ekr.20031218072017.3785:createMenusFromTables
#@-node:ekr.20050303061941:(Changes to hooks)
#@+node:ekr.20050309054857:(Changed 'onCreate' hook to 'before-create-leo-frame')
#@+node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    gui = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
    
    frame.finishCreate(c)
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)

    return c,frame
#@nonl
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
#@-node:ekr.20050309054857:(Changed 'onCreate' hook to 'before-create-leo-frame')
#@+node:ekr.20050308020541:(Fixed 2 problems in mod_scripting plugin)
 
#@nonl
#@+node:ekr.20050308020541.1:Traceback
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 2180, in doHook
    return f(tag,keywords)

  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 73, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "C:\prog\leoCVS\leo\src\leoPlugins.py", line 51, in callTagHandler
    result = handler(tag,keywords)

  File "c:\prog\leoCVS\leo\plugins\mod_scripting.py", line 160, in createAllButtons
    self.createStandardButtons()

  File "c:\prog\leoCVS\leo\plugins\mod_scripting.py", line 238, in createStandardButtons
    c = self.c ; p = c.currentPosition()

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 5232, in currentPosition
    if c._currentPosition:

AttributeError: Commands instance has no attribute '_currentPosition'
#@nonl
#@-node:ekr.20050308020541.1:Traceback
#@+node:ekr.20050308101529:Report: buttons installed twice
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3035661
By: nobody

new mod scripting run script/script button 
is installing twice. not at all on new leo.
from cvs 3/4/05 and 3/7 just now, uses onCreate hook.
may be anomaly or I just
didn't notice it yesterday.

open leo from shortcut
open a recent or new leo, no script buttons
close it
there are another set of script buttons on the first leo!
and then you can't rclick away @buttons in the first leo.
you can when you first open the leo from shortcut.
open leo file does get script buttons.
close it now the first has 3 sets of buttons.

redo the sequence
this time close the first leo, leave the new leo open
and magically script buttons appear where there were none.

replacing the comented out register line using
open2 and new doesn't work anymore in mod_scripting.
same problems w/py2.4 or 2.3 after reboot.
my local copies of a few plugins still work ok.

appropo of your comment about rewritting the hooks:
there was an indirect url to a joel on software artical 
on daily python the other day. from a comment by Guido,
why python 3000 will not be a complete rewrite.
how netscape might have lost valuable time and 
marketshare by rewriting netscape 6 from scratch
with very few of the origional v4 developers to boot.
they even had to completely trash version 5 for 
some possibly unrelated reason. details are fuzzy. 
maybe Internet Explorer was at version 6 
by the time they had a beta ready?
<http://joelonsoftware.com/articles/fog0000000069.html>

e
#@nonl
#@-node:ekr.20050308101529:Report: buttons installed twice
#@-node:ekr.20050308020541:(Fixed 2 problems in mod_scripting plugin)
#@+node:ekr.20050302074854.1:Fixed problem in templates.py
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3024624
By: e

- Changed 'new_c' logic to 'c' logic.
- Replaced 'start2' hook with 'new' hook.
#@nonl
#@-node:ekr.20050302074854.1:Fixed problem in templates.py
#@+node:ekr.20050311093518:Removed new_c from all plugins
Changed these plugins:

ConceptualSort.py
macros.py
scheduler.py
templates.py
dyna_menu.py
arrows.py
autocompleter.py
nodenavigator.py
nodebar.py
UASearch.py
URLloader.py
open_with.py
read_only_nodes.py
mod_scripting.py
base64Packager.py
multifile.py
cleo.py
mod_read_dir_outline.py
#@nonl
#@-node:ekr.20050311093518:Removed new_c from all plugins
#@+node:ekr.20050311101812:Removed 'start2' hook
import_cisco_config.py
scheduler.py
table.py
autocompleter.py
color_markup.py
nodebar.py
UASearch.py
URLloader.py
open_with.py
at_produce.py
read_only_nodes.py
usetemacs.py
xsltWithNodes.py
fastGotoNode.py
groupOperations.py
multifile.py
#@nonl
#@-node:ekr.20050311101812:Removed 'start2' hook
#@+node:ekr.20050311111530:Fixed crash in autocompleter(leoNodes) during unit test
What I did:
    - Disabled initial scan during unit test.
      The outline was being destroyed before the scan finished.

.Exception in thread Thread-21:
Traceback (most recent call last):
  File "c:\python24\lib\threading.py", line 442, in __bootstrap
    self.run()
  File "c:\python24\lib\threading.py", line 422, in run
    self.__target(*self.__args, **self.__kwargs)
  File "C:\prog\leoCVS\leo\plugins\autocompleter.py", line 440, in scan
    readOutline( c )
  File "C:\prog\leoCVS\leo\plugins\autocompleter.py", line 557, in readOutline
    setLanguage( z )
  File "C:\prog\leoCVS\leo\plugins\autocompleter.py", line 787, in setLanguage
    pos = pos.parent()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1812, in getParent
    def getParent        (self): return self.copy().moveToParent()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1603, in copy
    return position(self.v,self.stack,trace=False)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1547, in __init__
    if v: self.c = v.c
AttributeError: 'vnode' object has no attribute 'c'
#@nonl
#@-node:ekr.20050311111530:Fixed crash in autocompleter(leoNodes) during unit test
#@+node:ekr.20050312141953:(Fixed emacs & vim plugins)
#@+node:ekr.20050312141953.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3044258
By: nobody

The current cvs has broken the emacs/vim plugins. They open the node but the
changes aren't written back to leo.

EKR:  See << version history >> in each plugin for full details.
#@nonl
#@-node:ekr.20050312141953.1:Report
#@-node:ekr.20050312141953:(Fixed emacs & vim plugins)
#@-node:ekr.20050227125015:Plugins & hooks
#@+node:ekr.20050225155947:Docs
#@+node:ekr.20050202052911.2:Documentation of tnodeLists & potential problems
#@+node:ekr.20050225075604:The basic design
@killcolor

The essential point is that tnodeLists are a _substitute_ for gnx's. They are
used only for @file trees, not @thin trees.

Writing: When writing an @file putOpenNodeSentinel does:

    at.root.v.t.tnodeList.append(p.v.t)

So the tnodeList is a list of tnodes for the nodes in the order in which they
were written. 

Reading: When reading an @file tree, findChild4 does:

    t = at.root.v.t.tnodeList[at.tnodeListIndex]
    v = t.vnodeList[0] # Get any vnode joined to t.

That is, findChild4 finds a vnode given the next tnode in the tnodeList.

This assumes that the tnodeList (stored in the .leo file) matches the structure
of the thin derived file, which is ok in a single-user environment only.
#@nonl
#@-node:ekr.20050225075604:The basic design
#@+node:ekr.20041005105605.73:findChild4
def findChild4 (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""
    
    __pychecker__ = '--no-argsused' # headline might be used for debugging.
    
    # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
    # tnodeLists compensate (a hack) for not having gnx's in derived files! 

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
#@nonl
#@-node:ekr.20041005105605.73:findChild4
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try:
            # Pychecker doesn't like so many references in a row...
            t = at.root.v.t
            t.tnodeList.append(p.v.t)
        except AttributeError:
            pass # Do nothing.  We are creating a script.
#@nonl
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@-node:ekr.20050202052911.2:Documentation of tnodeLists & potential problems
#@+node:ekr.20050228200421:Revised scripting chapter (on web and in LeoDocs.leo) to use predefined g, c, p
#@-node:ekr.20050228200421:Revised scripting chapter (on web and in LeoDocs.leo) to use predefined g, c, p
#@-node:ekr.20050225155947:Docs
#@-node:ekr.20050225104239:4.3 a4 projects
#@+node:ekr.20050316083031:4.3 b1 projects
#@+node:ekr.20050316083031.1:Bugs...
#@+node:ekr.20050315082746:(Made sure NameErrors are reported with tracebacks in scripts)
#@+node:ekr.20050315082746.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3048149
By: bwmulder

Create a node with some code:

x = 0
import pdb; pdb.set_trace()
y = 1
z = z + 1

And then either use the "run_script" button from the plugin, or "execute script"
from the menu. You get:


>> <string>(5)?()

(Pdb) s

>> <string>(6)?()

(Pdb) s
NameError: "name 'z' is not defined"

>> <string>(6)?()

(Pdb) s
NameError: "name 'z' is not defined"

>> c:\bwm\svn_checkouts\oracle_ipf\trunk\python\other\leo_cvs\src\leocommands.py(

1195)executeScript()
-> exec script in d # Use {} to get a pristine environment!

[Assuming that you have a DOS window in which you started leo.py].

The debugger indicates some line numbers, but no source lines.

When you remove the import line, you just get:

exception executing script 
NameError: name 'z' is not defined
#@nonl
#@-node:ekr.20050315082746.1:Report
#@+node:ekr.20050316073527:What I did
@killcolor

The problem arose from a misguided attempt to eliminate non-useful information from traces.  Alas, the baby got thrown out with the bath water.

Here are the changes I made:

 - c.executeScript now calls g.es_exception(full=True) to ensure that a full stack trace always gets produced.  This is especially important when the exception happens in a module (file) called by the script.

-  c.executeScript now always executes the section < < dump the lines near the error > >,  regardless of context.  The lines are printed (in black) in the log.  This is useful information in almost all cases.

- After much experimentation, g.es_exception is basically unchanged.

Note: If the error occurs in your script itself (as contrasted with an exception thrown from a file called by your script) Leo always has properly put the cursor on the offending line.  I made no changes in this logic.

BTW, calling pdb.set_trace() in your scripts may cause more problems than it is worth.  Indeed.pdb.set_trace() uses only the information on the stack, and that may not be enough information to be useful.  I usually use g.trace to find out what is happening.  This works well.
#@nonl
#@-node:ekr.20050316073527:What I did
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@+node:ekr.20031218072017.3138:g.executeScript
def executeScript (name):
    
    """Execute a script whose short python file name is given"""
    
    mod_name,ext = g.os_path_splitext(name)
    theFile = None
    try:
        # This code is in effect an import or a reload.
        # This allows the user to modify scripts without leaving Leo.
        import imp
        theFile,filename,description = imp.find_module(mod_name)
        imp.load_module(mod_name,theFile,filename,description)
    except:
        g.es("Exception executing " + name,color="red")
        g.es_exception()

    if theFile:
        theFile.close()
#@nonl
#@-node:ekr.20031218072017.3138:g.executeScript
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20031218072017.3108:Dumps
#@+node:ekr.20031218072017.3109:dump
def dump(s):
    
    out = ""
    for i in s:
        out += str(ord(i)) + ","
    return out
        
def oldDump(s):

    out = ""
    for i in s:
        if i=='\n':
            out += "[" ; out += "n" ; out += "]"
        if i=='\t':
            out += "[" ; out += "t" ; out += "]"
        elif i==' ':
            out += "[" ; out += " " ; out += "]"
        else: out += i
    return out
#@nonl
#@-node:ekr.20031218072017.3109:dump
#@+node:ekr.20031218072017.3110:es_error
def es_error (s,color=None):

    if color is None and g.app.config: # May not exist during initialization.
        color = g.app.config.getColor(None,"log_error_color")

    g.es(s,color=color)
#@nonl
#@-node:ekr.20031218072017.3110:es_error
#@+node:ekr.20031218072017.3111:es_event_exception
def es_event_exception (eventName,full=False):

    g.es("exception handling ", eventName, " event")
    typ,val,tb = sys.exc_info()

    if full:
        errList = traceback.format_exception(typ,val,tb)
    else:
        errList = traceback.format_exception_only(typ,val)

    for i in errList:
        g.es(i)
        
    if not g.stdErrIsRedirected(): # 2/16/04
        traceback.print_exc()
#@nonl
#@-node:ekr.20031218072017.3111:es_event_exception
#@+node:ekr.20031218072017.3112:es_exception & test
def es_exception (full=True,c=None,color="red"):
    
    __pychecker__ = '--no-argsused' # c not used. retained for compatibility.

    typ,val,tb = sys.exc_info()

    # g.trace(full,typ,tb)
    
    fileName,n = g.getLastTracebackFileAndLineNumber()

    if full or g.app.debugSwitch > 0:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        if 0: # We might as well print the entire SyntaxError message.
            lines = lines[-1:] # Usually only one line, but more for Syntax errors!

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    if g.app.debugSwitch > 1:
        import pdb # Be careful: g.pdb may or may not have been defined.
        pdb.set_trace()

    return fileName,n
#@nonl
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@nonl
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20031218072017.3112:es_exception & test
#@+node:ekr.20040731204831:getLastTracebackFileAndLineNumber
def getLastTracebackFileAndLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code is similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return filename,lineno
        except:
            g.trace("bad line number")
            return None,0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        # g.trace(data)
        item = data[-1]
        filename = item[0]
        n = item[1]
        return filename,n
#@nonl
#@-node:ekr.20040731204831:getLastTracebackFileAndLineNumber
#@+node:ekr.20031218072017.3113:printBindings
def print_bindings (name,window):

    bindings = window.bind()
    print
    print "Bindings for", name
    for b in bindings:
        print b
#@nonl
#@-node:ekr.20031218072017.3113:printBindings
#@+node:ekr.20031218072017.3114:printGlobals
def printGlobals(message=None):
    
    # Get the list of globals.
    globs = list(globals())
    globs.sort()
    
    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    for glob in globs:
        print glob
#@nonl
#@-node:ekr.20031218072017.3114:printGlobals
#@+node:ekr.20031218072017.3115:printLeoModules
def printLeoModules(message=None):
    
    # Create the list.
    mods = []
    for name in sys.modules.keys():
        if name and name[0:3] == "leo":
            mods.append(name)

    # Print the list.
    if message:
        leader = "-" * 10
        print leader, ' ', message, ' ', leader
    mods.sort()
    for m in mods:
        print m,
    print
#@nonl
#@-node:ekr.20031218072017.3115:printLeoModules
#@-node:ekr.20031218072017.3108:Dumps
#@-node:ekr.20050315082746:(Made sure NameErrors are reported with tracebacks in scripts)
#@+node:ekr.20050317153857:(Finally! fixed .leoID problem!)
#@+node:ekr.20050317153857.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3053699
By: nobody

I also struggled with leoID after changing from v4.2 to v4.3 on Windows (I started
http://sourceforge.net/forum/forum.php?thread_id=1240664&forum_id=10226).

Without HOME environmental variable or sitecustomize.py Leo creates leoID.txt
in the current working directory, not in the globalConfigDir as before.
My understanding is that HOME is not typically present on Windows, so this could
keep confusing HOME-less windows users.

The problem is computeHomeDir(). It returns current working directory if HOME
does not exist. From computeHomeDir() definition:

home = os.getenv('HOME',default=None) # home = None
home = g.os_path_abspath(home,encoding) # current working directory!

Note that it does not help if computeHomeDir() returns None. In that case
f = open(fn,'w') in
Code-->Core classes...-->@thin leoApp.py-->app.setLeoID--><< attempt to create
leoID.txt >>
still creates '.leoID.txt' in the current directory.

Things that work if HOME does not exist (not sure if work on Mac and Win98):
from user import home
os.path.expanduser('~')

Hope this is useful.

'vpe'

_____________________
#@nonl
#@-node:ekr.20050317153857.1:Report
#@+node:ekr.20050318021951:What I did
@killcolor

There were three similar bugs, all arising from the fact that g.os_path_abs and g.os_path_join return the _working_ directory if the initial path is None!

I removed my HOME directory for testing.  This was essential.

- Compute home directory must return None, rather than the working directory if the HOME variable is None.

- app.setLeoId must be careful (in two sections) to do nothing if any of (homeDir,globalConfigDir,loadDir) is None.
#@nonl
#@-node:ekr.20050318021951:What I did
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20031218072017.1978:app.setLeoID
def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir

    << return if we can set self.leoID from sys.leoID >>
    << return if we can set self.leoID from "leoID.txt" >>

    << put up a dialog requiring a valid id >>
    << attempt to create leoID.txt >>
#@nonl
#@+node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
# This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr & getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose:
        g.es("leoID = " + g.app.leoID, color="orange")
    return
else:
    g.app.leoID = None
#@nonl
#@-node:ekr.20031218072017.1979:<< return if we can set self.leoID from sys.leoID>>
#@+node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) > 0:
                g.app.leoID = s
                if verbose:
                    g.es("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()
#@nonl
#@-node:ekr.20031218072017.1980:<< return if we can set self.leoID from "leoID.txt" >>
#@+node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
# New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()
g.app.gui = None

# g.trace(g.app.leoID)
g.es("leoID = %s" % (repr(g.app.leoID)),color="blue")
#@nonl
#@-node:ekr.20031218072017.1981:<< put up a dialog requiring a valid id >>
#@+node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                print s ; g.es(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')
#@nonl
#@-node:ekr.20031218072017.1982:<< attempt to create leoID.txt >>
#@-node:ekr.20031218072017.1978:app.setLeoID
#@-node:ekr.20050317153857:(Finally! fixed .leoID problem!)
#@+node:ekr.20050328070924:(Investigated problem with LeoPluginsRef.leo)
#@+node:ekr.20050404103202:Report
@killcolor

The problem is that newButtons must use @nosent, so any changes to newButtons must be accompanied by a change to LeoPluginsRef.py.  There is nothing more that needs to be done.
#@nonl
#@-node:ekr.20050404103202:Report
#@+node:ekr.20050404103202.1:Log message
Warning: updating changed text in @file-noref newButtons.py
----- error reading @file: newButtons.py
bad tnodeList index: 14, <vnode 22734128:'@file-noref newButtons.py'>

#@-node:ekr.20050404103202.1:Log message
#@+node:ekr.20050202052911.2:Documentation of tnodeLists & potential problems
#@+node:ekr.20050225075604:The basic design
@killcolor

The essential point is that tnodeLists are a _substitute_ for gnx's. They are
used only for @file trees, not @thin trees.

Writing: When writing an @file putOpenNodeSentinel does:

    at.root.v.t.tnodeList.append(p.v.t)

So the tnodeList is a list of tnodes for the nodes in the order in which they
were written. 

Reading: When reading an @file tree, findChild4 does:

    t = at.root.v.t.tnodeList[at.tnodeListIndex]
    v = t.vnodeList[0] # Get any vnode joined to t.

That is, findChild4 finds a vnode given the next tnode in the tnodeList.

This assumes that the tnodeList (stored in the .leo file) matches the structure
of the thin derived file, which is ok in a single-user environment only.
#@nonl
#@-node:ekr.20050225075604:The basic design
#@+node:ekr.20041005105605.73:findChild4
def findChild4 (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""
    
    __pychecker__ = '--no-argsused' # headline might be used for debugging.
    
    # Note: tnodeLists are used _only_ when reading @file (not @thin) nodes.
    # tnodeLists compensate (a hack) for not having gnx's in derived files! 

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex >= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
#@nonl
#@-node:ekr.20041005105605.73:findChild4
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
def putOpenNodeSentinel(self,p,inAtAll=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)

    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        # It may not exist when executing scripts.
        try:
            # Pychecker doesn't like so many references in a row...
            t = at.root.v.t
            t.tnodeList.append(p.v.t)
        except AttributeError:
            pass # Do nothing.  We are creating a script.
#@nonl
#@-node:ekr.20041005105605.193:putOpenNodeSentinel (sets tnodeList) 4.x
#@-node:ekr.20050202052911.2:Documentation of tnodeLists & potential problems
#@-node:ekr.20050328070924:(Investigated problem with LeoPluginsRef.leo)
#@+node:ekr.20050416150731:Fixed conflicts in menu shortcuts
# The De-hoist command conflicted with the Expand/Contract submenu.
# Also, the Paste Node As Clone conflicted with the Mark submenu.
#@nonl
#@+node:ekr.20031218072017.3785:createMenusFromTables
def createMenusFromTables (self):

    c = self.c
    << create the file menu >>
    << create the edit menu >>
    << create the outline menu >>
    g.doHook("create-optional-menus",c=c)
    << create the window menu >>
    << create the help menu >>
#@nonl
#@+node:ekr.20031218072017.3790:<< create the file menu >>
fileMenu = self.createNewMenu("&File")

self.createMenuEntries(fileMenu,self.fileMenuTopTable,init=True)
self.createNewMenu("Open &With...","File")
self.createMenuEntries(fileMenu,self.fileMenuTop2Table,init=True)
<< create the recent files submenu >>
self.add_separator(fileMenu)
<< create the read/write submenu >>
<< create the tangle submenu >>
<< create the untangle submenu >>
<< create the import submenu >>
<< create the export submenu >>
self.add_separator(fileMenu)
self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable,init=True)
#@nonl
#@+node:ekr.20031218072017.3791:<< create the recent files submenu >>
self.createNewMenu("Recent &Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.3791:<< create the recent files submenu >>
#@+node:ekr.20031218072017.3792:<< create the read/write submenu >>
readWriteMenu = self.createNewMenu("&Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3792:<< create the read/write submenu >>
#@+node:ekr.20031218072017.3793:<< create the tangle submenu >>
tangleMenu = self.createNewMenu("&Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3793:<< create the tangle submenu >>
#@+node:ekr.20031218072017.3794:<< create the untangle submenu >>
untangleMenu = self.createNewMenu("&Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3794:<< create the untangle submenu >>
#@+node:ekr.20031218072017.3795:<< create the import submenu >>
importMenu = self.createNewMenu("&Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3795:<< create the import submenu >>
#@+node:ekr.20031218072017.3796:<< create the export submenu >>
exportMenu = self.createNewMenu("&Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3796:<< create the export submenu >>
#@-node:ekr.20031218072017.3790:<< create the file menu >>
#@+node:ekr.20031218072017.3786:<< create the edit menu >>
editMenu = self.createNewMenu("&Edit")

self.createMenuEntries(editMenu,self.editMenuTopTable,init=True)

<< create the edit body submenu >>
<< create the edit headline submenu >>
<< create the find submenu >>

self.createMenuEntries(editMenu,self.editMenuTop2Table,init=True)
#@nonl
#@+node:ekr.20031218072017.3787:<< create the edit body submenu >>
editBodyMenu = self.createNewMenu("Edit &Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3787:<< create the edit body submenu >>
#@+node:ekr.20031218072017.3788:<< create the edit headline submenu >>
editHeadlineMenu = self.createNewMenu("Edit &Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3788:<< create the edit headline submenu >>
#@+node:ekr.20031218072017.3789:<< create the find submenu >>
findMenu = self.createNewMenu("&Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3789:<< create the find submenu >>
#@-node:ekr.20031218072017.3786:<< create the edit menu >>
#@+node:ekr.20031218072017.3797:<< create the outline menu >>
outlineMenu = self.createNewMenu("&Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable,init=True)

<< create check submenu >>
<< create expand/contract submenu >>
<< create move submenu >>
<< create mark submenu >>
<< create goto submenu >>
#@nonl
#@+node:ekr.20040711140738.1:<< create check submenu >>
checkOutlineMenu = self.createNewMenu("Chec&k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable,init=True)
#@nonl
#@-node:ekr.20040711140738.1:<< create check submenu >>
#@+node:ekr.20031218072017.3798:<< create expand/contract submenu >>
expandMenu = self.createNewMenu("E&xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3798:<< create expand/contract submenu >>
#@+node:ekr.20031218072017.3799:<< create move submenu >>
moveSelectMenu = self.createNewMenu("&Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3799:<< create move submenu >>
#@+node:ekr.20031218072017.3800:<< create mark submenu >>
markMenu = self.createNewMenu("M&ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3800:<< create mark submenu >>
#@+node:ekr.20031218072017.3801:<< create goto submenu >>
gotoMenu = self.createNewMenu("&Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3801:<< create goto submenu >>
#@-node:ekr.20031218072017.3797:<< create the outline menu >>
#@+node:ekr.20031218072017.3802:<< create the window menu >>
windowMenu = self.createNewMenu("&Window")

self.createMenuEntries(windowMenu,self.windowMenuTopTable,init=True)
#@nonl
#@-node:ekr.20031218072017.3802:<< create the window menu >>
#@+node:ekr.20031218072017.3803:<< create the help menu >>
helpMenu = self.createNewMenu("&Help")

self.createMenuEntries(helpMenu,self.helpMenuTopTable,init=True)

if sys.platform=="win32":
    self.createMenuEntries(helpMenu,self.helpMenuTop2Table,init=True)

self.createMenuEntries(helpMenu,self.helpMenuTop3Table,init=True)
#@nonl
#@-node:ekr.20031218072017.3803:<< create the help menu >>
#@-node:ekr.20031218072017.3785:createMenusFromTables
#@+node:ekr.20031218072017.3767:<< define outline menu tables >>
<< define outlineMenuTopMenuTable >>
<< define outlineMenuCheckOutlineMenuTable >>
<< define outlineMenuExpandContractMenuTable >>
<< define outlineMenuMoveMenuTable >>
<< define outlineMenuMarkMenuTable >>
<< define outlineMenuGoToMenuTable >>
#@nonl
#@+node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
self.outlineMenuTopMenuTable = (
    ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Pas&te Node As Clone",None,c.pasteOutlineRetainingClones),
    ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&Insert Node","Ctrl+I",c.insertHeadline),
    ("&Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
    ("&Sort Siblings","Alt+A",c.sortSiblings),
    ("-",None,None),
    ("&Hoist",None,c.hoist),
    ("D&e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
# Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:<< define outlineMenuTopMenuTable >>
#@+node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
self.outlineMenuCheckOutlineMenuTable = (

    ("Check &Outline",None,c.checkOutline),
    ("&Dump Outline",None,c.dumpOutline),
    ("-",None,None),
    ("Check &All Python Code",None,c.checkAllPythonCode),
    ("&Check Python &Code",None,c.checkPythonCode),
    ("-",None,None),
    ("Pretty P&rint All Python Code",None,c.prettyPrintAllPythonCode),
    ("&Pretty Print Python Code",None,c.prettyPrintPythonCode),
    
)

# shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:<< define outlineMenuCheckOutlineMenuTable >>
#@+node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
self.outlineMenuExpandContractMenuTable = (
    ("&Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &Node","Alt+[",c.contractNode),
    ("Contract &Parent","Alt+0",c.contractParent),
    ("Contract Or Go Left","Alt+LtArrow",c.contractNodeOrGoToParent),
    ("-",None,None),
    ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&ext Level","Alt+=",c.expandNextLevel),
    ("Expand Or Go Right","Alt+RtArrow",c.expandNodeOrGoToFirstChild),
    ("-",None,None),
    ("Expand To Level &1","Alt+1",c.expandLevel1),
    ("Expand To Level &2","Alt+2",c.expandLevel2),
    ("Expand To Level &3","Alt+3",c.expandLevel3),
    ("Expand To Level &4","Alt+4",c.expandLevel4),
    ("Expand To Level &5","Alt+5",c.expandLevel5),
    ("Expand To Level &6","Alt+6",c.expandLevel6),
    ("Expand To Level &7","Alt+7",c.expandLevel7),
    ("Expand To Level &8","Alt+8",c.expandLevel8),
    # ("Expand To Level &9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &All","Alt+9",c.expandAllHeadlines),
    ("Expand N&ode","Alt+]",c.expandNode))
#@nonl
#@-node:ekr.20031218072017.3769:<< define outlineMenuExpandContractMenuTable >>
#@+node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
self.outlineMenuMoveMenuTable = (
    ("Move &Down", "Ctrl+D",c.moveOutlineDown),
    ("Move &Left", "Ctrl+L",c.moveOutlineLeft),
    ("Move &Right","Ctrl+R",c.moveOutlineRight),
    ("Move &Up",   "Ctrl+U",c.moveOutlineUp),
    ("-",None,None),
    ("&Promote","Ctrl+{",c.promote),
    ("&Demote", "Ctrl+}",c.demote))
#@nonl
#@-node:ekr.20031218072017.3770:<< define outlineMenuMoveMenuTable >>
#@+node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
self.outlineMenuMarkMenuTable = (
    ("&Mark","Ctrl+M",c.markHeadline),
    ("Mark &Subheads","Alt+S",c.markSubheads),
    ("Mark Changed &Items","Alt+C",c.markChangedHeadlines),
    ("Mark Changed &Roots","Alt+R",c.markChangedRoots),
    ("Mark &Clones","Alt+K",c.markClones),
    ("&Unmark All","Alt+U",c.unmarkAll))
#@nonl
#@-node:ekr.20031218072017.3771:<< define outlineMenuMarkMenuTable >>
#@+node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
self.outlineMenuGoToMenuTable = (
    ("Go Back",None,c.goPrevVisitedNode), # Usually use buttons for this.
    ("Go Forward",None,c.goNextVisitedNode),
    ("-",None,None),
    ("Go To Next &Marked","Alt+M",c.goToNextMarkedHeadline),
    ("Go To Next C&hanged","Alt+D",c.goToNextDirtyHeadline),
    ("Go To Next &Clone","Alt+N",c.goToNextClone),
    ("-",None,None),
    ("Go To &First Node","Alt+Shift+G",c.goToFirstNode),
    ("Go To &Last Node","Alt+Shift+H",c.goToLastNode),
    ("Go To &Parent","Alt+Shift+P",c.goToParent),
    ("Go To P&rev Sibling","Alt+Shift+R",c.goToPrevSibling),
    ("Go To Next &Sibling","Alt+Shift+S",c.goToNextSibling),
    ("-",None,None),
    ("Go To Prev V&isible","Alt+UpArrow",c.selectVisBack),
    ("Go To Next &Visible","Alt+DnArrow",c.selectVisNext),
    ("Go To Prev Node","Alt+Shift+UpArrow",c.selectThreadBack),
    ("Go To Next Node","Alt+Shift+DnArrow",c.selectThreadNext))
#@nonl
#@-node:ekr.20031218072017.3772:<< define outlineMenuGoToMenuTable >>
#@-node:ekr.20031218072017.3767:<< define outline menu tables >>
#@-node:ekr.20050416150731:Fixed conflicts in menu shortcuts
#@+node:ekr.20050419062215.1:(Debugged @if-platform, @if-gui, @ints & @strings)
#@+node:ekr.20050419085131:Notes
@killcolor

g.app.gui typically not defined when the config settings are loaded, so to use a
setting in @if-gui a plugin would have to call g.app.config.readSettingsFiles.
#@nonl
#@-node:ekr.20050419085131:Notes
#@+node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
def visitNode (self,p):
    
    """Visit a node, and possibly append a widget description to self.widgets."""
    
    munge = g.app.config.munge
    h = p.headString().strip() or ''
    kind,name,val = self.parseHeadline(h)
    
    # g.trace(kind,name,val)

    f = self.dispatchDict.get(munge(kind))
    if f is not None:
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
            return None
#@nonl
#@-node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
#@+node:ekr.20041119204714:visitNode (settingsTreeParser)
def visitNode (self,p):
    
    """Init any settings found in node p."""
    
    # g.trace(p.headString())
    
    munge = g.app.config.munge

    kind,name,val = self.parseHeadline(p.headString())
    kind = munge(kind)

    if kind == "settings":
        pass
    elif kind not in self.control_types and val in (u'None',u'none','None','none','',None):
        # None is valid for all data types.
        self.set(p,kind,name,None)
    elif kind in self.control_types or kind in self.basic_types:
        f = self.dispatchDict.get(kind)
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
    elif name:
        # self.error("unknown type %s for setting %s" % (kind,name))
        # Just assume the type is a string.
        self.set(p,kind,name,val)
    
    return None
#@nonl
#@-node:ekr.20041119204714:visitNode (settingsTreeParser)
#@+node:ekr.20041119204700.1:traverse (parserBaseClass)
def traverse (self):
    
    c = self.c
    
    p = g.app.config.settingsRoot(c)
    if not p:
        return None

    self.settingsDict = {}
    after = p.nodeAfterTree()
    while p and p != after:
        result = self.visitNode(p)
        # g.trace(result,p.headString())
        if result == "skip":
            s = 'skipping settings in %s' % p.headString()
            print s ; g.es(s,color='blue')
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()
            
    return self.settingsDict
#@nonl
#@-node:ekr.20041119204700.1:traverse (parserBaseClass)
#@+node:ekr.20041119204700: ctor (parserBaseClass)
def __init__ (self,c):
    
    self.c = c
    self.recentFiles = [] # List of recent files.
    
    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        self.doIfGui,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        'shortcut':     self.doShortcut,
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }
#@nonl
#@-node:ekr.20041119204700: ctor (parserBaseClass)
#@+node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20041120094940.1:doBool
def doBool (self,p,kind,name,val):

    if val in ('True','true','1'):
        self.set(p,kind,name,True)
    elif val in ('False','false','0'):
        self.set(p,kind,name,False)
    else:
        self.valueError(p,kind,name,val)
#@nonl
#@-node:ekr.20041120094940.1:doBool
#@+node:ekr.20041120094940.2:doColor
def doColor (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)
#@nonl
#@-node:ekr.20041120094940.2:doColor
#@+node:ekr.20041120094940.3:doDirectory & doPath
def doDirectory (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)

doPath = doDirectory
#@nonl
#@-node:ekr.20041120094940.3:doDirectory & doPath
#@+node:ekr.20041120094940.6:doFloat
def doFloat (self,p,kind,name,val):
    
    try:
        val = float(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@nonl
#@-node:ekr.20041120094940.6:doFloat
#@+node:ekr.20041120094940.4:doFont
def doFont (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind not used.
    
    d = self.parseFont(p)
    
    # Set individual settings.
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data is not None:
            name,val = data
            setKind = key
            self.set(p,setKind,name,val)
#@nonl
#@-node:ekr.20041120094940.4:doFont
#@+node:ekr.20041120103933:doIf
def doIf(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used.

    g.trace("'if' not supported yet")
    return None
#@nonl
#@-node:ekr.20041120103933:doIf
#@+node:ekr.20041121125416:doIfGui
def doIfGui (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used.
    
    # g.trace(repr(name))
    
    if not g.app.gui or not g.app.gui.guiName():
        s = '@if-gui has no effect: g.app.gui not defined yet'
        print s ; g.es(s,color='blue')
        return "skip"
    elif g.app.gui.guiName().lower() == name.lower():
        return None
    else:
        return "skip"
#@nonl
#@-node:ekr.20041121125416:doIfGui
#@+node:ekr.20041120104215:doIfPlatform
def doIfPlatform (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used.
    
    # g.trace(sys.platform,repr(name))

    if sys.platform.lower() == name.lower():
        return None
    else:
        return "skip"
#@nonl
#@-node:ekr.20041120104215:doIfPlatform
#@+node:ekr.20041120104215.1:doIgnore
def doIgnore(self,p,kind,name,val):

    return "skip"
#@nonl
#@-node:ekr.20041120104215.1:doIgnore
#@+node:ekr.20041120094940.5:doInt
def doInt (self,p,kind,name,val):
    
    try:
        val = int(val)
        self.set(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@nonl
#@-node:ekr.20041120094940.5:doInt
#@+node:ekr.20041217132253:doInts
def doInts (self,p,kind,name,val):
    
    '''We expect @ints aName[val1,val2]=val'''

    name = name.strip() # The name indicates the valid values.
    i = name.find('[')
    j = name.find(']')
    
    # g.trace(kind,name,val)

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        name = name[0:i].strip()
        try:
            items = [int(item.strip()) for item in items]
        except ValueError:
            items = []
            self.valueError(p,'ints[]',name,val)
            return
        kind = "ints[%s]" % (','.join([str(item) for item in items]))
        try:
            val = int(val)
        except ValueError:
            self.valueError(p,'int',name,val)
            return
        if val not in items:
            self.error("%d is not in %s in %s" % (val,kind,name))
            return

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@nonl
#@-node:ekr.20041217132253:doInts
#@+node:ekr.20041120104215.2:doPage
def doPage(self,p,kind,name,val):

    pass # Ignore @page this while parsing settings.
#@nonl
#@-node:ekr.20041120104215.2:doPage
#@+node:ekr.20041121125741:doRatio
def doRatio (self,p,kind,name,val):
    
    try:
        val = float(val)
        if 0.0 <= val <= 1.0:
            self.set(p,kind,name,val)
        else:
            self.valueError(p,kind,name,val)
    except ValueError:
        self.valueError(p,kind,name,val)
#@nonl
#@-node:ekr.20041121125741:doRatio
#@+node:ekr.20041120113848:doShortcut
def doShortcut(self,p,kind,name,val):

    self.set(p,kind,name,val)
    self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120113848:doShortcut
#@+node:ekr.20041120105609:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind not used.
    
    #g.trace('*'*10,p.headString())

    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,val = self.parseShortcutLine(line)
            # g.trace(name,val)
            if val is not None:
                self.set(p,"shortcut",name,val)
                self.setShortcut(name,val)
#@nonl
#@-node:ekr.20041120105609:doShortcuts
#@+node:ekr.20041217132028:doString
def doString (self,p,kind,name,val):
    
    # At present no checking is done.
    self.set(p,kind,name,val)
#@-node:ekr.20041217132028:doString
#@+node:ekr.20041120094940.8:doStrings
def doStrings (self,p,kind,name,val):
    
    '''We expect @strings aName[val1,val2]=val'''
    
    name = name.strip()
    i = name.find('[')
    j = name.find(']')

    if -1 < i < j:
        items = name[i+1:j]
        items = items.split(',')
        items = [item.strip() for item in items]
        name = name[0:i].strip()

        kind = "strings[%s]" % (','.join(items))

        # g.trace(repr(kind),repr(name),val)

        # At present no checking is done.
        self.set(p,kind,name,val)
#@nonl
#@-node:ekr.20041120094940.8:doStrings
#@-node:ekr.20041120094940:kind handlers (parserBaseClass)
#@+node:ekr.20041120094940.10:valueError
def valueError (self,p,kind,name,val):
    
    """Give an error: val is not valid for kind."""
    
    __pychecker__ = '--no-argsused' # p not used, but needed.
    
    self.error("%s is not a valid %s for %s" % (val,kind,name))
#@nonl
#@-node:ekr.20041120094940.10:valueError
#@-node:ekr.20050419062215.1:(Debugged @if-platform, @if-gui, @ints & @strings)
#@+node:ekr.20050128092443:(Reloaded settings files when opening the settings dialog)
#@+node:ekr.20050419085515:Notes
@killcolor

> I...change the @settings node to @string server = mail.otherisp.net

the script doesn't print  -mail.otherisp.net-
until I restart Leo.

# EKR:  The change _is_ available if the change is made from the settings panel.  However, it is not available if the change is made in the Leo outline.  So opening the settings dialog should reload the files!

g.app.config.readSettingsFiles(c.fileName(),verbose=True) reloads all settings files.
#@nonl
#@-node:ekr.20050419085515:Notes
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20041225063637.65:writeChangedVars & helpers
def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '<none>'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
                print s ; g.es(s,color='blue')
            else:
                s = "write  %10s -> %10s %s" % (str(oldVal),str(newVal),iname)
                print s ; g.es(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList,"write")
#@nonl
#@+node:ekr.20041225063637.66:updateConfig
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Put the values in the body.
                p.initHeadString("@%s %s" % (kind,name))
                body = '\n'.join(val)
                p.setBodyStringOrPane(body)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.69:writeChangedList
def writeChangedList (self,changedList,tag):
    
    __pychecker__ = '--no-argsused' # tag used for debugging.
    
    filesInfoDict = self.filesInfoDict
    if 0:
        << dump all the dicts in filesInfoDict >>

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -> %10s %s" % (tag,kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # Always write the file so as to preserve expansion state.
        self.writeChangesToFile(c,changes,path)
        self.updateConfig(c,changes)
        d['changes'] = []
#@nonl
#@+node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print
#@nonl
#@-node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
#@-node:ekr.20041225063637.69:writeChangedList
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.fileName())
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@-node:ekr.20041225063637.65:writeChangedVars & helpers
#@-node:ekr.20050128092443:(Reloaded settings files when opening the settings dialog)
#@+node:ekr.20050422153813:Fixed bug in p.initStatus caught by pychecker
@killcolor

The status bits weren't being passed to v.initStatus.
#@nonl
#@-node:ekr.20050422153813:Fixed bug in p.initStatus caught by pychecker
#@+node:ekr.20050421185808:(Fixed Crasher in undo)
Exception executing command
Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1418, in undo
    u.undoHelper()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1442, in undoDeleteNode
    elif u.parent:
AttributeError: undoer instance has no attribute 'parent'

#@+node:ekr.20050412084055:undoDeleteNode
def undoDeleteNode (self):
    
    u = self ; c = u.c
    
    if u.oldBack:
        u.p.linkAfter(u.oldBack)
    elif u.oldParent:
        u.p.linkAsNthChild(u.oldParent,0)
    else:
        oldRoot = c.rootPosition()
        u.p.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.p.restoreLinksInTree()

    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412084055:undoDeleteNode
#@-node:ekr.20050421185808:(Fixed Crasher in undo)
#@+node:ekr.20050421190435:(Fixed crasher in import logic (leoAtFile)
Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 174, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 863, in importDerivedFile
    c.importCommands.importDerivedFiles(v,names)
  File "C:\prog\leoCVS\leo\src\leoImport.py", line 137, in importDerivedFiles
    isThin = at.scanHeaderForThin(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 570, in scanHeaderForThin
    junk,junk,isThin = at.scanHeader(theFile,fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2616, in scanHeader
    at.error("Bad @+leo sentinel in: %s" % fileName)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4500, in error
    self.printError(message)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4509, in printError
    if self.errors == 0:
AttributeError: atFile instance has no attribute 'errors'
#@+node:ekr.20041005105605.8:atFile.__init__ & initIvars
def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.

    << define the dispatch dictionary used by scanText4 >>
#@nonl
#@+node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }
#@nonl
#@-node:ekr.20041005105605.9:<< define the dispatch dictionary used by scanText4 >>
#@-node:ekr.20041005105605.8:atFile.__init__ & initIvars
#@+node:ekr.20050103163224:scanHeaderForThin
def scanHeaderForThin (self,theFile,fileName):
    
    '''Scan the header of a derived file and return True if it is a thin file.
    
    N.B. We are not interested in @first lines, so any encoding will do.'''
    
    at = self

    # The encoding doesn't matter.  No error messages are given.
    at.encoding = at.c.config.default_derived_file_encoding
    
    junk,junk,isThin = at.scanHeader(theFile,fileName)
    
    return isThin
#@nonl
#@-node:ekr.20050103163224:scanHeaderForThin
#@-node:ekr.20050421190435:(Fixed crasher in import logic (leoAtFile)
#@+node:ekr.20050424134449:(Put in protections against unbounded recursion in idle_scrollTo)
#@+node:ekr.20050424153218:Traceback
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1409, in idle_scrollTo
    h1 = self.yoffset(p)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1488, in yoffset
    h, flag = self.yoffsetTree(root,v1)
  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1506, in yoffsetTree
    h2, flag = self.yoffsetTree(child,p1)
  
# Maximum recursion depth exceeded.
#@nonl
#@-node:ekr.20050424153218:Traceback
#@+node:ekr.20040803072955.65:idle_scrollTo
def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p: p = self.c.currentPosition()
    if not p: p = self.c.rootPosition()
    if not p or not p.exists(c):
        g.trace('does not exist:',p.headString())
        return
    # g.trace(p.headString())
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:idle_scrollTo
#@+node:ekr.20040803072955.69:scrollTo
def scrollTo (self,p):
    
    def scrollToCallback(event=None,self=self,p=p):
        __pychecker__ = '--no-argsused' # event not used.
        self.idle_scrollTo(p)
    
    self.canvas.after_idle(scrollToCallback)
#@nonl
#@-node:ekr.20040803072955.69:scrollTo
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@+node:ekr.20040305173343:p.siblings_iter
class siblings_iter_class:

    '''Returns a list of siblings of a position, including the position itself!'''

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)
#@nonl
#@+node:ekr.20040305173343.1:__init__ & __iter__
def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

#@-node:ekr.20040305173343.1:__init__ & __iter__
#@+node:ekr.20040305173343.2:next
def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration
#@nonl
#@-node:ekr.20040305173343.2:next
#@-node:ekr.20040305173343:p.siblings_iter
#@-node:ekr.20050424134449:(Put in protections against unbounded recursion in idle_scrollTo)
#@-node:ekr.20050316083031.1:Bugs...
#@+node:ekr.20050316083031.2:Features...
#@+node:ekr.20050328133058.1:(Created stand-alone leoGlobals.py module)
#@+node:ekr.20050329031925:What I did
@killcolor

- Moved computeGlobalConfigDir, computeHomeDir, computeLoadDir and startupEncoding from leo.py to leoGlobals.py.

- Created g.computeStandardDirectories and used it in leo.py.

- Created g.createStandAloneApp using the above functions.  This function was based on the 'Standalone Operation' classed in the plugin_manager plugin.  g.createStandAloneApp doesn't actually use any of these classes because the nullGui class is basically a clumsier version of the BlackHole class.

- Added a do-nothing attachLeoIcon method to nullGui class to suppress a warning.  As I said, the nullGui class is not as elegant as Paul's BlackHole class.

- Added <<importLeoGlobals>> button to newButtons plugin.  This creates a node named
  << define importLeoGlobals >> whose body text defines an importLeoGlobals function.

The idea is that importing leoGlobals from a stand-alone plugin is a bit tricky.  The importLeoGlobals handles these details.  Note that we don't want to define importLeoGlobals in a node included by @others, because this function must be available to the code in the << imports >> section.  So we use a named section and reference it in before referencing the << imports >> section.  See the plugin_manager plugin for an example.

- Changed the plugin_manager plugin as follows:
    - Used the newButtons plugin to add an << define importLeoGlobals >> section.
    - Simplified the import logic using importLeoGlobals function.
    - Commented out the Standalone Operation classes.
    - Called g.createStandAloneApp in the '__name__ == "__main__"' code.

The new code passes all unit tests.  It's not too surprising that g.createStandAloneApp works in the plugin_manager plugin because all the new code was based on the old plugin_manager code.  Still, I believe the new code will be generally useful.
#@nonl
#@-node:ekr.20050329031925:What I did
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame
    
    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20050328133058:g.createStandAloneApp
def createStandAloneApp(pluginName=''):
    
    '''Create a version of the g.app object for 'stand-alone' plugins.'''
    
    if not g.app:
        Tk = g.importExtension('Tkinter',pluginName=pluginName,verbose=True)
        if Tk:
            import leoApp, leoGui
            g.app = leoApp.LeoApp()
            g.app.root = Tk.Tk()
            g.app.gui = leoGui.nullGui('<stand-alone app gui>')
            g.computeStandardDirectories()
    return g.app
#@nonl
#@-node:ekr.20050328133058:g.createStandAloneApp
#@+node:ekr.20050304072744:Compute directories... (leoGlobals)
#@+node:ekr.20041117155521:computeGlobalConfigDir
def computeGlobalConfigDir():
    
    # None of these suppresses warning about sys.leo_config_directory
    # __pychecker__ = '--no-objattrs --no-modulo1 --no-moddefvalue'
    
    import leoGlobals as g
    
    encoding = g.startupEncoding()

    try:
        theDir = sys.leo_config_directory
    except AttributeError:
        theDir = g.os_path_join(g.app.loadDir,"..","config")
        
    if theDir:
        theDir = g.os_path_abspath(theDir)
        
    if (
        not theDir or
        not g.os_path_exists(theDir,encoding) or
        not g.os_path_isdir(theDir,encoding)
    ):
        theDir = None
    
    return theDir
#@nonl
#@-node:ekr.20041117155521:computeGlobalConfigDir
#@+node:ekr.20041117151301:computeHomeDir
def computeHomeDir():
    
    """Returns the user's home directory."""
    
    import leoGlobals as g

    encoding = g.startupEncoding()
    # dotDir = g.os_path_abspath('./',encoding)
    home = os.getenv('HOME',default=None)

    if home and len(home) > 1 and home[0]=='%' and home[-1]=='%':
	    # Get the indirect reference to the true home.
	    home = os.getenv(home[1:-1],default=None)

    if home:
        # N.B. This returns the _working_ directory if home is None!
        # This was the source of the 4.3 .leoID.txt problems.
        home = g.os_path_abspath(home,encoding)
        if (
            not g.os_path_exists(home,encoding) or
            not g.os_path_isdir(home,encoding)
        ):
            home = None

    # g.trace(home)
    return home
#@nonl
#@-node:ekr.20041117151301:computeHomeDir
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        encoding = g.startupEncoding()
        path = g.os_path_abspath(leo.__file__,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@+node:ekr.20050328133444:computeStandardDirectories
def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
#@nonl
#@-node:ekr.20050328133444:computeStandardDirectories
#@+node:ekr.20041117151301.1:startupEncoding
def startupEncoding ():
    
    import leoGlobals as g
    import sys
    
    if sys.platform=="win32": # "mbcs" exists only on Windows.
        encoding = "mbcs"
    elif sys.platform=="dawwin":
        encoding = "utf-8"
    else:
        encoding = g.app.tkEncoding
        
    return encoding
#@nonl
#@-node:ekr.20041117151301.1:startupEncoding
#@-node:ekr.20050304072744:Compute directories... (leoGlobals)
#@-node:ekr.20050328133058.1:(Created stand-alone leoGlobals.py module)
#@+node:ekr.20050329055521:(Ignore problems opening settings file for chapters plugin)
#@+node:ekr.20050329061015:What I did
@killcolor

- config.openSettingsFile returns None if there is a read error.
- leoFileCommand.open gives no BadLeoFile message if silent is True.
#@nonl
#@-node:ekr.20050329061015:What I did
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@-node:ekr.20050329055521:(Ignore problems opening settings file for chapters plugin)
#@+node:ekr.20050212040628:(Improved write logic)
Or better yet, use CStringIO?
#@nonl
#@+node:ekr.20050405111218:What I did
@killcolor

- Simplified write_Leo_file using new leoFileCommand.deleteFileWithMessage and g.utils_rename.

- Eliminated outputList var.
    - The code that writes to a clipboard sets self.outputFile to g.fileLikeObject.

- Speeded up put routine: it always writes to self.outputFile.

- self.outputFile is now a cStringIo object.  However, the heart of the put routine is:

    s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
    self.outputFile.write(s)

and it appears that the call to g.toEncodedString is the limiting factor.
#@nonl
#@-node:ekr.20050405111218:What I did
#@+node:ekr.20050405105804:From leoGlobals
#@+node:ekr.20040331083824.1:g.fileLikeObject
# Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""
    
    @others
#@nonl
#@+node:ekr.20050404151753: ctor
def __init__(self,fromString=None):

    # New in 4.2.1: allow the file to be inited from string s.
    if fromString:
        self.list = g.splitLines(fromString) # Must preserve newlines!
    else:
        self.list = []

    self.ptr = 0
    
# In CStringIO the buffer is read-only if the initial value (fromString) is non-empty.
#@nonl
#@-node:ekr.20050404151753: ctor
#@+node:ekr.20050404151753.1:clear
def clear (self):
    
    self.list = []


#@-node:ekr.20050404151753.1:clear
#@+node:ekr.20050404151753.2:close
def close (self):
    
    pass
    
    # The StringIo version free's the memory buffer.
#@nonl
#@-node:ekr.20050404151753.2:close
#@+node:ekr.20050404151753.3:flush
def flush (self):
    
    pass
#@nonl
#@-node:ekr.20050404151753.3:flush
#@+node:ekr.20050404151753.4:get & getvalue
def get (self):

    return ''.join(self.list)
    
getvalue = get # for compatibility with StringIo
#@-node:ekr.20050404151753.4:get & getvalue
#@+node:ekr.20050404151753.5:readline
def readline(self): # New for read-from-string (readOpenFile).

    if self.ptr < len(self.list):
        line = self.list[self.ptr]
        # g.trace(repr(line))
        self.ptr += 1
        return line
    else:
        return ''
#@nonl
#@-node:ekr.20050404151753.5:readline
#@+node:ekr.20050404151753.6:write
def write (self,s):
    
    if s:
        self.list.append(s)
#@-node:ekr.20050404151753.6:write
#@-node:ekr.20040331083824.1:g.fileLikeObject
#@+node:ekr.20031218072017.1263:g.utils_rename & test
<< about os.rename >>

def utils_rename(src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''
    
    head,tail=g.os_path_split(dst)
    if head and len(head) > 0:
        g.makeAllNonExistentDirectories(head)
        
    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
        
    try:
        if 1: # Use rename in all cases.
            os.rename(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True
        else:
            # This isn't a great solution: distutils.file_util may not exist.
            if sys.platform=="win32":
                os.rename(src,dst)
            else:
                from distutils.file_util import move_file
                move_file(src,dst)
            if mode:
                g.utils_chmod(dst,mode,verbose)
            return True

    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False
#@nonl
#@+node:ekr.20050104123726.1:<< about os.rename >>
@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.
#@nonl
#@-node:ekr.20050104123726.1:<< about os.rename >>
#@+node:ekr.20050107085710.1:test_g_utils_rename
def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)
#@nonl
#@-node:ekr.20050107085710.1:test_g_utils_rename
#@-node:ekr.20031218072017.1263:g.utils_rename & test
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@-node:ekr.20050405105804:From leoGlobals
#@+node:ekr.20050404152720:From leoFileCommands
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        theActualFile = None
        << create backup file >>
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        << put the .leo file >>
        theActualFile.write(self.outputFile.getvalue())
        theActualFile.close()
        self.outputFile = None
        << delete backup file >>
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        << delete fileName >>
        << rename backupName to fileName >>
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
#@nonl
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@nonl
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20031218072017.1470:put (basic)(leoFileCommands)
def put (self,s):
    '''
    Put string s to self.outputFile.
    All output eventually comes here.
    '''
    # Improved code: self.outputFile (a cStringIO object) always exists.
    if s:
        s = g.toEncodedString(s,self.leo_file_encoding,reportErrors=True)
        self.outputFile.write(s)

def put_dquote (self):
    self.put('"')
        
def put_dquoted_bool (self,b):
    if b: self.put('"1"')
    else: self.put('"0"')
        
def put_flag (self,a,b):
    if a:
        self.put(" ") ; self.put(b) ; self.put('="1"')
        
def put_in_dquotes (self,a):
    self.put('"')
    if a: self.put(a) # will always be True if we use backquotes.
    else: self.put('0')
    self.put('"')

def put_nl (self):
    self.put("\n")
    
def put_tab (self):
    self.put("\t")
    
def put_tabs (self,n):
    while n > 0:
        self.put("\t")
        n -= 1
#@nonl
#@-node:ekr.20031218072017.1470:put (basic)(leoFileCommands)
#@+node:ekr.20031218072017.1573:putLeoOutline (to clipboard)
# Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline (self):

    self.outputFile = g.fileLikeObject()
    self.usingClipboard = True
    self.assignFileIndices() # 6/11/03: Must do this for 3.x code.
    self.putProlog()
    self.putClipboardHeader()
    self.putVnodes()
    self.putTnodes()
    self.putPostlog()
    s = self.outputFile.getvalue()
    self.outputFile = None
    self.usingClipboard = False
    return s
#@nonl
#@-node:ekr.20031218072017.1573:putLeoOutline (to clipboard)
#@+node:ekr.20050404190914.2:deleteFileWithMessage
def deleteFileWithMessage(self,fileName,kind):
    
    __pychecker__ = '--no-argsused' # kind unused: retained for debugging.

    try:
        os.remove(fileName)

    except Exception:
        if self.read_only:
            g.es("read only",color="red")
        g.es("exception deleting backup file:" + fileName)
        g.es_exception(full=False)
        return False
#@nonl
#@+node:ekr.20050404212949:test_fc_deleteFileWithMessage
def test_fc_deleteFileWithMessage(self):

    fc=c.fileCommands # Self is a dummy argument.
    fc.deleteFileWithMessage('xyzzy','test')
    
if 0: # one-time test of es statements.
    fileName = 'fileName' ; kind = 'kind'
    g.es("read only",color="red")
    g.es("exception deleting %s file: %s" % (fileName,kind))
    g.es("exception deleting backup file:" + fileName)
#@nonl
#@-node:ekr.20050404212949:test_fc_deleteFileWithMessage
#@-node:ekr.20050404190914.2:deleteFileWithMessage
#@-node:ekr.20050404152720:From leoFileCommands
#@-node:ekr.20050212040628:(Improved write logic)
#@+node:ekr.20050408110906:(Finished new undo)
#@+node:ekr.20050315133212:What I did
@nocolor

- Use the old generalized code?
    - Yes!  The old code works.
    - The new code should just repackage the old code.
- Use g.Bunch to simplify code.
- Added 'before' & 'after' methods
- Added entries to optionalIvars dynamically in bead methods.
- Eliminated 'case-itis' by making it unnessesary ever to add more cases.
- Removed 'v' key in undoer:  replaced it with 'p'.
- Replaced u.v by u.p and v by p in find code (It's too confusing).
- p.setDirty and p.setAllAncestorAtFileNodesDirty  return list of nodes that were marked dirty.
- Create new top-level before/after methods & helpers:
    before/afterClone
    before/afterDeleteNode
    before/afterInsertNode
    before/afterHoist
    before/afterDeHoist
- Changed setUndoTypingParams to use new dispatch method.
    - (Undo/redo typing now works again.)
- Removed makeBeadDict.
- Removed updateSetChangedFlag.
- Added new methods to nullUndoer class.
- Moved undo methods from leoNodes.py to leoUndo.py
- Added dirtyVnodeList param to afterChangeNodeContents.
@color
#@nonl
#@-node:ekr.20050315133212:What I did
#@+node:ekr.20050408055511:Calls to undoer methods
#@+node:ekr.20050408072730:From Commands...
#@+node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.1549:cutOutline
def cutOutline(self):

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
#@nonl
#@-node:ekr.20031218072017.1549:cutOutline
#@+node:ekr.20031218072017.1550:copyOutline
def copyOutline(self):

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
#@nonl
#@-node:ekr.20031218072017.1550:copyOutline
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return
    
    copiedBunchList = []
    if pasteAsClone:
        << put only needed info in copiedBunchList >>
    
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.beginUpdate()
    c.endEditing()
    if 1: # inside update...
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    c.endUpdate()
    c.recolor()
#@nonl
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
#@nonl
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@nonl
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self):
    
    c = self

    return c.pasteOutline(reassignIndices=False)
#@nonl
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@-node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.2028:Hoist & dehoist
def dehoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')

def hoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
#@nonl
#@-node:ekr.20031218072017.2028:Hoist & dehoist
#@+node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
    
    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if warningFlag:
                g.alert(message)
            return False
    return True
#@nonl
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,op_name="Delete Node"):
    
    """Deletes the current position.
    
    Does nothing if the outline would become empty."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    if 1: # In update...
        c.endEditing() # Make sure we capture the headline for Undo.
        undoData = u.beforeDeleteNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.doDelete(newNode)
        c.setChanged(True)
        u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()
    c.validateOutline()
#@nonl
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    if 1: # In update...
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].current)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.editPosition(p)
        c.selectPosition(p)
    c.endUpdate()
    return p # for mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.1762:c.clone
def clone (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    if 1: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone(p)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    c.endUpdate()

    return clone # For mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.1765:c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self):

    c = self
    
    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
#@nonl
#@-node:ekr.20031218072017.1765:c.validateOutline
#@-node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20050415134809:c.sortChildren
def sortChildren(self):

    c = self ; u = c.undoer ; undoType = 'Sort Children'
    p = c.currentPosition()
    if not p or not p.hasChildren(): return

    c.beginUpdate()
    if 1: # In update
        c.endEditing()
        u.beforeChangeGroup(p,undoType)
        c.sortChildrenHelper(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(p,undoType,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()
#@nonl
#@-node:ekr.20050415134809:c.sortChildren
#@+node:ekr.20040303175026.12:c.sortChildrenHelper
def sortChildrenHelper (self,p):
    
    c = self ; u = c.undoer

    # Create a list of tuples sorted on headlines.
    pairs = [(child.headString().lower(),child.copy()) for child in p.children_iter()]
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        undoData = u.beforeMoveNode(child)
        child.moveToNthChildOf(p,index)
        u.afterMoveNode(child,'Sort',undoData)
        index += 1
#@nonl
#@-node:ekr.20040303175026.12:c.sortChildrenHelper
#@+node:ekr.20050415134809.1:c.sortSiblings
def sortSiblings (self):
    
    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    p = c.currentPosition()
    if not p: return

    parent = p.parent()
    if not parent:
        c.sortTopLevel()
    else:
        c.beginUpdate()
        if 1: # In update...
            c.endEditing()
            u.beforeChangeGroup(p,undoType)
            c.sortChildrenHelper(parent)
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            c.setChanged(True)
            u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20031218072017.2896:c.sortTopLevel
def sortTopLevel (self):

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    root = c.rootPosition()
    if not root: return

    # Create a list of tuples sorted by headlines.
    pairs = [(p.headString().lower(),p.copy())
        for p in root.self_and_siblings_iter()]
    pairs.sort()
 
    c.beginUpdate()
    if 1: # In update...
        dirtyVnodeList = []
        u.beforeChangeGroup(root,undoType)
        if 1: # In group...
            h,p = pairs[0]
            if p != root:
                undoData = u.beforeMoveNode(p)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                p.moveToRoot(oldRoot=root)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMoveNode(p,'Sort',undoData)
            for h,next in pairs[1:]:
                undoData = u.beforeMoveNode(next)
                next.moveAfter(p)
                u.afterMoveNode(next,'Sort',undoData)
                p = next
        u.afterChangeGroup(root,undoType,dirtyVnodeList=dirtyVnodeList)
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2896:c.sortTopLevel
#@-node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    if 1: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        if count > 0:
            u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    if 1: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        if count > 0:
            u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20031218072017.1823:createLastChildNode
def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) > 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
#@nonl
#@-node:ekr.20031218072017.1823:createLastChildNode
#@+node:ekr.20031218072017.1824:dedentBody
def dedentBody (self):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1824:dedentBody
#@+node:ekr.20031218072017.1706:extract
def extract(self):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    junk, ws = g.skip_leading_ws_with_indent(headline,0,c.tab_width)

    # Remove leading whitespace from all body lines.
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1706:extract
#@+node:ekr.20031218072017.1708:extractSection
def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    headline = lines[0].strip() ; del lines[0]
    junk, ws = g.skip_leading_ws_with_indent(headline,0,c.tab_width)
    line1 = "\n" + headline
    << Set headline for extractSection >>
    
    # Remove leading whitespace from all body lines.
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@+node:ekr.20031218072017.1710:extractSectionNames
def extractSectionNames(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
#@nonl
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)
        
if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@nonl
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames
#@+node:ekr.20031218072017.1825:findBoundParagraph
def findBoundParagraph (self):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i < len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#	para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
#@nonl
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:findBoundParagraph
#@+node:ekr.20031218072017.1827:findMatchingBracket
def findMatchingBracket (self):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"<=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
#@nonl
#@+node:ekr.20031218072017.1828:findMatchingBracket
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,">=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level <= 0:
                return index
        if not forward and body.compareIndices(index,"<=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@nonl
#@-node:ekr.20031218072017.1828:findMatchingBracket
#@-node:ekr.20031218072017.1827:findMatchingBracket
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview
#@nonl
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.1830:indentBody
def indentBody (self):

    c = self ; undoType = 'Indent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1830:indentBody
#@+node:ekr.20031218072017.1831:insertBodyTime & allies
def insertBodyTime (self):
    
    c = self ; undoType = 'Insert Body Time'
    p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(p,undoType,oldSel=oldSel)
#@nonl
#@+node:ekr.20031218072017.1832:getTime
def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getString("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt     = c.config.getString("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
#@-node:ekr.20031218072017.1832:getTime
#@-node:ekr.20031218072017.1831:insertBodyTime & allies
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph(self):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
#@nonl
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
# Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 	18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 	18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
#@nonl
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo by calling setUndoTypingParams (in idle_body_key).
    body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    if 1: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@-node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = [] # List of strings comprising the line being accumulated.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.line = 0 # Same as self.srow
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False

    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine
def doMultiLine (self):
    
    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine
#@+node:ekr.20041021101911.5:doName
def doName(self):

    self.array.append("%s " % self.val)
    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.
    self.prevName = self.val
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):
    
    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel > 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel > 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20031218072017.1767:demote
def demote(self):

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext(): return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            return
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(current)
    c.endUpdate()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next: return
    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        << Move p down & set moved if successful >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
            c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)
#@nonl
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft(self):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasParent(): return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight(self):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasBack: return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True): return

    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        return

    c.beginUpdate()
    if 1: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        << Move p up >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
#@nonl
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren(): return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1774:promote
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.2353:c.dragAfter
def dragAfter(self,p,after):

    c = self ; u = self.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,after.parent(),True): return

    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty() # 1/12/04
        p.moveAfter(after)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2353:c.dragAfter
#@+node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
def dragCloneToNthChildOf (self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    
    c.beginUpdate()
    if 1: # In update...
        # g.trace("p,parent,n:",p.headString(),parent.headString(),n)
        clone = p.clone(p) # Creates clone & dependents, does not set undo.
        if not c.checkMoveWithParentWithWarning(clone,parent,True):
            clone.doDelete(p) # Destroys clone and makes p the current node.
            c.endUpdate(False) # Nothing has changed.
            return
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
           dirtyVnodeList2 =  p.setAllAncestorAtFileNodesDirty()
           dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(clone)
    c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2946:c.dragCloneToNthChildOf
#@+node:ekr.20031218072017.2947:c.dragToNthChildOf
def dragToNthChildOf(self,p,parent,n):

    c = self ; u = c.undoer ; undoType = 'Drag'
    current = c.currentPosition()
    inAtIgnoreRange = p.inAtIgnoreRange()
    if not c.checkMoveWithParentWithWarning(p,parent,True): return

    c.beginUpdate()
    if 1: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(current)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(parent,n)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    c.endUpdate()
    c.updateSyntaxColorer(p) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2947:c.dragToNthChildOf
#@+node:ekr.20031218072017.2948:c.dragCloneAfter
def dragCloneAfter (self,p,after):

    c = self ; u = c.undoer ; undoType = 'Clone Drag'
    current = c.currentPosition()

    c.beginUpdate()
    if 1: # In update...
        clone = p.clone(p) # Creates clone.  Does not set undo.
        # g.trace("p,after:",p.headString(),after.headString())
        if not c.checkMoveWithParentWithWarning(clone,after.parent(),True):
            # g.trace("invalid clone drag")
            clone.doDelete(p) # Destroys clone & dependents. Makes p the current node.
            c.endUpdate(False) # Nothing has changed.
            return
        inAtIgnoreRange = clone.inAtIgnoreRange()
        c.endEditing()
        undoData = u.beforeInsertNode(current)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        clone.moveAfter(after)
        if inAtIgnoreRange and not clone.inAtIgnoreRange():
            # The moved node have just become newly unignored.
            dirtyVnodeList2 = clone.setDirty() # Mark descendent @thin nodes dirty.
            dirtyVnodeList.extend(dirtyVnodeList2)
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = clone.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterInsertNode(clone,undoType,undoData,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(clone)
    c.endUpdate()
    c.updateSyntaxColorer(clone) # Dragging can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.2948:c.dragCloneAfter
#@-node:ekr.20031218072017.2945:Dragging (commands)
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self):

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    
    c.fileCommands.readAtFileNodes()
    
    u.afterChangeTree(p,'Read @file Nodes',undoData)
#@nonl
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@-node:ekr.20050408072730:From Commands...
#@+node:ekr.20050408072730.2:From Find
#@+node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
def changeAll(self):

    c = self.c ; u = c.undoer ; undoType = 'Change All'
    current = c.currentPosition()
    st = self.s_ctrl ; gui = g.app.gui
    if not self.checkArgs(): return
    self.initInHeadline()
    saveData = self.save()
    self.initBatchCommands()
    count = 0
    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,undoType)
        while 1:
            pos1, pos2 = self.findNextMatch()
            if not pos1: break
            count += 1
            self.batchChange(pos1,pos2)
            line = gui.getLineContainingIndex(st,pos1)
            self.printLine(line,allFlag=True)
        p = c.currentPosition()
        u.afterChangeGroup(p,undoType,reportFlag=True)
        g.es("changed: %d instances" % (count))
        self.restore(saveData)
    c.endUpdate()
#@-node:ekr.20031218072017.3069:changeAll (sets end of change-all group)
#@+node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
@ This routine performs a single batch change operation, updating the head or body string of p and leaving the result in s_ctrl.  We update the body if we are changing the body text of c.currentVnode().

s_ctrl contains the found text on entry and contains the changed text on exit.  pos and pos2 indicate the selection.  The selection will never be empty. NB: we can not assume that self.p is visible.
@c

def batchChange (self,pos1,pos2):

    c = self.c ; u = c.undoer
    p = self.p ; st = self.s_ctrl ; gui = g.app.gui
    # Replace the selection with self.change_text
    if gui.compareIndices(st,pos1, ">", pos2):
        pos1,pos2=pos2,pos1
    gui.replaceSelectionRangeWithText(st,pos1,pos2,self.change_text)
    s = gui.getAllText(st)
    # Update the selection.
    insert=g.choose(self.reverse,pos1,pos1+'+'+str(len(self.change_text))+'c')
    gui.setSelectionRange(st,insert,insert)
    gui.setInsertPoint(st,insert)
    # Update the node
    if self.in_headline:
        << change headline >>
    else:
        << change body >>
#@nonl
#@+node:ekr.20031218072017.2294:<< change headline >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.headString():
    
    undoData = u.beforeChangeNodeContents(p)

    p.initHeadString(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
    
    u.afterChangeNodeContents(p,'Change Headline',undoData)
#@nonl
#@-node:ekr.20031218072017.2294:<< change headline >>
#@+node:ekr.20031218072017.2295:<< change body >>
if len(s) > 0 and s[-1]=='\n': s = s[:-1]

if s != p.bodyString():
    
    undoData = u.beforeChangeNodeContents(p)

    p.setBodyStringOrPane(s)
    if self.mark_changes:
        p.setMarked()
    p.setDirty()
    if not c.isChanged():
        c.setChanged(True)
     
    u.afterChangeNodeContents(p,'Change Body',undoData)
#@nonl
#@-node:ekr.20031218072017.2295:<< change body >>
#@-node:ekr.20031218072017.2293:batchChange (sets start of change-all group)
#@-node:ekr.20050408072730.2:From Find
#@+node:ekr.20050408072730.1:From Import...
#@+node:ekr.20031218072017.3210:createOutline
def createOutline (self,fileName,parent):

    c = self.c ; u = c.undoer
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    << Read file into s >>
    # Create the top-level headline.
    undoData = u.beforeInsertNode(parent)
    p = parent.insertAsLastChild()
    if self.treeType == "@file":
        p.initHeadString("@file " + fileName)
    else:
        p.initHeadString(fileName)
    u.afterInsertNode(p,'Import',undoData)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        p.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,p)
    elif ext == ".el":
        self.scanElispText(s,p)
    elif ext in (".fs", ".fi"):
        self.scanForthText(s,p)
    elif ext == ".java":
        self.scanJavaText(s,p,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,p)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,p)
    elif ext == ".php":
        self.scanPHPText(s,p) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return p
#@nonl
#@+node:ekr.20031218072017.3211:<< Read file into s >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = g.toUnicode(s,self.encoding)
    theFile.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None
#@nonl
#@-node:ekr.20031218072017.3211:<< Read file into s >>
#@-node:ekr.20031218072017.3210:createOutline
#@+node:ekr.20031218072017.1810:importDerivedFiles
def importDerivedFiles (self,parent,paths):
    
    c = self.c ; u = c.undoer
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    command = 'Import'

    c.beginUpdate()
    if 1: # In update...
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            << set isThin if fileName is a thin derived file >>
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        u.afterChangeGroup(p,command)
    c.endUpdate()
#@nonl
#@+node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False
#@nonl
#@-node:ekr.20040930135204:<< set isThin if fileName is a thin derived file >>
#@-node:ekr.20031218072017.1810:importDerivedFiles
#@+node:ekr.20031218072017.3220:importFlattenedOutline
def importFlattenedOutline (self,files):

    c = self.c ; u = c.undoer ; current = c.currentPosition()
    if current == None: return
    if len(files) < 1: return

    self.setEncoding()
    fileName = files[0] # files contains at most one file.
    << Read the file into array >>

    # Convert the string to an outline and insert it after the current node.
    undoData = u.beforeInsertNode(current)
    p = self.convertMoreStringsToOutlineAfter(array,current)
    if p:
        c.endEditing()
        c.validateOutline()
        c.editPosition(p)
        p.setDirty()
        c.setChanged(True)
        u.afterInsertNode(p,'Import',undoData)
    else:
        g.es(fileName + " is not a valid MORE file.")
#@nonl
#@+node:ekr.20031218072017.3221:<< Read the file into array >>
try:
    theFile = open(fileName)
    s = theFile.read()
    s = string.replace(s,"\r","")
    s = g.toUnicode(s,self.encoding)
    array = string.split(s,"\n")
    theFile.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return
#@-node:ekr.20031218072017.3221:<< Read the file into array >>
#@-node:ekr.20031218072017.3220:importFlattenedOutline
#@+node:ekr.20031218072017.3225:createOutlineFromWeb
def createOutlineFromWeb (self,path,parent):

    c = self.c ; u = c.undoer
    junk,fileName = g.os_path_split(path)

    undoData = u.beforeInsertNode(parent)
    
    # Create the top-level headline.
    p = parent.insertAsLastChild()
    p.initHeadString(fileName)
    if self.webType=="cweb":
        p.setBodyStringOrPane("@ignore\n" + self.rootLine + "@language cweb")

    # Scan the file, creating one section for each function definition.
    self.scanWebFile(path,p)

    u.afterInsertNode(p,'Import',undoData)

    return p
#@nonl
#@-node:ekr.20031218072017.3225:createOutlineFromWeb
#@-node:ekr.20050408072730.1:From Import...
#@+node:ekr.20050408072730.3:From tkTree
#@+node:ekr.20040803072955.91:idle_head_key
def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; u = c.undoer

    if not p or not p.isCurrentPosition():
        return "break"

    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    << set head to vnode text >>
    done = ch in ('\r','\n')
    if done:
        << set the widget text to head >>
    << set s to the widget text >>
    changed = s != head
    if changed:
        undoData = u.beforeChangeNodeContents(p)
        << update p >>
        u.afterChangeNodeContents(p,'Change Headline',undoData,dirtyVnodeList=dirtyVnodeList)
    if done or changed:
        << reconfigure p and all nodes joined to p >>
        << update the screen >>

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"
#@nonl
#@+node:ekr.20040803072955.92:<< set head to vnode text >>
head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")
#@nonl
#@-node:ekr.20040803072955.92:<< set head to vnode text >>
#@+node:ekr.20040803072955.93:<< set the widget text to head >>
self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)
#@nonl
#@-node:ekr.20040803072955.93:<< set the widget text to head >>
#@+node:ekr.20040803072955.94:<< set s to the widget text >>
s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i > -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) > limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')
#@nonl
#@-node:ekr.20040803072955.94:<< set s to the widget text >>
#@+node:ekr.20040803072955.95:<< update p >>
c.beginUpdate()
if 1: # In update...

    # Update changed bit.
    if not c.changed:
        c.setChanged(True)

    # We must call p.setDirty even if p is dirty!
    dirtyVnodeList = p.setDirty()

    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)

c.endUpdate(False) # do not redraw now.
#@nonl
#@-node:ekr.20040803072955.95:<< update p >>
#@+node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
# Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))
#@nonl
#@-node:ekr.20040803072955.96:<< reconfigure p and all nodes joined to p >>
#@+node:ekr.20040803072955.97:<< update the screen >>
if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.
#@nonl
#@-node:ekr.20040803072955.97:<< update the screen >>
#@-node:ekr.20040803072955.91:idle_head_key
#@-node:ekr.20050408072730.3:From tkTree
#@-node:ekr.20050408055511:Calls to undoer methods
#@-node:ekr.20050408110906:(Finished new undo)
#@+node:ekr.20050128081550:(Implemented undo/redo for Paste Retaining clones)
#@+node:ekr.20050418103514.1:Notes
#@+node:ekr.20050207062841:Report
@killcolor

By: Graham Horler - grahamh
 paste retaining clones bug: old data zaps new   
2005-01-27 12:31  
Leo 4.3 alpha 1, build 1.208 , January 24, 2005 
Python 2.3.4, Tk 8.4.7-1, Debian GNU/Linux 3.0 
 
(Please excuse my leo-newbieness) 
 
Is this a bug?: 
 
Create a new headline "Head1", insert some body text. 
Click Outline/Copy Node. 
Type some more body text in "Head1" and change its name to "Head1a". 
Create another headline "Head2". 
Click Outline/Paste Retaining Clones. 
Your changes to "Head1" are destroyed (bug 1). 
Undo does NOT undo the destruction (bug 2) 
 
Hope this helps, Graham
 
#@-node:ekr.20050207062841:Report
#@+node:ekr.20050207062841.1:Responses
@killcolor

> Edward wants to empty the undo stack. So all should still behave as expected if you do copy / paste retaining clones without making changes in between, except that you might loose undo and get pestered with warnings.  
 
You have just convinced me that clearing the undo stack and issuing a warning is not good.
 
Besides, it should be possible to undo Paste As Clone. The paste code "just" needs to create a list of changed nodes. This list must be created while pasting; it can not be created after the fact. 
 
I put quotes around the word 'just' above because the paste code is, in fact, quite complex. The difficult part is in leoFileCommands.getVnode, and I suspect that this is the part that must remember changed data.

4/18/05:  The code actually remembers _all_ body and headline text in the entire outline.  It probably should also remember marks, but it doesn't...
#@nonl
#@-node:ekr.20050207062841.1:Responses
#@-node:ekr.20050418103514.1:Notes
#@+node:ekr.20050418083241.1:fc.read logic
#@+node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
# This method reads a Leo outline from string s in clipboard format.
def getLeoOutline (self,s,reassignIndices=True):

    self.usingClipboard = True
    self.fileBuffer = s ; self.fileIndex = 0
    self.tnodesDict = {}
    self.descendentUnknownAttributesDictList = []

    if not reassignIndices:
        << recreate tnodesDict >>

    try:
        self.getXmlVersionTag() # leo.py 3.0
        self.getXmlStylesheetTag() # 10/25/02
        self.getTag("<leo_file>") # <leo_file/> is not valid.
        self.getClipboardHeader()
        self.getVnodes(reassignIndices)
        self.getTnodes()
        self.getTag("</leo_file>")
        v = self.finishPaste(reassignIndices)
    except invalidPaste:
        v = None
        g.es("Invalid Paste As Clone",color="blue")
    except BadLeoFile:
        v = None
        g.es("The clipboard is not valid ",color="blue")

    # Clean up.
    self.fileBuffer = None ; self.fileIndex = 0
    self.usingClipboard = False
    self.tnodesDict = {}
    return v
#@nonl
#@+node:EKR.20040610134756:<< recreate tnodesDict >>
nodeIndices = g.app.nodeIndices

self.tnodesDict = {}

for t in self.c.all_unique_tnodes_iter():
    tref = t.fileIndex
    if nodeIndices.isGnx(tref):
        tref = nodeIndices.toString(tref)
    self.tnodesDict[tref] = t
    
if 0:
    print '-'*40
    for key in self.tnodesDict.keys():
        print key,self.tnodesDict[key]
#@nonl
#@-node:EKR.20040610134756:<< recreate tnodesDict >>
#@-node:ekr.20031218072017.1559:getLeoOutline (from clipboard)
#@+node:ekr.20031218072017.1561:getTnode
def getTnode (self):

    # we have already matched <t.
    index = -1 ; attrDict = {}
    # New in version 1.7: attributes may appear in any order.
    while 1:	
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag(">"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("tnode")
            if attr: attrDict[attr] = val
            
    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    << handle unknown attributes >>
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("</t>")
#@nonl
#@+node:ekr.20031218072017.1564:<< handle unknown attributes >>
keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        print s ; g.es(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1564:<< handle unknown attributes >>
#@-node:ekr.20031218072017.1561:getTnode
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched <v.
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:ekr.20040326063413:getExistingVnode
def getExistingVnode (self,tref,headline):

    assert(tref > -1)
    tref = self.canonicalTnodeIndex(tref)
    t = self.tnodesDict.get(tref)
    try:
        return t.vnodeList[0]
    except (IndexError,AttributeError):
        g.es("Missing vnode:",headline,color="red")
        g.es("Probably an outline topology error.")
        return None
#@nonl
#@-node:ekr.20040326063413:getExistingVnode
#@+node:ekr.20031218072017.1860:createVnode (changed for 4.2) sets skip
def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(c,t)
        v.moveToRoot()

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        print s ; g.es(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode (changed for 4.2) sets skip
#@-node:ekr.20050418083241.1:fc.read logic
#@+node:ekr.20050418083241.2:fc.write logic
#@+node:ekr.20031218072017.1573:putLeoOutline (to clipboard)
# Writes a Leo outline to s in a format suitable for pasting to the clipboard.

def putLeoOutline (self):

    self.outputFile = g.fileLikeObject()
    self.usingClipboard = True
    self.assignFileIndices() # 6/11/03: Must do this for 3.x code.
    self.putProlog()
    self.putClipboardHeader()
    self.putVnodes()
    self.putTnodes()
    self.putPostlog()
    s = self.outputFile.getvalue()
    self.outputFile = None
    self.usingClipboard = False
    return s
#@nonl
#@-node:ekr.20031218072017.1573:putLeoOutline (to clipboard)
#@+node:ekr.20031218072017.1577:putTnode
def putTnode (self,t):

    self.put("<t")
    self.put(" tx=")

    gnx = g.app.nodeIndices.toString(t.fileIndex)
    self.put_in_dquotes(gnx)

    if hasattr(t,"unknownAttributes"):
        self.putUnknownAttributes(t)

    self.put(">")

    # g.trace(t)
    if t.bodyString:
        self.putEscapedString(t.bodyString)

    self.put("</t>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1577:putTnode
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    # Must check all parents.
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>
    
    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20050418083241.2:fc.write logic
#@+node:ekr.20050418070354:From undo
#@+node:ekr.20050411193627.4:beforeInsertNode
def beforeInsertNode (self,p,pasteAsClone=False,copiedBunchList=[]):
    
    u = self

    bunch = u.createCommonBunch(p)
    bunch.pasteAsClone = pasteAsClone
    
    if pasteAsClone:
        # Save the list of bunches created by fc.createVnode.
        bunch.beforeTree = copiedBunchList
        # g.trace(bunch.beforeTree)

    return bunch
#@nonl
#@-node:ekr.20050411193627.4:beforeInsertNode
#@+node:ekr.20050411193627.9:afterInsertNode
def afterInsertNode (self,p,command,bunch,dirtyVnodeList=[]):
    
    u = self ; c = u.c
    if u.redoing or u.undoing: return
    
    # Set types & helpers
    bunch.kind = 'insert'
    bunch.undoType = command
    
    # Set helpers
    bunch.undoHelper = u.undoInsertNode
    bunch.redoHelper = u.redoInsertNode
    
    bunch.newP = p.copy()
    bunch.dirtyVnodeList = dirtyVnodeList

    bunch.newCurrent = c.currentPosition()
    bunch.newBack = p.back()
    bunch.newParent = p.parent()

    bunch.newChanged = c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()
    
    if bunch.pasteAsClone:
        beforeTree=bunch.beforeTree
        afterTree = []
        for bunch2 in beforeTree:
            t = bunch2.t
            afterTree.append(
                g.Bunch(t=t,head=t.headString[:],body=t.bodyString[:]))
        bunch.afterTree=afterTree
        # g.trace(afterTree)

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]
    
    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050411193627.9:afterInsertNode
#@+node:ekr.20050412085112:undoInsertNode
def undoInsertNode (self):
    
    u = self ; c = u.c

    c.selectPosition(u.newP)
    c.deleteOutline()
    
    if u.pasteAsClone:
        for bunch in u.beforeTree:
            t = bunch.t
            if u.p.v.t == t:
                u.p.setBodyStringOrPane(bunch.body)
                u.p.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050412085112:undoInsertNode
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):
    
    u = self ; c = u.c

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412084532:redoInsertNode
#@-node:ekr.20050418070354:From undo
#@+node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.1549:cutOutline
def cutOutline(self):

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
#@nonl
#@-node:ekr.20031218072017.1549:cutOutline
#@+node:ekr.20031218072017.1550:copyOutline
def copyOutline(self):

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
#@nonl
#@-node:ekr.20031218072017.1550:copyOutline
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return
    
    copiedBunchList = []
    if pasteAsClone:
        << put only needed info in copiedBunchList >>
    
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.beginUpdate()
    c.endEditing()
    if 1: # inside update...
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    c.endUpdate()
    c.recolor()
#@nonl
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
#@nonl
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@nonl
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self):
    
    c = self

    return c.pasteOutline(reassignIndices=False)
#@nonl
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@-node:ekr.20031218072017.1548:Cut & Paste Outlines
#@-node:ekr.20050128081550:(Implemented undo/redo for Paste Retaining clones)
#@+node:ekr.20041231102453:(Added support for 'str_' uA's
#@+node:ekr.20050407090040:Posting
@killcolor

I have been going round and round with ideas for improving uA's.  The more I think about this issue, the more I am inclined to make absolutely the minimal changes possible.

My first thought was to define new xml elements that could be embedded in <v> and <t> elements.  This would be the natural way to extend Leo's file format from an xml purist's point of view.  However,   I absolutely want to avoid trying to define a set of xml elements that will magically be perfect for all plugins.  This way madness lies: I couldn't bear to entertain endless proposals for further 'improvements'.

Moreover, I'm not sure a new set of elements embedded in <v> and <t> elements actually addresses the present requests.  There are two such requests:

1. The first was originally from Martin Clifford.  The request was not to pickle and hexlify plain strings.  (BTW, Martin has already worked around the problem on his own.)  This request makes sense: we would like allow myAttrib="myAttribute" to remain readable in the xml file if "myAttribute" is a plain string.

2. The second was from BH, aka Leo User.  The request was to allow base64 values as the value of attributes.  Like this:  myAttrib="base64value".

What if we don't change Leo's file format at all?  What if we just change how Leo encodes and decodes items in t.unknownAttributes and v.unknownAttributes?

Absent new information from the file format, the only way to tell Leo how to write attributes is to use naming conventions.  The idea is that when writing attributes, Leo will do the following:

- Do nothing except apply xml escapes if the attribute name (in t.unknownAttributes or v.unknownAttributes) starts with str_ and the attribute is, in fact, a string.  If the string is a Unicode string Leo must convert the Unicode string to an encoded string.

- Try to convert the value to base64 if the attribute names starts with base64_.  Fall back to the present pickling/hexlifying scheming if converting to base64 fails.

- Use the present pickling/hexlifying scheming otherwise.  In particular, issue a warning and ignore the attribute if the attribute can not be pickled.

Leo will do the reverse when reading.

BTW, plugins could add their own naming conventions in an emergency.  Indeed, the conventions will be confined to code in atFile.putUa and atFile.getUa, so a plugin would only need to override these two methods.
#@nonl
#@-node:ekr.20050407090040:Posting
#@+node:ekr.20050304124404.4:From leoTkinterTree...
#@+node:ekr.20040317184631:Design for drawUserIcons (use dict instead of tuples) (finished)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=2477913
By: edream

A better design for user icons

Using tuples in t.unknownAttributes["icons"] is too constricted.  Much better
to have t.unknownAttributes["icons"] be a list of g.Bunches rather
than a list of tuples.  Each of these bunches could have the
following keys:

"type"

"file", "icon" or "url".  At present my prototype code uses "file" to specify
the location of an icon.

"where":

"beforeBox", "beforeIcon", "beforeHeadLine", "afterHeadline".  This specifies
where to put the icon.  The default would be "beforeHeadline".  "beforeBox"
means before the plus/minus box.  "beforeIcon" means before the standard icon.

"height":

the height of the icon to use when calculating the line height.  Default: get
from the icon itself, if possible.

"width":

the width of the icon to use when calculating where to put the following element.
Default: get from the icon, if possible.

"xoffset"

Leo draws the icon at x + xoffset, where x is determined by the where param
above.  Default 0.

"xpad"

The amount of extra space following the icon.  Default 0.

"yoffset"

Leo draws the icon at y + yoffset.  Default 0.

"ypad"

The amount of extra vertical space to add to the line height.  Default 0.

These offset and pad values are integer pixel values and may be positive or
negative.

"lineHeight"  NOT USED.

Overrides any calculated line height.  Default:  lineHeight = yoffset + height + ypad.

"onClick", "onRightClick", "onDoubleClick"

commands to call when the specified event happens.  By default, the "onRightClick"
icon will be bound to a popup menu that offers the user a chance to delete the
icon,  and maybe other options such as "nudging" the icon up or down, left or
right.

"popUpMenu"

a list of items to put in a popup menu.  This would be a convenience to avoid
having to use "onRightClick".

I think you get the idea.  We want the drawing code to support lots of common
things that plugins would like to do.  I'll probably think of other goodies,
but this already is a big step forward.  Note that each of these keys will have
a default, so plugins only need to specify keys that have non-default values.

Edward

P.S.  Other gui's might not be able to support all these options.  That's ok.
The drawing code in gui plugins should degrade gracefully.

EKR
#@nonl
#@-node:ekr.20040317184631:Design for drawUserIcons (use dict instead of tuples) (finished)
#@+node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0
#@nonl
#@+node:ekr.20040803072955.43:force_draw_node
def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent
#@nonl
#@-node:ekr.20040803072955.43:force_draw_node
#@-node:ekr.20040803072955.42:drawNode & force_draw_node (good trace)
#@+node:ekr.20040803072955.46:drawUserIcons
def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w
#@nonl
#@-node:ekr.20040803072955.46:drawUserIcons
#@+node:ekr.20040803072955.47:drawUserIcon
def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    << set offsets and pads >>
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            << draw the icon in string s >>
    elif theType == "file":
        theFile = theDict.get("file")
        << draw the icon at file >>
    elif theType == "url":
        ## url = theDict.get("url")
        << draw the icon at url >>
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w
#@nonl
#@+node:ekr.20040803072955.48:<< set offsets and pads >>
xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0
#@nonl
#@-node:ekr.20040803072955.48:<< set offsets and pads >>
#@+node:ekr.20040803072955.49:<< draw the icon in string s >>
pass
#@nonl
#@-node:ekr.20040803072955.49:<< draw the icon in string s >>
#@+node:ekr.20040803072955.50:<< draw the icon at file >>
try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

#@-node:ekr.20040803072955.50:<< draw the icon at file >>
#@+node:ekr.20040803072955.51:<< draw the icon at url >>
pass
#@nonl
#@-node:ekr.20040803072955.51:<< draw the icon at url >>
#@-node:ekr.20040803072955.47:drawUserIcon
#@-node:ekr.20050304124404.4:From leoTkinterTree...
#@+node:ekr.20050306090634:From docs...
#@+node:ekr.20050306090634.1:Adding attributes to nodes and .leo files
@nocolor
#@nonl
#@+node:ekr.20050306090634.2:Extending the format of .leo files
New in 4.0: Leo can now read and write "foreign" attributes in <v> and <t> elements in .leo files:

- When reading a .leo file, Leo will create t.unknownAttributes or v.unknownAttributes ivars for any tnode and vnode object whose corresponding <v> or <t> element in the .leo file contains a foreign attribute.

- The unknownAttributes ivars are a dictionary whose keys are the attribute names and whose values are strings.

- When writing a file, Leo will write "foreign" attributes if  a vnode or tnode contains an unknownAttributes ivar.

- The only "native" attributes that Leo expects to find are the "tx" attribute in <t> elements and the "a", "t", "vtag" and "tnodeList" attributes of <v> elements.  Everything else is a foreign attribute.

New in 4.2: The "marks", "expanded" and "descendentTnodeUnknownAttributes" attributes are "native" attribute of <v> elements.

- Leo performs the usual xml escapes on these strings when reading or writing the unknownAttributes ivars.

Plugins may cause Leo to write such foreign attributes simply by attaching unknownAttributes ivars to a vnode or tnode.  For example:

	v.unknownAttributes = {"vnodeIcon" : pathToIcon}

It would be best not to delete other foreign attributes, so the following would be preferred:

	if hasattr(v,"unknownAttributes"):
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	else:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

Another way:

	try:
		v.unknownAttributes["vnodeIcon"] = pathToIcon
	except AttributeError:
		v.unknownAttributes = {"vnodeIcon" : pathToIcon}

See the section called "Recommended conventions for plugins" for advice about how to avoid potential conflicts in naming new attributes.

New in 4.2:

All members of these dictionaries should be "pickleable".  That is, Leo uses Python's Pickle module to encode all values in these dictionaries.  Leo will discard any attributes that can not be pickled.  This should not be a major problem to plugins.  For example, instead of putting a tnode into these dictionaries, a plugin could put the tnode's gnx (a string) in the dictionary.

Leo writes only t.unknownAttributes when writing @thin trees to the .leo file.  Leo puts (the encoding of) these elements into an attribute called descendentTnodeUnknownAttributes.  This attribute is part of the <v> element representing the @thin node.

The reason Leo does _not_ write v.unknownAttributes in @thin trees is that only tnodes have gnx's in thin derived files.  In effect, vnodes are anonymous.  We could attempt to get around this by identifying vnodes by their corresponding tnodes, but that's not a general solution and it is, in effect, equivalent to writing only t.unknownAttributes.  So it seems pointless to "pretend" to be writing v.unknownAttributes.

The effect of this is to make all vnodes identical, as far as using unknownAttributes is concerned.  This won't work in all cases.  For example, a plugin that creates an arbitrary directed graph between vnodes must distinguish between joined vnodes.  In that case, the plugin should confine itself to @file trees, or just vnodes in .leo files, for that matter.
#@nonl
#@-node:ekr.20050306090634.2:Extending the format of .leo files
#@+node:ekr.20050306090634.3:Attaching temporary attributes to vnodes and tnodes
Plugins may create (or add to) v.tempAttributes (for vnodes) or t.tempAttributes (for tnodes).  These will work just like the corresponding unknownAttributes dicts except that Leo will _not_ read or write these dictionaries when reading or writing files.  Note: nothing needs to change in Leo to support this convention.
#@nonl
#@-node:ekr.20050306090634.3:Attaching temporary attributes to vnodes and tnodes
#@+node:ekr.20050306090634.4:Recommended conventions for plugins
@nocolor

We wish to avoid the possibility that two plugins might unwittingly choose the same name for attributes in the unknownAttributes or tempAttributes dictionaries.  The following convention eliminates that possibility.

Each plugin should create its own dictionary _inside_ any tempAttributes or unknownAttributes dictionaries that it intends to create or modify.  Something like this:

@color

# Create the tempAttributes dict for this vnode.
if not v.hasattr("tempAttributes"):
	v.tempAttributes = {}

# Create a subdictionary for the private use of my plugin.
d = v.tempAttributes.get("myPluginName")
if d is None:
	v.tempAttributes["myPluginName"] = d = {}

@nocolor

Now the plugin can set and get fields in d.  Similar code would be used for the t.tempAttributes, v.unknownAttributes and t.unknownAttributes dictionaries.
#@nonl
#@-node:ekr.20050306090634.4:Recommended conventions for plugins
#@-node:ekr.20050306090634.1:Adding attributes to nodes and .leo files
#@-node:ekr.20050306090634:From docs...
#@+node:ekr.20050304124404:From leoFileCommands...
#@+node:ekr.20050304124404.1:read...
#@+node:ekr.20040701065235.1:getDescendentAttributes
def getDescendentAttributes (self,s,tag=""):
    
    '''s is a list of gnx's, separated by commas from a <v> or <t> element.
    Parses s into a list.
    
    This is used to record marked and expanded nodes.
    '''
    
    __pychecker__ = '--no-argsused' # tag used only for debugging.

    gnxs = s.split(',')
    result = [gnx for gnx in gnxs if len(gnx) > 0]
    # g.trace(tag,result)
    return result
#@-node:ekr.20040701065235.1:getDescendentAttributes
#@+node:EKR.20040627114602:getDescendentUnknownAttributes
# Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        return None
#@nonl
#@-node:EKR.20040627114602:getDescendentUnknownAttributes
#@+node:ekr.20031218072017.1860:createVnode (changed for 4.2) sets skip
def createVnode (self,parent,back,tref,headline,attrDict):
    
    # g.trace(parent,headline)
    v = None ; c = self.c
    # Shared tnodes are placed in the file even if empty.
    if tref == -1:
        t = leoNodes.tnode()
    else:
        tref = self.canonicalTnodeIndex(tref)
        t = self.tnodesDict.get(tref)
        if not t:
            t = self.newTnode(tref)
    if back: # create v after back.
        v = back.insertAfter(t)
    elif parent: # create v as the parent's first child.
        v = parent.insertAsNthChild(0,t)
    else: # create a root vnode
        v = leoNodes.vnode(c,t)
        v.moveToRoot()

    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v) # New in 4.2.

    skip = len(v.t.vnodeList) > 1
    v.initHeadString(headline,encoding=self.leo_file_encoding)
    << handle unknown vnode attributes >>
    # g.trace(skip,tref,v,v.t,len(v.t.vnodeList))
    return v,skip
#@nonl
#@+node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
keys = attrDict.keys()
if keys:
    v.unknownAttributes = attrDict

    if 0: # For debugging.
        s = "unknown attributes for " + v.headString()
        print s ; g.es(s,color="blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1861:<< handle unknown vnode attributes >>
#@-node:ekr.20031218072017.1860:createVnode (changed for 4.2) sets skip
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        if not silent:
            << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.1561:getTnode
def getTnode (self):

    # we have already matched <t.
    index = -1 ; attrDict = {}
    # New in version 1.7: attributes may appear in any order.
    while 1:	
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag(">"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("tnode")
            if attr: attrDict[attr] = val
            
    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    << handle unknown attributes >>
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("</t>")
#@nonl
#@+node:ekr.20031218072017.1564:<< handle unknown attributes >>
keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        print s ; g.es(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            print s ; g.es(s)
#@nonl
#@-node:ekr.20031218072017.1564:<< handle unknown attributes >>
#@-node:ekr.20031218072017.1561:getTnode
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched <v.
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2)
#@+node:EKR.20040526204036.1:getUa (changed for 4.3)
def getUa(self,nodeType):
    
    """Parse an unknown attribute in a <v> or <t> element."""
    
    __pychecker__ = '--no-argsused' # nodeType not used: good for debugging.
    
    # New in 4.2.  The unknown tag has been pickled and hexlify'd.
    attr,val = self.getUnknownTag()
    if not attr:
        return None,None
        
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if attr.startswith('str_') and type(val) == type(''):
        # g.trace(attr,val)
        return attr,val
        
    # New in 4.3: convert attributes starting with 'b64_' using the base64 conversion.
    if 0: # Not ready yet.
        if attr.startswith('b64_'):
            try: pass
            except Exception: pass
        
    try:
        binString = binascii.unhexlify(val) # Throws a TypeError if val is not a hex string.
    except TypeError:
        # Assume that Leo 4.1 wrote the attribute.
        # g.trace('4.1 val:',val2)
        return attr,val
    try:
        # No change needed to support protocols.
        val2 = pickle.loads(binString)
        # g.trace('v.3 val:',val2)
        return attr,val2
    except (pickle.UnpicklingError,ImportError):
        return attr,val
#@nonl
#@-node:EKR.20040526204036.1:getUa (changed for 4.3)
#@-node:ekr.20050304124404.1:read...
#@+node:ekr.20050304124404.2:write...
#@+node:EKR.20040627113418:putDescendentUnknownAttributes
def putDescendentUnknownAttributes (self,p):

    # Create a list of all tnodes having a valid unknownAttributes dict.
    tnodes = []
    for p2 in p.subtree_iter():
        t = p2.v.t
        if hasattr(t,"unknownAttributes"):
            if t not in tnodes :
                tnodes.append((p,t),)
    
    # Create a list of pairs (t,d) where d contains only pickleable entries.
    data = []
    for p,t in tnodes:
        if type(t.unknownAttributes) != type({}):
             g.es("ignoring non-dictionary unknownAttributes for",p,color="blue")
        else:
            # Create a new dict containing only entries that can be pickled.
            d = dict(t.unknownAttributes) # Copy the dict.
            for key in d.keys():
                try: pickle.dumps(d[key],bin=True)
                except pickle.PicklingError:
                    del d[key]
                    g.es("ignoring bad unknownAttributes key %s in %s" % (
                        key,p),color="blue")
            data.append((t,d),)
            
    # Create resultDict, an enclosing dict to hold all the data.
    resultDict = {}
    nodeIndices = g.app.nodeIndices
    for t,d in data:
        gnx = nodeIndices.toString(t.fileIndex)
        resultDict[gnx]=d
    
    if 0:
        print "resultDict"
        for key in resultDict:
            print ; print key,resultDict[key]
        
    # Pickle and hexlify resultDict.
    if resultDict:
        try:
            tag = "descendentTnodeUnknownAttributes"
            s = pickle.dumps(resultDict,bin=True)
            field = ' %s="%s"' % (tag,binascii.hexlify(s))
            self.put(field)
        except pickle.PicklingError:
            g.trace("can't happen",color="red")
#@nonl
#@-node:EKR.20040627113418:putDescendentUnknownAttributes
#@+node:ekr.20031218072017.1577:putTnode
def putTnode (self,t):

    self.put("<t")
    self.put(" tx=")

    gnx = g.app.nodeIndices.toString(t.fileIndex)
    self.put_in_dquotes(gnx)

    if hasattr(t,"unknownAttributes"):
        self.putUnknownAttributes(t)

    self.put(">")

    # g.trace(t)
    if t.bodyString:
        self.putEscapedString(t.bodyString)

    self.put("</t>") ; self.put_nl()
#@nonl
#@-node:ekr.20031218072017.1577:putTnode
#@+node:EKR.20040526202501:putUnknownAttributes
def putUnknownAttributes (self,torv):
    
    """Put pickleable values for all keys in torv.unknownAttributes dictionary."""
    
    attrDict = torv.unknownAttributes
    if type(attrDict) != type({}):
        g.es("ignoring non-dictionary unknownAttributes for",torv,color="blue")
        return

    for key in attrDict.keys():
        val = attrDict[key]
        self.putUa(torv,key,val)
#@nonl
#@-node:EKR.20040526202501:putUnknownAttributes
#@+node:ekr.20050418161620.2:putUa (new in 4.3) (changed for 4.3)
def putUa (self,torv,key,val):
    
    '''Put attribute whose name is key and value is val to the output stream.'''
    
    # New in 4.3: leave string attributes starting with 'str_' alone.
    if key.startswith('str_'):
        if type(val) == type(''):
            attr = ' %s="%s"' % (key,self.xmlEscape(val))
            self.put(attr)
        else:
            g.es("ignoring non-string attribute %s in %s" % (
                key,torv),color="blue")
        return
    try:
        try:
            # Protocol argument is new in Python 2.3
            # Use protocol 1 for compatibility with bin.
            s = pickle.dumps(val,protocol=1)
        except TypeError:
            s = pickle.dumps(val,bin=True)
        attr = ' %s="%s"' % (key,binascii.hexlify(s))
        self.put(attr)

    except pickle.PicklingError:
        # New in 4.2 beta 1: keep going after error.
        g.es("ignoring non-pickleable attribute %s in %s" % (
            key,torv),color="blue")
#@nonl
#@-node:ekr.20050418161620.2:putUa (new in 4.3) (changed for 4.3)
#@+node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
def putVnode (self,p):

    """Write a <v> element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    # Must check all parents.
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("<v")
    << Put tnode index >>
    << Put attribute bits >>
    << Put tnodeList and unKnownAttributes >>
    fc.put(">")
    << Write the head text >>
    
    if not self.usingClipboard:
        << issue informational messages >>

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("</v>") ; fc.put_nl()
#@nonl
#@+node:ekr.20031218072017.1864:<< Put tnode index >>
if v.t.fileIndex:
    gnx = g.app.nodeIndices.toString(v.t.fileIndex)
    fc.put(" t=") ; fc.put_in_dquotes(gnx)

    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")
#@nonl
#@-node:ekr.20031218072017.1864:<< Put tnode index >>
#@+node:ekr.20031218072017.1865:<< Put attribute bits >>
attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):   attr += "T" # was a bottleneck
    if c.isCurrentPosition(p):      attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)
#@nonl
#@-node:ekr.20031218072017.1865:<< Put attribute bits >>
#@+node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
# Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)
#@nonl
#@-node:ekr.20040324082713:<< Put tnodeList and unKnownAttributes >>
#@+node:ekr.20040702085529:<< issue informational messages >>
if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")
#@nonl
#@-node:ekr.20040702085529:<< issue informational messages >>
#@+node:ekr.20031218072017.1866:<< Write the head text >>
headString = p.v.headString()

if headString:
    fc.put("<vh>")
    fc.putEscapedString(headString)
    fc.put("</vh>")
#@nonl
#@-node:ekr.20031218072017.1866:<< Write the head text >>
#@-node:ekr.20031218072017.1863:putVnode (3.x and 4.x)
#@-node:ekr.20050304124404.2:write...
#@-node:ekr.20050304124404:From leoFileCommands...
#@-node:ekr.20041231102453:(Added support for 'str_' uA's
#@+node:ekr.20050422162615:Removed unused params from leoAtFile.py
@nocolor

Removed inAtOthers  param from putOpen/CloseNodeSentinel.
Removed inAtAll param from putCloseNodeSentinel.
Removed putCloseSentinel param from putAtAllBody
Removed putCloseSentinel param from putBody

Removed toString param from openFileForWritingHelper
Removed toString param from v.putUnknownAttributes

Note: most(all?) top-level atFile.write methods pass toString to initWriteIvars.
#@nonl
#@-node:ekr.20050422162615:Removed unused params from leoAtFile.py
#@+node:ekr.20050424161505.2:(Added u.before/afterClearRecentFiles
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer
    
    bunch = u.beforeClearRecentFiles()
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())
    
    g.app.config.appendToRecentFiles(c.recentFiles)
    
    u.afterClearRecentFiles(bunch)
#@nonl
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20050424170219:redoClearRecentFiles
def redoClearRecentFiles (self):
    
    u = self ; c = u.c

    g.app.recentFiles = u.newRecentFiles[:]
    c.recentFiles = u.newRecentFiles[:]
    
    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219:redoClearRecentFiles
#@+node:ekr.20050424170219.1:undoClearRecentFiles
def undoClearRecentFiles (self):
    
    u = self ; c = u.c
    
    g.app.recentFiles = u.oldRecentFiles[:]
    c.recentFiles = u.oldRecentFiles[:]

    c.frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20050424170219.1:undoClearRecentFiles
#@-node:ekr.20050424161505.2:(Added u.before/afterClearRecentFiles
#@+node:ekr.20050419073824:(Read and write .leoRecentFiles.txt)
#@+node:ekr.20050420061036:What I did
@killcolor

- Properly implemented undo/redo Clear Recent Files.

- readSettingsFiles now reads @recentfiles nodes from all settings files.

- Created @settings nodes and @recent-files nodes if they do not exist.
#@nonl
#@-node:ekr.20050420061036:What I did
#@+node:ekr.20050424111508:New plan
@killcolor

You all have convinced me that storing recent files data in .leo files is a dubious idea. My new plan is as follows:

1. Leo will store recent files info in files called .leoRecentFiles.txt.  These will be a plain text files with one line per recent files entry.  These will be local files, so problems concerning directory structure and path specifications should go away.

2.  On startup, Leo will search for the .leoRecentFiles.txt files in the user's home directory, if it exists.  Leo will look in Leo's config directory next, but only if the home directory does not exist, or does not contain a .leoRecentFiles.txt file.  In other words, Leo will use at most one .leoRecentFiles.txt file on startup.

3.  When opening a .leo file, Leo will look for .leoRecentFiles.txt in the directory containing the file.

4.  At no time after installation will Leo create any .leoRecentFiles.txt file.  This will allow users (or their managers) to set policy regarding where to store this information (if anywhere).

5.  Leo will write at most one .leoRecentFiles.txt file when saving a .leo file, namely the file read in item 3 if it exists, or the file read in item 2 otherwise.

6.  Leo will have settings to tell which .leoRecentFiles.txt files may be written.

7. Leo will never create @settings nodes or @recent-files nodes automatically.  Moreover, I shall remove the @recent-files panel from the settings dialog and the corresponding @recent-files code from the config classes.

I believe this will address everyone's concerns without the need for resolving thorny questions about exactly where recent files info belongs.

#@-node:ekr.20050424111508:New plan
#@+node:ekr.20031218072017.3046:write_Leo_file
def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c
    self.assignFileIndices()
    if not outlineOnlyFlag:
        # Update .leoRecentFiles.txt if possible.
        g.app.config.writeRecentFilesFile(c)
        << write all @file nodes >>
    << return if the .leo file is read-only >>
    try:
        theActualFile = None
        << create backup file >>
        self.mFileName = fileName
        self.outputFile = cStringIO.StringIO() # or g.fileLikeObject()
        theActualFile = open(fileName, 'wb')
        << put the .leo file >>
        theActualFile.write(self.outputFile.getvalue())
        theActualFile.close()
        self.outputFile = None
        << delete backup file >>
        return True
    except Exception:
        g.es("exception writing: " + fileName)
        g.es_exception(full=False)
        if theActualFile: theActualFile.close()
        self.outputFile = None
        << delete fileName >>
        << rename backupName to fileName >>
        return False

write_LEO_file = write_Leo_file # For compatibility with old plugins.
#@nonl
#@+node:ekr.20040324080359:<< write all @file nodes >>
try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except Exception:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False
#@nonl
#@-node:ekr.20040324080359:<< write all @file nodes >>
#@+node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
# self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.
#@nonl
#@-node:ekr.20040324080359.1:<< return if the .leo file is read-only >>
#@+node:ekr.20031218072017.3047:<< create backup file >>
# rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    backupName = g.os_path_join(g.app.loadDir,fileName)
    backupName = fileName + ".bak"
    if g.os_path_exists(backupName):
        g.utils_remove(backupName)
    ok = g.utils_rename(fileName,backupName)
    if not ok:
        if self.read_only:
            g.es("read only",color="red")
        return False
else:
    backupName = None
#@nonl
#@-node:ekr.20031218072017.3047:<< create backup file >>
#@+node:ekr.20040324080819.1:<< put the .leo file >>
self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()
#@nonl
#@-node:ekr.20040324080819.1:<< put the .leo file >>
#@+node:ekr.20050405103712:<< delete fileName >>
if fileName and g.os_path_exists(fileName):
    self.deleteFileWithMessage(fileName,'')
#@-node:ekr.20050405103712:<< delete fileName >>
#@+node:ekr.20050405103712.1:<< rename backupName to fileName >>
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    g.utils_rename(backupName,fileName)
#@nonl
#@-node:ekr.20050405103712.1:<< rename backupName to fileName >>
#@+node:ekr.20031218072017.3048:<< delete backup file >>
if backupName and g.os_path_exists(backupName):

    self.deleteFileWithMessage(backupName,'backup')
#@nonl
#@-node:ekr.20031218072017.3048:<< delete backup file >>
#@-node:ekr.20031218072017.3046:write_Leo_file
#@+node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041117085625:openSettingsFile
def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c
#@nonl
#@-node:ekr.20041117085625:openSettingsFile
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                s = 'reading settings in %s' % path
                print s ; g.es(s)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:config.readSettingsFiles
#@+node:ekr.20041117083857.1:readSettings
# Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d
#@nonl
#@-node:ekr.20041117083857.1:readSettings
#@-node:ekr.20041117093246:Scanning @settings (g.app.config)
#@+node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)
#@nonl
#@-node:ekr.20041118195812.3:setRecentFiles (c.configSettings)
#@+node:ekr.20041201080436:appendToRecentFiles (g.app.config)
def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)
#@nonl
#@-node:ekr.20041201080436:appendToRecentFiles (g.app.config)
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer
    
    bunch = u.beforeClearRecentFiles()
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())
    
    g.app.config.appendToRecentFiles(c.recentFiles)
    
    u.afterClearRecentFiles(bunch)
#@nonl
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'

    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    
    if not g.os_path_exists(fileName):
        # g.trace('----- no file',kind,fileName)
        return

    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return
            
    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        self.appendToRecentFiles(lines)
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    localFileName = c.fileName()
    if not localFileName:
        g.trace('----no file name')
        return
        
    # Create a list of bunches to control the comparison below.
    files = []
    for fileName,kind in (
        (localFileName,'local'),
        (self.homeFile,'home'),
        (self.globalConfigFile,'global'),
    ):
        if fileName:
            path,junk = g.os_path_split(fileName)
            files.append(g.Bunch(
                fileName=g.os_path_join(path,tag),kind=kind))

    # Search local file first, then home and global files.                
    for kind in ('local','home','global'):
        for bunch in files:
            for bunch2 in self.recentFilesFiles:
                if bunch.kind == bunch2.kind:
                    # g.trace('----- comparing',bunch.kind,bunch.fileName)
                    if bunch.fileName == bunch2.fileName:
                        self.writeRecentFilesFileHelper(bunch.fileName)
                        return
                    
    # g.trace('----- not found:',localFileName)
#@nonl
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        theFile = file(fileName,'w')
        if self.recentFiles:
            theFile.write('\n'.join(self.recentFiles))

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@nonl
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@-node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@-node:ekr.20050419073824:(Read and write .leoRecentFiles.txt)
#@+node:ekr.20050424174315:(Added support for read-only as the first line of .leoRecentFiles.txt)
#@+node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@+node:ekr.20050424115658:readRecentFilesFile
def readRecentFilesFile (self,path):
    
    # Set the kind of file for later.
    for path2,kind in (
        (self.globalConfigFile,'global'),
        (self.homeFile,'home'),
    ):
        if path2 and path2 == path: break
    else:
        kind = 'local'

    path,junk = g.os_path_split(path)
    fileName = g.os_path_join(path,'.leoRecentFiles.txt')
    
    if not g.os_path_exists(fileName):
        # g.trace('----- no file',kind,fileName)
        return

    for bunch in self.recentFilesFiles:
        if bunch.fileName == fileName:
            # g.trace('-----already read',kind,fileName)
            return
            
    # g.trace('-----',kind,fileName)
    self.recentFilesFiles.append(
        g.Bunch(fileName=fileName,kind=kind))

    lines = file(fileName).readlines()
    if lines and self.munge(lines[0])=='readonly':
        lines = lines[1:]
    if lines:
        self.appendToRecentFiles(lines)
#@nonl
#@-node:ekr.20050424115658:readRecentFilesFile
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    localFileName = c.fileName()
    if not localFileName:
        g.trace('----no file name')
        return
        
    # Create a list of bunches to control the comparison below.
    files = []
    for fileName,kind in (
        (localFileName,'local'),
        (self.homeFile,'home'),
        (self.globalConfigFile,'global'),
    ):
        if fileName:
            path,junk = g.os_path_split(fileName)
            files.append(g.Bunch(
                fileName=g.os_path_join(path,tag),kind=kind))

    # Search local file first, then home and global files.                
    for kind in ('local','home','global'):
        for bunch in files:
            for bunch2 in self.recentFilesFiles:
                if bunch.kind == bunch2.kind:
                    # g.trace('----- comparing',bunch.kind,bunch.fileName)
                    if bunch.fileName == bunch2.fileName:
                        self.writeRecentFilesFileHelper(bunch.fileName)
                        return
                    
    # g.trace('----- not found:',localFileName)
#@nonl
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        theFile = file(fileName,'w')
        if self.recentFiles:
            theFile.write('\n'.join(self.recentFiles))

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@nonl
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@-node:ekr.20050424114937.1:Reading and writing .leoRecentFiles.txt (g.app.config)
#@-node:ekr.20050424174315:(Added support for read-only as the first line of .leoRecentFiles.txt)
#@+node:ekr.20050420061320:(Copied expansion state when writing @settings trees)
# This means that Leo writes all config files whenever the user chooses OK.
#@nonl
#@+node:ekr.20041225063637.74:copyExpansionState
def copyExpansionState(self,p1,p2):
 
    # Don't depend on p.nodeAfterTree, etc.
    if p1.isExpanded():
        # g.trace("p1",p1)
        # g.trace("p2",p2)
        p2.expand()
        child1 = p1.firstChild()
        child2 = p2.firstChild()
        while child1:
            self.copyExpansionState(child1,child2)
            child1 = child1.next()
            child2 = child2.next()
#@nonl
#@-node:ekr.20041225063637.74:copyExpansionState
#@+node:ekr.20041225063637.21:createSettingsTree & helpers
def createSettingsTree (self):
    
    """Create a tree of vnodes representing all settings."""

    createEmptyRootNodes = False
    c = self.c ; config = g.app.config
    root_p = None ; last_p = None
    for kind,path,otherFileFlag in (
        ("Global",config.globalConfigFile,True),
        ("Home",config.homeFile,True),
        ("Local",c.fileName(),False),
    ):
        if path:
            if otherFileFlag: c2 = config.openSettingsFile(path)
            else: c2 = c
            root2 = g.app.config.settingsRoot(c2)
        else:
            root2 = None
        if root2 or createEmptyRootNodes:
            << create a node p for kind & root2 >>
    if self.createSummaryNode: root_p.expand()
    return root_p
#@nonl
#@+node:ekr.20041225063637.22:<< create a node p for  kind & root2 >>
if not root_p:
    t = leoNodes.tnode()
    root_v = leoNodes.vnode(c,t) # Using c2 --> oops: nullTree.
    root_p = leoNodes.position(root_v,[])
    if self.createSummaryNode:
        root_p.initHeadString("All settings")
        root_p.scriptSetBodyString(self.rootNodeComments())
        p = root_p.insertAsLastChild()
    else:
        p = root_p.copy()
    last_p = p.copy()
else:
    # Pychecker may complain, but last_p _is_ defined here!
    p = last_p.insertAfter()
    last_p = p.copy()

if root2:
    root2.copyTreeFromSelfTo(p)  # replace p by root2.

self.copyExpansionState(root2,p)
# g.trace(p.isExpanded(),p.headString())

<< add entry for p to filesInfoDict >>

path2 = g.choose(otherFileFlag,path,g.shortFileName(path))
p.initHeadString("%s settings: %s" % (kind,path2))
#@nonl
#@+node:ekr.20041225063637.23:<< add entry for p to filesInfoDict >>
self.filesInfoDict[p] = {
    'c': c2,
    'changes': [],
    'p': p.copy(),
    'path': path,
    'isLocal':  not otherFileFlag,
}
#@nonl
#@-node:ekr.20041225063637.23:<< add entry for p to filesInfoDict >>
#@-node:ekr.20041225063637.22:<< create a node p for  kind & root2 >>
#@+node:ekr.20041225063637.24:rootNodeComments
def rootNodeComments(self):
    
    c = self.c ; fileName = g.shortFileName(c.mFileName)
    
    s = """This tree shows Leo's global and home settings, as well as the local settings in %s."""\
        % (fileName)
    
    return s
#@nonl
#@-node:ekr.20041225063637.24:rootNodeComments
#@-node:ekr.20041225063637.21:createSettingsTree & helpers
#@+node:ekr.20041225063637.65:writeChangedVars & helpers
def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '<none>'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
                print s ; g.es(s,color='blue')
            else:
                s = "write  %10s -> %10s %s" % (str(oldVal),str(newVal),iname)
                print s ; g.es(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList,"write")
#@nonl
#@+node:ekr.20041225063637.66:updateConfig
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Put the values in the body.
                p.initHeadString("@%s %s" % (kind,name))
                body = '\n'.join(val)
                p.setBodyStringOrPane(body)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.69:writeChangedList
def writeChangedList (self,changedList,tag):
    
    __pychecker__ = '--no-argsused' # tag used for debugging.
    
    filesInfoDict = self.filesInfoDict
    if 0:
        << dump all the dicts in filesInfoDict >>

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -> %10s %s" % (tag,kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # Always write the file so as to preserve expansion state.
        self.writeChangesToFile(c,changes,path)
        self.updateConfig(c,changes)
        d['changes'] = []
#@nonl
#@+node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print
#@nonl
#@-node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
#@-node:ekr.20041225063637.69:writeChangedList
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.fileName())
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@-node:ekr.20041225063637.65:writeChangedVars & helpers
#@-node:ekr.20050420061320:(Copied expansion state when writing @settings trees)
#@+node:ekr.20050428103606:(Added support for UNL's in settings pane)
#@+node:ekr.20041225063637.83:tree.select
def select (self,p,updateBeadList=True):
    
    __pychecker__ = '--no-argsused' # updateBeadList required for compatibility.

    old_p = self.old_p
    
    # g.trace(p.headString())

    # Unselect the old
    if old_p:
        t = self.getTextWidget(old_p)
        if t: self.setUnselectColors(t)

    # Select the new
    t = self.getTextWidget(p)
    if t: self.setSelectColors(t)
    
    # N.B. Do not change the commander's notion of the present position.
    self.old_p = p

    self.controller.onTreeClick(p)
    
    # For the UNL plugin.
    g.doHook("select2",c=p.c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
#@nonl
#@-node:ekr.20041225063637.83:tree.select
#@+node:ekr.20040803072955.65:idle_scrollTo
def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p: p = self.c.currentPosition()
    if not p: p = self.c.rootPosition()
    if not p or not p.exists(c):
        g.trace('does not exist:',p.headString())
        return
    # g.trace(p.headString())
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:idle_scrollTo
#@+node:ekr.20041225063637.13: ctor (settingsController)
def __init__ (self,c,replaceBody=True):
    
    self.createSummaryNode = True # Works either way.

    << init ivars >>
    << define Tk color names>>

    if not Pmw:
        s = 'Setting dialog requires Pmw: see http://pmw.sourceforge.net'
        print s ; g.es(s,color='red')
        return
    
    # Reread the settings files so any changes will take effect.
    g.app.config.readSettingsFiles(c.fileName(),verbose=True)
    self._settingsPosition = p = self.createSettingsTree()
    self.parser = settingsDialogParserClass(c,p)
    << set background color for widgets >>
    c.disableCommandsMessage = 'All commands disabled while settings dialog is open'
    if self.replaceBody:
        self.replaceBodyWithDialog()
        self.log = g.app.log
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
    else:
        d = self.createStandAloneDialog()
        self.log = self.logClass(self.logText)
        self.tree.redraw_now() # To allocate widgets.
        self.tree.select(p)
        self.center()
        g.app.gui.widgetWantsFocus(None,None)
        if self.modal: d.activate()
#@nonl
#@+node:ekr.20050123194330:<< init ivars >>
self._settingsPosition = None
self.alterComments = None # position for which to alter comments.
self.alteredCommentsString = None
self.c = c
self.buttonNames = ('OK', 'Cancel','Apply','Revert')
self.colorSettingDict = {} # Contains entries for all changed colors.
self.commentWidget = None
self.commonBackground = None
self.dialog = None
self.initValueDict = {} # Initial value of settings in present pane.
self.fileValueDict = {} # Values of settings written to file.
self.filesInfoDict = {} # Info about all settings file in the settings outline.
    # Keys are positions, values are dicts giving info for a setting file.
self.fontRefs = {} # A dict to retain references to fonts.
self.modal = False
self.old_p = c.currentPosition()
self.old_root = c.rootPosition()
self.p = None # Used to revert settings.
self.panes = {}
self.parser = None
self.replaceBody = replaceBody
self.sc = None
self.setterLabel = None
self.suppressComments = None # position for which to suppress comments.
self.title = "Settings for %s" % g.shortFileName(c.fileName())
self.top = None
self.tree = None
#@nonl
#@-node:ekr.20050123194330:<< init ivars >>
#@+node:ekr.20050129111522:<< define Tk color names >>
self.colorNamesList = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )
#@nonl
#@-node:ekr.20050129111522:<< define Tk color names >>
#@+node:ekr.20050121105232:<< set background color for widgets >>
if 0:
    # Get the color from the background color of the body text widget.
    self.commonBackground = c.frame.body.bodyCtrl.cget('background')
    
else:
    # 'LightSteelBlue1' # too blue.
    # 'gray80' # too dark.
    # 'gray90' # Possible: very light.
    # '#f2fdff' # Same as log window.  Too cute.
    
    self.commonBackground = 'gray90'
#@nonl
#@-node:ekr.20050121105232:<< set background color for widgets >>
#@-node:ekr.20041225063637.13: ctor (settingsController)
#@+node:ekr.20041223105114.1:Status line methods (compatibility)
def getStatusObject(self):
    component = self.component(self.statusLineComponentName)
    if not component: return g.trace("No statusLine component")
    obj = component.getObject()
    if obj: return obj
    else: return g.trace(
        "%s component has no status line object" % (
            self.statusLineComponentName))
                
def callStatus(self,name,*args,**keys):
    obj = self.getStatusObject()
    if not obj: return
    try:
        f = getattr(obj,name)
        return f(*args,**keys)
    except AttributeError:
        return g.trace("%s component has no '%s' method" % (
            self.statusLineComponentName,name))

def createStatusLine (self):
    self.callStatus('show')
    return self.getStatusObject() # For compatibility.

def clearStatusLine (self):
    return self.callStatus('clear')
    
def disableStatusLine (self,background=None):
    return self.callStatus('disable',background)

def enableStatusLine (self,background="white"):
    return self.callStatus('enable',background)

def getStatusLine (self):
    return self.callStatus('get')
    
def putStatusLine (self,s,color=None):
    return self.callStatus('put',s,color)
    
def setFocusStatusLine (self):
    return self.callStatus('setFocus')

def statusLineIsEnabled(self):
    return self.callStatus('isEnabled')
#@nonl
#@-node:ekr.20041223105114.1:Status line methods (compatibility)
#@-node:ekr.20050428103606:(Added support for UNL's in settings pane)
#@+node:ekr.20050430105726:(Added Paul Paterson's Tangle patch)
#@+node:ekr.20050430105726.1:email
@nocolor

I know you don't like to maintain the tangle code, but here is a patch to remove a hangnail of mine ...

The current way Leo works is that if you do a tangle on a node then it searches for child nodes which are @root's and then tangles them. However, in my workflow, the most common use case is that I make a quick change to a method and want to tangle the *parent* file. If you make the change and then hit ctrl-shift-t then Leo says "No roots in node".

What this patch does is to extend the current behaviour. If (and only if) there are no @roots in the node then it tries to find a parent node which is a @root. If if finds one then it tangles it and then stops. In most cases I think this is what the user would want to happen.

You will probably say,

a) I should be using @thin's, or
b) marking nodes and then using the tangle-marked function

(a) is not currently workable on my main project (14,000 nodes and 700+ files!) since writing the Leo file itself takes 30 seconds or more. I do use marked nodes but even then if I have several large nodes marked it takes 10+ seconds to tangle them and so I often want to just do a quick tangle to a single file without losing my current node location.

Anyway, here is the patch ... it affects only the tangle method of baseTangleCommands in leoTangle.py ...

   def tangle(self):
         c = self.c ; p = c.currentPosition()
       self.initTangleCommand()
       if not self.tangleTree(p,report_errors):
           g.es("Looking for a parent to tangle")
           while p:
               if g.get_directives_dict(p.bodyString(),[self.head_root]).has_key("root"):
                   g.es("Tangling parent")
                   self.tangleTree(p,report_errors)
                   break
               p.moveToParent()


This could have been a plugin but it seems to me that this is probably just easier to roll into Leo rather than have another tiny plugin to support.
#@-node:ekr.20050430105726.1:email
#@+node:ekr.20050430105726.2:patch
# Anyway, here is the patch ... it affects only the tangle method of baseTangleCommands in leoTangle.py ...

def tangle(self):
    c = self.c ; p = c.currentPosition()
    self.initTangleCommand()
    if not self.tangleTree(p,report_errors):
        g.es("Looking for a parent to tangle")
        while p:
            if g.get_directives_dict(p.bodyString(),[self.head_root]).has_key("root"):
                g.es("Tangling parent")
                self.tangleTree(p,report_errors)
                break
            p.moveToParent()
#@nonl
#@-node:ekr.20050430105726.2:patch
#@+node:ekr.20031218072017.3472:tangle
def tangle(self):
    
    c = self.c ; p = c.currentPosition()
    self.initTangleCommand()
    
    if 1: # Paul Paterson's patch.
        if not self.tangleTree(p,report_errors):
            g.es("looking for a parent to tangle...")
            while p:
                d = g.get_directives_dict(p.bodyString(),[self.head_root])
                if d.has_key("root"):
                    g.es("tangling parent")
                    self.tangleTree(p,report_errors)
                    break
                p.moveToParent()
    else:
        self.tangleTree(p,report_errors)
    
    g.es("tangle complete")
#@-node:ekr.20031218072017.3472:tangle
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@-node:ekr.20050430105726:(Added Paul Paterson's Tangle patch)
#@-node:ekr.20050316083031.2:Features...
#@+node:ekr.20050429092616:Plugins
#@+node:ekr.20050429091529:(Read @file Nodes v Import Derived Files)
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self):

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    
    c.fileCommands.readAtFileNodes()
    
    u.afterChangeTree(p,'Read @file Nodes',undoData)
#@nonl
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20031218072017.3029:readAtFileNodes (leoAtFile)
def readAtFileNodes (self):

    c = self.c ; current = c.currentPosition()
    c.atFileCommands.readAll(current,partialFlag=True)
    c.redraw()
    
    # Force an update of the body pane.
    current.setBodyStringOrPane(current.bodyString())
    c.frame.body.onBodyChanged(current,undoType=None)
#@nonl
#@-node:ekr.20031218072017.3029:readAtFileNodes (leoAtFile)
#@+node:ekr.20031218072017.1809:importDerivedFile
def importDerivedFile (self):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(p,names)
#@nonl
#@-node:ekr.20031218072017.1809:importDerivedFile
#@-node:ekr.20050429091529:(Read @file Nodes v Import Derived Files)
#@-node:ekr.20050429092616:Plugins
#@-node:ekr.20050316083031:4.3 b1 projects
#@+node:ekr.20050503111718:4.3 b2 projects
#@+node:ekr.20050505094928:Bugs
#@+node:ekr.20050328090032:(Investigated problems with os.spwawnv in openWith
#@+node:ekr.20050328090032.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3054876
By: mstarzyk

It looks to me like there is a bug in baseCommands.openWith(("os.spawnv"...))
(Or in vim.py plugin that calls it)

The executable should be passed twice to os.spawnv - first 
as the "path" param, then as the first item in "args"
But in line leoCommands.py:485 the executable is not included
in the "args" param.

Python manual says:
    os.spawnv
    The "v" variants are good when the number of parameters 
    is variable [...]
    In either case, the arguments to the child process must 
    start with the name of the command being run. 

With the current code the process runs, but the first parameter 
is not passed to it. 
So for example in the vim plugin vim is actually started 
without the "--servername LEO" param.

Additionally - on windows the executable in "args" should 
be surrounded with doublequotes if the path contains whitespace.

Cheers, 
Maciek
#@nonl
#@-node:ekr.20050328090032.1:Report
#@+node:ekr.20050428093945:Suggested fix
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3122633
By: davidschein

In leoCommands.baseCommands.openWith(..) I added

@color

elif openType == "desHACK": apply(os.spawnv,(os.P_NOWAIT, r"c:\vim\vim63\gvim.exe",
[" --servername LEO "," --remote-silent "]+[shortPath]))

# and in vim.open_in_vim(..) I made the call to open Vim

#des: the big HACK
g.top().openWith(("desHACK",None, None))

@nocolor

I know it is outrageous, but I was in a hurry and it does the trick for now.
I thought I would just share it in case it points to a proper solution.
#@nonl
#@-node:ekr.20050428093945:Suggested fix
#@+node:ekr.20050503111641:Not really a problem
@nocolor

I think you misunderstand how Leo calls os.spawnv. 
 
The following works for me: 
 
table = ('spawnv',None,( 
'os.spawnv',[ 
r'c:\vim\vim63\gvim.exe', 
' --servername LEO ', 
' --remote-silent ', 
], 
".py")) 
 
c.frame.menu.createOpenWithMenuFromTable(table) 
 
This works because c.openWith takes the first element of the list (in this case, r'c:\vim\vim63\gvim.exe') and uses it as the first argument to spawnv. 
 
I grant you that this is not well documented :-) 
 
Edward 
 
P.S. Here is the actual code in openWith: 
 
elif openType == "os.spawnv": 
    filename = os.path.basename(arg[0])  
    vtuple = arg[1:]  
    vtuple.append(path) 
    apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple)) 
 
EKR
#@-node:ekr.20050503111641:Not really a problem
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:] 
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(os.path.abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@-node:ekr.20050328090032:(Investigated problems with os.spwawnv in openWith
#@+node:ekr.20050504105855:(Fixed nodenavagator bug)
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3133917

Having the Nodenavigator plugin enabled by default: 
in an empty, new outline, no 'Recently' nor 'Marked' button shows up in the tool bar
#@nonl
#@-node:ekr.20050504105855:(Fixed nodenavagator bug)
#@+node:ekr.20050504110933:(Fixed LaTex Coloring bug)
#@+node:ekr.20050504110933.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3133915
By: Greg

Latex keywords aren't colored when certain characters are after them.  For example,
"\documentclass" in

\documentclass{report}

is not colorized, but it is when you add a space like so:

\documentclass {report}

I've traced the problem to line 1684 in LeoColor.py (as it appears in CVS).
This is in the section labeled "<< handle possible latex keyword >>".  This
line currently reads

j = self.skip_id(s,i+1,chars=self.latex_special_keyword_characters) # 11/9/03

So what I think is happening is that, since "{" and "}" are considered special
keyword characters, it's parsing the entire command "\documentclass{report}"
as a single keyword, rather than just "\documentclass".  The fix is easy:  just
get rid of the chars= keyword like so:

j = self.skip_id(s,i+1)

This seems to be  working for me... it's kinda odd that someone put that in
there in the first place, though, so maybe it does something else that
I'm missing?

Also, disclaimer:  I'm currently running 4.1 on my computer.  Although line
1684 appears the same on the CVS as it does in my version, maybe something else
was changed in the latest version to make it work.
#@nonl
#@-node:ekr.20050504110933.1:Report
#@+node:ekr.20050504110933.2:Notes
The code must handle the following with special-case code:
    
"\\@", "\\(", "\\)", "\\{", "\\}",
#@nonl
#@-node:ekr.20050504110933.2:Notes
#@+node:ekr.20031218072017.1899:<< handle possible latex keyword >>
if g.match(s,i,"\\"):
    if i + 1 < len(s) and s[i+1] in self.latex_special_keyword_characters:
        j = i + 2 # A special 2-character LaTex keyword.
    else:
        j = self.skip_id(s,i+1)
    word = s[i:j]
    if word in self.latex_keywords:
        self.tag("latexKeyword",i,j)
    else:
        self.tag("latexBackground",i,j)
else:
    self.tag("latexBackground",i,i+1)
    j = i + 1 # skip the character.
#@nonl
#@-node:ekr.20031218072017.1899:<< handle possible latex keyword >>
#@+node:ekr.20031218072017.377:latex keywords
#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
    "\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
    "\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
    "\\cot", "\\coth",	"csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
    "\\linethickness", "\\linewidth",	"\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow",	"longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi",	"\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow",	"\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone",	"\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]
#@nonl
#@-node:ekr.20031218072017.377:latex keywords
#@-node:ekr.20050504110933:(Fixed LaTex Coloring bug)
#@+node:ekr.20050317073747:(Unredirected output only after all script processing is complete)
#@+node:ekr.20050317102007:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3051870
By: e

if you make a script button, the error is printed
to the console only. no redirection to log if enabled.
#@nonl
#@-node:ekr.20050317102007:Report
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20050220030850:test_g_es_exception
def test_g_es_exception():
    
    if c.config.redirect_execute_script_output_to_log_pane:
        return # Test doesn't work when redirection is on.

    try:
        import sys
        # Catch the output of g.es_exception.
        # We catch the AssertionError, so nothing gets written to stderr.
        sys.stdout = fo = g.fileLikeObject()
        try: # Create an exception to catch.
            assert False, 'Assert False in test_g_es_exception'
        except AssertionError:
            g.es_exception(color='suppress')
            result = fo.get()
            s1 = 'Traceback (most recent call last):'
            s2 = 'AssertionError: Assert False in test_g_es_exception'
            assert result.find(s1) > -1, 'No traceback line: %s' % repr(result)
            assert result.find(s2) > -1, 'No AssertionError line: %s' % repr(result)
    finally:
        # Not needed unless we execute this script as selected text.
        sys.stdout = sys.__stdout__
#@nonl
#@-node:ekr.20050220030850:test_g_es_exception
#@-node:ekr.20050317073747:(Unredirected output only after all script processing is complete)
#@+node:ekr.20050507081356.1:(Fixed Crasher in nav_buttons)
#@+node:ekr.20050508113634:Notes
@killcolor

The nav_buttons plugin was using self.c rather than keywords.get('c') in a hook
handler. The general rule is that hook handlers should do nothing if self.c !-
keywords.get('c').  This was an old bug, arising from the rewrite of the plugin.

I added a warning to that effect in the plugin template.

It would perhaps be better to specify an optional commander in registerHandler
and only call the handler if the commander matches. However, this isn't so easy
or clean to do.
#@nonl
#@-node:ekr.20050508113634:Notes
#@+node:ekr.20050508060138:Traceback
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3138608

With nav_buttons plugin loaded. the first click in the outline window after
loading an outline produces:
Traceback (most recent call last):
  File "C:\Program Files\leo\src\leoGlobals.py", line 2286, in doHook
    return f(tag,keywords)
  File "C:\Program Files\leo\src\leoPlugins.py", line 92, in doPlugins
    return doHandlersForTag(tag,keywords)
  File "C:\Program Files\leo\src\leoPlugins.py", line 73, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)
  File "C:\Program Files\leo\src\leoPlugins.py", line 51, in callTagHandler
    result = handler(tag,keywords)
  File "C:\Program Files\leo\plugins\nav_buttons.py", line 395, in updateRecent
    self.updateButtons()
  File "C:\Program Files\leo\plugins\nav_buttons.py", line 374, in
updateButtons
    for b,b2,enabled_image,disabled_image,cond in (
AttributeError: Commands instance has no attribute 'beadPointer'
#@nonl
#@-node:ekr.20050508060138:Traceback
#@+node:ekr.20050102094729:callTagHandler
def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                if not hasattr(c,'frame'): return None
                if c.frame not in g.app.windowList:
                    return None # c has (or will be) destroyed.

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result
#@nonl
#@-node:ekr.20050102094729:callTagHandler
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        if self.trace and self.verbose:
            g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@-node:ekr.20050507081356.1:(Fixed Crasher in nav_buttons)
#@+node:ekr.20050317075352:(Investigated disappearing scrollbar  when autocompleter plugin is enabled)
# Autocompleter appears to work as expected with the 4.3b1 release.
#@nonl
#@+node:ekr.20050317075352.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3052150
By: brianvanden

Leo Log Window...
Leo 4.3 alpha 4, build  1.231 , March 15, 2005
Python 2.4.0, Tk 8.4.7, win32

I installed a4 today, made some changes to leoSettings.leo, and began exploring
plugins. If autocompleter.py is enabled while the other plugins are left as
in a fresh leo install, and the body pane is set not to wrap, then, when a line
is longer than the screen, there is no horizontal scrollbar in the body pane.
(I've observed this in both nodes not in a @nowrap sub- tree as well as those
in such a sub-tree.)

If autocompleter.py is disabled and leo is relaunched, the horizontal scroll
bar appears as expected.

but http://sourceforge.net/forum/forum.php?thread_id=1244118&forum_id=10226
might be relevant.
#@nonl
#@-node:ekr.20050317075352.1:Report
#@-node:ekr.20050317075352:(Investigated disappearing scrollbar  when autocompleter plugin is enabled)
#@+node:ekr.20050317074713:(Tested chapters plugin)
#@+node:ekr.20050508200915:Problem: crasher (no problem now)
#@+node:ekr.20050317074713.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3051866
By: nobody

3)When enabling the chapters plugin, starting up Leo (which gives me an untitled
window) and use the File-->Open menu to open leopluginsref.leo I get the following
in the log pane:

Leo Log Window...
Leo 4.3 alpha 4, build  1.234 , March 15, 2005
Python 2.3.4, Tk 8.4.3, win32

exceptions opening: C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\plugins\leoPluginsRef.leo
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\src\leoGlobals.py", line 630, in openWithFileName
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\plugins\chapters.py", line 924, in newOpen
    return oldOpen(self,file,fileName,readAtFileNodesFlag)
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo\src\leoFileCommands.py", line 1285, in open
    ok, ratio =
self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
TypeError: newGetLeoFile() got an unexpected keyword argument 'silent'

of the newly opened window. In the still open 'untitled' window I can see a
second 'no reportlab' line added to the log.
#@nonl
#@-node:ekr.20050317074713.1:Report
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        if not silent:
            << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)
    
    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@-node:ekr.20050508200915:Problem: crasher (no problem now)
#@+node:ekr.20050330135547:Problem: disappearing chapters (I don't see this)
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        if self.trace and self.verbose:
            g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20050330135641:Report 1
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3073752
By: nobody

I just tried Chapters (latest CVS from a few hours ago) and I had a major bug,
one that I've noticed for a few months now. I have 5 chapters and many cross-chapter
clones.

At unexpected times, when clicking on a node in one of the Chapters, Leo suddenly
loses track of an entire subtree or the entirety of nodes in the outline. Just
minutes ago, I clicked on a node in my first chapter (containing my entire outline,
with subparts cloned to other chapters), and the ENTIRE CONTENTS of the chapter
DISAPPEARED with the exception of one "New Headline" node, which was odd because
I didn't add anything new in the first chapter. I tried CTRL+1, CTRL+2 to force
Leo to redraw the outline in case the  nodes were present but somehow hidden,
but no luck - all the nodes really seemed to be gone. The other chapters (containing
clones from the first chapter) still looked ok. I had saved a few minutes earlier,
so I quit without saving, hoping my earlier-saved version would still be OK,
but to my disappointment the earlier-saved version had a one-node ("New Headline")
outline in the first chapter.

I had noticed this behavior since a few months (unfortunately I can't recall
starting with which version), so I had been refraining from using Chapters,
but it appears that there is still a serious bug lurking somewhere in there.
#@nonl
#@-node:ekr.20050330135641:Report 1
#@+node:ekr.20050330135641.1:Report 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3073757
By: nobody

Regarding my previous message about Chapters deleting my entire outline, I just
remembered my sequence of steps more clearly. This may provide some hint towards
reproducing and fixing the bug.

What I did:
- Enabled Chapters, re-started Leo (latest CVS).
- Load my huge outline. It appears in Chapter 1.
- Add a chapter.
- ***MAYBE IMPORTANT?*** The new chapter contains a new node, "New Headline".
I leave this headline as it is, for now.
- Clone some/many nodes into the new Chapters.
- Add a few more chapters, again not touching the default "New Headline" node,
and cloning nodes from Chapter 1 (big outline) into the new chapters.

Up until now everything "seems" ok.

Then, I started with Chapter 5, and deleted the "New Headline" node with the
right-mouse-click menu. I did the same in Chapter 4, Chapter 3, and Chapter 2.

Now, I returned to Chapter 1, clicked somewhere in the huge outline, and suddenly
my entire outline disappeared, and a single "New Headline" node took its place.

It looks as if some links or references between nodes/chapters are getting out
of sync. Anyway, I know this information is not extremely specific, but maybe
it will help in finding the bug.
#@nonl
#@-node:ekr.20050330135641.1:Report 2
#@-node:ekr.20050330135547:Problem: disappearing chapters (I don't see this)
#@+node:ekr.20050508201625:Problem: c.exists may return False in chapters
#@+node:ekr.20040803072955.65:idle_scrollTo
def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p: p = self.c.currentPosition()
    if not p: p = self.c.rootPosition()
    if not p or not p.exists(c):
        g.trace('does not exist:',p.headString())
        return
    # g.trace(p.headString())
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:idle_scrollTo
#@-node:ekr.20050508201625:Problem: c.exists may return False in chapters
#@-node:ekr.20050317074713:(Tested chapters plugin)
#@+node:ekr.20050508201158:(Fixed crasher in yoffsetTree)
# This happened when creating a new chapter with chapters.py enabled.
#@nonl
#@+node:ekr.20050508201158.1:Traceback
idle_scrollTo: does not exist: NewHeadline
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1416, in idle_scrollTo
    h2 = self.yoffset(last)

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1493, in yoffset
    h,flag = self.yoffsetTree(root,p1)

  File "C:\prog\leoCVS\leo\src\leoTkinterTree.py", line 1509, in yoffsetTree
    h2, flag = self.yoffsetTree(child,p1)

TypeError: unpack non-sequence
#@nonl
#@-node:ekr.20050508201158.1:Traceback
#@+node:ekr.20040803072955.70:yoffset
@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False
#@nonl
#@-node:ekr.20040803072955.70:yoffset
#@-node:ekr.20050508201158:(Fixed crasher in yoffsetTree)
#@-node:ekr.20050505094928:Bugs
#@+node:ekr.20050505094928.1:Features
#@+node:ekr.20050505051303:(Allow quoted urls in  @urls nodes)
#@+node:ekr.20050505051303.1:Request
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3135170
By: trishul

I am also using leo partly as a pim and partly for warehousing code in W2K.
The clickable "@url file://" nodes work fine, but how
do you manage spaces in filenames ?  (the %20 substitute appears to work only
in http:// url's and quoting didn't help)
#@-node:ekr.20050505051303.1:Request
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        << stop the url after any whitespace >>
        # g.trace(url)
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,p=p,v=p)
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
    
#@nonl
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
#@-node:ekr.20050505051303:(Allow quoted urls in  @urls nodes)
#@+node:ekr.20050503112513:(Moved executeFile into core)
@ For tests of this, see the script in test.leo at:
    
Scripts-->Script to execute @test, @suite or file

Read the documentation in that node before running the script.
#@nonl
#@+node:ekr.20050503112513.7:g.executeFile
def executeFile(filename, options= ''):

    if not os.access(filename, os.R_OK): return
    
    try: import subprocess # Exists in Python 2.4 or later.
    except ImportError: subprocess = None

    cwd = os.getcwdu()
    fdir, fname = g.os_path_split(filename)
    
    if subprocess: # Only exists in Python 2.4.
        << define subprocess_wrapper >>
        rc, so, se = subprocess_wrapper('%s %s %s'%(sys.executable, fname, options))
        if rc:
             print 'return code', rc
        print so, se
    else:
        if fdir: os.chdir(fdir)
        d = {'__name__': '__main__'}
        execfile(fname, d)  #, globals()
        os.system('%s %s' % (sys.executable, fname))
        if fdir: os.chdir(cwd)
#@nonl
#@+node:ekr.20050503112513.8:<< define subprocess_wrapper >>
def subprocess_wrapper(cmdlst):
    
    # g.trace(cmdlst, fdir)
    # g.trace(subprocess.list2cmdline([cmdlst]))

    p = subprocess.Popen(cmdlst, cwd=fdir,
        universal_newlines=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdo, stde = p.communicate()
    return p.wait(), stdo, stde
#@nonl
#@-node:ekr.20050503112513.8:<< define subprocess_wrapper >>
#@-node:ekr.20050503112513.7:g.executeFile
#@-node:ekr.20050503112513:(Moved executeFile into core)
#@+node:ekr.20050211173540:(Rewrote g.getScript using at.writeFromString)
#@+node:ekr.20050506095420:What I did
@killcolor

g.getScript now fully processes all scripts, regardless of where they came from.

- Changed g.getScript:
    - p arg is now required.
    - Removed unused script arg.
    - Added forcePythonSentinels arg (default is True).
    - g.getScript no longer temporarily alters any body text.
        - atFile.writeFromString gets the initial text using the fromString arg.
    - g.getScript now always calls atFile.writeFromString to handle all Leo directives.

- Added forcePythonSentinels to atFile.initWriteIvars and atFile.scanAllDirectives.
    - Default is None, in which case the code sets forcePythonSentinels to the scriptWrite arg.

- Added forcePythonSentinels to atFile.scanAllDirectives.
    - Default is False.

- Created atFile.putAtFirstLines and atFile.putAtLastLines.
    - These replace the corresonding sections in writeOpenFile.
    - It was not actually necessary to define these, but it cleans up the code.

- Created atFile.writeFromString.
    - This handles all the details of simulating a write _from_ a string _to_ a string.

- atFile.initWriteIvars and atFile.openFileForWriting now allow root to be None.
    - This is not used at present: root is always defined.

- Added fromString arg to atFile.writeOpenFile and atFile.putBody.
#@nonl
#@-node:ekr.20050506095420:What I did
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:EKR.20040614071102.1:g.getScript & tests
def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        print s ; g.es(s)
        g.es_exception()
        script = ''

    return script
#@nonl
#@+node:ekr.20050211100535:test_g_getScript_strips_crlf
def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)
#@nonl
#@-node:ekr.20050211100535:test_g_getScript_strips_crlf
#@-node:EKR.20040614071102.1:g.getScript & tests
#@+node:ekr.20041005105605.15:initWriteIvars
def initWriteIvars(self,root,targetFileName,
    nosentinels=False,
    thinFile=False,
    scriptWrite=False,
    toString=False,
    forcePythonSentinels=None):

    self.initCommonIvars()
    << init ivars for writing >>
    
    if forcePythonSentinels is None:
        forcePythonSentinels = scriptWrite

    if root:
        self.scanAllDirectives(root,
            scripting=scriptWrite,
            forcePythonSentinels=forcePythonSentinels)
    
    # g.trace(forcePythonSentinels,self.startSentinelComment,self.endSentinelComment)
    
    if forcePythonSentinels:
        # Force Python comment delims for g.getScript.
        self.startSentinelComment = "#"
        self.endSentinelComment = None

    # Init state from arguments.
    self.targetFileName = targetFileName
    self.sentinels = not nosentinels
    self.thinFile = thinFile
    self.toString = toString
    self.root = root
    
    # Ignore config settings for unit testing.
    if toString and g.app.unitTesting: self.output_newline = '\n'
    
    # Init all other ivars even if there is an error.
    if not self.errors and self.root:
        self.root.v.t.tnodeList = []
#@nonl
#@+node:ekr.20041005105605.16:<< init ivars for writing >>>
@
When tangling, we first write to a temporary output file. After tangling is
temporary file. Otherwise we delete the old target file and rename the temporary
file to be the target file.
@c

self.docKind = None
self.explicitLineEnding = False # True: an @lineending directive specifies the ending.
self.fileChangedFlag = False # True: the file has actually been updated.
self.shortFileName = "" # short version of file name used for messages.
self.thinFile = False

if toString:
    self.outputFile = g.fileLikeObject()
    self.stringOutput = ""
    self.targetFileName = self.outputFileName = "<string-file>"
else:
    self.outputFile = None # The temporary output file.
    self.stringOutput = None
    self.targetFileName = self.outputFileName = u""
#@nonl
#@-node:ekr.20041005105605.16:<< init ivars for writing >>>
#@-node:ekr.20041005105605.15:initWriteIvars
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self
    
    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20050506090446.1:putAtFirstLines (new in 4.3 b2)
def putAtFirstLines (self,s):
    
    '''Write any @firstlines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines preceding the @+leo sentinel.'''

    at = self ; tag = "@first"

    i = 0
    while g.match(s,i,tag):
        i += len(tag)
        i = g.skip_ws(s,i)
        j = i
        i = g.skip_to_end_of_line(s,i)
        # Write @first line, whether empty or not
        line = s[j:i]
        at.os(line) ; at.onl()
        i = g.skip_nl(s,i)
#@nonl
#@-node:ekr.20050506090446.1:putAtFirstLines (new in 4.3 b2)
#@+node:ekr.20050506090955:putAtLastLines (new in 4.3 b2)
def putAtLastLines (self,s):
    
    '''Write any @last lines from string s.
    These lines are converted to @verbatim lines,
    so the read logic simply ignores lines following the @-leo sentinel.'''

    at = self ; tag = "@last"
    
    # Use g.splitLines to preserve trailing newlines.
    lines = g.splitLines(s)
    n = len(lines) ; j = k = n - 1
    
    # Scan backwards for @last directives.
    while j >= 0:
        line = lines[j]
        if g.match(line,0,tag): j -= 1
        elif not line.strip():
            j -= 1
        else: break
        
    # Write the @last lines.
    for line in lines[j+1:k+1]:
        if g.match(line,0,tag):
            i = len(tag) ; i = g.skip_ws(line,i)
            at.os(line[i:])
#@nonl
#@-node:ekr.20050506090955:putAtLastLines (new in 4.3 b2)
#@+node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
def openFileForWriting (self,root,fileName,toString):

    at = self
    at.outputFile = None
    
    if toString:
        at.shortFileName = g.shortFileName(fileName)
        at.outputFileName = "<string: %s>" % at.shortFileName
        at.outputFile = g.fileLikeObject()
    else:
        at.openFileForWritingHelper(fileName)

    # New in 4.3 b2: root may be none when writing from a string.
    if root:
        if at.outputFile:
            root.clearOrphan()
        else:
            root.setOrphan()
            root.setDirty()
    
    return at.outputFile is not None
#@nonl
#@+node:ekr.20041005105605.143:openFileForWritingHelper
def openFileForWritingHelper (self,fileName):
    
    at = self

    try:
        at.shortFileName = g.shortFileName(fileName)
        fileName = g.os_path_join(at.default_directory,fileName)
        at.targetFileName = g.os_path_normpath(fileName)
        path = g.os_path_dirname(at.targetFileName)
        if not path or not g.os_path_exists(path):
            at.writeError("path does not exist: " + path)
            return
    except:
        at.exception("exception creating path:" + path)
        return

    if g.os_path_exists(at.targetFileName):
        try:
            if not os.access(at.targetFileName,os.W_OK):
                at.writeError("can not create: read only: " + at.targetFileName)
                return
        except AttributeError: pass # os.access() may not exist on all platforms.

    try:
        at.outputFileName = at.targetFileName + ".tmp"
        at.outputFile = self.openForWrite(at.outputFileName,'wb') # bwm
        if not at.outputFile:
            at.writeError("can not create " + at.outputFileName)
    except:
        at.exception("exception creating:" + at.outputFileName)
#@nonl
#@-node:ekr.20041005105605.143:openFileForWritingHelper
#@-node:ekr.20041005105605.142:openFileForWriting & openFileForWritingHelper
#@+node:ekr.20041005105605.144:write
# This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,scriptWrite=False,toString=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.
    << set at.targetFileName >>
    at.initWriteIvars(root,at.targetFileName,
        nosentinels=nosentinels,thinFile=thinFile,
        scriptWrite=scriptWrite,toString=toString)
    if not at.openFileForWriting(root,at.targetFileName,toString):
        return

    try:
        at.writeOpenFile(root,nosentinels=nosentinels,toString=toString)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            << set dirty and orphan bits on error >>
    except:
        if toString:
            at.exception("exception preprocessing script")
            at.root.v.t.tnodeList = []
        else:
            at.writeException() # Sets dirty and orphan bits.
#@+node:ekr.20041005105605.145:<< set at.targetFileName >>
if toString:
    at.targetFileName = "<string-file>"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
#@nonl
#@-node:ekr.20041005105605.145:<< set at.targetFileName >>
#@+node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
# Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors > 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()
#@nonl
#@-node:ekr.20041005105605.146:<< set dirty and orphan bits on error >>
#@-node:ekr.20041005105605.144:write
#@+node:ekr.20041005105605.157:writeOpenFile
# New in 4.3: must be inited before calling this method.
# New in 4.3 b2: support for writing from a string.

def writeOpenFile(self,root,nosentinels=False,toString=False,fromString=''):

    """Do all writes except asis writes."""
    
    at = self ; s = g.choose(fromString,fromString,root.v.t.bodyString)

    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    at.putAtFirstLines(s)
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root,fromString=fromString)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    at.putAtLastLines(s)

    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()
#@nonl
#@-node:ekr.20041005105605.157:writeOpenFile
#@+node:ekr.20050506084734:writeFromString (new in 4.3 beta2)
# This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing() # Capture the current headline.

    at.initWriteIvars(root,"<string-file>",
        nosentinels=False,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=False,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput
#@nonl
#@-node:ekr.20050506084734:writeFromString (new in 4.3 beta2)
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,useSelectedText=True,define_g=True):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20050505104140.1:notes
@killcolor

At present c.executeScript does not call at.write if the script came from a selection.

In fact, at.write assumes the 'root' node is c.currentPosition(). This must
change if selections are to support Leo directives and section references.
#@nonl
#@-node:ekr.20050505104140.1:notes
#@+node:ekr.20050228093753:e post 1
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3017712

maybe not yet, except as a conditional script.
its really only a very first draft.
py2.4 ok
py2.3 if you put subprocess.py in extensions
and their compiled extension from effbot.org
unless pywin32 is installed one or the other.
no extension needed for nix.
2.2 not even sure.
but worse, subprocess doesn't work well under puthonw.exe
I emailed the author, no one filed a bug report!

and the redirection is external you'll notice,
that should be internal or the results should
be passed back. print to console otherwise is useless.
good enough in this application but not ready for primetime.

I see subprocess is used in temacs plugin too.
so subprocess should be in extensions in any case. and the merge of both use
functions should
be possible in a general way we can all use.
#@nonl
#@-node:ekr.20050228093753:e post 1
#@+node:ekr.20050228093753.1:e post 2
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3018068

a few other considerations,
executeFile is now a misnomer. I originally expected
to only need to make __name__ = '__main__',
but then what about options?
what about running another program than python?
the other sticky problem from Leo, what about packing 
sys.args for the spawned program? which I didn't attempt.
and to duplicate the experience many programs expect args.
execfile() was not going to cut it.

the fallback for pythonw for now is:

.    child_stdin, child_stdout, child_stderr = os.popen3(cmds)
.    output = child_stdout.read()
.    outerr = child_stderr.read()
.    return output, outerr

but, no return code? maybe popen4 is required for that.
subprocess handles it allot better.
not to mention piping the output from one program into another.
we don't want to have people tripping over shell
escaping problems to do simple things in a secure way.
and did I read in another thread the mac has pythonw?
does it suffer the same lack of stdout/stderr as 
windows' pythonw?
no one problem insurmountable. I could imagine 
python.org taking the compatibility lead providing
a py2224.zip with a few of the missing pieces.
subprocess, datetime, sets, itertools, csv what have you.
then instead of everyone incompletely trying
to piece together compatibility those that want it
could install a compete package.
then there would only be PMW.
we probably need elementtree and celementtree too.
#@nonl
#@-node:ekr.20050228093753.1:e post 2
#@+node:ekr.20050302072742:iPython support (more powerful execute script)
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3023147
By: e

a little IPython integration woulden't be a bad thing.
not with IPython code as much as in its execution.

there '%' is now the magic char (was @) 

you can also have automagic enabled.
in scripting we have the static approach where you have
to carefully think about what function to call
the system and if it works on this or that OS.
how to construct the call, list or string, 
do I need to escape etc.

what about a less static:
filename = 'whatever.py'
%python filename > <<details>>
%cat <<details>> | sort

maybe that would make too much work
for executeScript.  just a thought.
code to follow RSN.

>>I'll discuss them in detail when getting around to moving this work into Leo's core

there are many places in Leo code, 
openwith g.executeScript and various plugins
all doing similar things in multitues of ways.
a little more centralization might be called for.
by then maybe subprocess will be updated.
#@nonl
#@-node:ekr.20050302072742:iPython support (more powerful execute script)
#@-node:ekr.20050211173540:(Rewrote g.getScript using at.writeFromString)
#@-node:ekr.20050505094928.1:Features
#@-node:ekr.20050503111718:4.3 b2 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
