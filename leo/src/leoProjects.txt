#@+leo-ver=4-thin
#@+node:EKR.20040429143933:@thin leoProjects.txt
#@+at 
#@nonl
# This part of the tree shows views of the outline related to specific 
# projects or tasks.  I put such headlines in parentheses, and that is just my 
# convention.
# 
# I create a new view by cloning headlines that relate to its task, and moving 
# the cloned headlines under the task headline.  This greatly increases my 
# focus.  Any changes made in a task view to clone headlines affect the other 
# clones scattered throughout the outline.  In particular, all @file nodes 
# containing changed clones become marked as dirty, so they will be written 
# when the entire outline is saved.
#@-at
#@@c

#@@language python 
#@@tabwidth -4

#@+all
#@+node:ekr.20031218072017.2606:<< Import pychecker >>
@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.

    # Note:  Pychecker presently works only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print
#@nonl
#@-node:ekr.20031218072017.2606:<< Import pychecker >>
#@+node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
#@nonl
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@+node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
# Called by __init__

def init_ivars(self):

    c = self.c
    << init tangle ivars >>
    << init untangle ivars >>
    
# Called by scanAllDirectives

def init_directive_ivars (self):

    c = self.c
    << init directive ivars >>
#@nonl
#@+node:ekr.20031218072017.1357:<< init tangle ivars >>
# Various flags and counts...

self.errors = 0 # The number of errors seen.
self.tangling = True # True if tangling, False if untangling.
self.path_warning_given = False # True: suppress duplicate warnings.
self.tangle_indent = 0 # Level of indentation during pass 2, in spaces.
if c.frame:
    self.file_name = c.mFileName # The file name (was a bridge function)
else:
    self.file_name = "<unknown file name>"
self.p = None # position being processed.
self.output_file = None # The file descriptor of the output file.
self.start_mode = "doc" # "code" or "doc".  Use "doc" for compatibility.
self.tangle_default_directory = None # Default directory set by scanAllDirectives.

@ Symbol tables: the TST (Tangle Symbol Table) contains all section names in the outline. The UST (Untangle Symbol Table) contains all sections defined in the derived file.
@c
self.tst = {}
self.ust = {}

# The section stack for Tangle and the definition stack for Untangle.
self.section_stack = []
self.def_stack = []

@ The list of all roots. The symbol table routines add roots to self list during pass 1. Pass 2 uses self list to generate code for all roots.
@c
self.root_list = []

# The delimiters for comments created by the @comment directive.
self.single_comment_string = "//"  # present comment delimiters.
self.start_comment_string = "/*"
self.end_comment_string = "*/"
self.sentinel = None

# The filename following @root in a headline.
# The code that checks for < < * > > = uses these globals.
self.root = None
self.root_name = None

# Formerly the "tangle private globals"
# These save state during tangling and untangling.
# It is possible that these will be removed...
if 1:
    self.head_root = None
    self.code = None
    self.doc = None
    self.header_name = None
    self.header = None
    self.section_name = None

@ The following records whether we have seen an @code directive in a body text.
If so, an @code represents < < header name > > = and it is valid to continue a section definition.
@c
self.code_seen = False # True if @code seen in body text.

# Support of output_newline option
self.output_newline = g.getOutputNewline(c=c)
#@nonl
#@-node:ekr.20031218072017.1357:<< init tangle ivars >>
#@+node:ekr.20031218072017.1358:<< init untangle ivars >>
@ Untangle vars used while comparing.
@c
self.line_comment = self.comment = self.comment_end = None
self.comment2 = self.comment2_end = None
self.string1 = self.string2 = self.verbatim = None
self.message = None # forgiving compare message.
#@nonl
#@-node:ekr.20031218072017.1358:<< init untangle ivars >>
#@+node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
if 0: # not used in this version of Leo
    self.allow_rich_text = default_allow_rich_text
    self.extended_noweb_flag = default_extended_noweb_flag
    self.target_language = default_target_language # uses c.target_lanuage instead
    
# Global options
self.page_width = c.page_width
self.tab_width = c.tab_width
self.tangle_batch_flag = c.tangle_batch_flag
self.untangle_batch_flag = c.untangle_batch_flag

# Default tangle options.
self.tangle_directory = None # Initialized by scanAllDirectives
self.output_doc_flag = c.output_doc_flag
self.use_header_flag = c.use_header_flag

# Default tangle language
if c.target_language: c.target_language = c.target_language.lower()
self.language = c.target_language
delim1,delim2,delim3 = g.set_delims_from_language(self.language)
# g.trace(delim1,delim2,delim3)

# 8/1/02: this now works as expected.
self.single_comment_string = delim1
self.start_comment_string = delim2
self.end_comment_string = delim3

# Abbreviations for self.language.
# Warning: these must also be initialized in tangle.scanAllDirectives.
if 1: # 10/30/02: Don't change the code, just ignore @language cweb.
    self.use_cweb_flag = False
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
else:
    self.use_cweb_flag = self.language == "cweb"
    self.raw_cweb_flag = False # was never used before.

self.use_noweb_flag = not self.use_cweb_flag

# Set only from directives.
self.print_mode = "verbose"

# Stephen P. Schaefer 9/13/2002
# support @first directive
self.first_lines = ""
self.encoding = c.config.default_derived_file_encoding # 2/21/03
self.output_newline = g.getOutputNewline(c=c) # 4/24/03: initialize from config settings.
#@nonl
#@-node:ekr.20031218072017.1359:<< init directive ivars >> (tangle)
#@-node:ekr.20031218072017.1356:tangle.init_ivars & init_directive_ivars
#@+node:ekr.20031218072017.1360:tangle.scanAllDirectives
@ Once a directive is seen, related directives in ancesors have no effect.  For example, if an @color directive is seen in node x, no @color or @nocolor directives are examined in any ancestor of x.
@c

def scanAllDirectives(self,p,require_path_flag,issue_error_flag):
    
    """Scan vnode p and p's ancestors looking for directives,
    setting corresponding tangle ivars and globals.
    """
    
    __pychecker__ = 'maxlines=500 maxbranches=100'

    c = self.c
    # g.trace(p)
    old = {} ; print_mode_changed = False
    self.init_directive_ivars()
    if p:
        s = p.bodyString()
        << Collect @first attributes >>
    for p in p.self_and_parents_iter():
        s = p.bodyString()
        theDict = g.get_directives_dict(s)
        # g.trace("theDict:",theDict,p)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for print modes directives >>
        << Test for @path >>
        << Test for @pagewidth >>
        << Test for @root >>
        << Test for @tabwidth >>
        << Test for @header and @noheader >>
        old.update(theDict)
    << Set self.tangle_directory >>
#@nonl
#@+node:ekr.20031218072017.1361:<< Collect @first attributes >>
@ Stephen P. Schaefer 9/13/2002: Add support for @first.
Unlike other root attributes, does *NOT* inherit from parent nodes.
@c
tag = "@first"
sizeString = len(s) # DTHEIN 13-OCT-2002: use to detect end-of-string
i = 0
while 1:
    # DTHEIN 13-OCT-2002: directives must start at beginning of a line
    if not g.match_word(s,i,tag):
        i = g.skip_line(s,i)
    else:
        i = i + len(tag)
        j = i = g.skip_ws(s,i)
        i = g.skip_to_end_of_line(s,i)
        if i>j:
            self.first_lines += s[j:i] + '\n'
        i = g.skip_nl(s,i)
    if i >= sizeString:  # DTHEIN 13-OCT-2002: get out when end of string reached
        break

#@-node:ekr.20031218072017.1361:<< Collect @first attributes >>
#@+node:ekr.20031218072017.1362:<< Test for @comment and @language >>
if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):

    i = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[i:])
    if delim1 or delim2:
        self.single_comment_string = delim1
        self.start_comment_string = delim2
        self.end_comment_string = delim3
        # @comment effectively disables Untangle.
        self.language = "unknown"
    else:
        if issue_error_flag:
            g.es("ignoring: " + s[i:])

elif theDict.has_key("language"):

    i = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,i)
    self.language = language
    self.single_comment_string = delim1
    self.start_comment_string = delim2
    self.end_comment_string = delim3
    if 0:
        g.trace(self.single_comment_string,
            self.start_comment_string,
            self.end_comment_string)

    # 10/30/02: These ivars must be updated here!
    # g.trace(self.language)
    self.use_noweb_flag = True
    self.use_cweb_flag = False # Only raw cweb mode is ever used.
    self.raw_cweb_flag = self.language == "cweb" # A new ivar.
#@-node:ekr.20031218072017.1362:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1363:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@-node:ekr.20031218072017.1363:<< Test for @encoding >>
#@+node:ekr.20031218072017.1364:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.output_newline = lineending
#@-node:ekr.20031218072017.1364:<< Test for @lineending >>
#@+node:ekr.20031218072017.1365:<< Test for print modes directives >>
@ It is valid to have more than one of these directives in the same body text: the more verbose directive takes precedence.
@c

if not print_mode_changed:
    for name in ("verbose","terse","quiet","silent"):
        if theDict.has_key(name):
            self.print_mode = name
            print_mode_changed = True
            break
#@-node:ekr.20031218072017.1365:<< Test for print modes directives >>
#@+node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
if require_path_flag and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute dir and relative_path from s[k:] >>
    if len(theDir) > 0:
        base = g.getBaseDirectory(c=c) # May return "".
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir):
                << handle absolute @path >>
            elif issue_error_flag and not self.path_warning_given:
                self.path_warning_given = True # supress future warnings
                self.error("ignoring relative path in @path:" + theDir)
    elif issue_error_flag and not self.path_warning_given:
        self.path_warning_given = True # supress future warnings
        self.error("ignoring empty @path")
#@+node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

theDir = relative_path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    theDir = g.os_path_join(g.app.loadDir,theDir)

# g.trace("theDir: " + theDir)
#@nonl
#@-node:ekr.20031218072017.1367:<< compute dir and relative_path from s[k:] >>
#@+node:ekr.20031218072017.1368:<< handle absolute @path >>
if g.os_path_exists(theDir):
    self.tangle_directory = theDir
else: # 11/19/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        if issue_error_flag and not self.path_warning_given:
            self.path_warning_given = True # supress future warnings
            self.error("@path directory does not exist: " + theDir)
            if base and len(base) > 0:
                g.es("relative_path_base_directory: " + base)
            if relative_path and len(relative_path) > 0:
                g.es("relative path in @path directive: " + relative_path)
#@nonl
#@-node:ekr.20031218072017.1368:<< handle absolute @path >>
#@-node:ekr.20031218072017.1366:<< Test for @path >> in tangleScanAllDirectives
#@+node:ekr.20031218072017.1369:<< Test for @pagewidth >>
if not old.has_key("pagewidth") and theDict.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20031218072017.1369:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1370:<< Test for @root >>
@ 10/27/02: new code:  self.root may not be defined here, so any relative directory specified in the @root node will have no effect unless we have this code.

@c
if self.root_name == None and theDict.has_key("root"):

    i = theDict["root"]
    # i += len("@root")
    self.setRootFromText(s[i:],issue_error_flag)
#@nonl
#@-node:ekr.20031218072017.1370:<< Test for @root >>
#@+node:ekr.20031218072017.1371:<< Test for @tabwidth >>
if not old.has_key("tabwidth") and theDict.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag)
    if w and w != 0:
        self.tab_width = w
#@-node:ekr.20031218072017.1371:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
if old.has_key("header") or old.has_key("noheader"):
    pass # Do nothing more.
    
elif theDict.has_key("header") and theDict.has_key("noheader"):
    if issue_error_flag:
        g.es("conflicting @header and @noheader directives")

elif theDict.has_key("header"):
    self.use_header_flag = True

elif theDict.has_key("noheader"):
    self.use_header_flag = False
#@-node:ekr.20031218072017.1372:<< Test for @header and @noheader >>
#@+node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
@ This code sets self.tangle_directory if it has not already been set by an @path directive.

An absolute file name in an @root directive will override the directory set here.
A relative file name gets appended later to the default directory.
That is, the final file name will be g.os_path_join(self.tangle_directory,fileName)
@c

if c.frame and require_path_flag and not self.tangle_directory:
    if self.root_name and len(self.root_name) > 0:
        root_dir = g.os_path_dirname(self.root_name)
    else:
        root_dir = None
    # print "root_dir:", root_dir

    table = ( # This is a precedence table.
        (root_dir,"@root"), 
        (c.tangle_directory,"default tangle"), # Probably should be eliminated.
        (c.frame.openDirectory,"open"))

    base = g.getBaseDirectory(c=c) # May return ""

    for dir2, kind in table:
        if dir2 and len(dir2) > 0:
            # print "base,theDir:",base,theDir
            theDir = g.os_path_join(base,dir2)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                << handle absolute path >>

if not self.tangle_directory and require_path_flag: # issue_error_flag:
    self.pathError("No absolute directory specified by @root, @path or Preferences.")
#@+node:ekr.20031218072017.1374:<< handle absolute path >>
if g.os_path_exists(theDir):
    if kind == "@root" and not g.os_path_isabs(root_dir):
        self.tangle_directory = base
    else:
        self.tangle_directory = theDir 
    break
else: # 9/25/02
    self.tangle_directory = g.makeAllNonExistentDirectories(theDir)
    if not self.tangle_directory:
        # 10/27/02: It is an error for this not to exist now.
        self.error("@root directory does not exist:" + theDir)
        if base and len(base) > 0:
            g.es("relative_path_base_directory: " + base)
        if dir2 and len(dir2) > 0:
            g.es(kind + " directory: " + dir2)
#@-node:ekr.20031218072017.1374:<< handle absolute path >>
#@-node:ekr.20031218072017.1373:<< Set self.tangle_directory >>
#@-node:ekr.20031218072017.1360:tangle.scanAllDirectives
#@+node:ekr.20031218072017.1375:scanForTabWidth
# Similar to code in scanAllDirectives.

def scanForTabWidth (self,p):

    c = self.c ; w = c.tab_width

    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << set w and break on @tabwidth >>

    c.frame.setTabWidth(w)
#@nonl
#@+node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
if theDict.has_key("tabwidth"):
    
    val = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=False)
    if val and val != 0:
        w = val
        break
#@nonl
#@-node:ekr.20031218072017.1376:<< set w and break on @tabwidth >>
#@-node:ekr.20031218072017.1375:scanForTabWidth
#@+node:ekr.20031218072017.1377:scanColorDirectives
def scanColorDirectives(self,p):
    
    """Scan position p and p's ancestors looking for @comment, @language and @root directives,
    setting corresponding colorizer ivars.
    """

    p = p.copy() ; c = self.c
    if c == None: return # self.c may be None for testing.

    if c.target_language:
        c.target_language = c.target_language.lower()
    self.language = language = c.target_language
    self.comment_string = None
    self.rootMode = None # None, "code" or "doc"
    
    for p in p.self_and_parents_iter():
        # g.trace(p)
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment or @language >>
        << Test for @root, @root-doc or @root-code >>

    return self.language # For use by external routines.
#@nonl
#@+node:ekr.20031218072017.1378:<< Test for @comment or @language >>
# 10/17/02: @comment and @language may coexist in the same node.

if theDict.has_key("comment"):
    k = theDict["comment"]
    self.comment_string = s[k:]

if theDict.has_key("language"):
    i = theDict["language"]
    language,junk,junk,junk = g.set_language(s,i)
    self.language = language

if theDict.has_key("comment") or theDict.has_key("language"):
    break
#@nonl
#@-node:ekr.20031218072017.1378:<< Test for @comment or @language >>
#@+node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
if theDict.has_key("root") and not self.rootMode:

    k = theDict["root"]
    if g.match_word(s,k,"@root-code"):
        self.rootMode = "code"
    elif g.match_word(s,k,"@root-doc"):
        self.rootMode = "doc"
    else:
        doc = c.config.at_root_bodies_start_in_doc_mode
        self.rootMode = g.choose(doc,"doc","code")
#@-node:ekr.20031218072017.1379:<< Test for @root, @root-doc or @root-code >>
#@-node:ekr.20031218072017.1377:scanColorDirectives
#@+node:ekr.20031218072017.1380:Directive utils...
#@+node:EKR.20040504150046.4:g.comment_delims_from_extension
def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    >>> g.comment_delims_from_extension(".py")
    ('#', None, None)

    >>> g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    >>> g.comment_delims_from_extension(".html")
    (None, '<!--', '-->')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None
#@nonl
#@-node:EKR.20040504150046.4:g.comment_delims_from_extension
#@+node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1382:set_delims_from_language
# Returns a tuple (single,start,end) of comment delims

def set_delims_from_language(language):

    val = app.language_delims_dict.get(language)
    if val:
        delim1,delim2,delim3 = g.set_delims_from_string(val)
        if delim2 and not delim3:
            return None,delim1,delim2
        else: # 0,1 or 3 params.
            return delim1,delim2,delim3
    else:
        return None, None, None # Indicate that no change should be made
#@-node:ekr.20031218072017.1382:set_delims_from_language
#@+node:ekr.20031218072017.1383:set_delims_from_string
def set_delims_from_string(s):

    """Returns (delim1, delim2, delim2), the delims following the @comment directive.
    
    This code can be called from @language logic, in which case s can point at @comment"""

    # Skip an optional @comment
    tag = "@comment"
    i = 0
    if g.match_word(s,i,tag):
        i += len(tag)
        
    count = 0 ; delims = [None, None, None]
    while count < 3 and i < len(s):
        i = j = g.skip_ws(s,i)
        while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        if j == i: break
        delims[count] = s[j:i]
        count += 1
        
    # 'rr 09/25/02
    if count == 2: # delims[0] is always the single-line delim.
        delims[2] = delims[1]
        delims[1] = delims[0]
        delims[0] = None

    # 7/8/02: The "REM hack": replace underscores by blanks.
    # 9/25/02: The "perlpod hack": replace double underscores by newlines.
    for i in xrange(0,3):
        if delims[i]:
            delims[i] = string.replace(delims[i],"__",'\n') 
            delims[i] = string.replace(delims[i],'_',' ')

    return delims[0], delims[1], delims[2]
#@nonl
#@-node:ekr.20031218072017.1383:set_delims_from_string
#@+node:ekr.20031218072017.1384:set_language
def set_language(s,i,issue_errors_flag=False):
    
    """Scan the @language directive that appears at s[i:].

    Returns (language, delim1, delim2, delim3)
    """

    tag = "@language"
    # g.trace(g.get_line(s,i))
    assert(i != None)
    assert(g.match_word(s,i,tag))
    i += len(tag) ; i = g.skip_ws(s, i)
    # Get the argument.
    j = i ; i = g.skip_c_id(s,i)
    # Allow tcl/tk.
    arg = string.lower(s[j:i])
    if app.language_delims_dict.get(arg):
        language = arg
        delim1, delim2, delim3 = g.set_delims_from_language(language)
        return language, delim1, delim2, delim3
    
    if issue_errors_flag:
        g.es("ignoring: " + g.get_line(s,i))

    return None, None, None, None,
#@nonl
#@-node:ekr.20031218072017.1384:set_language
#@-node:ekr.20031218072017.1381:@language and @comment directives (leoUtils)
#@+node:ekr.20031218072017.1385:findReference
@ We search the descendents of v looking for the definition node matching name.
There should be exactly one such node (descendents of other definition nodes are not searched).
@c

def findReference(name,root):

    for p in root.subtree_iter():
        assert(p!=root)
        if p.matchHeadline(name) and not p.isAtIgnoreNode():
            return p

    # g.trace("not found:",name,root)
    return root.c.nullPosition()
#@nonl
#@-node:ekr.20031218072017.1385:findReference
#@+node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
# The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    theDict = {}
    i = 0 ; n = len(s)
    while i < n:
        if s[i] == '@' and i+1 < n:
            << set theDict for @ directives >>
        elif root and g.match(s,i,"<<"):
            << set theDict["root"] for noweb * chunks >>
        i = g.skip_line(s,i)
    return theDict
#@nonl
#@+node:ekr.20031218072017.1261:<< set theDict for @ directives >>
j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if theDict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        theDict [word] = i
#@nonl
#@-node:ekr.20031218072017.1261:<< set theDict for @ directives >>
#@+node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
@ The following looks for chunk definitions of the form < < * > > =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i < n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,">>="):
        # < < * > > = implies that @root should appear in the headline.
        i += 3
        if root_node:
            theDict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")
#@nonl
#@-node:ekr.20031218072017.1262:<< set theDict["root"] for noweb * chunks >>
#@-node:ekr.20031218072017.1260:get_directives_dict & globalDirectiveList
#@+node:ekr.20031218072017.1386:getOutputNewline
def getOutputNewline (c=None,name=None):
    
    '''Convert the name of a line ending to the line ending itself.
    
    Priority:
    - Use name if name given
    - Use c.config.output_newline if c given,
    - Otherwise use g.app.config.output_newline.'''
    
    # g.trace(c,name,c.config.output_newline)
    if name: s = name
    elif c:  s = c.config.output_newline
    else:    s = app.config.output_newline

    if not s: s = ''
    s = s.lower()
    if s in ( "nl","lf"): s = '\n'
    elif s == "cr": s = '\r'
    elif s == "platform": s = os.linesep  # 12/2/03: emakital
    elif s == "crlf": s = "\r\n"
    else: s = '\n' # Default for erroneous values.
    return s
#@nonl
#@-node:ekr.20031218072017.1386:getOutputNewline
#@+node:ekr.20031218072017.1387:scanAtEncodingDirective
def scanAtEncodingDirective(s,theDict):
    
    """Scan the @encoding directive at s[theDict["encoding"]:].

    Returns the encoding name or None if the encoding name is invalid.
    """

    k = theDict["encoding"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@encoding")
    encoding = s[k+j:i].strip()
    if g.isValidEncoding(encoding):
        # g.trace(encoding)
        return encoding
    else:
        g.es("invalid @encoding:"+encoding,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1387:scanAtEncodingDirective
#@+node:ekr.20031218072017.1388:scanAtLineendingDirective
def scanAtLineendingDirective(s,theDict):
    
    """Scan the @lineending directive at s[theDict["lineending"]:].

    Returns the actual lineending or None if the name of the lineending is invalid.
    """

    k = theDict["lineending"]
    i = g.skip_to_end_of_line(s,k)
    j = len("@lineending")
    j = g.skip_ws(s,j)
    e = s[k+j:i].strip()

    if e in ("cr","crlf","lf","nl","platform"):
        lineending = g.getOutputNewline(name=e)
        # g.trace(e,lineending)
        return lineending
    else:
        # g.es("invalid @lineending directive:"+e,color="red")
        return None
#@nonl
#@-node:ekr.20031218072017.1388:scanAtLineendingDirective
#@+node:ekr.20031218072017.1389:scanAtPagewidthDirective
def scanAtPagewidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @pagewidth directive at s[theDict["pagewidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["pagewidth"]
    j = i = k + len("@pagewidth")
    i, val = g.skip_long(s,i)
    if val != None and val > 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            j = g.skip_to_end_of_line(s,k)
            g.es("ignoring " + s[k:j],color="red")
        return None
#@-node:ekr.20031218072017.1389:scanAtPagewidthDirective
#@+node:ekr.20031218072017.1390:scanAtTabwidthDirective
def scanAtTabwidthDirective(s,theDict,issue_error_flag=False):
    
    """Scan the @tabwidth directive at s[theDict["tabwidth"]:].

    Returns the value of the width or None if the width is invalid.
    """
    
    k = theDict["tabwidth"]
    i = k + len("@tabwidth")
    i, val = g.skip_long(s, i)
    if val != None and val != 0:
        # g.trace(val)
        return val
    else:
        if issue_error_flag:
            i = g.skip_to_end_of_line(s,k)
            g.es("Ignoring " + s[k:i],color="red")
        return None

#@-node:ekr.20031218072017.1390:scanAtTabwidthDirective
#@+node:ekr.20040715155607:scanForAtIgnore
def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False
#@nonl
#@-node:ekr.20040715155607:scanForAtIgnore
#@+node:ekr.20041123094807:g.scanForAtSettings
def scanForAtSettings(p):
    
    """Scan position p and its ancestors looking for @settings nodes."""
    
    for p in p.self_and_parents_iter():
        h = p.headString()
        h = g.app.config.canonicalizeSettingName(h)
        if h.startswith("@settings"):
            return True

    return False
#@nonl
#@-node:ekr.20041123094807:g.scanForAtSettings
#@+node:ekr.20040712084911.1:scanForAtLanguage
def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    
    # Unlike the code in x.scanAllDirectives, this code ignores @comment directives.

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language
#@nonl
#@-node:ekr.20040712084911.1:scanForAtLanguage
#@+node:ekr.20031218072017.1391:scanDirectives (utils)
@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    << Set local vars >>
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @comment and @language >>
        << Test for @encoding >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @path >>
        << Test for @tabwidth >>
        << Test for @wrap and @nowrap >>
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }
#@nonl
#@+node:ekr.20031218072017.1392:<< Set local vars >>
page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")
#@nonl
#@-node:ekr.20031218072017.1392:<< Set local vars >>
#@+node:ekr.20031218072017.1393:<< Test for @comment and @language >>
# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20031218072017.1393:<< Test for @comment and @language >>
#@+node:ekr.20031218072017.1394:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
#@-node:ekr.20031218072017.1394:<< Test for @encoding >>
#@+node:ekr.20031218072017.1395:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
#@-node:ekr.20031218072017.1395:<< Test for @lineending >>
#@+node:ekr.20031218072017.1396:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w > 0:
        page_width = w
#@nonl
#@-node:ekr.20031218072017.1396:<< Test for @pagewidth >>
#@+node:ekr.20031218072017.1397:<< Test for @path >>
if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        
#@nonl
#@+node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)
#@nonl
#@-node:ekr.20031218072017.1398:<< compute relative path from s[k:] >>
#@-node:ekr.20031218072017.1397:<< Test for @path >>
#@+node:ekr.20031218072017.1399:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w
#@nonl
#@-node:ekr.20031218072017.1399:<< Test for @tabwidth >>
#@+node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False
#@nonl
#@-node:ekr.20031218072017.1400:<< Test for @wrap and @nowrap >>
#@-node:ekr.20031218072017.1391:scanDirectives (utils)
#@-node:ekr.20031218072017.1380:Directive utils...
#@+node:ekr.20031218072017.1401:Tests
@ignore
@lineending nl
@encoding iso-8859-1
@pagewidth 80
@tabwidth -8
#@nonl
#@+node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@+node:ekr.20031218072017.1403:node 1
node 1 line 1
node 1 line 2
node 1 line 3 (newline)
#@-node:ekr.20031218072017.1403:node 1
#@+node:ekr.20031218072017.1404:node 2
node 2 line 1
node 2 line 2
node 2 line 3 (no newline)
#@nonl
#@-node:ekr.20031218072017.1404:node 2
#@-node:ekr.20031218072017.1402:@rawfile c:\prog\test\rawFileTest.txt
#@+node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
line 1
line 2
last line (no newline)
#@nonl
#@-node:ekr.20031218072017.1405:@silentfile c:\prog\test\silentFileTest.txt
#@+node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
@root c:\prog\test\tangleTest.txt

line 1 Ã
line 2
<< ref >>
line 3
#@nonl
#@+node:ekr.20031218072017.1407:ref
<< ref >>=
ref line 1
ref line 2
#@nonl
#@-node:ekr.20031218072017.1407:ref
#@-node:ekr.20031218072017.1406:@root c:\prog\test\tangleTest.txt
#@-node:ekr.20031218072017.1401:Tests
#@-node:ekr.20031218072017.1341:(scanAllDirectives, scanDirectives, related utils)
#@+node:ekr.20050524073547.1:4.3.1 projects
#@+node:ekr.20050524102538:Bug fixes...
#@+node:ekr.20050524092311:(Fixed ratio bugs)
#@+node:ekr.20050524092311.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3166883
By: rogererens

I swear I didn't wait for the release to be the first to report a bug! I just
didn't try this in the alfa/beta versions:

Leo 4.3 final, build  1.262 , May 23, 2005
Python 2.4.1, Tk 8.4.7, win32

Changing
Global settings: C:\Leo\config\leoSettings.leo-->Window options-->@page Options
for new windows-->@ratio initial_horizontal_ratio = 0.3
or any of the other ratios, does not save them to leoSettings.leo. So after
restarting I still have the old settings in use.
#@nonl
#@-node:ekr.20050524092311.1:Report
#@+node:ekr.20041225063637.43:createRatio
def createRatio (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def ratioCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            val2 = float(val2)
            if 0.0 <= val2 <= 1.0:
                return val2
        except TypeError:
            pass
        g.trace("bad val:",val2)
        return val
            
    self.initValue(p,name,kind,val,ratioCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.43:createRatio
#@-node:ekr.20050524092311:(Fixed ratio bugs)
#@+node:ekr.20050524095049:(Fixed crasher footprint plugin)
@ The fix was to add the following line to the init function:

    global click_registry, coloured_nodes
#@nonl
#@+node:ekr.20050524095049.1:Report
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3167166
By: porter235

with footprints enabled, attempting to open a document causes the following
error

exceptions opening: D:\Program Files\leo-4.3-final\Leo\doc\LeoDocs.leo
Traceback (most recent call last):
  File "D:\Program Files\leo-4.3-final\Leo\src\leoGlobals.py", line 771, in
openWithFileName
    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
  File "D:\Program Files\leo-4.3-final\Leo\src\leoFileCommands.py", line 1325,
in open
    ok, ratio =
self.getLeoFile(fileName,readAtFileNodesFlag=readAtFileNodesFlag,silent=silent)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoFileCommands.py", line 649,
in getLeoFile
    c.frame.tree.redraw_now(scroll=False)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1277,
in redraw_now
    self.idle_redraw(scroll=scroll)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1317,
in idle_redraw
    self.drawTopTree()
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1174,
in drawTopTree
    self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1201,
in drawTree
    h,indent = self.drawNode(const_p,x,y)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 916,
in drawNode
    return self.force_draw_node(p,x,y)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 945,
in force_draw_node
    h2 = self.drawText(p,x,y)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1021,
in drawText
    self.configureTextState(p)
  File "D:\Program Files\leo-4.3-final\Leo\src\leoTkinterTree.py", line 1738,
in configureTextState
    self.setUnselectedLabelState(p) # unselected
  File "D:\Program Files\leo-4.3-final\Leo\plugins\footprints.py", line 138,
in doFootprint
    if click_registry.get(p.v, 0) >= HITS_TO_HOT:
NameError: global name 'click_registry' is not defined
#@-node:ekr.20050524095049.1:Report
#@-node:ekr.20050524095049:(Fixed crasher footprint plugin)
#@+node:ekr.20050523071432:(Worked around invalid position bug)
#@+node:ekr.20050523085407:Report
@killcolor

While doing final testing I discovered a long-standing bug that is potentially serious but that has lain dormant for a year or more.  I'm not going to delay 4.3 while I (try) to fix this bug because any potential fix would create the potential for even more serious bugs.  So I'll start work on the bug right after releasing 4.3 final, and I'll release 4.3.1 b1 about a week later.

The bug is this:  modifying outlines can invalidate existing positions!  This rarely happens.  At present it affects the atFile.read logic when reading an outline whose initial current position is a clone outside an @thin tree with another clone inside the @thin tree.  So the read logic computes the expected current position before reading all derived files, and this expected current position becomes invalid.  This bug itself is minor: Leo doesn't highlight the initial node correctly in this case and nothing else bad happens.

However, this bug is probably also behind a recent hang in the unit tests.  What happens is that inserting and deleting nodes also can invalidate existing positions, and in general this can have bad results.  N.B. Typical scripts will never encounter the bug because the vast majority of scripts a) do not attempt to modify the outline and b) don't have state that must be saved as the outline changes.  However, unit tests do both.

The reason I'm not going even to attempt to fix the bug is that doing so will require a change deep in the heart of the position class.  I don't remember all the details of the implementation, so at the minimum I'll have to document the code much better than at present.  Iirc the code and data structures are something of a hack.  Rather than hacking the hack I'll see if maybe I can simplify matters, but this is potentially very dangerous.  Thus, I would rather live with a mostly dormant bug in 4.3 final than attempting a change that could ruin a release or two.
#@nonl
#@-node:ekr.20050523085407:Report
#@+node:ekr.20050525065038:What I did
@killcolor

1.  Moved << set current and top positions >> from getVnodes to end of getLeoFile.
This ensures that the outline won't change after computing the position.

2. Unit tests will have to be revised to make sure that only valid positions get used.
#@nonl
#@-node:ekr.20050525065038:What I did
#@+node:ekr.20031218072017.890:<< about the position class >>
@killcolor

@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible and p.hasThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.
#@nonl
#@-node:ekr.20031218072017.890:<< about the position class >>
#@+node:ekr.20050524082843:<< positions may become invalid when outlines change >>
@killcolor

@ If a vnode has only one parent, v._parent is that parent. Otherwise,
v.t.vnodeList is the list of vnodes v2 such that v2._firstChild == v. Alas, this
means that positions can become invalid when vnodeList's change!

There is no use trying to solve the problem in p.moveToParent or
p.vParentWithStack: the invalidated positions simply don't have the stack
entries needed to compute parent fields properly. In short, changing t.vnodeList
may invalidate existing positions!
#@nonl
#@-node:ekr.20050524082843:<< positions may become invalid when outlines change >>
#@+node:ekr.20031218072017.2983:c.currentPosition & c.setCurrentPosition
#@+node:ekr.20040803140033:currentPosition
def currentPosition (self,copy=True):
    
    """Return the presently selected position."""
    
    c = self
    
    if c._currentPosition:
        if copy:
            return c._currentPosition.copy() # Must make a second copy now.
        else:
            # The caller MUST copy the position if it is passed to any other method.
            # At present no core method uses copy = False.
            g.trace("copy=False")
            return c._currentPosition
    else:
        return c.nullPosition()
    
# For compatibiility with old scripts.
currentVnode = currentPosition
#@nonl
#@-node:ekr.20040803140033:currentPosition
#@+node:ekr.20040803140033.1:setCurrentPosition
def setCurrentPosition (self,p):
    
    """Set the presently selected position."""
    
    c = self
    
    if p:
        if p.equal(c._currentPosition):
            pass # We have already made a copy.
        else: # Must make a copy _now_
            c._currentPosition = p.copy()
        # g.trace('exists',p.exists(c),'returns',p)
        # if not p.exists(c):
            # g.printStack()
    else:
        c._currentPosition = None
    
# For compatibiility with old scripts.
setCurrentVnode = setCurrentPosition
#@nonl
#@-node:ekr.20040803140033.1:setCurrentPosition
#@-node:ekr.20031218072017.2983:c.currentPosition & c.setCurrentPosition
#@+node:ekr.20050524095253:undo...
#@+node:ekr.20050412084532:redoInsertNode
def redoInsertNode (self):

    u = self ; c = u.c
    
    # g.trace('p',u.newP.v,'parent',u.newParent.v)

    if u.newBack:
        u.newP.linkAfter(u.newBack)
    elif u.newParent:
        u.newP.linkAsNthChild(u.newParent,0)
    else:
        oldRoot = c.rootPosition()
        u.newP.linkAsRoot(oldRoot)

    # assert(u.newP.exists(c))
        
    # Restore all vnodeLists (and thus all clone marks).
    u.newP.restoreLinksInTree()
    
    if u.pasteAsClone:
        for bunch in u.afterTree:
            t = bunch.t
            if u.newP.v.t == t:
                u.newP.setBodyStringOrPane(bunch.body)
                u.newP.setHeadString(bunch.head)
            else:
                t.setTnodeText(bunch.body)
                t.setHeadString(bunch.head)
            # g.trace(t,bunch.head,bunch.body)

    c.selectPosition(u.newP)
#@nonl
#@-node:ekr.20050412084532:redoInsertNode
#@-node:ekr.20050524095253:undo...
#@+node:ekr.20050524074930.5:drawing...
#@+node:ekr.20040803072955.59:idle_redraw
def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    << return if disabled, or quitting or dragging >>

    # g.print_bindings("canvas",self.canvas)

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        # Do a scrolling operation after the scrollbar is redrawn
        if scroll:
            self.canvas.after_idle(self.idle_scrollTo)
        if 0:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor
#@nonl
#@+node:ekr.20040803072955.60:<< return if disabled, or quitting or dragging >>
# g.trace('disableRedraw',self.disableRedraw)

if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return
#@nonl
#@-node:ekr.20040803072955.60:<< return if disabled, or quitting or dragging >>
#@-node:ekr.20040803072955.59:idle_redraw
#@+node:ekr.20040803072955.69:scrollTo
def scrollTo (self,p):
    
    def scrollToCallback(event=None,self=self,p=p):
        __pychecker__ = '--no-argsused' # event not used.

        self.idle_scrollTo(p)
    
    self.canvas.after_idle(scrollToCallback)
#@nonl
#@-node:ekr.20040803072955.69:scrollTo
#@+node:ekr.20040803072955.65:idle_scrollTo
def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        << compute approximate line height >>
        << Compute the fractions to scroll down/up >>
        if frac <= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) >= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
#@nonl
#@+node:ekr.20040803072955.66:<< compute approximate line height >>
if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.
#@nonl
#@-node:ekr.20040803072955.66:<< compute approximate line height >>
#@+node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 > 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)
#@nonl
#@-node:ekr.20040803072955.67:<< Compute the fractions to scroll down/up >>
#@-node:ekr.20040803072955.65:idle_scrollTo
#@+node:ekr.20031218072017.1708:extractSection
def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@-node:ekr.20050524074930.5:drawing...
#@+node:ekr.20050524074930.7:position methods...
#@+node:ekr.20040228060340:p.vParentWithStack
# A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

<< about the vParentWithStack utility method >>

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n >= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n
#@nonl
#@+node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

#@-node:ekr.20040228060340.1:<< about the vParentWithStack utility method >>
#@-node:ekr.20040228060340:p.vParentWithStack
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20040227214711:p.level & simpleLevel
def simpleLevel(self):
    
    return len([p for p in self.parents_iter()])

def level(self,verbose=False):
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==self.simpleLevel())
            break
    return level
#@nonl
#@-node:ekr.20040227214711:p.level & simpleLevel
#@+node:ekr.20040307104131.3:p.exists
def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()

    # This code must be fast.
    root = c.rootPosition()

    while p:
        # g.trace(p,'parent',p.parent(),'back',p.back())
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False
#@nonl
#@-node:ekr.20040307104131.3:p.exists
#@-node:ekr.20050524074930.7:position methods...
#@+node:ekr.20050524074930.6:read logic...
#@+node:ekr.20031218072017.1553:getLeoFile
# The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,readAtFileNodesFlag=True,silent=False):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    << warn on read-only files >>
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        << scan all the xml elements >>
    except BadLeoFile, message:
        if not silent:
            << raise an alert >>
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    # g.trace(readAtFileNodesFlag,c.mFileName)

    if ok and readAtFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)
        
    # g.trace(c.currentPosition())
    
    # New in 4.3.1: do this after reading derived files.
    if not self.usingClipboard:
        << set current and top positions >>

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    << restore attributes in descendent tnodes >>
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio
#@nonl
#@+node:ekr.20031218072017.1554:<< warn on read-only files >>
# os.access may not exist on all platforms.

try:
    self.read_only = not os.access(fileName,os.W_OK)
except AttributeError:
    self.read_only = False
except UnicodeError:
    self.read_only = False
        
if self.read_only:
    g.es("read only: " + fileName,color="red")
#@nonl
#@-node:ekr.20031218072017.1554:<< warn on read-only files >>
#@+node:ekr.20031218072017.1555:<< scan all the xml elements >>
self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("<leo_file>") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio)
if not silent:
    g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("</leo_file>")
#@nonl
#@-node:ekr.20031218072017.1555:<< scan all the xml elements >>
#@+node:ekr.20031218072017.1556:<< raise an alert >>
# All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))
#@nonl
#@-node:ekr.20031218072017.1556:<< raise an alert >>
#@+node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    # else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
#@nonl
#@-node:EKR.20040627120120:<< restore attributes in descendent tnodes >>
#@+node:ekr.20040326054052:<< set current and top positions >>
current = self.convertStackToPosition(self.currentVnodeStack)
if current:
    # g.trace('using convertStackToPosition',current)
    c.setCurrentPosition(current)
else:
    # g.trace(self.currentVnodeStack)
    c.setCurrentPosition(c.rootPosition())
    
# At present this is useless: the drawing code doesn't set the top position properly.
if 0:
    top = self.convertStackToPosition(self.topVnodeStack)
    if top:
        c.setTopPosition(top)
#@nonl
#@-node:ekr.20040326054052:<< set current and top positions >>
#@-node:ekr.20031218072017.1553:getLeoFile
#@+node:ekr.20031218072017.1565:getVnodes
def getVnodes (self,reassignIndices=True):

    c = self.c

    if self.getOpenTag("<vnodes>"):
        return # <vnodes/> seen.
        
    self.forbiddenTnodes = []
    back = parent = None # This routine _must_ work on vnodes!
    self.currentVnodeStack = []
    self.topVnodeStack = []
        
    if self.usingClipboard:
        oldRoot = c.rootPosition()
        oldCurrent = c.currentPosition()
        if not reassignIndices:
            << set self.forbiddenTnodes to tnodes than must not be pasted >>

    while self.matchTag("<v"):
        append1 = not self.usingClipboard and len(self.currentVnodeStack) == 0
        append2 = not self.usingClipboard and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip=False,
            appendToCurrentStack=append1,appendToTopStack=append2)

    if self.usingClipboard:
        # Link in the pasted nodes after the current position.
        newRoot = c.rootPosition()
        c.setRootPosition(oldRoot)
        newRoot.v.linkAfter(oldCurrent.v)
        newCurrent = oldCurrent.copy()
        newCurrent.v = newRoot.v
        c.setCurrentPosition(newCurrent)

    self.getTag("</vnodes>")
#@nonl
#@+node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
self.forbiddenTnodes = []

for p in oldCurrent.self_and_parents_iter():
    if p.v.t not in self.forbiddenTnodes:
        self.forbiddenTnodes.append(p.v.t)
        
# g.trace("forbiddenTnodes",self.forbiddenTnodes)
#@nonl
#@-node:ekr.20041023105832:<< set self.forbiddenTnodes to tnodes than must not be pasted >>
#@-node:ekr.20031218072017.1565:getVnodes
#@+node:ekr.20040326052245:convertStackToPosition
def convertStackToPosition (self,stack):

    c = self.c ; p2 = None
    if not stack: return None

    for p in c.allNodes_iter():
        if p.v == stack[0]:
            p2 = p.copy()
            for n in xrange(len(stack)):
                if not p2: break
                # g.trace("compare",n,p2.v,stack[n])
                if p2.v != stack[n]:
                    p2 = None
                elif n + 1 == len(stack):
                    break
                else:
                    p2.moveToParent()
            if p2:
                # g.trace('exists',p.exists(c),p)
                return p

    return None
#@nonl
#@-node:ekr.20040326052245:convertStackToPosition
#@+node:ekr.20041005105605.21:read
# The caller must enclose this code in beginUpdate/endUpdate.

def read(self,root,importFileName=None,thinFile=False,fromString=None):
    
    """Read any derived file."""

    at = self ; c = at.c
    if 0:
        p = c.currentPosition()
        g.trace('1',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    << set fileName >>
    at.initReadIvars(root,fileName,importFileName=importFileName,thinFile=thinFile)
    if at.errors: return False
    at.openFileForReading(fileName,fromString=fromString)
    if not at.inputFile: return False
    g.es("reading: " + root.headString())
    root.clearVisitedInTree()
    at.scanAllDirectives(root,importing=at.importing,reading=True)
    at.readOpenFile(root,at.inputFile,fileName)
    if 0:
        p = c.currentPosition()
        g.trace('2',p,p.v._parent,p.v._parent and p.v._parent.t.vnodeList)
    at.inputFile.close()
    root.clearDirty() # May be set dirty below.
    if not at.thinFile:
        << warn about non-empty unvisited nodes >>
    if at.errors == 0 and not at.importing:
        if 1: # Package this as a method for use by mod_labels plugin.
            self.copyAllTempBodyStringsToTnodes(root,thinFile)
        else:
            << copy all tempBodyStrings to tnodes >>
    << delete all tempBodyStrings >>
    return at.errors == 0
#@nonl
#@+node:ekr.20041005105605.22:<< set fileName >>
if fromString:
    fileName = "<string-file>"
elif importFileName:
    fileName = importFileName
elif root.isAnyAtFileNode():
    fileName = root.anyAtFileNodeName()
else:
    fileName = None

if not fileName:
    at.error("Missing file name.  Restoring @file tree from .leo file.")
    return False
#@nonl
#@-node:ekr.20041005105605.22:<< set fileName >>
#@+node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
for p in root.self_and_subtree_iter():

    # g.trace(p)
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s and not p.v.t.isVisited():
        at.error("Not in derived file: %s" % p.headString())
        p.v.t.setVisited() # One message is enough.
#@nonl
#@-node:ekr.20041005105605.23:<< warn about non-empty unvisited nodes >>
#@+node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
for p in root.self_and_subtree_iter():
    try: s = p.v.t.tempBodyString
    except: s = ""
    if s != p.bodyString():
        if 0: # For debugging.
            print ; print "changed: " + p.headString()
            print ; print "new:",s
            print ; print "old:",p.bodyString()
        if thinFile:
            p.v.setTnodeText(s)
            if p.v.isDirty():
                p.setAllAncestorAtFileNodesDirty()
        else:
            p.setBodyStringOrPane(s) # Sets v and v.c dirty.
            
        if not thinFile or (thinFile and p.v.isDirty()):
            g.es("changed: " + p.headString(),color="blue")
            p.setMarked()
#@nonl
#@-node:ekr.20041005105605.24:<< copy all tempBodyStrings to tnodes >>
#@+node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"tempBodyString"):
        delattr(p.v.t,"tempBodyString")
#@nonl
#@-node:ekr.20041005105605.25:<< delete all tempBodyStrings >>
#@-node:ekr.20041005105605.21:read
#@-node:ekr.20050524074930.6:read logic...
#@-node:ekr.20050523071432:(Worked around invalid position bug)
#@+node:ekr.20050525074210:(Fixed undo problems in unit tests)
#@+node:ekr.20050525162830:What I did, and why
@killcolor

- Fixed bugs in convertAllBlanks and convertAllTabs.

These must always call afterChangeGroup to match beforeChangeGroup, even if
nothing has changed.

- Added u.getMark and u.rollbackToMark.

These allow unit tests to cut the undo stack back to an initial position in the
tearDown method. This should be done for all tests that use u.undo and u.redo
methods. The bug was probably the result of changing the outline in the tearDown
method.

Both the Reformat Paragraph and Edit Body unit tests now roll back the undo stack.

- Added traces for unexpected conditions in u.undo, u.redo and tree.select.

- Call u.setUndoTypes() in u.setUndoTypingParams when returning early.

- Corrected Edit Body unit tests.

These tests should not call undo/redo when nothing is expected to change. Doing
so may trigger the new 'cant undo' traces in u.undo.

- doTest in leoTest.py now makes copies of both p and p1.

It's not clear that this is needed, it can't hurt, and it may have been important.
#@nonl
#@-node:ekr.20050525162830:What I did, and why
#@+node:ekr.20050525163715:undo...
#@+node:ekr.20050525151217:getMark & rollbackToMark
def getMark (self):
    
    return self.bead
    
def rollbackToMark (self,n):
    
    u = self

    u.bead = n
    u.beads = u.beads[:n+1]
    u.setUndoTypes()
    
rollBackToMark = rollbackToMark
#@nonl
#@-node:ekr.20050525151217:getMark & rollbackToMark
#@+node:ekr.20031218072017.3616:setUndoTypes
def setUndoTypes (self):
    
    u = self

    # Set the undo type and undo menu label.
    bunch = u.peekBead(u.bead)
    if bunch:
        # g.trace(u.bead,len(u.beads),bunch.undoType)
        u.setUndoType(bunch.undoType)
    else:
        # g.trace(u.bead,len(u.beads))
        u.setUndoType("Can't Undo")

    # Set only the redo menu label.
    bunch = u.peekBead(u.bead+1)
    if bunch:
        u.setRedoType(bunch.undoType)
    else:
        u.setRedoType("Can't Redo")
#@nonl
#@-node:ekr.20031218072017.3616:setUndoTypes
#@+node:ekr.20031218072017.1490:setUndoTypingParams
@ This routine saves enough information so a typing operation can be undone and redone.

We do nothing when called from the undo/redo logic because the Undo and Redo commands merely reset the bead pointer.
@c

def setUndoTypingParams (self,p,undo_type,oldText,newText,oldSel,newSel,oldYview=None):
    
    __pychecker__ = 'maxlines=2000' # Ignore the size of this method.
    
    u = self ; c = u.c
    << return if there is nothing to do >>
    # g.trace(undo_type)
    << init the undo params >>
    << compute leading, middle & trailing  lines >>
    << save undo text info >>
    << save the selection and scrolling position >>
    << adjust the undo stack, clearing all forward entries >>
    u.setUndoTypes() # Recalculate the menu labels.
    return bunch
#@nonl
#@+node:ekr.20040324061854:<< return if there is nothing to do >>
if u.redoing or u.undoing:
    return None

if undo_type == None:
    return None

if undo_type == "Can't Undo":
    u.clearUndoState()
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None

if oldText == newText:
    # g.trace("no change")
    u.setUndoTypes() # Must still recalculate the menu labels.
    return None
#@nonl
#@-node:ekr.20040324061854:<< return if there is nothing to do >>
#@+node:ekr.20040324061854.1:<< init the undo params >>
# Clear all optional params.
for ivar in u.optionalIvars:
    setattr(u,ivar,None)

# Set the params.
u.undoType = undo_type
u.p = p.copy()
#@nonl
#@-node:ekr.20040324061854.1:<< init the undo params >>
#@+node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
@ Incremental undo typing is similar to incremental syntax coloring.  We compute the number of leading and trailing lines that match, and save both the old and new middle lines.

NB: the number of old and new middle lines may be different.
@c

old_lines = string.split(oldText,'\n')
new_lines = string.split(newText,'\n')
new_len = len(new_lines)
old_len = len(old_lines)
min_len = min(old_len,new_len)

i = 0
while i < min_len:
    if old_lines[i] != new_lines[i]:
        break
    i += 1
leading = i

if leading == new_len:
    # This happens when we remove lines from the end.
    # The new text is simply the leading lines from the old text.
    trailing = 0
else:
    i = 0
    while i < min_len - leading:
        if old_lines[old_len-i-1] != new_lines[new_len-i-1]:
            break
        i += 1
    trailing = i
    
# NB: the number of old and new middle lines may be different.
if trailing == 0:
    old_middle_lines = old_lines[leading:]
    new_middle_lines = new_lines[leading:]
else:
    old_middle_lines = old_lines[leading:-trailing]
    new_middle_lines = new_lines[leading:-trailing]

# Remember how many trailing newlines in the old and new text.
i = len(oldText) - 1 ; old_newlines = 0
while i >= 0 and oldText[i] == '\n':
    old_newlines += 1
    i -= 1

i = len(newText) - 1 ; new_newlines = 0
while i >= 0 and newText[i] == '\n':
    new_newlines += 1
    i -= 1

if u.debug_print:
    print "lead,trail",leading,trailing
    print "old mid,nls:",len(old_middle_lines),old_newlines,oldText
    print "new mid,nls:",len(new_middle_lines),new_newlines,newText
    #print "lead,trail:",leading,trailing
    #print "old mid:",old_middle_lines
    #print "new mid:",new_middle_lines
    print "---------------------"
#@nonl
#@-node:ekr.20031218072017.1491:<< compute leading, middle & trailing  lines >>
#@+node:ekr.20031218072017.1492:<< save undo text info >>
@ This is the start of the incremental undo algorithm.

We must save enough info to do _both_ of the following:

Undo: Given newText, recreate oldText.
Redo: Given oldText, recreate oldText.

The "given" texts for the undo and redo routines are simply p.bodyString().
@c

if u.debug:
    # Remember the complete text for comparisons...
    u.oldText = oldText
    u.newText = newText
    # Compute statistics comparing old and new ways...
    # The old doesn't often store the old text, so don't count it here.
    u.old_mem += len(newText)
    s1 = string.join(old_middle_lines,'\n')
    s2 = string.join(new_middle_lines,'\n')
    u.new_mem += len(s1) + len(s2)
else:
    u.oldText = None
    u.newText = None

u.leading = leading
u.trailing = trailing
u.oldMiddleLines = old_middle_lines
u.newMiddleLines = new_middle_lines
u.oldNewlines = old_newlines
u.newNewlines = new_newlines
#@nonl
#@-node:ekr.20031218072017.1492:<< save undo text info >>
#@+node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#Remember the selection.
u.oldSel = oldSel
u.newSel = newSel

# Remember the scrolling position.
if oldYview:
    u.yview = oldYview
else:
    u.yview = c.frame.body.getYScrollPosition()
#@-node:ekr.20040324061854.2:<< save the selection and scrolling position >>
#@+node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
@ New in Leo 4.3. Instead of creating a new bead on every character, we may adjust the top bead:

word granularity: adjust the top bead if the typing would continue the word.
line granularity: adjust the top bead if the typing is on the same line.
node granularity: adjust the top bead if the typing is anywhere on the same node.
@c

granularity = u.granularity

old_d = u.peekBead(u.bead)
old_p = old_d and old_d.get('p')

<< set newBead if we can't share the previous bead >>

if newBead:
    # Push params on undo stack, clearing all forward entries.
    u.bead += 1
    bunch = g.Bunch(
        p = p.copy(),
        kind='typing',
        undoType = undo_type,
        undoHelper=u.undoTyping,
        redoHelper=u.redoTyping,
        oldText=u.oldText,
        oldSel=u.oldSel,
        oldNewlines=u.oldNewlines,
        oldMiddleLines=u.oldMiddleLines,
    )
else:
    bunch = old_d

bunch.leading=u.leading
bunch.trailing= u.trailing
bunch.newNewlines=u.newNewlines
bunch.newMiddleLines=u.newMiddleLines
bunch.newSel=u.newSel
bunch.newText=u.newText
bunch.yview=u.yview

u.beads[u.bead:] = [bunch]
    
# g.trace(u.bead,len(u.beads))
#@nonl
#@+node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
@ We must set newBead to True if undo_type is not 'Typing' so that commands that
get treated like typing (by updateBodyPane and onBodyChanged) don't get lumped
with 'real' typing.
@c
# g.trace(granularity)
if (
    not old_d or not old_p or
    old_p.v != p.v or
    old_d.get('kind') != 'typing' or
    old_d.get('undoType') != 'Typing' or
    undo_type != 'Typing'
):
    newBead = True # We can't share the previous node.
elif granularity == 'char':
    newBead = True # This was the old way.
elif granularity == 'node':
    newBead = False # Always replace previous bead.
else:
    assert granularity in ('line','word')
    # Replace the previous bead if only the middle lines have changed.
    newBead = (
        old_d.get('leading',0)  != u.leading or 
        old_d.get('trailing',0) != u.trailing
    )
    if granularity == 'word' and not newBead:
        # Protect the method that may be changed by the user
        try:
            << set newBead if the change does not continue a word >>
        except Exception:
            if 0:
                g.trace('old_lines',old_lines)
                g.trace('new_lines',new_lines)
            g.es('Exception in setUndoRedoTypingParams',color='blue')
            g.es_exception()
            newBead = True
#@nonl
#@+node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
old_start,old_end = oldSel
new_start,new_end = newSel
# g.trace('new_start',new_start,'old_start',old_start)
if old_start != old_end or new_start != new_end:
    # The new and old characters are not contiguous.
    newBead = True
else:
    old_row,old_col = old_start.split('.')
    new_row,new_col = new_start.split('.')
    old_row,old_col = int(old_row),int(old_col)
    new_row,new_col = int(new_row),int(new_col)
    old_lines = g.splitLines(oldText)
    new_lines = g.splitLines(newText)
    # g.trace('old',old_row,old_col,len(old_lines))
    # g.trace('new',new_row,new_col,len(new_lines))
    # Recognize backspace, del, etc. as contiguous.
    if old_row != new_row or abs(old_col- new_col) != 1:
        # The new and old characters are not contiguous.
        newBead = True
    elif old_col == 0 or new_col == 0:
        pass # We have just inserted a line.
    else:
        old_s = old_lines[old_row-1]
        new_s = new_lines[new_row-1]
        # New in 4.3b2:
        # Guard against invalid oldSel or newSel params.
        if old_col-1 >= len(old_s) or new_col-1 >= len(new_s):
            newBead = True
        else:
            # g.trace(new_col,len(new_s),repr(new_s))
            # g.trace(repr(old_ch),repr(new_ch))
            old_ch = old_s[old_col-1]
            new_ch = new_s[new_col-1]
            newBead = self.recognizeStartOfTypingWord(
                old_lines,old_row,old_col,old_ch,
                new_lines,new_row,new_col,new_ch)
#@nonl
#@-node:ekr.20050125203937:<< set newBead if the change does not continue a word >>
#@-node:ekr.20050125220613:<< set newBead if we can't share the previous bead >>
#@-node:ekr.20040324061854.3:<< adjust the undo stack, clearing all forward entries >>
#@-node:ekr.20031218072017.1490:setUndoTypingParams
#@+node:ekr.20031218072017.1493:undoRedoText
# Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading & trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):
        
    __pychecker__ = '--no-argsused' # newNewlines is unused, but it has symmetry.

    u = self ; c = u.c
    # assert p == c.currentPosition(),'not current position'+repr(p)

    << Incrementally update the Tk.Text widget >>
    << Compute the result using p's body text >>
    # g.trace(undoType)
    p.setTnodeText(result)
    << Get textResult from the Tk.Text widget >>
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            << print mismatch trace >>
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)
#@nonl
#@+node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
# Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading > 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len > 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading > 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i >= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
# g.trace(newlines,oldNewlines)
while newlines > oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines > newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))
#@nonl
#@-node:ekr.20031218072017.1494:<< Incrementally update the Tk.Text widget >>
#@+node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
# Recreate the text using the present body text.
body = p.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading > 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) > 0:
    s.extend(oldMidLines)
if trailing > 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) > 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines > 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result
#@nonl
#@-node:ekr.20031218072017.1495:<< Compute the result using p's body text >>
#@+node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) > 0 and textResult[:-1] == result:
        textResult = result
#@nonl
#@-node:ekr.20031218072017.1496:<< Get textResult from the Tk.Text widget >>
#@+node:ekr.20031218072017.1497:<< print mismatch trace >>
print "undo mismatch"
print "expected:",result
print "actual  :",textResult
#@nonl
#@-node:ekr.20031218072017.1497:<< print mismatch trace >>
#@-node:ekr.20031218072017.1493:undoRedoText
#@-node:ekr.20050525163715:undo...
#@+node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20031218072017.1823:createLastChildNode
def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) > 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
#@nonl
#@-node:ekr.20031218072017.1823:createLastChildNode
#@+node:ekr.20031218072017.1824:dedentBody
def dedentBody (self):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1824:dedentBody
#@+node:ekr.20031218072017.1706:extract
def extract(self):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1706:extract
#@+node:ekr.20031218072017.1708:extractSection
def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@+node:ekr.20031218072017.1710:extractSectionNames
def extractSectionNames(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
#@nonl
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)
        
if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@nonl
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames
#@+node:ekr.20031218072017.1825:findBoundParagraph
def findBoundParagraph (self):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i < len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#	para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
#@nonl
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:findBoundParagraph
#@+node:ekr.20031218072017.1827:findMatchingBracket
def findMatchingBracket (self):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"<=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
#@nonl
#@+node:ekr.20031218072017.1828:findMatchingBracket
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,">=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level <= 0:
                return index
        if not forward and body.compareIndices(index,"<=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@nonl
#@-node:ekr.20031218072017.1828:findMatchingBracket
#@-node:ekr.20031218072017.1827:findMatchingBracket
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview
#@nonl
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.1830:indentBody
def indentBody (self):

    c = self ; undoType = 'Indent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1830:indentBody
#@+node:ekr.20031218072017.1831:insertBodyTime & allies
def insertBodyTime (self):
    
    c = self ; undoType = 'Insert Body Time'
    p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(p,undoType,oldSel=oldSel)
#@nonl
#@+node:ekr.20031218072017.1832:getTime
def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getString("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt     = c.config.getString("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
#@-node:ekr.20031218072017.1832:getTime
#@-node:ekr.20031218072017.1831:insertBodyTime & allies
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph(self):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
#@nonl
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
# Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 	18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 	18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
#@nonl
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo by calling setUndoTypingParams (in idle_body_key).
    body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@-node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    
    # g.trace(p.headString())

    if not p: return
    if not p.exists(c):
        g.trace('does not exist',p)
        return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        # g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    # g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@-node:ekr.20050525074210:(Fixed undo problems in unit tests)
#@+node:ekr.20050523134613:(Made sure same case is used in all recent files entries)
@ The problem was that leo.__file__ returns a randomly upper or lower cased drive letter.
#@nonl
#@+node:ekr.20031218072017.1937:computeLoadDir
def computeLoadDir():
    
    """Returns the directory containing leo.py."""
    
    import leoGlobals as g

    try:
        import leo
        import sys
        
        # Fix a hangnail: on Windows the drive letter returned by
        # __file__ is randomly upper or lower case!
        # The made for an ugly recent files list.
        path = leo.__file__
        if sys.platform=='win32':
            if len(path) > 2 and path[1]==':':
                # Convert the drive name to upper case.
                path = path[0].upper() + path[1:]
        encoding = g.startupEncoding()
        path = g.os_path_abspath(path,encoding)
        if path:
            loadDir = g.os_path_dirname(path,encoding)
        else: loadDir = None
            
        if (
            not loadDir or
            not g.os_path_exists(loadDir,encoding) or
            not g.os_path_isdir(loadDir,encoding)
        ):
            loadDir = os.getcwd()
            print "Using emergency loadDir:",repr(loadDir)
        
        loadDir = g.os_path_abspath(loadDir,encoding)
        # g.es("load dir: %s" % (loadDir),color="blue")
        return loadDir
    except:
        print "Exception getting load directory"
        import traceback ; traceback.print_exc()
        return None
#@nonl
#@-node:ekr.20031218072017.1937:computeLoadDir
#@-node:ekr.20050523134613:(Made sure same case is used in all recent files entries)
#@+node:ekr.20050524061338:(Made sure all dialogs gets focus when they are run)
# The About Leo dialog was not getting focus.
#@nonl
#@+node:ekr.20031218072017.3866:run (tkDialog)
def run (self,modal):
    
    """Run a leoTkinterDialog."""
    
    if g.app.unitTesting: return None

    c = self.c ; self.modal = modal

    self.center() # Do this after all packing complete.
    self.top.lift()

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        
    if self.focus_widget == None:
        self.focus_widget = self.top
        
    self.focus_widget.focus_set() # Get all keystrokes.
    if c:
        # g.trace(self.focus_widget,c)
        g.app.gui.widget_wants_focus(c,self.focus_widget)
       
    self.root.wait_window(self.top)
    
    if self.modal:
        return self.answer
    else:
        return None
#@nonl
#@-node:ekr.20031218072017.3866:run (tkDialog)
#@-node:ekr.20050524061338:(Made sure all dialogs gets focus when they are run)
#@+node:ekr.20050514171429.1:(Improved Resize To Screen command)
#@+node:ekr.20050526091058:Request
@killcolor 
http://sourceforge.net/forum/message.php?msg_id=3151996
By: ngirard, Nicolas

The "resize to screen" command doesn't actually resize to the entire screen.
#@nonl
#@-node:ekr.20050526091058:Request
#@+node:EKR.20040422130619:resizeToScreen
def resizeToScreen (self):
    
    top = self.top
    
    w = top.winfo_screenwidth()
    h = top.winfo_screenheight()

    if 1: # Fill the entire screen (almost)
        # This works well on Windows.  YMMV for other platforms.
        geom = "%dx%d%+d%+d" % (w-8,h-46,0,0)
    else: # The old way.
        geom = "%dx%d%+d%+d" % (w-20,h-55,10,25)

    top.geometry(geom)
#@nonl
#@-node:EKR.20040422130619:resizeToScreen
#@-node:ekr.20050514171429.1:(Improved Resize To Screen command)
#@+node:ekr.20050531105422:(Made sure comments are always visible in setting dialog even for non-@ nodes)
# Tricky to get right.
# Note that createOnlyComments doesn't have to do anything.
#@nonl
#@+node:ekr.20050531105422.1:Report
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3176499
By: mackal

5) am I missing text in the Settings panels?  the outline shows that certain
nodes have text (e.g., "About keyboard shortcuts" has the blue rectangle), yet
the body pane is empty; heck, even the title suggests that something should
be there...
#@-node:ekr.20050531105422.1:Report
#@+node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
def visitNode (self,p):
    
    """Visit a node, and possibly append a widget description to self.widgets."""
    
    munge = g.app.config.munge
    h = p.headString().strip() or ''
    kind,name,val = self.parseHeadline(h)
    
    # g.trace(kind,name,val)

    f = self.dispatchDict.get(munge(kind)) or self.doComment
    if f is not None:
        try:
            return f(p,kind,name,val)
        except TypeError:
            g.es_exception()
            print "*** no handler",kind
            return None
#@nonl
#@-node:ekr.20041225063637.99:visitNode (settingsDialogParserClass)
#@+node:ekr.20041225063637.100:kind handlers (settingsDialogParserClass)
# Most of the work is done by base class methods.
#@nonl
#@+node:ekr.20050603065400:doComment
def doComment (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    self.set(p,'comment',None,None)
#@nonl
#@-node:ekr.20050603065400:doComment
#@+node:ekr.20041225063637.101:doFont
def doFont (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    d = self.parseFont(p)
    # g.trace("\n\nfont dict...\n%s" % g.dictToString(d))
    self.set(p,kind,name,d)
#@-node:ekr.20041225063637.101:doFont
#@+node:ekr.20041225063637.102:doPage
def doPage(self,p,kind,name,val):
    
    """Create a widget for each setting in the subtree."""
    
    __pychecker__ = '--no-argsused' # args not used, but required.

    for p in p.subtree_iter():
        self.visitNode(p)
#@nonl
#@-node:ekr.20041225063637.102:doPage
#@+node:ekr.20041225063637.103:doRecentFiles & doBodyPaneList
def doBodyPaneList (self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # val not used, but required.

    s = p.bodyString()
    lines = g.splitLines(s)

    vals = []
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            vals.append(line)
                
    self.set(p,kind,name,vals)
#@-node:ekr.20041225063637.103:doRecentFiles & doBodyPaneList
#@+node:ekr.20041225063637.104:doShortcuts
def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # val not used, but required.

    s = p.bodyString()
    self.set(p,kind,name,s)
    self.controller.suppressComments=p.copy()
#@nonl
#@-node:ekr.20041225063637.104:doShortcuts
#@-node:ekr.20041225063637.100:kind handlers (settingsDialogParserClass)
#@+node:ekr.20041225063637.25:createWidgets & helpers
def createWidgets (self,widgets,parent,p):

    munge = g.app.config.munge

    << define creatorDispatchDict >>
    
    # g.trace(p.headString())
    
    # self.printWidgets(widgets)
    
    self.h = 0 # Offset from top of pane for first widget.
    self.createSpacerFrame(parent,size=15)
    
    if p != self.suppressComments:
        self.createComments(parent,p.copy())

    for data in widgets:
        p,kind,name,vals = data
        if kind.startswith('ints'):
            self.createInts(parent,p,kind,name,vals)
        if kind.startswith('strings'):
            self.createStrings(parent,p,kind,name,vals)
        else:
            f = creatorDispatchDict.get(munge(kind))
            if f is not None:
                try:
                    f(parent,p,kind,name,vals)
                except TypeError:
                    g.es_exception()
                    g.trace("***No handler***",kind)
#@nonl
#@+node:ekr.20041225063637.26:<< define creatorDispatchDict >>
creatorDispatchDict = {
    'bool':         self.createBool,
    'color':        self.createColor,
    'comment':      self.createOnlyComments, # New in 4.3.1
    'directory':    self.createDirectory,
    'font':         self.createFont,
    'int':          self.createInt,
    'ints':         self.createInts,
    'float':        self.createFloat,
    'path':         self.createPath,
    'ratio':        self.createRatio,
    'shortcut':     self.createShortcut,
    'shortcuts':    self.createShortcuts,
    'string':       self.createString,
    'strings':      self.createStrings,
}
#@nonl
#@-node:ekr.20041225063637.26:<< define creatorDispatchDict >>
#@+node:ekr.20041225063637.27:createBool
def createBool (self,parent,p,kind,name,val):
    
    val = g.choose(val.lower()=='true',1,0)

    # Inits the checkbutton widget. 
    var = Tk.IntVar()
    var.set(val)

    def boolCallback():
        val2 = g.choose(var.get(),True,False)
        # g.trace(name,val2)
        return val2
    
    val = g.choose(val,True,False)
    self.initValue(p,name,kind,val,boolCallback)

    box = Tk.Checkbutton(parent,text=name,variable=var,background=self.commonBackground)

    self.sc.create_window(10,self.h,anchor='w',window=box)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.27:createBool
#@+node:ekr.20041225063637.28:createColor
def createColor (self,parent,p,kind,name,val):
    
    munge = g.app.config.munge
    noColor = "<no color>"
    colorNamesList = list(self.colorNamesList)
    
    f = Tk.Frame(parent,background=self.commonBackground) # No need to pack.
    << munge val and add val to colorNamesList >>
    << create optionMenu and callback >>
    << create picker button and callback >>
    Tk.Label(f,text=name,background=self.commonBackground).pack(side='left')
    
    self.colorSettingDict [munge(name)] = val

    def getColorCallback ():
        return self.colorSettingDict.get(munge(name))

    self.initValue(p,name,kind,val,getColorCallback)

    self.sc.create_window(15,self.h+8,anchor='w',window=f)
    self.h += 30
#@nonl
#@+node:ekr.20041225063637.29:<< munge val and add val to colorNamesList >>
if val in ("None",None): val = noColor
val = str(val) # Get rid of unicode.

if noColor in colorNamesList:
    colorNamesList.remove(val)
if val is not noColor and val not in colorNamesList:
     colorNamesList.append(val)
colorNamesList.sort()
colorNamesList.insert(0,noColor)

initVal = val
if val is noColor: val = None
#@nonl
#@-node:ekr.20041225063637.29:<< munge val and add val to colorNamesList >>
#@+node:ekr.20041225063637.30:<< create optionMenu and callback >>
colorBox = Pmw.ComboBox(f,scrolledlist_items=colorNamesList)
colorBox.selectitem(initVal)
colorBox.pack(side="left",padx=2)

color = g.choose(val is None,f.cget('background'),val)
colorSample = Tk.Button(f,width=8,background=color)
colorSample.pack(side='left',padx=2)

def colorCallback (newName):
    # g.trace(repr(newName))
    if not newName or newName.lower() in ('none','<none>','<no color>'):
        self.colorSettingDict[munge(name)] = None
        color = f.cget('background')
        colorSample.configure(background=color)
    else:
        try:
            colorSample.configure(background=newName)
            self.colorSettingDict[munge(name)] = g.choose(newName is noColor,None,newName)
        except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)
#@nonl
#@-node:ekr.20041225063637.30:<< create optionMenu and callback >>
#@+node:ekr.20041225063637.31:<< create picker button and callback >>
def pickerCallback (color=val):

    rgb,val = tkColorChooser.askcolor(parent=parent,color=color)
    if rgb or val:
        # g.trace(rgb,val)
        self.colorSettingDict[munge(name)] = val
        colorSample.configure(background=val,activebackground=val,text=val)

b = Tk.Button(f,text="Color Picker...",command=pickerCallback,background=self.commonBackground)
b.pack(side="left")
#@nonl
#@-node:ekr.20041225063637.31:<< create picker button and callback >>
#@-node:ekr.20041225063637.28:createColor
#@+node:ekr.20050121131613:createComments
def createComments (self,parent,p):
    
    # g.trace(p.headString())
    
    bg = self.commonBackground

    s = p.bodyString().strip()
    if not s: return
    
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='comments',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background=bg,
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=5,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',s)
    t.configure(state='disabled')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 70
#@nonl
#@-node:ekr.20050121131613:createComments
#@+node:ekr.20050603065744:createOnlyComments
def createOnlyComments (self,parent,p,kind,name,val):
    
    pass # The existence of the 'comments' widget is enough.
#@nonl
#@-node:ekr.20050603065744:createOnlyComments
#@+node:ekr.20041225063637.32:createDirectory
def createDirectory (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.32:createDirectory
#@+node:ekr.20041225063637.33:createFloat
def createFloat (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent,background=bg)
    Tk.Entry(f,textvariable=var,background=bg).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def floatCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            float(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
            
    self.initValue(p,name,kind,val,floatCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.33:createFloat
#@+node:ekr.20041225063637.34:createFont
def createFont (self,parent,p,kind,fontName,val):
    
    """Create a font picker.  val is a dict containing the specified values."""
    bg = self.commonBackground
    d = val
    munge = g.app.config.munge
    f = Tk.Frame(parent,background=bg) # No need to pack.
    self.alterComments = p.copy()
    self.alteredCommentsString = d.get('comments')
    << create the family combo box >>
    << create the size entry >>
    << create the weight combo box >>
    << create the slant combo box >>
    Tk.Label(f,text=fontName,background=bg).pack(side='left')
    << define fontCallback >>

    familyBox.configure(selectioncommand=fontCallback)
    slantBox.configure(selectioncommand=fontCallback)
    weightBox.configure(selectioncommand=fontCallback)

    self.initValue(p,munge(fontName),'font',d,fontCallback)

    self.sc.create_window(15,self.h,anchor='w',window = f)
    self.h += 30
#@nonl
#@+node:ekr.20041225063637.35:<< create the family combo box >>
names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'<None>')

data = d.get('family')
initialitem = 0
if data:
    name2,val = data
    if val and val in names:
        initialitem = names.index(val)

familyBox = Pmw.ComboBox(f,
    labelpos="we",label_text='Family:',
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(initialitem)
familyBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.35:<< create the family combo box >>
#@+node:ekr.20041225063637.36:<< create the size entry >>
Tk.Label(f,text="Size:",background=bg).pack(side="left")

sizeEntry = Tk.Entry(f,width=4)
sizeEntry.pack(side="left")

data = d.get('size')
if data:
    kind,val = data
    if val not in (None,'None','none'):
        try:
            int(val)
            sizeEntry.insert('end',val)
        except ValueError:
            s = "invalid size: %s" % val
            print s ; self.es(s,color="blue")
#@nonl
#@-node:ekr.20041225063637.36:<< create the size entry >>
#@+node:ekr.20041225063637.37:<< create the weight combo box >>
initialitem = 0
values = ['<None>','normal','bold']
data = d.get('weight')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

weightBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Weight:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

weightBox.selectitem(initialitem)
weightBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.37:<< create the weight combo box >>
#@+node:ekr.20041225063637.38:<< create the slant combo box>>
initialitem = 0
values=['<None>','roman','italic']
data = d.get('slant')
if data:
    kind,val = data
    if val in values:
        initialitem = values.index(val)

slantBox = Pmw.ComboBox(f,
    labelpos="we",label_text="Slant:",
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=values)

slantBox.selectitem(initialitem)
slantBox.pack(side="left",padx=2)
#@nonl
#@-node:ekr.20041225063637.38:<< create the slant combo box>>
#@+node:ekr.20041225063637.39:<< define fontCallback >>
def fontCallback(*args,**keys):
    
    __pychecker__ = '--no-argsused' # not used, but needed.
    
    d2 = d.copy() # The update logic must compare distinct dicts.
    
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:   val = sizeEntry.get().strip()
        if not val or  val.lower() in ('none','<none>',): val = None

        data = d.get(key)
        name,oldval = data
        d2[key] = name,val
    
    return d2
#@nonl
#@-node:ekr.20041225063637.39:<< define fontCallback >>
#@-node:ekr.20041225063637.34:createFont
#@+node:ekr.20041225063637.40:createInt
def createInt (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')

    def intCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val
    
    self.initValue(p,name,kind,val,intCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.40:createInt
#@+node:ekr.20041225063637.41:createInts
def createInts (self,parent,p,kind,name,val):
    
    # g.trace(repr(kind),repr(name),val)
    
    bg = self.commonBackground
    
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 < i < j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'<none>')
    
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent)

    intsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background=bg,
        scrolledlist_items=items)

    intsBox.selectitem(initialitem)
    intsBox.pack(side="left",padx=2)
    
    def intsCallback():
        val2 = intsBox.get()
        try:
            int(val2)
            return val2
        except TypeError:
            g.trace("bad val:",val2)
            return val

    self.initValue(p,name,kind,val,intsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.41:createInts
#@+node:ekr.20041225063637.42:createPath
def createPath (self,parent,p,kind,name,val):
    
    self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.42:createPath
#@+node:ekr.20041225063637.43:createRatio
def createRatio (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # Inits the entry widget.
    var = Tk.StringVar()
    var.set(val)

    f = Tk.Frame(parent)
    Tk.Entry(f,textvariable=var).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def ratioCallback():
        val2 = var.get()
        # g.trace(name,val2)
        try:
            val2 = float(val2)
            if 0.0 <= val2 <= 1.0:
                return val2
        except TypeError:
            pass
        g.trace("bad val:",val2)
        return val
            
    self.initValue(p,name,kind,val,ratioCallback)
    
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.43:createRatio
#@+node:ekr.20041225063637.45:createShortcut
def createShortcut (self,parent,p,kind,name,val):
    
    g.trace(name,val)
    
    if name:
        self.createString(parent,p,kind,name,val)
#@nonl
#@-node:ekr.20041225063637.45:createShortcut
#@+node:ekr.20041225063637.46:createShortcuts
def createShortcuts (self,parent,p,kind,name,vals):
    
    __pychecker__ = '--no-argsused' # vals not used.
    
    t = self.createText(parent,p)
    
    def shortcutsCallback():
        val = t.get('1.0','end').rstrip()
        return val

    self.initValue(p,name,kind,vals,shortcutsCallback)
#@nonl
#@-node:ekr.20041225063637.46:createShortcuts
#@+node:ekr.20041225063637.47:createSpacerFrame
def createSpacerFrame (self,parent,size=10):
    
    f = Tk.Frame(parent)
    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += size
#@nonl
#@-node:ekr.20041225063637.47:createSpacerFrame
#@+node:ekr.20041225063637.48:createString
def createString (self,parent,p,kind,name,val):
    
    bg = self.commonBackground

    if val in (None,'None'): val = ""
    
    # Inits the Entry widget.
    var = Tk.StringVar()
    var.set(val)
    
    f = Tk.Frame(parent) # No need to pack.
    Tk.Entry(f,textvariable=var,width=40).pack(side='left')
    Tk.Label(f,text=name,background=bg).pack(side='left')
    
    def stringCallback():
        val = var.get()
        # g.trace(name,val)
        return val

    self.initValue(p,name,kind,val,stringCallback)
    
    self.sc.create_window(15,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.48:createString
#@+node:ekr.20041225063637.49:createStrings
def createStrings (self,parent,p,kind,name,val):
    
    bg = self.commonBackground
    
    # g.trace(repr(kind),repr(name),val)
    i = kind.find('[')
    j = kind.find(']')
    if not (-1 < i < j):
        return
    
    items = kind[i+1:j].split(',')
    items.sort()
    items.insert(0,'<none>')
    if val in items:
        initialitem = items.index(val)
    else:
        initialitem = 0
        
    f = Tk.Frame(parent,background=bg)

    stringsBox = Pmw.ComboBox(f,
        labelpos="ew",label_text=name,
        label_background = bg,
        scrolledlist_items=items)

    stringsBox.selectitem(initialitem)
    stringsBox.pack(side="left",padx=2)
    
    def stringsCallback():
        return stringsBox.get()

    self.initValue(p,name,kind,val,stringsCallback)

    self.sc.create_window(10,self.h,anchor='w',window=f)
    self.h += 30
#@nonl
#@-node:ekr.20041225063637.49:createStrings
#@+node:ekr.20050512134219:createText
def createText (self,parent,p):
    
    bg = self.commonBackground
    f = Tk.Frame(parent,background=bg) # No need to pack.

    scrolled_text = Pmw.ScrolledText(f,
        labelpos = 'ew',label_text='shortcuts',
        hull_background=bg,
        hull_bd=2,hull_relief='groove',
        hull_padx=6,hull_pady=6,
        text_background='white',
        text_padx=6,text_pady=6,
        text_bd=2,text_relief='sunken',
        label_background=bg,
        text_height=10,text_width=80)
    scrolled_text.pack(side='left',pady=6,padx=6,expand=1,fill='x')
    t = scrolled_text.component('text')
    t.insert('end',p.bodyString().strip())
    t.configure(state='normal')
    scrolled_text.component('hull')

    self.sc.create_window(10-2,self.h,anchor='w',window=f)
    self.h += 140
    
    return t
#@nonl
#@-node:ekr.20050512134219:createText
#@-node:ekr.20041225063637.25:createWidgets & helpers
#@-node:ekr.20050531105422:(Made sure comments are always visible in setting dialog even for non-@ nodes)
#@+node:ekr.20050608084340:(Fixed problem with leading @ in body text)
#@+node:ekr.20050608084340.1:Report
@killcolor
https://sourceforge.net/forum/message.php?msg_id=3190593

As luck would have it, I need to put an @ character at the beginning of a line
in source code (windows registry file format) and can't figure out how to do
it.  Any suggestions?
#@-node:ekr.20050608084340.1:Report
#@+node:ekr.20050608084340.2:Notes
@nocolor
This looks like a bug.  I suspect the fix will be relatively straightforward.  I plan to fix it today.  BTW, I have no idea why Leo thinks it must special-case an @-sign in this context.

The rest of the posting are essentially notes to myself.  You can skip it if you like :-)

Here is an example of the bug.  I put the following text in an @file node and an @thin node.  (All examples were with @language plain: I doubt if language has any major effect.)

Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@="&Notepad"

The contents of the file derived from the @file tree was:

#@verbatim
#@+leo-ver=4
#@verbatim
#@+node:@file leadingAtTest.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
#@verbatim
#@@="&Notepad"
#@verbatim
#@-node:@file leadingAtTest.py
#@verbatim
#@-leo

The contents of the file derived from the @thin tree was:

#@verbatim
#@+leo-ver=4-thin
#@verbatim
#@+node:ekr.20050608081942:@thin leadingAtTest2.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
#@verbatim
#@@="&Notepad"
#@verbatim
#@nonl
#@verbatim
#@-node:ekr.20050608081942:@thin leadingAtTest2.py
#@verbatim
#@-leo

The bug does not appear if the @ sign is followed by what looks to be a keyword.  For example, I put the following text in an @file node and an @thin node:

Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad

The contents of the file derived from the @file tree was:

#@verbatim
#@+leo-ver=4
#@verbatim
#@+node:@file leadingAtTest3.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad
#@verbatim
#@nonl
#@verbatim
#@-node:@file leadingAtTest3.py
#@verbatim
#@-leo

The contents of the file derived from the @thin tree was:

#@verbatim
#@+leo-ver=4-thin
#@verbatim
#@+node:ekr.20050608082702.1:@thin leadingAtTest4.py
Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad
#@verbatim
#@-node:ekr.20050608082702.1:@thin leadingAtTest4.py
#@verbatim
#@-leo
#@-node:ekr.20050608084340.2:Notes
#@+node:ekr.20041005105605.161:putBody
# oneNodeOnly is no longer used, but it might be used in the future?

def putBody(self,p,oneNodeOnly=False,fromString=''):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self
    
    # New in 4.3 b2: get s from fromString if possible.
    s = g.choose(fromString,fromString,p.bodyString())

    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
    if not at.thinFile and not s: return

    inCode = True
    << Make sure all lines end in a newline >>
    i = 0
    while i < len(s):
        next_i = g.skip_line(s,i)
        assert(next_i > i)
        kind = at.directiveKind4(s,i)
        << handle line at s[i] >>
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")
#@nonl
#@+node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
# 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl
#@nonl
#@-node:ekr.20041005105605.162:<< Make sure all lines end in a newline >>
#@+node:ekr.20041005105605.163:<< handle line at s[i]  >>
if kind == at.noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (at.docDirective,at.atDirective):
    assert(not at.pending)
    if not inCode: # Bug fix 12/31/04: handle adjacent doc parts.
        at.putEndDocLine() 
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (at.cDirective,at.codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == at.allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == at.rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == at.endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == at.miscDirective:
    # g.trace('miscDirective')
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.
#@nonl
#@-node:ekr.20041005105605.163:<< handle line at s[i]  >>
#@-node:ekr.20041005105605.161:putBody
#@+node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first & @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i < len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        << handle @delims >>
    elif g.match_word(s,k,"@language"):
        << handle @language >>
    elif g.match_word(s,k,"@comment"):
        << handle @comment >>
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i
#@nonl
#@+node:ekr.20041005105605.207:<< handle @delims >>
# Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j < i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i < len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j<i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")
#@nonl
#@-node:ekr.20041005105605.207:<< handle @delims >>
#@+node:ekr.20041005105605.208:<< handle @language >>
self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.208:<< handle @language >>
#@+node:ekr.20041005105605.209:<< handle @comment >>
self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")
#@nonl
#@-node:ekr.20041005105605.209:<< handle @comment >>
#@-node:ekr.20041005105605.206:putDirective  (handles @delims,@comment,@language) 4.x
#@+node:ekr.20041005105605.198:directiveKind4 & test
def directiveKind4(self,s,i):
    
    """Return the kind of at-directive or noDirective."""

    at = self
    n = len(s)
    if i >= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return at.othersDirective
        elif g.match_word(s,j,"@all"):
            return at.allDirective
        else:
            return at.noDirective

    table = (
        ("@all",at.allDirective),
        ("@c",at.cDirective),
        ("@code",at.codeDirective),
        ("@doc",at.docDirective),
        ("@end_raw",at.endRawDirective),
        ("@others",at.othersDirective),
        ("@raw",at.rawDirective))
        
    # Rewritten 6/8/2005.
    if i+1 >= n or s[i+1] in (' ','\t','\n'):
        # Bare '@' not recognized in cweb mode.
        return g.choose(at.language=="cweb",at.noDirective,at.atDirective)
    if s[i+1] not in string.ascii_letters:
        return at.noDirective # Bug fix: do NOT return miscDirective here!
    if at.language=="cweb" and g.match_word(s,i,'@c'):
        return at.noDirective
    
    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # Return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return at.miscDirective

    return at.noDirective
#@nonl
#@+node:ekr.20050608103755:test_directiveKind4
def test_directiveKind4 (self):
    
    at=c.atFileCommands # Self is a dummy argument.
    import leoColor
    table = [
        ('@=',0,at.noDirective),
        ('@',0,at.atDirective),
        ('@ ',0,at.atDirective),
        ('@\t',0,at.atDirective),
        ('@\n',0,at.atDirective),
        ('@all',0,at.allDirective),
        ('    @all',4,at.allDirective),
        ("@c",0,at.cDirective),
        ("@code",0,at.codeDirective),
        ("@doc",0,at.docDirective),
        ("@end_raw",0,at.endRawDirective),
        ('@others',0,at.othersDirective),
        ('    @others',4,at.othersDirective),
        ("@raw",0,at.rawDirective),
    ]
    for name in leoColor.leoKeywords:
        if name not in ('@','@all','@c','@code','@doc','@end_raw','@others','@raw',):
            table.append((name,0,at.miscDirective),)

    for s,i,expected in table:
        result = at.directiveKind4(s,i)
        assert result == expected, '%d %s result: %s expected: %s' % (
            i,repr(s),at.sentinelName(result),at.sentinelName(expected))
#@nonl
#@-node:ekr.20050608103755:test_directiveKind4
#@-node:ekr.20041005105605.198:directiveKind4 & test
#@-node:ekr.20050608084340:(Fixed problem with leading @ in body text)
#@+node:ekr.20050615100824:(Fixed several  crashers while undoing a move involving clones)
#@+node:ekr.20050615101010:(fixed) Crash: move c up, then undo.
exception executing command
Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 177, in doCommand
    command()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1563, in undo
    u.undoHelper()
  File "c:\prog\leoCVS\leo\src\leoUndo.py", line 1711, in undoMove
    u.p.moveToNthChildOf(u.oldParent,u.oldN)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 2760, in moveToNthChildOf
    p.unlink()
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3283, in unlink
    assert(parent.v in p.v.directParents())
AssertionError
#@nonl
#@-node:ekr.20050615101010:(fixed) Crash: move c up, then undo.
#@+node:ekr.20050615111747:(fixed) Crash2: clone c, move up twice, undo three times (no clone), redo: clone moves to wrong position
#@-node:ekr.20050615111747:(fixed) Crash2: clone c, move up twice, undo three times (no clone), redo: clone moves to wrong position
#@+node:ekr.20050615111747.1:(fixed) Crash 3: clone c, undo, redo
@killcolor

exception executing command
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 177, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 1309, in redo
    u.redoHelper()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 1334, in redoCloneNode
    if u.newBack:

AttributeError: undoer instance has no attribute 'newBack'
#@nonl
#@-node:ekr.20050615111747.1:(fixed) Crash 3: clone c, undo, redo
#@+node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
# These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext
#@nonl
#@-node:ekr.20031218072017.915:p.getX & vnode compatibility traversal routines
#@+node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
    else:
        p.v = None
    return p
#@nonl
#@-node:ekr.20031218072017.937:p.moveToParent (pops stack when multiple parents)
#@+node:ekr.20040310062332.5:p.unlink
def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""
    
    # Warning: p.parent() is NOT necessarily the same as p.v._parent!

    p = self ; v = p.v
    
    # g.trace('p.v._parent',p.v._parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if p.v._parent:
        assert(p.v and p.v._parent in p.v.directParents())
        if p.v._parent.t._firstChild == v:
            #g.trace('resetting _parent.v.t._firstChild to',v._next)
            p.v._parent.t._firstChild = v._next
    else:
        parent = p.parent()
        if parent:
            assert(parent.v in p.v.directParents())
            if parent.v.t._firstChild == v:
                #g.trace('resetting parent().v.t._firstChild to',v._next)
                parent.v.t._firstChild = v._next

    # Do NOT delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
#@nonl
#@-node:ekr.20040310062332.5:p.unlink
#@+node:ekr.20040323100443:v.directParents (new method in 4.2)
def directParents (self):
    
    """(New in 4.2) Return a list of all direct parent vnodes of a vnode.
    
    This is NOT the same as the list of ancestors of the vnode."""
    
    v = self
    
    if v._parent:
        return v._parent.t.vnodeList
    else:
        return []
#@nonl
#@-node:ekr.20040323100443:v.directParents (new method in 4.2)
#@+node:ekr.20050411112033:undoMove
def undoMove (self):
    
    u = self ; c = u.c

    # g.trace(u.p,u.oldParent,u.oldN)

    if u.oldParent:
        u.p.moveToNthChildOf(u.oldParent,u.oldN)
    elif u.oldBack:
        u.p.moveAfter(u.oldBack)
    else:
        oldRoot = c.rootPosition()
        u.p.moveToRoot(oldRoot)

    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()

    # Selecting can scroll the tree which causes flash.
    if u.groupCount == 0:
        c.selectPosition(u.p)
#@nonl
#@-node:ekr.20050411112033:undoMove
#@clone 2
#@+node:ekr.20050615101010.1:a
#@clone 2
#@+node:ekr.20050615101010.2:b
#@+node:ekr.20050615101010.3:c
#@-node:ekr.20050615101010.3:c
#@-node:ekr.20050615101010.2:b
#@-node:ekr.20050615101010.1:a
#@-node:ekr.20050615100824:(Fixed several  crashers while undoing a move involving clones)
#@+node:ekr.20050614061546.2:(Experimented with patch for canvas scrolling problems) Crashes on XP
#@+node:ekr.20050614061546.3:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3178878
By: mackal

Found this in Tk's   "text.tcl":

@color
@language tcltk

if {[string equal "x11" [tk windowingsystem]]} {
    # Support for mousewheels on Linux/Unix commonly comes through mapping
    # the wheel to the extended buttons.  If you have a mousewheel, find
    # Linux configuration info at:
    #   http://www.inria.fr/koala/colas/mouse-wheel-scroll/
    bind Text <4> {
        if {!$tk_strictMotif} {
            %W yview scroll -5 units
        }
    }
    bind Text <5> {
        if {!$tk_strictMotif} {
            %W yview scroll 5 units
        }
    }
}

@nocolor


So basically the text widget grabs the mouse-wheel scroll events.  I'm kind
of rusty in TclTk bind and bindtags particulars, so perhaps someone can suggest
the "proper" way to fix this... is it just a matter of deleting the binging
from the default bindtags for Tk.Text?

BTW, I'm using Tk 8.4... (i.e.,that's where that code snippet was ripped from)
#@-node:ekr.20050614061546.3:Report
#@+node:ekr.20050614064918:Patch
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3184865
By: mackal

The prior patch is even faultier than I realized, causing even the node body
mouse wheel events to scroll outline views (basically any mousewheel event in
any Tk.Text would scroll the outline which had the most recently called
newText()).

Here is a properly functioning patch:[snip]

EKR: I don't see how this can work.  The tree pane almost never gets focus.  And it seems to crash on XP.
#@nonl
#@-node:ekr.20050614064918:Patch
#@+node:ekr.20040803072955.11:newText (leoTkinterTree)
def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    
    d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        t = Tk.Text(canvas,state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            t.bind("<Button-1>", self.onHeadlineClick)
            t.bind("<Button-3>", self.onHeadlineRightClick)
            t.bind("<Key>",      self.onHeadlineKey)
            t.bind("<Control-t>",self.onControlT)

        if 0: # Crashes on XP.
            << patch by Maciej Kalisiak to handle scroll-wheel events >>
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # Bug fix 7/31/04:  We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString(),tag="newText")
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # New in 4.2 b3: entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList

    # g.trace(p,t)
    return t
#@nonl
#@+node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
def PropagateButton4(e):
    canvas.event_generate("<Button-4>")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("<Button-5>")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("<MouseWheel>")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "<Button-4>", PropagateButton4)
    t.bind_class(instance_tag, "<Button-5>", PropagateButton5)
    t.bind_class(instance_tag, "<MouseWheel>",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("<Button-4>", PropagateButton4)
    t.bind("<Button-5>", PropagateButton5)
    t.bind("<MouseWheel>", PropagateMouseWheel)

#@-node:ekr.20050618045715:<< patch by Maciej Kalisiak  to handle scroll-wheel events >>
#@-node:ekr.20040803072955.11:newText (leoTkinterTree)
#@-node:ekr.20050614061546.2:(Experimented with patch for canvas scrolling problems) Crashes on XP
#@+node:ekr.20050614065022:(Fixed Unicode encoding problem)
#@+node:ekr.20050614065022.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3186385
By: ejoy

I just tried 4.3-final, and it seems it does not work with Chinese LC_CTYPE:

echo $LC_CTYPE
zh_CN

leo
reading settings in /home/zl/opt/lib/leo/config/leoSettings.leo
Traceback (most recent call last):
  File "/home/zl/opt/lib/leo/src/leo.py", line 310, in ?
    run(fileName)
  File "/home/zl/opt/lib/leo/src/leo.py", line 96, in run
    g.app.setEncoding()
  File "/home/zl/opt/lib/leo/src/leoApp.py", line 361, in setEncoding
    for (encoding,src) in (
  File "/home/zl/opt/lib/python2.4/locale.py", line 415,
in getpreferredencoding
    setlocale(LC_CTYPE, "")
  File "/home/zl/opt/lib/python2.4/locale.py", line 379, in setlocale
    return _setlocale(category, locale)
locale.Error: unsupported locale setting

This can be solve by wrap setlocale with a try/except statement to fallback
to English on local.Error, I think.

#@-node:ekr.20050614065022.1:Report
#@+node:ekr.20031218072017.2618:app.setEncoding
@ According to Martin v. Löwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):
    
    """Set g.app.tkEncoding."""

    try: locale_encoding = g.getpreferredencoding()
    except Exception: locale_encoding = None
    
    try: sys_encoding = sys.getdefaultencoding()
    except Exception: sys_encoding = None

    for (encoding,src) in (
        (self.config.tkEncoding,"config"),
        (locale_encoding,"locale"),
        (sys_encoding,"sys"),
        ("utf-8","default")):
    
        if g.isValidEncoding (encoding):
            self.tkEncoding = encoding
            # g.trace(self.tkEncoding,src)
            break
        elif encoding:
            color = g.choose(self.tkEncoding=="ascii","red","blue")
            g.trace("ignoring invalid %s encoding: %s" % (src,encoding),color=color)
#@nonl
#@-node:ekr.20031218072017.2618:app.setEncoding
#@-node:ekr.20050614065022:(Fixed Unicode encoding problem)
#@+node:ekr.20050614061546:(Fixed problem with coloring @language plain)
#@+node:ekr.20050614061546.1:Report & fix
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3175553
By: nobody

When I set default_target_language to plain in 4.2., no words in any body text
is colored. This behavior seems to have changed in 4.3. Is it right, that I
now have to write @nocolor on top of *every* body text to get rid of randomly
colored words?
 
Kind regards 
Franz GEIGER, who's still using Leo as the world's best outliner and not for
programming tasks (I'm in love for more than 2 years now :-) )

What I did:

- Added entries for target_language to ivarsDic and defaultsDict in leoConfig.py.
- Added @language target_language = Python to leoSettings.leo.
- Convert c.target_language to lowercase in several places.
 
#@-node:ekr.20050614061546.1:Report & fix
#@+node:ekr.20031218072017.1602:<< initialize ivars & tags >> colorizeAnyLanguage
# Add any newly-added user keywords.
for d in g.globalDirectiveList:
    name = '@' + d
    if name not in leoKeywords:
        leoKeywords.append(name)

# Copy the arguments.
self.p = p

# Get the body text, converted to unicode.
s = self.body.getAllText() # 10/27/03
self.sel = sel = self.body.getInsertionPoint() # 10/27/03
start,end = self.body.convertIndexToRowColumn(sel) # 10/27/03

if self.language: self.language = self.language.lower() # 6/20/05
# g.trace(self.count,self.p)
# g.trace(body.tag_names())

if not self.incremental:
    self.removeAllTags()
    self.removeAllImages()

self.redoColoring = False
self.redoingColoring = False

<< configure tags >>
<< configure language-specific settings >>

self.hyperCount = 0 # Number of hypertext tags
self.count += 1
lines = string.split(s,'\n')
#@nonl
#@+node:ekr.20031218072017.1603:<< configure tags >>
for name in default_colors_dict.keys(): # Python 2.1 support.
    option_name,default_color = default_colors_dict[name]
    option_color = c.config.getColor(option_name)
    color = g.choose(option_color,option_color,default_color)
    # Must use foreground, not fg.
    try:
        self.body.tag_configure(name, foreground=color)
    except: # Recover after a user error.
        self.body.tag_configure(name, foreground=default_color)

underline_undefined = c.config.getBool("underline_undefined_section_names")
use_hyperlinks      = c.config.getBool("use_hyperlinks")
self.use_hyperlinks = use_hyperlinks

# underline=var doesn't seem to work.
if 0: # use_hyperlinks: # Use the same coloring, even when hyperlinks are in effect.
    self.body.tag_configure("link",underline=1) # defined
    self.body.tag_configure("name",underline=0) # undefined
else:
    self.body.tag_configure("link",underline=0)
    if underline_undefined:
        self.body.tag_configure("name",underline=1)
    else:
        self.body.tag_configure("name",underline=0)
        
# 8/4/02: we only create tags for whitespace when showing invisibles.
if self.showInvisibles:
    for name,option_name,default_color in (
        ("blank","show_invisibles_space_background_color","Gray90"),
        ("tab",  "show_invisibles_tab_background_color",  "Gray80")):
        option_color = c.config.getColor(option_name)
        color = g.choose(option_color,option_color,default_color)
        try:
            self.body.tag_configure(name,background=color)
        except: # Recover after a user error.
            self.body.tag_configure(name,background=default_color)
    
# 11/15/02: Colors for latex characters.  Should be user options...

if 1: # Alas, the selection doesn't show if a background color is specified.
    self.body.tag_configure("latexModeBackground",foreground="black")
    self.body.tag_configure("latexModeKeyword",foreground="blue")
    self.body.tag_configure("latexBackground",foreground="black")
    self.body.tag_configure("latexKeyword",foreground="blue")
else: # Looks cool, and good for debugging.
    self.body.tag_configure("latexModeBackground",foreground="black",background="seashell1")
    self.body.tag_configure("latexModeKeyword",foreground="blue",background="seashell1")
    self.body.tag_configure("latexBackground",foreground="black",background="white")
    self.body.tag_configure("latexKeyword",foreground="blue",background="white")
    
# Tags for wiki coloring.
if self.showInvisibles:
    self.body.tag_configure("elide",background="yellow")
else:
    self.body.tag_configure("elide",elide="1")
self.body.tag_configure("bold",font=self.bold_font)
self.body.tag_configure("italic",font=self.italic_font)
self.body.tag_configure("bolditalic",font=self.bolditalic_font)
for name in self.color_tags_list:
    self.body.tag_configure(name,foreground=name)
#@nonl
#@-node:ekr.20031218072017.1603:<< configure tags >>
#@+node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
# Define has_string, keywords, single_comment_start, block_comment_start, block_comment_end.

if self.language == "cweb": # Use C comments, not cweb sentinel comments.
    delim1,delim2,delim3 = g.set_delims_from_language("c")
elif self.comment_string:
    delim1,delim2,delim3 = g.set_delims_from_string(self.comment_string)
elif self.language == "plain": # 1/30/03
    delim1,delim2,delim3 = None,None,None
else:
    delim1,delim2,delim3 = g.set_delims_from_language(self.language)

self.single_comment_start = delim1
self.block_comment_start = delim2
self.block_comment_end = delim3

# A strong case can be made for making this code as fast as possible.
# Whether this is compatible with general language descriptions remains to be seen.
self.case_sensitiveLanguage = self.language not in case_insensitiveLanguages
self.has_string = self.language != "plain"
if self.language == "plain":
    self.string_delims = ()
elif self.language in ("elisp","html"):
    self.string_delims = ('"')
else:
    self.string_delims = ("'",'"')
self.has_pp_directives = self.language in ("c","csharp","cweb","latex")

# The list of languages for which keywords exist.
# Eventually we might just use language_delims_dict.keys()
languages = [
    "actionscript","ada","c","csharp","css","cweb","elisp","forth","html","java","latex",
    "pascal","perl","perlpod","php","plsql","python","rapidq","rebol","shell","tcltk"]

self.keywords = []
if self.language == "cweb":
    for i in self.c_keywords:
        self.keywords.append(i)
    for i in self.cweb_keywords:
        self.keywords.append(i)
else:
    for name in languages:
        if self.language==name: 
            # g.trace("setting keywords for",name)
            self.keywords = getattr(self, name + "_keywords")

# For forth.
self.nextForthWordIsNew = False

# Color plain text unless we are under the control of @nocolor.
# state = g.choose(self.flag,"normal","nocolor")
state = self.setFirstLineState()

if 1: # 10/25/02: we color both kinds of references in cweb mode.
    self.lb = "<<"
    self.rb = ">>"
else:
    self.lb = g.choose(self.language == "cweb","@<","<<")
    self.rb = g.choose(self.language == "cweb","@>",">>")
#@nonl
#@-node:ekr.20031218072017.370:<< configure language-specific settings >> colorizer
#@-node:ekr.20031218072017.1602:<< initialize ivars & tags >> colorizeAnyLanguage
#@+node:ekr.20041117072055:ivarsDict
# Each of these settings sets the corresponding ivar.
# Also, the c.configSettings settings class inits the corresponding commander ivar.
ivarsDict = {'_hash':'ivarsDict'}

ivarsData = (
    ("at_root_bodies_start_in_doc_mode","bool",True),
        # For compatibility with previous versions.
    ("create_nonexistent_directories","bool",False),
    ("output_initial_comment","string",""),
        # "" for compatibility with previous versions.
    ("output_newline","string","nl"),
    ("page_width","int","132"),
    ("read_only","bool",True),
        # Make sure we don't alter an illegal leoConfig.txt file!
    ("redirect_execute_script_output_to_log_pane","bool",False),
    ("relative_path_base_directory","string","!"),
    ("remove_sentinels_extension","string",".txt"),
    ("save_clears_undo_buffer","bool",False),
    ("stylesheet","string",None),
    ("tab_width","int",-4),
    ("target_language","language","python"), # Bug fix: added: 6/20/2005.
    ("trailing_body_newlines","string","asis"),
    ("use_plugins","bool",True),
        # New in 4.3: use_plugins = True by default.
    # use_pysco can not be set by 4.3:  config processing happens too late.
        # ("use_psyco","bool",False),
    ("undo_granularity","string","word"),
        # "char","word","line","node"
    ("write_strips_blank_lines","bool",False),
)
#@nonl
#@-node:ekr.20041117072055:ivarsDict
#@+node:ekr.20041117062717.1:defaultsDict
@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {'_hash':'defaultsDict'}

defaultsData = (
    # compare options...
    ("ignore_blank_lines","bool",True),
    ("limit_count","int",9),
    ("print_mismatching_lines","bool",True),
    ("print_trailing_lines","bool",True),
    # find/change options...
    ("search_body","bool",True),
    ("whole_word","bool",True),
    # Prefs panel.
    ("default_target_language","language","python"),
    ("target_language","language","python"), # Bug fix: 6/20,2005.
    ("tab_width","int",-4),
    ("page_width","int",132),
    ("output_doc_chunks","bool",True),
    ("tangle_outputs_header","bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    ("color_directives_in_plain_text","bool",True),
    ("underline_undefined_section_names","bool",True),
    # Window options...
    ("allow_clone_drags","bool",True),
    ("body_pane_wraps","bool",True),
    ("body_text_font_family","family","Courier"),
    ("body_text_font_size","size",defaultBodyFontSize),
    ("body_text_font_slant","slant","roman"),
    ("body_text_font_weight","weight","normal"),
    ("enable_drag_messages","bool",True),
    ("headline_text_font_family","string",None),
    ("headline_text_font_size","size",defaultLogFontSize),
    ("headline_text_font_slant","slant","roman"),
    ("headline_text_font_weight","weight","normal"),
    ("log_text_font_family","string",None),
    ("log_text_font_size","size",defaultLogFontSize),
    ("log_text_font_slant","slant","roman"),
    ("log_text_font_weight","weight","normal"),
    ("initial_window_height","int",600),
    ("initial_window_width","int",800),
    ("initial_window_left","int",10),
    ("initial_window_top","int",10),
    ("initial_splitter_orientation","string","vertical"),
    ("initial_vertical_ratio","ratio",0.5),
    ("initial_horizontal_ratio","ratio",0.3),
    ("initial_horizontal_secondary_ratio","ratio",0.5),
    ("initial_vertical_secondary_ratio","ratio",0.7),
    ("outline_pane_scrolls_horizontally","bool",False),
    ("split_bar_color","color","LightSteelBlue2"),
    ("split_bar_relief","relief","groove"),
    ("split_bar_width","int",7),
)
#@nonl
#@-node:ekr.20041117062717.1:defaultsDict
#@+node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)
#@nonl
#@-node:ekr.20041228042224:setIvarsFromSettings (g.app.config)
#@+node:ekr.20041005105605.222:atFile.scanAllDirectives
@ Once a directive is seen, no other related directives in nodes further up the tree have any effect.  For example, if an @color directive is seen in node p, no @color or @nocolor directives are examined in any ancestor of p.

This code is similar to Commands.scanAllDirectives, but it has been modified for use by the atFile class.
@c

def scanAllDirectives(self,p,scripting=False,importing=False,reading=False,forcePythonSentinels=False):
    
    """Scan position p and p's ancestors looking for directives,
    setting corresponding atFile ivars.
    """
    
    __pychecker__ = '--maxlines=400'

    c = self.c
    << Set ivars >>
    << Set path from @file node >>
    old = {}
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        << Test for @path >>
        << Test for @encoding >>
        << Test for @comment and @language >>
        << Test for @header and @noheader >>
        << Test for @lineending >>
        << Test for @pagewidth >>
        << Test for @tabwidth >>
        old.update(theDict)
    << Set current directory >>
    if not importing and not reading:
        # 5/19/04: don't override comment delims when reading!
        << Set comment strings from delims >>
#@nonl
#@+node:ekr.20041005105605.223:<< Set ivars >>
self.page_width = self.c.page_width
self.tab_width  = self.c.tab_width

self.default_directory = None # 8/2: will be set later.

if c.target_language:
    c.target_language = c.target_language.lower() # 6/20/05
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
self.language = c.target_language

self.encoding = c.config.default_derived_file_encoding
self.output_newline = g.getOutputNewline(c=self.c) # Init from config settings.
#@nonl
#@-node:ekr.20041005105605.223:<< Set ivars >>
#@+node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
# An absolute path in an @file node over-rides everything else.
# A relative path gets appended to the relative path by the open logic.

name = p.anyAtFileNodeName() # 4/28/04

theDir = g.choose(name,g.os_path_dirname(name),None)

if theDir and len(theDir) > 0 and g.os_path_isabs(theDir):
    if g.os_path_exists(theDir):
        self.default_directory = theDir
    else: # 9/25/02
        self.default_directory = g.makeAllNonExistentDirectories(theDir)
        if not self.default_directory:
            self.error("Directory \"%s\" does not exist" % theDir)
#@nonl
#@-node:ekr.20041005105605.224:<< Set path from @file node >> in scanDirectory in leoGlobals.py
#@+node:ekr.20041005105605.225:<< Test for @path >>
# We set the current director to a path so future writes will go to that directory.

if not self.default_directory and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    << compute relative path from s[k:] >>
    if path and len(path) > 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        if g.os_path_isabs(path):
            << handle absolute path >>
        else:
            self.error("ignoring bad @path: %s" % path)
    else:
        self.error("ignoring empty @path")
#@nonl
#@+node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) > 2 and (
    (path[0]=='<' and path[-1] == '>') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]
path = path.strip()

if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(g.app.loadDir,path)
#@nonl
#@-node:ekr.20041005105605.226:<< compute relative path from s[k:] >>
#@+node:ekr.20041005105605.227:<< handle absolute path >>
# path is an absolute path.

if g.os_path_exists(path):
    self.default_directory = path
else: # 9/25/02
    self.default_directory = g.makeAllNonExistentDirectories(path)
    if not self.default_directory:
        self.error("invalid @path: %s" % path)
#@-node:ekr.20041005105605.227:<< handle absolute path >>
#@-node:ekr.20041005105605.225:<< Test for @path >>
#@+node:ekr.20041005105605.228:<< Test for @encoding >>
if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        self.encoding = e
#@nonl
#@-node:ekr.20041005105605.228:<< Test for @encoding >>
#@+node:ekr.20041005105605.229:<< Test for @comment and @language >>
# 10/17/02: @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

# 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
     pass # Do nothing more.

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1, delim2, delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    self.language,delim1,delim2,delim3 = g.set_language(s,k)
#@nonl
#@-node:ekr.20041005105605.229:<< Test for @comment and @language >>
#@+node:ekr.20041005105605.230:<< Test for @header and @noheader >>
# EKR: 10/10/02: perform the sames checks done by tangle.scanAllDirectives.
if theDict.has_key("header") and theDict.has_key("noheader"):
    g.es("conflicting @header and @noheader directives")
#@nonl
#@-node:ekr.20041005105605.230:<< Test for @header and @noheader >>
#@+node:ekr.20041005105605.231:<< Test for @lineending >>
if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    lineending = g.scanAtLineendingDirective(s,theDict)
    if lineending:
        self.explicitLineEnding = True
        self.output_newline = lineending
#@-node:ekr.20041005105605.231:<< Test for @lineending >>
#@+node:ekr.20041005105605.232:<< Test for @pagewidth >>
if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict,issue_error_flag=True)
    if w and w > 0:
        self.page_width = w
#@nonl
#@-node:ekr.20041005105605.232:<< Test for @pagewidth >>
#@+node:ekr.20041005105605.233:<< Test for @tabwidth >>
if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict,issue_error_flag=True)
    if w and w != 0:
        self.tab_width = w

#@-node:ekr.20041005105605.233:<< Test for @tabwidth >>
#@+node:ekr.20041005105605.234:<< Set current directory >>
# This code is executed if no valid absolute path was specified in the @file node or in an @path directive.

if c.frame and not self.default_directory:
    base = g.getBaseDirectory(c=c) # returns "" on error.
    for theDir in (c.tangle_directory,c.frame.openDirectory,c.openDirectory):
        if theDir and len(theDir) > 0:
            theDir = g.os_path_join(base,theDir)
            if g.os_path_isabs(theDir): # Errors may result in relative or invalid path.
                if g.os_path_exists(theDir):
                    self.default_directory = theDir ; break
                else: # 9/25/02
                    self.default_directory = g.makeAllNonExistentDirectories(theDir)

if not self.default_directory and not scripting and not importing:
    # This should never happen: c.openDirectory should be a good last resort.
    g.trace()
    self.error("No absolute directory specified anywhere.")
    self.default_directory = ""
#@-node:ekr.20041005105605.234:<< Set current directory >>
#@+node:ekr.20041005105605.235:<< Set comment strings from delims >>
if forcePythonSentinels:
    # Force Python language.
    delim1,delim2,delim3 = g.set_delims_from_language("python")
    self.language = "python"
    
# Use single-line comments if we have a choice.
# delim1,delim2,delim3 now correspond to line,start,end
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else: # Emergency!
    # assert(0)
    g.es("Unknown language: using Python comment delimiters")
    g.es("c.target_language:",c.target_language)
    g.es("delim1,delim2,delim3:",delim1,delim2,delim3)
    self.startSentinelComment = "#" # This should never happen!
    self.endSentinelComment = ""
    
# g.trace(repr(self.startSentinelComment),repr(self.endSentinelComment))
#@nonl
#@-node:ekr.20041005105605.235:<< Set comment strings from delims >>
#@-node:ekr.20041005105605.222:atFile.scanAllDirectives
#@-node:ekr.20050614061546:(Fixed problem with coloring @language plain)
#@-node:ekr.20050524102538:Bug fixes...
#@+node:ekr.20050526081733:New features...
#@+node:ekr.20050523075215:(Created separate helpers for idle_body_key)
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    # g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@-node:ekr.20050523075215:(Created separate helpers for idle_body_key)
#@+node:ekr.20050518055557:(Created v0.2 of UniversalScrolling plugin)
@killcolor

http://sourceforge.net/forum/message.php?msg_id=3155710

I simplified the code so I could understand it.

Known problems:

- Binding <Button-1> events is not a good idea.  The plugin has no good way to be sure whether the user intended to select a headline or scroll.

- Sometimes 'junk' appears above the scrolled outline when the root node gets scrolled down.  It appears impossible to fix.  A workaround would be to prevent scrolling downward if that would move the root node down.  However, I don't know how to do this: the canvas.yview method always returns the same value.
#@nonl
#@-node:ekr.20050518055557:(Created v0.2 of UniversalScrolling plugin)
#@+node:ekr.20050512085922:(Made all Mark commands undoable)
# I also fixed a bug: the Mark Clones command did not work!
#@nonl
#@+node:ekr.20050526131252:beforeMark
def beforeMark (self,p,command):
    
    u = self
    bunch = u.createCommonBunch(p)

    bunch.kind = 'mark'
    bunch.undoType = command
    
    return bunch
#@nonl
#@-node:ekr.20050526131252:beforeMark
#@+node:ekr.20050526124257:afterMark
def afterMark (self,p,command,bunch,dirtyVnodeList=[]):
    
    '''Create an undo node for mark and unmark commands.'''
    
    __pychecker__ = '--no-argsused'
        # 'command' unused, but present for compatibility with similar methods.
    
    u = self
    if u.redoing or u.undoing: return

    # Set the type & helpers.
    bunch.undoHelper = u.undoMark
    bunch.redoHelper = u.redoMark
    
    bunch.dirtyVnodeList = dirtyVnodeList
    bunch.newChanged = u.c.isChanged()
    bunch.newDirty = p.isDirty()
    bunch.newMarked = p.isMarked()

    # Push the bunch.
    u.bead += 1
    u.beads[u.bead:] = [bunch]

    # Recalculate the menu labels.
    u.setUndoTypes()
#@nonl
#@-node:ekr.20050526124257:afterMark
#@+node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self): 

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()
    
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self):

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                s = p.bodyString()
                flag, i = g.is_special(s,0,"@root")
                if flag:
                    bunch = u.beforeMark(p,undoType)
                    p.setMarked()
                    c.setChanged(True)
                    u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
def markAllAtFileNodesDirty (self):

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    try: # In update...
        while p:
            if p.isAtFileNode()and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
def markAtFileNodesDirty (self):

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    c.beginUpdate()
    try: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2927:markClones
def markClones (self):

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline
def markHeadline (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            p.clearMarked()
        else:
            p.setMarked()
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2928:markHeadline
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads(self):

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll(self):

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.clearMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2930:unmarkAll
#@-node:ekr.20031218072017.2922:Mark...
#@-node:ekr.20050512085922:(Made all Mark commands undoable)
#@+node:ekr.20050527100614:(Removed dependence on profile and pstats modules from leoTest.py)
#@+node:ekr.20050527100614.1:Report
@killcolor

https://sourceforge.net/forum/message.php?msg_id=3172485
By: ktenney


/usr/lib/python2.4/site-packages# python leo/src/leo.py
reading settings in /usr/lib/python2.4/site-packages/leo/config/leoSettings.leo
Traceback (most recent call last):
  File "leo/src/leo.py", line 312, in ?
    run()
  File "leo/src/leo.py", line 95, in run
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting
g.app.config.
  File "/usr/lib/python2.4/site-packages/leo/src/leoConfig.py", line 1169, in
readSettingsFiles
    c = self.openSettingsFile(path)
  File "/usr/lib/python2.4/site-packages/leo/src/leoConfig.py", line 1141, in
openSettingsFile
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
  File "/usr/lib/python2.4/site-packages/leo/src/leoGui.py", line 105,
in newLeoCommanderAndFrame
    import leoCommands
  File "/usr/lib/python2.4/site-packages/leo/src/leoCommands.py", line 24, in ?
    import leoImport
  File "/usr/lib/python2.4/site-packages/leo/src/leoImport.py", line 8, in ?
    import leoTest # Support for unit tests.
  File "/usr/lib/python2.4/site-packages/leo/src/leoTest.py", line 29, in ?
    import profile
ImportError: No module named profile


#@-node:ekr.20050527100614.1:Report
#@-node:ekr.20050527100614:(Removed dependence on profile and pstats modules from leoTest.py)
#@+node:ekr.20050601112005:(Body key handlers now call colorizer.interrupt)
# This supports the new colorizer.  It has no effect in the present code base.
#@nonl
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    # g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@+node:ekr.20031218072017.1329:onBodyChanged (tkTree)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.c.frame.body.colorizer.interrupt()
    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (tkTree)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event,undoType='Typing'):
    
    '''Handle any key press event in the body pane.'''

    # New in Leo 4.4.  May be called with event = None
    c = self.c
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(repr(ch),repr(event.keysym))

    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@-node:ekr.20050601112005:(Body key handlers now call colorizer.interrupt)
#@+node:ekr.20050602081251:(Added patch for tk options)
@

Leo will now look for a file called .leo_xresources' in the users home
directory. If found, Leo will pass that file to Tk's option_readfile method for
the top widget. This allows users to set Tk options.
#@nonl
#@+node:ekr.20050602081251.1:Initial posting
@killcolor
http://sourceforge.net/forum/message.php?msg_id=3181786
By: mackal

The following is a patch for allowing the user to have a configuration file
specifying what fonts to use in menubars, etc.  This is mostly intended for
Linux/UNIX, where the default Tk look is very Motif-like (read "ugly"!).  As
suggested, I might turn this into a plugin once I figure out how to do that,
but for the time being it might be a fix for other Linux users currently suffering.
:)

Although AFAIK TclTk supports the notion of X11 resources with  its option_readfile()
and other option-related commands, I'm not sure whether this has any effect
under Windows, where I believe the native toolkit is used.

Here is the patch:[snip]

Here is a sample resource file I look to give Leo a much "lighter" feel
(to be placed in ~/.leo_xresources):

! X resources to use in Leo
*font:                  -*-helvetica-medium-r-*-*-12-*-*-*-*-*-*-*
*padY:                  0
*borderWidth:           1
*activeBorderWidth:     1

! have to reset the borderWidth back to 0 for dialogs
*Dialog*borderWidth:    0
*Dialog.msg.font:       -*-helvetica-medium-r-*-*-12-*-*-*-*-*-*-*
#@-node:ekr.20050602081251.1:Initial posting
#@+node:ekr.20050328133444:computeStandardDirectories
def computeStandardDirectories():
    
    '''Set g.app.loadDir, g.app.homeDir and g.app.globalConfigDir.'''
    
    g.app.loadDir = g.computeLoadDir()
        # Depends on g.app.tkEncoding: uses utf-8 for now.
    
    g.app.homeDir = g.computeHomeDir()
    
    g.app.extensionsDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','extensions'))
    
    g.app.globalConfigDir = g.computeGlobalConfigDir()
    
    g.app.testDir = g.os_path_abspath(
        g.os_path_join(g.app.loadDir,'..','test'))
        
    g.app.user_xresources_path = g.os_path_join(g.app.homeDir,'.leo_xresources')
#@nonl
#@-node:ekr.20050328133444:computeStandardDirectories
#@+node:ekr.20031218072017.1416:app.__init__
def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.trace = False # True: enable debugging traces.
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.wantedCommander = None # Used by leoTkinterFrame logic to manage calls to g.app.gui.set_focus.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    << Define global constants >>
    << Define global data structures >>
#@nonl
#@+node:ekr.20031218072017.1417:<< define global constants >>
self.prolog_string = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>"

# New in leo.py 3.0
self.prolog_prefix_string = "<?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?>"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
#@-node:ekr.20031218072017.1417:<< define global constants >>
#@+node:ekr.20031218072017.368:<< define global data structures >> app
# Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @>", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "<!-- -->",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
#@-node:ekr.20031218072017.368:<< define global data structures >> app
#@-node:ekr.20031218072017.1416:app.__init__
#@-node:ekr.20050602081251:(Added patch for tk options)
#@+node:ekr.20050618045013.1:(Installed support for PL/SQL language)
#@+node:ekr.20050618045013.17:plsql keywords
plsql_keywords = [
# reserved keywords
"abort",
"accept",
"access",
"add",
"admin",
"after",
"all",
"allocate",
"alter",
"analyze",
"and",
"any",
"archive",
"archivelog",
"array",
"arraylen",
"as",
"asc",
"assert",
"assign",
"at",
"audit",
"authorization",
"avg",
"backup",
"base_table",
"become",
"before",
"begin",
"between",
"binary_integer",
"block",
"body",
"boolean",
"by",
"cache",
"cancel",
"cascade",
"case",
"change",
"char",
"char_base",
"character",
"check",
"checkpoint",
"close",
"cluster",
"clusters",
"cobol",
"colauth",
"column",
"columns",
"comment",
"commit",
"compile",
"compress",
"connect",
"constant",
"constraint",
"constraints",
"contents",
"continue",
"controlfile",
"count",
"crash",
"create",
"current",
"currval",
"cursor",
"cycle",
"data_base",
"database",
"datafile",
"date",
"dba",
"debugoff",
"debugon",
"dec",
"decimal",
"declare",
"default",
"definition",
"delay",
"delete",
"delta",
"desc",
"digits",
"disable",
"dismount",
"dispose",
"distinct",
"distinct",
"do",
"double",
"drop",
"drop",
"dump",
"each",
"else",
"else",
"elsif",
"enable",
"end",
"end",
"entry",
"escape",
"events",
"except",
"exception",
"exception_init",
"exceptions",
"exclusive",
"exec",
"execute",
"exists",
"exists",
"exit",
"explain",
"extent",
"externally",
"false",
"fetch",
"fetch",
"file",
"float",
"float",
"flush",
"for",
"for",
"force",
"foreign",
"form",
"fortran",
"found",
"freelist",
"freelists",
"from",
"from",
"function",
"generic",
"go",
"goto",
"grant",
"group",
"groups",
"having",
"identified",
"if",
"immediate",
"in",
"including",
"increment",
"index",
"indexes",
"indicator",
"initial",
"initrans",
"insert",
"instance",
"int",
"integer",
"intersect",
"into",
"is",
"key",
"language",
"layer",
"level",
"like",
"limited",
"link",
"lists",
"lock",
"logfile",
"long",
"loop",
"manage",
"manual",
"max",
"maxdatafiles",
"maxextents",
"maxinstances",
"maxlogfiles",
"maxloghistory",
"maxlogmembers",
"maxtrans",
"maxvalue",
"min",
"minextents",
"minus",
"minvalue",
"mlslabel",
"mod",
"mode",
"modify",
"module",
"mount",
"natural",
"new",
"new",
"next",
"nextval",
"noarchivelog",
"noaudit",
"nocache",
"nocompress",
"nocycle",
"nomaxvalue",
"nominvalue",
"none",
"noorder",
"noresetlogs",
"normal",
"nosort",
"not",
"notfound",
"nowait",
"null",
"number",
"number_base",
"numeric",
"of",
"off",
"offline",
"old",
"on",
"online",
"only",
"open",
"open",
"optimal",
"option",
"or",
"order",
"others",
"out",
"own",
"package",
"package",
"parallel",
"partition",
"pctfree",
"pctincrease",
"pctused",
"plan",
"pli",
"positive",
"pragma",
"precision",
"primary",
"prior",
"private",
"private",
"privileges",
"procedure",
"procedure",
"profile",
"public",
"quota",
"raise",
"range",
"raw",
"read",
"real",
"record",
"recover",
"references",
"referencing",
"release",
"remr",
"rename",
"resetlogs",
"resource",
"restricted",
"return",
"reuse",
"reverse",
"revoke",
"role",
"roles",
"rollback",
"row",
"rowid",
"rowlabel",
"rownum",
"rows",
"rowtype",
"run",
"savepoint",
"schema",
"scn",
"section",
"segment",
"select",
"select",
"separate",
"sequence",
"session",
"set",
"set",
"share",
"shared",
"size",
"size",
"smallint",
"smallint",
"snapshot",
"some",
"sort",
"space",
"sql",
"sqlbuf",
"sqlcode",
"sqlerrm",
"sqlerror",
"sqlstate",
"start",
"start",
"statement",
"statement_id",
"statistics",
"stddev",
"stop",
"storage",
"subtype",
"successful",
"sum",
"sum",
"switch",
"synonym",
"sysdate",
"system",
"tabauth",
"table",
"tables",
"tables",
"tablespace",
"task",
"temporary",
"terminate",
"then",
"thread",
"time",
"to",
"tracing",
"transaction",
"trigger",
"triggers",
"true",
"truncate",
"type",
"uid",
"under",
"union",
"unique",
"unlimited",
"until",
"update",
"use",
"user",
"using",
"validate",
"values",
"varchar",
"varchar2",
"variance",
"view",
"views",
"when",
"whenever",
"where",
"while",
"with",
"work",
"write",
"xor" ]
#@-node:ekr.20050618045013.17:plsql keywords
#@-node:ekr.20050618045013.1:(Installed support for PL/SQL language)
#@-node:ekr.20050526081733:New features...
#@-node:ekr.20050524073547.1:4.3.1 projects
#@+node:ekr.20050621084408:4.3.2 projects
#@+node:ekr.20050705192437:Bug fixes...
#@+node:ekr.20050705140158:Fixed bug with non-unicode characters in file name
#@+node:ekr.20050705140158.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3224635
By: madmike

Leo doesn't seem to like to read leo-Files which has non-ascii charaters in
the Filename (like "Präsentation.leo"). Trying to do so results in the following
Exception raised:

C:\>D:\Userdata\CH00JAP\Programme\Python\python.exe
D:\Userdata\CH00JAP\Programme\leo\src\leo.py
D:\Userdata\CH00JAP\programming\leo\Präsentation.leo
reading settings in D:\Userdata\CH00JAP\Programme\leo\config\leoSettings.leo
Traceback (most recent call last):
  File "D:\Userdata\CH00JAP\Programme\leo\src\leo.py", line 310, in ?
    run(fileName)
  File "D:\Userdata\CH00JAP\Programme\leo\src\leo.py", line 95, in run
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting
g.app.config.
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 1173,
in readSettingsFiles
    print s ; g.es(s)
  File "D:\Userdata\CH00JAP\Programme\Python\lib\encodings\cp850.py", line 18,
in encode
    return codecs.charmap_encode(input,errors,encoding_map)
UnicodeEncodeError: 'charmap' codec can't encode character u'\ufffd' in position
58: character maps to <undefined>

Renaming the File does work as a workaround.

#@-node:ekr.20050705140158.1:Report
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20041120064303:config.readSettingsFiles
def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                d = self.readSettings(c)
                if d:
                    d['_hash'] = theHash = c.hash()
                    if localFlag:
                        self.localOptionsDict[theHash] = d
                    else:
                        self.localOptionsList.insert(0,d)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)
#@nonl
#@-node:ekr.20041120064303:config.readSettingsFiles
#@-node:ekr.20050705140158:Fixed bug with non-unicode characters in file name
#@+node:ekr.20050705142321:Fixed bug with non-unicode characters in settings value
#@+node:ekr.20050705142321.1:Report
@nocolor 
http://sourceforge.net/forum/message.php?msg_id=3222750
By: madmike

Trying to set non-ascii characters in settingsraises exception on clicking
"OK":

Exception in Tkinter callback
Traceback (most recent call last):
  File "D:\Userdata\CH00JAP\Programme\Python\lib\lib-tk\Tkinter.py", line 1345,
in __call__
    return self.func(*args)
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 1893,
in buttonCallback
    self.onAnyButton(name)
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 2758,
in onAnyButton
    if f: f()
  File "D:\Userdata\CH00JAP\Programme\leo\src\leoConfig.py", line 2977,
in writeChangedVars
    s = "write  %10s -> %10s %s" % (str(oldVal),str(newVal),iname)
UnicodeEncodeError: 'ascii' codec can't encode character u'\xf6' in position
29: ordinal not in range(128)

I've tested this in my own outline local preferences and with the global prefernces
and get the same result.

I've recieve reproduced the error on @string, @path und @directory.


MadMike

#@-node:ekr.20050705142321.1:Report
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20041225063637.65:writeChangedVars & helpers
def writeChangedVars (self):
    
    """Create per-file changes lists from diffs between what has been inited and written.
    
    Call writeChangedList to update each file from items in this list."""

    changedList = []
    fDict = self.fileValueDict
    iDict = self.initValueDict
    munge = g.app.config.munge
    
    for key in iDict.keys():

        iData = iDict.get(key)
        ip,iname,ikind,ival,getValueCallback = iData
        newVal = getValueCallback()
        fData = fDict.get(key)
        if fData:
            fp,fname,fkind,fval,junk = fData
            assert(ip==fp and iname==fname and ikind==fkind)
            changed = fval != newVal ; oldVal = fval
        else:
            changed = ival != newVal ; oldVal = ival
            fval = '<none>'

        if changed:
            # print "write","key","ival",ival,"fval",fval
            if type(oldVal) == type({}):
                s = "write  %s" % (iname)
            elif ikind == 'shortcuts':
                s = 'updating shortcuts in %s' % ip.headString()
            else:
                # Convert unicode strings to strings safe for printing.
                # The calls to str are needed because g.toEncodedString only changes unicode strings.
                strOldVal = str(g.toEncodedString(oldVal,'ascii'))
                strNewVal = str(g.toEncodedString(newVal,'ascii'))
                strIname  = str(g.toEncodedString(iname,'ascii'))
                s = "write  %10s -> %10s %s" % (strOldVal,strNewVal,strIname)
            g.es_print(s,color='blue')
            self.fileValueDict [munge(iname)] = ip,iname,ikind,newVal,getValueCallback
            changedList.append((ip,iname,ikind,oldVal,newVal),)
            
    self.writeChangedList(changedList,"write")
#@nonl
#@+node:ekr.20041225063637.66:updateConfig
def updateConfig(self,c,changes):
    
    """Update the core config settings from the changes list."""
    
    munge = g.app.config.munge

    for data in changes:
        p,name,kind,oldval,val = data
        if munge(kind) == 'font':
            for key in ('family','size','slant','weight'):
                data2 = val.get(key)
                if data2:
                    name2,val2 = data2
                    kind2 = g.choose(key=='size','int','string')
                    g.app.config.set(c,name2,kind2,val2)
            # Update the visible fonts: c may not be the same as self.c.
            for c2 in (c,self.c):
                c2.frame.body.setFontFromConfig()
                c2.frame.body.colorizer.setFontFromConfig()
                c2.frame.log.setFontFromConfig()
                c2.frame.tree.setFontFromConfig()
                c2.redraw()
        elif munge(kind) == "color":
            # g.trace("setting colors")
            g.app.config.set(c,name,kind,val)
            for c2 in (c,self.c):
                c2.frame.tree.setColorFromConfig()
                c2.frame.log.setColorFromConfig()
                c2.frame.body.setColorFromConfig()
        else:
            # g.trace(name,kind,val)
            g.app.config.set(c,name,kind,val)
#@nonl
#@-node:ekr.20041225063637.66:updateConfig
#@+node:ekr.20041225063637.67:updateOneNode & helper
def updateOneNode (self,c,data):
    
    """Update the node in c corresponding to p = data[0]."""
    
    p,name,kind,oldVal,val = data
    munge = g.app.config.munge
    name = name.strip() ; kind = munge(kind.strip())

    # Root1 is the root of the dialog's outline.
    p1 = p
    root1 = self.findSettingsRoot(p1.copy())
    c1 = root1.c
    
    # Root2 is the root of the settings outline in the file.
    root2 = g.app.config.settingsRoot(c) # c is NOT self.c
    p2 = self.findCorrespondingNode(root1.copy(),root2.copy(),p1.copy())
    if p2:
        c2 = p2.c ; filename = c2.mFileName
    else:
        g.trace("can't happen: can't find node in root2:",root2.c.mFileName)
        g.trace('root1',root1)
        g.trace('root2',root2)
        g.trace('p1',p1)
        c2 = None ; filename = None

    # Update the outline in the dialog and the target file.
    for p,c,where in ((p1,c1,"dialog"),(p2,c2,filename)):
        if p:
            # g.trace("updating %s in %s" % (name,where))
            if kind == 'shortcuts':
                # Just put the new the values in the body.
                p.setBodyStringOrPane(val)
            elif kind == 'font':
                body = self.computeBodyFromFontDict(val)
                p.setBodyStringOrPane(body)
            else:
                # Put everything in the headline.
                p.initHeadString("@%s %s = %s" % (kind,name,val))
#@nonl
#@+node:ekr.20041225063637.68:computeBodyFromFontDict
def computeBodyFromFontDict(self,d):

    lines = []
    comments = d.get('comments')
    if comments:
        comment_lines = g.splitLines(comments)
        comment_lines = ["# %s" % (line) for line in comment_lines]
        lines.extend(comment_lines)
        lines.extend('\n\n')
        
    for key in ('family','size','slant','weight'):
        data = d.get(key)
        if data:
            name,val = data
            if val in (None,'<none>'):
                val = "None"
            line = "%s = %s\n" % (name,val)
            lines.extend(line)

    body = ''.join(lines)
    return body
#@nonl
#@-node:ekr.20041225063637.68:computeBodyFromFontDict
#@-node:ekr.20041225063637.67:updateOneNode & helper
#@+node:ekr.20041225063637.69:writeChangedList
def writeChangedList (self,changedList,tag):
    
    __pychecker__ = '--no-argsused' # tag used for debugging.
    
    filesInfoDict = self.filesInfoDict
    if 0:
        << dump all the dicts in filesInfoDict >>

    # Accumulate the changes for each file in a 'changes' list for each root.
    for data in changedList:
        p,name,kind,oldVal,newVal = data
        # print "%6s %6s %10s -> %10s %s" % (tag,kind,str(oldVal),str(newVal),name)
        root = self.findSettingsRoot(p)
        d = filesInfoDict.get(root)
        changes = d.get('changes')
        changes.append(data)
        d['changes'] = changes

    for root in filesInfoDict.keys():
        d = filesInfoDict.get(root)
        # Keys are 'c','changes','path','islocal' (unused)
        c = d.get('c')
        changes = d.get('changes')
        path = d.get('path')
        # Always write the file so as to preserve expansion state.
        self.writeChangesToFile(c,changes,path)
        self.updateConfig(c,changes)
        d['changes'] = []
#@nonl
#@+node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
for key in filesInfoDict.keys():
    print ; print
    print "key",key
    g.printDict(filesInfoDict.get(key))
print ; print
#@nonl
#@-node:ekr.20041225063637.70:<< dump all the dicts in filesInfoDict >>
#@-node:ekr.20041225063637.69:writeChangedList
#@+node:ekr.20041225063637.71:writeChangesToFile
def writeChangesToFile (self,c,changes,path):

    # Write the individual changes.
    for data in changes:
        self.updateOneNode(c,data)
        
    # Copy the expansion state of the dialog to the file.
    for d in self.filesInfoDict.values():
        c2 = d.get('c')
        if c2 and c2 == c:
            p2 = d.get('p')
            p = g.app.config.settingsRoot(c)
            # g.trace(c,p)
            if p and p2:
                p = p.copy() ; p2 = p2.copy()
                # Defensive programming: don't assume p and p2 are in synch.
                while p and p2:
                    if p2.isExpanded(): p.expand()
                    else: p.contract()
                    p.moveToThreadNext()
                    p2.moveToThreadNext()
            break

    if c.fileName():
        self.es("writing " + g.shortFilename(path))
        # Save the file corresponding to c.
        # Non-local files aren't open otherwise!
        c.fileCommands.save(c.fileName())
        c.redraw() # This should work for non-local files too.
        self.tree.redraw()
    else:
        print "no settings saved.  local file not named."
#@nonl
#@-node:ekr.20041225063637.71:writeChangesToFile
#@-node:ekr.20041225063637.65:writeChangedVars & helpers
#@-node:ekr.20050705142321:Fixed bug with non-unicode characters in settings value
#@+node:ekr.20050706081854:Fixed two recent files bugs
#@+node:ekr.20050706081854.1:Report
@nocolor 
http://sourceforge.net/forum/message.php?msg_id=3218558
By: billp9619

Leo Log Window...
Leo 4.3.1, build  1.266 , June 20, 2005
Python 2.3.4, Tk 8.4.3, win32

On a new install with no prior Recent Files, I opened a file without saving
and exited Leo. On return there were still no Recent Files listed.

I opened another file and saved under a different name. After exiting leo and
restarting, the different name saved did not appear listed but the original
opened file was.I guess both should have been listed.

My preference for Recent Files list is that there would be a very long history
maintained and any file name I view is in the the list. :)

I guess you need to update the list anytime a name is dropped from the open
widow status including if the current open file is Closed or superceded using
Save As.

regards,

bill p
#@-node:ekr.20050706081854.1:Report
#@+node:ekr.20031218072017.2835:saveAs
def saveAs(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
#@nonl
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
#@nonl
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20050424114937.2:writeRecentFilesFile & helper
def writeRecentFilesFile (self,c):
    
    '''Write the appropriate .leoRecentFiles.txt file.'''
    
    tag = '.leoRecentFiles.txt'
    
    localFileName = c.fileName()
    if not localFileName:
        # g.trace('----no file name')
        return
        
    # Create a list of bunches to control the comparison below.
    files = []
    for fileName,kind in (
        (localFileName,'local'),
        (self.homeFile,'home'),
        (self.globalConfigFile,'global'),
    ):
        if fileName:
            path,junk = g.os_path_split(fileName)
            files.append(g.Bunch(
                fileName=g.os_path_join(path,tag),kind=kind))

    # Search local file first, then home and global files.                
    for kind in ('local','home','global'):
        for bunch in files:
            for bunch2 in self.recentFilesFiles:
                if bunch.kind == bunch2.kind:
                    # g.trace('----- comparing',bunch.kind,bunch.fileName)
                    if bunch.fileName == bunch2.fileName:
                        self.writeRecentFilesFileHelper(bunch.fileName)
                        return
                    
    # g.trace('----- not found:',localFileName)
#@nonl
#@+node:ekr.20050424131051:writeRecentFilesFileHelper
def writeRecentFilesFileHelper (self,fileName):
    # g.trace(fileName)
    
    # Don't update the file if it begins with read-only.
    theFile = None
    try:
        theFile = file(fileName)
        lines = theFile.readlines()
        if lines and self.munge(lines[0])=='readonly':
            # g.trace('read-only: %s' %fileName)
            return
    except IOError:
        # The user may have erased a file.  Not an error.
        if theFile: theFile.close()

    theFile = None
    try:
        # g.trace('writing',fileName)
        theFile = file(fileName,'w')
        if self.recentFiles:
            theFile.write('\n'.join(self.recentFiles))
        else:
            theFile.write('\n')

    except IOError:
        # The user may have erased a file.  Not an error.
        pass
            
    except Exception:
        g.es('unexpected exception writing %s' % fileName,color='red')
        g.es_exception()
    
    if theFile:
        theFile.close()
#@nonl
#@-node:ekr.20050424131051:writeRecentFilesFileHelper
#@-node:ekr.20050424114937.2:writeRecentFilesFile & helper
#@+node:ekr.20031218072017.2609:app.closeLeoWindow
def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False
        
    g.app.config.writeRecentFilesFile(c) # Make sure .leoRecentFiles.txt is written.

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        g.app.setLog(w.log)
    else:
        g.app.finishQuit()

    return True # The window has been closed.
#@nonl
#@-node:ekr.20031218072017.2609:app.closeLeoWindow
#@-node:ekr.20050706081854:Fixed two recent files bugs
#@+node:ekr.20050825081645:Fixed bug in g.reportBadChars
#@+node:ekr.20050825084513:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3307318
By: zhms

Error in tangling when section name contain unicode.

reading: D:\doc\digest\buddha\amtb\amtb.leo
Tangling...
exception executing command
Traceback (most recent call last):
  File "C:\tool\Leo\src\leoCommands.py", line 177, in doCommand
    command()
  File "C:\tool\Leo\src\leoCommands.py", line 889, in tangle
    c.tangleCommands.tangle()
  File "C:\tool\Leo\src\leoTangle.py", line 604, in tangle
    if not self.tangleTree(p,report_errors):
  File "C:\tool\Leo\src\leoTangle.py", line 744, in tangleTree
    self.tanglePass2() # self.p invalid in pass 2.
  File "C:\tool\Leo\src\leoTangle.py", line 712, in tanglePass2
    self.put_all_roots() # pass 2 top level function.
  File "C:\tool\Leo\src\leoTangle.py", line 1466, in put_all_roots
    self.put_part_node(part,False) # output first lws
  File "C:\tool\Leo\src\leoTangle.py", line 1782, in put_part_node
    self.put_code(part.code,no_first_lws_flag)
  File "C:\tool\Leo\src\leoTangle.py", line 1525, in put_code
    self.put_section(s,i,name,name_end)
  File "C:\tool\Leo\src\leoTangle.py", line 1907, in put_section
    self.put_part_node(part,no_first_leading_ws_flag)
  File "C:\tool\Leo\src\leoTangle.py", line 1782, in put_part_node
    self.put_code(part.code,no_first_lws_flag)
  File "C:\tool\Leo\src\leoTangle.py", line 1525, in put_code
    self.put_section(s,i,name,name_end)
  File "C:\tool\Leo\src\leoTangle.py", line 1879, in put_section
    self.os(self.single_comment_string) ; self.oblank() ; self.os(name)
  File "C:\tool\Leo\src\leoTangle.py", line 1382, in os
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
  File "C:\tool\Leo\src\leoGlobals.py", line 3603, in toEncodedString
    g.reportBadChars(s,encoding)
  File "C:\tool\Leo\src\leoGlobals.py", line 3582, in reportBadChars
    g.es("%d errors converting %s to %s" %
UnicodeDecodeError: 'ascii' codec can't decode byte 0xcc in position 23: ordinal
not in range(128)
#@-node:ekr.20050825084513:Report
#@+node:ekr.20031218072017.1498:Unicode utils...
#@+node:ekr.20031218072017.1499:isUnicode
def isUnicode(s):
    
    return s is None or type(s) == type(u' ')
#@nonl
#@-node:ekr.20031218072017.1499:isUnicode
#@+node:ekr.20031218072017.1500:isValidEncoding
def isValidEncoding (encoding):
    
    try:
        if len(encoding) == 0:
            return False
        unicode("a",encoding)
        return True
    except:
        return False
#@-node:ekr.20031218072017.1500:isValidEncoding
#@+node:ekr.20031218072017.1501:reportBadChars
def reportBadChars (s,encoding):
    
    errors = 0
    if type(s) == type(u""):
        for ch in s:
            try: ch.encode(encoding,"strict")
            except UnicodeEncodeError:
                errors += 1
        if errors:
            g.es("%d errors converting %s to %s" % (
                errors, s.encode(encoding,'replace'),
                encoding.encode('ascii','replace')),
            color='red')
    elif type(s) == type(""):
        for ch in s:
            try: unicode(ch,encoding,"strict")
            except: errors += 1
        if errors:
            g.es("%d errors converting %s (%s encoding) to unicode" % (
                errors,
                unicode(s,encoding,'replace'),
                encoding.encode('ascii','replace')),
            color='red')
#@nonl
#@+node:ekr.20050825092149:test_g_reportBadChars
def test_g_reportBadChars ():
    
    for s,encoding in (
        ('aĂbĂ',  'ascii'),
        (u'aĂbĂ', 'ascii'),
        ('炰',    'ascii'),
        (u'炰',   'ascii'),
        
        ('aĂbĂ',  'utf-8'),
        (u'aĂbĂ', 'utf-8'),
        ('炰',    'utf-8'),
        (u'炰',   'utf-8'),
    ):
    
        g.reportBadChars(s,encoding)
#@nonl
#@-node:ekr.20050825092149:test_g_reportBadChars
#@-node:ekr.20031218072017.1501:reportBadChars
#@+node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20050208093800:toEncodedString
def toEncodedString (s,encoding,reportErrors=False):

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = s.encode(encoding,"replace")
    return s
#@nonl
#@-node:ekr.20050208093800:toEncodedString
#@+node:ekr.20050208093903:toEncodedStringWithErrorCode
def toEncodedStringWithErrorCode (s,encoding):
    
    ok = True

    if type(s) == type(u""):
        try:
            s = s.encode(encoding,"strict")
        except UnicodeError:
            s = s.encode(encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208093903:toEncodedStringWithErrorCode
#@+node:ekr.20050208093800.1:toUnicode
def toUnicode (s,encoding,reportErrors=False):
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            if reportErrors:
                g.reportBadChars(s,encoding)
            s = unicode(s,encoding,"replace")
    return s
    
#@-node:ekr.20050208093800.1:toUnicode
#@+node:ekr.20050208095723:toUnicodeWithErrorCode
def toUnicodeWithErrorCode (s,encoding):
    
    ok = True
    
    if s is None:
        s = u""
    if type(s) == type(""):
        try:
            s = unicode(s,encoding,"strict")
        except UnicodeError:
            s = unicode(s,encoding,"replace")
            ok = False

    return s,ok
#@nonl
#@-node:ekr.20050208095723:toUnicodeWithErrorCode
#@+node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
def test_round_trip_toUnicode_toEncodedString ():
   
    for s,encoding in (
        ('a',    'utf-8'),
        ('a',    'ascii'),
        ('äöü',  'utf-8'),
        ('äöü',  'mbcs'),
        ('炰',   'utf-8'),
        ('炰',   'mbcs'),
    ):
        if g.isValidEncoding(encoding):
            s2,ok = g.toUnicodeWithErrorCode(s,encoding)
            assert ok, 'toUnicodeWithErrorCode fails for %s' %s
            s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
            assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
            assert s3 == s, 'Round-trip one failed for %s' %s
            
            s2 = g.toUnicode(s,encoding)
            s3 = g.toEncodedString(s2,encoding)
            assert s3 == s, 'Round-trip two failed for %s' %s
#@nonl
#@-node:ekr.20050208104358:test_round_trip_toUnicode_toEncodedString
#@+node:ekr.20050208112123:test_failure_with_ascii_encodings
def test_failure_with_ascii_encodings():

    encoding = 'ascii'
    
    s = '炰'
    s2,ok = g.toUnicodeWithErrorCode(s,encoding)
    assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s
    
    s = u'炰'
    s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
    assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s
#@nonl
#@-node:ekr.20050208112123:test_failure_with_ascii_encodings
#@-node:ekr.20031218072017.1502:toUnicode & toEncodedString (and tests)
#@+node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
# Suppress warning about redefining getpreferredencoding
__pychecker__ = '--no-reuseattr'

try:
    # Use Python's version of getpreferredencoding if it exists.
    # It is new in Python 2.3.
    import locale
    getpreferredencoding = locale.getpreferredencoding
except Exception:
    # Use code copied from locale.py in Python 2.3alpha2.
    if sys.platform in ('win32', 'darwin', 'mac'):
        << define getpreferredencoding using _locale >>
    else:
        << define getpreferredencoding for *nix >>
        
__pychecker__ = '--reuseattr'
#@+node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
# On Win32, this will return the ANSI code page
# On the Mac, it should return the system encoding;
# it might return "ascii" instead.

def getpreferredencoding(do_setlocale = True):
    """Return the charset that the user is likely using."""
    try:
        import _locale
        return _locale._getdefaultlocale()[1]
    except:
        return None
#@nonl
#@-node:ekr.20031218072017.1504:<< define getpreferredencoding using _locale >>
#@+node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
# On Unix, if CODESET is available, use that.

__pychecker__ = '--no-noeffect' # Note: this is at the top level!

try:
    locale.CODESET # Bug fix, 2/12/05
except NameError:
    # Fall back to parsing environment variables :-(
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        by looking at environment variables."""
        try:
            return locale.getdefaultlocale()[1]
        except:
            return None
else:
    def getpreferredencoding(do_setlocale = True):
        """Return the charset that the user is likely using,
        according to the system configuration."""
        try:
            if do_setlocale:
                oldloc = locale.setlocale(LC_CTYPE)
                locale.setlocale(LC_CTYPE, "")
                result = locale.nl_langinfo(CODESET)
                locale.setlocale(LC_CTYPE, oldloc)
                return result
            else:
                return locale.nl_langinfo(CODESET)
        except:
            return None
#@nonl
#@-node:ekr.20031218072017.1505:<< define getpreferredencoding for *nix >>
#@-node:ekr.20031218072017.1503:getpreferredencoding from 2.3a2
#@-node:ekr.20031218072017.1498:Unicode utils...
#@-node:ekr.20050825081645:Fixed bug in g.reportBadChars
#@+node:ekr.20050723093228:Fixed minor crash in colorizer
#@+node:ekr.20050825095048:What I did
@nocolor

The fix was to add an entry of 'unknown' state to state_dict. This fixes the
crash by brute force, but may not be strictly correct. However, this is pretty
much moot: we shall soon be moving to the new colorizer.
#@nonl
#@-node:ekr.20050825095048:What I did
#@+node:ekr.20050723093228.1:Traceback
Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoColor.py", line 1688, in colorizeAnyLanguage
    state = self.colorizeLine(new_lines[i],state)
  File "C:\prog\leoCVS\leo\src\leoColor.py", line 1803, in colorizeLine
    func = self.state_dict[state]
KeyError: 'unknown'
#@-node:ekr.20050723093228.1:Traceback
#@+node:ekr.20031218072017.1607:<< define dispatch dicts >>
self.state_dict = {
    "blockComment" : self.continueBlockComment,
    "doubleString" : self.continueDoubleString, # 1/25/03
    "nocolor"      : self.continueNocolor,
    "normal"       : self.doNormalState,
    "singleString" : self.continueSingleString,  # 1/25/03
    "string3s"     : self.continueSinglePythonString,
    "string3d"     : self.continueDoublePythonString,
    "doc"          : self.continueDocPart,
    "unknown"      : self.doNormalState, # 8/25/05
}
    
# Eventually all entries in these dicts will be entered dynamically
# under the control of the XML description of the present language.

if 0: # not ready yet.

    self.dict1 = { # 1-character patterns.
        '"' : self.doString,
        "'" : self.doString,
        '@' : self.doPossibleLeoKeyword,
        ' ' : self.doBlank,
        '\t': self.doTab }

    self.dict2 = {} # 2-character patterns
    
    # Searching this list might be very slow!
    mutli_list = [] # Multiple character patterns.
    
    # Enter single-character patterns...
    if self.has_pp_directives:
        dict1 ["#"] = self.doPPDirective
                
    for ch in string.ascii_letters:
        dict1 [ch] = self.doPossibleKeyword
    dict1 ['_'] = self.doPossibleKeyword
    
    if self.language == "latex":
        dict1 ['\\'] = self.doPossibleKeyword
        
    if self.language == "php":
        dict1 ['<'] = self.doSpecialPHPKeyword
        dict1 ['?'] = self.doSpecialPHPKeyword
    
    # Enter potentially multi-character patterns.  (or should this be just 2-character patterns)
    if self.language == "cweb":
        dict2 ["@("] = self.doPossibleSectionRefOrDef
    else:
        dict2 ["<<"] = self.doPossibleSectionRefOrDef
        
    if self.single_comment_start:
        n = len(self.single_comment_start)
        if n == 1:
            dict1 [self.single_comment_start] = self.doSingleCommentLine
        elif n == 2:
            dict2 [self.single_comment_start] = self.doSingleCommentLine
        else:
            mutli_list.append((self.single_comment_start,self.doSingleCommentLine),)
    
    if self.block_comment_start:
        n = len(self.block_comment_start)
        if n == 1:
            dict1 [self.block_comment_start] = self.doBlockComment
        elif n == 2:
            ddict2 [self.block_comment_start] = self.doBlockComment
        else:
            mutli_list.append((self.block_comment_start,self.doBlockComment),)
#@nonl
#@-node:ekr.20031218072017.1607:<< define dispatch dicts >>
#@-node:ekr.20050723093228:Fixed minor crash in colorizer
#@+node:ekr.20050825101028:Protected several methods used by plugin manager
@nocolor

The code gets c = keywords.get('c') in several places.
The protection is to return if c is None.

This affects the following files: plugins_menu.py, pluginsTest.py, plugin_manager.py
#@nonl
#@-node:ekr.20050825101028:Protected several methods used by plugin manager
#@+node:ekr.20050704090830:Added test files to distribution list and cvs
@

- Only files used by unit tests should be on cvs and the distribution.
    - test\unittest\batchTest.py and test\unittest\errorTest.py were already on cvs.
    - Added these files to the distribution.
- Other test files should be distributed in @ignore nodes.
- Leo's distribution checklist now has an item to check that the distributed test.leo can be opened without errors.
#@nonl
#@+node:ekr.20050830051128:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3231597
By: edcdave

After uninstalling my earlier version of Leo and deleting all files, I installed
Leo 4.3.1 Build 1.266. (Python 2.3.3)

Making no other changes or installing any other files, I opened leo/test/test.leo.
The document opens with the following errors:

fixed:
    can not open: '@file C:\Program Files\Leo\extensions\testExtension.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest2.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest3.py'
    can not open: '@file C:\Program Files\Leo\test\leadingAtTest4.py'

Add to distribution list (and cvs)
    can not open: '@file C:\Program Files\Leo\test\unittest\errorTest.py'
    can not open: '@file C:\Program Files\Leo\test\unittest\batchTest.py'

And sure enough none of these files are in leo/test and the directory
leo/test/unittest was not created by the installation.

Dave
#@-node:ekr.20050830051128:Report
#@-node:ekr.20050704090830:Added test files to distribution list and cvs
#@+node:ekr.20050801102407:Investigated bug report: dead link for leoPy.leo in help menu: not a problem
@ This does not seem to be a problem.

Leo is distributed with the expected file names for LeoDocs.leo, LeoPy.leo, LeoPluings.leo.
#@nonl
#@+node:ekr.20050801102407.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3274505
By: ktenney

I like that, a nice way to access the source 
without risking unwanted changes.

Does the same principle apply to 
LeoPy.leo/LeoPyRef.leo ?

Didn't there used to be an entry for leoPy.leo 
on the 'Help' menu?

That means that Leo ships with a dead link on the 
'Help' menu, I wonder how we could make sure the
 reason for that is explained.

We don't want to cause discouragement among folks
wanting to dive into the source.

Maybe the menu text could be;
leoPlugins.leo (leoPluginsRef.leo save as)
leoPy.leo (leoPyRef.leo save as)
... must be a better way ...

Thanks,
Kent
#@-node:ekr.20050801102407.1:Report
#@+node:ekr.20050802082948:Post 2
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3274666
By: ktenney

Maybe the menu item could be 'Leo plugins source'

When selected, create leoPlugins.leo if required, explaining that this is a safe
copy of the source file.

An entry which behaved like this called 'Leo source' which did the same routine
with LeoPy.leo might be nice for folks in the 'Use the source, Luke' category.
#@nonl
#@-node:ekr.20050802082948:Post 2
#@-node:ekr.20050801102407:Investigated bug report: dead link for leoPy.leo in help menu: not a problem
#@+node:ekr.20050906192101:Fixed bug in mod_spelling
# Sometimes the word wasn't selected properly.
#@nonl
#@-node:ekr.20050906192101:Fixed bug in mod_spelling
#@+node:ekr.20050721095052:Investigated problems with outline colors: works for me
#@+node:ekr.20050721095052.1:Post 1
http://sourceforge.net/forum/message.php?msg_id=3247013
By: rich_ries

First, I D/L'd all the 'stuff' I could find in CVS, making sure none of the
files were older than the LeoPy.leo file.

CLEO - Nice! But I can't clear the priority marks.

Group Operations - I _used_ to be able to use keypresses Alt+Shift+M/V/C/T/~
to Mark/Move/Copy/Tag/Clone, which was a LOT easier than playing with the mouse.
(Try Tagging three sequential nodes. Previously, it was Alt+Shift+T, Alt+Shift+T,
Alt+Shift+T. Now it's Move-Mouse-to-location+ click+ Move-Mouse-to-another-location+
Move-Mouse-to-another-location+ click JUST TO TAG ONE NODE! Now try doing that
for  THREE nodes -- let alone the dozen I usually work with!

I have (amongst other plugins) Nav_Buttons, NodeBar, and Hoist turned on, and
it's a gamble regarding which button(s) will be full-sized, and which ones
half-sized. NodeBar's 'about' claims to add buttons "to the bottom of the tree
canvas", yet they are up with the other buttons.

When I open an empty .LEO file, the focus is on the body pane. I press a key
to start entering text, but after the first character, I'm in the Outline Pane,
_adding_ text to "NewHeadline".

--Rich
#@nonl
#@-node:ekr.20050721095052.1:Post 1
#@+node:ekr.20050721095052.2:Post 2
http://sourceforge.net/forum/message.php?msg_id=3248719
By: nobody

From: Rich

Nit:
Outline Pane Colors goes background/foreground until headline_text_editing_selection,
which is then reversed: foreground/background. Similar thing with the Log Pane
Colors. Changing leoSettings.leo corrected this.

Hitting [ESC] no longer exits the editing mode.

Also, running Preferences & clicking [OK] seems to have no effect, at least
on the colors. If this is a case of "exit to enable" a message should be shown
in BIG NEON LETTERS indicating this: It's an important functional detail, but
I shouldn't need to remember it -- the computer can do that very nicely.

Try as I can, I can not change the headline_text_unselected_background_color.
It is stuck on white, and white it SHALL remain!

--Rich
#@nonl
#@-node:ekr.20050721095052.2:Post 2
#@+node:ekr.20050831130936:Post 3
http://sourceforge.net/forum/message.php?msg_id=3260433
By: nobody

From: Rich
I get the names from the color-selector, and I am careful with the case.
Here are my outline pane colors:
+ @page Outline pane colors
- @color outline_pane_background_color = AntiqueWhite1
- @color headline_text_unselected_foreground_color = black
- @color headline_text_unselected_background_color = AntiqueWhite1
- @color headline_text_selected_foreground_color = black
- @color headline_text_selected_background_color = AntiqueWhite3
- @color headline_text_editing_foreground_color = blue
- @color headline_text_editing_background_color = white
- @color headline_text_editing_selection_foreground_color = black
- @color headline_text_editing_selection_background_color = blue

And what I see:
New file comes up w/ Blue on White for "New Headline"
Pressing the first key changes the headline to Black on Blue, and brings the
cursor/focus up to the headline.
Pressing [Enter] to go back to the body pane sets the headkine to Black
on AntiqueWhite3.
Adding another node sets the first headline to Black on White, and the second
headline to Black on Blue, with the cursor/focus on the headline.

I also tried restoring the order of the names to their original locations just
in case this would have an effect. No difference.

--Rich
#@-node:ekr.20050831130936:Post 3
#@-node:ekr.20050721095052:Investigated problems with outline colors: works for me
#@+node:ekr.20050909113245.4:Investigated problems with *some* settings (still works for me)
#@+node:ekr.20050909113245.5:Report
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3331806
By: nobody

From: Rich
Further tests

I changed leoSettings to:

+ @page Outline pane colors
   - @color headline_text_unselected_background_color = black
   - @color headline_text_unselected_foreground_color = brown

   - @color headline_text_selected_background_color = red
   - @color headline_text_selected_foreground_color = orange
   - @color headline_text_editing_background_color = yellow
   - @color headline_text_editing_foreground_color = green
   - @color headline_text_editing_selection_foreground_color = blue
   - @color headline_text_editing_selection_background_color = purple
   - @color outline_pane_background_color = AntiqueWhite1

saved the file, and opened a new (empty) .leo file. I would expect the colors
to follow the scheme in config\leoSettings.leo. However, what I got was:

+ @page Outline pane colors
   - @color headline_text_unselected_background_color = white
   - @color headline_text_unselected_foreground_color = black

   - @color headline_text_selected_background_color = red
   - @color headline_text_selected_foreground_color = orange
   - @color headline_text_editing_background_color = yellow
   - @color headline_text_editing_foreground_color = green
   - @color headline_text_editing_selection_foreground_color = blue
   - @color headline_text_editing_selection_background_color = purple
   - @color outline_pane_background_color = AntiqueWhite1

That is, everything changed _except_ the unselected background and foreground
colors!? When I hit Ctrl-Y, the UBG/UFG colors changed to black/brown, thereby
matching the @settings selection. Hitting [Apply] and closing the preferences
window brought UBG/UFG back to white/black.

--Rich


______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226

#@-node:ekr.20050909113245.5:Report
#@-node:ekr.20050909113245.4:Investigated problems with *some* settings (still works for me)
#@-node:ekr.20050705192437:Bug fixes...
#@+node:ekr.20050705192437.1:New & improved features...
#@+node:ekr.20050706090801:(Added g.es_print, es_trace & eliminate corresponding print statements)
@ Calling print directly is dangerous: it will fail for unicode characters.
#@nonl
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):
    
    print g.toEncodedString(s,'ascii')
    g.es(s,*args,**keys)
    
def test_g_es_print():
    
    g.es_print('\ntest of es_print: Ă',color='red')
#@nonl
#@-node:ekr.20050707064040:es_print & test
#@+node:ekr.20050707065530:es_trace & test
def es_trace(s,*args,**keys):
    
    g.trace(g.toEncodedString(s,'ascii'))
    g.es(s,*args,**keys)
    
def test_g_es_trace():
    
    g.es_trace('\ntest of es_trace: Ă',color='red')
#@nonl
#@-node:ekr.20050707065530:es_trace & test
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20041225063637.76:printChangedVars
def printChangedVars (self):

    d = self.initValueDict
    
    for key in d.keys():
        
        data = d.get(key)
        p,name,kind,val,getValueCallback = data
        newVal = getValueCallback()
        
        if val != newVal:
            name   = str(g.toEncodedString(name))
            val    = str(g.toEncodedString(val))
            newVal = str(g.toEncodedString(newVal))
            print "%10s -> %10s %s" % (val,newVal,name)
#@nonl
#@-node:ekr.20041225063637.76:printChangedVars
#@-node:ekr.20050706090801:(Added g.es_print, es_trace & eliminate corresponding print statements)
#@+node:ekr.20050726101110.1:(Improved PrettyPrinting)
#@+node:ekr.20050726130115:What I did
@nocolor

- Strip trailing blanks in get.
- Many improvement to doOp.
- Improved DoMultiline:
    - Added special case logic to ensure '#' is preceded by space except at start of line.
    - Added blank after multi-line string if needed.
- Added lastName token for special-case handling depending on previous token.
- No change to put, putArray or doName.
#@nonl
#@-node:ekr.20050726130115:What I did
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20050729211526:prettyPrintPythonNode
def prettyPrintPythonNode (self,p=None,dump=False):

    c = self
    
    if not p:
        p = c.currentPosition()
    
    pp = c.prettyPrinter(c)

    # Unlike scanDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20050729211526:prettyPrintPythonNode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next text by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.
    
    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
    
    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine (strings, etc).
#@+node:ekr.20041021101911.5:doName
def doName(self):
    
    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@nonl
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and prev[-1] not in string.digits + string.letters:
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.
    
    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
    
    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine (strings, etc).
#@+node:ekr.20041021101911.5:doName
def doName(self):
    
    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@nonl
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and prev[-1] not in string.digits + string.letters:
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@-node:ekr.20050726101110.1:(Improved PrettyPrinting)
#@+node:ekr.20050906081155:Added leoPostings.leo to distribution
#@-node:ekr.20050906081155:Added leoPostings.leo to distribution
#@+node:ekr.20050711185846.1:Installed patch for xemacs plugin from mackal
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3219471
By: mackal

Here's a simple patch to have this plugin work in Linux:

*** xemacs.py.orig Sat Jun 25 19:12:52 2005
--- xemacs.py Sat Jun 25 19:15:15 2005
***************
*** 51,54 ****
--- 51,64 ----
      # This path must not contain blanks in XP.  Sheesh.
      _emacs_cmd = r"c:\XEmacs\XEmacs-21.4.13\i586-pc-win32\xemacs.exe"
+ elif sys.platform.startswith("linux"):
+     clients = ["gnuclient", "emacsclient", "xemacs"]
+     _emacs_cmd = ""
+     for cl in clients:
+         path = "/usr/bin/"+cl
+         if os.path.exists(path):
+             _emacs_cmd = path
+             break
+     if not _emacs_cmd:
+         print>> sys.stderr, "Unable to locate a usable version of *Emacs"
  else:
      _emacs_cmd = "/Applications/Emacs.app/Contents/MacOS/bin/emacsclient"
#@nonl
#@-node:ekr.20050711185846.1:Installed patch for xemacs plugin from mackal
#@+node:JSBiz.20050817134120:Installed patches for vim, openWith: Jim Sizelove
#@+node:JSBiz.20050817145837:Problems spawning gVim, and the solutions I came up with.
@nocolor

I was trying to get Leo to work more effectively with Vim, my editor of choice.
To do so, I made several changes to Leo which (I believe) make it work better.

After much exploring and trying various things, I made a change to the os.spawnv
section of the openWith function in leoCommands.py. This added line seems to
prevent the "weird error message on first open of Vim." (vim.py, line 32) when
opening Vim with os.spawnv.

os.spawnv needs the command it is calling as the first argument in the args list
in addition, so the command actually shows twice in the total args to os.spawnv,
e.g.::
    
    os.spawnv(os.P_NOWAIT, "C:/Program Files/Vim/vim63/gvim.exe",
        ["gvim.exe", "--servername", "LEO", "--remote", "foo.txt"])
    
If the call is made without the command-name as the first item in the list of
args, like so::
    
    os.spawnv(os.P_NOWAIT, "C:/Program Files/Vim/vim63/gvim.exe",
        ["--servername", "LEO", "--remote", "foo.txt"])

an error message pops up::
    
    E247: no registered server named "GVIM": Send failed.  Trying to execute locally
    
This message means that gVim is not looking for a server named "LEO", which
presumably the user has already opened with the command "gvim --servername LEO".
Instead it is looking for a server named "GVIM", and not finding it, opens the
files "foo.txt" and "LEO" (notice that it didn't catch the "--servername"
argument and thinks that "LEO" is the name of a new file to create) in two
buffers in a local copy of gVim. Now, if the command is::

    os.spawnv(
        os.P_NOWAIT, "C:/Program Files/Vim/vim63/gvim.exe",
        ["gvim.exe", "--servername", "LEO", "--remote", "foo.txt"])

everything works great, as long as the user doesn't close the gVim window. If
the user has closed the gVim window, then tries to open a node in Vim, they will
see this error message::

    E247: no registered server named "LEO": Send failed.

Trying to execute locally If you use the "--remote-silent" argument, gVim will
start the LEO server without the error message.

One other comment:  you can see which servers gVim has running by typing::

    vim --serverlist

at the command prompt.
#@nonl
#@-node:JSBiz.20050817145837:Problems spawning gVim, and the solutions I came up with.
#@+node:JSBiz.20050817145837.1:Using the subprocess module from Python 2.4
@nocolor

The rest of my changes have to do with using the subprocess module instead of
the os.system, and various os.spawn* calls. I find subprocess easier to
understand, and it is fairly simple to use for the most common kinds of process
calls, but is capable of all the variations you may need. It is designed to
replace all the os.system, os.spawn*, and popen* calls. It is available in
Python 2.4.

So I added some lines to use subprocess in the OpenWith plugin and the Vim
plugin. I also have added a table in the "create_open_with_menu" function that
makes use of the various editors I have used at times. Most of those editors are
called with subprocess.Popen.
#@nonl
#@-node:JSBiz.20050817145837.1:Using the subprocess module from Python 2.4
#@+node:ekr.20040712045933:<< imports  >> (leoCommands)
import leoGlobals as g

if g.app and g.app.use_psyco:
    # print "enabled psyco classes",__file__
    try: from psyco.classes import *
    except ImportError: pass

import leoAtFile
import leoConfig
import leoEditCommands
import leoFileCommands
import leoKeys
import leoImport
import leoNodes
import leoTangle
import leoUndo

import compiler # for Check Python command
import keyword
import os
import parser # needed only for weird Python 2.2 parser errors.
import string

# Bug fix: 9-16-05
subprocess = g.importExtension('subprocess',None,verbose=False)

import sys
import tempfile

import tabnanny # for Check Python command
import tokenize # for Check Python command

# The following import _is_ used.
__pychecker__ = '--no-import'
import token    # for Check Python command
#@nonl
#@-node:ekr.20040712045933:<< imports  >> (leoCommands)
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@-node:JSBiz.20050817134120:Installed patches for vim, openWith: Jim Sizelove
#@+node:ekr.20050910103843:added aspell23.pyd and aspell24.pyd to Leo's extension folder
@nocolor

See the installation nodes in the docstring for the spellpyx plugin for how to use these files.
#@nonl
#@-node:ekr.20050910103843:added aspell23.pyd and aspell24.pyd to Leo's extension folder
#@-node:ekr.20050705192437.1:New & improved features...
#@-node:ekr.20050621084408:4.3.2 projects
#@+node:ekr.20050914132013:4.3.2 final projects
#@+node:ekr.20050912070506:Fixed crasher in rst3 plugin when docutils not present
#@+node:ekr.20050912070506.1:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3333638
By: tfer

As downloaded; log pane notes problems with rst3 and aspell plug-ins.  Will,
aspell still appears in the plugin menu and supplies directions for downloading
and setting up needed components for that plugin in its "about".

Following those directions (and searching help for aspell tips that lead me
to making the using raw strings for the pathnames, (i.e. <pathvar> = r'<pahtname>')),
I get the following in the log pane:

global config dir: C:\Program Files\Leo\config
home dir: None
reading settings in C:\Program Files\Leo\config\leoSettings.leo
unexpected exception in g.importFromPath
Traceback (most recent call last):

  File "C:\Program Files\Leo\src\leoGlobals.py", line 4964, in importFromPath
    module = imp.load_module(moduleName,theFile,pathname,description)

  File "C:\Program Files\Leo\plugins\rst3.py", line 553, in ?
    code_block.options = {

AttributeError: 'NoneType' object has no attribute 'parsers'

can not load enabled rst3 plugin
Can not import aspell from plugin spellpyx
can not load enabled spellpyx plugin
5 plugins loaded
#@-node:ekr.20050912070506.1:Report
#@-node:ekr.20050912070506:Fixed crasher in rst3 plugin when docutils not present
#@+node:ekr.20050911085148:Investigated problems with es_print (works for me)
#@+node:ekr.20050914132954:Report
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3333424
Viktor Ransmayr

  with your release of the beta I tried to generate the Leo
User Guide locally at my laptop and encountered the
following problems:

2005-09-11 09:04:20

o Try creation of leo-documentation with rst3-plugin. 
 - Help->Open LeoDocs.leo
 - Edit->Write Restructured Text
 - See <<Log2>>

### Begin of Log2 content

Leo Log Window...
Leo 4.3.2 beta 1, build  1.278 , September 10, 2005
Python 2.4.1, Tk 8.4.7, win32

reading: C:\Programme\Leo\doc\LeoDocs.leo
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
wrote: C:\Programme\Leo\doc\rstplugin3.html
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
wrote: C:\Programme\Leo\doc\leo_TOC.html
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css

...

SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
wrote: C:\Programme\Leo\doc\directives.html
SilverCity not present so no syntax highlighting
stylesheet does not exist: C:\Dokumente und Einstellungen\VR\Eigene
Dateien\Tools\Leo\default.css
exception executing command
Traceback (most recent call last):
  File "C:\Programme\Leo\src\leoCommands.py", line 186, in doCommand
    command()
  File "C:\Programme\Leo\plugins\rst3.py", line 656, in callback
    self.processTree(c.currentPosition())
  File "C:\Programme\Leo\plugins\rst3.py", line 1105, in processTree
    self.report(self.outputFileName)
  File "C:\Programme\Leo\plugins\rst3.py", line 1537, in report
    g.es_print('wrote: %s' % (name),color="blue")
  File "C:\Programme\Leo\src\leoGlobals.py", line 2458, in es_print
    print g.toEncodedString(s,'ascii')
IOError: [Errno 9] Bad file descriptor

### End of Log2 content

When I tried to generate the various chapters manually
by hand using the rst3 button in the outline I succeeded.
#@-node:ekr.20050914132954:Report
#@+node:ekr.20050707064040:es_print & test
def es_print(s,*args,**keys):
    
    print g.toEncodedString(s,'ascii')
    g.es(s,*args,**keys)
    
def test_g_es_print():
    
    g.es_print('\ntest of es_print: Ă',color='red')
#@nonl
#@-node:ekr.20050707064040:es_print & test
#@-node:ekr.20050911085148:Investigated problems with es_print (works for me)
#@+node:ekr.20050911084855:Added doc/html/*.html to distribution list
#@-node:ekr.20050911084855:Added doc/html/*.html to distribution list
#@-node:ekr.20050914132013:4.3.2 final projects
#@+node:ekr.20050916095957:4.3.3 projects
#@+node:ekr.20050916101421:Cleanup
#@+node:ekr.20050902074723:Protected c.beginEndUpdate against exceptions.
@nocolor

Use the following pattern throughout:

@color

    c.beginUpdate()
    try:
        << whatever >>
    finally:
        c.endUpdate(flag)
        
@nocolor

c.endUpdate re-raises any pending exception.
#@nonl
#@+node:ekr.20031218072017.2952:c.endUpdate & test
def endUpdate(self, flag=True):
    
    '''End a beginUpdate/endUpdate region.
    
    Redraw the tree if this is the outermost endUpdate.
    
    Note that calls to g.es() will disable redraws, so calls to endUpdate
    should follow all such writes to the log pane.
    
    New in Python 4.4:  All of Leo's core code uses this pattern::
        
        c.beginUpdate()
        try:
            ...
        finally:
            c.endUpdate()
        
    Python automatically re-raises an exception after executing a finally block,
    so there is no need to do so here.'''

    try:
        self.frame.tree.endUpdate(flag)
    except Exception:
        pass
    
EndUpdate = endUpdate # Compatibility with old scripts
#@nonl
#@+node:ekr.20050916100046:test_c_endUpdate
def test_c_endUpdate (self):

    try:
        c.beginUpdate()
        try:
            assert(0)
        finally:
            c.endUpdate()
    except AssertionError:
        return
    
    # This will never happen: finally always re-raises a pending exception.
    assert(0,'no re-raise after finally')
#@nonl
#@-node:ekr.20050916100046:test_c_endUpdate
#@-node:ekr.20031218072017.2952:c.endUpdate & test
#@-node:ekr.20050902074723:Protected c.beginEndUpdate against exceptions.
#@+node:ekr.20050902115502:Any way to fix this bug? (works for me)
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3322277
By: dcbbcd

If I use Toggle Active Pane to switch to the outline, the
outline does not get the keyboard focus. I.e. I can't select
another node by using the arrow keys. The black focus
rectangle is around the outline, so partly it worked.

Is this a bug or am I misunderstanding what the 
command does?
#@-node:ekr.20050902115502:Any way to fix this bug? (works for me)
#@-node:ekr.20050916101421:Cleanup
#@+node:ekr.20050916190932:Docs
#@+node:ekr.20050621130815:Rewrote tech report with rst3
@nocolor

This is the rST version of the Tech Report handed out at EuroPython in 2005.

**Important**: Leo's tutorial is now a clearer explanation of the basics.
This tech report should be rewritten.
#@nonl
#@-node:ekr.20050621130815:Rewrote tech report with rst3
#@-node:ekr.20050916190932:Docs
#@+node:ekr.20050917092155:Plugins
@nocolor

- Fixed bugs in niceNosent and fastGotoNode plugins.
- Added niceNosent and fastGotoNode plugins to pluginsManager.txt (disabled)
- Realized that the rst3 plugin should **ignore** @ignore directives.
  Indeed, we typically want to use @ignore to suppress creation of derived files.
- Called Pmw.initialise in the plugins manager plugin.
#@nonl
#@+node:ekr.20050917114044:Fix problem in plugin manager
#@+node:ekr.20050917114044.1:Report
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3342256

Started Plugin Mgr. Got:

exception executing command
Traceback (most recent call last):
  File "C:\Software Engineering\Leo\src\leoCommands.py", line 186, in doCommand
    command()
  File "C:\Software Engineering\Leo\plugins\plugins_menu.py", line 502,
in callback
    p.hastoplevel()
  File "C:\Software Engineering\Leo\plugins\plugin_manager.py", line 193, in
topLevelMenu
    dlg = ManagerDialog()
  File "C:\Software Engineering\Leo\plugins\plugin_manager.py", line 680, in
__init__
    self.plugin_view = PluginView(self.upper, self.file_text)
  File "C:\Software Engineering\Leo\plugins\plugin_manager.py", line 311, in
__init__
    label_text = 'Name:',
  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwEntryField.py",
line 73, in __init__
    sequences = root.bind_class(tag)
  File "C:\Language\Python\lib\lib-tk\Tkinter.py", line 958, in bind_class
    return self._bind(('bind', className), sequence, func, add, 0)
  File "C:\Language\Python\lib\lib-tk\Tkinter.py", line 893, in _bind
    return self.tk.splitlist(self.tk.call(what))
TclError: bad window path name
".12775632.15466288.15466328.15466408.15466448.15800760.15801320"
#@nonl
#@-node:ekr.20050917114044.1:Report
#@+node:ekr.20050917114044.2:What I did
@nocolor

- Added a call to Pmw.initialise(g.app.root) in the top-level init method.
#@nonl
#@-node:ekr.20050917114044.2:What I did
#@-node:ekr.20050917114044:Fix problem in plugin manager
#@-node:ekr.20050917092155:Plugins
#@-node:ekr.20050916095957:4.3.3 projects
#@+node:ekr.20050718150452:(Stuff used by wx plugin)
#@+node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
def newLeoCommanderAndFrame(self,fileName,updateRecentFiles=True):
    
    """Create a commander and its view frame for the Leo main window."""
    
    gui = self
    
    import leoCommands
    
    if not fileName: fileName = ""
    << compute the window title >>

    # Create an unfinished frame to pass to the commanders.
    frame = gui.createLeoFrame(title)
    
    # Create the commander and its subcommanders.
    c = leoCommands.Commands(frame,fileName)
    
    if not g.app.initing:
        g.doHook("before-create-leo-frame",c=c) # Was 'onCreate': too confusing.
    
    frame.finishCreate(c)
    c.finishCreate() # New in 4.4.
    
    # Finish initing the subcommanders.
    c.undoer.clearUndoState() # Menus must exist at this point.
    
    if updateRecentFiles:
        c.updateRecentFiles(fileName)
    
    if not g.app.initing:
        g.doHook("after-create-leo-frame",c=c)
        
    # g.trace(c,frame)

    return c,frame
#@nonl
#@+node:ekr.20031218072017.2189:<< compute the window title >>
# Set the window title and fileName
if fileName:
    title = g.computeWindowTitle(fileName)
else:
    s = "untitled"
    n = g.app.numberOfWindows
    if n > 0:
        s += str(n)
    title = g.computeWindowTitle(s)
    g.app.numberOfWindows = n+1

#@-node:ekr.20031218072017.2189:<< compute the window title >>
#@-node:ekr.20031218072017.2188:newLeoCommanderAndFrame (gui-independent)
#@+node:ekr.20031218072017.1934:run & allies
def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    << import leoGlobals and leoApp >>
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    << import leoNodes and leoConfig >>
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    g.app.config.readSettingsFiles(fileName,verbose) # Must be done after setting g.app.config.
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    << start psycho >>
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()
#@nonl
#@+node:ekr.20041219072112:<< import leoGlobals and leoApp >>
# Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)
#@nonl
#@-node:ekr.20041219072112:<< import leoGlobals and leoApp >>
#@+node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041219072416.1:<< import leoNodes and leoConfig >>
#@+node:ekr.20040411081633:<< start psycho >>
if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()
#@nonl
#@-node:ekr.20040411081633:<< start psycho >>
#@+node:ekr.20031218072017.1936:isValidPython
def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0
#@nonl
#@-node:ekr.20031218072017.1936:isValidPython
#@+node:ekr.20041124083125:completeFileName (leo.py)
def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName
#@nonl
#@-node:ekr.20041124083125:completeFileName (leo.py)
#@+node:ekr.20031218072017.1624:createFrame (leo.py)
def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(repr(fileName))

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            ok, frame = g.openWithFileName(fileName,None)
            if ok:
                return frame.c,frame

    # Create a _new_ frame & indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # 5/13/05
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
#@-node:ekr.20031218072017.1624:createFrame (leo.py)
#@+node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
#@-node:ekr.20031218072017.1938:createNullGuiWithScript (leo.py)
#@+node:ekr.20031218072017.1939:getBatchScript
def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 < len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script
#@nonl
#@-node:ekr.20031218072017.1939:getBatchScript
#@+node:ekr.20041130093254:reportDirectories
def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")
#@nonl
#@-node:ekr.20041130093254:reportDirectories
#@-node:ekr.20031218072017.1934:run & allies
#@+node:ekr.20031218072017.2052:g.openWithFileName
def openWithFileName(fileName,old_c,enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.trace('Already open',fileName)
            return True, frame
    try:
        # g.trace('Not open',fileName)
        # Open the file in binary mode to allow 0x1a in bodies & headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        frame.openDirectory = g.os_path_dirname(fileName)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None
#@nonl
#@-node:ekr.20031218072017.2052:g.openWithFileName
#@+node:ekr.20031218072017.1474:es, enl, ecnl
def ecnl():
    g.ecnls(1)

def ecnls(n):
    log = app.log
    if log and not log.isNull:
        while log.newlines < n:
            g.enl()

def enl():
    log = app.log
    if log and not log.isNull:
        log.newlines += 1
        log.putnl()

def es(s,*args,**keys):
    if app.killed:
        return
    newline = keys.get("newline",True)
    color = keys.get("color",None)
    if color == 'suppress': return # New in 4.3.
    if type(s) != type("") and type(s) != type(u""): # 1/20/03
        s = repr(s)
    for arg in args:
        if type(arg) != type("") and type(arg) != type(u""): # 1/20/03
            arg = repr(arg)
        s = s + ", " + arg
    if app.batchMode:
        if app.log:
            app.log.put(s)
    else:
        log = app.log
        if log and not log.isNull:
            # print 'g.es',s
            log.put(s,color=color)
            for ch in s:
                if ch == '\n': log.newlines += 1
                else: log.newlines = 0
            if newline:
                g.ecnl() # only valid here
        elif newline:
            app.logWaiting.append((s+'\n',color),)
            # print s
        else:
            app.logWaiting.append((s,color),)
            # print s,
#@nonl
#@-node:ekr.20031218072017.1474:es, enl, ecnl
#@+node:ekr.20040803072955.128:tree.select
# Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    
    # g.trace(p.headString())

    if not p: return
    if not p.exists(c):
        g.trace('does not exist',p)
        return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << unselect the old node >>

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        << select the new node >>
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        << update c.beadList or c.beadPointer >>
        << update c.visitedList >>

    << set the current node >>
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()
#@nonl
#@+node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
# Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        # g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot
#@nonl
#@-node:ekr.20040803072955.129:<< unselect the old node >> (changed in 4.2)
#@+node:ekr.20040803072955.130:<< select the new node >>
frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())
#@nonl
#@-node:ekr.20040803072955.130:<< select the new node >>
#@+node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
if updateBeadList:
    
    if c.beadPointer > -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)
#@nonl
#@-node:ekr.20040803072955.131:<< update c.beadList or c.beadPointer >>
#@+node:ekr.20040803072955.132:<< update c.visitedList >>
# Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())
#@nonl
#@-node:ekr.20040803072955.132:<< update c.visitedList >>
#@+node:ekr.20040803072955.133:<< set the current node >>
c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

frame.bodyWantsFocus(frame.bodyCtrl,tag='select')
#@nonl
#@-node:ekr.20040803072955.133:<< set the current node >>
#@-node:ekr.20040803072955.128:tree.select
#@+node:ekr.20031218072017.3704:class leoTree
# This would be useful if we removed all the tree redirection routines.
# However, those routines are pretty ingrained into Leo...

class leoTree:
    
    """The base class for the outline pane in Leo windows."""
    
    __pychecker__ = '--no-argsused' # base classes have many unused args.
    
    @others
#@nonl
#@+node:ekr.20031218072017.3705:  tree.__init__ (base class)
def __init__ (self,frame):
    
    self.frame = frame
    self.c = frame.c

    self.edit_text_dict = {}
        # New in 3.12: keys vnodes, values are edit_text (Tk.Text widgets)
        # New in 4.2: keys are vnodes, values are pairs (p,Tk.Text).
    
    # "public" ivars: correspond to setters & getters.
    self._editPosition = None

    # Controlling redraws
    self.disableRedraw = False
    self.updateCount = 0 # self.redraw does nothing unless this is zero.
    self.redrawCount = 0 # For traces
    self.redrawScheduled = False # True if redraw scheduled.
#@nonl
#@-node:ekr.20031218072017.3705:  tree.__init__ (base class)
#@+node:ekr.20031218072017.3706: Must be defined in subclasses
#@+node:ekr.20031218072017.3709:Colors & Fonts
def setColorFromConfig (self):
    self.oops()

def getFont(self):
    self.oops()
    
def setFont(self,font=None,fontName=None):
    self.oops()
    
def setFontFromConfig (self):
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3709:Colors & Fonts
#@+node:ekr.20031218072017.3707:Drawing
def drawIcon(self,v,x=None,y=None):
    self.oops()

def redraw(self,event=None): # May be bound to an event.
    self.oops()

def redraw_now(self,scroll=True):
    self.oops()
    
def redrawAfterException (self):
    self.oops()
#@-node:ekr.20031218072017.3707:Drawing
#@+node:ekr.20031218072017.3708:Edit label
def editLabel(self,v):
    self.oops()

def endEditLabel(self):
    self.oops()

def setNormalLabelState(self,v):
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3708:Edit label
#@+node:ekr.20031218072017.3710:Notifications
# These should all be internal to the tkinter.frame class.

def OnActivateHeadline(self,p):
    __pychecker__ = '--no-argsused'
    self.oops()
    
def onHeadChanged(self,p):
    __pychecker__ = '--no-argsused'
    self.oops()

def OnHeadlineKey(self,p,event):
    __pychecker__ = '--no-argsused'
    self.oops()

def idle_head_key(self,p,ch=None):
    __pychecker__ = '--no-argsused'
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3710:Notifications
#@+node:ekr.20031218072017.3711:Scrolling
def scrollTo(self,p):
    self.oops()

def idle_scrollTo(self,p=None):
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3711:Scrolling
#@+node:ekr.20031218072017.3712:Selecting
def select(self,p,updateBeadList=True):
    
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3712:Selecting
#@+node:ekr.20031218072017.3713:Tree operations
def expandAllAncestors(self,v):
    
    self.oops()
#@nonl
#@-node:ekr.20031218072017.3713:Tree operations
#@-node:ekr.20031218072017.3706: Must be defined in subclasses
#@+node:ekr.20031218072017.3714:beginUpdate
def beginUpdate (self):

    self.updateCount += 1
#@nonl
#@-node:ekr.20031218072017.3714:beginUpdate
#@+node:ekr.20031218072017.3715:tree.endUpdate
def endUpdate (self,flag=True):
    
    '''Redraw the tree if this is the outermost endUpdate.
    
    Calls to g.es() will disable redraws, so calls to c.endUpdate
    should follow all such writes to the log pane.'''

    assert(self.updateCount > 0)
    self.updateCount -= 1
    # g.trace(self.updateCount, 'disableRedraw',self.disableRedraw)

    if flag and self.updateCount == 0:
        # Bug fix: 3/11/05. Force a redraw here.
        # Writing to the log sets self.disableRedraw.
        self.disableRedraw = False
        self.redraw()
#@nonl
#@-node:ekr.20031218072017.3715:tree.endUpdate
#@+node:ekr.20031218072017.3716:Getters/Setters (tree)
def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setEditPosition(self,p):
    self._editPosition = p
#@nonl
#@-node:ekr.20031218072017.3716:Getters/Setters (tree)
#@+node:ekr.20031218072017.3718:oops
def oops(self):
    
    print "leoTree oops:", g.callerName(2), "should be overridden in subclass"
#@nonl
#@-node:ekr.20031218072017.3718:oops
#@+node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
def OnIconDoubleClick (self,p):

    # Note: "icondclick" hooks handled by vnode callback routine.

    c = self.c
    s = p.headString().strip()
    if g.match_word(s,0,"@url"):
        url = s[4:].strip()
        << stop the url after any whitespace >>
        # g.trace(url)
        if not g.doHook("@url1",c=c,p=p,v=p,url=url):
            # Note: the UNL plugin has its own notion of what a good url is.
            << check the url; return if bad >>
            << pass the url to the web browser >>
        g.doHook("@url2",c=c,p=p,v=p)
#@nonl
#@+node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
# For safety, the URL string should end at the first whitespace, unless quoted.
# This logic is also found in the UNL plugin so we don't have to change the 'unl1' hook.

url = url.replace('\t',' ')

# Strip quotes.
i = -1
if url and url[0] in ('"',"'"):
    i = url.find(url[0],1)
    if i > -1:
        url = url[1:i]

if i == -1:
    # Not quoted or no matching quote.
    i = url.find(' ')
    if i > -1:
        if 0: # No need for a warning.  Assume everything else is a comment.
            g.es("ignoring characters after space in url:"+url[i:])
            g.es("use %20 instead of spaces")
        url = url[:i]
    
#@nonl
#@-node:ekr.20031218072017.2313:<< stop the url after any whitespace  >>
#@+node:ekr.20031218072017.2314:<< check the url; return if bad >>
if not url or len(url) == 0:
    g.es("no url following @url")
    return
    
@ A valid url is (according to D.T.Hein):

3 or more lowercase alphas, followed by,
one ':', followed by,
one or more of: (excludes !"#;<>[\]^`|)
  $%&'()*+,-./0-9:=?@A-Z_a-z{}~
followed by one of: (same as above, except no minus sign or comma).
  $%&'()*+/0-9:=?@A-Z_a-z}~
@c

urlPattern = "[a-z]{3,}:[\$-:=?-Z_a-z{}~]+[\$-+\/-:=?-Z_a-z}~]"

# 4/21/03: Add http:// if required.
if not re.match('^([a-z]{3,}:)',url):
    url = 'http://' + url
if not re.match(urlPattern,url):
    g.es("invalid url: "+url)
    return
#@-node:ekr.20031218072017.2314:<< check the url; return if bad >>
#@+node:ekr.20031218072017.2315:<< pass the url to the web browser >>
@ Most browsers should handle the following urls:
  ftp://ftp.uu.net/public/whatever.
  http://localhost/MySiteUnderDevelopment/index.html
  file://home/me/todolist.html
@c

try:
    import os
    os.chdir(g.app.loadDir)

    if g.match(url,0,"file:") and url[-4:]==".leo":
        ok,frame = g.openWithFileName(url[5:],c)
        if ok:
            frame.bringToFront()
    else:
        import webbrowser
        
        # Mozilla throws a weird exception, then opens the file!
        try: webbrowser.open(url)
        except: pass
except:
    g.es("exception opening " + url)
    g.es_exception()

#@-node:ekr.20031218072017.2315:<< pass the url to the web browser >>
#@-node:ekr.20031218072017.2312:tree.OnIconDoubleClick (@url)
#@+node:ekr.20040106095546.1:tree.enableDrawingAfterException
def enableDrawingAfterException (self):
    pass
#@nonl
#@-node:ekr.20040106095546.1:tree.enableDrawingAfterException
#@-node:ekr.20031218072017.3704:class leoTree
#@+node:ekr.20031218072017.1320:body key handlers
@ The <Key> event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others
#@nonl
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    # g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@+node:ekr.20031218072017.1329:onBodyChanged (tkTree)
# Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.c.frame.body.colorizer.interrupt()
    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)
#@nonl
#@-node:ekr.20031218072017.1329:onBodyChanged (tkTree)
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event,undoType='Typing'):
    
    '''Handle any key press event in the body pane.'''

    # New in Leo 4.4.  May be called with event = None
    c = self.c
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(repr(ch),repr(event.keysym))

    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1331:onBodyWillChange
# Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)
#@nonl
#@-node:ekr.20031218072017.1331:onBodyWillChange
#@-node:ekr.20031218072017.1320:body key handlers
#@+node:ekr.20050719130846:Log stuff (there may be a bad bug here)
#@+node:ekr.20031218072017.1847:app.setLog, lockLog, unlocklog
def setLog (self,log,tag=""):
    """set the frame to which log messages will go"""
    
    __pychecker__ = '--no-argsused' # tag used for debugging.
    
    # print "setLog:",tag,"locked:",self.logIsLocked,log
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True
    
def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False
#@nonl
#@-node:ekr.20031218072017.1847:app.setLog, lockLog, unlocklog
#@+node:ekr.20031218072017.2619:app.writeWaitingLog
def writeWaitingLog (self):

    # g.trace(g.app.gui,self.log)

    if self.log:
        if 1: ## not self.log.isNull: # The test for isNull would probably interfere with batch mode.
            for s,color in self.logWaiting:
                g.es(s,color=color,newline=0) # The caller must write the newlines.
            self.logWaiting = []
    else:
        print 'writeWaitingLog: still no log!'
#@nonl
#@-node:ekr.20031218072017.2619:app.writeWaitingLog
#@-node:ekr.20050719130846:Log stuff (there may be a bad bug here)
#@-node:ekr.20050718150452:(Stuff used by wx plugin)
#@+node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050315071727:g.convertRowColToPythonIndex & test
def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row > len(lines) or col > len(lines[row]):
        raise IndexError
    
    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col
#@nonl
#@+node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = g.convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1
#@nonl
#@-node:ekr.20050315072239:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050315071727:g.convertRowColToPythonIndex & test
#@+node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl > -1
            return row,i-prevNl-1
#@nonl
#@+node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i < total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total
#@nonl
#@-node:ekr.20050314140957.1:bruteForceConvertPythonIndexToRowCol
#@+node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'

    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = g.convertPythonIndexToRowCol(s,i)
        rowCol_2 = g.bruteForceConvertPythonIndexToRowCol(s,i)
        if g.app.unitTesting:
            assert i == len(s) or rowCol_1 == rowCol_2
        else:
            print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
            print rowCol_1,rowCol_2
#@nonl
#@-node:ekr.20050314140957.2:test_g_convertPythonIndexToRowCol
#@-node:ekr.20050314140957:g.convertPythonIndexToRowCol  & test
#@+node:ekr.20050710102922:get/setPythonInsertionPoint
def getPythonInsertionPoint (self,t=None,s=None):
    
    b = self
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    i = t.index("insert")
    row,col = b.convertIndexToRowColumn(i)
    
    return g.convertRowColToPythonIndex(s,row-1,col)
    
def setPythonInsertionPoint (self,i,t=None,s=None):
    
    if t is None: t = self.bodyCtrl
    if s is None: s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    t.mark_set( 'insert','%d.%d' % (row+1,col))
#@nonl
#@-node:ekr.20050710102922:get/setPythonInsertionPoint
#@+node:ekr.20050710104804:getPythonTextSelection
def getPythonTextSelection (self):
    
    """Return a tuple representing the selected range of body text.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    b = self ; t = self.bodyCtrl
    sel = t.tag_ranges("sel")

    if len(sel) == 2:
        s = t.get('1.0','end')
        i,j = sel
        row,col = b.convertIndexToRowColumn(i)
        i1 = g.convertRowColToPythonIndex(s,row-1,col)
        row,col = b.convertIndexToRowColumn(j)
        i2 = g.convertRowColToPythonIndex(s,row-1,col)
        return i1,i2
    else:
        # Return the insertion point if there is no selected text.
        i = self.getPythonTextSelection()
        return i,i
#@nonl
#@-node:ekr.20050710104804:getPythonTextSelection
#@+node:ekr.20050710104804.1:setPythonTextSelection
def setPythonTextSelection(self,i,j):

    t = self.bodyCtrl
    s = t.get('1.0','end')
    row,col = g.convertPythonIndexToRowCol(s,i)
    i1 = '%d.%d' % (row+1,col)
    row,col = g.convertPythonIndexToRowCol(s,j)
    i2 = '%d.%d' % (row+1,col)
    g.app.gui.setTextSelection(self.bodyCtrl,i1,i2)
#@nonl
#@-node:ekr.20050710104804.1:setPythonTextSelection
#@+node:ekr.20031218072017.3173:Scanners: no error messages
#@+node:ekr.20031218072017.3174:escaped
# Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 >= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1
#@nonl
#@-node:ekr.20031218072017.3174:escaped
#@+node:ekr.20031218072017.3175:find_line_start
def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1
#@nonl
#@-node:ekr.20031218072017.3175:find_line_start
#@+node:ekr.20031218072017.3176:find_on_line
def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k > -1: return k
    else: return None
#@nonl
#@-node:ekr.20031218072017.3176:find_on_line
#@+node:ekr.20031218072017.3177:is_c_id
def is_c_id(ch):

    return ch and (ch in string.ascii_letters or ch in string.digits or ch == '_')
#@-node:ekr.20031218072017.3177:is_c_id
#@+node:ekr.20031218072017.3178:is_nl
def is_nl(s,i):

    return i < len(s) and (s[i] == '\n' or s[i] == '\r')
#@nonl
#@-node:ekr.20031218072017.3178:is_nl
#@+node:ekr.20031218072017.3179:is_special
# We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i < len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1
#@nonl
#@-node:ekr.20031218072017.3179:is_special
#@+node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
def is_ws(c):

    return c == '\t' or c == ' '
    
def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i < len(s) and g.is_ws(s[i]))
#@nonl
#@-node:ekr.20031218072017.3180:is_ws & is_ws_or_nl
#@+node:ekr.20031218072017.3181:match
# Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i
#@nonl
#@-node:ekr.20031218072017.3181:match
#@+node:ekr.20031218072017.3182:match_c_word
def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))
#@nonl
#@-node:ekr.20031218072017.3182:match_c_word
#@+node:ekr.20031218072017.3183:match_ignoring_case
def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)
#@nonl
#@-node:ekr.20031218072017.3183:match_ignoring_case
#@+node:ekr.20031218072017.3184:match_word
def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if string.find(s,pattern,i,i+j) != i:
        return False
    if i+j >= len(s):
        return True
    c = s[i+j]
    return not (c in string.ascii_letters or c in string.digits or c == '_')
#@nonl
#@-node:ekr.20031218072017.3184:match_word
#@+node:ekr.20031218072017.3185:skip_blank_lines
def skip_blank_lines(s,i):

    while i < len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3185:skip_blank_lines
#@+node:ekr.20031218072017.3186:skip_c_id
def skip_c_id(s,i):

    n = len(s)
    while i < n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i
#@nonl
#@-node:ekr.20031218072017.3186:skip_c_id
#@+node:ekr.20040705195048:skip_id
def skip_id(s,i,chars=None):

    n = len(s)
    while i < n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
#@-node:ekr.20040705195048:skip_id
#@+node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i
#@nonl
#@-node:ekr.20031218072017.3187:skip_line, skip_to_end_of_line
#@+node:ekr.20031218072017.3188:skip_long
def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i >= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i < n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
#@-node:ekr.20031218072017.3188:skip_long
#@+node:ekr.20031218072017.3189:skip_matching_delims
def skip_matching_delims(s,i,delim1,delim2):
    
    assert(g.match(s,i,delim1))

    i += len(delim1)
    k = string.find(s,delim2,i)
    if k == -1:
        return len(s)
    else:
        return k + len(delim2)
#@nonl
#@-node:ekr.20031218072017.3189:skip_matching_delims
#@+node:ekr.20031218072017.3190:skip_nl
# We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i
#@nonl
#@-node:ekr.20031218072017.3190:skip_nl
#@+node:ekr.20031218072017.3191:skip_non_ws
def skip_non_ws (s,i):

    n = len(s)
    while i < n and not g.is_ws(s[i]):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3191:skip_non_ws
#@+node:ekr.20031218072017.3192:skip_pascal_braces
# Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k
#@nonl
#@-node:ekr.20031218072017.3192:skip_pascal_braces
#@+node:ekr.20031218072017.3193:skip_to_char
def skip_to_char(s,i,ch):
    
    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
#@-node:ekr.20031218072017.3193:skip_to_char
#@+node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
def skip_ws(s,i):

    n = len(s)
    while i < n and g.is_ws(s[i]):
        i += 1
    return i
    
def skip_ws_and_nl(s,i):

    n = len(s)
    while i < n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i
#@nonl
#@-node:ekr.20031218072017.3194:skip_ws, skip_ws_and_nl
#@-node:ekr.20031218072017.3173:Scanners: no error messages
#@-node:ekr.20050710102922.1:(Using Python indices instead of Tk indices)
#@+node:ekr.20050924073836:4.4 projects
#@+node:ekr.20050929075341:Added option for selected body text
#@+node:ekr.20050929075920:Request
@nocolor

http://sourceforge.net/forum/message.php?msg_id=3355954
By: nobody

Well, I came to the conclusion that there is no setting for body selection colors.
Please consider adding such settings in the future.

I changed it the source (Code-->Gui Tkinter classes-->@thin
leoTkinterFrame.py-->class leoTkinterBody--> Birth & death-->tkBody.createControl).
CadetBlue3 is more cheerful than Gray80, and syntax coloring still looks good.
#@-node:ekr.20050929075920:Request
#@+node:ekr.20031218072017.3998:tkBody.createControl
def createControl (self,frame,parentFrame):
    
    c = self.c

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = Tk.Text(parentFrame,name='body',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    return body
#@nonl
#@-node:ekr.20031218072017.3998:tkBody.createControl
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: body.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: body.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@-node:ekr.20050929075341:Added option for selected body text
#@+node:ekr.20050928112629:Fixed bug in Leo's read logic
#@+node:ekr.20050929082939:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3351985
By: leouserz

I have ran into my first case of actual brittleness in regular leos read code.

If I output via dom a tnode that has no text it does it like so:
<t/>

leo yacks on the fact that it was expecting:
<t></t>
#@nonl
#@-node:ekr.20050929082939:Report
#@+node:ekr.20031218072017.1566:getVnode changed for 4.2 & 4.4)
def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched <v.
    
    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        return v
    
    while 1:
        if self.matchTag("a=\""):
            << Handle vnode attribute bits >>
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                << raise invalidPaste if the tnode is in self.forbiddenTnodes >>
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag(">"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("<vh>"):
        headline = self.getEscapedString() ; self.getTag("</vh>")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    << Set the remembered status bits >>

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("<v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    << Append to current or top stack >>

    # End this vnode.
    self.getTag("</v>")
    return v
#@nonl
#@+node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
# The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()
#@nonl
#@-node:ekr.20031218072017.1567:<< Handle vnode attribute bits  >>
#@+node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
# Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste
#@nonl
#@-node:ekr.20041023110111:<< raise invalidPaste if the tnode is in self.forbiddenTnodes >>
#@+node:ekr.20031218072017.1568:<< Set the remembered status bits >>
if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()
#@nonl
#@-node:ekr.20031218072017.1568:<< Set the remembered status bits >>
#@+node:ekr.20040326055828:<< Append to current or top stack >>
if not setCurrent and len(self.currentVnodeStack) > 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) > 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)
#@nonl
#@-node:ekr.20040326055828:<< Append to current or top stack >>
#@-node:ekr.20031218072017.1566:getVnode changed for 4.2 & 4.4)
#@+node:ekr.20031218072017.1561:getTnode (changed for 4.4)
def getTnode (self):

    # we have already matched <t.
    index = -1 ; attrDict = {}

    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/>'): # A collapsed tnode.
        return

    # Attributes may appear in any order.
    while 1:
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag(">"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("tnode")
            if attr: attrDict[attr] = val
            
    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    << handle unknown attributes >>
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("</t>")
#@nonl
#@+node:ekr.20031218072017.1564:<< handle unknown attributes >>
keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        g.es_print(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)
#@nonl
#@-node:ekr.20031218072017.1564:<< handle unknown attributes >>
#@-node:ekr.20031218072017.1561:getTnode (changed for 4.4)
#@-node:ekr.20050928112629:Fixed bug in Leo's read logic
#@+node:ekr.20050929084510:Fixed problem with auto-indent
@

idle_body_key was being called twice for every keystroke.
Why this worked at all is still a bit of a mystery.
The fix was to eliminate the binding to <Key> in tkBody.createBindings.

To do: remove the cut/copy/paste bindings in tkBody.createBindings.
#@nonl
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    k.stroke = stroke # Set this global for general use.
    commandName = k.ultimateFuncName(func)
    special = event.keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'

    # if interesting: g.trace(stroke,commandName)

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=event.keysym))

    if inserted:
        # g.trace(stroke,event.keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.previousStroke = stroke
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName,tag='keyboard-quit')
        return 'break'

    if k.inState():
        k.forceFocusToBody()
        k.previousStroke = stroke
        k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # k.previousStroke = stroke
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = event.keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        k.previousStroke = stroke
        forceFocus = func.__name__ != 'leoCallback'
        if forceFocus:
            k.forceFocusToBody()
        func(event)
        k.endCommand(event,commandName,forceFocus,tag='masterCommand')
        return 'break'

    else:
        c.frame.body.onBodyKey(event)
        return None # Not 'break'
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,event.keysym)

if len(event.char) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,event.char)

if 0: # traces
    g.trace(event.keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self
    
    # g.trace(k.stateKind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            k.state.handler(event)
            k.endCommand(event,k.commandName,tag='callStateFunction')
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName,forceFocus,tag='callKeystrokeFunction')
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@+node:ekr.20031218072017.1330:onBodyKey
def onBodyKey (self,event,undoType='Typing'):
    
    '''Handle any key press event in the body pane.'''

    # New in Leo 4.4.  May be called with event = None
    c = self.c
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(repr(ch),repr(event.keysym))

    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()
        
    # We must execute this even if len(ch) > 0 to delete spurious trailing newlines.
    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,ch)
#@nonl
#@+node:ekr.20040105223536:handleStatusLineKey
def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)>0:
        << trace the key event >>

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status
#@nonl
#@+node:ekr.20040105223536.1:<< trace the key event >>
try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state < 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)
#@nonl
#@-node:ekr.20040105223536.1:<< trace the key event >>
#@-node:ekr.20040105223536:handleStatusLineKey
#@-node:ekr.20031218072017.1330:onBodyKey
#@+node:ekr.20031218072017.1321:idle_body_key & helpers
def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    # g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    << return if nothing has changed >>
    << set removeTrailing >>
    if ch in ('\t','\n','\r',chr(8)):
        << handle special characters >>
    << set s to widget text, removing trailing newlines if necessary >>
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    << recolor the body >>
    if not c.changed:
        c.setChanged(True)
    << redraw the screen if necessary >>
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
#@nonl
#@+node:ekr.20031218072017.1322:<< return if nothing has changed >>
# Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"
#@nonl
#@-node:ekr.20031218072017.1322:<< return if nothing has changed >>
#@+node:ekr.20031218072017.1323:<< set removeTrailing >>
@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)
#@nonl
#@-node:ekr.20031218072017.1323:<< set removeTrailing >>
#@+node:ekr.20050526080309:<< handle special characters >>
d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width < 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width < 0:
    << handle backspace with negative tab_width >>
#@nonl
#@+node:EKR.20040604090913:<< handle backspace with negative tab_width >>
# Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 > 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count > 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.
#@nonl
#@-node:EKR.20040604090913:<< handle backspace with negative tab_width >>
#@-node:ekr.20050526080309:<< handle special characters >>
#@+node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
s = c.frame.body.getAllText()
if len(s) > 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"
#@nonl
#@-node:ekr.20031218072017.1326:<< set s to widget text, removing trailing newlines if necessary >>
#@+node:ekr.20031218072017.1327:<< recolor the body >>
self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False
#@nonl
#@-node:ekr.20031218072017.1327:<< recolor the body >>
#@+node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary
#@nonl
#@-node:ekr.20031218072017.1328:<< redraw the screen if necessary >>
#@+node:ekr.20031218072017.1324:doAutoIndent (David McNab)
def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) > 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) > 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) > 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing
#@nonl
#@-node:ekr.20031218072017.1324:doAutoIndent (David McNab)
#@+node:ekr.20031218072017.1325:convertBlanksToTabs
def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        << convert tab no matter where it is >>
    else:
        << convert only leading tabs >>
#@nonl
#@+node:ekr.20050526081024:<< convert tab no matter where it is >>
w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024:<< convert tab no matter where it is >>
#@+node:ekr.20050526081024.1:<< convert only leading tabs >>
# Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)
#@nonl
#@-node:ekr.20050526081024.1:<< convert only leading tabs >>
#@-node:ekr.20031218072017.1325:convertBlanksToTabs
#@-node:ekr.20031218072017.1321:idle_body_key & helpers
#@+node:ekr.20031218072017.838:tkBody.createBindings
def createBindings (self,frame):
    
    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    c = self.c ; t = self.bodyCtrl
    
    # Event handlers...
    t.bind("<Button-1>", frame.OnBodyClick)
    if sys.platform == "win32":
        # Support Linux middle-button paste easter egg.
        t.bind("<Button-2>", frame.OnPaste)
    t.bind("<Button-3>", frame.OnBodyRClick)
    t.bind("<Double-Button-1>", frame.OnBodyDoubleClick)
    
    if not c.useMiniBuffer:
        g.trace('binding <Key> to frame.body.onBodyKey')
        t.bind("<Key>", self.onBodyKey)

    # Gui-dependent bindings...
    if 0:
        # These cause problems when cut/copy/paste-text commands are bound.
        t.bind(g.virtual_event_name("Cut"), frame.OnCut)
        t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
        t.bind(g.virtual_event_name("Paste"), frame.OnPaste)
#@nonl
#@-node:ekr.20031218072017.838:tkBody.createBindings
#@-node:ekr.20050929084510:Fixed problem with auto-indent
#@+node:ekr.20051006195420:Added background/foreground selection confic options
#@+node:ekr.20051006195420.1:Report
@nocolor
https://sourceforge.net/forum/message.php?msg_id=3361442
By: nobody

Thanks, now I know where those settings live. For completeness, and in case
somebody doesn't like low contrast of white on gray, I suggest to also add foreground
color setting. Imitating what you did I added the following:

two new settings under @settings-->Colors-->@page Body pane colors
in leoSettings.leo:

 @color body_text_selection_background_color = Gray80   (or CadetBlue2 etc.)
 @color body_text_selection_foreground_color = white    (or black)

added to tkBody.setColorFromConfig:

....sel_bg = c.config.getColor('body_text_selection_background_color')
or 'Gray80'
....try: body.configure(selectbackground=sel_bg)
....except Exception:
........g.es("exception setting body pane text selection background color")
........g.es_exception()
....
....sel_fg = c.config.getColor('body_text_selection_foreground_color')
or 'white'
....try: body.configure(selectforeground=sel_fg)
....except Exception:
........g.es("exception setting body pane text selection foreground color")
........g.es_exception()

Works with Leo 4.3.3, build  1.282 , Python 2.3.5, Tk 8.4.3, win32
#@-node:ekr.20051006195420.1:Report
#@+node:ekr.20041217135735.1:tkBody.setColorFromConfig
def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: body.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: body.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()
#@nonl
#@-node:ekr.20041217135735.1:tkBody.setColorFromConfig
#@-node:ekr.20051006195420:Added background/foreground selection confic options
#@+node:ekr.20050920084720.1:Moved emacs commands and new keyHandler to Leo's core
#@+node:ekr.20051003064825:Big picture
- The primary goal is to allow Emacs and Vim users to retain their 'finger habits' while using Leo.

    - It is *not* necessary to implement all Emacs commands: just those that are used frequently.
    - It *is* necessary to extend commands like isearch so they can deal with multiple body texts.

- The secondary goal is 'mouseless leo': being able to drive all parts of Leo without using the mouse.

    - The user must be able to drive all dialogs from the keyboard,
      **or to get the same effect without using a dialog at all**.
#@nonl
#@-node:ekr.20051003064825:Big picture
#@+node:ekr.20051008204635:Docs
#@+node:ekr.20050930083044:@url 'http://www.sas.upenn.edu/computing/help/Unix/emacs.html'   (Basic Emacs commands)
@killcolor

Invoking:
    emacs file1 file2 file3 .... 

Help
    CTRL-h enters the Help facility.
    Help Tutorial  (CTRL-h t)
    Help Apropos   (CTRL-h a) find a command given its functionality,
    Help Character (CTRL-h c) describes a given character's effect,
    Help Function ( CTRL-h f) describes a given Lisp function specified by name.

Reading, writing files
    C-x C-f Find file (to read into buffer) 
    C-x C-s Save current buffer (ie. file in the buffer) 

Moving the cursor
    C-f forward character 
    C-b backward character 
    C-n next line 
    C-p previous line 
    C-e move cursor to end of line 
    C-a move cursor to beginning of line 
    Esc-< move cursor to top of document 
    Esc-> move cursor to bottom of document 
    Esc-f forward word 
    Esc-b backward word 
    Esc-a backward sentence 
    Esc-e forward sentence 
    Esc-] forward paragraph 
    Esc-[ backward paragraph 
    C-v forward page 
    Esc-v backward page 
    Esc-x goto-linen 
    Esc-x goto-char 
    C-l recenter and redraw page 

Repeating Commands
    ESC-5 C-f       move forward 5 chars 
    C-u (the universal argument command)
        Just like Esc-n, but does not need an argument -> in which case the default of 4 is used. eg: 
    C-u C-u -> repeat 16 times 

Deleting Stuff (Killing)
    C-d delete char 
    E-d kill word 
    C-k kill line (but not newline after it) 
    C-u C-k delete 4 lines (not 2 lines! - newlines go too!) 
    E-4 C-k same 

Yanking back things from the Kill ring
    C-y yank 
    C-w kill region 
    E-w copy region into kill ring 
    C-@ or C-SPC set-mark 
    
Paragraph Reformatting
    E-q fill-paragraph 
    E-g fill-region

Searching and replacing
    C-s isearch-forward 
    C-r isearch-backward 
    Esc exit a successful search 
    C-g quit 
    C-s Esc non incremental search forward 
    C-r Esc backward " 
    E-x  replace-string RET bad RET good RET 
    E-% query replace 

By default, searches are case insensitive. You can change this by setting the
variable: case-fold-search --> set it to: nil (Use Esc-x set-variable) 
    E-x re-search-forward simple 
    E-x re-search-backward 
    E-x isearch-forward-regexp incremental 
    E-x isearch-backward-regexp 
    E-x query-replace-regexp 
    E-x replace-regexp 
    replace unconditionally 

Undo
    E-x revert-buffer restore file from disk 
    C-s u undo

Transpose
    C-t transpose characters 
    E-t transpose words 
    C-x C-t transpose lines 

Buffer Manipulation
    C-x b move to other buffer 
    C-x s save some buffers 
    E-x kill-buffer kill buffer 
    E-x kill-some-buffers kill some buffers 
    E-x rename-buffer rename buffer 
    C-x C-q toggle read only status of buffer 
    C-x C-b list buffers 

Window Manipulation
    C-x 2 split current window into 2 horizontals 
    C-x 5 vertically 
    C-x o move to other window 
    E-C v scroll next window 
    Attach '4' to C-x to have the operation go to the other window, eg: C-x 4 f find-file-other window 
    C-x 4 b change buffer other window 
    E-x compare-windows (must have 2 buffers in split windows) 

Spelling Checker
    E-$ (spell check the word the cursor is on)
    E-x spell-string
    E-x spell-buffer
    E-x spell-region

Shell commands in Emacs
    E-! run UNIX command 
    E-| run command on marked region (shell-command-on-region) 
    C-u E-! run UNIX command, but in the current window! 
    E-x shell invoke shell buffer 

Fix echo'ing and ^M ing at the end of lines: 
    stty -echo nl 

Dired: Directory Editor commands
    E-x dired or emacs  
    SPC move 
    n next 
    p prev 
    v view (via recursive edit) 
    C-c (or q) to return to directory list 
    d mark for deletion 
    e edit file 
    f edit file 
    x DELETE those marked 
    c copy file 
    r rename file 
    M change file permissions 

Text Formatting
    E-x fill-paragraph
    E-x fill-individual-paragraphs
    E-x edit-tab-stops
    E-x untabify (converts tabs to spaces)
    E-x tabify
    E-x mark-whole-buffer
    C-x h variable: indent-tabs-mode
    (if set to nil, Emacs always uses spaces to make tabs)
    C-x fill-prefix: this string automatically gets inserted at begin of each line
    C-x . set-fill-prefix
    E-x indented-text-mode

Centering Text
    E-s center-line
    E-x center-paragraph
    C-l form feed - used for pagination

Macros
    C-x ( start macro definition
    C-x ) end macro definition
    C-x e call-last-kbd-macro

Customizing Emacs
    (define-key keymap "keystroke" 'command-name)
    (global-set-key "keystroke" 'command-name)
    (local-set-key "keystroke" 'command-name)
    (global-unset-key "\C-s") 
    Example:
        (define-key global-map "\C-xl" 'goto-line)
            (global-set-key "\C-xl" 'goto-line) 
    Maps: global-map, ctl-x-map, esc-map 

Indentation
    E-C-\ indent-region 
    E-m back-to-indentation 
    E-^ delete-indentation join this line to previous 
    E-; indent-for-comment 

C-Mode
    E-C-a beginning-of-defun 
    E-C-e end-of-defun 
    E-C-h mark-c-function 

Variables Default 
    c-indent-level 2 
    c-auto-new-line nil 
    c-continued-statement-offset 2 
    c-argdecl-indent 5 
    c-brace-offset 0 
    c-continued-brace-offset 0 
    c-brace-imaginary-offset 0 
    c-label-offset -2 

ETAGS
    etags *.[ch] creates a TAGS file E-.
    find-tag C-x 4 find-tag-other-window E-,
    tags-loop-continue (find next tag)
    E-x tags-search prompts for an RE and finds it.
    find next by E-,
    E-x tags-query-replace
    C-u E-x tags-query-replace (only replace for full words) E-x list-tags 

Lisp Mode
    3: emacs-lisp-mode, lisp-mode, lisp-interaction-mode 
    S-expression: any syntactically correct LISP expression: atom or parenthesized list. 
    E C-a beginning-of-defun 
    E C-e end-of-defun 
    E C-h mark-defun 

Lisp Interaction Mode
    E-x lisp-interaction-mode
    LINEFEED C-j is bound to eval-print-last-sexp

Compiling Programs withing Emacs
    E-x compile
    default: make -k (controlled by compile-command variable)
    C-c ` next-error
    C-u C-x ` start at first error again
    E-x grep
#@nonl
#@-node:ekr.20050930083044:@url 'http://www.sas.upenn.edu/computing/help/Unix/emacs.html'   (Basic Emacs commands)
#@+node:ekr.20051004093536:@url 'http://www.ling.ed.ac.uk/facilities/help/emacs/emacs_14.html' (Registers)
#@-node:ekr.20051004093536:@url 'http://www.ling.ed.ac.uk/facilities/help/emacs/emacs_14.html' (Registers)
#@+node:ekr.20051005094144:@url 'http://www.delorie.com/gnu/docs/emacs/emacs_487.html' (Macros)
#@-node:ekr.20051005094144:@url 'http://www.delorie.com/gnu/docs/emacs/emacs_487.html' (Macros)
#@-node:ekr.20051008204635:Docs
#@+node:ekr.20051012124113:Pychecker report
# None of the following are correct.

C:\prog\leoCVS\leo\src\leoKeys.py:789: Redefining attribute (keyCallback) original line (778)
    # Wrong.
C:\prog\leoCVS\leo\src\leoKeys.py:1311: No module attribute (initAllEditCommanders) found
    # Wrong.
C:\prog\leoCVS\leo\src\leoKeys.py:1554: Local variable (z) not used
    # for z in xrange(...):
C:\prog\leoCVS\leo\src\leoEditCommands.py:706: Parameter (name) not used
    # WRONG:  name **is** used.
C:\prog\leoCVS\leo\src\leoEditCommands.py:1104: No class attribute (capitalize) found
    # text.capitalize.
C:\prog\leoCVS\leo\src\leoEditCommands.py:1850: Statement appears to have no effect
    # Weird
#@+node:ekr.20051012124520:Others
(fixed) C:\prog\leoCVS\leo\src\leoTkinterFrame.py:128: Local variable (gui) not used

# These are now defined in the ctor.

C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1290: No class attribute (iconBarComponentName) found
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1294: No class attribute (iconBarComponentName) found
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1305: No class attribute (iconBarComponentName) found\

C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1324: No class attribute (statusLineComponentName) found
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1328: No class attribute (statusLineComponentName) found
C:\prog\leoCVS\leo\src\leoTkinterFrame.py:1339: No class attribute (statusLineComponentName) found
#@-node:ekr.20051012124520:Others
#@+node:ekr.20051012124113.1:leoKeys
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:14: Imported module (leoNodes) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:17: Imported module (tkFileDialog) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:434: Local variable (t) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:561: Local variable (f) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:780: Parameter (name) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:922: Parameter (name) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:979: Local variable (bodyCtrl) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:1139: Local variable (w) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:1253: Function returns a value and also implicitly returns None
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:1275: Function returns a value and also implicitly returns None
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:1557: No global (method) found
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:1582: No global (c) found

(bad warning) C:\prog\leoCVS\leo\src\leoKeys.py:791: Redefining attribute (keyCallback) original line (780)
(bad warning) C:\prog\leoCVS\leo\src\leoKeys.py:1308: No module attribute (initAllEditCommanders) found
(bad warning) C:\prog\leoCVS\leo\src\leoKeys.py:1551: Local variable (z) not used

(Fixed) C:\prog\leoCVS\leo\src\leoKeys.py:15: Imported module (tkFont) not used
(WRONG) C:\prog\leoCVS\leo\src\leoKeys.py:778: Parameter (name) not used
(fixed) C:\prog\leoCVS\leo\src\leoKeys.py:1251: Function returns a value and also implicitly returns None
#@nonl
#@-node:ekr.20051012124113.1:leoKeys
#@-node:ekr.20051012124113:Pychecker report
#@+node:ekr.20050921100955:Not used
#@+node:ekr.20050723064110:class generalizedEditCommands (Do not delete)
class editCommands:

    @others
#@nonl
#@+node:ekr.20050723064110.1:ctor
def __init__ (self,c):
    
    self.c = c

    self.mode = 'default'
    self.modeStack = []
    
    self.defaultWordChars1, self.defaultWordChars2 = self.setDefaultWordChars()
    self.wordChars1 = self.defaultWordChars1
    self.wordChars2 = self.defaultWordChars2

    self.setDefaultOptions()
#@nonl
#@-node:ekr.20050723064110.1:ctor
#@+node:ekr.20050723064110.3:Options...
#@+node:ekr.20050723064110.4:setDefaultOptions
def setDefaultOptions(self):
    
    self.options = {
        'extendMovesForward':   True,  # True: moving forward may cross node boundaries.
        'extendMovesBack':      True,  # True: moving back may cross node boundaries.
        'extendFindsForward':   True,   # True: find forward may cross node boundaries.
        'extendFindsBack':      True,   # True: find back may cross node boundaries.
    }
#@nonl
#@-node:ekr.20050723064110.4:setDefaultOptions
#@+node:ekr.20050723064110.5:getOption
def getOption (self,optionName):
    
    # This may change when modes get put in.
    return self.options.get(optionName)
#@nonl
#@-node:ekr.20050723064110.5:getOption
#@-node:ekr.20050723064110.3:Options...
#@+node:ekr.20050723064110.6:Word stuff...
#@+node:ekr.20050723064110.7:findWordStart
def findWordStart(self,s,i):
    
    while i < len(s):
        if s[i] in self.wordChars1:
            return i
        else:
            i += 1
    return i
#@nonl
#@-node:ekr.20050723064110.7:findWordStart
#@+node:ekr.20050723064110.8:insideWord
def insideWord (self,s,i):
    
    '''Return True if the char at s[i] is inside a word but does not start the word.'''
    
    return (
        0 < i < len(s) and
        s[i] in self.wordChars2 and
        s[i-1] in self.wordChars2
    )
#@nonl
#@-node:ekr.20050723064110.8:insideWord
#@+node:ekr.20050723064110.9:skipWord
def skipWord(self,s,i):
    
    while i < len(s) and s[i] in self.wordChars2:
        i += 1
    return i
#@nonl
#@-node:ekr.20050723064110.9:skipWord
#@+node:ekr.20050723064110.10:startsWord
def startsWord (self,s,i):
    
    '''Return True if the char at s[i] is inside a word but does not start the word.'''
    
    return (
        i < len(s) and 
        s[i] in self.wordChars1 and
        (i == 0 or s[i-1] not in self.wordChars1)
    )
#@nonl
#@-node:ekr.20050723064110.10:startsWord
#@+node:ekr.20050723064110.11:setDefaultWordChars
def setDefaultWordChars (self):
    
    chars1 = '_' + string.letters
    chars2 = '_' + string.letters + string.digits
    return chars1, chars2
#@nonl
#@-node:ekr.20050723064110.11:setDefaultWordChars
#@-node:ekr.20050723064110.6:Word stuff...
#@+node:ekr.20050723064110.12:Cursor movement
#@+node:ekr.20050723064110.13:moveBackwardChar
def moveBackwardChar (self):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    i = b.getPythonInsertionPoint(s=s)
    i -= 1
    if i >= 0:
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesBackward'): # Recursively look for words in previous nodes.
        p = c.currentPosition().moveToThreadBack()
        while p:
            s = p.bodyString()
            if len(s) > 0:
                c.selectPosition(p)
                b.setPythonInsertionPoint(len(s)-1)
                return True
            else:
                p.moveToThreadBack()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.13:moveBackwardChar
#@+node:ekr.20050723064110.14:moveBackwardWord (Finish)
def moveBackwardWord (self,i=None):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    if i is None: i = b.getPythonInsertionPoint(s=s)

    if self.startsWord(s,i) or self.insideWord(s,i):
        i = self.findWordStart(s,i)
    i = self.findWordStart(s,i) ###
    if self.startsWord(s,i): ###
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesBackward'): # Recursively look for words in previous nodes.
        p = c.currentPosition().moveToThreadBack()
        while p:
            c.selectPosition(p)
            if self.moveBackwardWord(0):
                return True
            p.moveToThreadBack()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.14:moveBackwardWord (Finish)
#@+node:ekr.20050723064110.15:moveForwardChar
def moveForwardChar (self):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    i = b.getPythonInsertionPoint(s=s)
    i += 1
    if i < len(s):
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesForward'): # Recursively look for words in following nodes.
        p = c.currentPosition().moveToThreadNext()
        while p:
            if len(p.bodyString()) > 0:
                c.selectPosition(p)
                b.setPythonInsertionPoint(0)
                return True
            else:
                p.moveToThreadNext()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.15:moveForwardChar
#@+node:ekr.20050723064110.16:moveForwardWord
def moveForwardWord (self,i=None):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    if i is None: i = b.getPythonInsertionPoint(s=s)

    if self.startsWord(s,i) or self.insideWord(s,i):
        i = self.skipWord(s,i)
    i = self.findWordStart(s,i)
    if self.startsWord(s,i):
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesForward'): # Recursively look for words in following nodes.
        p = c.currentPosition().moveToThreadNext()
        while p:
            c.selectPosition(p)
            if self.moveForwardWord(0):
                return True
            p.moveToThreadNext()
        return False
    else:
        return False
#@nonl
#@-node:ekr.20050723064110.16:moveForwardWord
#@+node:ekr.20050723064110.17:selectWord
#@-node:ekr.20050723064110.17:selectWord
#@+node:ekr.20050723064110.18:selectForwordWord
def selectForwardWord (self):
    
    c = self ; b = c.frame.body ; s = b.getAllText()

    i = i1 = b.getPythonInsertionPoint()
    
    if i < len(s) and g.is_c_id(s[i]):
        i = g.skip_c_id(s,i+1)
    
    while i < len(s) and not g.is_c_id(s[i]):
        i += 1
        
    if i < len(s) and g.is_c_id(s[i]):
        # b.setPythonTextSelection(i1,i)
        pass ### TODO
#@nonl
#@-node:ekr.20050723064110.18:selectForwordWord
#@-node:ekr.20050723064110.12:Cursor movement
#@-node:ekr.20050723064110:class generalizedEditCommands (Do not delete)
#@+node:ekr.20051012124209:From leoEditCommands...
#@+node:ekr.20050920084036.129:zapTo
def zapTo (self,event):

    k = self.k ; c = k.c ; w = event.widget
    s = string.ascii_letters+string.digits+string.punctuation

    if len(event.char) != 0 and event.char in s:
        k.setState('zap',0)
        i = w.search(event.char,'insert',stopindex='end')
        k.resetLabel()
        if i:
            t = w.get('insert','%s+1c' % i)
            c.killBufferCommands.addToKillBuffer(t)
            w.delete('insert','%s+1c' % i)

    return 'break'
#@-node:ekr.20050920084036.129:zapTo
#@+node:ekr.20050927102645:From bufferCommandsClass
#@+node:ekr.20050920084036.46:setBufferListGetter
def setBufferListGetter (self,buffer,method):

    #Sets a method that returns a buffer name and its text, and its insert position.
    self.bufferListGetters [buffer] = method
#@nonl
#@-node:ekr.20050920084036.46:setBufferListGetter
#@+node:ekr.20050920084036.47:setBufferSetter
def setBufferSetter( self, buffer, method ):

    #Sets a method that takes a buffer name and the new contents.
    self.bufferSetters[ buffer ] = method
#@nonl
#@-node:ekr.20050920084036.47:setBufferSetter
#@+node:ekr.20050920084036.48:getBufferDict
def getBufferDict (self,event):

    w = event.widget
    meth = self.bufferListGetters [w]
    return meth()
#@nonl
#@-node:ekr.20050920084036.48:getBufferDict
#@+node:ekr.20050920084036.49:setBufferData
def setBufferData( self, event, name, data ):
    
    w = event.widget
    meth = self.bufferSetters[ w ]
    meth( name, data )
#@nonl
#@-node:ekr.20050920084036.49:setBufferData
#@+node:ekr.20050920084036.50:setBufferGoto
def setBufferGoto( self, w, method ):

    self.bufferGotos[ w ] = method
#@nonl
#@-node:ekr.20050920084036.50:setBufferGoto
#@+node:ekr.20050920084036.51:setBufferDelete
def setBufferDelete( self, w, method ):
    
    self.bufferDeletes[ w ] = method
#@nonl
#@-node:ekr.20050920084036.51:setBufferDelete
#@+node:ekr.20050920084036.52:setBufferRename
def setBufferRename( self, buffer, method ):
    
    self.renameBuffers[ buffer ] = method
#@nonl
#@-node:ekr.20050920084036.52:setBufferRename
#@-node:ekr.20050927102645:From bufferCommandsClass
#@+node:ekr.20050920085536.43:findItemsWithPrefix (Not used)
def findItemsWithPrefix (self,s,aList=None):

    '''This method returns a sorted list of matches.
    
    It returns the list of matches and the longest common prefix of all the matches.'''

    k = self ; c = k.c

    common_prefix = ''

    if s: pmatches = [a for a in aList if a.startswith(s)]
    else: pmatches = []
        
    if pmatches:
        s = pmatches[0] ; done = False
        for i in xrange(len(s)):
            prefix = s[:i]
            for z in pmatches:
                if not z.startswith(prefix):
                    done = True ; break
            if done:
                break
            else:
                common_prefix = prefix
        pmatches.sort()

    # g.trace(repr(s),len(pmatches))
    return pmatches,common_prefix
#@nonl
#@-node:ekr.20050920085536.43:findItemsWithPrefix (Not used)
#@+node:ekr.20050920084036.73:startGoto (No longer used)
def startGoto (self,event,ch=False):

    k = self.k ; state = k.getState('goto')
    k.setState('goto',state+1,handler=self.Goto)
    k.setLabelBlue('')
    return 'break'
#@nonl
#@-node:ekr.20050920084036.73:startGoto (No longer used)
#@+node:ekr.20050920084036.143:Goto (no longer used)
def Goto (self,event):

    k = self.k ; w = event.widget
    if event.keysym == 'Return':
        i = k.getLabel()
        k.resetLabel()
        state = k.getState('goto')
        k.setState('goto',0)
        if i.isdigit():
            if state == 1:
                w.mark_set('insert','%s.0' % i)
            elif state == 2:
                w.mark_set('insert','1.0 +%sc' % i)
            w.event_generate('<Key>')
            w.update_idletasks()
            w.see('insert')
    else:
        k.updateLabel(event)

    return 'break'
#@nonl
#@-node:ekr.20050920084036.143:Goto (no longer used)
#@+node:ekr.20050930091642:walkKB
def walkKB( self, event, frm, which ):# kb = self.iterateKillBuffer() ):

    k = self.k ; w = event.widget
    i = w.index( 'insert' )
    t , t1 = i.split( '.' )
    clip_text = self.getClipboard( w )    
    if self.killbuffer or clip_text:
        if which == 'c':
            self.reset = True
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
        else:
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            t1 = str( int( t1 ) + len( txt ) )
            r = w.tag_ranges( 'kb' )
            if r and r[ 0 ] == i:
                w.delete( r[ 0 ], r[ -1 ] )
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
    return k._tailEnd( w )
#@nonl
#@-node:ekr.20050930091642:walkKB
#@+node:ekr.20050930095323:killSentenceHelper
def killSentenceHelper (self,event,back):
    w = event.widget
    i = w.search('.','insert',stopindex='end')
    if back:
        i = w.search('.','insert',backwards=True,stopindex='1.0')
        if not i: return 'break'
        i2 = w.search('.',i,backwards=True,stopindex='1.0') or '1.0'
        return self.kill(event,i2,'%s + 1c' % i)
    else:
        i  = w.search('.','insert',stopindex='end')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i)

    return 'break'
#@nonl
#@-node:ekr.20050930095323:killSentenceHelper
#@+node:ekr.20050920085536.69:tailEnd...
#@+node:ekr.20050920114619.1:utTailEnd
def utTailEnd (self,event=None):

    '''A method that Emacs will call with its _tailEnd method'''
    
    k = self ; c = k.c ; w = c.frame.bodyCtrl

    # w.event_generate('<Key>')
    w.focus_force()
    w.update_idletasks()
    # c.frame.bodyWantsFocus(w,later=True,tag='utTailEnd')

    return 'break'
#@nonl
#@-node:ekr.20050920114619.1:utTailEnd
#@+node:ekr.20050920085536.70:_tailEnd
def _tailEnd (self,w):
    
    '''This returns the tailEnd function that has been configure for the w parameter.'''
    
    k = self
    func = k.tailEnds.get(w)
    if func:
        # g.trace(func)
        return func(w)
    else:
        return 'break'
#@-node:ekr.20050920085536.70:_tailEnd
#@+node:ekr.20050920085536.71:setTailEnd
def setTailEnd (self,w,tailCall):

    '''This method sets a ending call that is specific for a particular Text widget.
       Some environments require that specific end calls be made after a keystroke
       or command is executed.'''

    k = self

    k.tailEnds [w] = tailCall
#@-node:ekr.20050920085536.71:setTailEnd
#@-node:ekr.20050920085536.69:tailEnd...
#@+node:ekr.20050920084036.44:setInBufferMode
def setInBufferMode (self,event,which):
    
    k = self.k ; w = event.widget

    k.keyboardQuit(event)
    k.setState('bufferList','start%s' % which)
    k.setLabelBlue('Choose Buffer Name: ',protect=True)
    self.bufferDict = self.getBufferDict(event)

    return 'break'
#@nonl
#@-node:ekr.20050920084036.44:setInBufferMode
#@+node:ekr.20050920084036.256:executeRegister (not used)
def executeRegister (self,event):
    
    k = self.k

    if self.method:
        self.method(event)

        if self.registerMode != 0:
            k.keyboardQuit(event)
#@nonl
#@-node:ekr.20050920084036.256:executeRegister (not used)
#@-node:ekr.20051012124209:From leoEditCommands...
#@+node:ekr.20051012141518:From bufferCommandsClass
#@+node:ekr.20050927101829.2:buildBufferList (not used)
def buildBufferList (self):

    '''Build a buffer list from an outline.'''
    
    self.positions =  {}
    self.tnodes = {}

    for p in c.allNodes_iter():
    
        t = p.v.t ; h = t.headString()
        
        theList = self.positions.get(h,[])
        theList.append(p.copy())
        self.positions [h] = theList
        
        self.tnodes [h] = t.bodyString()
#@nonl
#@-node:ekr.20050927101829.2:buildBufferList (not used)
#@+node:ekr.20050920084036.41:bufferList (to be deleted)
def bufferList (self,event):
    
    k = self.k
    state = k.getState('bufferList')
    if state.startswith('start'):
        state = state[5:]
        k.setState('bufferList',state)
        k.setLabel('')
    if event.keysym=='Tab':
        stext = k.getLabel().strip()
        if self.bufferTracker.prefix and stext.startswith(self.bufferTracker.prefix):
            k.setLabel(self.bufferTracker.next())#get next in iteration
        else:
            prefix = k.getLabel()
            pmatches =[]
            for z in self.bufferDict.keys():
                if z.startswith(prefix):
                    pmatches.append(z)
            self.bufferTracker.setTabList(prefix,pmatches)
            k.setLabel(self.bufferTracker.next())#begin iteration on new lsit
    elif event.keysym=='Return':
       bMode = k.getState('bufferList')
       c.commandsDict[bMode](event,k.getLabel())
    else:
        self.update(event)
#@nonl
#@-node:ekr.20050920084036.41:bufferList (to be deleted)
#@+node:ekr.20051012133615:switchToBuffer (not used)
def switchToBuffer( self, event, name ):
    
    method = self.bufferGotos[ event.widget ]
    self.keyboardQuit( event )
    method( name )
    return 'break'
#@-node:ekr.20051012133615:switchToBuffer (not used)
#@-node:ekr.20051012141518:From bufferCommandsClass
#@+node:ekr.20050920084036.251:_ToReg (not used)
def _ToReg (self,event,which):

    if not self._chckSel(event):
        return
    if self._checkIfRectangle(event):
        return

    if event.keysym in string.letters:
        event.keysym = event.keysym.lower()
        w = event.widget
        if not self.registers.has_key(event.keysym):
            self.registers [event.keysym] = ''
        txt = w.get('sel.first','sel.last')
        rtxt = self.registers [event.keysym]
        if self.which == 'p':
            txt = txt + rtxt
        else:
            txt = rtxt + txt
        self.registers [event.keysym] = txt
#@nonl
#@-node:ekr.20050920084036.251:_ToReg (not used)
#@+node:ekr.20050920085536.64:k.manufactureKeyPress
def manufactureKeyPress (self,event,keysym):
    
    '''Implement a command by passing a keypress to Tkinter.'''

    w = event.widget
    w.event_generate('<Key>',keysym=keysym)
    
    ### Synthesize commandName instead of keysym?
    self.endCommand(event,keysym,tag='manufactureKeyPress')
    
    return 'break'
#@nonl
#@-node:ekr.20050920085536.64:k.manufactureKeyPress
#@+node:ekr.20050929170812:leoEditCommands.manufactureKeyPress
def manufactureKeyPress (self,event,keysym):
    
    return self.k.manufactureKeyPress(event,keysym)
#@nonl
#@-node:ekr.20050929170812:leoEditCommands.manufactureKeyPress
#@-node:ekr.20050921100955:Not used
#@+node:ekr.20050921094025.254:All xemacs commands
@killcolor
#@+node:ekr.20050921094025.255:B: Buffer-menu
Buffer-menu-1-window
Buffer-menu-2-window
Buffer-menu-backup-unmark
Buffer-menu-delete
Buffer-menu-delete-backwards
Buffer-menu-execute
Buffer-menu-igrep
Buffer-menu-mark
Buffer-menu-maybe-mouse-select
Buffer-menu-mouse-select
Buffer-menu-not-modified
Buffer-menu-other-window
Buffer-menu-popup-menu
Buffer-menu-quit
Buffer-menu-save
Buffer-menu-select
Buffer-menu-switch-other-window
Buffer-menu-this-window
Buffer-menu-toggle-read-only
Buffer-menu-unmark
Buffer-menu-visit-tags-table
#@nonl
#@-node:ekr.20050921094025.255:B: Buffer-menu
#@+node:ekr.20050921094025.256:C, E, F, H
Custom-buffer-done
Custom-goto-parent
Custom-make-dependencies
Custom-mode-menu
Custom-reset-current
Custom-reset-saved
Custom-reset-standard
Custom-save
Custom-set

Electric-command-history-redo-expression

Footnote-add-footnote

Helper-describe-bindings
Helper-help

#@-node:ekr.20050921094025.256:C, E, F, H
#@+node:ekr.20050921094025.257:I: info
Info-elisp-ref
Info-emacs-command
Info-emacs-key
Info-goto-emacs-command-node
Info-goto-emacs-key-command-node
Info-goto-node
Info-query
Info-search
Info-speedbar-browser
Info-split
Info-tagify
Info-validate
Info-visit-file
#@nonl
#@-node:ekr.20050921094025.257:I: info
#@+node:ekr.20050921094025.258:L, M, R, T, V: LaTeX,TeX
LaTeX-install-toolbar
LaTeX-mode

Manual-nuke-nroff-bs

Rd-mode

TeX-auto-generate
TeX-auto-generate-global
TeX-insert-quote
TeX-mode
TeX-submit-bug-report

View-process-status
#@nonl
#@-node:ekr.20050921094025.258:L, M, R, T, V: LaTeX,TeX
#@+node:ekr.20050921094025.259:a add- align- append- apropos- auto-
abbrev-mode
abbrev-prefix-mark

abort-recursive-edit
about-xemacs
activate-region
ada-make-filename-from-adaname
ada-mode

add-change-log-entry
add-change-log-entry-other-window
add-global-abbrev
add-log-convert
add-mode-abbrev
add-name-to-file

advertised-switch-to-completions
advertised-undo

align
align-current
align-entire
align-highlight-rule
align-newline-and-indent
align-regexp
align-unhighlight-rule

all-hail-emacs
all-hail-xemacs
ams-tex-mode
ansi-color-for-comint-mode-on
apache-mode

append-next-kill
append-to-buffer
append-to-file
append-to-register

apply-macro-to-region-lines
appt-add
appt-delete
apropos
apropos-command
apropos-documentation
apropos-value
apropos-zippy
arp
asm-mode
assign-last-kbd-macro-to-key

auto-compression-mode
auto-fill-mode
auto-insert
auto-revert-mode
auto-save-mode
auto-show-make-point-visible
auto-show-mode

autoconf-mode
awk-mode
#@nonl
#@-node:ekr.20050921094025.259:a add- align- append- apropos- auto-
#@+node:ekr.20050921094025.260:b backward- bbdb- beginning- bookmark- br- browse- buffer- build- byte-
back-to-indentation
background
backtrace

backward-block-of-lines
backward-char
backward-char-command
backward-delete-char
backward-delete-char-untabify
backward-kill-line
backward-kill-paragraph
backward-kill-sentence
backward-kill-sexp
backward-kill-word
backward-list
backward-or-forward-delete-char
backward-or-forward-kill-sentence
backward-or-forward-kill-sexp
backward-or-forward-kill-word
backward-other-window
backward-page
backward-paragraph
backward-sentence
backward-sexp
backward-to-indentation
backward-up-list
backward-word

balance-windows
balloon-help-minor-mode
balloon-help-mode
base64-decode-region
base64-encode-region
basic-save-buffer

bbdb
bbdb-add-or-remove-mail-alias
bbdb-apply-next-command-to-all-records
bbdb-changed
bbdb-company
bbdb-complete-name
bbdb-create
bbdb-create-ftp-site
bbdb-creation-newer
bbdb-creation-no-change
bbdb-creation-older
bbdb-delete-current-field-or-record
bbdb-delete-current-record
bbdb-dial
bbdb-display-all-records-completely
bbdb-display-record-completely
bbdb-edit-current-field
bbdb-finger
bbdb-fontify-buffer
bbdb-force-record-create
bbdb-ftp
bbdb-help
bbdb-info
bbdb-insert-new-field
bbdb-load-touchtones
bbdb-menu
bbdb-merge-file
bbdb-name
bbdb-net
bbdb-notes
bbdb-omit-record
bbdb-print
bbdb-record-edit-notes
bbdb-record-edit-property
bbdb-refile-record
bbdb-send-mail
bbdb-show-all-recipients
bbdb-snarf
bbdb-snarf-region
bbdb-submit-bug-report
bbdb-timestamp-newer
bbdb-timestamp-older
bbdb-toggle-all-records-display-layout
bbdb-toggle-records-display-layout
bbdb-transpose-fields
bbdb-whois
bbdb-www
bbdb-www-grab-homepage
bbdb-yank
bbdb/gnus-annotate-sender
bbdb/gnus-show-all-recipients
bbdb/gnus-show-records
bbdb/gnus-snarf-signature
bbdb/mh-annotate-sender
bbdb/mh-show-sender
bbdb/rmail-annotate-sender
bbdb/rmail-show-sender
bbdb/vm-annotate-sender
bbdb/vm-set-auto-folder-alist
bbdb/vm-show-all-recipients
bbdb/vm-show-records
bbdb/vm-show-sender

beginning-of-buffer
beginning-of-buffer-other-window
beginning-of-defun
beginning-of-defun-raw
beginning-of-line
beginning-of-line-text

bib-cite-minor-mode
bib-mode
bibtex-mode
binary-overwrite-mode
blackbox
blink-cursor-mode
blink-matching-open
blink-paren
bnf-mode

bookmark-bmenu-list
bookmark-delete
bookmark-insert
bookmark-insert-location
bookmark-jump
bookmark-load
bookmark-locate
bookmark-menu-delete
bookmark-menu-insert
bookmark-menu-jump
bookmark-menu-locate
bookmark-menu-rename
bookmark-relocate
bookmark-rename
bookmark-save
bookmark-set
bookmark-write

br-complete-symbol
br-env-browse
br-env-load
br-three-button-mouse
br-to-from-viewer
br-two-button-mouse

browse-url
browse-url-at-mouse
browse-url-at-point
browse-url-cci
browse-url-firefox
browse-url-galeon
browse-url-generic
browse-url-gnome-moz
browse-url-grail
browse-url-iximosaic
browse-url-kde
browse-url-lynx-emacs
browse-url-lynx-xterm
browse-url-mail
browse-url-mmm
browse-url-mosaic
browse-url-mozilla
browse-url-netscape
browse-url-of-buffer
browse-url-of-dired-file
browse-url-of-file
browse-url-of-region
browse-url-opera
browse-url-w3
browse-url-w3-gnudoit
browse-url-w3m
browse-url-w3m-gnudoit

bsh-script-help

buffer-disable-undo
buffer-enable-undo
buffer-flush-undo
buffer-menu
buffer-menu-other-window

build
build-report
build-version

bury-buffer

byte-compile-and-load-file
byte-compile-buffer
byte-compile-file
byte-force-recompile
byte-recompile-directory
byte-recompile-file
#@nonl
#@-node:ekr.20050921094025.260:b backward- bbdb- beginning- bookmark- br- browse- buffer- build- byte-
#@+node:ekr.20050921094025.261:c c- calc-, call- capitalize- center- checkdoc- command- completion- copy- count- customize- cvs-
c++-browse
c++-mode

c-add-style
c-comment-edit
c-macro-expand
c-mode
c-set-offset
c-set-style

calc
calc-dispatch
calc-embedded
calc-embedded-activate
calc-grab-rectangle
calc-grab-region
calc-keypad
calc-tutorial

calendar
call-last-kbd-macro
call-tree
caml-mode
camldebug
cancel-debug-on-entry
canonically-space-region

capitalize-region
capitalize-region-as-title
capitalize-region-or-word
capitalize-word

cd
cde-start-drag
cde-start-drag-region

center-line
center-paragraph
center-region
center-to-window-line

change-log-merge
change-log-mode
change-log-redate

check-ispell-version

checkdoc
checkdoc-continue
checkdoc-current-buffer
checkdoc-defun
checkdoc-eval-current-buffer
checkdoc-eval-defun
checkdoc-interactive
checkdoc-ispell
checkdoc-ispell-comments
checkdoc-ispell-continue
checkdoc-ispell-current-buffer
checkdoc-ispell-defun
checkdoc-ispell-interactive
checkdoc-ispell-message-interactive
checkdoc-ispell-message-text
checkdoc-ispell-start
checkdoc-message-interactive
checkdoc-message-text
checkdoc-minor-mode
checkdoc-rogue-spaces
checkdoc-start

choose-completion

clear-profiling-info
clear-rectangle
clearcase-install
clearcase-integrate
clearcase-unintegrate

clos-browse
column-number-mode
comint-dynamic-complete
comint-mode
comint-run
command-apropos
command-history-mode
comment-region
compare-windows
compilation-minor-mode
compilation-mode
compilation-shell-minor-mode
compile
compile-defun
complete

completion-do-in-minibuffer
completion-list-mode
completion-list-mode-quit
completion-switch-to-minibuffer

compose-mail
compose-mail-other-frame
compose-mail-other-window

consing-since-gc
context-en-mode
context-nl-mode

conx
conx-buffer
conx-load
conx-region

copy-file
copy-from-above-command
copy-primary-selection
copy-rectangle-to-register
copy-region-as-kill
copy-to-buffer
copy-to-register

count-lines-buffer
count-lines-page
count-lines-region
count-matches
count-words-buffer
count-words-region

cperl-mode
cperl-perldoc
cperl-perldoc-at-point

css-mode

ctypes-all-buffers
ctypes-auto-parse-mode
ctypes-buffer
ctypes-define-type
ctypes-define-type-in-mode
ctypes-dir
ctypes-file
ctypes-read-file
ctypes-tags

customize
customize-apropos
customize-apropos-faces
customize-apropos-groups
customize-apropos-options
customize-browse
customize-changed-options
customize-customized
customize-face
customize-face-other-window
customize-group
customize-group-other-window
customize-option
customize-option-other-window
customize-other-window
customize-save-customized
customize-save-variable
customize-saved
customize-set-value
customize-set-variable
customize-variable
customize-variable-other-window

cvs-checkout
cvs-examine
cvs-log-mode
cvs-quickdir
cvs-status
cvs-status-mode
cvs-update
#@nonl
#@-node:ekr.20050921094025.261:c c- calc-, call- capitalize- center- checkdoc- command- completion- copy- count- customize- cvs-
#@+node:ekr.20050921094025.262:d dabbrev- define- delete- describe- dictionary dired- display- downcase-
dabbrev-completion
dabbrev-expand

dbx

debug
debug-on-entry

decipher
decipher-mode
decrease-left-margin
decrease-right-margin

define-abbrevs
define-global-abbrev
define-mail-alias
define-mode-abbrev
defining-kbd-macro

delete-backward-char
delete-blank-lines
delete-char
delete-completion-window
delete-directory
delete-file
delete-frame
delete-horizontal-space
delete-indentation
delete-matching-lines
delete-non-matching-lines
delete-other-frames
delete-other-windows
delete-primary-selection
delete-rectangle
delete-region
delete-selection-mode
delete-window
delete-windows-on

deprecated-help-command

describe-beta
describe-bindings
describe-buffer-case-table
describe-class
describe-copying
describe-current-display-table
describe-distribution
describe-function
describe-function-arglist
describe-function-at-point
describe-generic
describe-installation
describe-key
describe-key-briefly
describe-last-error
describe-method
describe-mode
describe-no-warranty
describe-pointer
describe-prefix-bindings
describe-project
describe-stroke
describe-syntax
describe-variable
describe-variable-at-point

desktop-entry-mode
desktop-read

diary
diary-mail-entries

dictionary
dictionary-lookup-definition
dictionary-match-words
dictionary-mouse-popup-matching-words
dictionary-popup-matching-words
dictionary-search

diff
diff-backup
diff-minor-mode
diff-mode

digit-argument
directory-tree-thing

dired
dired-apropos
dired-backup-diff
dired-cleanup
dired-compress-subdir-files
dired-describe-mode
dired-diff
dired-do-background-shell-command
dired-do-compress
dired-do-copy-regexp
dired-do-grep
dired-do-hardlink-regexp
dired-do-igrep
dired-do-igrep-find
dired-do-print
dired-do-relsymlink-regexp
dired-do-rename-regexp
dired-do-shell-command
dired-do-symlink-regexp
dired-do-uucode
dired-downcase
dired-ediff
dired-emerge
dired-emerge-with-ancestor
dired-epatch
dired-flag-extension
dired-flag-files-regexp
dired-jump-back
dired-jump-back-other-frame
dired-jump-back-other-window
dired-mark-extension
dired-mark-files-compilation-buffer
dired-mark-files-from-other-dired-buffer
dired-mark-files-regexp
dired-mark-sexp
dired-other-frame
dired-other-window
dired-read-mail
dired-report-bug
dired-rmail
dired-summary
dired-upcase
dired-virtual
dired-vm

disable-command
disassemble

display-buffer
display-call-tree
display-column-mode
display-time

dissociated-press
dns-mode
dns-mode-soa-increment-serial
do-auto-save
docbook-grep
docbook-mode
docref-setup
doctor
down-list

downcase-region
downcase-region-or-word
downcase-word

drag-window-divider
dsssl-mode
dunnet
#@nonl
#@-node:ekr.20050921094025.262:d dabbrev- define- delete- describe- dictionary dired- display- downcase-
#@+node:ekr.20050921094025.263:e ediff- edir edit- emerge- end- exchange- eshell eval- exit- expand-
ebuffers
ebuffers3

ecb-activate
ecb-byte-compile
ecb-minor-mode
ecb-show-help
edebug-defun
edebug-eval-top-level-form

ediff
ediff-backup
ediff-buffers
ediff-buffers3
ediff-customize
ediff-directories
ediff-directories3
ediff-directory-revisions
ediff-documentation
ediff-files
ediff-files3
ediff-merge
ediff-merge-buffers
ediff-merge-buffers-with-ancestor
ediff-merge-directories
ediff-merge-directories-with-ancestor
ediff-merge-directory-revisions
ediff-merge-directory-revisions-with-ancestor
ediff-merge-files
ediff-merge-files-with-ancestor
ediff-merge-revisions
ediff-merge-revisions-with-ancestor
ediff-merge-with-ancestor
ediff-patch-buffer
ediff-patch-file
ediff-regions-linewise
ediff-regions-wordwise
ediff-revision
ediff-show-registry
ediff-toggle-multiframe
ediff-toggle-use-toolbar
ediff-version
ediff-windows-linewise
ediff-windows-wordwise
ediff3

edir-merge-revisions
edir-merge-revisions-with-ancestor
edir-revisions
edirs
edirs-merge
edirs-merge-with-ancestor
edirs3

edit-abbrevs
edit-abbrevs-mode
edit-abbrevs-redefine
edit-bookmarks
edit-faces
edit-itimers
edit-kbd-macro
edit-last-kbd-macro
edit-mime
edit-named-kbd-macro
edit-picture
edit-pr
edit-tab-stops
edit-tab-stops-note-changes
edit-toolbar

edt-emulation-on
edt-set-scroll-margins

efs-display-ftp-activity
efs-nslookup-host
efs-report-bug
efs-set-passwd
efs-set-user

eieio-class-tree
eieio-describe-class
eieio-describe-generic
eieio-describe-method

eif-browse
eiffel-mode
eldoc-mode

electric-buffer-list
electric-command-history
electric-nroff-mode

elp-instrument-function
elp-instrument-list
elp-instrument-package
elp-results

emacs-lisp-byte-compile
emacs-lisp-byte-compile-and-load
emacs-lisp-mode
emacs-version

emerge
emerge-buffers
emerge-buffers-with-ancestor
emerge-files
emerge-files-with-ancestor
emerge-merge-directories
emerge-revisions
emerge-revisions-with-ancestor

enable-command
enable-flow-control

encrypt-insert-file-contents

end-kbd-macro
end-of-buffer
end-of-buffer-other-window
end-of-defun
end-of-line

enlarge-window
enlarge-window-horizontally
enlarge-window-pixels

enriched-mode
epatch

epatch-buffer
erase-buffer

erc-add-dangerous-host
erc-add-fool
erc-add-keyword
erc-add-pal
erc-autojoin-mode
erc-button-mode
erc-chanlist
erc-cmd-LIST
erc-complete
erc-completion-mode
erc-delete-dangerous-host
erc-delete-fool
erc-delete-keyword
erc-delete-pal
erc-fill-mode
erc-log-mode
erc-nickserv-identify
erc-nickserv-identify-mode
erc-notify-mode
erc-ring-mode
erc-save-buffer-in-logs
erc-select
erc-server-select
erc-services-mode
erc-spelling-mode
erc-timestamp-mode
erc-track-mode
erc-track-when-inactive-mode
erc-truncate-buffer
erc-truncate-mode
erc-xdcc-add-file

eregistry
erevision
escreen-install

eshell
eshell-command
eshell-report-bug
eshell-test
eshell-toggle
eshell-toggle-cd

eudc-edit-hotlist
eudc-expand-inline
eudc-get-email
eudc-get-phone
eudc-insert-record-at-point-into-bbdb
eudc-load-eudc
eudc-query-form
eudc-set-server
eudc-try-bbdb-insert

eval-buffer
eval-current-buffer
eval-defun
eval-expr
eval-expr-install
eval-expression
eval-last-sexp
eval-print-last-sexp
eval-region

exchange-dot-and-mark
exchange-point-and-mark

executable-self-display
executable-set-magic

execute-extended-command

exit-minibuffer
exit-recursive-edit

expand-abbrev
expand-region-abbrevs
#@nonl
#@-node:ekr.20050921094025.263:e ediff- edir edit- emerge- end- exchange- eshell eval- exit- expand-
#@+node:ekr.20050921094025.264:f fill- find- format- forward-
f90-mode

facemenu-make-larger
facemenu-make-much-larger
facemenu-make-much-smaller
facemenu-make-smaller
facemenu-remove-props
facemenu-remove-special
facemenu-set-background
facemenu-set-face
facemenu-set-face-from-menu
facemenu-set-foreground
facemenu-set-intangible
facemenu-set-invisible
facemenu-set-read-only
facemenu-set-size-default

fast-lock-mode

feedmail-queue-reminder
feedmail-run-the-queue
feedmail-run-the-queue-global-prompt
feedmail-run-the-queue-no-prompts

ffap
ffap-at-mouse
ffap-menu
ffap-next

fill-individual-paragraphs
fill-nonuniform-paragraphs
fill-paragraph
fill-paragraph-or-region
fill-region
fill-region-as-paragraph

find-alternate-file
find-alternate-file-other-window
find-file
find-file-at-point
find-file-other-frame
find-file-other-window
find-file-read-only
find-file-read-only-other-frame
find-file-read-only-other-window
find-function
find-function-at-point
find-function-on-key
find-function-other-frame
find-function-other-window
find-library
find-library-other-frame
find-library-other-window
find-tag
find-tag-at-point
find-tag-other-window
find-variable
find-variable-at-point
find-variable-other-frame
find-variable-other-window

finder-by-keyword
finder-commentary
finger
first-error
fixup-whitespace
flame

floating-toolbar
floating-toolbar-from-extent-or-popup-mode-menu
floating-toolbar-or-popup-mode-menu

flush-lines

flyspell-buffer
flyspell-mode
flyspell-prog-mode
flyspell-region
flyspell-version

folding-mode
folding-mode-add-find-file-hook

font-lock-fontify-buffer
font-lock-mode

footnote-mode

format-decode-buffer
format-decode-region
format-encode-buffer
format-encode-region
format-find-file
format-insert-file
format-write-file

forms-find-file
forms-find-file-other-window
forms-mode

fortran-mode

forward-block-of-lines
forward-char
forward-char-command
forward-line
forward-list
forward-page
forward-paragraph
forward-sentence
forward-sexp
forward-to-indentation
forward-word

frame-configuration-to-register
ftelnet
ftp
full-calc
full-calc-keypad
fume-mode
fume-setup-buffer
function-menu
fundamental-mode
fusion-mode
#@nonl
#@-node:ekr.20050921094025.264:f fill- find- format- forward-
#@+node:ekr.20050921094025.265:g global- goto- grep-
garbage-collect
gdb
gdb-with-core
gdbsrc
generate-file-autoloads
generic-page-setup
generic-print-buffer
getenv

global-auto-revert-mode
global-semantic-auto-parse-mode
global-semantic-show-dirty-mode
global-semantic-show-unmatched-syntax-mode
global-semantic-summary-mode
global-semanticdb-minor-mode
global-senator-minor-mode
global-set-key
global-set-stroke
global-unset-key

gnats:edit-pr
gnats:query-pr
gnats:summ-pr
gnats:view-pr

gnuserv-start
gomoku

google-query
google-query-region

goto-address
goto-address-at-mouse
goto-address-at-point
goto-char
goto-line

grep
grep-all-files-in-current-directory
grep-all-files-in-current-directory-and-below
grep-find

gtk-start-drag
gtk-start-drag-region
#@nonl
#@-node:ekr.20050921094025.265:g global- goto- grep-
#@+node:ekr.20050921094025.266:h help- hide- html- hyper-
hanoi
haskell-doc-mode
haskell-doc-show-type
haskell-mode

help
help-for-help
help-mode
help-mode-bury
help-mode-quit
help-next-section
help-next-symbol
help-prev-section
help-prev-symbol
help-quit
help-with-tutorial

hexl-find-file
hexl-mode
hexlify-buffer

hide-copyleft-region
hide-ifdef-mode

highlight-headers-follow-url
highlight-headers-follow-url-kfm
highlight-headers-follow-url-mosaic
highlight-headers-follow-url-netscape

highline-customize
highline-local-mode
highline-mode
highline-mode-off
highline-mode-on
highline-off
highline-on
highline-view-mode
highline-view-off
highline-view-on

hippie-expand
hm--html-minor-mode
hm--html-mode
hmail:compose
holidays
how-many
hs-minor-mode

html-mode
html-quote-region
html-view-get-display
html-view-goto-url
html-view-start-mosaic
html-view-view-buffer
html-view-view-file
htmlize-buffer
htmlize-file
htmlize-many-files
htmlize-many-files-dired
htmlize-region

hyper-apropos
hyper-apropos-popup-menu
hyper-apropos-set-variable
hyper-describe-face
hyper-describe-function
hyper-describe-key
hyper-describe-key-briefly
hyper-describe-variable
hyper-set-variable
hyper-where-is

hyperb:customize
hyperb:find-file-urls-mode
hyperb:init-menubar
hyperbole

hypropos-popup-menu
hypropos-set-variable
#@nonl
#@-node:ekr.20050921094025.266:h help- hide- html- hyper-
#@+node:ekr.20050921094025.267:i ibuffer- id-select- igrep- indent- info- insert- isearch- ispell- iswitchb- itimer-
ibuffer
ibuffer-add-saved-filters
ibuffer-add-to-tmp-hide
ibuffer-add-to-tmp-show
ibuffer-auto-mode
ibuffer-backward-filter-group
ibuffer-backwards-next-marked
ibuffer-bs-show
ibuffer-clear-filter-groups
ibuffer-copy-filename-as-kill
ibuffer-customize
ibuffer-decompose-filter
ibuffer-delete-saved-filter-groups
ibuffer-delete-saved-filters
ibuffer-diff-with-file
ibuffer-do-kill-lines
ibuffer-do-occur
ibuffer-exchange-filters
ibuffer-filter-disable
ibuffer-filters-to-filter-group
ibuffer-forward-next-marked
ibuffer-invert-sorting
ibuffer-jump-to-buffer
ibuffer-jump-to-filter-group
ibuffer-kill-filter-group
ibuffer-kill-line
ibuffer-list-buffers
ibuffer-mark-by-file-name-regexp
ibuffer-mark-by-mode
ibuffer-mark-by-mode-regexp
ibuffer-mark-by-name-regexp
ibuffer-mark-dired-buffers
ibuffer-mark-dissociated-buffers
ibuffer-mark-help-buffers
ibuffer-mark-modified-buffers
ibuffer-mark-old-buffers
ibuffer-mark-read-only-buffers
ibuffer-mark-special-buffers
ibuffer-mark-unsaved-buffers
ibuffer-negate-filter
ibuffer-or-filter
ibuffer-other-window
ibuffer-pop-filter
ibuffer-pop-filter-group
ibuffer-save-filter-groups
ibuffer-save-filters
ibuffer-set-filter-groups-by-mode
ibuffer-switch-to-saved-filter-groups
ibuffer-switch-to-saved-filters
ibuffer-toggle-sorting-mode
ibuffer-yank

icomplete-mode
icon-mode
iconify-emacs
iconify-frame

id-select-and-copy-thing
id-select-and-kill-thing
id-select-goto-matching-tag
id-select-install
id-select-thing
id-select-thing-with-mouse

idl-mode
idlwave-mode
idlwave-shell
ielm
ifconfig

ignore

igrep
igrep-find
igrep-insinuate
igrep-visited-files

ilisp-imenu-add-menubar-index
image-mode

imenu
imenu-add-menubar-index
imenu-add-to-menubar

increase-left-margin
increase-right-margin

increment-register

indent-according-to-mode
indent-code-rigidly
indent-for-comment
indent-for-tab-command
indent-new-comment-line
indent-region
indent-relative
indent-relative-maybe
indent-rigidly
indent-sexp
indent-to
indent-to-column

indented-text-mode
inferior-prolog-mode
inferior-tcl

info
info-browse
info-complete-file
info-complete-symbol
info-lookup-file
info-lookup-reset
info-lookup-symbol

insert-abbrevs
insert-buffer
insert-file
insert-kbd-macro
insert-key-binding
insert-parentheses
insert-register
insert-selection
insert-zippyism

install-where-was-i
inverse-add-global-abbrev
inverse-add-mode-abbrev
invert-face
ipconfig

isearch-*-char
isearch-abort
isearch-backward
isearch-backward-regexp
isearch-cancel
isearch-complete
isearch-complete-edit
isearch-delete-char
isearch-edit-string
isearch-exit
isearch-forward
isearch-forward-exit-minibuffer
isearch-forward-regexp
isearch-help-or-delete-char
isearch-mode-help
isearch-nonincremental-exit-minibuffer
isearch-printing-char
isearch-quote-char
isearch-repeat-backward
isearch-repeat-forward
isearch-return-char
isearch-reverse-exit-minibuffer
isearch-ring-advance
isearch-ring-advance-edit
isearch-ring-retreat
isearch-ring-retreat-edit
isearch-toggle-case-fold
isearch-toggle-regexp
isearch-whitespace-chars
isearch-yank-clipboard
isearch-yank-kill
isearch-yank-line
isearch-yank-selection
isearch-yank-sexp
isearch-yank-word
isearch-yank-x-clipboard
isearch-yank-x-selection
isearch-|-char

iso-accents-mode

ispell
ispell-buffer
ispell-change-dictionary
ispell-comments-and-strings
ispell-complete-word
ispell-complete-word-interior-frag
ispell-continue
ispell-kill-ispell
ispell-message
ispell-minor-mode
ispell-pdict-save
ispell-region
ispell-word

iswitchb-buffer
iswitchb-buffer-other-frame
iswitchb-buffer-other-window
iswitchb-default-keybindings
iswitchb-display-buffer

itimer-edit-delete-itimer
itimer-edit-help
itimer-edit-next-field
itimer-edit-previous-field
itimer-edit-quit
itimer-edit-set-field
#@nonl
#@-node:ekr.20050921094025.267:i ibuffer- id-select- igrep- indent- info- insert- isearch- ispell- iswitchb- itimer-
#@+node:ekr.20050921094025.268:j jde-
japanese-latex-mode
japanese-plain-tex-mode

java-browse
java-mode

javascript-mode
javascript-shell

jde-ant-build
jde-ant-projecthelp
jde-ant-show-options
jde-bug-debug-app
jde-build
jde-checkstyle
jde-checkstyle-customize
jde-compile
jde-compile-jde
jde-create-new-project
jde-db-set-app-args
jde-db-set-args
jde-db-set-debugger
jde-ejb-entity-bean-buffer
jde-ejb-session-bean-buffer
jde-gen-buffer
jde-gen-class-buffer
jde-gen-console-buffer
jde-gen-interface-buffer
jde-gen-jfc-app-buffer
jde-gen-junit-test-class-buffer
jde-help-browse-jdk-doc
jde-import-organize
jde-java-font-lock-setup-keywords
jde-javadoc-autodoc-at-line
jde-javadoc-checkdoc
jde-javadoc-checkdoc-at-line
jde-javadoc-checker-fix
jde-javadoc-checker-next
jde-javadoc-checker-previous
jde-javadoc-checker-quit
jde-javadoc-customize
jde-javadoc-make
jde-jdb
jde-jdb-applet
jde-make
jde-make-show-options
jde-mode
jde-open-project-file
jde-package-update
jde-run
jde-run-applet
jde-run-set-app
jde-run-set-app-args
jde-run-set-applet-doc
jde-run-set-applet-viewer
jde-run-set-args
jde-save-project
jde-set-compile-options
jde-set-global-classpath
jde-show-help
jde-stat-loc-report
jde-stat-loc-report-directory
jde-stat-loc-report-project
jde-xref-customize
jde-xref-display-call-tree
jde-xref-first-caller
jde-xref-list-uncalled-functions
jde-xref-make-xref-db
jde-xref-next-caller
jde-xref-update

join-line
jump-to-register
just-one-space
justify-current-line
#@nonl
#@-node:ekr.20050921094025.268:j jde-
#@+node:ekr.20050921094025.269:k kill- kimport-
kbd-macro-query
keep-lines

keyboard-escape-quit
keyboard-quit

kfile:find
kfile:view

kill-all-abbrevs
kill-buffer
kill-buffer-and-window
kill-comment
kill-console-local-variable
kill-emacs
kill-entire-line
kill-line
kill-local-variable
kill-paragraph
kill-primary-selection
kill-rectangle
kill-region
kill-ring-save
kill-sentence
kill-sexp
kill-some-buffers
kill-this-buffer
kill-word

kimport:aug-post-outline
kimport:file
kimport:star-outline
kimport:text

klink:create
kotl-mode
kotl-mode:example
ksh-mode
#@nonl
#@-node:ekr.20050921094025.269:k kill- kimport-
#@+node:ekr.20050921094025.270:l lisp- list- load-
latex-mode
lazy-lock-mode
lazy-shot-mode
ledit-mode
liece
life
line-number-mode
linuxdoc-sgml-mode

lisp-complete-symbol
lisp-fill-paragraph
lisp-indent-for-comment
lisp-indent-line
lisp-interaction-mode
lisp-mode
lisp-send-defun

list-abbrevs
list-bookmarks
list-buffers
list-colors-display
list-command-history
list-directory
list-faces-display
list-holidays
list-itimers
list-load-path-shadows
list-matches-in-buffers
list-matching-lines
list-mode
list-mode-item-keyboard-selected
list-mode-item-mouse-selected
list-packages
list-processes
list-strokes
list-tags
list-text-properties-at
list-yahrzeit-dates

literate-haskell-mode

load-default-sounds
load-file
load-library
load-sound-file
load-user-strokes

local-set-key
local-unset-key

locate-library
lock-buffer
lower-frame
lpr-buffer
lpr-region
lua-mode
#@nonl
#@-node:ekr.20050921094025.270:l lisp- list- load-
#@+node:ekr.20050921094025.271:m macroexpand- mail- make- mark- minibuffer- mouse- move-
m4-mode

macroexpand-all-sexp
macroexpand-sexp

mail
mail-mode
mail-other-frame
mail-other-window

make-command-summary
make-compatible
make-compatible-variable
make-directory
make-directory-path
make-face-bold
make-face-bold-italic
make-face-italic
make-face-larger
make-face-smaller
make-face-unbold
make-face-unitalic
make-file-part
make-frame
make-indirect-buffer
make-local-variable
make-obsolete
make-obsolete-variable
make-search-dialog
make-symbolic-link
make-variable-buffer-local
makefile-mode

manual-entry
map-query-replace-regexp
mark-beginning-of-buffer

mark-bob
mark-defun
mark-end-of-buffer
mark-end-of-line
mark-end-of-sentence
mark-eob
mark-page
mark-paragraph
mark-sexp
mark-whole-buffer
mark-word

maybe-unmigrate-user-init-file
mchat
mchat-other-frame

metamail-buffer
metamail-interpret-body
metamail-interpret-header
metamail-region

mew
mew-send
mh-letter-mode
mh-nmail
mh-rmail
mh-smail
mh-smail-other-window
mh-version
migrate-user-init-file
mime-decode-region
mime-encode-region
mime-insert-encoded-file
mime/editor-mode

minibuffer-complete
minibuffer-complete-and-exit
minibuffer-complete-word
minibuffer-completion-help
minibuffer-electric-separator
minibuffer-electric-tilde
minibuffer-keyboard-quit
minibuffer-smart-maybe-select-highlighted-completion
minibuffer-smart-select-highlighted-completion

mode-compile
mode-compile-kill
mode-compile-submit-bug-report

modeline-buffers-menu
modeline-menu
modeline-minor-mode-menu
modeline-toggle-read-only

modify-syntax-entry
modula-2-mode
morse-region

mouse-avoidance-mode
mouse-bury-buffer
mouse-choose-completion
mouse-consolidated-yank
mouse-del-char
mouse-delete-window
mouse-drag-modeline
mouse-eval-last-sexpr
mouse-eval-sexp
mouse-ignore
mouse-keep-one-window
mouse-kill-line
mouse-line-length
mouse-me
mouse-scroll
mouse-select
mouse-select-and-split
mouse-set-mark
mouse-set-point
mouse-track
mouse-track-adjust
mouse-track-adjust-default
mouse-track-default
mouse-track-delete-and-insert
mouse-track-do-rectangle
mouse-track-insert
mouse-unbury-buffer
mouse-window-to-region
mouse-yank

move-past-close-and-reindent
move-to-left-margin
move-to-tab-stop
move-to-window-line

mpuz
mswindows-paste-clipboard
mwheel-install
#@nonl
#@-node:ekr.20050921094025.271:m macroexpand- mail- make- mark- minibuffer- mouse- move-
#@+node:ekr.20050921094025.272:n narrow- newline- next-
name-last-kbd-macro

narrow-stack-mode
narrow-to-defun
narrow-to-page
narrow-to-region
narrow-window-to-region

negative-argument
netstat
network-connection
network-connection-to-service
new-frame

newline
newline-and-indent

next-complete-history-element
next-error
next-file
next-history-element
next-line
next-list-mode-item
next-matching-history-element
next-multiframe-window

normal-mode
not-modified
nroff-mode
nslookup
nslookup-host
nuke-nroff-bs
nuke-selective-display
number-to-register
#@nonl
#@-node:ekr.20050921094025.272:n narrow- newline- next-
#@+node:ekr.20050921094025.273:o open- other- outl- outline- overwrite
objc-browse
objc-mode

occur
occur-mode-goto-occurrence
occur-mode-mouse-goto

offix-start-drag
offix-start-drag-region

old-whitespace-incremental-mode
old-whitespace-mode

oo-browser

open-dribble-file
open-line
open-rectangle
open-termscript

other-frame
other-window

outl-mouse-minor-mode
outl-mouse-mode

outline-minor-mode
outline-mode

overstrike-region
overwrite-mode
own-selection
#@nonl
#@-node:ekr.20050921094025.273:o open- other- outl- outline- overwrite
#@+node:ekr.20050921094025.274:p package- paren- pcomplete- pending- pop- popup- pp- prepend- prettyexapnd- previous- profile- ps- pydoc pymacs- python-
package-admin-add-binary-package
package-admin-add-single-file-package
package-get
package-get-all
package-get-custom
package-get-delete-package
package-get-package-provider
package-get-save-base
package-get-update-all
package-get-update-base
package-get-update-base-from-buffer

paragraph-indent-text-mode
paren-activate
paren-backward-sexp
paren-deactivate
paren-forward-sexp
paren-set-mode
paren-toggle-matching-paired-delimiter
paren-toggle-matching-quoted-paren
paren-toggle-open-paren-context

pascal-mode
patch-to-change-log

patcher-mail
patcher-mail-subproject
patcher-version

pcomplete
pcomplete-continue
pcomplete-expand
pcomplete-expand-and-complete
pcomplete-help
pcomplete-list
pcomplete-reverse

pdb

pending-delete
pending-delete-mode
pending-delete-off
pending-delete-on

perl-mode
perldb
permanent-buffers-mode

pgg-decrypt
pgg-decrypt-region
pgg-encrypt
pgg-encrypt-region
pgg-insert-key
pgg-sign
pgg-sign-region
pgg-snarf-keys
pgg-snarf-keys-region
pgg-verify
pgg-verify-region

phases-of-moon
php-mode
picture-mode
pike-mode
ping

plain-TeX-mode
plain-tex-mode

play-sound-file
point-to-register

pop-global-mark
pop-tag-mark
pop-window-configuration

popper-install

popup-buffer-menu
popup-menubar-menu
popup-mode-menu

posix-search-backward
posix-search-forward

postscript-mode

pp-eval-expression
pp-eval-last-sexp
pp-function
pp-plist
pp-variable

praise-be-unto-emacs
praise-be-unto-xemacs

prefer-coding-system
prefix-region

prepend-to-buffer
prepend-to-register

press-toolbar-button

prettyexpand-all-sexp
prettyexpand-sexp

previous-complete-history-element
previous-error
previous-history-element
previous-line
previous-list-mode-item
previous-matching-history-element
previous-multiframe-window

print-buffer
print-region

profile-command
profile-expression
profile-key-sequence
profile-results

prolog-mode

ps
ps-despool
ps-line-lengths
ps-nb-pages-buffer
ps-nb-pages-region
ps-print-buffer
ps-print-buffer-with-faces
ps-print-customize
ps-print-region
ps-print-region-with-faces
ps-spool-buffer
ps-spool-buffer-with-faces
ps-spool-region
ps-spool-region-with-faces

psychoanalyze-pinhead
pui-add-install-directory
pui-list-packages
push-window-configuration
pwd

py-shell
pydoc-apropos
pydoc-commands
pydoc-help
pydoc-keywords
pydoc-modules
pydoc-packages
pydoc-topics
pydoc-xrefs

pymacs-eval
pymacs-load

python-browse
python-mode
#@nonl
#@-node:ekr.20050921094025.274:p package- paren- pcomplete- pending- pop- popup- pp- prepend- prettyexapnd- previous- profile- ps- pydoc pymacs- python-
#@+node:ekr.20050921094025.275:q query-
query-pr
query-replace
query-replace-regexp
quick-calc
quoted-insert
#@nonl
#@-node:ekr.20050921094025.275:q query-
#@+node:ekr.20050921094025.276:r re- read- recentf- recover- recursive- rename- repeat- replace- reverse- run-
raise-frame

re-builder
re-search-backward
re-search-forward

read-abbrev-file
read-kbd-macro
read-library-name

recent-files-initialize
recent-files-visit-file

recenter

recentf-cancel-dialog
recentf-cleanup
recentf-dialog-mode
recentf-edit-list
recentf-mode
recentf-open-files
recentf-open-more-files
recentf-rebuild-virtual-pathes
recentf-save-list

recover-all-files
recover-file
recover-session
recover-session-finish

recursive-edit

reftex-citation
reftex-index-phrases-mode
reftex-mode

regexp-builder
register-to-point
reindent-then-newline-and-indent
release-and-activate-toolbar-button
release-toolbar-button
remote-compile
remove-directory

rename-buffer
rename-file
rename-uniquely

repeat-complex-command
repeat-matching-complex-command

replace-buffer-in-windows
replace-rectangle
replace-regexp
replace-string

report-emacs-bug
report-xemacs-bug

reposition-window
resize-minibuffer-mode
restore-initial-toolbar
resume-console
reverse-region
revert-buffer
rexx-mode
riece
rlogin

rmail
rmail-input
rmail-mode

rolo-add
rolo-display-matches
rolo-edit
rolo-fgrep
rolo-fgrep-logical
rolo-grep
rolo-kill
rolo-sort
rolo-toggle-datestamps
rolo-yank

rot13-other-window
rotate-yank-pointer
route

rpm
rpm-spec-mode

rsh

rtf-clip-buffer
rtf-clip-region
rtf-export
rtf-export-region
rtf-spool-buffer
rtf-spool-region

ruby-mode
rubydb

run-at-time
run-caml
run-ediff-from-cvs-buffer
run-prolog
run-ruby
run-scheme
run-scsh
run-sml
run-with-idle-timer
run-with-timer
#@nonl
#@-node:ekr.20050921094025.276:r re- read- recentf- recover- recursive- rename- repeat- replace- reverse- run-
#@+node:ekr.20050921094025.277:s save- scroll- search- set- shell- sort- speedbar spell- strokes- suspend- switch- symbol-
s-region-bind
s-region-bind-cua

save-buffer
save-buffers-kill-emacs
save-some-buffers

savehist-load
savehist-save

scheme-mode
scribe-mode

scroll-down
scroll-down-command
scroll-down-one
scroll-left
scroll-other-window
scroll-other-window-down
scroll-right
scroll-up
scroll-up-command
scroll-up-one

sdb

search-backward
search-backward-regexp
search-forward
search-forward-regexp

self-insert-and-exit
self-insert-command

semantic-analyze-current-context
semantic-auto-parse-mode
semantic-bnf-mode
semantic-cb-speedbar-mode
semantic-chart-database-size
semantic-chart-nonterminal-complexity-token
semantic-chart-nonterminals-by-token
semantic-show-dirty-mode
semantic-show-unmatched-syntax-mode
semantic-summary-mode

senator-complete-symbol
senator-completion-menu-popup
senator-jump
senator-jump-regexp
senator-minor-mode
senator-next-token
senator-previous-token
senator-re-search-backward
senator-re-search-forward
senator-search-backward
senator-search-forward
senator-word-search-backward
senator-word-search-forward

send-pr
send-pr-mode
send-pr:send-pr
send-pr:send-pr-mode

set-buffer-file-coding-system
set-buffer-file-coding-system-for-read
set-buffer-process-coding-system
set-comment-column
set-default-buffer-file-coding-system
set-default-file-coding-system
set-face-background
set-face-background-pixmap
set-face-blinking-p
set-face-dim-p
set-face-display-table
set-face-doc-string
set-face-font
set-face-foreground
set-face-highlight-p
set-face-reverse-p
set-face-strikethru-p
set-face-underline-p
set-file-coding-system
set-file-coding-system-for-read
set-fill-column
set-fill-prefix
set-goal-column
set-justification
set-justification-center
set-justification-full
set-justification-left
set-justification-none
set-justification-right
set-keyboard-coding-system
set-left-margin
set-mark-command
set-pathname-coding-system
set-right-margin
set-selective-display
set-terminal-coding-system
set-variable
set-visited-file-name

setenv
setnu-mode
sgml-mode
sh-mode

shell
shell-command
shell-command-on-region
shell-script-mode

show-message-log

shrink-window
shrink-window-horizontally
shrink-window-if-larger-than-buffer
shrink-window-pixels

sieve-manage
sieve-mode
sieve-upload
sieve-upload-and-bury

signal-process
simula-mode

skeleton-pair-insert-maybe
skeleton-proxy
skeleton-proxy-new

smart-c++
smart-info
smart-info-assist
smart-java
smart-objc

smerge
sml-mode
smt-browse
snake
sokoban

sort-columns
sort-fields
sort-float-fields
sort-lines
sort-numeric-fields
sort-pages
sort-paragraphs
sort-regexp-fields
sort-regexp-fields-numerically

speedbar
speedbar-frame-mode
speedbar-get-focus

spell-buffer
spell-region
spell-string
spell-word

split-line
split-window
split-window-horizontally
split-window-vertically

spook

sql-db2
sql-help
sql-informix
sql-ingres
sql-interbase
sql-linter
sql-mode
sql-ms
sql-mysql
sql-oracle
sql-postgres
sql-product-interactive
sql-solid
sql-sqlite
sql-sybase

ssh
standard-display-european
start-itimer
start-kbd-macro
startup-presentation-hack
string-rectangle

strokes-compose-complex-stroke
strokes-decode-buffer
strokes-describe-stroke
strokes-do-complex-stroke
strokes-do-stroke
strokes-global-set-stroke
strokes-help
strokes-list-strokes
strokes-load-user-strokes
strokes-mode

style-format
summ-pr
sunrise-sunset

suspend-console
suspend-emacs
suspend-emacs-or-iconify-frame
suspend-or-iconify-emacs

switch-to-buffer
switch-to-buffer-other-frame
switch-to-buffer-other-window
switch-to-completions
switch-to-other-buffer

symbol-file
symbol-near-point
#@nonl
#@-node:ekr.20050921094025.277:s save- scroll- search- set- shell- sort- speedbar spell- strokes- suspend- switch- symbol-
#@+node:ekr.20050921094025.278:t tab tags- toggle- toolbar- turn-off turn-on
tab-to-tab-stop
tabify

tag-complete-symbol
tags-apropos
tags-loop-continue
tags-query-replace
tags-search

tcl-help-on-word
tcl-mode

tdbx
teco-command
telnet
term
terminal-emulator
tetris

tex-mode
texi2info
texinfo-format-buffer
texinfo-format-region
texinfo-mode
texmathp

text-mode
tgdb
time-stamp
time-stamp-toggle-active

tmpl-expand-templates-in-buffer
tmpl-expand-templates-in-region
tmpl-insert-template-file
tmpl-insert-template-file-from-fixed-dirs
tmpl-minor-mode

toggle-auto-compression
toggle-buffer-file-coding-system
toggle-debug-on-error
toggle-debug-on-quit
toggle-debug-on-signal
toggle-profiling
toggle-read-only
toggle-rot13-mode
toggle-text-mode-auto-fill
toggle-truncate-lines
toggle-viper-mode
toggle-where-was-i

toolbar-add-button-on-the-fly
toolbar-add-execute-macro-button
toolbar-add-kbd-macro
toolbar-compile
toolbar-copy
toolbar-cut
toolbar-debug
toolbar-dired
toolbar-external
toolbar-gnus
toolbar-info
toolbar-ispell
toolbar-ispell-internal
toolbar-mail
toolbar-news
toolbar-not-configured
toolbar-open
toolbar-paste
toolbar-print
toolbar-redo
toolbar-replace
toolbar-save
toolbar-search
toolbar-undo

top-level
tperldb
tpu-edt
tpu-edt-mode
tpu-edt-on
tpu-set-cursor-bound
tpu-set-cursor-free
tpu-set-scroll-margins

tpum-global-mode
tpum-minor-mode

trace-function
trace-function-background
traceroute

transpose-chars
transpose-line-down
transpose-line-up
transpose-lines
transpose-paragraphs
transpose-preceding-chars
transpose-sentences
transpose-sexps
transpose-words

tree-test-it-all
tsdb
tshell

turn-off-font-lock
turn-off-haskell-doc-mode
turn-off-pending-delete
turn-on-auto-fill
turn-on-eldoc-mode
turn-on-font-lock
turn-on-fume-mode
turn-on-haskell-doc-mode
turn-on-pending-delete
turn-on-permanent-buffers

txdb
#@nonl
#@-node:ekr.20050921094025.278:t tab tags- toggle- toolbar- turn-off turn-on
#@+node:ekr.20050921094025.279:u universal- upcase- url-
uil-mode
undefined
underline-region
undo
unexpand-abbrev
unhide-copyleft-region

universal-argument
universal-argument-minus
universal-argument-more
universal-argument-other-key
universal-coding-system-argument

unix-sync
unload-feature
unlock-buffer
unmigrate-user-init-file
unmorse-region
unoverstrike-region
unpop-window-configuration
unrmail
untabify
ununderline-and-unoverstrike-region
ununderline-region
up-list

upcase-initials-region
upcase-region
upcase-region-or-word
upcase-word

update-autoloads-from-directory
update-autoloads-here
update-file-autoloads

url-gateway-nslookup-host
url-mail
url-setup-save-timer

use-hard-newlines
user-mail-address
#@nonl
#@-node:ekr.20050921094025.279:u universal- upcase- url-
#@+node:ekr.20050921094025.280:v view- vm-
vc-annotate
vc-cancel-version
vc-create-snapshot
vc-diff
vc-directory
vc-insert-headers
vc-load-vc-hooks
vc-merge
vc-next-action
vc-print-log
vc-register
vc-rename-file
vc-resolve-conflicts
vc-retrieve-snapshot
vc-revert-buffer
vc-update-change-log
vc-version-diff
vc-version-other-window

verilog-customize
verilog-mode
verilog-version

version
vertical-mode
vhdl-mode

view-buffer
view-buffer-other-window
view-emacs-news
view-file
view-file-other-window
view-lossage
view-major-mode
view-minor-mode
view-mode
view-pr
view-register
view-sample-init-el

viper-mode
visit-tags-table

vm
vm-compose-mail
vm-folders-summarize
vm-mail
vm-mail-other-frame
vm-mail-other-window
vm-mode
vm-other-frame
vm-other-window
vm-submit-bug-report
vm-visit-folder
vm-visit-folder-other-frame
vm-visit-folder-other-window
vm-visit-imap-folder
vm-visit-imap-folder-other-frame
vm-visit-imap-folder-other-window
vm-visit-pop-folder
vm-visit-pop-folder-other-frame
vm-visit-pop-folder-other-window
vm-visit-virtual-folder
vm-visit-virtual-folder-other-frame
vm-visit-virtual-folder-other-window

vrml-mode
#@nonl
#@-node:ekr.20050921094025.280:v view- vm-
#@+node:ekr.20050921094025.281:w win32- winring- word- write-
w3
w3-display-stylesheet
w3-fetch
w3-fetch-other-frame
w3-find-file
w3-follow-link
w3-follow-url-at-point
w3-follow-url-at-point-other-frame
w3-hotindex-add-key
w3-hotindex-query
w3-hotindex-rm-key
w3-hotlist-add-document
w3-hotlist-add-document-at-point
w3-hotlist-append
w3-hotlist-apropos
w3-hotlist-delete
w3-hotlist-refresh
w3-hotlist-rename-entry
w3-maybe-follow-link
w3-maybe-follow-link-mouse
w3-next-document
w3-open-local
w3-prev-document
w3-preview-this-buffer
w3-print-this-url
w3-print-url-under-point
w3-read-html-bookmarks
w3-region
w3-show-dvi
w3-table-speak-current-table-column
w3-use-hotlist
w3-version

wconfig-add-by-name
wconfig-delete-by-name
wconfig-delete-pop
wconfig-restore-by-name
wconfig-ring-save
wconfig-yank-pop

webjump

what-coding-system
what-cursor-position
what-domain
what-line
what-page

where-is

whitespace-buffer
whitespace-cleanup
whitespace-cleanup-region
whitespace-global-mode
whitespace-region
whitespace-toggle-ateol-check
whitespace-toggle-indent-check
whitespace-toggle-leading-check
whitespace-toggle-spacetab-check
whitespace-toggle-trailing-check
whitespace-visual-incremental-mode
whitespace-visual-mode
whitespace-write-file-hook

whois
whois-reverse-lookup
widen

widget-backward
widget-beginning-of-line
widget-browse
widget-browse-at
widget-browse-other-window
widget-button-click
widget-button-press
widget-button1-click
widget-complete
widget-end-of-line
widget-field-activate
widget-file-complete
widget-forward
widget-kill-line
widget-minor-mode
widget-transpose-chars

win32-get-current-locale-id
win32-get-default-locale-id
win32-get-locale-info
win32-get-valid-locale-ids
win32-long-file-name
win32-set-current-locale
win32-set-process-priority
win32-short-file-name

window-configuration-to-register
winmgr-mode

winring-delete-configuration
winring-duplicate-configuration
winring-jump-to-configuration
winring-new-configuration
winring-next-configuration
winring-prev-configuration
winring-rename-configuration

word-search-backward
word-search-forward

wordstar-mode

write-abbrev-file
write-file
write-region
write-region-internal

wrolo-popup-menu
#@nonl
#@-node:ekr.20050921094025.281:w win32- winring- word- write-
#@+node:ekr.20050921094025.282:x xwem-
x-symbol-decode
x-symbol-decode-recode
x-symbol-encode
x-symbol-encode-recode
x-symbol-fontify
x-symbol-grid
x-symbol-image-editor
x-symbol-image-parse-buffer
x-symbol-init-language-interactive
x-symbol-initialize
x-symbol-key-autoload
x-symbol-map-autoload
x-symbol-mode
x-symbol-modify-key
x-symbol-package-bug
x-symbol-package-info
x-symbol-package-reply-to-report
x-symbol-package-web
x-symbol-rotate-key
x-symbol-unalias

xdb

xemacs-local-faq
xemacs-splash-buffer
xemacs-www-faq
xemacs-www-page

xetla
xetla-add-log-entry
xetla-apply-changeset
xetla-archives
xetla-bookmarks
xetla-browse
xetla-changelog
xetla-changes
xetla-changes-against
xetla-changes-last-revision
xetla-commit
xetla-conflicts-finish
xetla-delta
xetla-ediff-add-log-entry
xetla-edit-log
xetla-file-diff
xetla-file-ediff
xetla-file-ediff-revisions
xetla-file-view-original
xetla-get-changeset
xetla-help
xetla-id-tagging-method
xetla-inventory
xetla-inventory-file-mode
xetla-log-edit-mode
xetla-logs
xetla-make-archive
xetla-missing
xetla-my-id
xetla-my-revision-library
xetla-prepare-patch-submission
xetla-revisions
xetla-rm
xetla-start-project
xetla-submit-bug-report
xetla-tag-insert
xetla-tag-regenerate
xetla-tree-lint
xetla-tree-version
xetla-version
xetla-view-conflicts

xmine
xmine-mode
xml-mode
xpm-mode
xrdb-mode
xsl-grep
xsl-mode
xslt-process-mode
xt-check-xlib

xwem-attach-client
xwem-backward-application
xwem-balance-windows
xwem-battery
xwem-battery-popup-menu
xwem-battery-status
xwem-cl-pop-to-client
xwem-cl-set-title
xwem-cl-switch-other-frame
xwem-cl-switch-other-win
xwem-cl-switch-to-other
xwem-cl-switch-to-other-in-other-win
xwem-cl-transpose
xwem-clgen-toggle-other-on-split
xwem-clgen-turn-off-other-on-split
xwem-clgen-turn-on-other-on-split
xwem-client-demanage-others
xwem-client-exchange-selected-and-mark
xwem-client-iconify
xwem-client-idestroy
xwem-client-imove
xwem-client-info
xwem-client-iresize
xwem-client-kill
xwem-client-query-kill
xwem-client-run-copy
xwem-client-run-copy-other-frame
xwem-client-run-copy-other-win
xwem-client-set-mark
xwem-client-unset-mark
xwem-clswi-next
xwem-clswi-next-other-window
xwem-clswi-prev
xwem-clswi-prev-other-window
xwem-copy-cutbuffer
xwem-copy-region-as-cutbuffer
xwem-describe-prefix-bindings
xwem-desktop-load
xwem-desktop-load-onetime
xwem-desktop-save
xwem-desktop-save-onetime
xwem-edit-client-properties
xwem-edmacro-edit-kbd-macro
xwem-eval-expression
xwem-execute-extended-command
xwem-fini
xwem-focus-click-on
xwem-forward-application
xwem-frame-destroy
xwem-frame-fit-screen
xwem-frame-goto-next
xwem-frame-goto-next-hor
xwem-frame-goto-next-vert
xwem-frame-goto-prev
xwem-frame-goto-prev-hor
xwem-frame-goto-prev-vert
xwem-frame-hide
xwem-frame-imove
xwem-frame-iresize
xwem-frame-lower
xwem-frame-next
xwem-frame-on-delim-menu
xwem-frame-on-delim-resize
xwem-frame-previous
xwem-frame-raise
xwem-frame-sbs-hor-split
xwem-frame-sbs-vert-split
xwem-frame-set-name
xwem-frame-showroot
xwem-frame-split-sbs
xwem-frame-switch
xwem-frame-switch-nth
xwem-frame-switch-nth-linkage
xwem-frame-transparency
xwem-frame-transpose
xwem-framei-dockapp-popup-alt-menu
xwem-framei-dockapp-popup-menu
xwem-fullscreen-mode
xwem-help
xwem-help-clients
xwem-help-cutbuffers
xwem-help-describe-bindings
xwem-help-describe-key
xwem-help-describe-key1
xwem-help-for-help
xwem-help-frames
xwem-help-mode
xwem-help-where-is
xwem-help-wins
xwem-ignore-command
xwem-kbd-quit
xwem-kbd-quote-command
xwem-keyboard-quit
xwem-keymacro-begin
xwem-keymacro-end
xwem-keymacro-exit-recursive-edit
xwem-keymacro-recursive-edit
xwem-keymacro-undefined
xwem-keytt-minor-mode
xwem-kill-cl-and-window
xwem-launch-dock-down
xwem-launch-dock-launch
xwem-launch-dock-menu
xwem-launch-lupe
xwem-launch-lupe-other-frame
xwem-launch-lupe-other-win
xwem-launch-program
xwem-launch-program-other-frame
xwem-launch-program-other-win
xwem-launch-xlock
xwem-launch-xterm
xwem-launch-xterm-other-frame
xwem-launch-xterm-other-win
xwem-launcher-toggle-frame-type
xwem-launcher-toggle-split-type
xwem-launcher-turn-on-embedded-frame-type
xwem-launcher-turn-on-horizontal-split-type
xwem-launcher-turn-on-normal-frame-type
xwem-launcher-turn-on-vertical-split-type
xwem-make-frame
xwem-mini-calc
xwem-minib-resize-mode
xwem-minibuffer-activate
xwem-misc-make-screenshot
xwem-misc-pause
xwem-misc-profiling-results
xwem-misc-start-profiling
xwem-modeline-disable
xwem-modeline-enable
xwem-open-file
xwem-other-window
xwem-pager
xwem-pager-move-down
xwem-pager-move-left
xwem-pager-move-right
xwem-pager-move-up
xwem-paste-cutbuffer
xwem-popup-auto-menu
xwem-popup-clients-menu
xwem-recover-do-recover
xwem-recover-toggle
xwem-recover-turn-off
xwem-recover-turn-on
xwem-register-client
xwem-register-frame-config
xwem-register-jump
xwem-register-win-config
xwem-report-bug
xwem-rooter-lower
xwem-rooter-raise
xwem-run-program
xwem-self-insert-or-undefined
xwem-shell-command
xwem-show-message-log
xwem-sm-global-mode
xwem-sm-mode
xwem-strokes-begin
xwem-strokes-cmplx-begin
xwem-strokes-define
xwem-strokes-ibutton1
xwem-strokes-ibutton1up
xwem-strokes-ibutton3
xwem-strokes-idescribe
xwem-strokes-list
xwem-strokes-nocmd
xwem-strokes-unset-last-stroke
xwem-switch-client
xwem-switch-other-client
xwem-switch-to-fullscreen-cl
xwem-tabber-popup-cl-menu
xwem-tabber-switch-cl
xwem-theme-set
xwem-time
xwem-toggle-fullscreen
xwem-transpose-frames
xwem-turn-off-keytt
xwem-turn-off-vline
xwem-turn-on-keytt
xwem-turn-on-vline
xwem-undefined-command
xwem-universal-argument
xwem-universal-command
xwem-universal-digit
xwem-universal-minus
xwem-universal-more
xwem-vline-minor-mode
xwem-weather-popup-menu
xwem-weather-popup-remove
xwem-weather-show-details
xwem-weather-update
xwem-window-delete
xwem-window-delete-others
xwem-window-enlarge-horizontally
xwem-window-enlarge-vertically
xwem-window-split-horizontally
xwem-window-split-vertically
xwem-winmove-down
xwem-winmove-left
xwem-winmove-right
xwem-winmove-up
xwem-worklog-login
xwem-worklog-logout
#@nonl
#@-node:ekr.20050921094025.282:x xwem-
#@+node:ekr.20050921094025.283:y yank-
yank
yank-clipboard-selection
yank-pop
yank-rectangle
yow
#@-node:ekr.20050921094025.283:y yank-
#@+node:ekr.20050921094025.284:z zap-
zap-to-char
zap-up-to-char
zenirc
#@nonl
#@-node:ekr.20050921094025.284:z zap-
#@-node:ekr.20050921094025.254:All xemacs commands
#@+node:ekr.20050921094025.6:What I did
@nocolor
#@nonl
#@+node:ekr.20051004132320:Early days
#@+node:ekr.20050921094025.7:Rewrote buildBufferList
There may be bugs here.  The old code had definite strange aspects to it.
#@nonl
#@-node:ekr.20050921094025.7:Rewrote buildBufferList
#@+node:ekr.20050921094025.8:Removed Emacs_instances class var
createBindings now sets c.emacs, so modifyOnBodyKey just uses c.emacs.
#@nonl
#@-node:ekr.20050921094025.8:Removed Emacs_instances class var
#@+node:ekr.20050921094025.9:Added c ivar to Emacs class
This is an important addition:  it guarantees that the proper commander is always used.
#@nonl
#@-node:ekr.20050921094025.9:Added c ivar to Emacs class
#@+node:ekr.20050921094025.10:Removed labels class var
This is not needed.  createBindings is called at most once per commander.
#@nonl
#@-node:ekr.20050921094025.10:Removed labels class var
#@+node:ekr.20050921094025.11:Added baseCommands class
Subclasses of baseCommands class should implement getPublicCommands.

This returns a dict whose keys are emacs command names and whose values are bound methods.
#@nonl
#@-node:ekr.20050921094025.11:Added baseCommands class
#@+node:ekr.20050921094025.12:The big collapse (of complexity)
The miniBufferClass is the one half of the great divide.  The commands classes are the other.

- The commnds classes do not understand the details of the miniBufferClass: it can be rearranged as needed.

(done) Replace:
    svar, label = self.getSvarLabel( event )
by:
    b = self.miniBuffer ; tbuffer = event.widget

(done) self.setSvar(event,svar) -> b.update(event)
(done) svar ->  b
(done) label.configure(background='lightblue') --> b.setLabelBlue()
(done) self.miniBuffer -> b
(done) Replaced all delegators by b.methods.
(done) Removed unused args from most methods.
#@nonl
#@-node:ekr.20050921094025.12:The big collapse (of complexity)
#@+node:ekr.20050921094025.13:Improvements to commands
- Improved feedback for interactive search.
    - The minibuffer now says isearch:
    - Added args to miniBuffer.set/get methods to protect/ignore initial prompt characters.

- Backspacing when tab completion cuts back to last 'really' typed character.
    - Further backspaces work as you would expect.
#@nonl
#@-node:ekr.20050921094025.13:Improvements to commands
#@+node:ekr.20050921094025.14:Removed all globals
- positions and tnodes globals are now ivars of bufferCommands class.
#@nonl
#@-node:ekr.20050921094025.14:Removed all globals
#@+node:ekr.20050921094025.15:Fixed bug: newline was not setting body pane dirty
The fix was to return return orig_OnBodyKey(self.c.frame.body,event) at end of masterCommand.
#@nonl
#@-node:ekr.20050921094025.15:Fixed bug: newline was not setting body pane dirty
#@+node:ekr.20050921101706:Replaced 'M-x' prompt by 'full-command'
#@-node:ekr.20050921101706:Replaced 'M-x' prompt by 'full-command'
#@+node:ekr.20050921105623:Added useMiniBuffer and useEditorMenu @settings
#@-node:ekr.20050921105623:Added useMiniBuffer and useEditorMenu @settings
#@+node:ekr.20050921105623.1:Deleted coreEmacs plugin
No longer needed.
#@nonl
#@-node:ekr.20050921105623.1:Deleted coreEmacs plugin
#@+node:ekr.20050922080526:Fixed outline selection bug
Thie problem was in the code at the end of keyHandler.finishCreate.

The watchDelete hack was interfering with some kind of event.

It was an ugly hack anyway ;-)
#@nonl
#@-node:ekr.20050922080526:Fixed outline selection bug
#@+node:ekr.20050923143034:c.commandsDict now describes all commands
- Keys are full Emacs command names, values are methods.
#@nonl
#@-node:ekr.20050923143034:c.commandsDict now describes all commands
#@+node:ekr.20050923141539:Rewrote altX code
- Eliminated iterator class.  (I now understand the code :-)
- Automatically call b.clearState() and b.keyboardQuit() before dispatching commands.
- Tab completion returns a non-trivial common prefix if it exists.  Further tabs cycle through possibilities.
#@nonl
#@-node:ekr.20050923141539:Rewrote altX code
#@+node:ekr.20050923233827:Eliminated all helper classes and simplified the code.
- Eliminated self.tbuffer

- Removed all subclssses from keyHandlerClass.
    - Replaced all references to keyHandler, miniBuffer, kstrokeManager, etc.
    - All methods are now methods of the keyHandler class.

- k denotes the keyHandler class everywhere.
    - All commands classes define k ivar that refers to keyHandler.

- Replaced tbuffer by w everywhere.

The effect of these changes:
    - There is never any confusion about how to access a keyHandler method: just use k.whatever.
    - The init logic is simple and clean.
    - The client code is visually much shorter and easier to understand.
    - The keyHandler class is now simpler, though larger.
    - There is no need for redirector methods.
#@nonl
#@-node:ekr.20050923233827:Eliminated all helper classes and simplified the code.
#@-node:ekr.20051004132320:Early days
#@+node:ekr.20050924073836.1:Simplifications 1
- setEvent is only used in one commands class, so it was moved there.

- setLabelBlue and setLabelGrey now can set the label text as well as color.
  This is a nice simplification of the client code.

- Changed k.get, k.set and k.update to k.getLabel, k.setLable and k.updateLabel.
  This is an important clarification.

- Used simplified state-handling scheme, under control of k.newState ivar.
    - I now see that state-handling is actually fully encapsulated in the commands classes.
    - In particular, masterCommand knows essentially nothing of states.
    - Removed getStateCommands dicts.

- Simplified keyboardQuit by defining leoEditCommands.initAllEditCommanders at the module level.
    - This call theInstance.init() for all commands classes.
      The default in the base class does nothing.
#@nonl
#@-node:ekr.20050924073836.1:Simplifications 1
#@+node:ekr.20051001180444:Simplifications 2
10/1/05

Important simplifications:

- Dispatchers call endCommand (via handleEndCommand)
  when a command returns and there is no state.
- "User" commands need only clear the state and set (or clear) the label:
  everything else is automatic.
- endCommand calls bodyWillChange.  This is the correct way to ensure that changes 'stick'.
- Dispatchers will return 'break' or None as appropriate:
  User code will not have to worry about this.
- keyboardQuit still exists, but it merely clears the state and the label.
  As before, commands may set the label to inform the user of what has happened.
#@nonl
#@-node:ekr.20051001180444:Simplifications 2
#@+node:ekr.20051002161714:Simplfications 3
- Removed tailEnd and return 'break's.  They are no longer needed.

- Replaced stopControlX by keyboardQuit.

- Rewrote state handling for search commands.

- Call endCommand after every keystroke.

- Set k.commandName to include args in keep-lines, shell-command, etc.

- Removed k.doUndo.
#@nonl
#@-node:ekr.20051002161714:Simplfications 3
#@+node:ekr.20051003140625:Improvements
- Extended k.commandName for undoable commands that use extension arguments.
  There aren't that many such commands, surprisingly.
#@nonl
#@-node:ekr.20051003140625:Improvements
#@+node:ekr.20051004085713:Improvement 2
- Split abbrevDispatch into addAbbreviation and inversAddAbbriviation.
- Removed coresponding lambda's.
- Change the hard binding for <Control-g> to k.abbortAllModesKey.
- Renamed the top-level dispatches to fullCommand and quickCommand.
** Massive improvements to rectangle and register commands.
    - new rCommands dispatcher.
    - Use new states in rCommands and most rectangle and register commands.
    - This simplifies and localizes the code.
    - The new code gives much better feedback.
    - Allow arbitrary location-types in registers:  e.g. 'end'
#@nonl
#@-node:ekr.20051004085713:Improvement 2
#@+node:ekr.20051007093659:Final integration
@nocolor

- menu.createMenuEntries calls c.keyHandler.bindShortcutFromMenu if useMiniBuffer is True.
    menu.createMenuEntries makes **no** bindings itself in this case.

- Created k.makeAllBindings to localize bindings.

- bindShortcutFromMenu and setBufferStrokes use two levels of callbacks.
    The keyCallback is bound to the key: it calls k.masterCommand.
    It refers to a refers to a second callback that dispatches the actual command.

- bindKey now tests for duplicates and recovers from bad key bindings (user error).

- Removed test to keystrokeFunctionDict in masterCommand.
    The regular key binding mechanism should be enough!
#@nonl
#@-node:ekr.20051007093659:Final integration
#@+node:ekr.20051008065518:Final integration 2
- k.finishCreate calls k.createInverseCommandsDict first.

- The values in k.inverseCommandsDict are f.__name__, rather than f.

- leoCommands.getPublicCommands now adds underlying f.__name__ to k.inverseCommandsDict rather than leoCallback.

- createInverseCommandsDict ignores 'leoCallback' when adding entries.

- Used k.inverseCommandsDict in << set accel to the shortcut for name >> to get shortcuts using emacs-style names.

    This allows either old-style menu shortcuts or emacs command names.

- Allow '-' in shortcut names in parseShortcutLine.

- Allow trailing comments in shortcut names in parseShortcutLine.

* cb_dict is now vestigial and will soon be removed.
    However, <Alt-X> is not bound properly at present.

Binding is mostly complete:  the traces from createMenuEntries show missing command names in leoSettings.leo.

- Removed last traces of cbDict ivar.  Use. by k.bindingsDict as need.
#@nonl
#@-node:ekr.20051008065518:Final integration 2
#@+node:ekr.20051009042953:Changeover
@nocolor

- replaced x.useMiniBuffer by c.useMiniBuffer.
- Replace useEditorMenu by useCmdMenu, etc.
- Call createMenuBar in c.finishCreate.
- Removed all dummy methods from nullMenu class.
    - The methods of the base class will do fine, provided that an overrided oops method does nothing!
** Always define c.keyHandler, even if c.useMiniBuffer is False.
    - Changes to c.finishCreate and keyHandler.ctor.
- Removed all warnings:
    - Added dynamicMenu arg to createMenuEntries to suppress a warning when a menu is created from a plugin.
    - Revise << set accel to the shortcut for name >> in createMenuEntries tests c.useMiniBuffer.
    - Use c.frame.selectAllText instead of c.editCommands.selectAll.
- Fixed bug in makeSpecialBindings so that Control-g works.
#@nonl
#@-node:ekr.20051009042953:Changeover
#@+node:ekr.20051009130341:Bugs fixed
- Make all bindings to c.frame.top (not w) in bindKey.
  This make bindings available everywhere.
#@nonl
#@-node:ekr.20051009130341:Bugs fixed
#@+node:ekr.20051011091759:Added big kludge to solve infamous control-v problems
Added big kludge to menu.createMenuEntries so that f.OnCut/Copy/PasteFromMenu get called
**only** when explicitly selected from the menu (rather than from a shortcut).
This allows the code in cut/copy/paste-text to be different as needed.

Users can override the shortcut by assigning shortcuts to cut/copy/paste-text commands.
The shortcut will appear in the menu, but does **not** get bound to c.frame.menu.

This is an essential step in solving the infamous Control-V problem.
The code appears to work properly on XP.  Not tested other places.

This is the last best hope to solve this problem: the code interacts as little as possible with Tk.
#@nonl
#@-node:ekr.20051011091759:Added big kludge to solve infamous control-v problems
#@-node:ekr.20050921094025.6:What I did
#@-node:ekr.20050920084720.1:Moved emacs commands and new keyHandler to Leo's core
#@+node:ekr.20051006122237:(Recent)
#@+node:ekr.20041120112043:g.app.config.parseShortcutLine  (Generalize this)
def parseShortcutLine (self,s):
    
    """Return the kind of @settings node indicated by p's headline."""
    
    name = val = None
    i = g.skip_id(s,0,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[0:i]
    if name:
        i = g.skip_ws(s,i)
        if g.match(s,i,'='):
            i = g.skip_ws(s,i+1)
            val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace. 
    if val:
        i = val.find('#')
        if i > 0 and val[i-1] in (' ','\t'):
            val = val[:i].strip()
            # g.trace('removed comment from shortcut: %s' % (val))

    # g.trace("%30s %s" %(name,val))
    return name,val
#@nonl
#@-node:ekr.20041120112043:g.app.config.parseShortcutLine  (Generalize this)
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    k.stroke = stroke # Set this global for general use.
    commandName = k.ultimateFuncName(func)
    special = event.keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'

    # if interesting: g.trace(stroke,commandName)

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=event.keysym))

    if inserted:
        # g.trace(stroke,event.keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.previousStroke = stroke
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName,tag='keyboard-quit')
        return 'break'

    if k.inState():
        k.forceFocusToBody()
        k.previousStroke = stroke
        k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # k.previousStroke = stroke
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = event.keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        k.previousStroke = stroke
        forceFocus = func.__name__ != 'leoCallback'
        if forceFocus:
            k.forceFocusToBody()
        func(event)
        k.endCommand(event,commandName,forceFocus,tag='masterCommand')
        return 'break'

    else:
        c.frame.body.onBodyKey(event)
        return None # Not 'break'
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,event.keysym)

if len(event.char) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,event.char)

if 0: # traces
    g.trace(event.keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self
    
    # g.trace(k.stateKind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            k.state.handler(event)
            k.endCommand(event,k.commandName,tag='callStateFunction')
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName,forceFocus,tag='callKeystrokeFunction')
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@+node:ekr.20051009120608:(ctors & finishCreate)
#@+node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20031218072017.2812:c.__init__
def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()
    self.useMiniBuffer = c.config.getBool('useMiniBuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)
#@nonl
#@-node:ekr.20031218072017.2812:c.__init__
#@+node:ekr.20040731071037:c.initIvars
def initIvars(self):

    c = self
    << initialize ivars >>
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)
#@nonl
#@+node:ekr.20031218072017.2813:<< initialize ivars >>
self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files
#@nonl
#@-node:ekr.20031218072017.2813:<< initialize ivars >>
#@-node:ekr.20040731071037:c.initIvars
#@+node:ekr.20031218072017.2814:c.__repr__ & __str__
def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

#@-node:ekr.20031218072017.2814:c.__repr__ & __str__
#@+node:ekr.20041130173135:c.hash
def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0
#@nonl
#@-node:ekr.20041130173135:c.hash
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.miniBufferWidget)
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    # There is no miniBufferWidget created for leoSettings.leo files.
    if c.miniBufferWidget:
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        # c.printCommandsDict()
    else:
        c.commandsDict = {}

    c.keyHandler.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@-node:ekr.20031218072017.2811: c.Birth & death
#@+node:ekr.20050920085536.2: ctor (keyHandler)
def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
        # A Tk Label widget.  Important: will be None if c.useMiniBuffer is False.
        
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    << define Tk ivars >>
    << define externally visible ivars >>
    << define internal ivars >>
#@nonl
#@+node:ekr.20051006092617:<< define Tk ivars >>
if self.widget:
    self.svar = Tk.StringVar()
    self.widget.configure(textvariable=self.svar)
    
else:
    self.svar = None
#@nonl
#@-node:ekr.20051006092617:<< define Tk ivars >>
#@+node:ekr.20051006092617.1:<< define externally visible ivars >>
self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)

#@-node:ekr.20051006092617.1:<< define externally visible ivars >>
#@+node:ekr.20050923213858:<< define internal ivars >>
# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(f=f,name=name)
    

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.keysymHistory = []
self.previous = []
self.previousStroke = ''

# For getArg...
self.afterGetArgState = None
self.argTabList = []

if 0: # These are now set in makeSpecialBindings.
    self.abortAllModesKey = 'Control-g'
    self.fullCommandKey = 'Alt-x'
    self.universalArgKey = 'Control-u'
#@nonl
#@-node:ekr.20050923213858:<< define internal ivars >>
#@-node:ekr.20050920085536.2: ctor (keyHandler)
#@+node:ekr.20050920093543:c.finishCreate & helper
def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.miniBufferWidget)
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    # There is no miniBufferWidget created for leoSettings.leo files.
    if c.miniBufferWidget:
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        # c.printCommandsDict()
    else:
        c.commandsDict = {}

    c.keyHandler.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
#@nonl
#@+node:ekr.20051007143620:printCommandsDict
def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'<None>'))
    print
#@nonl
#@-node:ekr.20051007143620:printCommandsDict
#@-node:ekr.20050920093543:c.finishCreate & helper
#@+node:ekr.20031218072017.2176:f.finishCreate & helpers
def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    g.app.setLog(f.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    if c.useMiniBuffer:
        f.miniBufferWidget = f.createMiniBufferWidget()
    f.body.createBindings(f)
#@nonl
#@+node:ekr.20051009044751:createOuterFrames
def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("<Button-1>", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    f.top.bind("<Activate>",f.OnActivateLeoEvent)
    f.top.bind("<Deactivate>",f.OnDeactivateLeoEvent)
    
    f.top.bind("<Control-KeyPress>",f.OnControlKeyDown)
    f.top.bind("<Control-KeyRelease>",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
#@-node:ekr.20051009044751:createOuterFrames
#@+node:ekr.20051009044920:createIconBarComponents
# Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()
#@nonl
#@-node:ekr.20051009044920:createIconBarComponents
#@+node:ekr.20051009045208:createSplitterComponents
def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()
#@nonl
#@-node:ekr.20051009045208:createSplitterComponents
#@+node:ekr.20051009045300:createStatusLineComponents
# Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.
#@nonl
#@-node:ekr.20051009045300:createStatusLineComponents
#@+node:ekr.20051009045404:createFirstTreeNode
def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()

    c.beginUpdate()
    try:
        c.selectVnode(p)
        c.redraw()
        c.frame.getFocus()
        c.editPosition(p)
    finally:
        c.endUpdate(False)
#@nonl
#@-node:ekr.20051009045404:createFirstTreeNode
#@-node:ekr.20031218072017.2176:f.finishCreate & helpers
#@+node:ekr.20050920094633:k.finishCreate & helpers
def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        return
        
    # g.trace('keyHandler')

    if c.useMiniBuffer:
        k.makeAllBindings()
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)
#@nonl
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@-node:ekr.20050920094633:k.finishCreate & helpers
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@+node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    << define dictionary d of names and Leo commands >>
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    #'check-spelling':      None,                   # Create this command.
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    # Leo find panel stuff.  It's not clear what will happen to these.
    'dismiss-leo-find-panel':   c.dismissFindPanel,
    'leo-change':               c.replace,
    'leo-change-then-find':     c.replaceThenFind,
    'leo-change-all':           c.replaceAll,
    'leo-find':                 c.findNext,
    'leo-find-panel':           c.showFindPanel,
    'leo-find-previous':        c.findPrevious,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}
#@nonl
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
#@-node:ekr.20051009120608:(ctors & finishCreate)
#@+node:ekr.20051006131811:(uArgs)
#@+node:ekr.20050920085536.65: masterCommand & helpers
def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    k.stroke = stroke # Set this global for general use.
    commandName = k.ultimateFuncName(func)
    special = event.keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '<Key>'

    # if interesting: g.trace(stroke,commandName)

    inserted = not special or (
        stroke != '<Key>' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=event.keysym))

    if inserted:
        # g.trace(stroke,event.keysym)
        << add character to history >>
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.previousStroke = stroke
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName,tag='keyboard-quit')
        return 'break'

    if k.inState():
        k.forceFocusToBody()
        k.previousStroke = stroke
        k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # k.previousStroke = stroke
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = event.keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        k.previousStroke = stroke
        forceFocus = func.__name__ != 'leoCallback'
        if forceFocus:
            k.forceFocusToBody()
        func(event)
        k.endCommand(event,commandName,forceFocus,tag='masterCommand')
        return 'break'

    else:
        c.frame.body.onBodyKey(event)
        return None # Not 'break'
#@nonl
#@+node:ekr.20050920085536.67:<< add character to history >>
# Don't add multiple special characters to history.

k.keysymHistory.insert(0,event.keysym)

if len(event.char) > 0:
    if len(keyHandlerClass.lossage) > 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,event.char)

if 0: # traces
    g.trace(event.keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)
#@nonl
#@-node:ekr.20050920085536.67:<< add character to history >>
#@+node:ekr.20050923172809.1:callStateFunction
def callStateFunction (self,event):
    
    k = self
    
    # g.trace(k.stateKind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            k.state.handler(event)
            k.endCommand(event,k.commandName,tag='callStateFunction')
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
#@nonl
#@-node:ekr.20050923172809.1:callStateFunction
#@+node:ekr.20050923174229.3:callKeystrokeFunction
def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName,forceFocus,tag='callKeystrokeFunction')
    
    return func
#@nonl
#@-node:ekr.20050923174229.3:callKeystrokeFunction
#@-node:ekr.20050920085536.65: masterCommand & helpers
#@+node:ekr.20050920085536.41:fullCommand (alt-x) & helper
def fullCommand (self,event):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    
    # g.trace(state,keysym)
    
    if state == 0:
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
    elif keysym == 'Return':
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
    elif keysym == 'BackSpace':
        k.doBackSpace()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'
#@nonl
#@+node:ekr.20050920085536.45:callAltXFunction
def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName,tag='callAltXFunction')
    else:
        k.setLabel('Command does not exist: %s' % commandName)
#@nonl
#@-node:ekr.20050920085536.45:callAltXFunction
#@-node:ekr.20050920085536.41:fullCommand (alt-x) & helper
#@+node:ekr.20050920085536.73:universalDispatcher & helpers
def universalDispatcher (self,event):
    
    '''Handle accumulation of universal argument.'''
    
    << about repeat counts >>

    k = self ; state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = event.keysym
            # Stroke is <Key> for plain keys, <Control-u> (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '<Key>' and keysym in string.digits + '-':
            k.updateLabel(event)
        elif stroke == '<Key>' and keysym in (
            'Alt_L','Alt_R','Shift_L','Shift_R','Control_L','Control_R'):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '<Control-x>':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'
#@nonl
#@+node:ekr.20051006083627.1:<< about repeat counts >>
@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.
#@nonl
#@-node:ekr.20051006083627.1:<< about repeat counts >>
#@+node:ekr.20050920085536.75:executeNTimes
def executeNTimes (self,event,n):
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = stroke.lstrip('<').rstrip('>')
        b = k.bindingsDict.get(stroke)
        if b:
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'<%s>' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('<Key>',keycode=event.keycode,keysym=event.keysym)
#@nonl
#@-node:ekr.20050920085536.75:executeNTimes
#@+node:ekr.20050920085536.76:doControlU
def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % stroke.lstrip('<').rstrip('>'))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)
#@nonl
#@-node:ekr.20050920085536.76:doControlU
#@-node:ekr.20050920085536.73:universalDispatcher & helpers
#@-node:ekr.20051006131811:(uArgs)
#@+node:ekr.20051010062551.1:(key dicts)
@

c.commandsDict:        keys are emacs command names, values are functions f.

k.inverseCommandsDict: keys are f.__name__, values are emacs command names.

k.leoCallbackDict:     keys are leoCallback functions, values are called functions.
#@nonl
#@+node:ekr.20050922104731:finishCreateEditCommanders (leoEditCommands module)
def finishCreateEditCommanders (c):
    
    '''Finish creating edit classes in the commander.
    
    Return the commands dictionary for all the classes.'''
    
    global classesList
    
    d = {}

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                keys = d2.keys()
                keys.sort()
                print '----- %s' % name
                for key in keys: print
                
    return d
#@nonl
#@-node:ekr.20050922104731:finishCreateEditCommanders (leoEditCommands module)
#@+node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    << define dictionary d of names and Leo commands >>
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    #'check-spelling':      None,                   # Create this command.
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    # Leo find panel stuff.  It's not clear what will happen to these.
    'dismiss-leo-find-panel':   c.dismissFindPanel,
    'leo-change':               c.replace,
    'leo-change-then-find':     c.replaceThenFind,
    'leo-change-all':           c.replaceAll,
    'leo-find':                 c.findNext,
    'leo-find-panel':           c.showFindPanel,
    'leo-find-previous':        c.findPrevious,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}
#@nonl
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
#@+node:ekr.20051008082929:createInverseCommandsDict
def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
#@nonl
#@-node:ekr.20051008082929:createInverseCommandsDict
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
# First, check the kludged cut/copy/paste commands.
if not useBindShortcut:
    cutCopyPasteDict = {
        'Ctrl+X': 'cut-text',
        'Ctrl+C': 'copy-text',
        'Ctrl+V': 'paste-text',
    }
    name = cutCopyPasteDict.get(accel)
    # Allow the user to override the shortcut using equivalent emacs name.
    rawKey,accel2 = c.config.getShortcut(name)
    # g.trace(accel,accel2,name,command.__name__)
    if not accel2:
        accel2 = 'none' # Do not allow any further overrides.
else:
    # Second, try to get the old-style name.
    rawKey,accel2 = c.config.getShortcut(name)
    
# if not openWith: g.trace(accel,accel2,name)

# New in 4.4: allow emacs-style or old style names in menu shortcuts.
if openWith:
    pass
elif not accel2:
    if c.useMiniBuffer:
        try: # User errors in the call can cause this.
            commandName = command.__name__
        except Exception:
            commandName = None
        emacs_name = k.inverseCommandsDict.get(commandName)
        if emacs_name:
            rawKey,accel2 = c.config.getShortcut(emacs_name)
            accel = accel2 # Override the default shortcut.
            # if accel: g.trace('%30s = %30s: %s' % (name,emacs_name,repr(accel)))
        else:
            accel = None # New in 4.4: remove the default shortcut.
            if init and not dynamicMenu: # Don't require command names for dynamic menu entries.
                if commandName and commandName != 'dummyCommand':
                    g.trace('no inverse for %s' % commandName)
    else:
        pass # Use the default shortcut.
elif accel2 and accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
    
# if not openWith: g.trace(accel,accel2,name)
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@-node:ekr.20051010062551.1:(key dicts)
#@+node:ekr.20051010181742:(Leo commands)
#@+node:ekr.20031218072017.2818:Command handlers...
#@+node:ekr.20031218072017.2819:File Menu
#@+node:ekr.20031218072017.2820:top level
#@+node:ekr.20031218072017.1623:new
def new (self):

    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=None)
    
    # 5/16/03: Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)

    # Use the config params to set the size and location of the window.
    frame.setInitialWindowGeometry()
    frame.deiconify()
    frame.lift()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
    
    c.beginUpdate()
    try:
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    finally:
        c.endUpdate()

    frame.body.setFocus()
    return c # For unit test.
#@nonl
#@-node:ekr.20031218072017.1623:new
#@+node:ekr.20031218072017.2821:open
def open(self):

    c = self
    << Set closeFlag if the only open window is empty >>

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) > 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
#@nonl
#@+node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@nonl
#@-node:ekr.20031218072017.2822:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2821:open
#@+node:ekr.20031218072017.2823:openWith and allies
def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            << set ext based on the present language >>
            << create or reopen temp file, testing for conflicting changes >>
            << execute a command to open path in external editor >>
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
#@+node:ekr.20031218072017.2824:<< set ext based on the present language >>
if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext
#@nonl
#@-node:ekr.20031218072017.2824:<< set ext based on the present language >>
#@+node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
theDict = None ; path = None
<< set dict and path if a temp file already refers to p.v.t >>
if path:
    << create or recreate temp file as needed >>
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.
#@nonl
#@+node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
#@-node:ekr.20031218072017.2826:<<set dict and path if a temp file already refers to p.v.t >>
#@+node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    << Raise dialog about conflict and set result >>
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")
#@nonl
#@+node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")
#@nonl
#@-node:ekr.20031218072017.2828:<< Raise dialog about conflict and set result >>
#@-node:ekr.20031218072017.2827:<< create or recreate temp file as needed >>
#@-node:ekr.20031218072017.2825:<< create or reopen temp file, testing for conflicting changes >>
#@+node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2829:<< execute a command to open path in external editor >>
#@+node:ekr.20031218072017.2830:createOpenWithTempFile
def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        << remove previous entry from app.openWithFiles if it exists >>
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None
#@nonl
#@+node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)
#@nonl
#@-node:ekr.20031218072017.2831:<< remove previous entry from app.openWithFiles if it exists >>
#@-node:ekr.20031218072017.2830:createOpenWithTempFile
#@+node:ekr.20031218072017.2832:c.openWithTempFilePath
def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path
#@nonl
#@-node:ekr.20031218072017.2832:c.openWithTempFilePath
#@-node:ekr.20031218072017.2823:openWith and allies
#@+node:ekr.20031218072017.2833:close
def close(self):
    
    """Handle the File-Close command."""

    g.app.closeLeoWindow(self.frame)
#@nonl
#@-node:ekr.20031218072017.2833:close
#@+node:ekr.20031218072017.2834:save
def save(self):

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName) 
        return

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.fileCommands.save(c.mFileName)
        c.updateRecentFiles(c.mFileName)
#@nonl
#@-node:ekr.20031218072017.2834:save
#@+node:ekr.20031218072017.2835:saveAs
def saveAs(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)
#@nonl
#@-node:ekr.20031218072017.2835:saveAs
#@+node:ekr.20031218072017.2836:saveTo
def saveTo(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)
#@nonl
#@-node:ekr.20031218072017.2836:saveTo
#@+node:ekr.20031218072017.2837:revert
def revert(self):
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
#@-node:ekr.20031218072017.2837:revert
#@-node:ekr.20031218072017.2820:top level
#@+node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2080:clearRecentFiles
def clearRecentFiles (self):
    
    """Clear the recent files list, then add the present file."""

    c = self ; f = c.frame ; u = c.undoer
    
    bunch = u.beforeClearRecentFiles()
    
    recentFilesMenu = f.menu.getMenu("Recent Files...")
    f.menu.delete_range(recentFilesMenu,0,len(c.recentFiles))
    
    c.recentFiles = []
    g.app.config.recentFiles = [] # New in Leo 4.3.
    f.menu.createRecentFilesMenuItems()
    c.updateRecentFiles(c.fileName())
    
    g.app.config.appendToRecentFiles(c.recentFiles)
    
    u.afterClearRecentFiles(bunch)
#@nonl
#@-node:ekr.20031218072017.2080:clearRecentFiles
#@+node:ekr.20031218072017.2081:openRecentFile
def openRecentFile(self,name=None):
    
    if not name: return

    c = self ; v = c.currentVnode()
    << Set closeFlag if the only open window is empty >>
    
    fileName = name
    if not g.doHook("recentfiles1",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag):
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame) # 12/12/03
            g.app.setLog(frame.log,"openRecentFile") # Sets the log stream for g.es()
            c = frame.c # 6/10/04: Switch to the new commander so the "recentfiles2" hook doesn't crash.

    g.doHook("recentfiles2",c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
#@+node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
#@nonl
#@-node:ekr.20031218072017.2082:<< Set closeFlag if the only open window is empty >>
#@-node:ekr.20031218072017.2081:openRecentFile
#@+node:ekr.20031218072017.2083:c.updateRecentFiles
def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    if g.app.unitTesting: return
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Update the recent files list in all windows.
    if fileName:
        compareFileName = munge(fileName)
        # g.trace(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if compareFileName == munge(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # g.trace(fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else:
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
#@nonl
#@-node:ekr.20031218072017.2083:c.updateRecentFiles
#@-node:ekr.20031218072017.2079:Recent Files submenu & allies
#@+node:ekr.20031218072017.2838:Read/Write submenu
#@+node:ekr.20031218072017.2839:readOutlineOnly
def readOutlineOnly (self):

    fileName = g.app.gui.runOpenFileDialog(
        title="Read Outline Only",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if not fileName:
        return

    try:
        theFile = open(fileName,'r')
        c,frame = g.app.gui.newLeoCommanderAndFrame(fileName)
        frame.deiconify()
        frame.lift()
        g.app.root.update() # Force a screen redraw immediately.
        c.fileCommands.readOutlineOnly(theFile,fileName) # closes file.
    except:
        g.es("can not open:" + fileName)
#@nonl
#@-node:ekr.20031218072017.2839:readOutlineOnly
#@+node:ekr.20031218072017.1839:readAtFileNodes (commands)
def readAtFileNodes (self):

    c = self ; u = c.undoer ; p = c.currentPosition()

    undoData = u.beforeChangeTree(p)
    
    c.fileCommands.readAtFileNodes()
    
    u.afterChangeTree(p,'Read @file Nodes',undoData)
#@nonl
#@-node:ekr.20031218072017.1839:readAtFileNodes (commands)
#@+node:ekr.20031218072017.2840:4.0 Commands
#@+node:ekr.20031218072017.1809:importDerivedFile
def importDerivedFile (self):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(p,names)
#@nonl
#@-node:ekr.20031218072017.1809:importDerivedFile
#@-node:ekr.20031218072017.2840:4.0 Commands
#@-node:ekr.20031218072017.2838:Read/Write submenu
#@+node:ekr.20031218072017.2841:Tangle submenu
#@+node:ekr.20031218072017.2842:tangleAll
def tangleAll(self):
    
    c = self
    c.tangleCommands.tangleAll()
#@-node:ekr.20031218072017.2842:tangleAll
#@+node:ekr.20031218072017.2843:tangleMarked
def tangleMarked(self):

    c = self
    c.tangleCommands.tangleMarked()
#@-node:ekr.20031218072017.2843:tangleMarked
#@+node:ekr.20031218072017.2844:tangle
def tangle (self):

    c = self
    c.tangleCommands.tangle()
#@nonl
#@-node:ekr.20031218072017.2844:tangle
#@-node:ekr.20031218072017.2841:Tangle submenu
#@+node:ekr.20031218072017.2845:Untangle submenu
#@+node:ekr.20031218072017.2846:untangleAll
def untangleAll(self):

    c = self
    c.tangleCommands.untangleAll()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2846:untangleAll
#@+node:ekr.20031218072017.2847:untangleMarked
def untangleMarked(self):

    c = self
    c.tangleCommands.untangleMarked()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2847:untangleMarked
#@+node:ekr.20031218072017.2848:untangle
def untangle(self):

    c = self
    c.tangleCommands.untangle()
    c.undoer.clearUndoState()
#@-node:ekr.20031218072017.2848:untangle
#@-node:ekr.20031218072017.2845:Untangle submenu
#@+node:ekr.20031218072017.2849:Import&Export submenu
#@+node:ekr.20031218072017.2850:exportHeadlines
def exportHeadlines (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        c.importCommands.exportHeadlines(fileName)

#@-node:ekr.20031218072017.2850:exportHeadlines
#@+node:ekr.20031218072017.2851:flattenOutline
def flattenOutline (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        c.importCommands.flattenOutline(fileName)

#@-node:ekr.20031218072017.2851:flattenOutline
#@+node:ekr.20031218072017.2852:importAtRoot
def importAtRoot (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@root")
#@-node:ekr.20031218072017.2852:importAtRoot
#@+node:ekr.20031218072017.2853:importAtFile
def importAtFile (self):
    
    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand(names,"@file")
#@nonl
#@-node:ekr.20031218072017.2853:importAtFile
#@+node:ekr.20031218072017.2854:importCWEBFiles
def importCWEBFiles (self):
    
    c = self
    
    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"cweb")
#@-node:ekr.20031218072017.2854:importCWEBFiles
#@+node:ekr.20031218072017.2855:importFlattenedOutline
def importFlattenedOutline (self):
    
    c = self
    
    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFlattenedOutline(names)
#@-node:ekr.20031218072017.2855:importFlattenedOutline
#@+node:ekr.20031218072017.2856:importNowebFiles
def importNowebFiles (self):
    
    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"noweb")
#@-node:ekr.20031218072017.2856:importNowebFiles
#@+node:ekr.20031218072017.2857:outlineToCWEB
def outlineToCWEB (self):
    
    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")

    if fileName and len(fileName) > 0:
        c.importCommands.outlineToWeb(fileName,"cweb")

#@-node:ekr.20031218072017.2857:outlineToCWEB
#@+node:ekr.20031218072017.2858:outlineToNoweb
def outlineToNoweb (self):
    
    c = self
    
    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")

    if fileName and len(fileName) > 0:
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName

#@-node:ekr.20031218072017.2858:outlineToNoweb
#@+node:ekr.20031218072017.2859:removeSentinels
def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.removeSentinelsCommand (names)
#@nonl
#@-node:ekr.20031218072017.2859:removeSentinels
#@+node:ekr.20031218072017.2860:weave
def weave (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) > 0:
        c.importCommands.weave(fileName)
#@-node:ekr.20031218072017.2860:weave
#@-node:ekr.20031218072017.2849:Import&Export submenu
#@-node:ekr.20031218072017.2819:File Menu
#@+node:ekr.20031218072017.2861:Edit Menu...
#@+node:ekr.20031218072017.2862:Edit top level
#@+node:ekr.20031218072017.2863:delete
def delete(self):

    c = self ; p = c.currentPosition()
    body = c.frame.body
    w = body.bodyCtrl.focus_get()
    
    # Don't assume the body has focus.
    if w == body.bodyCtrl:
        oldSel = body.getTextSelection()
        body.deleteTextSelection()
        body.onBodyChanged(p,"Delete",oldSel=oldSel)
    else:
        # Assume we are changing a headline...
        # This works even if the assumption is incorrect.
        start,end=g.app.gui.getTextSelection(w)
        g.app.gui.replaceSelectionRangeWithText(w,start,end,'')
        c.frame.tree.onHeadChanged(p)
#@nonl
#@-node:ekr.20031218072017.2863:delete
#@+node:ekr.20031218072017.2140:c.executeScript
def executeScript(self,p=None,script=None,
    useSelectedText=True,define_g=True,define_name=''):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; script1 = script
    if not script:
        script = g.getScript(c,p,useSelectedText=useSelectedText)
    << redirect output >>
    try:
        if script.strip():
            sys.path.insert(0,c.frame.openDirectory)
            script += '\n' # Make sure we end the script properly.
            try:
                p = c.currentPosition()
                d = g.choose(define_g,{'c':c,'g':g,'p':p},{})
                if define_name: d['__name__'] = define_name
                exec script in d
                if not script1:
                    g.es("end of script",color="purple")
            except Exception:
                << handle an exception in the script >>
            del sys.path[0]
        else:
            g.es("no script selected",color="blue")
    finally: # New in 4.3 beta 2: unredirect output last.
        << unredirect output >>

    # Force a redraw _after_ all messages have been output.
    c.redraw() 
#@nonl
#@+node:ekr.20031218072017.2143:<< redirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr
#@nonl
#@-node:ekr.20031218072017.2143:<< redirect output >>
#@+node:ekr.20050505104140:<< handle an exception in the script >>
g.es("exception executing script",color='blue')

if 0:
    print 'script...'
    for line in g.splitLines(script):
        print repr(line)

fileName,n = g.es_exception(full=True,c=c)
if p and not script1 and fileName == "<string>":
    c.goToScriptLineNumber(p,script,n)

<< dump the lines near the error >>
c.frame.tree.redrawAfterException()
#@nonl
#@+node:EKR.20040612215018:<< dump the lines near the error >>
if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
g.es_print(s)

if 0:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        g.es(s,newline=False)
else: # Print surrounding lines.
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i < j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        g.es(s,newline=False)
        i += 1
#@nonl
#@-node:EKR.20040612215018:<< dump the lines near the error >>
#@-node:ekr.20050505104140:<< handle an exception in the script >>
#@+node:EKR.20040627100424:<< unredirect output >>
if c.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()
#@nonl
#@-node:EKR.20040627100424:<< unredirect output >>
#@-node:ekr.20031218072017.2140:c.executeScript
#@+node:ekr.20031218072017.2864:goToLineNumber & allies
def goToLineNumber (self,root=None,lines=None,n=None,scriptFind=False):
    
    __pychecker__ = 'maxlines=400'

    c = self ; p = c.currentPosition()
    root1 = root
    if root is None:
        << set root >>
    if lines is None:
        << read the file into lines >>
    if n is None:
        << get n, the line number, from a dialog >>
        n = self.applyLineNumberMappingIfAny(n) #bwm
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n >= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        << count outline lines, setting p,n2,found >>
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root,scriptFind)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        << set p to the node given by vnodeName, etc. >>
    << select p and make it visible >>
    << put the cursor on line n2 of the body text >>
#@nonl
#@+node:ekr.20031218072017.2865:<< set root >>
# First look for ancestor @file node.
fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break

if fileName:
    root = p.copy()
else:
    # New in 4.2.1: assume the c.currentPosition is the root of a script.
    root = c.currentPosition()
    g.es("No ancestor @file node: using script line numbers", color="blue")
    scriptFind = True
    lines = g.getScript (c,root,useSelectedText=False)
    lines = g.splitLines(lines)
    if 0:
        for line in lines:
            print line,
#@nonl
#@-node:ekr.20031218072017.2865:<< set root >>
#@+node:ekr.20031218072017.2866:<< read the file into lines >>
# 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    lines=self.gotoLineNumberOpen(fileName) # bwm
except:
    g.es("not found: " + fileName)
    return
#@nonl
#@-node:ekr.20031218072017.2866:<< read the file into lines >>
#@+node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
n = g.app.gui.runAskOkCancelNumberDialog(c,"Enter Line Number","Line number:")
if n == -1:
    return
#@nonl
#@-node:ekr.20031218072017.2867:<< get n, the line number, from a dialog >>
#@+node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) > 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines >= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)
#@nonl
#@-node:ekr.20031218072017.2868:<< count outline lines, setting p,n2,found >> (@file-nosent only)
#@+node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
if scriptFind:
    << just scan for the node name >>
elif gnx:
    << 4.2: get node from gnx >>
elif childIndex == -1:
    << 4.x: scan for the node using tnodeList and n >>
else:
    << 3.x: scan for the node with the given childIndex >>
#@nonl
#@+node:ekr.20041111093404:<< just scan for the node name >>
# This is safe enough because clones are not much of an issue.
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break
#@nonl
#@-node:ekr.20041111093404:<< just scan for the node name >>
#@+node:EKR.20040609110138:<< 4.2: get node from gnx >>
found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:EKR.20040609110138:<< 4.2: get node from gnx >>
#@+node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
# This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    g.es_print(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    << set tnodeIndex to the number of +node sentinels before line n >>
    tnodeIndex = max(0,tnodeIndex)
    << set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False >>
            
if not ok:
    # Fall back to the old logic.
    << set p to the first node whose headline matches vnodeName >>
#@nonl
#@+node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned >= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1
#@nonl
#@-node:ekr.20031218072017.2871:<< set tnodeIndex to the number of +node sentinels before line n >>
#@+node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex < len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        g.es_print(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            g.es_print(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        g.es_print(s, color = "red")
    ok = False
#@nonl
#@-node:ekr.20031218072017.2872:<< set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false >>
#@+node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    g.es_print(s, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2873:<< set p to the first node whose headline matches vnodeName >>
#@-node:ekr.20031218072017.2870:<< 4.x: scan for the node using tnodeList and n >>
#@+node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex <= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return
#@nonl
#@-node:ekr.20031218072017.2874:<< 3.x: scan for the node with the given childIndex >>
#@-node:ekr.20031218072017.2869:<< set p to the node given by vnodeName, etc. >>
#@+node:ekr.20031218072017.2875:<< select p and make it visible >>
c.beginUpdate()
try:
    c.frame.tree.expandAllAncestors(p)
    c.selectVnode(p)
finally:
    c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2875:<< select p and make it visible >>
#@+node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()
#@nonl
#@-node:ekr.20031218072017.2876:<< put the cursor on line n2 of the body text >>
#@+node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root,scriptFind):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    << set delim, leoLine from the @+leo line >>
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    << scan back to @+node, setting offset,nodeSentinelLine >>
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    << set vnodeName and (childIndex or gnx) from s >>
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
#@+node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
# Find the @+leo line.
tag = "@+leo"
i = 0 
while i < len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine < len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end,derivedFileIsThin = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
#@-node:ekr.20031218072017.2878:<< set delim, leoLine from the @+leo line >>
#@+node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line >= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        << handle delim while scanning backward >>
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1
#@nonl
#@+node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"<<") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.
#@nonl
#@-node:ekr.20031218072017.2880:<< handle delim while scanning backward >>
#@-node:ekr.20031218072017.2879:<< scan back to  @+node, setting offset,nodeSentinelLine >>
#@+node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
if scriptFind:
    # The vnode name follows the first ':'
    i = s.find(':',i)
    if i > -1:
        vnodeName = s[i+1:].strip()
    childIndex = -1
elif newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i > 0:
            i += 1
            j = s.find(':',i)
            if j > 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i > -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i < len(s) and colons < 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 < len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")
#@nonl
#@-node:ekr.20031218072017.2881:<< set vnodeName and (childIndex or gnx) from s >>
#@-node:ekr.20031218072017.2877:convertLineToVnodeNameIndexLine
#@+node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 <= n < len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n
#@nonl
#@-node:ekr.20031218072017.2882:skipToMatchingNodeSentinel
#@-node:ekr.20031218072017.2864:goToLineNumber & allies
#@+node:bwmulder.20041231211219:gotoLineNumberOpen
def gotoLineNumberOpen(self, *args, **kw):
    """
    Hook for mod_shadow plugin.
    """
    theFile = open(*args, **kw)
    lines = theFile.readlines()
    theFile.close()
    return lines
#@nonl
#@-node:bwmulder.20041231211219:gotoLineNumberOpen
#@+node:bwmulder.20041231211219.1:applyLineNumberMappingIfAny
def applyLineNumberMappingIfAny(self, n):
    """
    Hook for mod_shadow plugin.
    """
    return n
#@nonl
#@-node:bwmulder.20041231211219.1:applyLineNumberMappingIfAny
#@+node:EKR.20040612232221:goToScriptLineNumber
def goToScriptLineNumber (self,root,script,n):

    """Go to line n of a script."""

    c = self
    
    # g.trace(n,root)
    
    lines = g.splitLines(script)
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
#@nonl
#@-node:EKR.20040612232221:goToScriptLineNumber
#@+node:ekr.20031218072017.2088:fontPanel
def fontPanel(self):
    
    c = self ; frame = c.frame

    if not frame.fontPanel:
        frame.fontPanel = g.app.gui.createFontPanel(c)
        
    frame.fontPanel.bringToFront()
#@nonl
#@-node:ekr.20031218072017.2088:fontPanel
#@+node:ekr.20031218072017.2090:colorPanel
def colorPanel(self):
    
    c = self ; frame = c.frame

    if not frame.colorPanel:
        frame.colorPanel = g.app.gui.createColorPanel(c)
        
    frame.colorPanel.bringToFront()
#@nonl
#@-node:ekr.20031218072017.2090:colorPanel
#@+node:ekr.20031218072017.2883:viewAllCharacters
def viewAllCharacters (self):

    c = self ; frame = c.frame
    p = c.currentPosition()
    colorizer = frame.body.getColorizer()

    colorizer.showInvisibles = g.choose(colorizer.showInvisibles,0,1)

    # It is much easier to change the menu name here than in the menu updater.
    menu = frame.menu.getMenu("Edit")
    if colorizer.showInvisibles:
        frame.menu.setMenuLabel(menu,"Show Invisibles","Hide Invisibles")
    else:
        frame.menu.setMenuLabel(menu,"Hide Invisibles","Show Invisibles")

    c.frame.body.recolor_now(p)
#@nonl
#@-node:ekr.20031218072017.2883:viewAllCharacters
#@+node:ekr.20031218072017.2086:preferences
def preferences(self):
    
    '''Replace the body pane by the preferences setters.'''
    
    c = self
    
    if 1: # New code
        leoConfig.settingsController(c,replaceBody=True)

    else: # Old code...
        # Show the Preferences Panel, creating it if necessary.
        frame = c.frame
    
        if not frame.prefsPanel:
            frame.prefsPanel = g.app.gui.createPrefsPanel(c)
            
        frame.prefsPanel.bringToFront()
#@nonl
#@-node:ekr.20031218072017.2086:preferences
#@-node:ekr.20031218072017.2862:Edit top level
#@+node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.1704:convertAllBlanks
def convertAllBlanks (self):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1704:convertAllBlanks
#@+node:ekr.20031218072017.1705:convertAllTabs
def convertAllTabs (self):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count > 0)
#@nonl
#@-node:ekr.20031218072017.1705:convertAllTabs
#@+node:ekr.20031218072017.1821:convertBlanks
def convertBlanks (self):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1821:convertBlanks
#@+node:ekr.20031218072017.1822:convertTabs
def convertTabs (self):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1822:convertTabs
#@+node:ekr.20031218072017.1823:createLastChildNode
def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) > 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p
#@nonl
#@-node:ekr.20031218072017.1823:createLastChildNode
#@+node:ekr.20031218072017.1824:dedentBody
def dedentBody (self):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1824:dedentBody
#@+node:ekr.20031218072017.1706:extract
def extract(self):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.1706:extract
#@+node:ekr.20031218072017.1708:extractSection
def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    << Set headline for extractSection >>
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()
#@nonl
#@+node:ekr.20031218072017.1709:<< Set headline for extractSection >>
if len(headline) < 5:
    oops = True
else:
    head1 = headline[0:2] == '<<'
    head2 = headline[0:2] == '@<'
    tail1 = headline[-2:] == '>>'
    tail2 = headline[-2:] == '@>'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return
#@nonl
#@-node:ekr.20031218072017.1709:<< Set headline for extractSection >>
#@-node:ekr.20031218072017.1708:extractSection
#@+node:ekr.20031218072017.1710:extractSectionNames
def extractSectionNames(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                << Find the next section name >>
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()
#@nonl
#@+node:ekr.20031218072017.1711:<< Find the next section name >>
head1 = string.find(s,"<<")
if head1 > -1:
    head2 = string.find(s,">>",head1)
else:
    head1 = string.find(s,"@<")
    if head1 > -1:
        head2 = string.find(s,"@>",head1)
        
if head1 == -1 or head2 == -1 or head1 > head2:
    name = None
else:
    name = s[head1:head2+2]
#@nonl
#@-node:ekr.20031218072017.1711:<< Find the next section name >>
#@-node:ekr.20031218072017.1710:extractSectionNames
#@+node:ekr.20031218072017.1825:findBoundParagraph
def findBoundParagraph (self):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        << trace head_lines, ins, tail_lines >>

    # Scan backwards.
    i = len(head_lines)
    while i > 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i < len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#	para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool
#@nonl
#@+node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)
#@nonl
#@-node:ekr.20031218072017.1826:<< trace head_lines, ins, tail_lines >>
#@-node:ekr.20031218072017.1825:findBoundParagraph
#@+node:ekr.20031218072017.1827:findMatchingBracket
def findMatchingBracket (self):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}<>"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"<=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)
#@nonl
#@+node:ekr.20031218072017.1828:findMatchingBracket
# To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{<" ; close_brackets = ")]}>"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,">=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level <= 0:
                return index
        if not forward and body.compareIndices(index,"<=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched
#@nonl
#@-node:ekr.20031218072017.1828:findMatchingBracket
#@-node:ekr.20031218072017.1827:findMatchingBracket
#@+node:ekr.20031218072017.1829:getBodyLines
def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview
#@nonl
#@-node:ekr.20031218072017.1829:getBodyLines
#@+node:ekr.20031218072017.1830:indentBody
def indentBody (self):

    c = self ; undoType = 'Indent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20031218072017.1830:indentBody
#@+node:ekr.20031218072017.1831:insertBodyTime & allies
def insertBodyTime (self):
    
    c = self ; undoType = 'Insert Body Time'
    p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(p,undoType,oldSel=oldSel)
#@nonl
#@+node:ekr.20031218072017.1832:getTime
def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getString("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt     = c.config.getString("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
#@-node:ekr.20031218072017.1832:getTime
#@-node:ekr.20031218072017.1831:insertBodyTime & allies
#@+node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20050312114529.1:addComments
def addComments (self):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.1:addComments
#@+node:ekr.20050312114529.2:deleteComments
def deleteComments (self):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
#@nonl
#@-node:ekr.20050312114529.2:deleteComments
#@-node:ekr.20050312114529:insert/removeComments
#@+node:ekr.20031218072017.1833:reformatParagraph
def reformatParagraph(self):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    << compute vars for reformatParagraph >>
    if lines:
        << compute the leading whitespace >>
        << compute the result of wrapping all lines >>
        << update the body, selection & undo state >>
#@nonl
#@+node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL
#@nonl
#@-node:ekr.20031218072017.1834:<< compute vars for reformatParagraph >>
#@+node:ekr.20031218072017.1835:<< compute the leading whitespace >>
indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i < len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
#@-node:ekr.20031218072017.1835:<< compute the leading whitespace >>
#@+node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
# Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 	18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 	18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
#@-node:ekr.20031218072017.1836:<< compute the result of wrapping all lines >>
#@+node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()
#@nonl
#@-node:ekr.20031218072017.1837:<< update the body, selection & undo state >>
#@-node:ekr.20031218072017.1833:reformatParagraph
#@+node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo by calling setUndoTypingParams (in idle_body_key).
    body.onBodyChanged(p,undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList
#@nonl
#@-node:ekr.20031218072017.1838:updateBodyPane (handles changeNodeContents)
#@-node:ekr.20031218072017.2884:Edit Body submenu
#@+node:ekr.20031218072017.2885:Edit Headline submenu
#@+node:ekr.20031218072017.2886:editHeadline
def editHeadline(self):
    
    c = self ; tree = c.frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Edit Headline")
        return

    tree.editLabel(c.currentPosition())
#@nonl
#@-node:ekr.20031218072017.2886:editHeadline
#@+node:ekr.20031218072017.2290:toggleAngleBrackets
def toggleAngleBrackets (self):
    
    c = self ; v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return

    s = v.headString().strip()
    if (s[0:2] == "<<"
        or s[-2:] == ">>"): # Must be on separate line.
        if s[0:2] == "<<": s = s[2:]
        if s[-2:] == ">>": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    
    c.frame.tree.editLabel(v)
    if v.edit_text():
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("1.0",s)
        c.frame.tree.onHeadChanged(v)
#@-node:ekr.20031218072017.2290:toggleAngleBrackets
#@-node:ekr.20031218072017.2885:Edit Headline submenu
#@+node:ekr.20031218072017.2887:Find submenu (frame methods)
#@+node:ekr.20051013084200:dismissFindPanel
def dismissFindPanel (self):
    
    c = self
    
    if c.frame.findPanel:
        c.frame.findPanel.dismiss()
#@nonl
#@-node:ekr.20051013084200:dismissFindPanel
#@+node:ekr.20031218072017.2888:showFindPanel
def showFindPanel(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.bringToFront()
#@nonl
#@-node:ekr.20031218072017.2888:showFindPanel
#@+node:ekr.20031218072017.2889:findNext
def findNext(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findNextCommand(c)
#@-node:ekr.20031218072017.2889:findNext
#@+node:ekr.20031218072017.2890:findPrevious
def findPrevious(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findPreviousCommand(c)
#@-node:ekr.20031218072017.2890:findPrevious
#@+node:ekr.20031218072017.2891:replace
def replace(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeCommand(c)
#@-node:ekr.20031218072017.2891:replace
#@+node:ekr.20031218072017.2892:replaceThenFind
def replaceThenFind(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeThenFindCommand(c)
#@-node:ekr.20031218072017.2892:replaceThenFind
#@+node:ekr.20051013083241:replaceAll
def replaceAll(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeAllCommand(c)
#@-node:ekr.20051013083241:replaceAll
#@-node:ekr.20031218072017.2887:Find submenu (frame methods)
#@+node:ekr.20031218072017.2893:notValidInBatchMode
def notValidInBatchMode(self, commandName):
    
    g.es("%s command is not valid in batch mode" % commandName)
#@-node:ekr.20031218072017.2893:notValidInBatchMode
#@-node:ekr.20031218072017.2861:Edit Menu...
#@+node:ekr.20031218072017.2894:Outline menu...
#@+node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.1549:cutOutline
def cutOutline(self):

    c = self
    if c.canDeleteHeadline():
        c.copyOutline()
        c.deleteOutline("Cut Node")
        c.recolor()
#@nonl
#@-node:ekr.20031218072017.1549:cutOutline
#@+node:ekr.20031218072017.1550:copyOutline
def copyOutline(self):

    # Copying an outline has no undo consequences.
    c = self
    c.endEditing()
    c.fileCommands.assignFileIndices()
    s = c.fileCommands.putLeoOutline()
    g.app.gui.replaceClipboardWith(s)
#@nonl
#@-node:ekr.20031218072017.1550:copyOutline
#@+node:ekr.20031218072017.1551:pasteOutline
# To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    
    tnodeInfoDict = {}
    if pasteAsClone:
        << remember all data for undo/redo Paste As Clone >>

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return
    
    copiedBunchList = []
    if pasteAsClone:
        << put only needed info in copiedBunchList >>
    
    undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)

    c.beginUpdate()
    try: # inside update...
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate()
    c.recolor()
#@nonl
#@+node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())
#@nonl
#@-node:ekr.20050418084539:<< remember all data for undo/redo Paste As Clone >>
#@+node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
# Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)
#@nonl
#@-node:ekr.20050418084539.2:<< put only needed info in copiedBunchList >>
#@-node:ekr.20031218072017.1551:pasteOutline
#@+node:EKR.20040610130943:pasteOutlineRetainingClones
def pasteOutlineRetainingClones (self):
    
    c = self

    return c.pasteOutline(reassignIndices=False)
#@nonl
#@-node:EKR.20040610130943:pasteOutlineRetainingClones
#@-node:ekr.20031218072017.1548:Cut & Paste Outlines
#@+node:ekr.20031218072017.2028:Hoist & dehoist
def dehoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canDehoist():
        bunch = c.hoistStack.pop()
        if bunch.expanded: p.expand()
        else:              p.contract()
        c.redraw()
        c.frame.clearStatusLine()
        if c.hoistStack:
            bunch = c.hoistStack[-1]
            c.frame.putStatusLine("Hoist: " + bunch.p.headString())
        else:
            c.frame.putStatusLine("No hoist")
        c.undoer.afterDehoist(p,'DeHoist')

def hoist(self):

    c = self ; p = c.currentPosition()
    if p and c.canHoist():
        # Remember the expansion state.
        bunch = g.Bunch(p=p.copy(),expanded=p.isExpanded())
        c.hoistStack.append(bunch)
        p.expand()
        c.redraw()
        c.frame.clearStatusLine()
        c.frame.putStatusLine("Hoist: " + p.headString())
        c.undoer.afterHoist(p,'Hoist')
#@nonl
#@-node:ekr.20031218072017.2028:Hoist & dehoist
#@+node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
def checkMoveWithParentWithWarning (self,root,parent,warningFlag):
    
    """Return False if root or any of root's descedents is a clone of
    parent or any of parents ancestors."""

    message = "Illegal move or drag: no clone may contain a clone of itself"

    # g.trace("root",root,"parent",parent)
    clonedTnodes = {}
    for ancestor in parent.self_and_parents_iter():
        if ancestor.isCloned():
            t = ancestor.v.t
            clonedTnodes[t] = t

    if not clonedTnodes:
        return True

    for p in root.self_and_subtree_iter():
        if p.isCloned() and clonedTnodes.get(p.v.t):
            if warningFlag:
                g.alert(message)
            return False
    return True
#@nonl
#@-node:ekr.20031218072017.1760:c.checkMoveWithParentWithWarning
#@+node:ekr.20031218072017.1193:c.deleteOutline
def deleteOutline (self,op_name="Delete Node"):
    
    """Deletes the current position.
    
    Does nothing if the outline would become empty."""

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if p.hasVisBack(): newNode = p.visBack()
    else: newNode = p.next() # _not_ p.visNext(): we are at the top level.
    if not newNode: return

    c.beginUpdate()
    try: # In update...
        c.endEditing() # Make sure we capture the headline for Undo.
        undoData = u.beforeDeleteNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.doDelete(newNode)
        c.setChanged(True)
        u.afterDeleteNode(newNode,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
    c.validateOutline()
#@nonl
#@-node:ekr.20031218072017.1193:c.deleteOutline
#@+node:ekr.20031218072017.1761:c.insertHeadline
def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.editPosition(p)
        c.selectPosition(p)
    finally:
        c.endUpdate()
    return p # for mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1761:c.insertHeadline
#@+node:ekr.20031218072017.1762:c.clone
def clone (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    
    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeCloneNode(p)
        clone = p.clone(p)
        dirtyVnodeList = clone.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        if c.validateOutline():
            u.afterCloneNode(clone,'Clone Node',undoData,dirtyVnodeList=dirtyVnodeList)
            c.selectPosition(clone)
    finally:
        c.endUpdate()

    return clone # For mod_labels plugin.
#@nonl
#@-node:ekr.20031218072017.1762:c.clone
#@+node:ekr.20031218072017.1765:c.validateOutline
# Makes sure all nodes are valid.

def validateOutline (self):

    c = self
    
    if not g.app.debug:
        return True

    root = c.rootPosition()
    parent = c.nullPosition()

    if root:
        return root.validateOutlineWithParent(parent)
    else:
        return True
#@nonl
#@-node:ekr.20031218072017.1765:c.validateOutline
#@-node:ekr.20031218072017.1759:Insert, Delete & Clone (Commands)
#@+node:ekr.20050415134809:c.sortChildren
def sortChildren(self):

    c = self ; u = c.undoer ; undoType = 'Sort Children'
    p = c.currentPosition()
    if not p or not p.hasChildren(): return

    c.beginUpdate()
    try: # In update
        c.endEditing()
        u.beforeChangeGroup(p,undoType)
        c.sortChildrenHelper(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(p,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20050415134809:c.sortChildren
#@+node:ekr.20040303175026.12:c.sortChildrenHelper
def sortChildrenHelper (self,p):
    
    c = self ; u = c.undoer

    # Create a list of tuples sorted on headlines.
    pairs = [(child.headString().lower(),child.copy()) for child in p.children_iter()]
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        undoData = u.beforeMoveNode(child)
        child.moveToNthChildOf(p,index)
        u.afterMoveNode(child,'Sort',undoData)
        index += 1
#@nonl
#@-node:ekr.20040303175026.12:c.sortChildrenHelper
#@+node:ekr.20050415134809.1:c.sortSiblings
def sortSiblings (self):
    
    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    p = c.currentPosition()
    if not p: return

    parent = p.parent()
    if not parent:
        c.sortTopLevel()
    else:
        c.beginUpdate()
        try: # In update...
            c.endEditing()
            u.beforeChangeGroup(p,undoType)
            c.sortChildrenHelper(parent)
            dirtyVnodeList = parent.setAllAncestorAtFileNodesDirty()
            c.setChanged(True)
            u.afterChangeGroup(p,'Sort Siblings',dirtyVnodeList=dirtyVnodeList)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20050415134809.1:c.sortSiblings
#@+node:ekr.20031218072017.2896:c.sortTopLevel
def sortTopLevel (self):

    c = self ; u = c.undoer ; undoType = 'Sort Siblings'
    root = c.rootPosition()
    if not root: return

    # Create a list of tuples sorted by headlines.
    pairs = [(p.headString().lower(),p.copy())
        for p in root.self_and_siblings_iter()]
    pairs.sort()
 
    c.beginUpdate()
    try: # In update...
        dirtyVnodeList = []
        u.beforeChangeGroup(root,undoType)
        if 1: # In group...
            h,p = pairs[0]
            if p != root:
                undoData = u.beforeMoveNode(p)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                p.moveToRoot(oldRoot=root)
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMoveNode(p,'Sort',undoData)
            for h,next in pairs[1:]:
                undoData = u.beforeMoveNode(next)
                next.moveAfter(p)
                u.afterMoveNode(next,'Sort',undoData)
                p = next
        u.afterChangeGroup(root,undoType,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2896:c.sortTopLevel
#@-node:ekr.20031218072017.2895: Top Level... (Commands)
#@+node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2072:c.checkOutline
def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    << assert equivalence of lastVisible methods >>
    for p in c.allNodes_iter():
        try:
            count += 1
            << remove unused tnodeList >>
            if full: # Unit tests usually set this false.
                << do full tests >>
        except AssertionError,message:
            errors += 1
            << give test failed message >>
    if verbose or not unittest:
        << print summary message >>
    return errors
#@nonl
#@+node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False
#@nonl
#@-node:ekr.20040314062338:<< assert equivalence of lastVisible methods >>
#@+node:ekr.20040313150633:<< remove unused tnodeList >>
# Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) > 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; g.es_print(s,color="blue")
    delattr(v.t,"tnodeList")
#@nonl
#@-node:ekr.20040313150633:<< remove unused tnodeList >>
#@+node:ekr.20040323155951:<< do full tests >>
if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others
#@nonl
#@+node:ekr.20040314035615:assert consistency of threadNext & threadBack links
threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"
#@nonl
#@-node:ekr.20040314035615:assert consistency of threadNext & threadBack links
#@+node:ekr.20040314035615.1:assert consistency of next and back links
back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"
#@nonl
#@-node:ekr.20040314035615.1:assert consistency of next and back links
#@+node:ekr.20040314035615.2:assert consistency of parent and child links
if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"
#@nonl
#@-node:ekr.20040314035615.2:assert consistency of parent and child links
#@+node:ekr.20040323155951.1:assert consistency of directParents and parent
if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
#@-node:ekr.20040323155951.1:assert consistency of directParents and parent
#@+node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"
#@nonl
#@-node:ekr.20040323161837:assert consistency of p.v.t.vnodeList, & v.parents for cloned nodes
#@+node:ekr.20040323162707:assert that clones actually share subtrees
if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"
#@nonl
#@-node:ekr.20040323162707:assert that clones actually share subtrees
#@+node:ekr.20040314043623:assert consistency of vnodeList
vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) > 1, "len(vnodeList) > 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"
#@nonl
#@-node:ekr.20040314043623:assert consistency of vnodeList
#@+node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
# Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"
#@nonl
#@-node:ekr.20040731053740:assert that p.headString() matches p.edit_text.get
#@-node:ekr.20040323155951:<< do full tests >>
#@+node:ekr.20040314044652:<< give test failed message >>
s = "test failed: %s %s" % (message,repr(p))
print s ; g.es_print(s,color="red")
#@nonl
#@-node:ekr.20040314044652:<< give test failed message >>
#@+node:ekr.20040314043900:<<print summary message >>
if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    g.es_print(s,color="red")
elif verbose:
    g.es(s,color="green")
#@nonl
#@-node:ekr.20040314043900:<<print summary message >>
#@-node:ekr.20031218072017.2072:c.checkOutline
#@+node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040723094220.1:checkAllPythonCode
def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not g.scanForAtSettings(p) and (not ignoreAtIgnore or not g.scanForAtIgnore(c,p)):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    import traceback ; traceback.print_exc()
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.cleanHeadString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result
#@nonl
#@+node:ekr.20040723094220.2:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.2:<< print dots >>
#@-node:ekr.20040723094220.1:checkAllPythonCode
#@+node:ekr.20040723094220.3:checkPythonCode
def checkPythonCode (self,unittest=False,ignoreAtIgnore=True,suppressErrors=False):
    
    c = self ; count = 0 ; result = "ok"
    
    if not unittest:
        g.es("checking Python code   ")
    
    for p in c.currentPosition().self_and_subtree_iter():
        
        count += 1
        if not unittest:
            << print dots >>

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest,suppressErrors)
                except (parser.ParserError,SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    g.es("surprise in checkPythonNode")
                    g.es_exception()
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")
        
    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result
#@nonl
#@+node:ekr.20040723094220.4:<< print dots >>
if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()
#@nonl
#@-node:ekr.20040723094220.4:<< print dots >>
#@-node:ekr.20040723094220.3:checkPythonCode
#@+node:ekr.20040723094220.5:checkPythonNode
def checkPythonNode (self,p,unittest=False,suppressErrors=False):

    c = self
    
    h = p.headString()
    # We must call getScript so that we can ignore directives and section references.
    body = g.getScript(c,p.copy())
    if not body: return

    try:
        compiler.parse(body + '\n')
    except (parser.ParserError,SyntaxError):
        if not suppressErrors:
            s = "Syntax error in: %s" % h
            g.es_print(s,color="blue")
        if unittest: raise
        else:
            g.es_exception(full=False,color="black")
            p.setMarked()

    c.tabNannyNode(p,h,body,unittest,suppressErrors)
#@nonl
#@-node:ekr.20040723094220.5:checkPythonNode
#@+node:ekr.20040723094220.6:tabNannyNode
# This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False,suppressErrors=False):

    """Check indentation using tabnanny."""

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))
        return
        
    except parser.ParserError, msg:
        if not suppressErrors:
            g.es("ParserError in %s" % headline,color="blue")
            g.es(str(msg))
        
    except tokenize.TokenError, msg:
        if not suppressErrors:
            g.es("TokenError in %s" % headline,color="blue")
            g.es(str(msg))

    except tabnanny.NannyNag, nag:
        if not suppressErrors:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])
        
    except:
        g.trace("unexpected exception")
        g.es_exception()

    if unittest: raise
    else: p.setMarked()
#@nonl
#@-node:ekr.20040723094220.6:tabNannyNode
#@-node:ekr.20040723094220:Check Outline commands & allies
#@+node:ekr.20040412060927:c.dumpOutline
def dumpOutline (self):
    
    """ Dump all nodes in the outline."""
    
    c = self

    for p in c.allNodes_iter():
        p.dump()
#@nonl
#@-node:ekr.20040412060927:c.dumpOutline
#@+node:ekr.20040711135959.1:Pretty Print commands
#@+node:ekr.20040712053025:prettyPrintAllPythonCode
def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025:prettyPrintAllPythonCode
#@+node:ekr.20040712053025.1:prettyPrintPythonCode
def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20040712053025.1:prettyPrintPythonCode
#@+node:ekr.20050729211526:prettyPrintPythonNode
def prettyPrintPythonNode (self,p=None,dump=False):

    c = self
    
    if not p:
        p = c.currentPosition()
    
    pp = c.prettyPrinter(c)

    # Unlike scanDirectives, scanForAtLanguage ignores @comment.
    if g.scanForAtLanguage(c,p) == "python":
        pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()
#@nonl
#@-node:ekr.20050729211526:prettyPrintPythonNode
#@+node:ekr.20040711135244.5:class prettyPrinter
class prettyPrinter:
    
    @others
#@nonl
#@+node:ekr.20040711135244.6:__init__
def __init__ (self,c):
    
    self.array = []
        # List of strings comprising the line being accumulated.
        # Important: this list never crosses a line.
    self.bracketLevel = 0
    self.c = c
    self.changed = False
    self.dumping = False
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.lastName = None # The name of the previous token type.
    self.line = 0 # Same as self.srow
    self.lineParenLevel = 0
    self.lines = [] # List of lines.
    self.name = None
    self.p = c.currentPosition()
    self.parenLevel = 0
    self.prevName = None
    self.s = None # The string containing the line.
    self.squareBracketLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.tracing = False
    << define dispatch dict >>
#@nonl
#@+node:ekr.20041021100850:<< define dispatch dict >>
self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}
#@nonl
#@-node:ekr.20041021100850:<< define dispatch dict >>
#@-node:ekr.20040711135244.6:__init__
#@+node:ekr.20040713093048:clear
def clear (self):
    self.lines = []
#@nonl
#@-node:ekr.20040713093048:clear
#@+node:ekr.20040713064323:dumpLines
def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.cleanHeadString()

    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])
#@nonl
#@-node:ekr.20040713064323:dumpLines
#@+node:ekr.20040711135244.7:dumpToken
def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))
#@nonl
#@-node:ekr.20040711135244.7:dumpToken
#@+node:ekr.20040713091855:endUndo
def endUndo (self):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    current = c.currentPosition()
    
    if self.changed:
        # Tag the end of the command.
        u.afterChangeGroup(current,undoType,dirtyVnodeList=self.dirtyVnodeList)
#@nonl
#@-node:ekr.20040713091855:endUndo
#@+node:ekr.20040711135244.8:get
def get (self):
    
    if self.lastName != 'newline' and self.lines:
        # Strip the trailing whitespace from the last line.
        self.lines[-1] = self.lines[-1].rstrip()
    
    return self.lines
#@nonl
#@-node:ekr.20040711135244.8:get
#@+node:ekr.20040711135244.4:prettyPrintNode
def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)
#@nonl
#@-node:ekr.20040711135244.4:prettyPrintNode
#@+node:ekr.20040711135244.9:put
def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)
#@nonl
#@-node:ekr.20040711135244.9:put
#@+node:ekr.20041021104237:putArray
def putArray (self):
    
    """Add the next text by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []
    self.lineParenLevel = 0
#@nonl
#@-node:ekr.20041021104237:putArray
#@+node:ekr.20040711135244.10:putNormalToken & allies
def putNormalToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row & col where the token begins in the source.
    self.erow,self.ecol = t4 # row & col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow

    if self.startLine:
        self.doStartLine()

    f = self.dispatchDict.get(self.name,self.oops)
    self.trace()
    f()
    self.lastName = self.name
#@nonl
#@+node:ekr.20041021102938:doEndMarker
def doEndMarker (self):
    
    self.putArray()
#@nonl
#@-node:ekr.20041021102938:doEndMarker
#@+node:ekr.20041021102340.1:doErrorToken
def doErrorToken (self):
    
    self.array.append(self.val)

    # This code is executed for versions of Python earlier than 2.4
    if self.val == '@':
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws:
            self.array.append(ws)
#@nonl
#@-node:ekr.20041021102340.1:doErrorToken
#@+node:ekr.20041021102340.2:doIndent & doDedent
def doDedent (self):
    
    pass
    
def doIndent (self):
    
    self.array.append(self.val)
#@-node:ekr.20041021102340.2:doIndent & doDedent
#@+node:ekr.20041021102340:doMultiLine (strings, etc).
def doMultiLine (self):

    # Ensure a blank before comments not preceded entirely by whitespace.
    
    if self.val.startswith('#') and self.array:
        prev = self.array[-1]
        if prev and prev[-1] != ' ':
            self.put(' ') 

    # These may span lines, so duplicate the end-of-line logic.
    lines = g.splitLines(self.val)
    for line in lines:
        self.array.append(line)
        if line and line[-1] == '\n':
            self.putArray()
    
    # Add a blank after the string if there is something in the last line.
    if self.array:
        line = self.array[-1]
        if line.strip():
            self.put(' ')
            
    # Suppress start-of-line logic.
    self.line = self.erow
#@nonl
#@-node:ekr.20041021102340:doMultiLine (strings, etc).
#@+node:ekr.20041021101911.5:doName
def doName(self):
    
    # Ensure whitespace or start-of-line precedes the name.
    if self.array:
        last = self.array[-1]
        ch = last[-1]
        outer = self.parenLevel == 0 and self.squareBracketLevel == 0
        chars = '@ \t{([.'
        if not outer: chars += ',=<>*-+&|/'
        if ch not in chars:
            self.array.append(' ')

    self.array.append("%s " % self.val)

    if self.prevName == "def": # A personal idiosyncracy.
        self.array.append(' ') # Retain the blank before '('.

    self.prevName = self.val
#@nonl
#@-node:ekr.20041021101911.5:doName
#@+node:ekr.20041021101911.3:doNewline
def doNewline (self):

    # Remove trailing whitespace.
    # This never removes trailing whitespace from multi-line tokens.
    if self.array:
        self.array[-1] = self.array[-1].rstrip()

    self.array.append('\n')
    self.putArray()
#@nonl
#@-node:ekr.20041021101911.3:doNewline
#@+node:ekr.20041021101911.6:doNumber
def doNumber (self):

    self.array.append(self.val)
#@-node:ekr.20041021101911.6:doNumber
#@+node:ekr.20040711135244.11:doOp
def doOp (self):
    
    val = self.val
    outer = self.lineParenLevel <= 0 or (self.parenLevel == 0 and self.squareBracketLevel == 0)
    # New in Python 2.4: '@' is an operator, not an error token.
    if self.val == '@':
        self.array.append(self.val)
        # Preserve whitespace after @.
        i = g.skip_ws(self.s,self.scol+1)
        ws = self.s[self.scol+1:i]
        if ws: self.array.append(ws)
    elif val == '(':
        # Nothing added; strip leading blank before function calls but not before Python keywords.
        strip = self.lastName=='name' and not keyword.iskeyword(self.prevName)
        self.put('(',strip=strip)
        self.parenLevel += 1 ; self.lineParenLevel += 1
    elif val in ('=','==','+=','-=','!=','<=','>=','<','>','<>','*','**','+','&','|','/','//'):
        # Add leading and trailing blank in outer mode.
        s = g.choose(outer,' %s ','%s')
        self.put(s % val)
    elif val in ('^','~','{','['):
        # Add leading blank in outer mode.
        s = g.choose(outer,' %s','%s')
        self.put(s % val)
        if val == '[': self.squareBracketLevel += 1
    elif val in (',',':','}',']',')'):
        # Add trailing blank in outer mode.
        s = g.choose(outer,'%s ','%s')
        self.put(s % val)
        if val == ']': self.squareBracketLevel -= 1
        if val == ')':
            self.parenLevel -= 1 ; self.lineParenLevel -= 1
    # ----- no difference between outer and inner modes ---
    elif val in (';','%'):
        # Add leading and trailing blank.
        self.put(' %s ' % val)
    elif val == '>>':
        # Add leading blank.
        self.put(' %s' % val)
    elif val == '<<':
        # Add trailing blank.
        self.put('%s ' % val)
    elif val in ('-'):
        # Could be binary or unary.  Or could be a hyphen in a section name.
        # Add preceding blank only for non-id's.
        if outer:
            if self.array:
                prev = self.array[-1].rstrip()
                if prev and prev[-1] not in string.digits + string.letters:
                    self.put(' %s' % val)
                else: self.put(val)
            else: self.put(val) # Try to leave whitespace unchanged.
        else:
            self.put(val)
    else:
        self.put(val)
#@nonl
#@-node:ekr.20040711135244.11:doOp
#@+node:ekr.20041021112219:doStartLine
def doStartLine (self):
    
    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
     
    if self.ws:
        self.array.append(self.ws)
#@nonl
#@-node:ekr.20041021112219:doStartLine
#@+node:ekr.20041021101911.1:oops
def oops(self):
    
    print "unknown PrettyPrinting code: %s" % (self.name)
#@nonl
#@-node:ekr.20041021101911.1:oops
#@+node:ekr.20041021101911.2:trace
def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))
#@nonl
#@-node:ekr.20041021101911.2:trace
#@-node:ekr.20040711135244.10:putNormalToken & allies
#@+node:ekr.20040711135244.12:putToken
def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)
#@nonl
#@-node:ekr.20040711135244.12:putToken
#@+node:ekr.20040713070356:replaceBody
def replaceBody (self,p,lines):
    
    c = self.c ; u = c.undoer ; undoType = 'Pretty Print'
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    if oldBody != body:
        if not self.changed:
            # Start the group.
            u.beforeChangeGroup(p,undoType)
            self.changed = True
            self.dirtyVnodeList = []
        undoData = u.beforeChangeNodeContents(p)
        p.setBodyStringOrPane(body)
        dirtyVnodeList2 = p.setDirty()
        self.dirtyVnodeList.extend(dirtyVnodeList2)
        u.afterChangeNodeContents(p,undoType,undoData,dirtyVnodeList=self.dirtyVnodeList)
    
#@nonl
#@-node:ekr.20040713070356:replaceBody
#@-node:ekr.20040711135244.5:class prettyPrinter
#@-node:ekr.20040711135959.1:Pretty Print commands
#@-node:ekr.20040711135959.2:Check Outline submenu...
#@+node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2899:Commands
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self):

    c = self
    
    c.beginUpdate()
    try: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    finally:
        c.endUpdate()

    c.expansionLevel = 1 # Reset expansion level.
#@nonl
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.contract()
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent(self):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
 
    if p.hasChildren() and p.isExpanded():
        c.contractNode()
    elif p.hasParent():
        c.goToParent()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20031218072017.2902:contractParent
def contractParent (self):
    
    c = self ; v = c.currentVnode()
    parent = v.parent()
    if not parent: return
    
    c.beginUpdate()
    try:
        c.selectVnode(parent)
        parent.contract()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2902:contractParent
#@+node:ekr.20031218072017.2903:expandAllHeadlines
def expandAllHeadlines(self):

    c = self ; v = root = c.rootVnode()
    c.beginUpdate()
    try:
        while v:
            c.expandSubtree(v)
            v = v.next()
        c.selectVnode(root)
    finally:
        c.endUpdate()
    c.expansionLevel = 0 # Reset expansion level.
#@nonl
#@-node:ekr.20031218072017.2903:expandAllHeadlines
#@+node:ekr.20031218072017.2904:expandAllSubheads
def expandAllSubheads (self):

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    try:
        c.expandSubtree(v)
        while child:
            c.expandSubtree(child)
            child = child.next()
        c.selectVnode(v)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2904:expandAllSubheads
#@+node:ekr.20031218072017.2905:expandLevel1..9
def expandLevel1 (self): self.expandToLevel(1)
def expandLevel2 (self): self.expandToLevel(2)
def expandLevel3 (self): self.expandToLevel(3)
def expandLevel4 (self): self.expandToLevel(4)
def expandLevel5 (self): self.expandToLevel(5)
def expandLevel6 (self): self.expandToLevel(6)
def expandLevel7 (self): self.expandToLevel(7)
def expandLevel8 (self): self.expandToLevel(8)
def expandLevel9 (self): self.expandToLevel(9)
#@-node:ekr.20031218072017.2905:expandLevel1..9
#@+node:ekr.20031218072017.2906:expandNextLevel
def expandNextLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(c.expansionLevel + 1)
#@-node:ekr.20031218072017.2906:expandNextLevel
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.expand()
    finally:
        c.endUpdate()

#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild(self):
    
    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        return

    if not p.isExpanded():
        c.expandNode()
        
    c.beginUpdate()
    try:
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        
def expandNodeOrGoToFirstChild(self):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren(): return

    if not p.isExpanded():
        c.expandNode()
    else:
        c.beginUpdate()
        try:
            c.selectVnode(p.firstChild())
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2908:expandPrevLevel
def expandPrevLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(max(1,c.expansionLevel - 1))
#@-node:ekr.20031218072017.2908:expandPrevLevel
#@-node:ekr.20031218072017.2899:Commands
#@+node:ekr.20031218072017.2909:Utilities
#@+node:ekr.20031218072017.2910:contractSubtree
def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()
#@nonl
#@-node:ekr.20031218072017.2910:contractSubtree
#@+node:ekr.20031218072017.2911:expandSubtree
def expandSubtree (self,v):

    c = self
    last = v.lastNode()
    while v and v != last:
        v.expand()
        v = v.threadNext()
    c.redraw()
#@nonl
#@-node:ekr.20031218072017.2911:expandSubtree
#@+node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    try:
        current = c.currentPosition()
        n = current.level()
        for p in current.self_and_subtree_iter():
            if p.level() - n + 1 < level:
                p.expand()
            else:
                p.contract()
        c.expansionLevel = level
        c.expansionNode = c.currentPosition()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
#@-node:ekr.20031218072017.2909:Utilities
#@-node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2913:Goto
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode(self):
    
    c = self

    while c.beadPointer + 1 < len(c.beadList):
        c.beadPointer += 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            c.frame.tree.idle_scrollTo(v)
            return
#@nonl
#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode(self):
    
    c = self

    while c.beadPointer > 0:
        c.beadPointer -= 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            c.frame.tree.idle_scrollTo(v)
            return
#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.2914:goToFirstNode
def goToFirstNode(self):
    
    c = self
    p = c.rootPosition()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2914:goToFirstNode
#@+node:ekr.20051012092453:goToFirstSibling (New in 4.4)
def goToFirstSibling(self):
    
    c = self ; p = c.currentPosition()
    
    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20051012092453:goToFirstSibling (New in 4.4)
#@+node:ekr.20031218072017.2915:goToLastNode (Bug fix in 4.4)
def goToLastNode(self):
    
    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext(): # Bug fix: 10/12/05: was p.hasNext.
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()

#@-node:ekr.20031218072017.2915:goToLastNode (Bug fix in 4.4)
#@+node:ekr.20051012092847.1:goToLastSibling (New in 4.4)
def goToLastSibling(self):
    
    c = self ; p = c.currentPosition()
    
    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20051012092847.1:goToLastSibling (New in 4.4)
#@+node:ekr.20050711153537:goToLastVisibleNode
def goToLastVisibleNode (self):
    
    c = self ; p = c.rootPosition()
    
    while p.hasNext():
        p.moveToNext()
        
    while p and p.isExpanded():
        p.moveToLastChild()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20050711153537:goToLastVisibleNode
#@+node:ekr.20031218072017.2916:goToNextClone
def goToNextClone(self):

    c = self ; current = c.currentVnode()
    if not current: return
    if not current.isCloned(): return

    v = current.threadNext()
    while v and v.t != current.t:
        v = v.threadNext()
        
    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and v != current and v.t != current.t:
            v = v.threadNext()

    if v:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectVnode(v)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2916:goToNextClone
#@+node:ekr.20031218072017.2917:goToNextDirtyHeadline
def goToNextDirtyHeadline (self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isDirty():
        v = v.threadNext()

    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and not v.isDirty():
            v = v.threadNext()

    if v:
        c.selectVnode(v)
    else:
        g.es("done",color="blue")
#@nonl
#@-node:ekr.20031218072017.2917:goToNextDirtyHeadline
#@+node:ekr.20031218072017.2918:goToNextMarkedHeadline
def goToNextMarkedHeadline(self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isMarked():
        v = v.threadNext()

    if v:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectVnode(v)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")
#@nonl
#@-node:ekr.20031218072017.2918:goToNextMarkedHeadline
#@+node:ekr.20031218072017.2919:goToNextSibling
def goToNextSibling(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    next = v.next()
    if next:
        c.beginUpdate()
        try:
            c.selectVnode(next)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2919:goToNextSibling
#@+node:ekr.20031218072017.2920:goToParent
def goToParent(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    p = v.parent()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20031218072017.2921:goToPrevSibling
def goToPrevSibling(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    back = v.back()
    if back:
        c.beginUpdate()
        try:
            c.selectVnode(back)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2921:goToPrevSibling
#@-node:ekr.20031218072017.2913:Goto
#@+node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.2923:markChangedHeadlines
def markChangedHeadlines (self): 

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()
    
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2923:markChangedHeadlines
#@+node:ekr.20031218072017.2924:markChangedRoots
def markChangedRoots (self):

    c = self ; u = c.undoer ; undoType = 'Mark Changed'
    current = c.currentPosition()

    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,undoType)
        for p in c.allNodes_iter():
            if p.isDirty()and not p.isMarked():
                s = p.bodyString()
                flag, i = g.is_special(s,0,"@root")
                if flag:
                    bunch = u.beforeMark(p,undoType)
                    p.setMarked()
                    c.setChanged(True)
                    u.afterMark(p,undoType,bunch)
        u.afterChangeGroup(current,undoType)
        g.es("done",color="blue")
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2924:markChangedRoots
#@+node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
def markAllAtFileNodesDirty (self):

    c = self ; p = c.rootPosition()

    c.beginUpdate()
    try: # In update...
        while p:
            if p.isAtFileNode()and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2925:markAllAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
def markAtFileNodesDirty (self):

    c = self
    p = c.currentPosition()
    if not p: return

    after = p.nodeAfterTree()
    c.beginUpdate()
    try: # In update...
        while p and p != after:
            if p.isAtFileNode() and not p.isDirty():
                p.setDirty()
                c.setChanged(True)
                p.moveToNodeAfterTree()
            else:
                p.moveToThreadNext()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2926:markAtFileNodesDirty (not used)
#@+node:ekr.20031218072017.2927:markClones
def markClones (self):

    c = self ; u = c.undoer ; undoType = 'Mark Clones'
    current = c.currentPosition()
    if not current or not current.isCloned():
        g.es('The current node is not a clone',color='blue')
        return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.v.t == current.v.t:
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                c.setChanged(True)
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2927:markClones
#@+node:ekr.20031218072017.2928:markHeadline
def markHeadline (self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    c.beginUpdate()
    try: # In update...
        undoType = g.choose(p.isMarked(),'Unmark','Mark')
        bunch = u.beforeMark(p,undoType)
        if p.isMarked():
            p.clearMarked()
        else:
            p.setMarked()
        dirtyVnodeList = p.setDirty()
        c.setChanged(True)
        u.afterMark(p,undoType,bunch,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2928:markHeadline
#@+node:ekr.20031218072017.2929:markSubheads
def markSubheads(self):

    c = self ; u = c.undoer ; undoType = 'Mark Subheads'
    current = c.currentPosition()
    if not current: return

    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in current.children_iter():
            if not p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.setMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2929:markSubheads
#@+node:ekr.20031218072017.2930:unmarkAll
def unmarkAll(self):

    c = self ; u = c.undoer ; undoType = 'Unmark All'
    current = c.currentPosition()
    if not current: return
    
    c.beginUpdate()
    u.beforeChangeGroup(current,undoType)
    try: # In update...
        dirtyVnodeList = []
        for p in c.allNodes_iter():
            if p.isMarked():
                bunch = u.beforeMark(p,undoType)
                p.clearMarked()
                dirtyVnodeList2 = p.setDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
                c.setChanged(True)
                u.afterMark(p,undoType,bunch)
    finally:
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2930:unmarkAll
#@-node:ekr.20031218072017.2922:Mark...
#@+node:ekr.20031218072017.1766:Move... (Commands)
#@+node:ekr.20031218072017.1767:demote
def demote(self):

    c = self ; u = c.undoer
    current = c.currentPosition()
    command = 'Demote'
    if not current or not current.hasNext(): return

    # Make sure all the moves will be valid.
    for child in current.children_iter():
        if not c.checkMoveWithParentWithWarning(child,current,True):
            return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        u.beforeChangeGroup(current,command)
        p = current.copy()
        while p.hasNext(): # Do not use iterator here.
            child = p.next()
            undoData = u.beforeMoveNode(child)
            child.moveToNthChildOf(p,p.numberOfChildren())
            u.afterMoveNode(child,command,undoData)
        p.expand()
        # Even if p is an @ignore node there is no need to mark the demoted children dirty.
        dirtyVnodeList = current.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterChangeGroup(current,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(current)
    finally:
        c.endUpdate()
    c.updateSyntaxColorer(current) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1767:demote
#@+node:ekr.20031218072017.1768:moveOutlineDown
@ Moving down is more tricky than moving up; we can't move p to be a child of itself.  An important optimization:  we don't have to call checkMoveWithParentWithWarning() if the parent of the moved node remains the same.
@c

def moveOutlineDown(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return

    if not c.canMoveOutlineDown(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
        
    inAtIgnoreRange = p.inAtIgnoreRange()
    # Set next to the node after which p will be moved.
    next = p.visNext()
    while next and p.isAncestorOf(next):
        next = next.visNext()
    if not next: return
    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        << Move p down & set moved if successful >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
                dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Down',undoData,dirtyVnodeList)
            c.selectPosition(p)
    finally:
        c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
if next.hasChildren() and next.isExpanded():
    # Attempt to move p to the first child of next.
    moved = c.checkMoveWithParentWithWarning(p,next,True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveToNthChildOf(next,0)
        
else:
    # Attempt to move p after next.
    moved = c.checkMoveWithParentWithWarning(p,next.parent(),True)
    if moved:
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(next)
#@nonl
#@-node:ekr.20031218072017.1769:<< Move p down & set moved if successful >>
#@-node:ekr.20031218072017.1768:moveOutlineDown
#@+node:ekr.20031218072017.1770:moveOutlineLeft
def moveOutlineLeft(self):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineLeft(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasParent(): return

    inAtIgnoreRange = p.inAtIgnoreRange()
    parent = p.parent()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        p.moveAfter(parent)
        if inAtIgnoreRange and not p.inAtIgnoreRange():
            # The moved nodes have just become newly unignored.
            p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Left',undoData,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1770:moveOutlineLeft
#@+node:ekr.20031218072017.1771:moveOutlineRight
def moveOutlineRight(self):
    
    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineRight(): # 11/4/03: Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    if not p.hasBack: return
    back = p.back()
    if not c.checkMoveWithParentWithWarning(p,back,True): return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        n = back.numberOfChildren()
        p.moveToNthChildOf(back,n)
        # Moving an outline right can never bring it outside the range of @ignore.
        dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
        dirtyVnodeList.extend(dirtyVnodeList2)
        c.setChanged(True)
        u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1771:moveOutlineRight
#@+node:ekr.20031218072017.1772:moveOutlineUp
def moveOutlineUp(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    if not p: return
    if not c.canMoveOutlineUp(): # Support for hoist.
        if c.hoistStack: g.es("Can't move node out of hoisted outline",color="blue")
        return
    back = p.visBack()
    if not back: return
    inAtIgnoreRange = p.inAtIgnoreRange()
    back2 = back.visBack()
    if back2 and p.v in back2.v.t.vnodeList:
        # A weird special case: just select back2.
        c.selectPosition(back2)
        return

    c.beginUpdate()
    try: # update...
        c.endEditing()
        undoData = u.beforeMoveNode(p)
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        << Move p up >>
        if moved:
            if inAtIgnoreRange and not p.inAtIgnoreRange():
                # The moved nodes have just become newly unignored.
                dirtyVnodeList2 = p.setDirty() # Mark descendent @thin nodes dirty.
            else: # No need to mark descendents dirty.
                dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty()
            dirtyVnodeList.extend(dirtyVnodeList2)
            c.setChanged(True)
            u.afterMoveNode(p,'Move Right',undoData,dirtyVnodeList)
            c.selectPosition(p)
    finally:
        c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@+node:ekr.20031218072017.1773:<< Move p up >>
if 0:
    g.trace("visBack",back)
    g.trace("visBack2",back2)
    g.trace("oldParent",oldParent)
    g.trace("back2.hasChildren",back2.hasChildren())
    g.trace("back2.isExpanded",back2.isExpanded())

if not back2:
    # p will be the new root node
    moved = True
    p.moveToRoot(c.rootPosition())

elif back2.hasChildren() and back2.isExpanded():
    if c.checkMoveWithParentWithWarning(p,back2,True):
        moved = True
        p.moveToNthChildOf(back2,0)

else:
    if c.checkMoveWithParentWithWarning(p,back2.parent(),True):
        moved = True
        p.moveAfter(back2)
#@nonl
#@-node:ekr.20031218072017.1773:<< Move p up >>
#@-node:ekr.20031218072017.1772:moveOutlineUp
#@+node:ekr.20031218072017.1774:promote
def promote(self):

    c = self ; u = c.undoer ; p = c.currentPosition()
    command = 'Promote'
    if not p or not p.hasChildren(): return

    isAtIgnoreNode = p.isAtIgnoreNode()
    inAtIgnoreRange = p.inAtIgnoreRange()
    c.beginUpdate()
    try: # In update...
        c.endEditing()
        u.beforeChangeGroup(p,command)
        after = p
        while p.hasChildren(): # Don't use an iterator.
            child = p.firstChild()
            undoData = u.beforeMoveNode(child)
            child.moveAfter(after)
            after = child
            u.afterMoveNode(child,command,undoData)
        c.setChanged(True)
        if not inAtIgnoreRange and isAtIgnoreNode:
            # The promoted nodes have just become newly unignored.
            dirtyVnodeList = p.setDirty() # Mark descendent @thin nodes dirty.
        else: # No need to mark descendents dirty.
            dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        u.afterChangeGroup(p,command,dirtyVnodeList=dirtyVnodeList)
        c.selectPosition(p)
    finally:
        c.endUpdate()
    c.updateSyntaxColorer(p) # Moving can change syntax coloring.
#@nonl
#@-node:ekr.20031218072017.1774:promote
#@-node:ekr.20031218072017.1766:Move... (Commands)
#@-node:ekr.20031218072017.2894:Outline menu...
#@+node:ekr.20031218072017.2931:Window Menu
#@+node:ekr.20031218072017.2092:openCompareWindow
def openCompareWindow (self):
    
    c = self ; frame = c.frame
    
    if not frame.comparePanel:
        frame.comparePanel = g.app.gui.createComparePanel(c)

    frame.comparePanel.bringToFront()
#@nonl
#@-node:ekr.20031218072017.2092:openCompareWindow
#@+node:ekr.20031218072017.2932:openPythonWindow (Dave Hein)
def openPythonWindow(self):

    if sys.platform == "linux2":
        << open idle in Linux >>
    else:
        << open idle in Windows >>
#@+node:ekr.20031218072017.2933:<< open idle in Linux >>
# 09-SEP-2002 DHEIN: Open Python window under linux

try:
    pathToLeo = g.os_path_join(g.app.loadDir,"leo.py")
    sys.argv = [pathToLeo]
    from idlelib import idle
    if g.app.idle_imported:
        reload(idle)
    g.app.idle_imported = True
except:
    try:
        g.es("idlelib could not be imported.")
        g.es("Probably IDLE is not installed.")
        g.es("Run Tools/idle/setup.py to build idlelib.")
        g.es("Can not import idle")
        g.es_exception() # This can fail!!
    except: pass
#@-node:ekr.20031218072017.2933:<< open idle in Linux >>
#@+node:ekr.20031218072017.2934:<< open idle in Windows >>
# Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo"] # ,"-t","Leo"]

ok = False
if g.CheckVersion(sys.version,"2.3"):
    << Try to open idle in Python 2.3 systems >>
else:
    << Try to open idle in Python 2.2 systems >>

if not ok:
    g.es("Can not import idle")
    if idle_dir and idle_dir not in sys.path:
        g.es("Please add '%s' to sys.path" % idle_dir)
#@nonl
#@+node:ekr.20031218072017.2936:<< Try to open idle in Python 2.3 systems >>
try:
    idle_dir = None
    
    import idlelib.PyShell

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    idlelib.PyShell.main()
    ok = True

except:
    ok = False
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2936:<< Try to open idle in Python 2.3 systems >>
#@+node:ekr.20031218072017.2935:<< Try to open idle in Python 2.2 systems>>
try:
    executable_dir = g.os_path_dirname(sys.executable)
    idle_dir = g.os_path_join(executable_dir,"Tools","idle")

    # 1/29/04: sys.path doesn't handle unicode in 2.2.
    idle_dir = str(idle_dir) # May throw an exception.

    # 1/29/04: must add idle_dir to sys.path even when using importFromPath.
    if idle_dir not in sys.path:
        sys.path.insert(0,idle_dir)

    if 1:
        import PyShell
    else: # Works, but is not better than import.
        PyShell = g.importFromPath("PyShell",idle_dir)

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    if 1: # Mostly works, but causes problems when opening other .leo files.
        PyShell.main()
    else: # Doesn't work: destroys all of Leo when Idle closes.
        self.leoPyShellMain()
    ok = True
except ImportError:
    ok = False
    g.es_exception()
#@nonl
#@-node:ekr.20031218072017.2935:<< Try to open idle in Python 2.2 systems>>
#@-node:ekr.20031218072017.2934:<< open idle in Windows >>
#@+node:ekr.20031218072017.2937:leoPyShellMain
@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work well.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
    
    import PyShell
    root = g.app.root
    PyShell.fixwordbreaks(root)
    flist = PyShell.PyShellFileList(root)
    shell = PyShell.PyShell(flist)
    flist.pyshell = shell
    shell.begin()
#@nonl
#@-node:ekr.20031218072017.2937:leoPyShellMain
#@-node:ekr.20031218072017.2932:openPythonWindow (Dave Hein)
#@-node:ekr.20031218072017.2931:Window Menu
#@+node:ekr.20031218072017.2938:Help Menu
#@+node:ekr.20031218072017.2939:about (version number & date)
def about(self):
    
    c = self
    
    # Don't use triple-quoted strings or continued strings here.
    # Doing so would add unwanted leading tabs.
    version = c.getSignOnLine() + "\n\n"
    theCopyright = (
        "Copyright 1999-2005 by Edward K. Ream\n" +
        "All Rights Reserved\n" +
        "Leo is distributed under the Python License")
    url = "http://webpages.charter.net/edreamleo/front.html"
    email = "edreamleo@charter.net"

    g.app.gui.runAboutLeoDialog(c,version,theCopyright,url,email)
#@nonl
#@-node:ekr.20031218072017.2939:about (version number & date)
#@+node:ekr.20031218072017.2943:leoConfig
def openLeoSettings (self):

    c = self
    name = 'leoSettings.leo'
    homeDir = g.app.homeDir
    loadDir = g.app.loadDir
    configDir = g.app.globalConfigDir

    # Look in configDir first.
    fileName = g.os_path_join(configDir,name)

    # Look in homeDir second.
    ok, frame = g.openWithFileName(fileName,c)
    if not ok:
        if configDir == loadDir:
            g.es("%s not found in %s" % (name,configDir))
        else:
            fileName = g.os_path_join(homeDir,name)
            ok, frame = g.openWithFileName(fileName,c)
            if not ok:
                g.es("%s not found in %s or %s" % (name,configDir,homeDir))
#@nonl
#@-node:ekr.20031218072017.2943:leoConfig
#@+node:ekr.20031218072017.2940:leoDocumentation
def leoDocumentation (self):
    
    c = self ; name = "LeoDocs.leo"

    fileName = g.os_path_join(g.app.loadDir,"..","doc",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)
#@-node:ekr.20031218072017.2940:leoDocumentation
#@+node:ekr.20031218072017.2941:leoHome
def leoHome (self):
    
    import webbrowser

    url = "http://webpages.charter.net/edreamleo/front.html"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found: " + url)
#@nonl
#@-node:ekr.20031218072017.2941:leoHome
#@+node:ekr.20050130152008:leoPlugins
def openLeoPlugins (self):
    
    c = self ; name = "leoPlugins.leo"
    fileName = g.os_path_join(g.app.loadDir,"..","plugins",name)
    ok,frame = g.openWithFileName(fileName,c)
    if not ok:
        g.es("not found: %s" % name)
#@nonl
#@-node:ekr.20050130152008:leoPlugins
#@+node:ekr.20031218072017.2942:leoTutorial (version number)
def leoTutorial (self):
    
    import webbrowser

    if 1: # new url
        url = "http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"
    else:
        url = "http://www.evisa.com/e/sbooks/leo/sbframetoc_ie.htm"
    try:
        webbrowser.open_new(url)
    except:
        g.es("not found: " + url)
#@nonl
#@-node:ekr.20031218072017.2942:leoTutorial (version number)
#@-node:ekr.20031218072017.2938:Help Menu
#@-node:ekr.20031218072017.2818:Command handlers...
#@+node:ekr.20051006125633.1:bindShortcut
def bindShortcut (self,shortcut,name,command,openWith,fromMenu=False):
    
    '''Bind one shortcut from a menu table.'''
    
    __pychecker__ = '--no-argsused'
        # The pychecker warning about 'name' being unused is WRONG.
    
    k = self ; c = k.c ; w = c.frame.body.bodyCtrl
    
    shortcut = str(shortcut)
    
    if openWith:
        k.bindOpenWith(shortcut,name,command)
        return True

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by this particular leoCallback function.
        func = k.leoCallbackDict.get(command)
        name = func.__name__
        # g.trace('%25s (leo) %s' % (shortcut,name))
        
        # No need for a second layer of callback.
        def keyCallback (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
    else:
        # Important: the name just needs to be unique for every function.
        name = command.__name__
        # g.trace('%25s %s' % (shortcut,name))

        def menuFuncCallback (event,command=command,name=name):
            # g.trace(name)
            return command(event)

        def keyCallback (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
        
    return k.bindKey(w,shortcut,keyCallback,name,fromMenu,tag='bindShortcut')
#@nonl
#@-node:ekr.20051006125633.1:bindShortcut
#@+node:ekr.20051008134059:setBindingsFromCommandsDict
def setBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.
    
    These bindings may also be specied later by menu code,
    but bindShortcut and bindKey ignore equivalent bindings.
    '''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for name in keys:
        command = c.commandsDict.get(name)
        
        key, accel = c.config.getShortcut(name)
        if accel:
            bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
            k.bindShortcut(bind_shortcut,name,command,openWith=name=='open-with')
        else:
            bind_shortcut = None
        
        # g.trace('%25s %s' % (name,bind_shortcut))
#@nonl
#@-node:ekr.20051008134059:setBindingsFromCommandsDict
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()
    
    if self.useCmdMenu and c.useMiniBuffer:
        self.defineEditorMenuTables()

    self.defineHelpMenuTables()
#@nonl
#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@nonl
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
        ("-",None,None),
        # A Horrible kludge.  The -- indicates we should set menu_shortcut but *not* the bind_shortcut.
        # This is needed so we can distinguish between invokes from the menu (very rare) and others.
        # Important: these shortcuts can be overridden by specifying shortcuts for copy-text, cut-text and paste-text.
        ("Cu&t","--Ctrl+X",f.OnCutFromMenu), 
        ("Cop&y","--Ctrl+C",f.OnCopyFromMenu),
        ("&Paste","--Ctrl+V",f.OnPasteFromMenu),
        ("&Delete",None,c.delete),
        ("Select &All","Ctrl+A",f.body.selectAllText),
        ("-",None,None),
    ]
        
    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20050711091931:defineEditMenuEditCursorTable
def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), # Tk: Del
            ('Delete Left',c.deleteLeftChar), # Tk: Backspace
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), # Tk: Home
            ('End of Line',c.moveToEndOfLine), # Tk: End
            ('Start of Node',c.moveToStartOfNode), # Tk: c-Home
            ('End of Node',c.moveToEndOfNode), # Tk: c-End
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), # Tk: s-Home
            ('Extend To End Of Line',c.extendToEndOfLine), # Tk: s-End
            ('Extend To End of Node',c.extendToEndOfNode), # Tk: s-c-End
            # The mark...
        ]
#@nonl
#@-node:ekr.20050711091931:defineEditMenuEditCursorTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &Section","Shift+Ctrl+E",c.extractSection),
        ("Extract &Names","Shift+Ctrl+N",c.extractSectionNames),
        ("&Extract","Shift+Ctrl+D",c.extract),
        ("-",None,None),
        ("Convert All B&lanks",None,c.convertAllBlanks),
        ("Convert All T&abs",None,c.convertAllTabs),
        ("Convert &Blanks","Shift+Ctrl+B",c.convertBlanks),
        ("Convert &Tabs","Shift+Ctrl+J",c.convertTabs),
        ("Insert Body Time/&Date","Shift+Ctrl+G",c.insertBodyTime),
        ("&Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
        ("-",None,None),
        ("&Indent","Ctrl+]",c.indentBody),
        ("&Unindent","Ctrl+[",c.dedentBody),
        ("&Match Brackets","Ctrl+K",c.findMatchingBracket),
        ("Add Comments",None,c.addComments),
        ("Delete Comments",None,c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@nonl
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &Headline","Ctrl+H",c.editHeadline),
        ("&End Edit Headline","Escape",f.endEditLabelCommand),
        ("&Abort Edit Headline","Shift+Escape",f.abortEditLabelCommand),
        ("Insert Headline Time/&Date","Shift+Ctrl+H",f.insertHeadlineTime),
        # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
        ("Toggle Angle Brackets",None,c.toggleAngleBrackets),
    ]
#@nonl
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuFindMenuTable = [
        ("&Find Panel","F5",c.showFindPanel),
        ("-",None,None),
        ("Find &Next","F3",c.findNext),
        ("Find &Previous","F4",c.findPrevious),
        ("&Replace","Ctrl+=",c.replace),
        ("Replace, &Then Find","Ctrl+-",c.replaceThenFind),
    ]
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")
        
    self.editMenuTop2Table = [
        ("&Go To Line Number","Alt+G",c.goToLineNumber),
        ("&Execute Script","Alt+Shift+E",c.executeScript),
        # ("Set Fon&t...",None,c.fontPanel), # To be replaced by general settings dialog.
        # ("Set &Colors...",None,c.colorPanel), # To be replaced by general settings dialog.
        (label,"Alt+V",c.viewAllCharacters),
        # ("-",None,None),
        ("Setti&ngs",None,c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@nonl
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&New","Ctrl+N",c.new),
        ("&Open...","Ctrl+O",c.open),
    ]
#@nonl
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None,None),
        ("&Close","Ctrl+W",c.close),
        ("&Save","Ctrl+S",c.save),
        ("Save &As","Shift+Ctrl+S",c.saveAs),
        ("Save To",None,c.saveTo), # &Tangle
        ("Re&vert To Saved",None,c.revert), # &Read/Write
    ]
#@nonl
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuReadWriteMenuTable = [
        ("&Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
        ("Read @file &Nodes",None,c.readAtFileNodes),
        ("-",None,None),
        ("Write &Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
        ("Write &Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
        ("Write &Outline Only",None,c.fileCommands.writeOutlineOnly),
        ("&Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes),
    ]
#@nonl
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &All","Shift+Ctrl+A",c.tangleAll),
        ("Tangle &Marked","Shift+Ctrl+M",c.tangleMarked),
        ("&Tangle","Shift+Ctrl+T",c.tangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &All",None,c.untangleAll),
        ("Untangle &Marked",None,c.untangleMarked),
        ("&Untangle","Shift+Ctrl+U",c.untangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",None,c.importDerivedFile),
        ("Import To @&file","Shift+Ctrl+F",c.importAtFile),
        ("Import To @&root",None,c.importAtRoot),
        ("Import &CWEB Files",None,c.importCWEBFiles),
        
        ("Import &noweb Files",None,c.importNowebFiles),
        ("Import Flattened &Outline",None,c.importFlattenedOutline),
    ]
#@nonl
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &Headlines",None,c.exportHeadlines),
        ("Outline To &CWEB",None,c.outlineToCWEB),
        ("Outline To &Noweb",None,c.outlineToNoweb),
        ("&Flatten Outline",None,c.flattenOutline),
        ("&Remove Sentinels",None,c.removeSentinels),
        ("&Weave",None,c.weave),
    ]
#@nonl
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&xit","Ctrl+Q",g.app.onQuit),
    ]
#@nonl
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@nonl
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
        ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
        ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
        ("Pas&te Node As Clone",None,c.pasteOutlineRetainingClones),
        ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
        ("-",None,None),
        ("&Insert Node","Ctrl+I",c.insertHeadline),
        ("&Clone Node","Ctrl+`",c.clone),
        ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
        ("&Sort Siblings","Alt+A",c.sortSiblings),
        ("-",None,None),
        ("&Hoist",None,c.hoist),
        ("D&e-Hoist",None,f.c.dehoist),
        ("-",None,None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &Outline",None,c.checkOutline),
        ("&Dump Outline",None,c.dumpOutline),
        ("-",None,None),
        ("Check &All Python Code",None,c.checkAllPythonCode),
        ("&Check Python &Code",None,c.checkPythonCode),
        ("-",None,None),
        ("Pretty P&rint All Python Code",None,c.prettyPrintAllPythonCode),
        ("&Pretty Print Python Code",None,c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&Contract All","Alt+-",c.contractAllHeadlines),
        ("Contract &Node","Alt+[",c.contractNode),
        ("Contract &Parent","Alt+0",c.contractParent),
        ("Contract Or Go Left",None,c.contractNodeOrGoToParent),
        ("-",None,None),
        ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
        ("Expand N&ext Level","Alt+=",c.expandNextLevel),
        ("Expand And Go Right",None,c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",None,c.expandNodeOrGoToFirstChild),
        ("-",None,None),
        ("Expand To Level &1","Alt+1",c.expandLevel1),
        ("Expand To Level &2","Alt+2",c.expandLevel2),
        ("Expand To Level &3","Alt+3",c.expandLevel3),
        ("Expand To Level &4","Alt+4",c.expandLevel4),
        ("Expand To Level &5","Alt+5",c.expandLevel5),
        ("Expand To Level &6","Alt+6",c.expandLevel6),
        ("Expand To Level &7","Alt+7",c.expandLevel7),
        ("Expand To Level &8","Alt+8",c.expandLevel8),
        # ("Expand To Level &9","Alt+9",c.expandLevel9),
        ("-",None,None),
        ("Expand &All","Alt+9",c.expandAllHeadlines),
        ("Expand N&ode","Alt+]",c.expandNode),
    ]
#@nonl
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &Down", "Ctrl+D",c.moveOutlineDown),
        ("Move &Left", "Ctrl+L",c.moveOutlineLeft),
        ("Move &Right","Ctrl+R",c.moveOutlineRight),
        ("Move &Up",   "Ctrl+U",c.moveOutlineUp),
        ("-",None,None),
        ("&Promote","Ctrl+{",c.promote),
        ("&Demote", "Ctrl+}",c.demote),
    ]
#@nonl
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&Mark","Ctrl+M",c.markHeadline),
        ("Mark &Subheads","Alt+S",c.markSubheads),
        ("Mark Changed &Items","Alt+C",c.markChangedHeadlines),
        ("Mark Changed &Roots","Alt+R",c.markChangedRoots),
        ("Mark &Clones","Alt+K",c.markClones),
        ("&Unmark All","Alt+U",c.unmarkAll),
    ]
#@nonl
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",None,c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",None,c.goNextVisitedNode),
        ("Go To Prev Node",None,c.selectThreadBack),
        ("Go To Next Node",None,c.selectThreadNext),
        ("-",None,None),
        ("Go To Next Marked",None,c.goToNextMarkedHeadline),
        ("Go To Next Changed",None,c.goToNextDirtyHeadline),
        ("Go To Next Clone",None,c.goToNextClone),
        ("-",None,None),
        ("Go To First Node",None,c.goToFirstNode),
        ("Go To Prev Visible",None,c.selectVisBack),
        ("Go To Next Visible",None,c.selectVisNext),
        ("Go To Last Node",None,c.goToLastNode),
        ('Go To Last Visible',None,c.goToLastVisibleNode),
        ("-",None,None),
        ("Go To Parent",None,c.goToParent),
        ('Go To First Sibling',None,c.goToFirstSibling),
        ('Go To Last Sibling',None,c.goToLastSibling),
        ("Go To Prev Sibling",None,c.goToPrevSibling),
        ("Go To Next Sibling",None,c.goToNextSibling),
    ]
#@nonl
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineEditorMenuTables
def defineEditorMenuTables (self):
    
    def dummyCommand():
        pass
    
    self.emacsMenuCommandsMenuTable = [
        ('Cmnd Command 1',None,dummyCommand),
    ]
    
    self.emacsMenuToolsMenuTable = [
        ('Tools Command 1',None,dummyCommand),
    ]

    self.emacsMenuOptionsMenuTable = [
        ('Options Command 1',None,dummyCommand),
    ]

    self.emacsMenuBuffersMenuTable = [
        ('Buffers Command 1',None,dummyCommand),
    ]
#@nonl
#@-node:ekr.20050921103230:defineEditorMenuTables
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&Equal Sized Panes","Ctrl+E",f.equalSizedPanes),
        ("Toggle &Active Pane","Ctrl+T",f.toggleActivePane),
        ("Toggle &Split Direction",None,f.toggleSplitDirection),
        ("-",None,None),
        ("Resize To Screen",None,f.resizeToScreen),
        ("Casca&de",None,f.cascade),
        ("&Minimize All",None,f.minimizeAll),
        ("-",None,None),
        ("Open &Compare Window",None,c.openCompareWindow),
        ("Open &Python Window","Alt+P",c.openPythonWindow),
    ]
#@nonl
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&About Leo...",None,c.about),
        ("Online &Home Page",None,c.leoHome),
        ("Open Online &Tutorial",None,c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &Offline Tutorial",None,f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&Docs.leo",None,c.leoDocumentation),
        ("Open Leo&Plugins.leo",None,c.openLeoPlugins),
        ("Open Leo&Settings.leo",None,c.openLeoSettings),
    ]
#@nonl
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@+node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    << define dictionary d of names and Leo commands >>
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2
#@nonl
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    #'check-spelling':      None,                   # Create this command.
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    # Leo find panel stuff.  It's not clear what will happen to these.
    'dismiss-leo-find-panel':   c.dismissFindPanel,
    'leo-change':               c.replace,
    'leo-change-then-find':     c.replaceThenFind,
    'leo-change-all':           c.replaceAll,
    'leo-find':                 c.findNext,
    'leo-find-panel':           c.showFindPanel,
    'leo-find-previous':        c.findPrevious,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}
#@nonl
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@-node:ekr.20050920084036.188:leoCommands.getPublicCommands (sets inversCommandDict & leoCallbackDict)
#@-node:ekr.20051010181742:(Leo commands)
#@+node:ekr.20051012091323:(Outline goto's)
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@nonl
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
        ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
        ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
        ("Pas&te Node As Clone",None,c.pasteOutlineRetainingClones),
        ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
        ("-",None,None),
        ("&Insert Node","Ctrl+I",c.insertHeadline),
        ("&Clone Node","Ctrl+`",c.clone),
        ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
        ("&Sort Siblings","Alt+A",c.sortSiblings),
        ("-",None,None),
        ("&Hoist",None,c.hoist),
        ("D&e-Hoist",None,f.c.dehoist),
        ("-",None,None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &Outline",None,c.checkOutline),
        ("&Dump Outline",None,c.dumpOutline),
        ("-",None,None),
        ("Check &All Python Code",None,c.checkAllPythonCode),
        ("&Check Python &Code",None,c.checkPythonCode),
        ("-",None,None),
        ("Pretty P&rint All Python Code",None,c.prettyPrintAllPythonCode),
        ("&Pretty Print Python Code",None,c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&Contract All","Alt+-",c.contractAllHeadlines),
        ("Contract &Node","Alt+[",c.contractNode),
        ("Contract &Parent","Alt+0",c.contractParent),
        ("Contract Or Go Left",None,c.contractNodeOrGoToParent),
        ("-",None,None),
        ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
        ("Expand N&ext Level","Alt+=",c.expandNextLevel),
        ("Expand And Go Right",None,c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",None,c.expandNodeOrGoToFirstChild),
        ("-",None,None),
        ("Expand To Level &1","Alt+1",c.expandLevel1),
        ("Expand To Level &2","Alt+2",c.expandLevel2),
        ("Expand To Level &3","Alt+3",c.expandLevel3),
        ("Expand To Level &4","Alt+4",c.expandLevel4),
        ("Expand To Level &5","Alt+5",c.expandLevel5),
        ("Expand To Level &6","Alt+6",c.expandLevel6),
        ("Expand To Level &7","Alt+7",c.expandLevel7),
        ("Expand To Level &8","Alt+8",c.expandLevel8),
        # ("Expand To Level &9","Alt+9",c.expandLevel9),
        ("-",None,None),
        ("Expand &All","Alt+9",c.expandAllHeadlines),
        ("Expand N&ode","Alt+]",c.expandNode),
    ]
#@nonl
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &Down", "Ctrl+D",c.moveOutlineDown),
        ("Move &Left", "Ctrl+L",c.moveOutlineLeft),
        ("Move &Right","Ctrl+R",c.moveOutlineRight),
        ("Move &Up",   "Ctrl+U",c.moveOutlineUp),
        ("-",None,None),
        ("&Promote","Ctrl+{",c.promote),
        ("&Demote", "Ctrl+}",c.demote),
    ]
#@nonl
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&Mark","Ctrl+M",c.markHeadline),
        ("Mark &Subheads","Alt+S",c.markSubheads),
        ("Mark Changed &Items","Alt+C",c.markChangedHeadlines),
        ("Mark Changed &Roots","Alt+R",c.markChangedRoots),
        ("Mark &Clones","Alt+K",c.markClones),
        ("&Unmark All","Alt+U",c.unmarkAll),
    ]
#@nonl
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",None,c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",None,c.goNextVisitedNode),
        ("Go To Prev Node",None,c.selectThreadBack),
        ("Go To Next Node",None,c.selectThreadNext),
        ("-",None,None),
        ("Go To Next Marked",None,c.goToNextMarkedHeadline),
        ("Go To Next Changed",None,c.goToNextDirtyHeadline),
        ("Go To Next Clone",None,c.goToNextClone),
        ("-",None,None),
        ("Go To First Node",None,c.goToFirstNode),
        ("Go To Prev Visible",None,c.selectVisBack),
        ("Go To Next Visible",None,c.selectVisNext),
        ("Go To Last Node",None,c.goToLastNode),
        ('Go To Last Visible',None,c.goToLastVisibleNode),
        ("-",None,None),
        ("Go To Parent",None,c.goToParent),
        ('Go To First Sibling',None,c.goToFirstSibling),
        ('Go To Last Sibling',None,c.goToLastSibling),
        ("Go To Prev Sibling",None,c.goToPrevSibling),
        ("Go To Next Sibling",None,c.goToNextSibling),
    ]
#@nonl
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2899:Commands
#@+node:ekr.20031218072017.2900:contractAllHeadlines
def contractAllHeadlines (self):

    c = self
    
    c.beginUpdate()
    try: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    finally:
        c.endUpdate()

    c.expansionLevel = 1 # Reset expansion level.
#@nonl
#@-node:ekr.20031218072017.2900:contractAllHeadlines
#@+node:ekr.20031218072017.2901:contractNode
def contractNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.contract()
    finally:
        c.endUpdate()
#@-node:ekr.20031218072017.2901:contractNode
#@+node:ekr.20040930064232:contractNodeOrGoToParent
def contractNodeOrGoToParent(self):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
 
    if p.hasChildren() and p.isExpanded():
        c.contractNode()
    elif p.hasParent():
        c.goToParent()
#@nonl
#@-node:ekr.20040930064232:contractNodeOrGoToParent
#@+node:ekr.20031218072017.2902:contractParent
def contractParent (self):
    
    c = self ; v = c.currentVnode()
    parent = v.parent()
    if not parent: return
    
    c.beginUpdate()
    try:
        c.selectVnode(parent)
        parent.contract()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2902:contractParent
#@+node:ekr.20031218072017.2903:expandAllHeadlines
def expandAllHeadlines(self):

    c = self ; v = root = c.rootVnode()
    c.beginUpdate()
    try:
        while v:
            c.expandSubtree(v)
            v = v.next()
        c.selectVnode(root)
    finally:
        c.endUpdate()
    c.expansionLevel = 0 # Reset expansion level.
#@nonl
#@-node:ekr.20031218072017.2903:expandAllHeadlines
#@+node:ekr.20031218072017.2904:expandAllSubheads
def expandAllSubheads (self):

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    try:
        c.expandSubtree(v)
        while child:
            c.expandSubtree(child)
            child = child.next()
        c.selectVnode(v)
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2904:expandAllSubheads
#@+node:ekr.20031218072017.2905:expandLevel1..9
def expandLevel1 (self): self.expandToLevel(1)
def expandLevel2 (self): self.expandToLevel(2)
def expandLevel3 (self): self.expandToLevel(3)
def expandLevel4 (self): self.expandToLevel(4)
def expandLevel5 (self): self.expandToLevel(5)
def expandLevel6 (self): self.expandToLevel(6)
def expandLevel7 (self): self.expandToLevel(7)
def expandLevel8 (self): self.expandToLevel(8)
def expandLevel9 (self): self.expandToLevel(9)
#@-node:ekr.20031218072017.2905:expandLevel1..9
#@+node:ekr.20031218072017.2906:expandNextLevel
def expandNextLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(c.expansionLevel + 1)
#@-node:ekr.20031218072017.2906:expandNextLevel
#@+node:ekr.20031218072017.2907:expandNode
def expandNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.expand()
    finally:
        c.endUpdate()

#@-node:ekr.20031218072017.2907:expandNode
#@+node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
def expandNodeAndGoToFirstChild(self):
    
    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        return

    if not p.isExpanded():
        c.expandNode()
        
    c.beginUpdate()
    try:
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        
def expandNodeOrGoToFirstChild(self):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren(): return

    if not p.isExpanded():
        c.expandNode()
    else:
        c.beginUpdate()
        try:
            c.selectVnode(p.firstChild())
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20040930064232.1:expandNodeAnd/OrGoToFirstChild
#@+node:ekr.20031218072017.2908:expandPrevLevel
def expandPrevLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(max(1,c.expansionLevel - 1))
#@-node:ekr.20031218072017.2908:expandPrevLevel
#@-node:ekr.20031218072017.2899:Commands
#@+node:ekr.20031218072017.2909:Utilities
#@+node:ekr.20031218072017.2910:contractSubtree
def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()
#@nonl
#@-node:ekr.20031218072017.2910:contractSubtree
#@+node:ekr.20031218072017.2911:expandSubtree
def expandSubtree (self,v):

    c = self
    last = v.lastNode()
    while v and v != last:
        v.expand()
        v = v.threadNext()
    c.redraw()
#@nonl
#@-node:ekr.20031218072017.2911:expandSubtree
#@+node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    try:
        current = c.currentPosition()
        n = current.level()
        for p in current.self_and_subtree_iter():
            if p.level() - n + 1 < level:
                p.expand()
            else:
                p.contract()
        c.expansionLevel = level
        c.expansionNode = c.currentPosition()
    finally:
        c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2912:expandToLevel (rewritten in 4.4)
#@-node:ekr.20031218072017.2909:Utilities
#@-node:ekr.20031218072017.2898:Expand & Contract...
#@+node:ekr.20031218072017.2913:Goto
#@+node:ekr.20031218072017.1628:goNextVisitedNode
def goNextVisitedNode(self):
    
    c = self

    while c.beadPointer + 1 < len(c.beadList):
        c.beadPointer += 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            c.frame.tree.idle_scrollTo(v)
            return
#@nonl
#@-node:ekr.20031218072017.1628:goNextVisitedNode
#@+node:ekr.20031218072017.1627:goPrevVisitedNode
def goPrevVisitedNode(self):
    
    c = self

    while c.beadPointer > 0:
        c.beadPointer -= 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            c.frame.tree.idle_scrollTo(v)
            return
#@-node:ekr.20031218072017.1627:goPrevVisitedNode
#@+node:ekr.20031218072017.2914:goToFirstNode
def goToFirstNode(self):
    
    c = self
    p = c.rootPosition()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2914:goToFirstNode
#@+node:ekr.20051012092453:goToFirstSibling (New in 4.4)
def goToFirstSibling(self):
    
    c = self ; p = c.currentPosition()
    
    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20051012092453:goToFirstSibling (New in 4.4)
#@+node:ekr.20031218072017.2915:goToLastNode (Bug fix in 4.4)
def goToLastNode(self):
    
    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext(): # Bug fix: 10/12/05: was p.hasNext.
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()

#@-node:ekr.20031218072017.2915:goToLastNode (Bug fix in 4.4)
#@+node:ekr.20051012092847.1:goToLastSibling (New in 4.4)
def goToLastSibling(self):
    
    c = self ; p = c.currentPosition()
    
    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20051012092847.1:goToLastSibling (New in 4.4)
#@+node:ekr.20050711153537:goToLastVisibleNode
def goToLastVisibleNode (self):
    
    c = self ; p = c.rootPosition()
    
    while p.hasNext():
        p.moveToNext()
        
    while p and p.isExpanded():
        p.moveToLastChild()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20050711153537:goToLastVisibleNode
#@+node:ekr.20031218072017.2916:goToNextClone
def goToNextClone(self):

    c = self ; current = c.currentVnode()
    if not current: return
    if not current.isCloned(): return

    v = current.threadNext()
    while v and v.t != current.t:
        v = v.threadNext()
        
    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and v != current and v.t != current.t:
            v = v.threadNext()

    if v:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectVnode(v)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2916:goToNextClone
#@+node:ekr.20031218072017.2917:goToNextDirtyHeadline
def goToNextDirtyHeadline (self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isDirty():
        v = v.threadNext()

    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and not v.isDirty():
            v = v.threadNext()

    if v:
        c.selectVnode(v)
    else:
        g.es("done",color="blue")
#@nonl
#@-node:ekr.20031218072017.2917:goToNextDirtyHeadline
#@+node:ekr.20031218072017.2918:goToNextMarkedHeadline
def goToNextMarkedHeadline(self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isMarked():
        v = v.threadNext()

    if v:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectVnode(v)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")
#@nonl
#@-node:ekr.20031218072017.2918:goToNextMarkedHeadline
#@+node:ekr.20031218072017.2919:goToNextSibling
def goToNextSibling(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    next = v.next()
    if next:
        c.beginUpdate()
        try:
            c.selectVnode(next)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2919:goToNextSibling
#@+node:ekr.20031218072017.2920:goToParent
def goToParent(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    p = v.parent()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()
#@-node:ekr.20031218072017.2920:goToParent
#@+node:ekr.20031218072017.2921:goToPrevSibling
def goToPrevSibling(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    back = v.back()
    if back:
        c.beginUpdate()
        try:
            c.selectVnode(back)
        finally:
            c.endUpdate()
#@nonl
#@-node:ekr.20031218072017.2921:goToPrevSibling
#@-node:ekr.20031218072017.2913:Goto
#@-node:ekr.20051012091323:(Outline goto's)
#@+node:ekr.20051013085834:(Added new emacs find commands & ekr abbreviations)
#@+node:ekr.20031218072017.2887:Find submenu (frame methods)
#@+node:ekr.20051013084200:dismissFindPanel
def dismissFindPanel (self):
    
    c = self
    
    if c.frame.findPanel:
        c.frame.findPanel.dismiss()
#@nonl
#@-node:ekr.20051013084200:dismissFindPanel
#@+node:ekr.20031218072017.2888:showFindPanel
def showFindPanel(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.bringToFront()
#@nonl
#@-node:ekr.20031218072017.2888:showFindPanel
#@+node:ekr.20031218072017.2889:findNext
def findNext(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findNextCommand(c)
#@-node:ekr.20031218072017.2889:findNext
#@+node:ekr.20031218072017.2890:findPrevious
def findPrevious(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findPreviousCommand(c)
#@-node:ekr.20031218072017.2890:findPrevious
#@+node:ekr.20031218072017.2891:replace
def replace(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeCommand(c)
#@-node:ekr.20031218072017.2891:replace
#@+node:ekr.20031218072017.2892:replaceThenFind
def replaceThenFind(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeThenFindCommand(c)
#@-node:ekr.20031218072017.2892:replaceThenFind
#@+node:ekr.20051013083241:replaceAll
def replaceAll(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeAllCommand(c)
#@-node:ekr.20051013083241:replaceAll
#@-node:ekr.20031218072017.2887:Find submenu (frame methods)
#@+node:ekr.20031218072017.3752:defineMenuTables & helpers
def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()
    
    if self.useCmdMenu and c.useMiniBuffer:
        self.defineEditorMenuTables()

    self.defineHelpMenuTables()
#@nonl
#@+node:ekr.20031218072017.3753:defineEditMenuTables & helpers
def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()
#@nonl
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
        ("-",None,None),
        # A Horrible kludge.  The -- indicates we should set menu_shortcut but *not* the bind_shortcut.
        # This is needed so we can distinguish between invokes from the menu (very rare) and others.
        # Important: these shortcuts can be overridden by specifying shortcuts for copy-text, cut-text and paste-text.
        ("Cu&t","--Ctrl+X",f.OnCutFromMenu), 
        ("Cop&y","--Ctrl+C",f.OnCopyFromMenu),
        ("&Paste","--Ctrl+V",f.OnPasteFromMenu),
        ("&Delete",None,c.delete),
        ("Select &All","Ctrl+A",f.body.selectAllText),
        ("-",None,None),
    ]
        
    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20050711091931:defineEditMenuEditCursorTable
def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), # Tk: Del
            ('Delete Left',c.deleteLeftChar), # Tk: Backspace
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), # Tk: Home
            ('End of Line',c.moveToEndOfLine), # Tk: End
            ('Start of Node',c.moveToStartOfNode), # Tk: c-Home
            ('End of Node',c.moveToEndOfNode), # Tk: c-End
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), # Tk: s-Home
            ('Extend To End Of Line',c.extendToEndOfLine), # Tk: s-End
            ('Extend To End of Node',c.extendToEndOfNode), # Tk: s-c-End
            # The mark...
        ]
#@nonl
#@-node:ekr.20050711091931:defineEditMenuEditCursorTable
#@+node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &Section","Shift+Ctrl+E",c.extractSection),
        ("Extract &Names","Shift+Ctrl+N",c.extractSectionNames),
        ("&Extract","Shift+Ctrl+D",c.extract),
        ("-",None,None),
        ("Convert All B&lanks",None,c.convertAllBlanks),
        ("Convert All T&abs",None,c.convertAllTabs),
        ("Convert &Blanks","Shift+Ctrl+B",c.convertBlanks),
        ("Convert &Tabs","Shift+Ctrl+J",c.convertTabs),
        ("Insert Body Time/&Date","Shift+Ctrl+G",c.insertBodyTime),
        ("&Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
        ("-",None,None),
        ("&Indent","Ctrl+]",c.indentBody),
        ("&Unindent","Ctrl+[",c.dedentBody),
        ("&Match Brackets","Ctrl+K",c.findMatchingBracket),
        ("Add Comments",None,c.addComments),
        ("Delete Comments",None,c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u
#@nonl
#@-node:ekr.20031218072017.3754:defineEditMenuEditBodyTable
#@+node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &Headline","Ctrl+H",c.editHeadline),
        ("&End Edit Headline","Escape",f.endEditLabelCommand),
        ("&Abort Edit Headline","Shift+Escape",f.abortEditLabelCommand),
        ("Insert Headline Time/&Date","Shift+Ctrl+H",f.insertHeadlineTime),
        # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
        ("Toggle Angle Brackets",None,c.toggleAngleBrackets),
    ]
#@nonl
#@-node:ekr.20031218072017.3755:defineEditMenuEditHeadlineTable
#@+node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuFindMenuTable = [
        ("&Find Panel","F5",c.showFindPanel),
        ("-",None,None),
        ("Find &Next","F3",c.findNext),
        ("Find &Previous","F4",c.findPrevious),
        ("&Replace","Ctrl+=",c.replace),
        ("Replace, &Then Find","Ctrl+-",c.replaceThenFind),
    ]
#@nonl
#@-node:ekr.20031218072017.3756:defineEditMenuFindMenuTable
#@+node:ekr.20031218072017.3757:defineEditMenuTop2Table
def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&visibles","Show In&visibles")
        
    self.editMenuTop2Table = [
        ("&Go To Line Number","Alt+G",c.goToLineNumber),
        ("&Execute Script","Alt+Shift+E",c.executeScript),
        # ("Set Fon&t...",None,c.fontPanel), # To be replaced by general settings dialog.
        # ("Set &Colors...",None,c.colorPanel), # To be replaced by general settings dialog.
        (label,"Alt+V",c.viewAllCharacters),
        # ("-",None,None),
        ("Setti&ngs",None,c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.3757:defineEditMenuTop2Table
#@-node:ekr.20031218072017.3753:defineEditMenuTables & helpers
#@+node:ekr.20031218072017.3758:defineFileMenuTables & helpers
def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()
#@nonl
#@+node:ekr.20031218072017.3759:defineFileMenuTopTable
def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&New","Ctrl+N",c.new),
        ("&Open...","Ctrl+O",c.open),
    ]
#@nonl
#@-node:ekr.20031218072017.3759:defineFileMenuTopTable
#@+node:ekr.20031218072017.3760:defineFileMenuTop2Table
def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None,None),
        ("&Close","Ctrl+W",c.close),
        ("&Save","Ctrl+S",c.save),
        ("Save &As","Shift+Ctrl+S",c.saveAs),
        ("Save To",None,c.saveTo), # &Tangle
        ("Re&vert To Saved",None,c.revert), # &Read/Write
    ]
#@nonl
#@-node:ekr.20031218072017.3760:defineFileMenuTop2Table
#@+node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuReadWriteMenuTable = [
        ("&Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
        ("Read @file &Nodes",None,c.readAtFileNodes),
        ("-",None,None),
        ("Write &Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
        ("Write &Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
        ("Write &Outline Only",None,c.fileCommands.writeOutlineOnly),
        ("&Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes),
    ]
#@nonl
#@-node:ekr.20031218072017.3761:defineFileMenuReadWriteMenuTable
#@+node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &All","Shift+Ctrl+A",c.tangleAll),
        ("Tangle &Marked","Shift+Ctrl+M",c.tangleMarked),
        ("&Tangle","Shift+Ctrl+T",c.tangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3762:defineFileMenuTangleMenuTable
#@+node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &All",None,c.untangleAll),
        ("Untangle &Marked",None,c.untangleMarked),
        ("&Untangle","Shift+Ctrl+U",c.untangle),
    ]
#@nonl
#@-node:ekr.20031218072017.3763:defineFileMenuUntangleMenuTable
#@+node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",None,c.importDerivedFile),
        ("Import To @&file","Shift+Ctrl+F",c.importAtFile),
        ("Import To @&root",None,c.importAtRoot),
        ("Import &CWEB Files",None,c.importCWEBFiles),
        
        ("Import &noweb Files",None,c.importNowebFiles),
        ("Import Flattened &Outline",None,c.importFlattenedOutline),
    ]
#@nonl
#@-node:ekr.20031218072017.3764:defineFileMenuImportMenuTable
#@+node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &Headlines",None,c.exportHeadlines),
        ("Outline To &CWEB",None,c.outlineToCWEB),
        ("Outline To &Noweb",None,c.outlineToNoweb),
        ("&Flatten Outline",None,c.flattenOutline),
        ("&Remove Sentinels",None,c.removeSentinels),
        ("&Weave",None,c.weave),
    ]
#@nonl
#@-node:ekr.20031218072017.3765:defineFileMenuExportMenuTable
#@+node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&xit","Ctrl+Q",g.app.onQuit),
    ]
#@nonl
#@-node:ekr.20031218072017.3766:defineFileMenuTop3MenuTable
#@-node:ekr.20031218072017.3758:defineFileMenuTables & helpers
#@+node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()
#@nonl
#@+node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&ut Node","Shift+Ctrl+X",c.cutOutline),
        ("C&opy Node","Shift+Ctrl+C",c.copyOutline),
        ("&Paste Node","Shift+Ctrl+V",c.pasteOutline),
        ("Pas&te Node As Clone",None,c.pasteOutlineRetainingClones),
        ("&Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
        ("-",None,None),
        ("&Insert Node","Ctrl+I",c.insertHeadline),
        ("&Clone Node","Ctrl+`",c.clone),
        ("Sort Childre&n",None,c.sortChildren), # Conflicted with Hoist.
        ("&Sort Siblings","Alt+A",c.sortSiblings),
        ("-",None,None),
        ("&Hoist",None,c.hoist),
        ("D&e-Hoist",None,f.c.dehoist),
        ("-",None,None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x
#@nonl
#@-node:ekr.20031218072017.3768:defineOutlineMenuTopMenuTable
#@+node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &Outline",None,c.checkOutline),
        ("&Dump Outline",None,c.dumpOutline),
        ("-",None,None),
        ("Check &All Python Code",None,c.checkAllPythonCode),
        ("&Check Python &Code",None,c.checkPythonCode),
        ("-",None,None),
        ("Pretty P&rint All Python Code",None,c.prettyPrintAllPythonCode),
        ("&Pretty Print Python Code",None,c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r
#@nonl
#@-node:ekr.20040711140738:defineOutlineMenuCheckOutlineMenuTable
#@+node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&Contract All","Alt+-",c.contractAllHeadlines),
        ("Contract &Node","Alt+[",c.contractNode),
        ("Contract &Parent","Alt+0",c.contractParent),
        ("Contract Or Go Left",None,c.contractNodeOrGoToParent),
        ("-",None,None),
        ("Expand P&rev Level","Alt+.",c.expandPrevLevel),
        ("Expand N&ext Level","Alt+=",c.expandNextLevel),
        ("Expand And Go Right",None,c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",None,c.expandNodeOrGoToFirstChild),
        ("-",None,None),
        ("Expand To Level &1","Alt+1",c.expandLevel1),
        ("Expand To Level &2","Alt+2",c.expandLevel2),
        ("Expand To Level &3","Alt+3",c.expandLevel3),
        ("Expand To Level &4","Alt+4",c.expandLevel4),
        ("Expand To Level &5","Alt+5",c.expandLevel5),
        ("Expand To Level &6","Alt+6",c.expandLevel6),
        ("Expand To Level &7","Alt+7",c.expandLevel7),
        ("Expand To Level &8","Alt+8",c.expandLevel8),
        # ("Expand To Level &9","Alt+9",c.expandLevel9),
        ("-",None,None),
        ("Expand &All","Alt+9",c.expandAllHeadlines),
        ("Expand N&ode","Alt+]",c.expandNode),
    ]
#@nonl
#@-node:ekr.20031218072017.3769:defineOutlineMenuExpandContractMenuTable
#@+node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &Down", "Ctrl+D",c.moveOutlineDown),
        ("Move &Left", "Ctrl+L",c.moveOutlineLeft),
        ("Move &Right","Ctrl+R",c.moveOutlineRight),
        ("Move &Up",   "Ctrl+U",c.moveOutlineUp),
        ("-",None,None),
        ("&Promote","Ctrl+{",c.promote),
        ("&Demote", "Ctrl+}",c.demote),
    ]
#@nonl
#@-node:ekr.20031218072017.3770:defineOutlineMenuMoveMenuTable
#@+node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&Mark","Ctrl+M",c.markHeadline),
        ("Mark &Subheads","Alt+S",c.markSubheads),
        ("Mark Changed &Items","Alt+C",c.markChangedHeadlines),
        ("Mark Changed &Roots","Alt+R",c.markChangedRoots),
        ("Mark &Clones","Alt+K",c.markClones),
        ("&Unmark All","Alt+U",c.unmarkAll),
    ]
#@nonl
#@-node:ekr.20031218072017.3771:defineOutlineMenuMarkMenuTable
#@+node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",None,c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",None,c.goNextVisitedNode),
        ("Go To Prev Node",None,c.selectThreadBack),
        ("Go To Next Node",None,c.selectThreadNext),
        ("-",None,None),
        ("Go To Next Marked",None,c.goToNextMarkedHeadline),
        ("Go To Next Changed",None,c.goToNextDirtyHeadline),
        ("Go To Next Clone",None,c.goToNextClone),
        ("-",None,None),
        ("Go To First Node",None,c.goToFirstNode),
        ("Go To Prev Visible",None,c.selectVisBack),
        ("Go To Next Visible",None,c.selectVisNext),
        ("Go To Last Node",None,c.goToLastNode),
        ('Go To Last Visible',None,c.goToLastVisibleNode),
        ("-",None,None),
        ("Go To Parent",None,c.goToParent),
        ('Go To First Sibling',None,c.goToFirstSibling),
        ('Go To Last Sibling',None,c.goToLastSibling),
        ("Go To Prev Sibling",None,c.goToPrevSibling),
        ("Go To Next Sibling",None,c.goToNextSibling),
    ]
#@nonl
#@-node:ekr.20031218072017.3772:defineOutlineMenuGoToMenuTable
#@-node:ekr.20031218072017.3767:defineOutlineMenuTables & helpers
#@+node:ekr.20050921103230:defineEditorMenuTables
def defineEditorMenuTables (self):
    
    def dummyCommand():
        pass
    
    self.emacsMenuCommandsMenuTable = [
        ('Cmnd Command 1',None,dummyCommand),
    ]
    
    self.emacsMenuToolsMenuTable = [
        ('Tools Command 1',None,dummyCommand),
    ]

    self.emacsMenuOptionsMenuTable = [
        ('Options Command 1',None,dummyCommand),
    ]

    self.emacsMenuBuffersMenuTable = [
        ('Buffers Command 1',None,dummyCommand),
    ]
#@nonl
#@-node:ekr.20050921103230:defineEditorMenuTables
#@+node:ekr.20031218072017.3773:defineWindowMenuTables
def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&Equal Sized Panes","Ctrl+E",f.equalSizedPanes),
        ("Toggle &Active Pane","Ctrl+T",f.toggleActivePane),
        ("Toggle &Split Direction",None,f.toggleSplitDirection),
        ("-",None,None),
        ("Resize To Screen",None,f.resizeToScreen),
        ("Casca&de",None,f.cascade),
        ("&Minimize All",None,f.minimizeAll),
        ("-",None,None),
        ("Open &Compare Window",None,c.openCompareWindow),
        ("Open &Python Window","Alt+P",c.openPythonWindow),
    ]
#@nonl
#@-node:ekr.20031218072017.3773:defineWindowMenuTables
#@+node:ekr.20031218072017.3774:defineHelpMenuTables
def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&About Leo...",None,c.about),
        ("Online &Home Page",None,c.leoHome),
        ("Open Online &Tutorial",None,c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &Offline Tutorial",None,f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&Docs.leo",None,c.leoDocumentation),
        ("Open Leo&Plugins.leo",None,c.openLeoPlugins),
        ("Open Leo&Settings.leo",None,c.openLeoSettings),
    ]
#@nonl
#@-node:ekr.20031218072017.3774:defineHelpMenuTables
#@-node:ekr.20031218072017.3752:defineMenuTables & helpers
#@-node:ekr.20051013085834:(Added new emacs find commands & ekr abbreviations)
#@+node:ekr.20051013103457:(bindings)
#@+node:ekr.20050920085536.12:<< define dict d of abbreviations >>
d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}
#@nonl
#@-node:ekr.20050920085536.12:<< define dict d of abbreviations >>
#@+node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    #'check-spelling':      None,                   # Create this command.
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    # Leo find panel stuff.  It's not clear what will happen to these.
    'dismiss-leo-find-panel':   c.dismissFindPanel,
    'leo-change':               c.replace,
    'leo-change-then-find':     c.replaceThenFind,
    'leo-change-all':           c.replaceAll,
    'leo-find':                 c.findNext,
    'leo-find-panel':           c.showFindPanel,
    'leo-find-previous':        c.findPrevious,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}
#@nonl
#@-node:ekr.20050920084036.189:<< define dictionary d of names and Leo commands >>
#@+node:ekr.20051006125633:Binding (keyHandler)
#@+node:ekr.20050920085536.11:add_ekr_altx_commands
def add_ekr_altx_commands (self):

    << define dict d of abbreviations >>

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            
#@nonl
#@+node:ekr.20050920085536.12:<< define dict d of abbreviations >>
d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}
#@nonl
#@-node:ekr.20050920085536.12:<< define dict d of abbreviations >>
#@-node:ekr.20050920085536.11:add_ekr_altx_commands
#@+node:ekr.20050920085536.16:bindKey
def bindKey (self,w,shortcut,callback,commandName,fromMenu=False,tag=''):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''

    k = self ; c = k.c

    # Check for duplicates: override or ignore default (menu) bindings.
    b = k.bindingsDict.get(shortcut)
    if b and not b.fromMenu:
        # We are trying to override a non-default (non-menu) binding.
        if b.name != commandName and not b.warningGiven: ### and not fromMenu:
            # Warning about a non-default binding
            b.warningGiven = True
            g.es_print('bindKey: ignoring %s = %s. Keeping binding to %s' % (
                shortcut, commandName, b.name))
        return b.name == commandName

    # g.trace(tag,'%25s' % (shortcut),commandName)

    try:
        # The original way.  Essential to make cut/copy/paste work.
        if shortcut == '<Key>':
            w.bind(shortcut,callback,'+')
            # Don't bind to menu.  Besides, menu.bind doesn't allow '+' arg.
        else:
            w.bind(shortcut,callback)
            # Binding to the menu ensures that keys are active in all parts of the frame.
            c.frame.menu.bind(shortcut,callback)
        << other ways that don't work >>
        k.bindingsDict [shortcut] = g.bunch(
            func = callback, name = commandName,
            warningGiven = False, fromMenu = fromMenu)
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding for %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGive = True
        return False
#@nonl
#@+node:ekr.20051010065140:<< other ways that don't work >>
if 0: # None of these are satisfactory.

    if 0: # Too restrictive, but might be useful later.
        w.bind(shortcut,callback)
    elif 0: # This prevents all insertions into body text!
        # This *might* work, but seems to be flaky.
        # Bind the key to *all* text widgets.
        c.frame.top.bind_class('Text',shortcut,callback)
    elif 0:
        # Doesn't work at all.
        c.frame.outerFrame.bind(shortcut,callback)
    elif 0:
        # A compromise.  This *almost* works, but cut/copy/paste may need help...
        for w in (c.frame.body.bodyCtrl,c.frame.canvas,c.frame.log.logCtrl):
            w.bind(shortcut,callback)
    else:
        # Make binding available everywhere.
        # This causes problems with tabs, cut/copy/paste (!!)
        c.frame.top.bind(shortcut,callback)
#@nonl
#@-node:ekr.20051010065140:<< other ways that don't work >>
#@-node:ekr.20050920085536.16:bindKey
#@+node:ekr.20051008135051.1:bindOpenWith
def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ; w = c.frame.body.bodyCtrl
    
    # g.trace(shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey(w,shortcut,keyCallback,name,tag='bindOpenWith')
#@nonl
#@-node:ekr.20051008135051.1:bindOpenWith
#@+node:ekr.20051006125633.1:bindShortcut
def bindShortcut (self,shortcut,name,command,openWith,fromMenu=False):
    
    '''Bind one shortcut from a menu table.'''
    
    __pychecker__ = '--no-argsused'
        # The pychecker warning about 'name' being unused is WRONG.
    
    k = self ; c = k.c ; w = c.frame.body.bodyCtrl
    
    shortcut = str(shortcut)
    
    if openWith:
        k.bindOpenWith(shortcut,name,command)
        return True

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by this particular leoCallback function.
        func = k.leoCallbackDict.get(command)
        name = func.__name__
        # g.trace('%25s (leo) %s' % (shortcut,name))
        
        # No need for a second layer of callback.
        def keyCallback (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
    else:
        # Important: the name just needs to be unique for every function.
        name = command.__name__
        # g.trace('%25s %s' % (shortcut,name))

        def menuFuncCallback (event,command=command,name=name):
            # g.trace(name)
            return command(event)

        def keyCallback (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
        
    return k.bindKey(w,shortcut,keyCallback,name,fromMenu,tag='bindShortcut')
#@nonl
#@-node:ekr.20051006125633.1:bindShortcut
#@+node:ekr.20051011103654:checkBindings
def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        if abbrev:
            name = abbrev
        # This logic is from c.config.getShortcut
        key = c.frame.menu.canonicalizeMenuName(name)
        key = key.replace('&','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut in any @shortcuts node for abbrev %s -> %s' % (
                    abbrev,name))
            else:
                g.trace('No shortcut in any @shortcuts node for %s' % name)
#@nonl
#@-node:ekr.20051011103654:checkBindings
#@+node:ekr.20051007080058:makeAllBindings
def makeAllBindings (self):
    
    k = self ; c = k.c
    
    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings() # These take precedence.
    k.setBindingsFromCommandsDict()
    k.add_ekr_altx_commands()
    k.checkBindings()
#@nonl
#@-node:ekr.20051007080058:makeAllBindings
#@+node:ekr.20050923174229.1:makeHardBindings
def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '<Alt-c>': c.editCommands.changePreviousWord,
        '<Alt-u>': c.editCommands.changePreviousWord,
        '<Alt-l>': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '<Control-s>':      (2, c.searchCommands.startIncremental),
        '<Control-r>':      (2, c.searchCommands.startIncremental),
        '<Alt-g>':          (1, c.editCommands.gotoLine),
        '<Alt-z>':          (1, c.killBufferCommands.zapToCharacter),
        '<Alt-percent>':    (1, c.queryReplaceCommands.queryReplace),
        '<Control-Alt-w>':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
    
    self.rCommandDict = {
        'space':    c.registerCommands.pointToRegister,
        'a':        c.registerCommands.appendToRegister,
        'i':        c.registerCommands.insertRegister,
        'j':        c.registerCommands.jumpToRegister,
        'n':        c.registerCommands.numberToRegister,
        'p':        c.registerCommands.prependToRegister,
        'r':        c.rectangleCommands.enterRectangleState,
        's':        c.registerCommands.copyToRegister,
        'v':        c.registerCommands.viewRegister,
        'plus':     c.registerCommands.incrementRegister,
    }
    
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }
    
    self.xcommands = {
        '<Control-t>':  c.editCommands.transposeLines,
        '<Control-u>':  c.editCommands.upCaseRegion,
        '<Control-l>':  c.editCommands.downCaseRegion,
        '<Control-o>':  c.editCommands.removeBlankLines,
        '<Control-i>':  c.editFileCommands.insertFile,
        '<Control-s>':  c.editFileCommands.saveFile,
        '<Control-x>':  c.editCommands.exchangePointMark,
        '<Control-c>':  c.controlCommands.shutdown,
        '<Control-b>':  c.bufferCommands.listBuffers,
        '<Control-Shift-at>': lambda event: event.widget.selection_clear(),
        '<Delete>':     c.killBufferCommands.backwardKillSentence,
    }
#@nonl
#@-node:ekr.20050923174229.1:makeHardBindings
#@+node:ekr.20051008152134:makeSpecialBindings (Binds to 'Key')
def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; w = c.frame.body.bodyCtrl ; tag = 'makeSpecialBindings'
    
    for stroke,ivar,name,func in (
		# These defaults may be overridden.
        ('Ctrl-g',  'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('Atl-x',   'fullCommandKey',  'full-command',  k.fullCommand),
        ('Ctrl-u',  'universalArgKey', 'universal-arg', k.universalArgument),
        ('Ctrl-c',  'quickCommandKey', 'quick-command', k.quickCommand),
    ):
        
        # Use two-levels of callbacks.
        def specialCallback (event,func=func):
            return func(event)

        def keyCallback (event,func=specialCallback,stroke=stroke):
            return k.masterCommand(event,func,stroke)
        
        # Allow the user to override.
        junk, accel = c.config.getShortcut(name)
        if not accel: accel = stroke
        shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
        k.bindKey(w,shortcut,keyCallback,func.__name__,tag)
        setattr(k,ivar,shortcut)
        # g.trace(shortcut,func.__name__)
        
    # Add a binding for <Key> events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='<Key>')
            
    k.bindKey(w,'<Key>',allKeysCallback,'masterCommand',tag=tag)
#@nonl
#@-node:ekr.20051008152134:makeSpecialBindings (Binds to 'Key')
#@+node:ekr.20051012201831:printBindings
def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    keys = k.bindingsDict.keys() ; keys.sort()

    for key in keys:
        b = k.bindingsDict.get(key)
        print key, b.name
#@nonl
#@-node:ekr.20051012201831:printBindings
#@+node:ekr.20051008134059:setBindingsFromCommandsDict
def setBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.
    
    These bindings may also be specied later by menu code,
    but bindShortcut and bindKey ignore equivalent bindings.
    '''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for name in keys:
        command = c.commandsDict.get(name)
        
        key, accel = c.config.getShortcut(name)
        if accel:
            bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
            k.bindShortcut(bind_shortcut,name,command,openWith=name=='open-with')
        else:
            bind_shortcut = None
        
        # g.trace('%25s %s' % (name,bind_shortcut))
#@nonl
#@-node:ekr.20051008134059:setBindingsFromCommandsDict
#@-node:ekr.20051006125633:Binding (keyHandler)
#@-node:ekr.20051013103457:(bindings)
#@-node:ekr.20051006122237:(Recent)
#@+node:ekr.20051012084345:Bugs
#@+node:ekr.20051013103838:(Escape does not end label editing)
#@+node:ekr.20050120092028.1:set_focus (tkFrame)
@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False,tag=''):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''
    
    __pychecker__ = '--no-argsused' # tag good for debugging.

    c = self.c
    # g.trace(tag) # c.shortFileName())

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget,
                        tag='frame.setFocus')
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(tag,c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                # New in 4.4: set the delay to 1 msec.: the smaller the better.
                self.outerFrame.after(1,setFocusCallback)
        else:
            # g.trace(tag,c.shortFileName())
            g.app.gui.set_focus(c,widget,tag='frame.setFocus')
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None
#@nonl
#@-node:ekr.20050120092028.1:set_focus (tkFrame)
#@+node:ekr.20040803072955.135:setNormalLabelState
def setNormalLabelState (self,p): # selected, editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 
    
    if p and p.edit_text():
        self.setEditHeadlineColors(p)
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        # Set the focus immediately
        self.frame.treeWantsFocus(p.edit_text(),later=False,tag='tree:setNormalLabelState')
#@nonl
#@-node:ekr.20040803072955.135:setNormalLabelState
#@+node:ekr.20040803072955.126:endEditLabel
def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; frame = c.frame
    
    p = self.editPosition()

    if p and p.edit_text():
        if 0: # New in recycled widgets scheme: this could cause a race condition.
            # This will be done in the redraw code becaused editPosition will be None.
            self.setUnselectedLabelState(p)

        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    frame.bodyWantsFocus(frame.bodyCtrl,tag='body:endEditLabel')
#@nonl
#@-node:ekr.20040803072955.126:endEditLabel
#@+node:ekr.20031218072017.3982:endEditLabelCommand
def endEditLabelCommand (self):

    frame = self ; c = frame.c ; tree = frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
        return
        
    if 1: # New code in 4.4a1.
        tree.endEditLabel()
        tree.select(tree.editPosition())
    else:
        v = frame.tree.editPosition()
        # g.trace(v)
        if v and v.edit_text():
            tree.select(v)
        if v: # Bug fix 10/9/02: also redraw ancestor headlines.
            tree.force_redraw() # force a redraw of joined headlines.

    frame.bodyWantsFocus(frame.bodyCtrl,tag='body:endEditLabelCommand')
#@nonl
#@-node:ekr.20031218072017.3982:endEditLabelCommand
#@+node:ekr.20031218072017.3981:abortEditLabelCommand
def abortEditLabelCommand (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode() ; tree = frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return

    if self.revertHeadline and v.edit_text() and v == tree.editPosition():
    
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("end",self.revertHeadline)
        tree.idle_head_key(v) # Must be done immediately.
        tree.revertHeadline = None
        if 1: # New code in 4.4a1.
            tree.endEditLabel()
            tree.select(tree.editPosition())
        else: # Old code:
            tree.select(v)
            if v and len(v.t.vnodeList) > 0:
                tree.force_redraw() # force a redraw of joined headlines.
#@nonl
#@-node:ekr.20031218072017.3981:abortEditLabelCommand
#@-node:ekr.20051013103838:(Escape does not end label editing)
#@+node:ekr.20051012075322:Fix bug: @settings not honored in opened outline
#@+node:ekr.20051010152921:Report
@nocolor
http://sourceforge.net/forum/message.php?msg_id=3376527
By: vpe

My first complaint is the same as in this earlier post:
http://sourceforge.net/forum/message.php?msg_id=3331283
If leo file has @settings in it, these settings are not applied when I open
the file from another outline, that is from File->Recent Files or File->Open
or Help->Leo Docs etc. They are applied when I open the file directly by double
clicking.

Also, when leo files are opened from another outline, the log window has no
messages about leoID, global config dir, home dir, reading settings, # plugins
loaded.

Possible reason:

I have leo files associated with "path\pythonw.exe" "path\leo.py" "%1". Each
time I open a leo file directly, a new pythonw.exe process is started. But,
when I open files from an outline, no new pythonw.exe is started. This does
not make much sense to me. It's not an MDI editor. It's also safer to have separate
processes--if one outline crashes, others will survive.

Leo 4.3.3, build  1.282 , Python 2.4.2, Tk 8.4.7, win2k
#@nonl
#@-node:ekr.20051010152921:Report
#@-node:ekr.20051012075322:Fix bug: @settings not honored in opened outline
#@+node:ekr.20051012101954:Crash in Open Compare Window
exception executing command
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 236, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 4856, in openCompareWindow
    frame.comparePanel = g.app.gui.createComparePanel(c)

  File "c:\prog\leoCVS\leo\src\leoTkinterGui.py", line 254, in createComparePanel
    return leoTkinterComparePanel.leoTkinterComparePanel(c)

  File "c:\prog\leoCVS\leo\src\leoTkinterComparePanel.py", line 41, in __init__
    self.useOutputFileVar = Tk.IntVar()

  File "c:\python24\lib\lib-tk\Tkinter.py", line 244, in __init__
    Variable.__init__(self, master)

  File "c:\python24\lib\lib-tk\Tkinter.py", line 179, in __init__
    self._tk = master.tk

AttributeError: 'NoneType' object has no attribute 'tk'

Exception exceptions.AttributeError: "IntVar instance has no attribute '_tk'" in <bound method IntVar.__del__ of <Tkinte
r.IntVar instance at 0x0171B800>> ignored
#@-node:ekr.20051012101954:Crash in Open Compare Window
#@+node:ekr.20051012082219:Crash in backwardParagraph
TclError Exception in Tk callback
  Function: <function keyCallback at 0x017923B0> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x026A9E18>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "c:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 792, in keyCallback
    return k.masterCommand(event,func,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1050, in masterCommand
    func(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 789, in menuFuncCallback
    return command(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 1979, in backwardParagraph
    w.mark_set('insert',i) ; w.see('insert')
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2932, in mark_set
    self.tk.call(self._w, 'mark', 'set', markName, index)
TclError: bad text index " +1c"

================================================
  Event contents:
    char: {
    delta: 219
    height: ??
    keycode: 219
    keysym: braceleft
    keysym_num: 123
    num: ??
    serial: 4627
    state: 131073
    time: 11194296
    type: 2
    widget: .19812560.24607680.24608040.24608160.body
    width: ??
    x: 656
    x_root: 873
    y: 37
    y_root: 487

TclError Exception in Tk callback
  Function: <function keyCallback at 0x017923B0> (type: <type 'function'>)
  Args: (<Tkinter.Event instance at 0x026B2648>,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "c:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 792, in keyCallback
    return k.masterCommand(event,func,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1050, in masterCommand
    func(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 789, in menuFuncCallback
    return command(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 1979, in backwardParagraph
    w.mark_set('insert',i) ; w.see('insert')
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2932, in mark_set
    self.tk.call(self._w, 'mark', 'set', markName, index)
TclError: bad text index " +1c"

================================================
  Event contents:
    char: {
    delta: 219
    height: ??
    keycode: 219
    keysym: braceleft
    keysym_num: 123
    num: ??
    serial: 4627
    state: 131073
    time: 11194296
    type: 2
    widget: .19812560.24607680.24608040.24608160.body
    width: ??
    x: 656
    x_root: 873
    y: 37
    y_root: 487

#@-node:ekr.20051012082219:Crash in backwardParagraph
#@+node:ekr.20051012101104:Fix bug: menu defaults don't 'take' if there is no @shortcuts node in effect.
#@-node:ekr.20051012101104:Fix bug: menu defaults don't 'take' if there is no @shortcuts node in effect.
#@+node:ekr.20051010130212:Crash in unit test
createMenuEntries: no inverse for launchCmd
createMenuEntries: no inverse for launchExplorer
createMenuEntries: no inverse for <lambda>
createMenuEntries: no inverse for parameterize
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoGlobals.py", line 2349, in doHook
    return f(tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 88, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 69, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 47, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\leoCVS\leo\plugins\rst2.py", line 248, in onFileOpen
    transform_rst2_text_in_subtree(c)

  File "C:\prog\leoCVS\leo\plugins\rst2.py", line 239, in transform_rst2_text_in_subtree
    c.frame.menu.createMenuEntries(editMenu, newEntries)

  File "C:\prog\leoCVS\leo\src\leoMenu.py", line 1022, in createMenuEntries
    emacs_name = k.inverseCommandsDict.get(command.__name__)

AttributeError: 'callOnFileOpen' object has no attribute '__name__'
#@nonl
#@+node:ekr.20031218072017.1723:menu.createMenuEntries (does bindings)
def createMenuEntries (self,menu,table,
    openWith=False,dontBind=False,
    init=False,dynamicMenu=False):
    
    c = self.c ; k = c.keyHandler
    
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            << clear useBindShortcut and adjust accel if accel startswith '--' >>
            << set name to the label for doCommand >>
            << set accel to the shortcut for name >>
            << set bind_shortcut and menu_shortcut using accel >>
            << define callback function >>
            << set realLabel, amp_index and menu_shortcut >>
            
            if bind_shortcut and useBindShortcut and not dontBind:
                ok = c.keyHandler.bindShortcut(bind_shortcut,name,command,openWith,fromMenu=True)
                if not ok: menu_shortcut = None

            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=menuCallback,underline=amp_index)
#@+node:ekr.20051011071542:<< clear useBindShortcut and adjust accel if accel startswith '--' >>
if accel and accel.startswith('--'):
    useBindShortcut = False
    accel = accel[2:]
else:
    useBindShortcut = True
#@nonl
#@-node:ekr.20051011071542:<< clear useBindShortcut and adjust accel if accel startswith '--' >>
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
# First, check the kludged cut/copy/paste commands.
if not useBindShortcut:
    cutCopyPasteDict = {
        'Ctrl+X': 'cut-text',
        'Ctrl+C': 'copy-text',
        'Ctrl+V': 'paste-text',
    }
    name = cutCopyPasteDict.get(accel)
    # Allow the user to override the shortcut using equivalent emacs name.
    rawKey,accel2 = c.config.getShortcut(name)
    # g.trace(accel,accel2,name,command.__name__)
    if not accel2:
        accel2 = 'none' # Do not allow any further overrides.
else:
    # Second, try to get the old-style name.
    rawKey,accel2 = c.config.getShortcut(name)
    
# if not openWith: g.trace(accel,accel2,name)

# New in 4.4: allow emacs-style or old style names in menu shortcuts.
if openWith:
    pass
elif not accel2:
    if c.useMiniBuffer:
        try: # User errors in the call can cause this.
            commandName = command.__name__
        except Exception:
            commandName = None
        emacs_name = k.inverseCommandsDict.get(commandName)
        if emacs_name:
            rawKey,accel2 = c.config.getShortcut(emacs_name)
            accel = accel2 # Override the default shortcut.
            # if accel: g.trace('%30s = %30s: %s' % (name,emacs_name,repr(accel)))
        else:
            accel = None # New in 4.4: remove the default shortcut.
            if init and not dynamicMenu: # Don't require command names for dynamic menu entries.
                if commandName and commandName != 'dummyCommand':
                    g.trace('no inverse for %s' % commandName)
    else:
        pass # Use the default shortcut.
elif accel2 and accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
    
# if not openWith: g.trace(accel,accel2,name)
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
        bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
    menuCallback = self.defineOpenWithMenuCallback(command)
else:
    menuCallback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&")
if amp_index == -1:
    amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@-node:ekr.20031218072017.1723:menu.createMenuEntries (does bindings)
#@-node:ekr.20051010130212:Crash in unit test
#@+node:ekr.20051012210958:Fixed
#@+node:ekr.20051011071542.1:(Cut/Copy/Paste bindings)
#@+node:ekr.20031218072017.839:defineEditMenuTopTable
def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo","Ctrl+Z",c.undoer.undo), # &U reserved for Undo
        ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &R reserved for Redo
        ("-",None,None),
        # A Horrible kludge.  The -- indicates we should set menu_shortcut but *not* the bind_shortcut.
        # This is needed so we can distinguish between invokes from the menu (very rare) and others.
        # Important: these shortcuts can be overridden by specifying shortcuts for copy-text, cut-text and paste-text.
        ("Cu&t","--Ctrl+X",f.OnCutFromMenu), 
        ("Cop&y","--Ctrl+C",f.OnCopyFromMenu),
        ("&Paste","--Ctrl+V",f.OnPasteFromMenu),
        ("&Delete",None,c.delete),
        ("Select &All","Ctrl+A",f.body.selectAllText),
        ("-",None,None),
    ]
        
    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v
#@nonl
#@-node:ekr.20031218072017.839:defineEditMenuTopTable
#@+node:ekr.20031218072017.1723:menu.createMenuEntries (does bindings)
def createMenuEntries (self,menu,table,
    openWith=False,dontBind=False,
    init=False,dynamicMenu=False):
    
    c = self.c ; k = c.keyHandler
    
    for label,accel,command in table:
        if label == None or command == None or label == "-":
            self.add_separator(menu)
        else:
            << clear useBindShortcut and adjust accel if accel startswith '--' >>
            << set name to the label for doCommand >>
            << set accel to the shortcut for name >>
            << set bind_shortcut and menu_shortcut using accel >>
            << define callback function >>
            << set realLabel, amp_index and menu_shortcut >>
            
            if bind_shortcut and useBindShortcut and not dontBind:
                ok = c.keyHandler.bindShortcut(bind_shortcut,name,command,openWith,fromMenu=True)
                if not ok: menu_shortcut = None

            self.add_command(menu,label=realLabel,accelerator=menu_shortcut,
                command=menuCallback,underline=amp_index)
#@+node:ekr.20051011071542:<< clear useBindShortcut and adjust accel if accel startswith '--' >>
if accel and accel.startswith('--'):
    useBindShortcut = False
    accel = accel[2:]
else:
    useBindShortcut = True
#@nonl
#@-node:ekr.20051011071542:<< clear useBindShortcut and adjust accel if accel startswith '--' >>
#@+node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
name = label.strip().lower()

# Remove special characters from command names.
name2 = ""
for ch in name:
    if ch in string.ascii_letters or ch in string.digits:
        name2 = name2 + ch
name = name2
#@-node:ekr.20031218072017.1724:<< set name to the label for doCommand >>
#@+node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
# First, check the kludged cut/copy/paste commands.
if not useBindShortcut:
    cutCopyPasteDict = {
        'Ctrl+X': 'cut-text',
        'Ctrl+C': 'copy-text',
        'Ctrl+V': 'paste-text',
    }
    name = cutCopyPasteDict.get(accel)
    # Allow the user to override the shortcut using equivalent emacs name.
    rawKey,accel2 = c.config.getShortcut(name)
    # g.trace(accel,accel2,name,command.__name__)
    if not accel2:
        accel2 = 'none' # Do not allow any further overrides.
else:
    # Second, try to get the old-style name.
    rawKey,accel2 = c.config.getShortcut(name)
    
# if not openWith: g.trace(accel,accel2,name)

# New in 4.4: allow emacs-style or old style names in menu shortcuts.
if openWith:
    pass
elif not accel2:
    if c.useMiniBuffer:
        try: # User errors in the call can cause this.
            commandName = command.__name__
        except Exception:
            commandName = None
        emacs_name = k.inverseCommandsDict.get(commandName)
        if emacs_name:
            rawKey,accel2 = c.config.getShortcut(emacs_name)
            accel = accel2 # Override the default shortcut.
            # if accel: g.trace('%30s = %30s: %s' % (name,emacs_name,repr(accel)))
        else:
            accel = None # New in 4.4: remove the default shortcut.
            if init and not dynamicMenu: # Don't require command names for dynamic menu entries.
                if commandName and commandName != 'dummyCommand':
                    g.trace('no inverse for %s' % commandName)
    else:
        pass # Use the default shortcut.
elif accel2 and accel2.lower() == "none":
    accel = None # Remove the default shortcut.
else:
    accel = accel2 # Override the default shortcut.
    
# if not openWith: g.trace(accel,accel2,name)
#@nonl
#@-node:ekr.20031218072017.1725:<< set accel to the shortcut for name >>
#@+node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
bind_shortcut,menu_shortcut = self.canonicalizeShortcut(accel)

# Kludge: disable the shortcuts for cut, copy, paste.
# This has already been bound in leoTkinterFrame.__init__
# 2/13/03: A _possible_ fix for the Linux control-v bug.

if sys.platform not in ("darwin","freebsd4","freebsd5","linux1","linux2"):
    if bind_shortcut in ("<Control-c>","<Control-v>","<Control-x>"):
        bind_shortcut = None
#@nonl
#@-node:ekr.20031218072017.1726:<< set bind_shortcut and menu_shortcut using accel >>
#@+node:ekr.20031218072017.1727:<< define callback function >>
if openWith:
    menuCallback = self.defineOpenWithMenuCallback(command)
else:
    menuCallback = self.defineMenuCallback(command,name)
#@nonl
#@-node:ekr.20031218072017.1727:<< define callback function >>
#@+node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
realLabel = self.getRealMenuName(label)

# A bad hack:  this does not allow for translations!
# We need a way of specifying shortcuts, & bindings and translations all in the same place.

amp_index = -1
if rawKey:
    amp_index = rawKey.find("&")
if amp_index == -1:
    amp_index = realLabel.find("&")

realLabel = realLabel.replace("&","")

if 0: # trace
    if rawKey and rawKey.lower().startswith("exit"):
        g.trace(amp_index,rawKey,label,realLabel,menu_shortcut)

if not menu_shortcut:
    menu_shortcut = ""
#@nonl
#@-node:ekr.20031218072017.1728:<< set realLabel, amp_index and menu_shortcut >>
#@-node:ekr.20031218072017.1723:menu.createMenuEntries (does bindings)
#@+node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@+node:ekr.20031218072017.841:f.cut methods


#@+node:ekr.20051011072049:OnCut (no longer used)
# No longer used.  Was called from tkBody.createBindings.

def OnCut (self,event=None):
    
    """The handler for the virtual Cut event."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    f = self ; c = f.c
    
    if 0: # g.app.gui.win32clipboard is always None.
        if g.app.gui.win32clipboard:
            data = f.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)

    # Activate the body key handler by hand.
    f.body.forceFullRecolor()
    f.body.onBodyWillChange(c.currentPosition(),"Cut")
#@nonl
#@-node:ekr.20051011072049:OnCut (no longer used)
#@+node:ekr.20051011072049.1:OnCutFromMenu
def OnCutFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.
    menu.createMenuEntries contains a horrible kludge to make this happen.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    # g.trace('isBody',isBody)

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        # Necessary
        w.event_generate(g.virtual_event_name("Cut"))
        f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072049.1:OnCutFromMenu
#@+node:ekr.20051011072049.2:cutText
def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    #g.trace('isBody',isBody)

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072049.2:cutText
#@-node:ekr.20031218072017.841:f.cut methods
#@+node:ekr.20031218072017.842:f.copy methods
#@+node:ekr.20051011072903:OnCopy (no longer used)
# No longer used.  Was called from tkBody.createBindings.

def OnCopy (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    if 0: # g.app.gui.win32clipboard is always None.
        f = self
        if g.app.gui.win32clipboard:
            data = f.body.getSelectedText()
            if data:
                g.app.gui.replaceClipboardWith(data)
        
    # Copy never changes dirty bits or syntax coloring.
    
#@-node:ekr.20051011072903:OnCopy (no longer used)
#@+node:ekr.20051011072903.1:OnCopyFromMenu
def OnCopyFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.
    menu.createMenuEntries contains a horrible kludge to make this happen.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    # g.trace('isBody',isBody,'isMenu',isMenu)

    if isBody:
        w.event_generate(g.virtual_event_name("Copy"))
    else:
        # Necessary when not using shortcut keys.
        w.event_generate(g.virtual_event_name("Copy"))
#@nonl
#@-node:ekr.20051011072903.1:OnCopyFromMenu
#@+node:ekr.20051011072903.2:copyText
def copyText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    # g.trace('isBody',isBody)

    if isBody:
        w.event_generate(g.virtual_event_name("Copy"))
    else:
        pass

#@-node:ekr.20051011072903.2:copyText
#@-node:ekr.20031218072017.842:f.copy methods
#@+node:ekr.20031218072017.843:f.OnPaste & OnPasteFromMenu & pasteText
#@+node:ekr.20051011072903.3:OnPaste (no longer used)
# No longer used.  Was called from tkBody.createBindings.

def OnPaste (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    f = self ; c = f.c
  
    if 0: # sys.platform=="linux2": # ??? workaround paste problems on Linux.
        bodyCtrl = f.body.bodyCtrl
        s = bodyCtrl.selection_get( selection='CLIPBOARD' )
        bodyCtrl.insert('insert', s)
        bodyCtrl.event_generate('<Key>')
        bodyCtrl.update_idletasks()
    else:
        # Activate the body key handler by hand.
        f.body.forceFullRecolor()
        f.body.onBodyWillChange(c.currentPosition(),"Paste")
    
#@-node:ekr.20051011072903.3:OnPaste (no longer used)
#@+node:ekr.20051011072903.4:OnPasteFromMenu
def OnPasteFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.
    menu.createMenuEntries contains a horrible kludge to make this happen.'''
    
    f = self ; c = f.c ; w = f.getFocus()

    w = self.getFocus()
    isBody = w == f.body.bodyCtrl
    # g.trace('isBody',isBody,'isMenu',isMenu)

    if isBody:
        w.event_generate(g.virtual_event_name("Paste"))
    else:
        w.event_generate(g.virtual_event_name("Paste"))
        f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072903.4:OnPasteFromMenu
#@+node:ekr.20051011072903.5:pasteText
def pasteText (self):
    
    '''This should be called **only** when invoked using the menu.
    menu.createMenuEntries contains a horrible kludge to make this happen.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    # g.trace('isBody',isBody)

    if isBody:
        w.event_generate(g.virtual_event_name("Paste"))
    else:
        # Do **not** call w.event_generate here.
        f.tree.onHeadChanged(c.currentPosition())
#@nonl
#@-node:ekr.20051011072903.5:pasteText
#@-node:ekr.20031218072017.843:f.OnPaste & OnPasteFromMenu & pasteText
#@-node:ekr.20031218072017.840:Cut/Copy/Paste (tkFrame)
#@-node:ekr.20051011071542.1:(Cut/Copy/Paste bindings)
#@+node:ekr.20051012205437:(Replaced all calls to manufactureKeyPress)
# Such calls will fail if keys have been rebound.
#@nonl
#@+node:ekr.20050929115226.1:forward/backCharacter
def backCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s - 1c' % i)
    except Exception:
        pass #  w might not be a text widget.
    
def forwardCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s + 1c' % i)
    except Exception:
        pass #  w might not be a text widget.
#@-node:ekr.20050929115226.1:forward/backCharacter
#@+node:ekr.20050929163210:next/prevLine
def nextLine (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s + 1l' % i) # 1Line
    except Exception:
        pass #  w might not be a text widget.

def prevLine (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s - 1l' % i) # 1Line
    except Exception:
        pass #  w might not be a text widget.
#@nonl
#@-node:ekr.20050929163210:next/prevLine
#@+node:ekr.20050929163010:backwardDeleteCharacter
def backwardDeleteCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.delete('%s-1c' % (i), '%s' % (i))
    except Exception:
        pass #  w might not be a text widget.
#@nonl
#@-node:ekr.20050929163010:backwardDeleteCharacter
#@-node:ekr.20051012205437:(Replaced all calls to manufactureKeyPress)
#@-node:ekr.20051012210958:Fixed
#@-node:ekr.20051012084345:Bugs
#@-node:ekr.20050924073836:4.4 projects
#@-all
#@nonl
#@-node:EKR.20040429143933:@thin leoProjects.txt
#@-leo
