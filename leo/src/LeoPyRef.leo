<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="8666" clone_windows="0"/>
<globals body_outline_ratio="0.583965330444">
	<global_window_position top="10" left="432" height="923" width="810"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20060106091831"><vh>4.4b1 projects</vh>
<v t="ekr.20060106091831.1"><vh>Bugs fixed</vh>
<v t="ekr.20060106064618"><vh>Fixed minor headline problems</vh>
<v t="ekr.20051026092433.1"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.87"><vh>deleteNextChar</vh></v>
<v t="ekr.20051214132256"><vh>begin/endCommand</vh>
<v t="ekr.20051214133130"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20051215102349"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20051214133130.1"><vh>endCommand</vh></v>
</v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060106112159"><vh>Removed all calls to g.top() from Leo's core</vh>
<v t="ekr.20060106112915"><vh>Changed</vh>
<v t="ekr.20031218072017.3843"><vh>createFrame (tkComparePanel)</vh>
<v t="ekr.20031218072017.3844"><vh>&lt;&lt; create the organizer frames &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3845"><vh>&lt;&lt; create the browser rows &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3846"><vh>&lt;&lt; create the extension row &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3847"><vh>&lt;&lt; create the whitespace options frame &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3848"><vh>&lt;&lt; create the print options frame &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3849"><vh>&lt;&lt; create the compare buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20060106125608"><vh>From leoGlobals.py</vh>
<v t="ekr.20051023083258"><vh>callers</vh></v>
<v t="ekr.20031218072017.822"><vh>createTopologyList</vh></v>
<v t="ekr.20040715155607"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20031218072017.1391"><vh>g.scanDirectives</vh>
<v t="ekr.20031218072017.1392"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1393"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1394"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1395"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1396"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1397"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1398"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1399"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1400"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20040321065415"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
</v>
<v t="ekr.20060106114716"><vh>From leoTest.py</vh>
<v t="ekr.20051104075904.4"><vh>doTests...</vh>
<v t="ekr.20051104075904.5"><vh>class generalTestCase</vh>
<v t="ekr.20051104075904.6"><vh>__init__</vh></v>
<v t="ekr.20051104075904.7"><vh> fail</vh></v>
<v t="ekr.20051104075904.8"><vh>setUp</vh></v>
<v t="ekr.20051104075904.9"><vh>tearDown</vh></v>
<v t="ekr.20051104075904.10"><vh>runTest</vh></v>
<v t="ekr.20051104075904.11"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20051104075904.12"><vh>makeTestSuite</vh></v>
<v t="ekr.20051104075904.13"><vh>makeTestCase</vh></v>
</v>
<v t="ekr.20051104075904.15"><vh>runTimerOnNode</vh></v>
<v t="ekr.20051104075904.33"><vh>numberOfClonesInOutline</vh></v>
<v t="ekr.20051104075904.34"><vh>numberOfNodesInOutline</vh></v>
<v t="ekr.20051104075904.42"><vh>leoTest.runLeoTest</vh></v>
<v t="ekr.20051104075904.69"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20051104075904.78"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20051104075904.89"><vh>runPerfectImportTest</vh></v>
</v>
<v t="ekr.20060106125608.1"><vh>From leoNodes.py</vh>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
</v>
<v t="ekr.20031218072017.3156"><vh>scanError</vh></v>
</v>
</v>
<v t="ekr.20051208081641"><vh>Fixed undo problems</vh>
<v t="ekr.20051208081641.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2820"><vh>top level</vh>
<v t="ekr.20031218072017.1623"><vh>new</vh></v>
<v t="ekr.20031218072017.2821"><vh>open</vh>
<v t="ekr.20031218072017.2822"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2823"><vh>openWith and allies</vh>
<v t="ekr.20031218072017.2824"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2825"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20031218072017.2826"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2827"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20031218072017.2828"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2829"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2830"><vh>createOpenWithTempFile</vh>
<v t="ekr.20031218072017.2831"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2832"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20031218072017.2833"><vh>close</vh></v>
<v t="ekr.20031218072017.2834"><vh>save</vh></v>
<v t="ekr.20031218072017.2835"><vh>saveAs</vh></v>
<v t="ekr.20031218072017.2836"><vh>saveTo</vh></v>
<v t="ekr.20031218072017.2837"><vh>revert</vh></v>
</v>
<v t="ekr.20031218072017.2052"><vh>g.openWithFileName</vh></v>
<v t="ekr.20031218072017.2817"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060103102115"><vh>Improved word-export plugin</vh></v>
<v t="ekr.20060107231542"><vh>Removed a bad use of g.app.log in the find panel</vh></v>
<v t="ekr.20060108115434"><vh>Fix crash: tab in minibuffer</vh>
<v t="ekr.20060108115434.1"><vh>traceback</vh></v>
</v>
<v t="ekr.20060106172320"><vh>Installed patch for headline width</vh>
<v t="ekr.20060109060505"><vh>Report</vh></v>
<v t="ekr.20040803072955.16"><vh>__init__</vh>
<v t="ekr.20040803072955.17"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20040803072955.18"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040803072955.19"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.28"><vh>headWidth &amp; widthInPixels</vh></v>
</v>
<v t="ekr.20060106131142"><vh>Redraw screen properly after Move To Next Dirty</vh>
<v t="ekr.20031218072017.2917"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20031218072017.2918"><vh>goToNextMarkedHeadline</vh></v>
</v>
<v t="ekr.20060110070304"><vh>Fixed focus bug</vh>
<v t="ekr.20060110070304.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.2950"><vh>c.begin/endUpdate</vh></v>
</v>
<v t="ekr.20060110113743"><vh>Made sure to bring proper window on top in settings.leo button</vh>
<v t="ekr.20031218072017.2052"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20060110084342.2"><vh>Fixed problem with arrow keys</vh>
<v t="ekr.20060110084342.3"><vh>Report</vh></v>
<v t="ekr.20051218122116"><vh>moveToHelper</vh></v>
</v>
<v t="ekr.20060110084745"><vh>Investigated cut/paste problem</vh>
<v t="ekr.20060110084745.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20060110120907"><vh>Fixed several bugs</vh></v>
<v t="ekr.20060110133007"><vh>Fixed recent bug: text in new headline was not selected</vh>
<v t="ekr.20031218072017.1761"><vh>c.insertHeadline</vh></v>
<v t="ekr.20031218072017.2950"><vh>c.begin/endUpdate</vh></v>
</v>
<v t="ekr.20060110084342"><vh>Fixed problem with Mac enter key</vh>
<v t="ekr.20060110084342.1"><vh>Report</vh></v>
</v>
<v t="ekr.20060110093631"><vh>Fixed problems with plugins</vh>
<v t="ekr.20060110093631.1"><vh>Report</vh></v>
<v t="ekr.20060110113743.1"><vh>Report 2</vh></v>
</v>
<v t="ekr.20060111113925"><vh>Installed patch to cleo plugin</vh></v>
<v t="ekr.20060112062706"><vh>Fixed old file handling bug</vh>
<v t="ekr.20060112062706.1"><vh>Report</vh></v>
<v t="ekr.20041005105605.99"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20060113050914"><vh>Use shutil.move in g.utils_rename</vh>
<v t="ekr.20060113060922"><vh>Report</vh></v>
<v t="ekr.20031218072017.1263"><vh>g.utils_rename &amp; test</vh>
<v t="ekr.20050104123726.1"><vh>&lt;&lt; about os.rename &gt;&gt;</vh></v>
<v t="ekr.20050107085710.1"><vh>test_g_utils_rename</vh></v>
</v>
</v>
<v t="ekr.20060112112241"><vh>Simplified k.copyBindingsToWidget and eliminated k.onTextWidgetKey</vh>
<v t="ekr.20060112202702"><vh>Notes</vh></v>
<v t="ekr.20051001051355"><vh>Dispatching...</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
</v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.11"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20050920085536.12"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20050923174229.1"><vh>makeHardBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
</v>
<v t="ekr.20060113090732"><vh>Made sure that focus stays in body during tab completion</vh>
<v t="ekr.20060113170919"><vh>Notes</vh></v>
<v t="ekr.20051017212057"><vh>clearTab</vh></v>
</v>
<v t="ekr.20060114060100.1"><vh>Leo now puts focus in body pane after deleting a window</vh></v>
<v t="ekr.20060114080203"><vh>Fixed many binding problems</vh>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20060114103244"><vh>All uses of prettyPrintKey</vh>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20051014061332"><vh>printCommands</vh></v>
<v t="ekr.20051015110547"><vh>k.registerCommand</vh></v>
<v t="ekr.20051122104219"><vh>prettyPrintKey</vh></v>
</v>
<v t="ekr.20060114104119"><vh>All uses of inverseCommandsDict</vh>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20050920084036.188"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20050920084036.189"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
<v t="ekr.20051010062551.1"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060105085031"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
<v t="ekr.20051015110547"><vh>k.registerCommand</vh></v>
</v>
<v t="ekr.20060114104119.1"><vh>All uses of inverseBindingDict</vh>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20051014061332"><vh>printCommands</vh></v>
<v t="ekr.20051017212452"><vh>computeCompletionList</vh></v>
<v t="ekr.20051018070524"><vh>computeInverseBindingDict</vh></v>
</v>
<v t="ekr.20060114091359"><vh>All uses of bindingsDict</vh>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20050920084036.203"><vh>_executeMacro (revise)</vh></v>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20050920085536.75"><vh>executeNTimes</vh></v>
<v t="ekr.20051018070524"><vh>computeInverseBindingDict</vh></v>
<v t="ekr.20051014170754.1"><vh>getShortcutForCommand/Name (should return lists)</vh></v>
</v>
</v>
<v t="ekr.20060114061826"><vh>Fixed extend-selection problems</vh>
<v t="ekr.20060113130510"><vh>extendHelper</vh></v>
</v>
<v t="ekr.20060114163130"><vh>Fixed per-pane bindings!</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060114171910"><vh>traceBinding</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060114180908"><vh>All calls to copyBindingsToWidget</vh>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20051023181449"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051025120920"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20040803072955.11"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20050618045715"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060114183604"><vh>Always redraw the screen after editing a label</vh></v>
</v>
<v t="ekr.20060107104019"><vh>Code level</vh>
<v t="ekr.20060107103157"><vh>Added support for plugin menu commands</vh>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
<v t="ekr.20031218072017.2817"><vh> doCommand</vh></v>
</v>
<v t="ekr.20060106212914"><vh>Removed g.top from all plugins</vh></v>
<v t="ekr.20060107224249.1"><vh>Created c.exists ivar and related logic</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1974"><vh>destroySelf (tkFrame)</vh></v>
<v t="ekr.20031218072017.2615"><vh>app.destroyWindow</vh></v>
<v t="ekr.20050102094729"><vh>callTagHandler</vh></v>
</v>
<v t="ekr.20060107222329"><vh>Cleaned up code</vh>
<v t="ekr.20060107232924"><vh>Won't do</vh></v>
</v>
<v t="ekr.20060108151437"><vh>Call c.setLog in all entries into code</vh>
<v t="ekr.20031218072017.1847"><vh>app.setLog, lockLog, unlocklog</vh></v>
<v t="ekr.20060109164136"><vh>c.setLog</vh></v>
<v t="ekr.20031218072017.2817"><vh> doCommand</vh></v>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20040803072955.71"><vh>Event handlers (tkTree)</vh>
<v t="ekr.20051105103233"><vh>Helpers</vh>
<v t="ekr.20040803072955.72"><vh>checkWidgetList</vh></v>
<v t="ekr.20040803072955.73"><vh>dumpWidgetList</vh></v>
<v t="ekr.20040803072955.75"><vh>edit_widget</vh></v>
<v t="ekr.20040803072955.74"><vh>eventToPosition</vh></v>
<v t="ekr.20040803072955.76"><vh>findEditWidget</vh></v>
<v t="ekr.20040803072955.109"><vh>findVnodeWithIconId</vh></v>
</v>
<v t="ekr.20040803072955.78"><vh>Click Box...</vh>
<v t="ekr.20040803072955.79"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20040803072955.99"><vh>Dragging</vh>
<v t="ekr.20041111115908"><vh>endDrag</vh>
<v t="ekr.20040803072955.104"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20041111114148"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20041111114944"><vh>startDrag</vh></v>
<v t="ekr.20040803072955.100"><vh>onContinueDrag</vh>
<v t="ekr.20040803072955.101"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.102"><vh>onDrag</vh></v>
<v t="ekr.20040803072955.103"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040803072955.80"><vh>Icon Box...</vh>
<v t="ekr.20040803072955.81"><vh>onIconBoxClick</vh></v>
<v t="ekr.20040803072955.89"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20040803072955.82"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20040803072955.105"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20040803072955.106"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20051022141020"><vh>onTreeClick</vh></v>
<v t="ekr.20040803072955.84"><vh>Text Box...</vh>
<v t="ekr.20040803072955.85"><vh>configureTextState</vh></v>
<v t="ekr.20040803072955.86"><vh>onCtontrolT</vh></v>
<v t="ekr.20040803072955.87"><vh>onHeadlineClick</vh></v>
<v t="ekr.20040803072955.83"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20040803072955.108"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20040803072955.110"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20040803072955.111"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20040803072955.112"><vh>createPopupMenu</vh>
<v t="ekr.20040803072955.113"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.114"><vh>enablePopupMenuItems</vh>
<v t="ekr.20040803072955.115"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.116"><vh>showPopupMenu</vh></v>
</v>
</v>
</v>
<v t="ekr.20060108105607"><vh>Generalized doCommand</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20031218072017.2817"><vh> doCommand</vh></v>
<v t="ekr.20050920084036.188"><vh>leoCommands.getPublicCommands</vh>
<v t="ekr.20050920084036.189"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
</v>
</v>
<v t="ekr.20060111193246"><vh>Documentation</vh>
<v t="ekr.20060111112513"><vh>Updated docs with warnings about deleting children of clones</vh></v>
</v>
<v t="ekr.20060112094901"><vh>New features</vh>
<v t="ekr.20060111114001"><vh>Installed new standard bindings</vh>
<v t="ekr.20060112064517.1"><vh>From Manfred</vh></v>
<v t="ekr.20060112045830"><vh>From Speed</vh></v>
</v>
<v t="ekr.20060112064517"><vh>Added script check bindings in leoSettings.leo</vh></v>
<v t="ekr.20060112065740"><vh>Scripts now maintain original focus</vh>
<v t="ekr.20060112191014"><vh>Report</vh></v>
<v t="ekr.20031218072017.2992"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20050506084734"><vh>writeFromString (new in 4.3 beta2)</vh></v>
</v>
<v t="ekr.20060112070752"><vh>Added scroll-up/down-extend-selection commands</vh>
<v t="ekr.20060113081442.2"><vh>Notes</vh></v>
<v t="ekr.20050920084036.55"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20051218122116"><vh>moveToHelper</vh></v>
<v t="ekr.20050920084036.116"><vh>scrollUp/Down/extendSelection</vh>
<v t="ekr.20060113082917"><vh>scrollHelper</vh></v>
</v>
</v>
<v t="ekr.20060110131309"><vh>Improved cursor move/extend commands</vh>
<v t="ekr.20060110131309.1"><vh>What I did</vh></v>
<v t="ekr.20050920084036.54"><vh> ctor (editCommandsClass)</vh></v>
<v t="ekr.20060113105246"><vh>tree.moveUpDown (Reference)</vh></v>
<v t="ekr.20050929114218"><vh>move... (leoEditCommands)</vh>
<v t="ekr.20051218170358"><vh> helpers</vh>
<v t="ekr.20060113130510"><vh>extendHelper</vh></v>
<v t="ekr.20060113105246.1"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20051218122116"><vh>moveToHelper</vh></v>
<v t="ekr.20051218121447"><vh>moveWordHelper</vh></v>
<v t="ekr.20051218171457"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20051213094517"><vh>backSentenceHelper</vh></v>
<v t="ekr.20050920084036.137"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20051218133207.1"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20051218133207"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20050920084036.136"><vh>exchangePointMark</vh></v>
<v t="ekr.20051218174113"><vh>extendMode</vh></v>
<v t="ekr.20050920084036.148"><vh>buffers</vh></v>
<v t="ekr.20051213080533"><vh>characters</vh></v>
<v t="ekr.20051218141237"><vh>lines</vh></v>
<v t="ekr.20050920084036.140"><vh>movePastClose (test)</vh></v>
<v t="ekr.20050920084036.102"><vh>paragraphs</vh></v>
<v t="ekr.20050920084036.131"><vh>sentences</vh></v>
<v t="ekr.20050920084036.149"><vh>words</vh></v>
</v>
<v t="ekr.20051218141237"><vh>lines</vh></v>
<v t="ekr.20051218122116"><vh>moveToHelper</vh></v>
<v t="ekr.20060113105246.1"><vh>moveUpOrDownHelper</vh></v>
<v t="ekr.20060113082917"><vh>scrollHelper</vh></v>
<v t="ekr.20060113130510"><vh>extendHelper</vh></v>
</v>
<v t="ekr.20060113163800"><vh>Made edit command keys work in headlines</vh></v>
<v t="ekr.20060115095641"><vh>Use pretty keys in tab completion tab</vh></v>
<v t="ekr.20060115091804.2"><vh>Finish support for @mode nodes</vh>
<v t="ekr.20051010062551.1"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20060115134337"><vh>From leoConfig</vh>
<v t="ekr.20060102103625"><vh>createModeCommand</vh></v>
<v t="ekr.20060102103625.1"><vh>doMode</vh></v>
</v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.11"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20050920085536.12"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20050923174229.1"><vh>makeHardBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060115103349"><vh>Modes</vh>
<v t="ekr.20060102135349.2"><vh>enterNamedMode</vh></v>
<v t="ekr.20060104110233"><vh>generalModeHandler</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp &amp; helper</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20050921094025"><vh>4.4 To do</vh>
<v t="ekr.20060113085710"><vh>First</vh>
<v t="ekr.20060115102006.1"><vh>Test on Mac</vh></v>
</v>
<v t="ekr.20060110202455"><vh>Next</vh>
<v t="ekr.20060115091804.2"><vh>Finish support for @mode nodes</vh>
<v t="ekr.20051010062551.1"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20060115134337"><vh>From leoConfig</vh>
<v t="ekr.20060102103625"><vh>createModeCommand</vh></v>
<v t="ekr.20060102103625.1"><vh>doMode</vh></v>
</v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.11"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20050920085536.12"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20050923174229.1"><vh>makeHardBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060115103349"><vh>Modes</vh>
<v t="ekr.20060102135349.2"><vh>enterNamedMode</vh></v>
<v t="ekr.20060104110233"><vh>generalModeHandler</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp &amp; helper</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
<v t="ekr.20060115162515"><vh>Specify what mode to enter for each mode command</vh></v>
<v t="ekr.20060114215112"><vh>Make sure all (or most) callbacks call masterCommand</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060115100407"><vh>Found: callback</vh>
<v t="ekr.20060115100841"><vh>Do call masterCommand</vh>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060115100841.1"><vh>Don't (yet) call masterCommand</vh>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
</v>
</v>
</v>
<v t="ekr.20060115091804.3"><vh>Use sandbox2 for experiments</vh></v>
<v t="ekr.20060114055714"><vh>Improve modes</vh>
<v t="ekr.20060114060100"><vh>Notes</vh></v>
<v t="ekr.20060114052626"><vh>@alias nodes set minibuffer aliases</vh></v>
</v>
<v t="ekr.20060113170919.1"><vh>Think commands when designing workflow, and for chapters</vh></v>
<v t="ekr.20050928144501.1"><vh>Commands for mouseless Leo</vh>
<v t="ekr.20060114080424"><vh>Urgent commands needed for mouseless Leo</vh></v>
<v t="ekr.20060112084446"><vh>Next</vh></v>
<v t="ekr.20060110202238"><vh>Missing bindings/commands</vh></v>
<v t="ekr.20060104083551"><vh>New commands for mouseless Leo (LeoUser)</vh></v>
<v t="ekr.20050707085637"><vh>Suggestions from an emacs user</vh></v>
<v t="ekr.20051221101851"><vh>Add commands to simulate clicks</vh>
<v t="ekr.20051221101851.1"><vh>Request</vh></v>
</v>
<v t="ekr.20060113090042"><vh>open-outline-by-name</vh></v>
<v t="ekr.20060115092257"><vh>Reference for function keys</vh></v>
</v>
<v t="ekr.20060111152145"><vh>Improve scripts menu plugin</vh></v>
<v t="ekr.20060111152145.1"><vh>Study jyLeo's chapters code</vh></v>
<v t="ekr.20060114055611"><vh>Fix sort-lines problems</vh></v>
<v t="ekr.20060111134901"><vh>Implement c.es etc.</vh></v>
</v>
<v t="ekr.20060105133043"><vh>Important</vh>
<v t="ekr.20060111134004"><vh>Run Idle in a separate process</vh>
<v t="ekr.20060111103821"><vh>This would fix weird crasher in Plugins Manager plugin</vh>
<v t="ekr.20060111103821.1"><vh>Report</vh></v>
</v>
<v t="ekr.20060111134004.1"><vh>Posting</vh></v>
<v t="ekr.20031218072017.2932"><vh>openPythonWindow (Dave Hein)</vh>
<v t="ekr.20031218072017.2933"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2934"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="ekr.20031218072017.2936"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2935"><vh>&lt;&lt; Try to open idle in Python 2.2 systems&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2937"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="ekr.20060109183500.1"><vh>Scripting improvements</vh></v>
<v t="ekr.20060108120501"><vh>Add @find node to scripting plugin</vh></v>
<v t="ekr.20051217135340.2"><vh>Create find-options panel</vh></v>
<v t="ekr.20051217175058"><vh>Add support in Leo's core for chapters</vh></v>
<v t="ekr.20051028061611.1"><vh>Unify all search commands</vh>
<v t="ekr.20051112075511"><vh>Idea for improving search command code</vh></v>
<v t="ekr.20051023094009"><vh>Search classes (ok, i-search is limited)</vh>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__</vh>
<v t="ekr.20051020120306.12"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051020120306.13"><vh>createFrame (findTab)</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.19"><vh>find.init</vh>
<v t="ekr.20051020120306.20"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020120306.21"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020120306.22"><vh>find.update_ivars</vh></v>
<v t="ekr.20051023183028"><vh>findButtonCallback</vh></v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.27"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020120306.28"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20051020120306.1"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020120306.2"><vh>__init__</vh>
<v t="ekr.20051020120306.3"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.4"><vh>bindHotKey</vh></v>
<v t="ekr.20051020120306.5"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051022211617"><vh>find tab...</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>commands...</vh></v>
</v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler &amp; helper</vh>
<v t="ekr.20051002120125"><vh>&lt;&lt; do a non-incremental search &gt;&gt;</vh></v>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
</v>
<v t="ekr.20050920084036.267"><vh>non-incremental search...</vh>
<v t="ekr.20050920084036.269"><vh>seachForward/Backward &amp; helper</vh>
<v t="ekr.20050920084036.268"><vh>plainSearchHelper</vh></v>
</v>
<v t="ekr.20051002111614"><vh>wordSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.272"><vh>wordSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.274"><vh>reSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.275"><vh>reSearchHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051012053017.4"><vh>Search improvements</vh></v>
</v>
<v t="ekr.20051126122638"><vh>Autocompletion tab</vh>
<v t="ekr.20051205093049"><vh>Use dir for auto-complete ?</vh></v>
<v t="ekr.20051025144611"><vh>Reference (Do not delete)</vh>
<v t="ekr.20051025144611.1"><vh>Configuration</vh>
<v t="ekr.20051025144611.2"><vh>autocompleter.ini</vh></v>
<v t="ekr.20051025144611.3"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20051025144611.4"><vh>autocompleter.py</vh>
<v t="ekr.20051025144611.5"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20051025144611.6"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051025144611.7"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20051025144611.8"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="ekr.20051025144611.10"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="ekr.20051025144611.11"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20051025144611.12"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="ekr.20051025144611.13"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20051025144611.14"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20051025170832"><vh>Initialization</vh>
<v t="ekr.20051025144611.15"><vh>init</vh></v>
<v t="ekr.20051025170832.1"><vh>Config stuff</vh>
<v t="ekr.20051025144611.24"><vh>has read config file meths</vh></v>
<v t="ekr.20051025144611.25"><vh>readConfigFile</vh></v>
<v t="ekr.20051025144611.26"><vh>createConfigFile</vh></v>
<v t="ekr.20051025144611.27"><vh>readLanguageFiles</vh></v>
<v t="ekr.20051025144611.28"><vh>readOutline</vh></v>
</v>
<v t="ekr.20051025144611.16"><vh>watcher</vh></v>
<v t="ekr.20051025144611.23"><vh>initialScan</vh></v>
</v>
<v t="ekr.20051025144611.17"><vh>scanText</vh></v>
<v t="ekr.20051025144611.18"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20051025144611.19"><vh>scanForCallTip</vh></v>
<v t="ekr.20051025144611.20"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20051025144611.21"><vh>_getCleanString</vh></v>
<v t="ekr.20051025144611.22"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20051025144611.29"><vh>reducer</vh></v>
<v t="ekr.20051025144611.30"><vh>unbind</vh></v>
<v t="ekr.20051025144611.31"><vh>moveSelItem</vh></v>
<v t="ekr.20051025144611.32"><vh>processKeyStroke</vh></v>
<v t="ekr.20051025144611.33"><vh>testForUnbind</vh></v>
<v t="ekr.20051025144611.34"><vh>processAutoBox</vh></v>
<v t="ekr.20051025144611.35"><vh>add_item</vh></v>
<v t="ekr.20051025144611.36"><vh>add_bindings</vh></v>
<v t="ekr.20051025144611.37"><vh>configureAutoBox</vh></v>
<v t="ekr.20051025144611.38"><vh>calculatePlace</vh></v>
<v t="ekr.20051025144611.39"><vh>setLanguage</vh></v>
<v t="ekr.20051025144611.40"><vh>newCreateControl</vh></v>
<v t="ekr.20051025144611.41"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20051025144611.42"><vh>onOpenWindow</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4059"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20031218072017.844"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20031218072017.845"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20031218072017.846"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20031218072017.4060"><vh>Dialog</vh>
<v t="ekr.20031218072017.4061"><vh>get_window_info</vh></v>
<v t="ekr.20031218072017.4062"><vh>center_dialog</vh></v>
<v t="ekr.20031218072017.4063"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20031218072017.4064"><vh>Focus</vh>
<v t="ekr.20031218072017.4065"><vh>get_focus</vh></v>
<v t="ekr.20031218072017.2373"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20050210082320"><vh>widget_wants_focus (tk.gui)</vh></v>
</v>
<v t="ekr.20031218072017.4066"><vh>Font</vh>
<v t="ekr.20031218072017.2187"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20031218072017.4067"><vh>Icons</vh>
<v t="ekr.20031218072017.4068"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20031218072017.4069"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4070"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4071"><vh>Idle Time</vh>
<v t="ekr.20031218072017.4072"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20031218072017.4073"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20031218072017.4074"><vh>Indices (Tk)</vh>
<v t="ekr.20031218072017.4075"><vh>firstIndex</vh></v>
<v t="ekr.20031218072017.4076"><vh>lastIndex</vh></v>
<v t="ekr.20031218072017.4077"><vh>moveIndexBackward</vh></v>
<v t="ekr.20031218072017.4078"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20031218072017.4079"><vh>compareIndices</vh></v>
<v t="ekr.20031218072017.4080"><vh>getindex</vh></v>
</v>
<v t="ekr.20031218072017.4081"><vh>Insert Point</vh>
<v t="ekr.20031218072017.4082"><vh>getInsertPoint</vh></v>
<v t="ekr.20031218072017.4083"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20031218072017.4084"><vh>Selection</vh>
<v t="ekr.20031218072017.4085"><vh>getSelectionRange (to be deleted?)</vh></v>
<v t="ekr.20051126125950"><vh>getSelectedText</vh></v>
<v t="ekr.20031218072017.4086"><vh>getTextSelection</vh></v>
<v t="ekr.20051126171929"><vh>hasSelection</vh></v>
<v t="ekr.20031218072017.4088"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20031218072017.4089"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20031218072017.4090"><vh>Text</vh>
<v t="ekr.20031218072017.4091"><vh>getAllText</vh></v>
<v t="ekr.20031218072017.4092"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20031218072017.4093"><vh>getCharAtIndex</vh></v>
<v t="ekr.20031218072017.4094"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20031218072017.4095"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20031218072017.4096"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20031218072017.4097"><vh>Visibility</vh>
<v t="ekr.20031218072017.4098"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20051220144507"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20051126123249"><vh>class autoCompleterClass (prototype)</vh>
<v t="ekr.20051126123759"><vh> birth</vh>
<v t="ekr.20051126123759.1"><vh> ctor</vh></v>
<v t="ekr.20051126123759.2"><vh> getPublicCommands (autoCommandsClass)</vh></v>
</v>
<v t="ekr.20051127105431"><vh>abort</vh></v>
<v t="ekr.20051126122952.1"><vh>autoComplete</vh></v>
<v t="ekr.20051126123149"><vh>computeCompletionList (autoCompleter)</vh></v>
<v t="ekr.20051126131103"><vh>doBackSpace</vh></v>
<v t="ekr.20051126123249.1"><vh>doTabCompletion (autoCompleter)</vh></v>
<v t="ekr.20051127065601"><vh>extendSelection</vh></v>
<v t="ekr.20051127105102"><vh>finish</vh></v>
<v t="ekr.20051127070018"><vh>setSelection</vh></v>
<v t="ekr.20051126124705"><vh>stateHandler (autoCompleter)</vh></v>
</v>
</v>
<v t="ekr.20051202094427"><vh>Resolve cvs conflicts</vh>
<v t="ekr.20031218072017.658"><vh>Resolve CVS Conflicts command (Stepen Schaefer)</vh>
<v t="ekr.20050501111900"><vh>Stephen Schaefer</vh></v>
<v t="ekr.20031218072017.659"><vh>Jonathon 1</vh></v>
<v t="ekr.20031218072017.660"><vh>Jonathan 2</vh></v>
<v t="ekr.20031218072017.661"><vh>Gil 1</vh></v>
<v t="ekr.20031218072017.662"><vh>Gil 2</vh></v>
</v>
</v>
</v>
<v t="ekr.20051129095023"><vh>Medium 3 days</vh>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
<v t="ekr.20051202100658"><vh>Filename completion</vh></v>
<v t="ekr.20060107082929"><vh>Fix problem reporting indentation errors</vh></v>
<v t="ekr.20051121070552"><vh>Add Cmds menu</vh></v>
<v t="ekr.20051104152338"><vh>Fix bug in Remove Sentinels command</vh>
<v t="ekr.20051104152338.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051014152256"><vh>Fix long-standing bug in import code</vh>
<v t="ekr.20040930075711"><vh>Handle underindented lines</vh></v>
<v t="ekr.20040722132104"><vh>Write script to report underindented lines</vh></v>
</v>
<v t="ekr.20051112080017"><vh>Problem removing script buttons on the mac</vh></v>
<v t="ekr.20051202095626"><vh>Add help-command</vh></v>
<v t="ekr.20060110102039"><vh>--script option</vh>
<v t="ekr.20060110102239.1"><vh>leomain.py</vh>
<v t="ekr.20060110102239.2"><vh>def profile</vh></v>
<v t="ekr.20060110102239.3"><vh>def parseopts(argv)</vh></v>
<v t="ekr.20060110102239.4"><vh>concatate(sys.argv)</vh></v>
<v t="ekr.20060110102239.5"><vh>test run manual</vh></v>
<v t="ekr.20060110102239.6"><vh>notes</vh></v>
</v>
<v t="ekr.20060110102239.7"><vh>Leo hprof script</vh>
<v t="ekr.20060110102239.8"><vh>try: psyco</vh></v>
</v>
</v>
</v>
<v t="ekr.20051012062458.1"><vh>Minor</vh>
<v t="ekr.20060111103821.2"><vh>Fix problems with universalScrolling pluing</vh>
<v t="ekr.20060111103821.3"><vh>Report</vh></v>
</v>
<v t="ekr.20051110155735.1"><vh>Improve Spell tab</vh>
<v t="ekr.20051025071455"><vh>Spell classes (ok)</vh>
<v t="ekr.20051025071455.6"><vh>class Aspell</vh>
<v t="ekr.20051025071455.7"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.8"><vh>__init__</vh></v>
</v>
<v t="ekr.20051025071455.10"><vh>processWord</vh></v>
<v t="ekr.20051025071455.11"><vh>updateDictionary</vh></v>
</v>
<v t="ekr.20051025071455.1"><vh>class spellCommandsClass</vh>
<v t="ekr.20051025080056"><vh>ctor</vh></v>
<v t="ekr.20051025080420"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051025080633"><vh>openSpellTab</vh></v>
<v t="ekr.20051025080420.1"><vh>commands...</vh></v>
</v>
<v t="ekr.20051025071455.18"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20051025071455.19"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.20"><vh>spellTab.__init__</vh></v>
<v t="ekr.20051025094004"><vh>init_aspell</vh></v>
<v t="ekr.20051025071455.22"><vh>createSpellTab</vh>
<v t="ekr.20051113090322"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051025071455.23"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20051025071455.24"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025120920"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20051025071455.16"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20051025071455.29"><vh>Buttons</vh>
<v t="ekr.20051025071455.30"><vh>onAddButton</vh></v>
<v t="ekr.20051025071455.31"><vh>onIgnoreButton</vh></v>
<v t="ekr.20051025071455.32"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20051025071455.33"><vh>onFindButton</vh></v>
<v t="ekr.20051025071455.34"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20051025071455.36"><vh>Commands</vh>
<v t="ekr.20051025071455.37"><vh>add</vh></v>
<v t="ekr.20051025071455.38"><vh>change</vh></v>
<v t="ekr.20051025071455.40"><vh>find</vh></v>
<v t="ekr.20051025121408"><vh>hide</vh></v>
<v t="ekr.20051025071455.41"><vh>ignore</vh></v>
</v>
<v t="ekr.20051025071455.42"><vh>Helpers</vh>
<v t="ekr.20051025071455.43"><vh>bringToFront</vh></v>
<v t="ekr.20051025071455.44"><vh>fillbox</vh></v>
<v t="ekr.20051025071455.45"><vh>findNextMisspelledWord</vh>
<v t="ekr.20051025071455.46"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025071455.47"><vh>findNextWord</vh></v>
<v t="ekr.20051025071455.48"><vh>getSuggestion</vh></v>
<v t="ekr.20051025071455.49"><vh>onMap</vh></v>
<v t="ekr.20051025071455.50"><vh>onSelectListBox</vh></v>
<v t="ekr.20051025071455.51"><vh>update</vh></v>
<v t="ekr.20051025071455.52"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051202102337"><vh>Minibuffer commands notes</vh>
<v t="ekr.20051202102337.1"><vh>abbrevCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102337.2"><vh>bufferCommandsClass Inot ready yet)</vh></v>
<v t="ekr.20051202102337.3"><vh>controlCommandsClass (ok)</vh></v>
<v t="ekr.20051202102337.4"><vh>editCommandsClass</vh></v>
<v t="ekr.20051202102337.6"><vh>editFileCommandsClass</vh></v>
<v t="ekr.20051202102752.1"><vh>keyHandlerCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102752.2"><vh>killBufferCommandsClass</vh></v>
<v t="ekr.20051202102752.3"><vh>macroCommandsClass</vh></v>
<v t="ekr.20051202102752.4"><vh>queryReplaceCommandsClass</vh></v>
<v t="ekr.20051202102752.5"><vh>rectangleCommandsClass (ok)</vh></v>
<v t="ekr.20051202102752.6"><vh>registerCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.7"><vh>searchCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.8"><vh>spellCommandsClass (ok)</vh></v>
</v>
<v t="ekr.20060103101524"><vh>Improve command-line handling</vh></v>
<v t="ekr.20050713105353"><vh>Add configuration setting to set menu fonts</vh>
<v t="ekr.20050713105353.1"><vh>Email from Martin Moncrieffe &lt;mcm35@cam.ac.uk&gt;</vh></v>
</v>
<v t="ekr.20050512031131"><vh>Use global_log_window_position to specify outline/log ratio?</vh></v>
<v t="ekr.20050916180203"><vh>Make more commands undoable</vh></v>
<v t="ekr.20051016155819"><vh>treat plugins/options.py  differently?</vh></v>
<v t="ekr.20051101161545"><vh>Allow multiple bindings for the same minibuffer command</vh></v>
<v t="ekr.20060102092148.1"><vh>--safe option</vh></v>
<v t="ekr.20060104083736"><vh>Improve how headline widtth gets computed</vh></v>
<v t="ekr.20060105143454.1"><vh>The colerer is calling c.config too much?</vh></v>
</v>
<v t="ekr.20051023192433"><vh>Maybe or never</vh>
<v t="ekr.20060105143454.2"><vh>Convert Emacs-Style Names to Menu Style Names when creating undo name</vh></v>
<v t="ekr.20051220062654"><vh>Open .leo file in new process</vh></v>
<v t="ekr.20051103091115.1"><vh>Report</vh></v>
<v t="ekr.20051207130144"><vh>Investigate Tk DnD</vh>
<v t="ekr.20051207130144.1"><vh>@url http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html</vh></v>
</v>
<v t="ekr.20060102092148.2"><vh>auto-install docutils?</vh></v>
<v t="ekr.20051104051733"><vh>Make Focus-in in minibuffer widget equivalent to Alt-x</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406" a="TV"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"
marks="ekr.20051010062551.1,"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.658">@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
</t>
<t tx="ekr.20031218072017.659">https://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

In the .leo, if I edit &lt;&lt;bar&gt;&gt;, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@+leo
#@+node:0::@file foo.py
#@+body
#@+others
#@+node:1::definition of a
#@+body
print "a:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"bar"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:1::definition of a
#@+node:2::definition of b
#@+body
print "b:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"variation b"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:2::definition of b
#@+node:3::definition of c
#@+body
print "c:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"variation c"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:3::definition of c
#@-others
#@-body
#@-node:0::@file foo.py
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
</t>
<t tx="ekr.20031218072017.660">By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

&lt;&lt;&lt;&lt;&lt;&lt;&lt; 
blah blah blah? 
======= 
blah blah blah! 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  

 
</t>
<t tx="ekr.20031218072017.661">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
</t>
<t tx="ekr.20031218072017.662">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?

More things to think about.

Gil
</t>
<t tx="ekr.20031218072017.822">def createTopologyList (c,root=None,useHeadlines=False):
    
    """Creates a list describing a node and all its descendents"""

    if not root: root = c.rootPosition()
    v = root
    if useHeadlines:
        aList = [(v.numberOfChildren(),v.headString()),]
    else:
        aList = [v.numberOfChildren()]
    child = v.firstChild()
    while child:
        aList.append(g.createTopologyList(c,child,useHeadlines))
        child = child.next()
    return aList</t>
<t tx="ekr.20031218072017.840"></t>
<t tx="ekr.20031218072017.844">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20031218072017.845">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20031218072017.846">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20031218072017.892">def __init__ (self,c,v,stack,trace=True):

    """Create a new position."""
    
    __pychecker__ = '--no-argsused' # trace not used.

    self.c = c
    self.v = v
    # assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.
    g.app.positions += 1
    
    # if g.app.tracePositions and trace:
        # g.trace("%-25s %-25s %s" % (
            # g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.</t>
<t tx="ekr.20031218072017.1263">&lt;&lt; about os.rename &gt;&gt;

def utils_rename (src,dst,mode=None,verbose=True):

    '''Platform independent rename.'''

    head, tail = g.os_path_split(dst)
    if head and len(head) &gt; 0:
        g.makeAllNonExistentDirectories(head)

    if g.os_path_exists(dst):
        if not g.utils_remove(dst):
            return False
    try:
        # New in Leo 4.4b1: try using shutil first.
        try:
            import shutil # shutil is new in Python 2.3
            shutil.move(src,dst)
        except ImportError:
            if sys.platform == "win32":
                os.rename(src,dst)
            else:
                try:
                    # Alas, distutils.file_util may not exist.
                    from distutils.file_util import move_file
                    move_file(src,dst)
                except ImportError:
                    # Desperation: may give: 'Invalid cross-device link'
                    os.rename(src,dst)
        if mode:
            g.utils_chmod(dst,mode,verbose)
        return True
    except Exception:
        if verbose:
            g.es('Exception renaming %s to %s' % (src,dst),color='red')
            g.es_exception(full=False)
        return False</t>
<t tx="ekr.20031218072017.1391">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        theDict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,p=p,v=p,s=s,
            old_dict=old,dict=theDict,pluginsList=pluginsList)
        old.update(theDict)

    if path == None: path = g.getBaseDirectory(c=c)

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }</t>
<t tx="ekr.20031218072017.1392">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
if c.target_language:
    c.target_language = c.target_language.lower()
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline(c=c) # Init from config settings.
wrap = c.config.getBool("body_pane_wraps")</t>
<t tx="ekr.20031218072017.1393"># 1/23/05: Any previous @language or @comment prevents processing up the tree.
# This code is now like the code in tangle.scanAlldirectives.

if old.has_key("comment") or old.has_key("language"):
    pass

elif theDict.has_key("comment"):
    k = theDict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

elif theDict.has_key("language"):
    k = theDict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20031218072017.1394">if not old.has_key("encoding") and theDict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,theDict)
    if e:
        encoding = e
</t>
<t tx="ekr.20031218072017.1395">if not old.has_key("lineending") and theDict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,theDict)
    if e:
        lineending = e
</t>
<t tx="ekr.20031218072017.1396">if theDict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,theDict)
    if w and w &gt; 0:
        page_width = w</t>
<t tx="ekr.20031218072017.1397">if not path and not old.has_key("path") and theDict.has_key("path"):

    k = theDict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory(c=c) # returns "" on error.
        path = g.os_path_join(base,path)
        </t>
<t tx="ekr.20031218072017.1398">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)</t>
<t tx="ekr.20031218072017.1399">if theDict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,theDict)
    if w and w != 0:
        tab_width = w</t>
<t tx="ekr.20031218072017.1400">if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if theDict.has_key("wrap"):
        wrap = True
    elif theDict.has_key("nowrap"):
        wrap = False</t>
<t tx="ekr.20031218072017.1623">def new (self):

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(c,v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    finally:
        c.endUpdate()
        frame.body.setFocus()
    return c # For unit test.</t>
<t tx="ekr.20031218072017.1761">def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.endEditing()
        c.editPosition(p)
    finally:
        c.endUpdate(restoreFocus=False)

    return p # for mod_labels plugin.</t>
<t tx="ekr.20031218072017.1847">def setLog (self,log):

    """set the frame to which log messages will go"""
    
    # print "setLog:",tag,"locked:",self.logIsLocked,log
    if not self.logIsLocked:
        self.log = log

def lockLog(self):
    """Disable changes to the log"""
    self.logIsLocked = True
    
def unlockLog(self):
    """Enable changes to the log"""
    self.logIsLocked = False</t>
<t tx="ekr.20031218072017.1974">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20031218072017.2052">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            frame.bodyWantsFocus()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20031218072017.2187">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20031218072017.2373">def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # I am not happy with this, but it seems preferable to trying to figure out
            # all the places where the code must call update()
            
            # New in 4.4b1: the place to call update is *after* log pane operations.
            w.update() 

        w.focus_set()</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode</t>
<t tx="ekr.20031218072017.2418">def initScriptFind(c,findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
        
    __pychecker__ = '--no-argsused' # firstNode is not used.
    
    import leoTest
    import leoGlobals as g

    # Find the scripts.
    p = c.currentPosition()
    u = leoTest.testUtils(c)
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    c.frame.findPanel.init(c)
    c.showFindPanel()</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2615">def destroyWindow (self,frame):
    
    # g.trace(frame in g.app.windowList,frame)
        
    g.app.destroyOpenWithFilesForFrame(frame)

    if frame in g.app.windowList:
        g.app.windowList.remove(frame)
        # g.trace(g.app.windowList)

    # force the window to go away now.
    # Important: this also destroys all the objects of the commander.
    frame.destroySelf()</t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = False
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For saving and restoring focus.
self.afterUpdateWidgetStack = []

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.2817">def doCommand (self,command,label,event=None):

    """Execute the given command, invoking hooks and catching exceptions.
    
    The code assumes that the "command1" hook has completely handled the command if
    g.doHook("command1") returns False.
    This provides a simple mechanism for overriding commands."""
    
    c = self
    c.setLog()
    p = c.currentPosition()
    #g.trace(command.__name__,label)
    
    # The presence of this message disables all commands.
    if c.disableCommandsMessage:
        g.es(c.disableCommandsMessage,color='blue')
        return 'break' # Inhibit all other handlers.

    if label and event is None: # Do this only for legacy commands.
        if label == "cantredo": label = "redo"
        if label == "cantundo": label = "undo"
        g.app.commandName = label

    if not g.doHook("command1",c=c,p=p,v=p,label=label):
        try:
            if event is None:
                val = command() # Call legacy command
                if c and c.exists: # Be careful: the command could destroy c.
                    c.keyHandler.funcReturn = val
            else:
                command(event) # Call minibuffer command.
        except:
            g.es("exception executing command")
            print "exception executing command"
            g.es_exception(c=c)
            if c and c.exists and hasattr(c,'frame'):
                c.redraw_now()

    # Be careful there: the command could destroy c.
    if c and c.exists:
        p = c.currentPosition()
        g.doHook("command2",c=c,p=p,v=p,label=label)
            
    return "break" # Inhibit all other handlers.</t>
<t tx="ekr.20031218072017.2820"></t>
<t tx="ekr.20031218072017.2821">def open(self):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20031218072017.2822">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20031218072017.2823">def openWith(self,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    if not data or len(data) != 3:
        g.trace('bad data')
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20031218072017.2824">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20031218072017.2825">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20031218072017.2826">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20031218072017.2827">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20031218072017.2828">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20031218072017.2829">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20031218072017.2830">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.2831">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20031218072017.2832">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20031218072017.2833">def close(self):
    
    """Handle the File-Close command."""

    g.app.closeLeoWindow(self.frame)</t>
<t tx="ekr.20031218072017.2834">def save(self):

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20031218072017.2835">def saveAs(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20031218072017.2836">def saveTo(self):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)</t>
<t tx="ekr.20031218072017.2837">def revert(self):
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20031218072017.2917">def goToNextDirtyHeadline (self):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isDirty():
        p.moveToThreadNext()

    if not p:
        # Wrap around.
        p = c.rootPosition()
        while p and not p.isDirty():
            p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20031218072017.2918">def goToNextMarkedHeadline(self):

    c = self ; p = c.currentPosition()
    if not p: return

    p.moveToThreadNext()
    while p and not p.isMarked():
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectPosition(p)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20031218072017.2932">def openPythonWindow(self):

    if sys.platform == "linux2":
        &lt;&lt; open idle in Linux &gt;&gt;
    else:
        &lt;&lt; open idle in Windows &gt;&gt;
</t>
<t tx="ekr.20031218072017.2933"># 09-SEP-2002 DHEIN: Open Python window under linux

try:
    pathToLeo = g.os_path_join(g.app.loadDir,"leo.py")
    sys.argv = [pathToLeo]
    from idlelib import idle
    if g.app.idle_imported:
        reload(idle)
    g.app.idle_imported = True
except:
    try:
        g.es("idlelib could not be imported.")
        g.es("Probably IDLE is not installed.")
        g.es("Run Tools/idle/setup.py to build idlelib.")
        g.es("Can not import idle")
        g.es_exception() # This can fail!!
    except: pass
</t>
<t tx="ekr.20031218072017.2934"># Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo"] # ,"-t","Leo"]

ok = False
if g.CheckVersion(sys.version,"2.3"):
    &lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;
else:
    &lt;&lt; Try to open idle in Python 2.2 systems &gt;&gt;

if not ok:
    g.es("Can not import idle")
    if idle_dir and idle_dir not in sys.path:
        g.es("Please add '%s' to sys.path" % idle_dir)</t>
<t tx="ekr.20031218072017.2935">try:
    executable_dir = g.os_path_dirname(sys.executable)
    idle_dir = g.os_path_join(executable_dir,"Tools","idle")

    # 1/29/04: sys.path doesn't handle unicode in 2.2.
    idle_dir = str(idle_dir) # May throw an exception.

    # 1/29/04: must add idle_dir to sys.path even when using importFromPath.
    if idle_dir not in sys.path:
        sys.path.insert(0,idle_dir)

    if 1:
        import PyShell
    else: # Works, but is not better than import.
        PyShell = g.importFromPath("PyShell",idle_dir)

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    if 1: # Mostly works, but causes problems when opening other .leo files.
        PyShell.main()
    else: # Doesn't work: destroys all of Leo when Idle closes.
        self.leoPyShellMain()
    ok = True
except ImportError:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20031218072017.2936">try:
    idle_dir = None
    
    import idlelib.PyShell

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    idlelib.PyShell.main()
    ok = True

except:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20031218072017.2937">@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work well.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
    
    import PyShell
    root = g.app.root
    PyShell.fixwordbreaks(root)
    flist = PyShell.PyShellFileList(root)
    shell = PyShell.PyShell(flist)
    flist.pyshell = shell
    shell.begin()</t>
<t tx="ekr.20031218072017.2950">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    w = g.app.gui.get_focus(c.frame)
    c.afterUpdateWidgetStack.append(w)
    # g.trace(g.app.gui.widget_name(w),g.callers(5))
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True,restoreFocus=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)
    w = c.afterUpdateWidgetStack.pop()
    if not c.afterUpdateWidgetStack and restoreFocus:
        # We are at the top-level endUpdate.
        c.frame.widgetWantsFocus(w)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20031218072017.2992"># Ends the editing in the outline.

def endEditing(self,restoreFocus=False):
    
    c = self ; tree = c.frame.tree
    
    if restoreFocus:
        w = g.app.gui.get_focus(c.frame)
        tree.endEditLabel()
        c.frame.widgetWantsFocus(w)
    else:
        tree.endEditLabel()</t>
<t tx="ekr.20031218072017.3156"># It is dubious to bump the Tangle error count here, but it really doesn't hurt.

def scanError(s):

    """Bump the error count in the tangle command."""
    
    # New in Leo 4.4b1: just set this global.
    g.app.scanErrors +=1
    g.es(s)</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3843">def createFrame (self):

    gui = g.app.gui ; top = self.top

    &lt;&lt; create the organizer frames &gt;&gt;
    &lt;&lt; create the browser rows &gt;&gt;
    &lt;&lt; create the extension row &gt;&gt;
    &lt;&lt; create the whitespace options frame &gt;&gt;
    &lt;&lt; create the print options frame &gt;&gt;
    &lt;&lt; create the compare buttons &gt;&gt;

    gui.center_dialog(top) # Do this _after_ building the dialog!
    self.finishCreate()
    top.protocol("WM_DELETE_WINDOW", self.onClose)</t>
<t tx="ekr.20031218072017.3844">outer = Tk.Frame(self.frame, bd=2,relief="groove")
outer.pack(pady=4)

row1 = Tk.Frame(outer)
row1.pack(pady=4)

row2 = Tk.Frame(outer)
row2.pack(pady=4)

row3 = Tk.Frame(outer)
row3.pack(pady=4)

row4 = Tk.Frame(outer)
row4.pack(pady=4,expand=1,fill="x") # for left justification.

options = Tk.Frame(outer)
options.pack(pady=4)

ws = Tk.Frame(options)
ws.pack(side="left",padx=4)

pr = Tk.Frame(options)
pr.pack(side="right",padx=4)

lower = Tk.Frame(outer)
lower.pack(pady=6)</t>
<t tx="ekr.20031218072017.3845">for row,text,text2,command,var in (
    (row1,"Compare path 1:","Ignore first line",self.onBrowse1,self.ignoreFirstLine1Var),
    (row2,"Compare path 2:","Ignore first line",self.onBrowse2,self.ignoreFirstLine2Var),
    (row3,"Output file:",   "Use output file",  self.onBrowse3,self.useOutputFileVar) ):

    lab = Tk.Label(row,anchor="e",text=text,width=13)
    lab.pack(side="left",padx=4)
    
    e = Tk.Entry(row)
    e.pack(side="left",padx=2)
    self.browseEntries.append(e)
    
    b = Tk.Button(row,text="browse...",command=command)
    b.pack(side="left",padx=6)

    b = Tk.Checkbutton(row,text=text2,anchor="w",variable=var,width=15)
    b.pack(side="left")</t>
<t tx="ekr.20031218072017.3846">b = Tk.Checkbutton(row4,anchor="w",var=self.limitToExtensionVar,
    text="Limit directory compares to type:")
b.pack(side="left",padx=4)

self.extensionEntry = e = Tk.Entry(row4,width=6)
e.pack(side="left",padx=2)

b = Tk.Checkbutton(row4,anchor="w",var=self.appendOutputVar,
    text="Append output to output file")
b.pack(side="left",padx=4)</t>
<t tx="ekr.20031218072017.3847">w,f = gui.create_labeled_frame(ws,caption="Whitespace options",relief="groove")
    
for text,var in (
    ("Ignore Leo sentinel lines", self.ignoreSentinelLinesVar),
    ("Ignore blank lines",        self.ignoreBlankLinesVar),
    ("Ignore leading whitespace", self.ignoreLeadingWhitespaceVar),
    ("Ignore interior whitespace",self.ignoreInteriorWhitespaceVar),
    ("Make whitespace visible",   self.makeWhitespaceVisibleVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w")
    
spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="ekr.20031218072017.3848">w,f = gui.create_labeled_frame(pr,caption="Print options",relief="groove")

row = Tk.Frame(f)
row.pack(expand=1,fill="x")

b = Tk.Checkbutton(row,text="Stop after",variable=self.stopAfterMismatchVar)
b.pack(side="left",anchor="w")

self.countEntry = e = Tk.Entry(row,width=4)
e.pack(side="left",padx=2)
e.insert(01,"1")

lab = Tk.Label(row,text="mismatches")
lab.pack(side="left",padx=2)

for padx,text,var in (    
    (0,  "Print matched lines",           self.printMatchesVar),
    (20, "Show both matching lines",      self.printBothMatchesVar),
    (0,  "Print mismatched lines",        self.printMismatchesVar),
    (0,  "Print unmatched trailing lines",self.printTrailingMismatchesVar) ):
    
    b = Tk.Checkbutton(f,text=text,variable=var)
    b.pack(side="top",anchor="w",padx=padx)
    self.printButtons.append(b)
    
# To enable or disable the "Print both matching lines" button.
b = self.printButtons[0]
b.configure(command=self.onPrintMatchedLines)

spacer = Tk.Frame(f)
spacer.pack(padx="1i")</t>
<t tx="ekr.20031218072017.3849">for text,command in (
    ("Compare files",      self.onCompareFiles),
    ("Compare directories",self.onCompareDirectories) ):
    
    b = Tk.Button(lower,text=text,command=command,width=18)
    b.pack(side="left",padx=6)</t>
<t tx="ekr.20031218072017.4059"></t>
<t tx="ekr.20031218072017.4060"></t>
<t tx="ekr.20031218072017.4061"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4062">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4063"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20031218072017.4064"></t>
<t tx="ekr.20031218072017.4065">def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()</t>
<t tx="ekr.20031218072017.4066"></t>
<t tx="ekr.20031218072017.4067"></t>
<t tx="ekr.20031218072017.4068">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20031218072017.4069">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20031218072017.4070"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20031218072017.4071"></t>
<t tx="ekr.20031218072017.4072">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4073">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4074"></t>
<t tx="ekr.20031218072017.4075">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20031218072017.4076">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20031218072017.4077">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20031218072017.4078">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20031218072017.4079">def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)</t>
<t tx="ekr.20031218072017.4080">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20031218072017.4081"></t>
<t tx="ekr.20031218072017.4082">def getInsertPoint(self,t):

    return t.index("insert")</t>
<t tx="ekr.20031218072017.4083">def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)</t>
<t tx="ekr.20031218072017.4084"></t>
<t tx="ekr.20031218072017.4085">def getSelectionRange (self,t):

    return t.tag_ranges("sel")</t>
<t tx="ekr.20031218072017.4086">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20031218072017.4088">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20031218072017.4089">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20031218072017.4090"></t>
<t tx="ekr.20031218072017.4091">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4092">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4093">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4094">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4095">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4096">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20031218072017.4097"></t>
<t tx="ekr.20031218072017.4098">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self,command,name):
    
    # The first parameter must be event, and it must default to None.
    def menuCallback(event=None,self=self,command=command,label=name):
        __pychecker__ = '--no-argsused' # event not used, and must be present.
        
        c = self.c
        return c.doCommand(command,label)

    return menuCallback</t>
<t tx="ekr.20040117171654"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    # if g.app.tracePositions:
        # g.trace("%-25s %-25s %s" % (
            # g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.c,self.v,self.stack,trace=False)</t>
<t tx="ekr.20040321065415">def findNodeInTree(c,p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(c,headline):
    
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(c,headline):
    
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 beta 1, build %s, January 17, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.374 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040715155607">def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""

    if g.app.unitTesting:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False</t>
<t tx="ekr.20040722132104"></t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20040803072955.11">def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget(['text','all'],t) # Text *must* be in the list.
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("&lt;Control-t&gt;",self.onControlT)

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p=p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t</t>
<t tx="ekr.20040803072955.16">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.expanded_click_area = c.config.getBool("expanded_click_area")
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')
        # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.trace = False
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.useBindtags = True
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are unchanging positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {} # Keys are vnodes, values are Tk.Text widgets
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = {} # Keys are vnodes, values are Tk.Text widgets
    self.freeUserIcons = []</t>
<t tx="ekr.20040803072955.17">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20040803072955.18"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20040803072955.19"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20040803072955.28">def headWidth(self,p=None,s=''):

    """Returns the proper width of the entry widget for the headline."""
    
    if p: s = p.headString()

    return self.font.measure(s)/self.font.measure('0')+1

    
def widthInPixels(self,s):

    s = g.toEncodedString(s,g.app.tkEncoding)
    
    return self.font.measure(s)</t>
<t tx="ekr.20040803072955.71"></t>
<t tx="ekr.20040803072955.72">def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True</t>
<t tx="ekr.20040803072955.73">def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t</t>
<t tx="ekr.20040803072955.74">def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    # 7/28/04: Not doing this translation was the real bug.
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId: return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None</t>
<t tx="ekr.20040803072955.75">def edit_widget (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
    
edit_text = edit_widget # For compatibility.</t>
<t tx="ekr.20040803072955.76"># Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c
    
    if p and c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.visibleText.get(p.v,[])
        for p2,t2,id2 in pairs:
            assert t2.leo_window_id == id2
            assert t2.leo_position == p2
            if p.equal(p2):
                # g.trace('found',t2)
                return t2
        
    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20040803072955.78"></t>
<t tx="ekr.20040803072955.79">def onClickBoxClick (self,event):
    
    c = self.c
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
            if p.isExpanded(): p.contract()
            else:              p.expand()
            self.active = True
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20040803072955.80"></t>
<t tx="ekr.20040803072955.81">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040803072955.82">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20040803072955.83">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.84"></t>
<t tx="ekr.20040803072955.85">def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20040803072955.86"># This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20040803072955.87">def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    # g.trace(p.headString())
    
    c.setLog()
    
    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headclick")

    return "continue"</t>
<t tx="ekr.20040803072955.88">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20040803072955.89">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.90"></t>
<t tx="ekr.20040803072955.91"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20040803072955.94"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20040803072955.99"></t>
<t tx="ekr.20040803072955.100">def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20040803072955.101"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.</t>
<t tx="ekr.20040803072955.102">def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20040803072955.103">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20040803072955.104">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20040803072955.105">def OnActivateHeadline (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(p.headString())

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20040803072955.106">if p == c.currentPosition():
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus()
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        c.frame.bodyWantsFocus()

self.active = True</t>
<t tx="ekr.20040803072955.108">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        c.beginUpdate()
        try:
            tree.endEditLabel()
            tree.dimEditLabel()
        finally:
            c.endUpdate(False)</t>
<t tx="ekr.20040803072955.109">def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
        
    
</t>
<t tx="ekr.20040803072955.110">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20040803072955.111">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()</t>
<t tx="ekr.20040803072955.112">def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)</t>
<t tx="ekr.20040803072955.113">table = (
    ("&amp;Read @file Nodes",c.readAtFileNodes),
    ("&amp;Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&amp;Tangle",c.tangle),
    ("&amp;Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &amp;Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&amp;Paste Node",c.pasteOutline),
    ("&amp;Delete Node",c.deleteOutline),
    ("-",None),
    ("&amp;Insert Node",c.insertHeadline),
    ("&amp;Clone Node",c.clone),
    ("Sort C&amp;hildren",c.sortChildren),
    ("&amp;Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)</t>
<t tx="ekr.20040803072955.114">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20040803072955.115">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20040803072955.116">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.frame.widgetWantsFocus(menu)</t>
<t tx="ekr.20040930075711">@nocolor

Leo can't represent some files using nodes!

I call this the "underindented blank line" problem.

Example:

@color

class aClass:
    def spam(): pass
# comment line
    def eggs(): pass
    
@nocolor

Leo's import code can't handle this:
    
- If the import code puts the comment line in a node, the line won't be output with the proper indentation!!

- Having the comment line stop the scanning of aClass is even worse.

- This usually shows up with an unindented blank line instead of the comment line.</t>
<t tx="ekr.20041005105605.99">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return
        
    # Bug fix: Append any whitespace following the tag to tag.
    while s and s[0] in (' ','\t'):
        tag = tag + s[0] ; s = s[1:]

    if end:
        # Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace('tag',repr(tag),'start',repr(start),'s',repr(s))
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []</t>
<t tx="ekr.20041111114148"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)</t>
<t tx="ekr.20041111114944"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    c.setLog()
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"</t>
<t tx="ekr.20041111115908">def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20050102094729">def callTagHandler (bunch,tag,keywords):
    
    handler = bunch.fn ; moduleName = bunch.moduleName

    # Make sure the new commander exists.
    if tag == 'idle':
        for key in ('c','new_c'):
            c = keywords.get(key)
            if c:
                # Make sure c exists and has a frame.
                if not c.exists or not hasattr(c,'frame'):
                    print 'skipping tag: c does not exists or does not have a frame.'
                    return None

    # Calls to registerHandler from inside the handler belong to moduleName.
    global loadingModuleNameStack
    loadingModuleNameStack.append(moduleName)
    result = handler(tag,keywords)
    loadingModuleNameStack.pop()
    return result</t>
<t tx="ekr.20050104123726.1">@ Here is the Python 2.4 documentation for rename (same as Python 2.3)

Rename the file or directory src to dst.  If dst is a directory, OSError will be raised.

On Unix, if dst exists and is a file, it will be removed silently if the user
has permission. The operation may fail on some Unix flavors if src and dst are
on different filesystems. If successful, the renaming will be an atomic
operation (this is a POSIX requirement).

On Windows, if dst already exists, OSError will be raised even if it is a file;
there may be no way to implement an atomic rename when dst names an existing
file.</t>
<t tx="ekr.20050107085710.1">def test_g_utils_rename():

    __pychecker__ = '--no-reimport'

    import os
    exists = g.os_path_exists
    
    path = g.os_path_join(g.app.testDir,'xyzzy')
    if exists(path):
        os.remove(path)
        
    assert not exists(path)
    assert not g.utils_remove(path,verbose=False)
    
    f = file(path,'w')
    f.write('test')
    f.close()
    
    assert exists(path)
    assert g.utils_remove(path,verbose=True)
    assert not exists(path)</t>
<t tx="ekr.20050210082320">def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050501111900">@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."</t>
<t tx="ekr.20050506084734"># This is at.write specialized for scripting.

def writeFromString(self,root,s,forcePythonSentinels=True):
    
    """Write a 4.x derived file from a string.
    
    This is used by the scripting logic."""
    
    at = self ; c = at.c
    c.endEditing(restoreFocus=True) # Capture the current headline, but don't change the focus!

    at.initWriteIvars(root,"&lt;string-file&gt;",
        nosentinels=False,thinFile=False,scriptWrite=True,toString=True,
        forcePythonSentinels=forcePythonSentinels)

    try:
        at.openFileForWriting(root,at.targetFileName,toString=True)
        # Simulate writing the entire file so error recovery works.
        at.writeOpenFile(root,nosentinels=False,toString=True,fromString=s)
        at.closeWriteFile()
        # Major bug: failure to clear this wipes out headlines!
        # Minor bug: sometimes this causes slight problems...
        if root: root.v.t.tnodeList = [] 
    except:
        at.exception("exception preprocessing script")

    return at.stringOutput</t>
<t tx="ekr.20050512031131"></t>
<t tx="ekr.20050618045715">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
    t.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
    t.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("&lt;Button-4&gt;", PropagateButton4)
    t.bind("&lt;Button-5&gt;", PropagateButton5)
    t.bind("&lt;MouseWheel&gt;", PropagateMouseWheel)

</t>
<t tx="ekr.20050707085637">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3237845
By: eichin

First, I'd like to thank Mr. Ream for presenting at EuroPython; I've been an
emacs user 'forever' (anyone else remember CCA emacs?) and have seen enough
"this could change your world as much as emacs did" sorts of comments, finally
seeing it on-screen live finally kicked me into trying it myself.

My overall experience was mixed; some of this may be due to my laziness (I just
unpacked 4-3-1 on my mac and ran src/leo.py, which got me a window so I counted
it as working.)  I did the original version of this in leo to attempt to get
some experience with it...

I am an emacs user.  So of course, I will use emacs bindings first - and since
some of them work (c-f, c-b) I get in trouble because the others then don't
(c-p pops up a python shell, c-a does something dramatic.)  *definitely* needs
at least a simple "you're an emacs user, here is basic editing in emacs bindings,
the leo-specific stuff is pushed out of the way."  Note that this is not actually
odd for a mac user - most of the basic emacs bindings work in text entry boxes,
like the Safari textarea I'm typing this in now - I'm not asking for m-x, but
for c-f/c-b/c-n/c-p/c-a/c-e and maybe a few more, but those are key.

Pure keyboard usage is also key - one thing that worried me watching the demo
was that Mr. Ream kept switching back and forth, keyboard to mouse, and that's
bad - and when I say bad, I mean that Raskin's book had a good footnote pointing
to a clinical study showing that RSIs correllated with *mouse* usage, not keyboard
usage, in a mainstream computer user context.  Note that I don't really mean
emacs-level keyboard-only use - just that in a typical hour of leo usage, I
shouldn't need the mouse for anything I use twice.  Having unusual stuff only
menus is fine.  Not having keybindings that I could find for *next-node* and
*prev-node* is *not* fine.  Frankly, just logging everything *you* use in an
hour and adding bindings for it might be enough...

Similarly, think of simple use-cases/workflows and make them easier.  Can node-titles
actually be multiple lines?  If not, why not have hitting return in a node title
take me to the text window? (This is just one example I tried and was surprised
didn't work.)  More critically, I couldn't find any keystroke at all to take
me from editing nodes to editing text, but I may have been confused at that
point.

For another, mac-specific case: *don't steal system bindings*.  M-`
(command-backtick, in macspeak) should cycle windows (M-~ the other direction.)
Breaking this dooms you on the Mac; even if that's an important binding on other
platforms, you just *have* to make it different on the mac - or you will only
have cross platform occasional mac users and *never* have any users who are
primarily mac users.  I suppose I should submit that one as a direct bug report.

Minor nit - on startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.

Defaulting to python-mode: sure, maybe it's just coloring, but coming into it
expecting it to be primarily a text-in-outlines editor, that confused me a lot.
I don't actually have an answer here - you can't cheat the way emacs does and
use an extension or #! line to decide "this is python code", though you may
be able to use other tricks - but a first time user is probably going to start
with bits of text and *then* move on to code, and if there's a sane way to support
that, please consider it.

More mac nits: two HELP menus, one is empty; "open leo docs.leo" from the help
menu gives a window that doesn't fit on-screen on my mac (tiger 10.4.1 12" powerbook)
and this leaves the resize control off-screen, so I can't fix it either.

Also (not so mac specific, but more glaring on the mac than elsewhere) - no
context-menu on nodes or text, and I couldn't seem to drag nodes with the mouse
at all (one of the things the mouse *is* obviously useful for, especially if
I'm doing a bunch of rearrangement in one place and *not* going back and forth.)

Finally, one comment from the talk that bothered me for a while and didn't click
until later - "emacs doesn't really have an outline mode".  This is true, at
face value - outline mode in fact is just some regexp and hiding kludging, powerful
in it's own way but not "deep".  However, the operations felt familiar, and
it wasn't until I went home and checked mail that I caught it -- *GNUS* is actually
surprisingly close in function set to an outliner.  Not in any immediately useful
way, but it both clarifies why I think emacs could work this way *and* possibly
clarifies why gnus users are so engaged by the interface :-)  Though that does
mean gnus might be a reasonable source of suggestions for key bindings...

Again, thanks for the demo.  It at least inspired a lot of interest, if not
actually a new convert, but I'll be watching more closely, at least.

_Mark_</t>
<t tx="ekr.20050713105353"></t>
<t tx="ekr.20050713105353.1">@nocolor

I have looked into leo's code and managed to figure out how to change 
some fonts. Here's what I did to change the menu fonts for example.

Fonts for the menu can be set in Code-&gt;Gui Tkinter classes-&gt;@thin 
leoTkinterMenu.py-&gt;Tkinter menu bindings-&gt;Routines with Tk 
spellings-&gt;new_menu

so to use the system font (linux) I changed the return statement to:

return Tk.Menu(parent,tearoff=tearoff, font=("System",11))

I'll try using .leo_xresources file and see if that works as well.</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050916180203"></t>
<t tx="ekr.20050920084036.54">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.moveSpotNode = None # A tnode.
    self.moveSpot = None # For retaining preferred column when moving up or down.
    self.moveCol = None # For retaining preferred column when moving up or down.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20050920084036.55">def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20050920084036.87">def deleteNextChar (self,event):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return

    name = g.app.gui.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    end = w.index('end-1c')
    # g.trace(i,j,'end',w.index('end-1c'))
    
    if name.startswith('body'):
        self.beginCommand()

    changed = True
    if i != j:
        w.delete(i,j)
    elif j != end:
        w.delete(i)
    else:
        changed = False
        
    if name.startswith('body'):
        self.endCommand(changed=changed)</t>
<t tx="ekr.20050920084036.102">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20050920084036.116">def scrollDown (self,event):
    self.scrollHelper(event,'down',extend=False)

def scrollDownExtendSelection (self,event):
    self.scrollHelper(event,'down',extend=True)

def scrollUp (self,event):
    self.scrollHelper(event,'up',extend=False)

def scrollUpExtendSelection (self,event):
    self.scrollHelper(event,'up',extend=True)</t>
<t tx="ekr.20050920084036.131">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20050920084036.136">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20050920084036.137">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    ins = w.index('insert')
    # sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20050920084036.140">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20050920084036.148">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20050920084036.149">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20050920084036.188">def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            # g.trace(f,name)
            return self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2</t>
<t tx="ekr.20050920084036.189">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':          f.abortEditLabelCommand,
    'about-leo':                    c.about,
    'add-comments':                 c.addComments,     
    'cascade-windows':              f.cascade,
    'clear-recent-files':           c.clearRecentFiles,
    'close-window':                 c.close,
    'contract-or-go-left':          c.contractNodeOrGoToParent,
    'check-python-code':            c.checkPythonCode,
    'check-all-python-code':        c.checkAllPythonCode,
    'check-outline':                c.checkOutline,
    'clear-recent-files':           c.clearRecentFiles,
    'clone-node':                   c.clone,
    'close-find-dialog':            c.dismissFindPanel, # Deprecated.
    'contract-node':                c.contractNode,
    'contract-all':                 c.contractAllHeadlines,
    'contract-parent':              c.contractParent,
    'convert-all-blanks':           c.convertAllBlanks,
    'convert-all-tabs':             c.convertAllTabs,
    'convert-blanks':               c.convertBlanks,
    'convert-tabs':                 c.convertTabs,
    'copy-node':                    c.copyOutline,
    'copy-text':                    f.copyText,
    'cut-node':                     c.cutOutline,
    'cut-text':                     f.cutText,
    'de-hoist':                     c.dehoist,
    'delete-comments':              c.deleteComments,
    'delete-node':                  c.deleteOutline,
    'demote':                       c.demote,
    'dump-outline':                 c.dumpOutline,
    'edit-headline':                c.editHeadline,
    'end-edit-headline':            f.endEditLabelCommand,
    'equal-sized-panes':            f.equalSizedPanes,
    'execute-script':               c.executeScript,
    'exit-leo':                     g.app.onQuit,
    'expand-all':                   c.expandAllHeadlines,
    'expand-next-level':            c.expandNextLevel,
    'expand-node':                  c.expandNode,
    'expand-and-go-right':          c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':           c.expandNodeOrGoToFirstChild,
    'expand-prev-level':            c.expandPrevLevel,
    'expand-to-level-1':            c.expandLevel1,
    'expand-to-level-2':            c.expandLevel2,
    'expand-to-level-3':            c.expandLevel3,
    'expand-to-level-4':            c.expandLevel4,
    'expand-to-level-5':            c.expandLevel5,
    'expand-to-level-6':            c.expandLevel6,
    'expand-to-level-7':            c.expandLevel7,
    'expand-to-level-8':            c.expandLevel8,
    'expand-to-level-9':            c.expandLevel9,
    'export-headlines':             c.exportHeadlines,
    'extract':                      c.extract,
    'extract-names':                c.extractSectionNames,
    'extract-section':              c.extractSection,
    'find-dialog-change':           c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':       c.replaceAll,           # Deprecated.
    'find-dialog-find-next':        c.findNext,             # Deprecated.
    'find-dialog-find-previous':    c.findPrevious,         # Deprecated.
    'flatten-outline':              c.flattenOutline,
    'go-back':                      c.goPrevVisitedNode,
    'go-forward':                   c.goNextVisitedNode,
    'goto-first-node':              c.goToFirstNode,
    'goto-first-sibling':           c.goToFirstSibling,
    'goto-last-node':               c.goToLastNode,
    'goto-last-sibling':            c.goToLastSibling,
    'goto-last-visible':            c.goToLastVisibleNode,
    'goto-line-number':             c.goToLineNumber,
    'goto-next-changed':            c.goToNextDirtyHeadline,
    'goto-next-clone':              c.goToNextClone,
    'goto-next-marked':             c.goToNextMarkedHeadline,
    'goto-next-node':               c.selectThreadNext,
    'goto-next-sibling':            c.goToNextSibling,
    'goto-next-visible':            c.selectVisNext,
    'goto-parent':                  c.goToParent,
    'goto-prev-node':               c.selectThreadBack,
    'goto-prev-sibling':            c.goToPrevSibling,
    'goto-prev-visible':            c.selectVisBack,
    'hoist':                        c.hoist,
    'import-at-file':               c.importAtFile,
    'import-at-root':               c.importAtRoot,
    'import-cweb-files':            c.importCWEBFiles,
    'import-derived-file':          c.importDerivedFile,
    'import-flattened-outline':     c.importFlattenedOutline,
    'import-noweb-files':           c.importNowebFiles,
    'indent-region':                c.indentBody,
    'insert-node':                  c.insertHeadline,
    'insert-body-time':             c.insertBodyTime,
    'insert-headline-time':         f.insertHeadlineTime,
    'mark':                         c.markHeadline,
    'mark-changed-items':           c.markChangedHeadlines,
    'mark-changed-roots':           c.markChangedRoots,
    'mark-clones':                  c.markClones,
    'mark-subheads':                c.markSubheads,
    'match-bracket':                c.findMatchingBracket,
    'minimize-all':                 f.minimizeAll,
    'move-outline-down':            c.moveOutlineDown,
    'move-outline-left':            c.moveOutlineLeft,
    'move-outline-right':           c.moveOutlineRight,
    'move-outline-up':              c.moveOutlineUp,
    'new':                          c.new,
    'open-compare-window':          c.openCompareWindow,
    'open-find-dialog':             c.showFindPanel, # Deprecated.
    'open-leoDocs-leo':             c.leoDocumentation,
    'open-leoPlugins-leo':          c.openLeoPlugins,
    'open-leoSettings-leo':         c.openLeoSettings,
    'open-online-home':             c.leoHome,
    'open-online-tutorial':         c.leoTutorial,
    'open-offline-tutorial':        f.leoHelp,
    'open-outline':                 c.open,
    'open-python-window':           c.openPythonWindow,
    'open-with':                    c.openWith,
    'outline-to-CWEB':              c.outlineToCWEB,
    'outline-to-noweb':             c.outlineToNoweb,
    'paste-node':                   c.pasteOutline,
    'paste-retaining-clones':       c.pasteOutlineRetainingClones,
    'paste-text':                   f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                      c.promote,
    'read-at-file-nodes':           c.readAtFileNodes,
    'read-outline-only':            c.readOutlineOnly,
    'redo':                         c.undoer.redo,
    'reformat-paragraph':           c.reformatParagraph,
    'remove-sentinels':             c.removeSentinels,
    'replace':                      c.replace,
    'replace-then-find':            c.replaceThenFind,
    'resize-to-screen':             f.resizeToScreen,
    'revert':                       c.revert,
    'save-file':                    c.save,
    'save-file-as':                 c.saveAs,
    'save-file-to':                 c.saveTo,
    'select-all':                   f.body.selectAllText,
    'settings':                     c.preferences,
    'set-colors':                   c.colorPanel,
    'set-font':                     c.fontPanel,
    'show-invisibles':              c.viewAllCharacters,
    'sort-children':                c.sortChildren,
    'sort-siblings':                c.sortSiblings,
    'tangle':                       c.tangle,
    'tangle-all':                   c.tangleAll,
    'tangle-marked':                c.tangleMarked,
    'toggle-active-pane':           f.toggleActivePane,
    'toggle-angle-brackets':        c.toggleAngleBrackets,
    'toggle-split-direction':       f.toggleSplitDirection,
    'undo':                         c.undoer.undo,
    'unindent':                     c.dedentBody,
    'unmark-all':                   c.unmarkAll,
    'untangle':                     c.untangle,
    'untangle-all':                 c.untangleAll,
    'untangle-marked':              c.untangleMarked,
    'weave':                        c.weave,
    'write-at-file-nodes':          c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':           c.fileCommands.writeOutlineOnly,
}</t>
<t tx="ekr.20050920084036.203">def _executeMacro (self,macro,w):

    k = self.k

    for z in macro:
        if len(z) == 2:
            w.event_generate('&lt;Key&gt;',keycode=z[0],keysym=z[1])
        else:
            meth = z [0].lstrip('&lt;').rstrip('&gt;')
            bunchList = k.bindingsDict.get(meth,[])  ### Probably should not strip &lt; and &gt;
            if bunchList:
                b = bunchList[0]
                ev = Tk.Event()
                ev.widget = w
                ev.keycode = z [1]
                ev.keysym = z [2]
                ev.char = z [3]
                k.masterCommand(ev,b.f,'&lt;%s&gt;' % meth)</t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    
    self.forward = True
    self.regexp = False

    # For replace-string and replace-regexp
    self._sString = ''
    self._rpString = ''
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':            self.hideFindTab,
        'open-find-tab':            self.openFindTab,
        'find-tab-find':            self.findTabFindNext,
        'find-tab-find-prev':       self.findTabFindPrev,
        'find-tab-change':          self.findTabChange,
        'find-tab-change-all':      self.findTabChangeAll,
        'find-tab-change-then-find':self.findTabChangeThenFind,

        'isearch-forward':          self.isearchForward,
        'isearch-backward':         self.isearchBackward,
        'isearch-forward-regexp':   self.isearchForwardRegexp,
        'isearch-backward-regexp':  self.isearchBackwardRegexp,
        
        're-search-forward':        self.reSearchForward,
        're-search-backward':       self.reSearchBackward,
        
        'search-forward':           self.searchForward,
        'search-backward':          self.searchBackward,
        'word-search-forward':      self.wordSearchForward,
        'word-search-backward':     self.wordSearchBackward,
    }</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.frame.minibufferWantsFocus()</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    s = k.getLabel(ignorePrompt=True)
    # g.trace(forward,repr(s))
    if s:
        try:
            if forward:
                i = w.search(s,"insert + 1c",stopindex='end',regexp=regexp)
                if not i:
                    # Start again at the top of the buffer.
                    i = w.search(s,'1.0',stopindex='insert',regexp=regexp)
            else:
                i = w.search(s,'insert',backwards=True,stopindex='1.0',regexp=regexp)
                if not i:
                    # Start again at the bottom of the buffer.
                    i = w.search(s,'end',backwards=True,stopindex='insert',regexp=regexp)
            
        except: pass

        if i and not i.isspace():
            w.mark_set('insert',i)
            w.see('insert')</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w ; keysym = event.keysym
    if keysym == 'Control_L': return
    
    c.frame.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        if 0: # Doesn't do anything at present.
            &lt;&lt; do a non-incremental search &gt;&gt;
        k.resetLabel()
        k.clearState()
        return

    if event.char == '\b':
        g.trace('backspace not handled yet')
        return
    
    if event.char:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        z = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if not z:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d
    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20050920084036.267"></t>
<t tx="ekr.20050920084036.268">def plainSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w ; i = w.index('insert')

    try:
        if forward:
            s = w.search(pattern,i,stopindex='end')
            if s: s = w.index('%s +%sc' % (s,len(pattern)))
        else:
            s = w.search(pattern,i,stopindex='1.0',backwards=True)
    except Exception:
        return

    if s:
        w.mark_set('insert',s)</t>
<t tx="ekr.20050920084036.269">def searchBackward (self,event):

    k = self.k ; state = k.getState('search-backward')
    if state == 0:
        k.setLabelBlue('Search Backward: ',protect=True)
        k.getArg(event,'search-backward',1,self.searchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=False)

def searchForward (self,event):

    k = self.k ; state = k.getState('search-forward')
    if state == 0:
        k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,'search-forward',1,self.searchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.272">def wordSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w ; i = w.index('insert')
    words = pattern.split()
    sep = '[%s%s]+' % (string.punctuation,string.whitespace)
    pattern = sep.join(words)
    cpattern = re.compile(pattern)
    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        if not match: return
        end = match.end()
    else:
        txt = w.get('1.0','insert') #initially the reverse words formula for Python Cookbook was going to be used.
        a = re.split(pattern,txt) #that didnt quite work right.  This one apparently does.
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return
        
    s = g.choose(forward,'insert +%sc','insert -%sc')
    w.mark_set('insert',s % end)
    w.see('insert')
</t>
<t tx="ekr.20050920084036.274">def reSearchBackward (self,event):

    k = self.k ; state = k.getState('re-search-backward')
    if state == 0:
        k.setLabelBlue('Regexp Search backward:',protect=True)
        k.getArg(event,'re-search-backward',1,self.reSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=False)

def reSearchForward (self,event):

    k = self.k ; state = k.getState('re-search-forward')
    if state == 0:
        k.setLabelBlue('Regexp Search:',protect=True)
        k.getArg(event,'re-search-forward',1,self.reSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.275">def reSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w
    cpattern = re.compile(pattern)

    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        end = match.end()
    else:
        # The reverse words formula for Python Cookbook didn't quite work.
        txt = w.get('1.0','insert') 
        a = re.split(pattern,txt)
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return

    if end:
        s = g.choose(forward,'insert +%sc','insert -%sc')
        w.mark_set('insert',s % end)
        w.see('insert')</t>
<t tx="ekr.20050920085536.11">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20050920085536.12">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunchList = k.bindingsDict.get(shortcut,[])
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        &lt;&lt; bind callback to shortcut in pane &gt;&gt;
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        k.bindingsDict [shortcut] = bunchList
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20050920085536.41">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20050920085536.45">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    trace = c.config.getBool('trace_masterCommand')
    c.setLog()
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    k.func = func
    k.funcReturn = None # For unit testing.
    if commandName is None:
        commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None or ch != '' # or stroke != '&lt;Key&gt;'
    
    if trace and interesting:
        g.trace(
            'stroke:',stroke,'ch:',repr(ch),'keysym:',repr(keysym),
            'widget:',w and g.app.gui.widget_name(w),
            g.callers())

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        # Note: k.funcReturn is for k.simulateCommand.
        if commandName.startswith('leoCallback') or commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920085536.75">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = stroke.lstrip('&lt;').rstrip('&gt;')
        bunchList = k.bindingsDict.get(stroke,[])
        if bunchList:
            b = bunchList[0]
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)</t>
<t tx="ekr.20050921094025">@nocolor</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.1">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
        
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20050928144501.1"></t>
<t tx="ekr.20050929114218"></t>
<t tx="ekr.20051001050607">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20051001051355"></t>
<t tx="ekr.20051002111614">def wordSearchBackward (self,event):

    k = self.k ; state = k.getState('word-search-backward')
    if state == 0:
        k.setLabelBlue('Word Search Backward: ',protect=True)
        k.getArg(event,'word-search-backward',1,self.wordSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=False)

def wordSearchForward (self,event):

    k = self.k ; state = k.getState('word-search-forward')
    if state == 0:
        k.setLabelBlue('Word Search: ',protect=True)
        k.getArg(event,'word-search-forward',1,self.wordSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20051002120125">s = k.getLabel(ignorePrompt=True)

if s:
    if self.forward:
        if self.regexp: self.reSearchForward(event)
        else:           self.searchForward(event)
    else:
        if self.regexp: self.reSearchBackward(event)
        else:           self.searchBackward(event)</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
&lt;&lt; set self.unboundKeyAction &gt;&gt;</t>
<t tx="ekr.20051006125633"></t>
<t tx="ekr.20051006125633.1">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        def menuFuncCallback (event,command=command,commandName=commandName):
            return command(event)

        def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke,commandName=commandName)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20051007080058">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings()
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    # k.add_ekr_altx_commands()
    k.checkBindings()</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20051008134059">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20051008135051.1">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20051008152134">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        #('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        # ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        # ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        # ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        # ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        # ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        # g.trace(commandName,bunchList)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20051010062551.1">@nocolor
@

ivars:

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are *lists* of g.bunch(func,name,warningGiven)

not an ivar (computed by computeInverseBindingDict):

inverseBindingDict
    keys are emacs command names, values are *lists* of shortcuts.</t>
<t tx="ekr.20051011072049.2">def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20051011072903.2">def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20051011072903.5">def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20051011103654">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20051012053017.4">** Important: search headline option.
    
[iqr] incremental,query,regex
[fb] forward,back
[w] word
[c] case-sensitive
[hat] headline,all,body
[osn] outline,subtree,node

*Set defaults for all the above using commands.
set-word-search-on/off
set-search-case-on/off
set-regexp-search-on/off
set-wrap-search-on/off
set-search-scope-to-outline/subtree/node

** Search mode: Control keys could change these options *after* starting the search command.

- Script-search commands
script-search  (can we abort the search somehow?)
set-find-script
set-change-script

Apply incremental search commands to headlines.  This might be fast, but is it useful if nodes aren't visible?</t>
<t tx="ekr.20051012062458.1">- Review the posting about making positions permanent, or recording vnode
indicies. It's probably time to do this.

- Make sure there is some way of executing script find/changes.

-@link-unl/url/etc.

- Put About dialog (all? dialogs) in tab.

- Create minibuffer commands to close tabs by name.

- the cycle-focus command should cycle through all log tabs.

- Something cool that can be bound to alt-tab.

- Strip quotes from color, font settings.

- Specify &amp; for most menu items.</t>
<t tx="ekr.20051012201831">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    keys = k.bindingsDict.keys() ; keys.sort()

    c.frame.log.clearTab('Command')
    for key in keys:
        bunchList = k.bindingsDict.get(key,[])
        for b in bunchList:
            pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
            s = k.prettyPrintKey(key) + pane
            g.es('%-30s\t%s' % (s,b.commandName),
                tabName='Command')</t>
<t tx="ekr.20051014061332">def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c
    
    c.frame.log.clearTab('Command')
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    for commandName in commandNames:
        shortcutList = inverseBindingDict.get(commandName,[''])
        for shortcut in shortcutList:
            g.es('%-30s\t%s' % (commandName,k.prettyPrintKey(shortcut)),
                tabName='Command')</t>
<t tx="ekr.20051014152256">Improve import code so it handles stufff like this from Ipyton/iplib

### This should *not* terminate the function!

    self.LOGHEAD = Itpl(
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = $self.rc.opts
#log# args = $self.rc.args
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
""")

- Handle blanks better in imports:
    - Add tab_width keyword arg to import command.
    - Convert tabs to blanks if tab width &lt; 0.
- Ignore position of blank lines wrt sentinels.
- Ignore (optionally?) underindented blank lines.
- Use pyclbr to parse Python imports?</t>
<t tx="ekr.20051014170754.1">def getShortcutForCommandName (self,commandName):
    
    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == commandName:
                    return key
    return ''
    
def getShortcutForCommand (self,command):
    
    k = self ; c = k.c
    
    if command:
        for key in k.bindingsDict:
            bunchList = k.bindingsDict.get(key,[])
            for b in bunchList:
                if b.commandName == command.__name__:
                    return key
    return ''</t>
<t tx="ekr.20051015110547">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(shortcut)),color='blue')
    else:
        if verbose:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20051016155819"></t>
<t tx="ekr.20051017212057">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    if t:
        t.delete('1.0','end')
        # Necessary to allow focus to move *out* of t.
        t.update()</t>
<t tx="ekr.20051017212452"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):
    
    k = self ; c = k.c ; s = k.getLabel() 
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        for commandName in k.mb_tabList:
            shortcutList = inverseBindingDict.get(commandName,[''])
            for shortcut in shortcutList:
                g.es('%s %s' % (commandName,k.prettyPrintKey(shortcut)),tabName='Completion')

    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051018070524">def computeInverseBindingDict (self):

    k = self ; d = {}
    
    # keys are minibuffer command names, values are shortcuts.
    for shortcut in k.bindingsDict.keys():
        bunchList = k.bindingsDict.get(shortcut,[])
        for b in bunchList:
            shortcutList = d.get(b.commandName,[])
            bunchList = k.bindingsDict.get(shortcut,[g.Bunch(pane='all')])
            for b in bunchList:
                # g.trace(shortcut,repr(b.pane))
                pane = g.choose(b.pane=='all','','[%s]' % (b.pane))
                s = '%s %s' % (k.prettyPrintKey(shortcut),pane)
                if s not in shortcutList:
                    shortcutList.append(s)
            d [b.commandName] = shortcutList

    return d</t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)
        
    self.findTabHandler.bringToFront()</t>
<t tx="ekr.20051020120306.1">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020120306.2">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020120306.3">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020120306.4">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20051020120306.5"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind.leoFind):

    """A class that implements Leo's tkinter find tab."""

    @others</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None # To keep pychecker happy.
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020120306.12">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)

    for w in buttons:
        w.bindHotKey(ftxt)
        w.bindHotKey(ctxt)</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

# Use bigger boxes for scripts.
self.find_ctrl = ftxt = Tk.Text(
    fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
self.change_ctrl = ctxt = Tk.Text(
    cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") 
ftxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    c = self.c
    c.frame.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&amp;Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap &amp;Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ('Clone Find All',  self.dict['clone_find_all']),
    ("Mark Finds",      self.dict["mark_finds"]),
    ("Mark &amp;Changes",   self.dict["mark_changes"]),
    ('Show Context',    self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051020120306.19">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020120306.20">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020120306.21">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20051020120306.22">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.frame.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.frame.widgetWantsFocus(t)</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"</t>
<t tx="ekr.20051020120306.28">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20051022094136"># Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or '').lower(),[])

if shortcut == '&lt;Key&gt;':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        # if shortcut == '&lt;Return&gt;': g.trace(g.app.gui.widget_name(w),shortcut,callback)
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20051022141020">def onTreeClick (self,event=None):
    
    c = self.c
    
    c.setLog()
    self.frame.treeWantsFocus()

    return 'break'</t>
<t tx="ekr.20051022162730">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['log','text','all'],w)</t>
<t tx="ekr.20051022211617"></t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20051023083258">def callers (n=5,excludeCaller=True):
    
    '''Return a list containing the callers of the function that called g.callerList.
    
    By default, the function that called g.callerList is not on the list,
    which is what is wanted when using g.trace.'''
    
    result = []
    while n &gt; 0:
        s = g.callerName(n)
        if s == 'callers':
            if excludeCaller and result:
                del result [-1]
            break
        elif s:
            result.append(s)
        n -= 1
        
    return ','.join(result)
</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-all', self.changeAllCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)</t>
<t tx="ekr.20051023182326">def copyBindingsToWidget (self,paneOrPanes,w):
    
    '''Copy all bindings for the given panes to widget w.
    
    paneOrPanes may be  pane name (a string) or a list of pane names in priority order.'''
    
    # g.trace(paneOrPanes,g.app.gui.widget_name(w))

    k = self ; d = k.bindingsDict
    bindings = {}
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes
    # g.trace(panes)

    for shortcut in keys:
        shortcutsBunchList = []
        for pane in panes:
            old_panes = bindings.get(shortcut,[])
            assert(type(old_panes)==type([]))
            if old_panes and pane in old_panes:
                # This should have been caught earlier, but another check doesn't hurt.
                g.trace('*** redefining %s in %s' % (shortcut,pane))
            else:
                bunchList = d.get(shortcut,[])
                for bunch in bunchList:
                    if bunch.pane == pane:
                        shortcutsBunchList.append(bunch)
                        old_panes.append(pane)
                        bindings [shortcut] = old_panes
        # Create bindings for the shortcut in all panes.
        if shortcutsBunchList:
            self.copyBindingsHelper(shortcutsBunchList,shortcut,w)        
                                
    # Bind all other keys to k.masterCommand.
    def generalTextKeyCallback (event,k=self):
        k.masterCommand(event,func=None,stroke='&lt;Key&gt;',commandName=None)

    w.bind('&lt;Key&gt;',generalTextKeyCallback)</t>
<t tx="ekr.20051023183028">def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'</t>
<t tx="ekr.20051023192433"></t>
<t tx="ekr.20051024102724"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['text','tree','all'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.change()
    
def changeAllCommand (self,event=None):
    c = self.c
    self.setup_command(c)
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.changeThenFind()</t>
<t tx="ekr.20051025071455">@others
</t>
<t tx="ekr.20051025071455.1">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others</t>
<t tx="ekr.20051025071455.6">class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others

</t>
<t tx="ekr.20051025071455.7"></t>
<t tx="ekr.20051025071455.8">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = c.config.getString('aspell_dir')
    self.aspell_bin_dir = c.config.getString('aspell_bin_dir')

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)
        
    self.aspell = aspell
    if aspell:
        self.sc = aspell.spell_checker(prefix=self.aspell_dir,lang=local_language_code)
        self.local_language_code = local_language_code
        self.local_dictionary_file = local_dictionary_file
        self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file) [0]</t>
<t tx="ekr.20051025071455.10">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; original count offset: miss, miss, ... 
    None: 
    # original offset 
    simplifyed to not create the string then make a list from it    
    """

    if self.sc.check(word):
        return None
    else:
        return self.sc.suggest(word)</t>
<t tx="ekr.20051025071455.11">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False</t>
<t tx="ekr.20051025071455.16">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d</t>
<t tx="ekr.20051025071455.18">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others</t>
<t tx="ekr.20051025071455.19"></t>
<t tx="ekr.20051025071455.20">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()</t>
<t tx="ekr.20051025071455.22">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20051025071455.23">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')</t>
<t tx="ekr.20051025071455.24"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="ekr.20051025071455.29"></t>
<t tx="ekr.20051025071455.30">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()</t>
<t tx="ekr.20051025071455.31">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()</t>
<t tx="ekr.20051025071455.32">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
</t>
<t tx="ekr.20051025071455.33">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    self.find()
    self.updateButtons()
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025071455.34">def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()</t>
<t tx="ekr.20051025071455.36"></t>
<t tx="ekr.20051025071455.37">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.38">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.frame.widgetWantsFocus(t)
            return True

    # The focus must never leave the body pane.
    c.frame.widgetWantsFocus(t)
    return False</t>
<t tx="ekr.20051025071455.40">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.frame.bodyWantsFocus()
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])</t>
<t tx="ekr.20051025071455.41">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.42"></t>
<t tx="ekr.20051025071455.43">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')</t>
<t tx="ekr.20051025071455.44">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1) 

</t>
<t tx="ekr.20051025071455.45">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word</t>
<t tx="ekr.20051025071455.46">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue</t>
<t tx="ekr.20051025071455.47"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as .  I don't know what the solution is.
    word_start = string.letters
    word_end   = string.letters + string.digits
    word_chars = string.letters + string.digits + "`" + "'" + "_"
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and line[i] not in word_start:
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.</t>
<t tx="ekr.20051025071455.48">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None</t>
<t tx="ekr.20051025071455.49">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)</t>
<t tx="ekr.20051025071455.50">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.frame.bodyWantsFocus()
</t>
<t tx="ekr.20051025071455.51">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025071455.52">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')</t>
<t tx="ekr.20051025080056">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.</t>
<t tx="ekr.20051025080420">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }</t>
<t tx="ekr.20051025080420.1"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.frame.bodyWantsFocus()

def ignore (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()</t>
<t tx="ekr.20051025080633">def openSpellTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()</t>
<t tx="ekr.20051025094004">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = Aspell(c,dictionaryFileName,self.local_language_code)
    
    if not self.aspell.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
</t>
<t tx="ekr.20051025120920">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget(['text','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
           </t>
<t tx="ekr.20051025121408">def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []</t>
<t tx="ekr.20051025144611"></t>
<t tx="ekr.20051025144611.1">@nocolor</t>
<t tx="ekr.20051025144611.2">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="ekr.20051025144611.3">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="ekr.20051025144611.4">&lt;&lt; docstring &gt;&gt;
&lt;&lt;imports&gt;&gt;
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;

#These two global determine if the autocompleter and calltip systems are used.  Default is on.
useauto = 1
usecall = 1

&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others</t>
<t tx="ekr.20051025144611.5">'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''</t>
<t tx="ekr.20051025144611.6">## import leoTkinterFrame 

import sets 
import threading
import weakref</t>
<t tx="ekr.20051025144611.7">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.</t>
<t tx="ekr.20051025144611.8">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="ekr.20051025144611.10">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information

context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode</t>
<t tx="ekr.20051025144611.11">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.</t>
<t tx="ekr.20051025144611.12">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20051025144611.13">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
</t>
<t tx="ekr.20051025144611.14"># This section defines patterns for calltips.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats ['python'] = re.compile(r'def\s+%s' % end)

pats ['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
        space, space, end))

pats ['perl'] = re.compile(r'sub\s+%s' % end)

pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (space,end))

pats ['c'] = re.compile(r'\w+%s%s' % (space,end))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits + string.letters + r

ripout = string.punctuation + string.whitespace + '\n'
ripout = ripout.replace('_','')

okchars = {}
for z in string.ascii_letters:
    okchars [z] = z
okchars ['_'] = '_'</t>
<t tx="ekr.20051025144611.15">def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20051025144611.16">watchitems = ('.',')')
txt_template = '%s%s%s'

def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.
    Certain chars activate the text scanning code.'''
    global lang
    if not (event.char.isspace() or event.char in watchitems):
        return
        
@
This if statement ensures that attributes set in another node are put in the
database.Of course the user has to type a whitespace to make sure it happens.
We try to be selective so that we dont burn through the scanText def for  every
whitespace char entered.This will help when the nodes become big.
@c
    bCtrl = event.widget
    if event.char.isspace():
        # Do nothing if the previous char was a whitespace
        if bCtrl.get('insert -1c').isspace(): return
        if bCtrl.get('insert -1c wordstart -1c') != '.': return
    c = bCtrl.commander
    lang = c.frame.body.getColorizer().language
    txt = txt_template % (
        bCtrl.get("1.0",'insert'),
        event.char, bCtrl.get('insert',"end"))
        # Add the newest char; its not in the bCtrl yet
    scanText(txt)</t>
<t tx="ekr.20051025144611.17">def scanText (txt):

    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)</t>
<t tx="ekr.20051025144611.18">def scanForAutoCompleter (txt):
    
    '''This function scans text for the autocompleter database.'''

    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b )
            # we are using the experimental DictSet class here.
            # usage removed the above statements
            # notice we have cut it down to one line of code here!</t>
<t tx="ekr.20051025144611.19">def scanForCallTip (txt):

    '''this function scans text for calltip info'''

    # pat2 = pats['python']
    # if lang:
        # if pats.has_key(lang):
            # pat2 = pats[lang]

    pat2 = pats.get(lang or 'python')
    g2 = pat2.findall(txt) or []

    for z in g2:
        if isinstance(z,tuple):
            z = z [0]
        pieces2 = z.split('(')
        pieces2 [0] = pieces2 [0].split() [ -1]
        a, b = pieces2 [0], pieces2 [1]
        calltips [lang][a].add(z)</t>
<t tx="ekr.20051025144611.20">def makeAutocompletionList (a,b,glist):
    
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 

</t>
<t tx="ekr.20051025144611.21">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20051025144611.22">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20051025144611.23">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
</t>
<t tx="ekr.20051025144611.24">#These functions determine if the config and language files have been read or not.
# No need to read it more than once.

def hasReadConfig():
    return configfilesread

def setReadConfig():
    global configfilesread
    configfilesread = True</t>
<t tx="ekr.20051025144611.25">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20051025144611.26">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="ekr.20051025144611.27">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20051025144611.28">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20051025144611.29">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20051025144611.30">def unbind (context):

    '''This method turns everything off and removes the calltip and autobox from the canvas.'''

    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map(context.unbind,(
            "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;", "&lt;Alt_R&gt;"))
        context.unbind_all('&lt;Button&gt;')
        context.update_idletasks()</t>
<t tx="ekr.20051025144611.31">def moveSelItem (event, context ):

    '''Move the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1  ## Can't be correct.
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:
        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="ekr.20051025144611.32">def processKeyStroke (event,context,body):

    '''Take action based on the state of context (a Tk.Canvas) and the event'''
    
    autobox = context.autobox

    if not context.on or event.keysym in ("??","Shift_L","Shift_R"):
        return None
    elif testForUnbind(event,context):
        unbind(context)
        return None
    elif context.which == 1:
        return None # It is calltip time.
        
    index = body.index('insert-1c wordstart')
    pat = body.get(index,'insert') + event.char
    pat = pat.lstrip('.')
    ww = list(autobox.get(0,'end'))
    aList = reducer(ww,pat)
    if not aList: return None
    # Select which item to select based on what the user has typed.
    i = ww.index(aList[0])
    # Set the current selection to match what the user has typed.
    autobox.select_clear(0,'end') 
    autobox.select_set(i)
    autobox.see(i)
    return 'break'</t>
<t tx="ekr.20051025144611.33">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="ekr.20051025144611.34">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20051025144611.35">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="ekr.20051025144611.36">def add_bindings( context, body ):
    
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''
    
    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )
</t>
<t tx="ekr.20051025144611.37">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20051025144611.38">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20051025144611.39">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20051025144611.40">def newCreateControl (self,frame,parentFrame):
    '''A decoration of the createControl def.
    We set up the ancestory of the control so we can draw
    widgets over the Text editor without disturbing the text.'''

@
Creating the background:
- We now use a placer: simpler to use and more efficient.
- We have to decorate the Tk.Text widget with a constructor that creates an
  intermediate Frame for the Text to be placed instead of packed.
  Had no idea that the placer could do this so nicely.
  With a couple changes in 3 places, we are using the placer !
@c
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init (self,master,*args,**kwords):

        context = Tk.Frame(master)
            #This is what we need to put in before the text to make place work.
        orig_init(self,context,*args,**kwords)

    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame,parentFrame) #orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init

    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack(expand=1,fill='both',after=frame.bodyBar) #We have to add it to the environment, since we pass on it in the __init__
    body.place(relwidth=1.0,relheight=1.0)
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets(context)
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler (event,context=context,body=body):
        processKeyStroke(event,context,body)
    def addItemHandler (event,context=context,body=body,colorizer=frame.body):
        add_item(event,context,body,colorizer.getColorizer())

    for z in (watcher,processKeyStrokeHandler,addItemHandler):
        context.bind("&lt;Key&gt;",z,'+')

    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr(context,'autobox'):
        ignore.append(context.autobox.component('listbox'))
        ignore.append(context.autobox.component('vertscrollbar'))
    def do_unbind (event):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind(context)

    context.do_unbind = do_unbind

    # This part protects this plugin from others that use Alt-Up, Alt-Down.
    # The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt (event):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ('&lt;Alt-Up&gt;','&lt;Alt-Down&gt;'): context.block_alt.bind(z,block_alt)

    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append(context.bindtags()[0])
    ctags.append(context.block_alt.bindtags()[0])
    ctags.extend(body.bindtags())
    body.bindtags(tuple(ctags))

    return body

</t>
<t tx="ekr.20051025144611.41">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []

    if useauto:
        context.autobox = Pmw.ScrolledListBox(
            context ,hscrollmode='none',
            listbox_selectbackground='#FFE7C6',
            listbox_selectforeground='blue',
            listbox_background='white',
            listbox_foreground='blue',
            vertscrollbar_background='#FFE7C6',
            vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):
        #This def makes removing the autobox or calltip label easy.
        # No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()

    context.clean_editor = clean_editor</t>
<t tx="ekr.20051025144611.42">def onOpenWindow ():

    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="ekr.20051025170832"></t>
<t tx="ekr.20051025170832.1"></t>
<t tx="ekr.20051026083544">def handleDefaultChar(self,event):
    
    c = self.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)

    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = self.unboundKeyAction
        if action in ('insert','replace'):
            c.editCommands.selfInsertCommand(event,action=action)
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20051026083544.2">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20051026092433.1">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return
    
    name = g.app.gui.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(i,j)

    if name.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=changed)
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20051026092746">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20051028061611.1">Revise:
    moveWordHelper
    findNextMatch

- Options to tell search commands whether search a single node, a subtree or the entire outline.

- (Maybe) a default-search-command.

- Expand 'point' so it indicates node as well as text location.</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051101161545"></t>
<t tx="ekr.20051103091115.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3411067
By: rogererens

Also, in the settings of Find/Change, I would choose for grouping the settings
node_only, search_body, search_headline, wrap (and possibly the whole_word option
also) together under search extent radio buttons. Although this organizational
mode mentions radio buttons, check boxes are used for selection_only and
suboutline_only, which I can enable both at the same time.
It's also not (yet?) very clear to me how selection_only, suboutline_only, node_only
(should) interact...</t>
<t tx="ekr.20051104051733">FocusIn does nothing for Label widgets.

http://sourceforge.net/forum/message.php?msg_id=3412640
By: btheado

Currently clicking on the minibuffer and typing text has no effect.  Kinda confusing
until the Alt-x binding I discovered that Alt-x is the way to access the minibuffer
command mode.

It would be nice if the &lt;FocusIn&gt; binding on the minibuffer widget were equivilent
to Alt-x.</t>
<t tx="ekr.20051104075904.4">def doTests(c,all,verbosity=1):

    p = c.currentPosition() ; p1 = p.copy()
    
    g.app.unitTesting = True
    try:
        g.app.unitTestDict["fail"] = False
    
        if all: theIter = c.all_positions_iter()
        else:   theIter = p.self_and_subtree_iter()
        
        # c.undoer.clearUndoState() # New in 4.3.1.
        changed = c.isChanged()
        suite = unittest.makeSuite(unittest.TestCase)
    
        for p in theIter:
            if isTestNode(p):
                test = makeTestCase(c,p)
                if test: suite.addTest(test)
            elif isSuiteNode(p):
                test = makeTestSuite(c,p)
                if test: suite.addTest(test)
    
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=verbosity).run(suite)
        c.setChanged(changed) # Restore changed state.
        # Restore the selected node unless overridden.
        if g.app.unitTestDict.get('restoreSelectedNode',True):
            c.selectPosition(p1)
    finally:
        g.app.unitTesting = False
        </t>
<t tx="ekr.20051104075904.5">class generalTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20051104075904.6">def __init__ (self,c,p):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.p = p.copy()
</t>
<t tx="ekr.20051104075904.7">def fail (self,msg=None):

    """Mark a unit test as having failed."""
    
    __pychecker__ = '--no-argsused'
        #  msg needed so signature matches base class.

    import leoGlobals as g

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20051104075904.8">def setUp (self):

    c = self.c ; p = self.p

    c.selectPosition(p)</t>
<t tx="ekr.20051104075904.9">def tearDown (self):

    pass

    # To do: restore the outline.</t>
<t tx="ekr.20051104075904.10">def runTest (self,define_g = True):

    c = self.c ; p = self.p.copy()
    script = g.getScript(c,p).strip()
    self.assert_(script)

    # Execute the script. Let unit test handle any errors!
    
    if define_g:
        # Execute the test in an environment containing c, g &amp; p.
        exec script + '\n' in {'c':c,'g':g,'p':p}
    else:
        # Execute the test in a totally pristine environment.
        exec script + '\n' in {}</t>
<t tx="ekr.20051104075904.11">def shortDescription (self):

    return self.p.headString() + '\n'</t>
<t tx="ekr.20051104075904.12">@ This code executes the script in an @suite node.  This code assumes:
- The script creates a one or more unit tests.
- The script puts the result in g.app.scriptDict["suite"]
@c

def makeTestSuite (c,p):

    """Create a suite of test cases by executing the script in an @suite node."""
    
    p = p.copy()

    h = p.headString()
    script = g.getScript(c,p).strip()
    if not script:
        print "no script in %s" % h
        return None

    try:
        exec script + '\n' in {'c':c,'g':g,'p':p}
        suite = g.app.scriptDict.get("suite")
        if not suite:
            print "%s script did not set g.app.scriptDict" % h
        return suite
    except:
        g.trace('Exception creating test cases for %s' % p.headString())
        g.es_exception()
        return None</t>
<t tx="ekr.20051104075904.13">def makeTestCase (c,p):
    
    p = p.copy()

    if p.bodyString().strip():
        return generalTestCase(c,p)
    else:
        return None</t>
<t tx="ekr.20051104075904.15"># A utility for use by script buttons.

def runTimerOnNode (c,p,count):

    s = p.bodyString().rstrip() + '\n'
    
    # A kludge so we the statement below can get c and p.
    g.app.unitTestDict = {'c':c,'p':p}
    
    # This looks like the best we can do.
    setup = 'import leoGlobals as g; c = g.app.unitTestDict.get("c"); p = g.app.unitTestDict.get("p")'

    t = timeit.Timer(s,setup)

    try:
        if count is None:
            count = 1000000
        result = t.timeit(count)
        print "count: %d time/count: %f %s" % (count,result/count,p.headString())
    except:
        t.print_exc()</t>
<t tx="ekr.20051104075904.33">def numberOfClonesInOutline (self):

    """Returns the number of cloned nodes in an outline"""

    c = self.c ; n = 0
    for p in c.allNodes_iter():
        if p.isCloned():
            n += 1
    return n</t>
<t tx="ekr.20051104075904.34">def numberOfNodesInOutline (self):

    """Returns the total number of nodes in an outline"""

    return len([p for p in self.c.allNodes_iter()])</t>
<t tx="ekr.20051104075904.42">def runLeoTest(c,path,verbose=False,full=False):

    frame = None ; ok = False ; old_gui = g.app.gui

    try:
        g.app.unitTesting = True
        ok, frame = g.openWithFileName(path,c,enableLog=False)
        assert(ok and frame)
        errors = frame.c.checkOutline(verbose=verbose,unittest=True,full=full)
        assert(errors == 0)
        ok = True
    finally:
        g.app.gui = old_gui
        if frame and frame.c != c:
            g.app.closeLeoWindow(frame.c.frame)
        c.frame.top.update()
        g.app.unitTesting = True

    if not ok: raise</t>
<t tx="ekr.20051104075904.69">def makeEditBodySuite(c):

    """Create an Edit Body test for every descendant of testParentHeadline.."""

    p = c.currentPosition()
    u = testUtils(c)
    assert p.exists(c)
    data_p = u.findNodeInTree(p,"editBodyTests")
    assert(data_p)
    temp_p = u.findNodeInTree(data_p,"tempNode")
    assert(temp_p)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in data_p.children_iter():
        if p.headString()=="tempNode": continue # TempNode now in data tree.
        before = u.findNodeInTree(p,"before")
        after  = u.findNodeInTree(p,"after")
        sel    = u.findNodeInTree(p,"selection")
        ins    = u.findNodeInTree(p,"insert")
        if before and after:
            test = editBodyTestCase(c,p,before,after,sel,ins,temp_p)
            suite.addTest(test)
        else:
            print 'missing "before" or "after" for', p.headString()

    return suite</t>
<t tx="ekr.20051104075904.78">def makeImportExportSuite(c,parentHeadline,doImport):

    """Create an Import/Export test for every descendant of testParentHeadline.."""

    u = testUtils(c)
    parent = u.findNodeAnywhere(parentHeadline)
    assert(parent)
    temp = u.findNodeInTree(parent,"tempNode")
    assert(temp)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)

    for p in parent.children_iter(copy=True):
        if p == temp: continue
        dialog = u.findNodeInTree(p,"dialog")
        assert(dialog)
        test = importExportTestCase(c,p,dialog,temp,doImport)
        suite.addTest(test)

    return suite</t>
<t tx="ekr.20051104075904.89">def runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=False):
        
    __pychecker__ = '--no-shadowbuiltin' # input is a builtin.

    # The contents of the "-input" and "-input-after" nodes define the changes.

    p = c.currentPosition()
    u = testUtils(c)
    input           = u.findNodeInTree(p,"-input")              # i file: before the change.
    input_ins       = u.findNodeInTree(p,"-input-after")        # j file: after the change.
    output_sent     = u.findNodeInTree(p,"-output-sent")        # fat file -&gt; i file.
    out_after_sent  = u.findNodeInTree(p,"-output-after-sent")  # Should match result.
    result          = u.findNodeInTree(p,"-result")
    ilines          = u.findNodeInTree(p,"-i_lines")
    jlines          = u.findNodeInTree(p,"-j_lines")

    # Create the output nodes containing sentinels from the original input.
    u.writeNodesToNode(c,input,output_sent,sentinels=True)
    u.writeNodesToNode(c,input_ins,out_after_sent,sentinels=True)

    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension("foo.py")

    fat_lines = g.splitLines(output_sent.bodyString())
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    if input_ins.hasChildren():
        # Get the lines by stripping sentinels from -output-after-sent node.
        lines = g.splitLines(out_after_sent.bodyString()) 
        j_lines = mu.removeSentinelsFromLines(lines,delims)
    else:
        j_lines = g.splitLines(input_ins.bodyString()) 

    # For viewing...
    ilines.scriptSetBodyString(''.join(i_lines))
    jlines.scriptSetBodyString(''.join(j_lines))
    if ilines.bodyString() != input.bodyString():
        if not ignoreSentinelsInCompare:
            print "i_lines != input !"

    # Put the resulting lines (with sentinels) into the -result node.
    lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
    result.scriptSetBodyString(''.join(lines))

    if ignoreSentinelsInCompare:
        sList = []
        for s in (result.bodyString(),out_after_sent.bodyString()):
            lines = g.splitLines(s)
            lines = mu.removeSentinelsFromLines(lines,delims)
            sList.append(''.join(lines))
        return sList[0] == sList[1]
    else:
        return u.compareIgnoringNodeNames(
            result.bodyString(),
            out_after_sent.bodyString(),
            delims,verbose=True)</t>
<t tx="ekr.20051104152338"></t>
<t tx="ekr.20051104152338.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3413805
By: nobody

I thought this might be for 4.4a2, but I see the same effect w/ 
Leo 4.3.3, build  1.282 , September 17, 2005
Python 2.3.5, Tk 8.4.7, win32

I haven't used Leo for code, but just started to try to re-organize some Perl
I inherited.

Leo apears to remove sentinels, AND preceding newlines, so the effect is something
like this:

.... some code....

   next line;
}
#@ leo sentinel here...
#

    If  ( something ) {
      more code;
......

becomes:

.... some code....

   next line;
} If  ( something ) {
      more code;
......

Now, that may be annoying, but mildly so - it still runs.
When this:

#
#@ sentinel
if () {

turns to this:

# if() {

code just breaks.</t>
<t tx="ekr.20051105103233"></t>
<t tx="ekr.20051110155735.1">@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color</t>
<t tx="ekr.20051112075511">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3424153
By: rogererens

Perhaps you've got this already lurking, but let me offer one other suggestion:

When reverting the search direction, it would be better to place the cursor
'on the other side' of the current hit, and then proceed to find the next occurrence
of &lt;pattern&gt;. At the current state of affairs, searching in the reverse direction
first finds the current occurrence _again_, just placing the cursor on the other
side of the higlighted selection.

This suggestion is based on the way searching in Vim works.
</t>
<t tx="ekr.20051112080017">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?

EKR: This is on the list of unfixable bugs, but I have a hard time believing there is no workaround.</t>
<t tx="ekr.20051113090322">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)</t>
<t tx="ekr.20051121070552"></t>
<t tx="ekr.20051122104219">def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    k = self ; c = k.c
    
    if not key: return ''
    if len(key) == 1: return key
    if key.startswith('&lt;'):
        key = key[1:]
    if key.endswith('&gt;'):
        key = key[:-1]
    if not key: return ''
    ch = key[-1]
    
    ch,junk = c.frame.menu.canonicalizeShortcut(ch)

    if ch in string.ascii_uppercase:
        return '%sShift-%s&gt;' % (key[:-2],ch.lower())
    else:
        return key</t>
<t tx="ekr.20051126122638">- Use typing completion to select desired word.
- No auto-scan: use database instead.
- Scan button does manual scan.
- Use import or inspect instead of text scan.
- @strings autocompleter-info
list of names for which classes are known: c,frame,g,k,p,t,tree,v etc.
  (Autocompleter may already do this)
</t>
<t tx="ekr.20051126122952.1">def autoComplete (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    self.widget = w = event and event.widget 
    self.prefix = gui.getSelectedText(w) or ''
    self.text = gui.getAllText(w)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.
    self.membersList = c.commandsDict.keys() ## Testing only.
    k.setState('auto-completer',1,handler=self.stateHandler)
    self.computeCompletionList()</t>
<t tx="ekr.20051126123149">def computeCompletionList (self):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.frame.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    if s:
        self.tabList,common_prefix = g.itemsMatchingPrefixInList(s,self.membersList)
        c.frame.log.clearTab('Completion') # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            g.es('%s' % (name),tabName='Completion')</t>
<t tx="ekr.20051126123249">class autoCompleterCommandsClass (baseEditCommandsClass):
    
    '''Similar to typing completion in the minibuffer,
    but the presently selected completion is shown in the widget itself.'''

    @others</t>
<t tx="ekr.20051126123249.1">def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051126123759"></t>
<t tx="ekr.20051126123759.1">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.c = c
    self.k = c.keyHandler
    self.membersList = None
    self.prefix = None
    self.tabList = []
    self.tabListIndex = -1
    self.text = None # For Escape.
    self.widget = None</t>
<t tx="ekr.20051126123759.2">def getPublicCommands (self):

    k = self.k

    return {
        'auto-complete':    self.autoComplete,
    }</t>
<t tx="ekr.20051126124705">def stateHandler (self,event):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.widget
    keysym = event and event.keysym
    ch = event and event.char or ''
    # g.trace(repr(ch),repr(keysym))
    if keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.finish()
    elif keysym == 'Escape':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif ch in string.printable:
        self.extendSelection(ch)
        s = gui.getSelectedText(w)
        if s.startswith(self.prefix):
            self.prefix = self.prefix + ch
            # g.trace('prefix',self.prefix)
        self.computeCompletionList()</t>
<t tx="ekr.20051126125950">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""</t>
<t tx="ekr.20051126131103">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    self.prefix = self.prefix[:-1]
    self.setSelection(self.prefix)
    self.computeCompletionList()</t>
<t tx="ekr.20051126171929">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20051127065601">def extendSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
    else:
        i = j = gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127070018">def setSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = gui.getInsertPoint(w)
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127105102">def finish (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    i,j = gui.getTextSelection(w)
    if i != j:
        gui.setTextSelection(w,j,j)</t>
<t tx="ekr.20051127105431">def abort (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    
    c.frame.widgetWantsFocus(w)

    w.delete('1.0','end')
    w.insert('1.0',self.text)
    gui.setTextSelection(w,'1.0','1.0')</t>
<t tx="ekr.20051129095023"></t>
<t tx="ekr.20051202094427">Investigate meld:  http://meld.sourceforge.net/</t>
<t tx="ekr.20051202095626">Use docstrings as the help message.</t>
<t tx="ekr.20051202100658"></t>
<t tx="ekr.20051202102337">@nocolor</t>
<t tx="ekr.20051202102337.1">auto-complete command is merely a prototype.</t>
<t tx="ekr.20051202102337.2">ok:

list-buffers

Not ready yet:

append-to-buffer
copy-to-buffer
insert-to-buffer
kill-buffer
prepend-to-buffer
rename-buffer       probably should change headline too
switch-to-buffer    use typing completion to get node name (headline)</t>
<t tx="ekr.20051202102337.3">advertised-undo
keyboard-quit
iconify-frame
save-buffers-kill-leo
shell-command
shell-command-on-region
suspend</t>
<t tx="ekr.20051202102337.4">back-sentence
back-to-indentation
backward-char
backward-delete-char
backward-kill-paragraph
backward-paragraph
backward-word
beginning-of-buffer
beginning-of-line
capitalize-word
center-line
center-region
count-region
cycle-focus
dabbrev-completion
dabbrev-expands
delete-char
delete-indentation
delete-spaces
downcase-region
downcase-word
end-of-buffer
end-of-line
escape
eval-expression
exchange-point-mark
fill-paragraph
fill-region
fill-region-as-paragraph
flush-lines
focus-to-body
focus-to-log
focus-to-minibuffer
focus-to-tree
forward-char
forward-paragraph
forward-sentence
forward-word
goto-char
goto-line
how-many
# Use indentBody in leoCommands.py
#indent-region
indent-relative
indent-rigidly
indent-to-comment-column
insert-newline
insert-parentheses
keep-lines
kill-paragraph
line-number
move-past-close
newline-and-indent
next-line
previous-line
remove-blank-lines
replace-regex
replace-string
reverse-region
scroll-down
scroll-up
select-paragraph
# Exists, but can not be executed via the minibuffer.
# self-insert-command
set-comment-column
set-fill-column
set-fill-prefix
set-mark-command
show-colors
show-fonts
# save-buffer
sort-columns
sort-fields
sort-lines
split-line
tabify
transpose-chars
transpose-lines
transpose-words
untabify
upcase-region
upcase-word
view-lossage
what-line</t>
<t tx="ekr.20051202102337.6">delete-file
diff
insert-file
make-directory
remove-directory
save-file</t>
<t tx="ekr.20051202102752.1">digit-argument
help
hide-mini-buffer
negative-argument
number-command
number-command-0
number-command-1
number-command-2
number-command-3
number-command-4
number-command-5
number-command-6
number-command-7
number-command-8
number-command-9
print-bindings
print-commands
repeat-complex-command
show-mini-buffer
toggle-mini-buffer
universal-argument</t>
<t tx="ekr.20051202102752.2">backward-kill-sentence
backward-kill-word
kill-line
kill-word
kill-sentence
kill-region
kill-region-save
yank
yank-pop
zap-to-character</t>
<t tx="ekr.20051202102752.3">call-last-keyboard-macro
end-kbd-macro
name-last-kbd-macro
load-file
insert-keyboard-macro 
start-kbd-macro</t>
<t tx="ekr.20051202102752.4">query-replace
query-replace-regex</t>
<t tx="ekr.20051202102752.5">clear-rectangle
close-rectangle
delete-rectangle
kill-rectangle
open-rectangle
string-rectangle
yank-rectangle</t>
<t tx="ekr.20051202102752.6">append-to-register
copy-rectangle-to-register
copy-to-register
increment-register
insert-register
jump-to-register
number-to-register not used: used copy-to-register insead.
point-to-register
prepend-to-register
view-register

To do:

point-to-register should write an 'expanded point' so inter-node jumps are possible.</t>
<t tx="ekr.20051202102752.7">hide-find-tab
open-find-tab
find-tab-find
find-tab-find-prev
find-tab-change
find-tab-change-then-find

isearch-forward
isearch-backward
isearch-forward-regexp
isearch-backward-regexp

re-search-forward
re-search-backward

search-forward
search-backward
word-search-forward
word-search-backward</t>
<t tx="ekr.20051202102752.8">ok:

hide-spell-tab
open-spell-tab
spell-find
spell-change
spell-change-then-find
spell-ignore</t>
<t tx="ekr.20051205093049">@nocolor

Working throught the IronPython tutorial just now I saw how useful the dir function could be, especially dir(object)

I'm thinking that Leo might use dir(object) to discover members for the auto-complete command.  It's not clear if or how this can be made to work, but it might be slick.</t>
<t tx="ekr.20051207130144">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3460955
By: nobody

I found this link:
http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html
TkinterDnD

so if Edward is interested in adding drag and drop support for regular leo,
this might be a path to do so.  It looks like an active project.

leouser
</t>
<t tx="ekr.20051207130144.1"></t>
<t tx="ekr.20051208081641"></t>
<t tx="ekr.20051208081641.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3465251
By: e

(fixed) after a save, undo last typing event
doesn't mark leo changed.
you can go up and down the undo redo list
and still the leo is not marked changed.
the changes in the body do stick.
didn't try other undo like insert node.

**Important**: the follows was likely due to improper calls to g.top()

(can't duplicate) I had a weird undo that I wasn't able to repeat
after a reboot, when I had 2 leos open and
and the undo after a save in one would display
the last undo in a node body from the other leo.
</t>
<t tx="ekr.20051213080533">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20051213094517">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20051214132256"></t>
<t tx="ekr.20051214133130">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)</t>
<t tx="ekr.20051214133130.1">def endCommand(self,label=None,changed=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b:
        name = b.name
        if name.startswith('body'):
            if changed:
                c.frame.body.onBodyChanged(undoType=b.undoType,
                    oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        elif name.startswith('head'):
            g.trace('Should not happen: endCommand does not support undo in headlines')
        else: pass
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    if label:
        k.setLabelGrey(label)
    else:
        k.resetLabel()</t>
<t tx="ekr.20051215102349">def beginCommandHelper (self,ch,undoType,w):

    p = self.c.currentPosition()
    name = g.app.gui.widget_name(w)
    
    # Bug fix 1/6/06 (after a5 released): don't do this in headlines!
    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
        
    return w</t>
<t tx="ekr.20051217135340.2"></t>
<t tx="ekr.20051217175058">show-chapters
hide-chapters
add-chapter
delete-this-chapter</t>
<t tx="ekr.20051218121447">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.frame.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20051218122116">def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
  
    # Move to the spot.
    w.mark_set('insert',spot)
    spot = w.index('insert')

    # Handle the selection.
    self.extendHelper(w,extend,ins1,spot)
    w.see(spot)</t>
<t tx="ekr.20051218133207">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20051218133207.1">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20051218141237">def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveUpOrDownHelper(event,'down',extend=False)
    # self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveUpOrDownHelper(event,'down',extend=True)
    #self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveUpOrDownHelper(event,'up',extend=False)
    #self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveUpOrDownHelper(event,'up',extend=True)
    #self.moveToHelper(event,'insert - 1line',extend=True)</t>
<t tx="ekr.20051218170358"></t>
<t tx="ekr.20051218171457">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20051218174113">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20051220062654">An alternative to test.leo!</t>
<t tx="ekr.20051220083410">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(commandName,shortcut,stroke)
    
    if pane == 'mini' and func != k.keyboardQuit:
        if 0:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)
    
            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)
    
            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)
    
            k.bindKey(pane,shortcut,keyCallback,commandName)
    
    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20051220144507">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20051221101851"></t>
<t tx="ekr.20051221101851.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3487424
By: p_michalczyk

Does anybody know how to double-click headline in outline panel using only keyboard
(that is how to simulate double-click through keyboard shortcut) ?
I need it to execute @run nodes from keyboard.

EKR: This can be done with @command nodes, but Leo should have official commands to do this too.</t>
<t tx="ekr.20060102092148.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3501193
By: nobody

::improving how Leo handle's arguments? 

Leo only needs a few simple options.
I don't think option handling would
work correctly in the IPYthon case either.

put optparse.py in leo/extensions for py2.2
docutils installs it if it isn't available.
its been the standard since py2.3
adding new options will be much less painfull.
some kind of --safe startup to allow editing
of leoSettings.leo, no @buttons or @scripts
might be a good thing.

Leo should allow scripts to set sys.argv for
commands they create. its very difficult to do now.

e</t>
<t tx="ekr.20060102092148.2">docutils installs it if it isn't available.
</t>
<t tx="ekr.20060102103625">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict
    
    # g.trace(modeDict.keys())

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060102103625.1">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Change the pane of all entries to 'mode-name'.
    # This will disable warnings about duplicate bindings.
    for key in d2.keys():
        bunchList = d2.get(key,[])
        for bunch in bunchList:
            bunch.pane = name
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060102135349.2">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName)
</t>
<t tx="ekr.20060103101524">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3501995
By: nobody

::But I don't understand why it's difficult to edit leoSettings.leo

--safe would use default settings,
maybe you set all body fg/bg to the same color
by mistake and you don't have a backup leoSettings to use. as a dumb example.

another nice option would be to override a setting
--set something=whatever
this could breakdown easy and on (older?) windows.
there is a limit to how many chars on a command line.
this would add another layer of choice
yet another chicken egg problem, 
parsing settings before settings can be parsed.

what about override @settings file, its a standard thing.
many people will expect this is possible 
and try it
or even leo.py -? 
help you get for free w/optparse.
--keys emacs anyone? 
especially the first time
untill you can get a chance to edit leoSettings.leo

I have already started enabling optparse
for leo.py so I can try various profile options.
I will post it when it works.

have to check how it handles filenames with spaces
seems that is all Leo is currently doing 
with multiple args, if there is no problem.
and later checking for -batch -script etc.

not to minimize how much work this would be.
parsing options is probably the least difficult part.

e</t>
<t tx="ekr.20060103102115">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3495741
By: stano_paska

Hi.

In plugin word_export encoding is defined:

encoding = dict.get("encoding",None)
if encoding == None:
    encoding = c.config.default_derived_file_encoding

I have default_derived_file_encoding set to UTF-8 but when exporting to word
some national characters are not encoded correctly (Slovak).

I think it is better get encoding for word from somewhere else.

In Slovak environment word uses cp1250.

When I used:

import sys
encoding = sys.getdefaultencoding() # 'cp1250'

everything goes fine.</t>
<t tx="ekr.20060104083551">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3488030

Some examples are:
selected text --&gt; press space bar.  A space is added to all the selected lines
at the beginning. tab does 4 spaces

selected text --&gt; hit back space.  A space is removed from the start of each
line.  If a space is not available in one of the lines, nothing is done.

selected text --&gt; hit keypad '-', selected text gets moved up one line.  The
selection is swapped with the line above it.  If we are at the top of a node,
the node identified by threadBack() is selected and the text is moved to the
bottom of the node.

selected text --&gt; hit keypad '+', selected text gets moved down one line.  The
selection is swapped with the line below it.  If we are at the bottom of the
node, the node identified by threadNext() is selected and the text is moved
to the top of the node.

in all cases of movement the text remains selected, even with node traversals.

- and + are arbitrary, you should be able to bind any key to these actions.
space, backspace and tab probably should always retain their convential meaning.

Also note, they we dont have to be in a mode to make this happen, it just happens.
So you can do keyboard selection or even mouse selection and it works.  What
matters is that something is selected.

Code wise, my implementation is totally based on the JTextPane's Document structure.
I rely heavily on the Paragraph Elements identified between the selection start
and end.  Im not sure what would be the equivilent in Tk.  The concept is clear
enough I hope that you could map out some functionality.  Having these large
structures to work with makes it much simpler to do the movement right.

leouser</t>
<t tx="ekr.20060104083736">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3488438
By: btheado

&gt; len(p.headString()) doesn't work for wide 
&gt; characters

According to this:
http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M15

"If the font doesn't have a uniform width then the width of the character '0'
is used in translating from character units to screen units."

Here is some Tcl code that can get an exact fit for the text widget width:

pack [text .t]
set font [.t cget -font]
set widechars WWWWWWWW
.t insert end $widechars
set strpixels [font measure $font $widechars]
set zeropixels [font measure $font 0]
set width [expr int(ceil(double($strpixels) / $zeropixels))]
.t configure -width $width


Summary of code: Set the width to be the pixel size of the text widget string
divided by the pixel size of the '0' char.
</t>
<t tx="ekr.20060104110233">def generalModeHandler (self,event,name=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c ; f = c.frame
    modeName = name or k.inputModeName or '&lt;no mode name&gt;'
    commandName = 'enter-' + modeName
    state = k.getState(modeName)
    keysym = event and event.keysym or ''
    # g.trace(modeName,'state',state)
    
    d = g.app.config.modeCommandsDict.get(commandName)
    if not d:
        k.clearState()
        if commandName.endswith('-mode'): commandName = commandName[:-5]
        k.setLabelGrey('@mode %s is not defined (or is empty)' % commandName)
    elif state == 0:
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(name,1,handler=k.generalModeHandler)
        k.setLabelBlue(name+': ',protect=True)
        k.modeCompletionList = d.keys()
    else:
        for key in d.keys():
            bunchList = d.get(key)
            for bunch in bunchList:
                if k.matchKeys(event,bunch.val):
                    func = c.commandsDict.get(key)
                    # g.trace('calling',func)
                    if key != 'mode-help':
                        # This must be done first because commands can change windows.
                        k.endCommand(event,k.stroke)
                        k.inputModeName = None
                        c.frame.log.deleteTab('Mode')
                        k.clearState()
                        k.resetLabel()
                        # k.setLabelGrey('top-level mode')
                        c.frame.widgetWantsFocus(k.modeWidget)
                    func(event)
                    return 'break'
        k.modeHelpHelper(d)
        f.minibufferWantsFocus()
        
    return 'break'</t>
<t tx="ekr.20060104125946">def modeHelpHelper (self,d):
    
    k = self ; c = k.c
    
    c.frame.log.clearTab('Mode')
    lines = []
    for key in d.keys():
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                lines.append('%-30s\t%s' % (key,k.prettyPrintKey(shortcut)))
    lines.sort()
    for line in lines:
        g.es(line,tabName='Mode')</t>
<t tx="ekr.20060104154937">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060104164523">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self

    if k.inputModeName:
        commandName = 'enter-' + k.inputModeName
        d = g.app.config.modeCommandsDict.get(commandName)
        k.modeHelpHelper(d)
    else:
        g.es('Not in any mode')





</t>
<t tx="ekr.20060105085031">defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
defaultAction.lower()
if defaultAction in ('insert','replace','ignore'):
    self.unboundKeyAction = defaultAction
else:
    g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
    self.unboundKeyAction = 'insert'</t>
<t tx="ekr.20060105133043"></t>
<t tx="ekr.20060105143454.1"></t>
<t tx="ekr.20060105143454.2"></t>
<t tx="ekr.20060106064618">A 'backward' delete at the start of a headline deletes the first character.
delete-char does not work in headlines.</t>
<t tx="ekr.20060106091831"></t>
<t tx="ekr.20060106091831.1"></t>
<t tx="ekr.20060106112159"># Every call was a potential bug.</t>
<t tx="ekr.20060106112915"></t>
<t tx="ekr.20060106114716"></t>
<t tx="ekr.20060106125608"></t>
<t tx="ekr.20060106125608.1"></t>
<t tx="ekr.20060106131142"></t>
<t tx="ekr.20060106172320"></t>
<t tx="ekr.20060106212914"></t>
<t tx="ekr.20060107082929">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3510448
By: ktenney

Howdy,

I'm executing a script in a Leo node which has
an indentation error. I get the following report,
which doesn't help locate the error.

Pardon me if this is well known issue, I don't
remember discussion of it.

Thanks,
Kent

################################################
exception executing script
Traceback (most recent call last):
  File "C:\python24\lib\site-packages\leo\src\leoCommands.py", line 1277, in
executeScript
    exec script in d
IndentationError: unindent does not match any outer indentation level (line
103)
--------------------
  line 1276:                     # g.trace(script)
* line 1277:                     exec script in d
  line 1278:                     if not script1 and not silent:
  line 1279:                         g.es("end of script",color="purple")

</t>
<t tx="ekr.20060107103157"></t>
<t tx="ekr.20060107104019"></t>
<t tx="ekr.20060107222329">@nocolor


- 
</t>
<t tx="ekr.20060107224249.1"></t>
<t tx="ekr.20060107231542">This could have been the source of weird find behavior.</t>
<t tx="ekr.20060107232924">The following would be major changes, with little benefit.

- Make leoGlobals a subclass of the commander.
    - There are many calls to to g.es in leoGlobals.py.

- Eliminate g.app.log.
    - It is dangerous, but g.es requires it.

- Eliminate g.scanErrors.
    - A laudable goal, but it's real messy.</t>
<t tx="ekr.20060108105607"># Leo now calls doCommand on all commands, so the 'command' hooks always get done.
# In addition, the normal processing in doCommand catches errors, etc.</t>
<t tx="ekr.20060108115434">The fix was to have x.getSelectedText return '' instead of None.</t>
<t tx="ekr.20060108115434.1">
AttributeError Exception in Tk callback
  Function: &lt;function allKeysCallback at 0x03463730&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x046801C0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 647, in allKeysCallback
    return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 763, in masterCommand
    k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 799, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 530, in stateHandler
    self.doTabCompletion()
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 457, in doTabCompletion
    if s.startswith(self.prefix) and self.tabList:
AttributeError: 'NoneType' object has no attribute 'startswith'

================================================
  Event contents:
    char:
    delta: 9
    height: ??
    keycode: 9
    keysym: Tab
    keysym_num: 65289
    num: ??
    serial: 197812
    state: 8
    time: 7154627
    type: 2
    widget: .62497976.62497136.17871136.17871376.body-pane
    width: ??
    x: 307
    x_root: 688
    y: 58
    y_root: 624</t>
<t tx="ekr.20060108120501">This is the easy way to do script finds!</t>
<t tx="ekr.20060108151437"># This includes k.masterCommand and all event handlers.
</t>
<t tx="ekr.20060109060505">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3510983
By: vpe

I realized it's not necessary to do int-float-int conversion to calculate width.
The result will be the same. So it's really simple:

width = font.measure(p.headString())/font.measure('0')+1

If font is not fixed-width, trailing space in headlines will vary between 0
pixels and width of char '0'.</t>
<t tx="ekr.20060109164136">def setLog (self):
    
    c = self

    if c.exists:
        try:
            # c.frame or c.frame.log may not exist.
            g.app.setLog(c.frame.log)
        except AttributeError:
            pass</t>
<t tx="ekr.20060109183500.1">execute-named-script executes script in leo/scripts.



does script_menu plugin exist? Yes!
    Where does it get scripts?</t>
<t tx="ekr.20060110070304"></t>
<t tx="ekr.20060110070304.1">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3514627
By: nobody

&lt;quote&gt;I suspect what you want is to elimate all the !text specifications in
the @shortcuts nodes. (just the !text part, not the whole binding!)&lt;/quote&gt;

Not neccessarialy, I just want to hinder that the body pane looses the focus
as soon as you press Ctrl-S for safe, or if you press ALT-DnArrow to skip to
the next node in the tree pane.The focus should stay in the body pane without
the need to explicitly give it back to it by mouse-click or Ctrl-T, but maybe
in the case of Ctrl-s that is a bug ?
Why should the body pane loose the focus by pressing Ctrl-S ?</t>
<t tx="ekr.20060110084342"></t>
<t tx="ekr.20060110084342.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3514294
By: sergio_101

i just started using Leo toinght, but i am having problems with the enter key..

unless i hit ctl-enter, i cannot get a lf/cr.. it seems almost like the enter
key is not active at all unless i hit ctl..</t>
<t tx="ekr.20060110084342.2"></t>
<t tx="ekr.20060110084342.3">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3514755

Leo Log Window...
Leo 4.4 alpha 5, build  1.358 , January 5, 2006
Python 2.3.4, Tk 8.4.3, Pmw 1.2
Windows 5, 1, 2600, 2, Service Pack 1

When I hit Ctrl-H to edit a headline, the entire headline is selected. Fine.
However, when I use an arrow key to move the cursor, the headline is _still_
selected. This is NOT Windows-standard action. What's happened?</t>
<t tx="ekr.20060110084745"># The report was mistaken.</t>
<t tx="ekr.20060110084745.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3514816

the cut&amp;paste doesn't mark leo dirty.
a cut then change of focus, does
an undo cleans up the mark again?</t>
<t tx="ekr.20060110093631"></t>
<t tx="ekr.20060110093631.1">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3509141
By: rich_ries

CLEO still does not remove markings. I set Priority -&gt; High, then tried Priority
-&gt; Clear. Arrow is still showing. Tried Clear All. Arrow is still showing.

FastGotoNode not working w/ ^SPC

Group Operations NEEDS the old KEY-BASED version -- try tagging a dozen nodes,
making a Mark, and cloning them using a mouse!!

Need How-to for Labels:
..Label to subnode
..label to subnodes
..labels to subnodes

may be clear to the programmer, but not to anyone else.
</t>
<t tx="ekr.20060110102039">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3505544
By: nobody

this topic deserves another thread, rather 
than hijack the IPython one in the main forum.

presently Leo has a few options documented,
--script has a required parameter filename
batch mode also requires a filename.
why are they not documented in the same place?
why is batch mode option called --script?
is it too late to change to --batch ?

filenames in windows that have spaces will 
have to be quoted if they follow an option.
otherwise there will be no telling the filename
after a --script from a possibly 'file name.leo'

luckily, there was no need to force everyone 
on windows to quote leo names or use -fsome.leo,
especially when other options aren't used.
a little tricky, but I think it works.

the --script could as well load the leo itself
for that matter maybe all the args after --script 
should be assumed to be part of the scripts options
and Leo should only process up to the --script fname.
maybe there can be another option to collect
options for the script to batch process.
not necessary to decide now.

optparse can verify option parameters 
with callbacks. like does a filename exist,
is there enough free diskspace etc etc.
and provide a standard usage menu on exit.
rather than a roll your own wherever it happens.
I am not familiar enough with Leo startup to say
how is the best way to verify filenames or to
pass the filenames to run or set ivars.
import leoGlobals as I have might not be possible
this early in startup. need to get version info too.

leo -script whatever.py  error or not? typo? fixable?
leo --script whatever.py is ['script', 'whatever.py'] 
coming up with a comprehensive set of input args and
expected outcomes will be necessary for testing.
I'll do that next.

what about encoding problems, should check optparse archive.
what about py2.2 using optparse from 2.4? trust but verify.
this also has to be well tested.

--help -? or -h all work.
wasn't able to mimic the /help  /?
windows world method of option entry.
probably someone knows how.
hope its not a registry setting!

profile options might only be available if you
enter -xpert mode, to avoid confusing anyone who 
thinks they may need to run it because it is there.
and be removed from the help menu as well.

here is the proof of concept leomain.py,
all it does is process commandline args and 
print what command it will run or var it will set.
nothing is actually opened or run.

$ \c\py\python22\python leomain.py some.leo
run(some.leo)

$ \c\py\python22\python leomain.py some.leo -P
profile(leoProfile.txt,some.leo)

$ python leomain.py -profile=/tmp/proFile.txt my favorite.leo
profile(rofile=/tmp/proFile.txt,my favorite.leo)

woops! not sure how to guard against that.
verifing is valid creatable filename could help.
that should have been:

$ python leomain.py --profile=/tmp/proFile.txt my favorite.leo
profile(/tmp/proFile.txt,my favorite.leo)

$ python leomain.py --script some.py some.leo
script some.py
run(some.leo)

$ python leomain.py --script some.py
script some.py
run()

that's the basics.
needless to add, some of the code default 
choices and wording of help messages 
will have to be fine tuned. 
have at it.

post a note if something breaks.
I know of a few typos already.

[http://rclick.netfirms.com/leomain.py.htm]

e
</t>
<t tx="ekr.20060110102239.1">@color
"""  to run, add your path to leo below if not already set.

proposed modification to leo.py for hprof or hotshot profile 
giving standard help options from the commandline
and making additional options or combinations less work.

using optparse for commandline parsing
for py2.2 will use optik if installed, but not critical
requires copy of optparse.py from py2.4 in leo/extensions
no problem for py2.3+ already in the stdlib
this also need seperate testing, unittests to follow.

to use from command or shell window:
python leomain.py some args, see what happens.
nothing except print will happen, no open or file creation.
presently use a copy of sys.argv but that would be mutated.
if something is not obvious it should be fixed.


comments presently are interspersed throughout the file
will be collected and shortened as bugs are removed.
getting all options and filenames correctly is complicated
by the possibility of unicode or spaces in filenames.
some options require filenames for later processing in run()
and a leo may be specified or even more than one at some point
wildcard handling is not especially cross platform compatible.

want to make it possible to enter filenames w/o quoting
but will be impossible for now for batch &amp; script option params.
they have to have quotes if there are spaces in the filenames on win.

also somewhat ambiguous, -sscript filename
will actually parse as --script cript filename
this could be a source of error and questions.
not sure if it can be avoided if there is to be longword args.

another point, -script is a possible typo to document at least.

a script like this could actually be some kind of leo launcher.
an option could popup a filedialog to get a leo, so it could in Leo.
or open the last leo that has been modified on the local filesystem.
as well as be a test bed for optparse &amp; profile, read from ini file.
not dependant on changing leo.py, just import leo, then leo.run(fname)

for scripting, ability to set argv should be possible somehow.
maybe set sys.argv = [] before run

maybe just breeze through argv trying to concatenate filenames
then try to parse it. and let parseopts save a copy
later calls to parseopts w/o argv will use the saved attribute copy.
probably passing opts+args to run() is cleaner though.


this is the kind of merge that can give cvs merge a bad name, 
good luck!
leoGlobals and change of sys.path used only for testing.
import leoGlobals may not work for the real leo.py this early
before g.app is created. some refactoring is inevitable

why check for win before trying to make filename w/spaces?
does other os not have problem w/spaces in argv w/o quotes?
and why win32? is there no win64 in Leo's user base
or does it not have the space problem w/argv
are single and double quotes around filename the same for other os?
for windows they don't work like double quotes.


the order of parameters might have to be significant
but as it is, the.leo can appear anywhere
and on win, all unused args are joined with spaces just in case
if you do strange stuff possibly you get what you ask for.

does Leo try to find filename.leo if filename is sans the extension?
does it cause an overwrite existing file y/n/c or pass silently overwriting?

-d datadir might be useful if you want to have other than the some.leo same dir
-set somesetting=this like for outline bg color in script playback mode

if leo is started from another shell, argv[0] might not be python or might be
it could be IPython or something else, but there might be its args
as well as the program it started that started Leo
so really, argv should be [find(leo.py'):]
and for some associations or os, no .py or .pyw required
for that matter import leo; leo.run() bypasses option parsing altogether!
this is another problem now that I think of it...
but only if you also expected to get --script or some other option parsed
if you import leo you probably know what you are doing
you would have to set some global options, args I guess is what __main__ will do.
searching to cut back sys.argv for python or python.exe leo etc etc 
is bound to failure, too many cross platform possibilities.

__file__ can also be unreliable when started from py2exe or freeze or a zip

can't so far get /h (a default windows help option) to trigger --help.
seems like if there is no -h option defined, -hanything gets help
could be a source of typo errors 
if other longword no param option started w/'h' 
optparse doesn't handle word-otherword conversion to word_otherword
may be reading the doc wrong on that.
but will handle -sb scriptfile batchfile combining
says -s outfile equivalent to --script=outfile
but what about --script outfile?
carefully avoiding too much smart processing.


hopefully a test suite will expose any anomalies.
the default help output has a few more inconsistencies.
strange there are no bug reports about it in 2 years!
also want to give default values in help, maybe there is a %default

help gets cutoff at 80 chars, 79 according to a lone bugtrack entry
but that was for optparse, nd maybe its base0 counting.
maybe its still bug tracked as optik.sf.net, the original project name.

for future editors, and I sense there will be future edits,
if an individual help entry is longer than ~79 it will get formated ok.


see if we can avoid the ridiculous problem on win where on error
you get an exit and see nothing unless started from console!
source of some forum traffic as well.
maybe, if sys.platform etc: raw_input('press any key to exit')
and for pythonw maybe should popup an alert somehow...
one can dream.

proof of concept, still missing pasing args to run somehow
or seetting an ivar or whatever to get script/batchmode filenames
from main to where it is required. that should be easy enough.



filename is be mandatory for both and it should exist
its checked for batch in leo.py already so checking should be more generic
haven't looked up where --script is processed
didn't rewtrite getbatchfile or whatever its called.
that will be replaced with a check if tobatch has a filename
decide if optparse callback should check for valid existing file
and exit or continue accordingly.

and for an opposing view, if you are scripting leo from another script
then want to enter script mode or batch mode
what has to be available is to intercept the call to read the file.
and pass it a string of the script or batch, w/o problem.
a seperate function instead of hardwireing the read at least.



if I've forgotten anything please post a note to the forums.
beyond that, I don't know what to tell you.
this is proto typical alpha proof of concept pseudo code
although tested somewhat and worked as I expect it to,
it can't be expected to do everything unforseen as well.
and I can't be sure some transmission error hasn't occured.
hold me harmless or hit delete now.

"""

#replace w/Leo's real version assuming it can be known this early
#won't be much use if its leo.py's version
__version__ = '4.4a5' #w06104p01:34 optparse &amp; profile for Leo

import sys, os

#####for testing use only, obviously don't add to leo.py
k = os.path.normpath(os.path.abspath(r"C:\c\leo\V43leos\leo-4-4-\src"))

#path being unicode can affect less than py2.3
if sys.version_info[:2] &lt; (2, 3):
    k = str(k)

#might not be found in sys path on win9x, there is no unicode paths
if k not in sys.path:
    sys.path.append(k)
del k
#needed in profile()too
import leoGlobals as g


@others

#replace from here to end, sans comments
if __name__ == "__main__":


@

    #print os.environ #('IPYTHON') #thought they had this!
    #there is no IPY env var when @run is used -p shell?
    #for IPy need to trim sys.argv
    #sys.argv = sys.argv[2:]
@c


    #not the final configuration FIXME FIXME, danger will robinson
    leofile = None
    argvtight = []

    #going to have to decide to build OptionParser seperatly
    #before parsing so concatate can have access to it.
    #concatate() should be here but is problematic
    #needs to know too much about options.

    #no sense if there are no options or no args.
    #there are ways this can fail though probably rare 
    #dir name w/trailing space + filename leading minus sign
    #and have to decide if slash is ok for option indicator
    #assume no complains if not win argv[1] is ok
    if sys.argv &gt; 1:
        if not [x for x in sys.argv if x[0] == '-']:  #in '-/'
            if sys.platform=="win32": # 
                leofile = ' '.join(sys.argv[1:])
            else:
                leofile = sys.argv[1]
        else:
            #just a test, don't trust it yet
            #may not even need it after all.
            #argvtight = concatate(sys.argv)
            argvtight = sys.argv[1:]
            #print 'concatate arg', argvtight

    #might have to add these to g.app or some kind of global?
    #they are needed in other parts of Leo before it completely starts
    #may need to pass to run and through profile into run as well.

    opts, args = parseopts(argvtight)

    if args and not leofile: leofile = ' '.join(args)
    elif args:
        print &gt;&gt; sys.stderr, 'too many args, try --help'
        #maybe print usage too? except its defined in parseopts
        raise SystemExit(2)

    #print 'past parse_args', `args`, 'leo=', `leofile`

    #for testing only, don't merge exactly
    if opts.tobatch:
        #w/filename hopefully w/o spaces
        print 'batch', opts.tobatch
    if opts.toscript:
        #w/filename hopefully w/o spaces
        print 'script', opts.toscript

    #assume run can get the options it needs at some later point
    #the profile run might require other options 
    #like print sorted stats report to file after exit
    #maybe delay start gathering for 20 seconds but continue

    #maybe should pass run a dict of the options 
    #rather than a static function attribute or global 
    #or just add to globals?

    if opts.toprofile:
        #will probably require filename arg
        #can take a leofile arg as well, default to ''
        #have to use keywords in case leofile is '' or drop coma
        #the actual call may be different, print is for ease of testing
        if leofile is None:  leofile = ''
        else:  leofile  = ','+ leofile
        #must be -P otherwise would be a string filename
        if opts.toprofile == True: opts.toprofile = 'leoProfile.txt'
        print 'profile(%s%s)'%(opts.toprofile, leofile)

    else:
        if leofile is None:  leofile = ''
        print 'run(%s)'%leofile


#e

</t>
<t tx="ekr.20060110102239.2">def profile (statfile='/tmp/leoProfile.txt', leofile= ''):
    
    """Gather and print statistics about Leo
    using new speedy hprof 
    http://www.planetsoc.com
    http://www.soton.ac.uk/~fb102/Python/hprof-0.1.0.tar.gz
    needs a blank __init__.py in the hprof dir

    or hotshot 
    even older profile if you want to go that far back
    add option to force profile, hotshot, hprof or lstat

    valid combined w/script or batch mode as well.
    
    may have the default args and calling sequence wrong
    refactored too much too fast with no time for testing
    should be easily fixed though. it did work yesterday!
    """

    #import profile, pstats
    try:
        from hprof.hprofile import Profile
    except ImportError:
        from hotshot import Profile

    import time

    start = time.time()
    #print "start %s seconds"%((start))


    prof = Profile(statfile)
    prof.run('run(%s)' % leofile)
    prof.close()

    stop = time.time()
    print 'Profile process ', statfile
    print "took %7.3f seconds"%((stop-start)),
    print "or %7.3f min"%((stop-start)/60)

    #skip the profile stats output after run
    #use scriptButton hprof in your work leo
    #may add option to generate stats after the run
</t>
<t tx="ekr.20060110102239.3">def parseopts(argv):
    """  
    should verify leo.py is [0]? optparse ignores [:1] if no argv passed
    except as %prog  in usage help
    running test in commandline manually too, 
    maybe need a maintest.py based on optik unit tests?

    &gt;&gt;&gt; import sys
    &gt;&gt;&gt; print 'argv:',`sys.argv`
    'before sys set'
    &gt;&gt;&gt; sys.argv = ["leo.py", "b", "b.txt"]
    &gt;&gt;&gt; sys.argv = ["leo.py", "b", "-?"]
    &gt;&gt;&gt; print 'argv:',`sys.argv`
    'after sys set'
    &gt;&gt;&gt; parseopts(sys.argv)
    profile
    """    
    import leoGlobals as g
    try:
        #was the original name available for py2.2
        import optik as optparse
    except ImportError:
        #using py2.3+ optparse
        optparse = g.importExtension('optparse')

    #description is in addition to normal help
    #any way to get description to be the help w/o subclassing?
    #later can use parser.usage= '%prog [-h,-n etc  defaults: -c ]'
    
    #if a filename doesn't have leo extension is it assumed?
    #I think some of the comments are starting to repeat.
    #maybe come will get closer to the point of active choice
    #and I can delete the impostor comments.

    descript = 'Leo the python scriptable literate programming editor '
        
    #usage  and description mutually exclusive?
    #usage alone is printed on unknown option or maybe other error
    #no wrap in that case

    #getting this cross platform correct could be difficult
    #especially with variations in associations
    #and isn't and can't be complete wrt paths and pythonpath
    #maybe point to the webspace and docs is enough
    #.py not required for some , python not required for others
    #maybe no choice but to generate some os specific strings
    
    #doesn't mac also have pythonw and can we detect running under wine?
    #has to be some way of embedding \n 

    #-s file -sfile --script=file or --script file all the same?
    
    usage = r'''options [-s/--script scriptfile -b/--batch batchfile leofile]
        more options [-h, --help  and --version]
        problems: try quoting any filenames
        if there is still a problem: please report it with any details
   http://webpages.charter.net/edreamleo/front.html  Leo version %s'''% __version__

    #prog name assumed eventually to be leo.py
    if sys.platform[:3] == 'win':
        usage = 'python -i %%prog leofile.leo  no console pythonw leo.py'+ usage
    else:
        usage = 'python %%prog leofile.leo  -h or --help' + usage
        
    
    parser = optparse.OptionParser(version='%%prog %s' % __version__, 
                        description=descript, usage= usage)

    #how to require a filename? and how to specify it is possibly w/spaces
    #is -s:filename acceptable? that is a common arg convention.
    #ideally tobatch would be None or be the filename
    #and because of spaces con-cation will have to happen outside the parser

    #please comment out any options that are not implemented yet.

    for (l,w,a,t,d,f,h) in (

        # -help does work because its just -h, gets me every time!
        ('-?', '--hepl', "help", "", "", "",
            "help message"),

        ("-q", "--quiet", "store_true", "int", "verbose", 0,
            "don't print status or trace messages"),

        #    -script invalid option
        ("-s", "--script", "store", "string", "toscript", None,
            " script.py to run on startup"),

        ("-b", "--batch", "store", "string", "tobatch", None,
            "batch.py to run, no GUI"),

        #if validate callback for script &amp; batch filename exists, 
        #could happen here if Leo is going to quit later anyway
        #and --safe may be mutually exclusive, confused -s being --script
        #so validate has to wait for parsing to complete, would it?

        #for profile filename is it valid? have permissions/disk space?
        #may want to force hotshot even if hprof or lprof installed
        #maybe only show these options if expert mode is on
        #no need to get a flood of forum reports about profile results
        #maybe leox.py has these options. oh, the possibilitiies.
        #this is for the 5 other people interested in this...
        #not something you want to do every day unless under duress.
        #combined with script and/or batch mode should be very powerful
        ("-p", "--profile", "store", "string", "toprofile", "",
            " save  profile results in outfile.ext       DEFAULT:\
            hprof or hotshot"),

        #a conflicting option repeat of -p won't work, so upcased it
        ("-P", "--Profile", "store_true", "", "toprofile", 0,
            " save  profile results in leoProfile.txt in the leo dir"),

        ):



        #add --settings add -home for change of home maybe -temp maybe -set
        #--settingsneeds leo/config as well as -home which one is germain


        if a == 'help':
            parser.add_option(l, w, action=a)

        elif a != 'store':
            parser.add_option(l, w, action=a,
                        dest= d, default= f, help= h )
        else:
            parser.add_option(l, w, action=a,
                type= t, dest= d, default= f, help= h )
#


@

    parser.add_option("--no-trace",action="store_false",
                  dest="trace", 
                  help="Don't print commands before executing them.") 


    #may want to subclass OptionParser to provide a Leo error exit

    #is there a generic way to check for / used as an option trigger?
    #is // even valid as a trigger
    

    #woops, if -h in argv a little too good
    #better not prevent -high 20 or something similar
    if '-h' in argv or '--help' in argv
           
    #for the win nubiee, / is the default win option starter
    #have to check every arg individually, py2.2 no substring in
    #definate bug that -? is not expected as help in optparse.
    #able to enter -? as an option though.
    
    #can't seem to get /h to trigger help
    for h in argv:
        for i in ('-?', '/help', '/h', '/?'):
            if i == h:
                #parser.error("does this help?")
                #parser.print_help()
                parser.print_usage()
                #print "didn't already exit!"
                raise SystemExit(2)
@c
                

    (opts, args) = parser.parse_args(argv)

    #can I just trap error: no such option: -? and set help=True

    return opts, args</t>
<t tx="ekr.20060110102239.4">#### may have to skip this whole concatate thing ###
#please ignore the comments too
def concatate(argv, paramdict={}):
    """
    paramdict is a dict of single letter keys and
    item = [T/F, 'longname'] set [1] as True/False for require param
    
    walk the list concatate anything with a space
    to the previous item if it doesn't look like a valid option.
    what are the valid options? we don't care...
    is - s filename parseable as -s:filename ??
    this has got to have generated lots of point counterpoint over the years.
    should do some research... 
    have to decide if will accept / as option seperator or if optparse does
    this may not be doable if we alow options to also have spaces in filenames
    does optparse resolve -ffilename as well as -f:filenname the same?

    lets assume an options param can't have spaces, just get it working for now.
    if you enter an option you better quote it if you need to
    leave the space correcting behaviour for default or trailing filenames only
    
    now there is a problem need to know which oiptions have required params
    otherwise can't decide how to concate, unless the space was preserved (it isn't)
    I think on win or anywhere argv[n][0] is never going to be a space
    dito for argv[n][-1]
    so, its a simple FSM with 2 states, an option or a param
    cancel concatate space if previous was an option
    but here we go again, what about options that don't have params?
    optparse doc talks at length about options not having optional params.
    in Leo's case we may need to pass it a list of options that have no params?
    maybe optparse team needs to gix this not the module user
    maybe someone filed a patch already? more study!
    if not who is going to need optparse after this gets done?
    
    maybe just concatate all trailing args till an option, process backward
    its looking moore like a parser than a FSM now and I need to know too much.
    maybe assume all options have required params for now untill imp paramdict
    what about "-script=name, the doc implys that this may be valid?
    
    all validm but they don't mention -file=outfile, maybe is a typo missing -?
    &lt;yourscript&gt; -f outfile --quiet
    &lt;yourscript&gt; --quiet --file outfile
    &lt;yourscript&gt; -q -foutfile
    &lt;yourscript&gt; -qfoutfile
    damm, this is not going to even be worth trying
    seems -script == --script criptm 
    that could be confusing and error prone


    &gt;&gt;&gt; concatate(['1','2','3'])
    ['1 2 3']
    &gt;&gt;&gt; concatate(['-1','2','3'])  #rule option param can't have spaces
    ['-1', '2', '3']
    &gt;&gt;&gt; concatate(['-s','2','3' '4']) #-s has required param
    ['-s', '2', '3 4']
    &gt;&gt;&gt; # a little trickier -ffilename default arg, 
    &gt;&gt;&gt; #optparse won't do this? getopt probably would,
    &gt;&gt;&gt; concatate(['-1',' 2','3' '4'])
    ['-1', '2', '3 4']

    &gt;&gt;&gt; #fix for extra credit, user probably screwed up? should ask them?
    &gt;&gt;&gt; concatate(['1','- 2','3'])
    ['1', '- 2', '3']
    
    """

    #preparse sys.argv concating filenames w/spaces 
    #as appropriate for --script and --batch and any leofilename
    #or is this something parseopts should be doing?
    #not so simple really 
    #if argc ==1 then no options or filename
    #if any options start w/ - or / then it gets dicey
    # could be a space in the last part of a directory in seperate items
    #we may not be able to cover every concievable case
    
    prev = ''
    lst = []
    
    for x in argv:

        if x[0] == '-':  #or '/' or x in '/-'
            lst.append(x)
            if prev:
                lst.append(prev)
                prev = ''
        else:
            if prev: prev = prev + ' ' + x
            else:    prev = x
        
        #print 'droped thru x:prev', `x`, `prev`
    else:
        if prev:
            lst.append(prev)

    return lst
    

</t>
<t tx="ekr.20060110102239.5">@
make into a real series of tests
I made the name leo\smain.py because my associateions for py are to open editor
so this could never run leo then open main.py even if I was in leo/src


$ python leo main.py
C:\C\PY\PYTHON~1\PYTHON.EXE: can't open file 'leo'

$ python "leo main.py"
past parse_args ['leo main.py']
leo.run()

$ python 'leo main.py'
C:\C\PY\PYTHON~1\PYTHON.EXE: can't open file ''leo'

$ python "leo main.py" filename
past parse_args ['leo main.py', 'filename']
leo.run()

$ python "leo main.py" c:/filename /help/some.leo
processed arg ['leo main.py', 'c:/filename', '/help/some.leo']
past parse_args ['leo main.py', 'c:/filename', '/help/some.leo']
leo.run()

$ python "leo main.py" "c:/filename /help/some.leo"
processed arg ['leo main.py', 'c:/filename /help/some.leo']
past parse_args ['leo main.py', 'c:/filename /help/some.leo']
leo.run()

$ python "leo main.py" "c:/filename /help/some.leo"
processed arg ['leo main.py', 'c:/filename /help/some.leo']
past parse_args ['leo main.py', 'c:/filename /help/some.leo'] leo= c:/filename /
help/some.leo
leo.run(c:/filename /help/some.leo)

$ python "leo main.py" c:/filename /help/some.leo
processed arg ['leo main.py', 'c:/filename', '/help/some.leo']
past parse_args ['leo main.py', 'c:/filename', '/help/some.leo'] leo= c:/filenam
e /help/some.leo
leo.run(c:/filename /help/some.leo)

-script works for --script cript it seems
and that could be a typo missing --script so the next filename
gets concatated into the leo name which I guess can't be helped

OTOH, if you use the default version=
then --versions works but -v or -version doesn't


$ \c\py\python24\python "leo main.py" test.leo -p whatever else
concatate arg ['test.leo', '-p', 'whatever', 'else']
past parse_args ['test.leo', 'else'] leo= 'test.leo else'
profile(whatever, test.leo else)
this is the thing that is still hard to avoid. on win, has to be
$ \c\py\python24\python "leo main.py" test.leo -p "whatever else"

really need to get this tested on other than old win9x,





@killcolor
</t>
<t tx="ekr.20060110102239.6">@
will it handle spaces in filenames w/o quotes?

leo.py --script filename.leo is not good
leo.py -script filename is not good, which is it a scriptfile or a leo to be?

as error for -profile as an option, going to have to subclass override error
AttributeError Values instance has no attribute 'profile' ["__module__ = 'exceptions' .", "__doc__ = 'Attribute not found.' ."] 
this was a programmer error though, the var is toprofile

little hard to test this as a script, can't control argv
update, sys.argv = seems now to be working from doctest
better readup, haven't used this in a while
haven't read the docs in a while either, a good read.
especially the origional optik.sf.net


need to make this a function to call returning a dict maybe?
at least to doctest it better w/o needing to create a test module 
and then run it saving stdout

its also going to be a little trickier to --script or --batch with --profile
and what is exactly the difference with --batch and --script?
one has no GUI maybe?


- is valid in a filename, so primitive argv parsing
will be difficult to distinguish in a filename w./spaces
since the spaces cause seperate items and just a join
is not good because you have to know if it is a valid arg
what if it is a valid arg? this is a nightmare in any case...


need a timer on operations while getting a profile
expandall, contrract all so can be output with the pstats

need to set options in a seperate function
so can generate test for all functions and params on the fly
this will be good in the general case for other programs

anyone already depending on case insensitive args?

default file for profile not working out
comprimise -P as an option w/o param uses default leoProfile.txt

if -p file name -s some.py will be difficult to get right w/o quoting
will anyone ever expect a default? 
unless thats in the leodir or something?
dito for script and batch but what possible default could they have, 



does x is None work on py2.2?

</t>
<t tx="ekr.20060110102239.7">@color
@
hprof from google summer of code replace hotshot &amp; profile
much faster on the uptake and output!
has compatibility modules so can use mostly the same calls
this script uses the hprof calls. didn't mod leo.py yet
as I am not able to compile _hotshot.c to pyd or .so
it will use hotshot created profile ok.

added psyco, need to create batch file so can automate &amp; timeit.
also have modified leoGlobals match and a few other things already
and proven You can shave at lest a few seconds overall,

can combine add more than one profile run to get better data
but I don;t do that in this script.

and pypy has lstat which also didn't compile for me
and possibly isn't windows compatible yet
along with another mentioned in this past weeks py-dev summary.


need something to compare the diff of 2 profiles
sorted the same way, something to add comments to the
profile, maybe a simple flatfile to manage profiling.
seems this would have been a project for someone already?

chg leo.py profile to create hotshot profile file
then run, copy a node from library
expand/contract a few times then exit.

takes a few minutes to process the hotshot file
then prints enormous amout of stats...
you see a few leoGlobals called a few hundred thousand times
on a run of 5 or 10 minutes.

        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
              "calls"     : (((1,-1),              ), "call count"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "file"      : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),

@c
from dyna_menu import dtef
@others 

 
def showstats():
    """ log sort of stops printing when you type! or grab scrollbars.
    need to print to copybuffer, redirect io to log print very slow
    may actually be faster if you minimize leo
    also can make the log window very small
    in Leo4.4 you can multitask a little when it starts to print.
    """
    import leoGlobals as g
    #import profile, pstats
    try:
        from hprof.hpstats import Stats
    except ImportError:
        from hotshot import Stats
    import sys
    
    name = "/tmp/leoProfile.txt"
    print 'processing ', name

    #profile.run('leo.run()',name)
    #prof = hotshot.Profile(name)
    #prof.runcall(run)
    #prof.close()

    #p = pstats.Stats(name)
    #p.strip_dirs()
    #p.sort_stats('cum','file','name')
    #p.print_stats()

    
    #would be nicer if strip_dirs left one more level of dir
    #or even better took an int to leave how many levels
    #several modules have similar def names, __init__ etc
    #will have to override that.
    
    s = Stats(name).strip_dirs()

    #need to reverse or trap stdout to file    
    #why does g. not have a simple command to do this?
    #whydoes stats.print not take a filename? 
    #weird no one thinks of these things. is it just me?

#    sys.stdout = g.fileLikeObject()
    
    print 'start.sort', dtef(c),
    s.sort_stats("time").print_stats()  #.print_callers()
@
    stat = sys.stdout.get()
    sys.stdout.close()
    sys.stdout = sys.__stdout__

    #attempt to get a better strip_dirs later
    for k,v in repdict.iteritems():
        stat = stat.replace(k,v)
    print stat[:400]
@c    

print 'start', dtef(c),
showstats()
print 'done', dtef(c)</t>
<t tx="ekr.20060110102239.8">try:
    if 1:#1/0  If present, use psyco to accelerate the program
        import psyco
        psyco.full()  #carefull with this in py2.3 esp w/leo 
        #shows alot of time in tkinter and other plain leo routines!
        #though this was per module only 
        #from psyco.classes import *

        #psyco.log(logfile='c:/temp/sb1.log', mode='w', top=30)
        #psyco.profile(0.2)
        #psyco.profile( watermark=0.09, halflife=0.5, pollfreq=20,  parentframe=0.25, memory=None, time=None, memorymax=None, timemax=None) 
        #psyco.bind(searchButton) #not in scope, put after def
        #psyco.bind(gen_nodes)  #generators 
except ImportError: pass
</t>
<t tx="ekr.20060110113743"></t>
<t tx="ekr.20060110113743.1">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3515025
By: nobody

From: Rich

&gt;&gt;  Rich, are you still having any problems with plugins? (except for problems
with the initial dynamic enabling of plugins).
 
I have a nimber of plugins turned on. Here are my findings:

I've had troubles with the following:

-  cleo.pyc
....Markers are not cleared. 
....Pressing Priority --&gt; clear gives:
---------------------------------------------------
........Error: 1
........AttributeError Exception in Tk callback
........  Function: &lt;function &lt;lambda&gt; at 0x0173BAB0&gt; (type: &lt;type 'function'&gt;)
........  Args: ()
........Traceback (innermost last):
........  File "C:\Language\Python\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py",
line 1747, in __call__
............return apply(self.func, args)
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 700,
in &lt;lambda&gt;
............command=lambda:self.priority_clear(p.v),underline=0)
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 742,
in priority_clear
............self.changed_redraw()
........  File "C:\Software Engineering\Leo\Leo 4.4\plugins\cleo.py", line 325,
in changed_redraw
............c.setChanged(True)
........  File "c:\softwa~1\leo\leo4~1.4\src\leoCommands.py", line 5966, in
setChanged
............if not c.frame: return
........AttributeError: Commands instance has no attribute 'frame'
---------------------------------------------------
(FWIW, I like the error window that pops up.)

...."Clear All" does NOT clear ALL(nodes) but restores the node colors to their
default values

....CLEO does not pick up Leo's colors. I use Antique White for the backgrounds,
but until I changed CLEO's "White" to "Antique White" it was a nuisance. Newbies
wouldn't want to / shouldn't need to go in and change the source code.


-  fastGotoNode.pyc
....Ctrl-Spc does not work to bring up the menu

~  groupOperations.pyc
....(Image) is not a very helpful name -- To me, 'image' has to do with graphics.
"GrpOps" would be better.

....I found using the old-time key combinations a LOT easier than mousing
around:
........Shift+Alt+M........Mark
........Shift+Alt+V........moVe (Remember Turbo Pascal?)
........Shift+Alt+C........Copy
........Shift+Alt+`........clone
........Shift+Alt+T........Tag
........Shift+Alt+R........Remove tag

....... and I'd rather have a multitude of operations (as above) than a multitude
of markings (mark for Move|Copy|Clone).

The following work as expected:
+  add_directives.pyc
+  color_markup.pyc
+  hoist.pyc
+  nav_buttons.pyc
+  open_with.pyc - even with my editor!
+  rClick.pyc
+  startfile.pyc
+  UniversalScrolling.pyc

Untried-until-I-get-a-chance:
?  ConceptualSort.pyc
?  labels.pyc
?  Scripts
?  timestamp.pyc
?  UNL.pyc

HTH,
--Rich
</t>
<t tx="ekr.20060110120907">@tabwidth 4

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=3515341
By: nobody

from latest cvs. post g.top disable.

inconsistent use of tabs and spaces
leo\src\leoUndo.py: 
leo\src\leoCommands.py:
leo\src\leoTkinterTree.py: 
@tabwidth 4
	
Library creating: default
problem starting Library: default
not sure where this is comming from.
I though Library did nothing untill first used.
the 2nd run of Leo, the db is already created
so no error reported. 
ok if have an existing db in the default place.

leo\plugins\rClick.py", line 244, in rClicker
    commandList=[
UnboundLocalError: local variable 'rc_selectAllCallback' referenced before
assignment

a lambda would work here.
or the callback has to be moved
outside the if startswith body

leo\src\leoTkinterGui.py", line 677, in getTextSelection
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine
instead!!
AttributeError: Entry instance has no attribute 'tag_ranges'
when paste into Entry widget of search box or button.
paste only understands Text widget?
and then only from Edit-Paste
keyboard paste is ok.

in dyna_menu
TypeError: cmd_flip_Leo_debug() takes no arguments (1 given)
thanks for adding the callback in plugin_menu, 
but now any plugin that has cmd_* functions 
needs a c or dummy parameter in all of them.

'help' in 139i should be copied from 
my website version 139j from last year.
this one fails on modules if you have epydoc,
that should fix the only crasher 
in the dyna version included with Leo.

pylint call might need to have the import
lines tweaked, depending on which version.
they stupidly changed logilab directorys
from version 6 to 7 and then again 7+.
Im not going to try and guess which if
any version of pylint someone has installed.
if you want it, then you can edit it in.

otherwise everything so far seems to work.
with other noted anomalies omited for brevity.
movement keys not  unselecting text the main one.

alpha testers, remember if there is a
traceback error in a plugin, although
Leo recovers often other plugins will
stop working 100% correctly in every case.
exit Leo and python and restart 
maybe with the offending plugin disabled,
to be sure other problems are real problems.

docutils 0.4 was released today.
has a new html slideshow writer.

e</t>
<t tx="ekr.20060110131309"></t>
<t tx="ekr.20060110131309.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3515616

Could we have a visible-line-up and visible-line-down command? (I.e. to move
the cursor up or down by a visible rather than a logical line).  With these
commands, the arrows plugin could be permanently retired!

What I did:

- next-line and prev-line now work as requested.  This obsoletes the arrow plugin.
    - Removed the redundant tree.OnUpKey and tree.OnDownKey
    - Retired the arrows plugin.

- Created the extendHelper method.
    This creates and maintains the moveSpot, moveCol an moveSpotNode ivars,
    and is responsible for extending the selection range.</t>
<t tx="ekr.20060110133007"></t>
<t tx="ekr.20060110202238">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3516262
By: btheado

I notice some keystrokes in the body pane are missing compared to 4.4a4.  I
guess Tk used to handle these:

Home/End - move cursor to start/end of line
Shift-Home/Shift-End - same with selection
Ctrl-Home/Ctrl-End - move cursor to start/end of widget
Shift-Pageup/Shift-Pagedown - select by page (oops I see that 4.4a didn't have
these either)

Tk also provides state for preserving the cursor column as much as possible
and 4.4a5 no longer has this functionality.

Example:
========
12345678
1
12345678
========

In 4.4a4, put the cursor on the 7 and move down two lines and the cursor will
be on the other 7.  In 4.4a5, the cursor will end up on the 2 after moving down
two lines.

This cursor column preservation isn't unique to Tk.  I've noticed that vim supports
it as well.  I find it useful.</t>
<t tx="ekr.20060110202455"></t>
<t tx="ekr.20060111103821"></t>
<t tx="ekr.20060111103821.1">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3517023
By: ktenney

W2K, recent CVS (Sourceforge is asking for a
passwords and refusing to let me update)

Window - Open Python Window

Close the Python Window

Plugins - Core - Plugin Manager causes traceback;

exception executing command
Traceback (most recent call last):
  File "C:\python24\lib\site-packages\leo\src\leoCommands.py", line 238, in
doCommand
    val = command()
  File "C:\python24\lib\site-packages\leo\plugins\plugins_menu.py", line 548,
in callback
    p.hastoplevel()
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 231,
in topLevelMenu
    dlg = ManagerDialog(True)
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 777,
in __init__
    self.plugin_view = PluginView(self.upper, self.file_text)
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 282,
in __init__
    labelpos = 'w',label_text = 'Name:')
  File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwEntryField.py", line
73, in __init__
    sequences = root.bind_class(tag)
AttributeError: 'NoneType' object has no attribute 'bind_class'
</t>
<t tx="ekr.20060111103821.2"></t>
<t tx="ekr.20060111103821.3">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3517180
By: rich_ries

With Universal Scrolling, the Right mouse button works (scrolls up) but the
Left mouse button (scroll down) does not. (Yes, I made sure I had a Leo file
I could scroll up/down in.)

--Rich
P.S. -- Is there any way for the "select-node-on-mouse-click" feature to be
disabled during scrolling? When I'm scrolling along, and I come to a long node,
the scrolling stops and the long node is selected. NOT what I want! FWIW, my
workaround is to locate the mouse on the far left side of the Outline Pane.</t>
<t tx="ekr.20060111112513">See this node in leoDocs.leo.

Users Guide--&gt;FAQ--&gt;@rst html\FAQ.html--&gt;Learning to use Leo--&gt;When is deleting a node dangerous?</t>
<t tx="ekr.20060111113925">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3517080</t>
<t tx="ekr.20060111114001">@nocolor</t>
<t tx="ekr.20060111134004"></t>
<t tx="ekr.20060111134004.1">Leo's Open Python Window command should take care to run Idle in a separate process.

The present code is essentially:

import idlelib.PyShell
idlelib.PyShell.main()

As the present problems with the Plugins manager show, this has the potential for mischief.  Indeed, idle is a Tkinter process, so Idle's shutdown code could interfere with Tkinter, Pmw, g.app or all three.

It's no good blaming Pmw or Idle or whatever, there needs to be a solid way of avoiding problems, both now and in the future.  The obvious way is to use os.system or subprocess to keep Idle at arm's length.  If necessary we can use settings in leoSettings.leo to tell Leo exactly how to start Idle.</t>
<t tx="ekr.20060111134901"></t>
<t tx="ekr.20060111152145"></t>
<t tx="ekr.20060111152145.1"></t>
<t tx="ekr.20060111193246"></t>
<t tx="ekr.20060112045830">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3518387

Here are the changes I made to get back to my old Leo:

back-word                               = Ctrl-LtArrow
back-word-extend-selection              = Shift-Ctrl-LtArrow
beginning-of-buffer                     = Ctrl-Home
beginning-of-buffer-extend-selection    = Shift-Ctrl-Home
beginning-of-line                       = Home
beginning-of-line-extend-selection      = Shift-Home
delete-char                             = Delete
end-of-buffer                           = Ctrl-End
end-of-buffer-extend-selection          = Shift-Ctrl-End
end-of-line                             = End
end-of-line-extend-selection            = Shift-End
forward-word                            = Ctrl-RtArrow
forward-word-extend-selection           = Shift-Ctrl-RtArrow
scroll-down                             = PageDn
scroll-up                               = PageUp
</t>
<t tx="ekr.20060112062706"></t>
<t tx="ekr.20060112062706.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3518722
By: nobody

I'm using Leo 4.3.1, build  1.266 , June 20, 2005.

To generate HTML file I entered the outline header "@file bbb.xml" under which
I put the following body text:

//////////////// beginning of excerpt
@first &lt;?xml version="1.0" encoding="windows-1250" ?&gt;
@language html
@
comment line
@c
@others
//////////////// end of excerpt

This works OK.
But, if I put a space after the sole @ above "comment line",  save and close
the .leo file and then open it, Leo protests in log pane on the right:

//////////////// beginning of excerpt
----- error reading @file: bbb.xml
Missing open block comment
//////////////// end of excerpt

maks.romih@snt.si</t>
<t tx="ekr.20060112064517"></t>
<t tx="ekr.20060112064517.1">I use SciTE, but these keystrokes are quite common.
http://www.scintilla.org/SciTE.html

These now exist in 'EKR bindings: a mix...'

back-word                               ! text = Ctrl-LtArrow
back-word-extend-selection              ! text = Ctrl-Shift-LtArrow
beginning-of-line                       ! text = Home
beginning-of-line-extend-selection      ! text = Shift-Home
end-of-line                             ! text = End
end-of-line-extend-selection            ! text = Shift-End
forward-word                            ! text = Ctrl-RtArrow
forward-word-extend-selection           ! text = Ctrl-Shift-RtArrow
scroll-down                             ! text = PageDn
scroll-up                               ! text = PageUp

I added these, but the commands don't exist yet:

beginning-of-text                       ! text = Ctrl-Home
beginning-of-text-extend-selection      ! text = Ctrl-Shift-Home
end-of-text                             ! text = Ctrl-End
end-of-text-extend-selection            ! text = Ctrl-Shift-End
scroll-down-extend-selection            ! text = Shift-PageDn
scroll-up-extend-selection              ! text = Shift-PageUp

Manfred
marl@pragmatis.de
www.pragmatis.de</t>
<t tx="ekr.20060112065740"></t>
<t tx="ekr.20060112070752"></t>
<t tx="ekr.20060112084446">@nocolor

- Set options from the keyboard.
    - set-variable sets a (Python) variable using an minibuffer-style variable name.

Focus
    - focus-in-body/tree/log/dialog.
    - cycle-active-pane and cycle-active-widget (in a single pane) commands.
    - activate-xxx-menu commands.  (alternative to XP Alt-f, Alt-E, etc.)

- Drive all tabs/dialogs from the keyboard

- Control all Leo commands &amp; widgets using only key commands.

- create-tab, clear-tab commands, etc.
    These might get the tab name from the minibuffer...
    
- find character, word,etc.

- extending the cursor
    Possibly the same as moves, except for being in extend mode.
    
- moving text around
    - cut, copy, paste, kill, yank, etc.
    - delete to x

- dismiss-about-dialog</t>
<t tx="ekr.20060112094901"></t>
<t tx="ekr.20060112112241"># These should be considered bug fixes.</t>
<t tx="ekr.20060112191014">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3518792

EKR: The change in focus happened in c.endEditing in at.writeFromString.

I added a new restoreFocus keyword arg to c.endEditing.</t>
<t tx="ekr.20060112202702">@nocolor

1. copyBindingsToWidget now binds keys in priority order. This also simplifies
and clarifies the code.

2. Removed k.onTextWidgetKey.  Added a callback that invokes k.masterCommand.</t>
<t tx="ekr.20060113050914"></t>
<t tx="ekr.20060113060922">This corrects a problem that shows up as 'Invalid cross-device link' messages on Linux.

http://sourceforge.net/forum/message.php?msg_id=3519803</t>
<t tx="ekr.20060113062832.1">def copyBindingsHelper(self,bunchList,shortcut,w):

    k = self ; c = k.c

    textBunch = treeBunch = None
    for bunch in bunchList:
        if bunch.pane == 'tree' and treeBunch is None:
            treeBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif bunch.pane != 'tree' and textBunch is None:
            textBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif c.config.getBool('trace_bindings'):
            g.trace('ignoring %s in %s' % (shortcut,bunch.pane))
            
    if textBunch and treeBunch:
        def textAndTreeKeyCallback(event,c=c,
            textFunc=textBunch.func,treeFunc=treeBunch.func):
            w = c.currentPosition().edit_widget()
            if w and w.cget('state') == 'disabled':
                treeFunc(event)
            else:
                textFunc(event)
            return 'break'

        w.bind(shortcut,textAndTreeKeyCallback)
        
    elif textBunch or treeBunch:

        def textOrTreeKeyCallback(event,func=bunch.func):
            func(event)
            return 'break'

        w.bind(shortcut,textOrTreeKeyCallback)</t>
<t tx="ekr.20060113081442.2">@nocolor

Later

open-outline-by-name

https://sourceforge.net/forum/message.php?msg_id=3519444

write-rst
execute-unit-tests</t>
<t tx="ekr.20060113082917">def scrollHelper (self,event,direction,extend):

    k = self.k ; c = k.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)

    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    row, col = ins1.split('.') ; row = int(row) ; col = int(col)

    # Compute the spot.
    chng = self.measure(w) ; delta = chng [0]
    row1 = g.choose(direction=='down',row+delta,row-delta)
    spot = w.index('%d.%d' % (row1,col))
    w.mark_set('insert',spot)

    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot)
    w.see('insert')</t>
<t tx="ekr.20060113085710"></t>
<t tx="ekr.20060113090042"></t>
<t tx="ekr.20060113090732"></t>
<t tx="ekr.20060113105246">def moveUpDown (self,direction):
    c = self.c ; body = c.frame.bodyCtrl
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = g.scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y &gt;= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width/2: x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    g.trace("entry:  %s.%s" % (lines,char),'result',result,'insert',body.index('insert'))
    return "break" # Inhibit further bindings.</t>
<t tx="ekr.20060113105246.1">def moveUpOrDownHelper (self,event,direction,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    # Make the insertion cursor visible so bbox won't return an empty list.
    w.see('insert')
    # Remember the original insert point.  This may become the moveSpot.
    ins1 = w.index('insert')
    # Compute the new spot.
    row1,col1 = ins1.split('.')
    row1 = int(row1) ; col1 = int(col1)
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    x, y, junk, textH = w.bbox('insert')
    bodyW, bodyH = w.winfo_width(), w.winfo_height()
    junk, maxy, junk, junk = w.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if direction == "up":
        if y &lt;= textH:  w.yview("scroll",-1,"units")
        else:           y = max(y-textH,0)
    else:
        if y &gt;= maxy:   w.yview("scroll",1,"units")
        else:           y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx, newy, width, junk = w.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width / 2: x = newx + width + 1
    # Move to the new row.
    spot = w.index("@%d,%d" % (x,y))
    row,col = spot.split('.')
    row = int(row) ; col = int(col)
    w.mark_set('insert',spot)
    # Adjust the column in the *new* row, but only if we have actually gone to a new row.
    if self.moveSpot:
        if col != self.moveCol and row != row1:
            s = w.get('insert linestart','insert lineend')
            col = min(len(s),self.moveCol)
            if col &gt;= 0:
                w.mark_set('insert','%d.%d' % (row,col))
                spot = w.index('insert')
                w.see('insert')
    # Handle the extension.
    self.extendHelper(w,extend,ins1,spot)</t>
<t tx="ekr.20060113130510">def extendHelper (self,w,extend,ins1,spot):

    '''Handle the details of extending the selection.
    
    extend: Clear the selection unless this is True.
    ins1:   The *previous* insert point.
    spot:   The *new* insert point.
    '''
    c = self.c ; p = c.currentPosition()
    moveSpot = self.moveSpot
    if extend or self.extendMode:
        i, j = g.app.gui.getTextSelection(w)
        if (
            not moveSpot or p.v.t != self.moveSpotNode or
            i == j or # A cute trick
            (not w.compare(moveSpot,'==',i) and
             not w.compare(moveSpot,'==',j))
        ):
            self.moveSpotNode = p.v.t
            self.moveSpot = w.index(ins1)
            self.moveCol = int(ins1.split('.')[1])
            # g.trace('reset moveSpot',self.moveSpot)
        moveSpot = self.moveSpot
        # g.trace(spot,moveSpot)
        if w.compare(spot,'&lt;',moveSpot):
            g.app.gui.setTextSelection(w,spot,moveSpot,insert=None)
        else:
            g.app.gui.setTextSelection(w,moveSpot,spot,insert=None)
    else:
        self.moveSpot = spot
        self.moveCol = int(spot.split('.')[1])
        g.app.gui.setTextSelection(w,spot,spot,insert=None)</t>
<t tx="ekr.20060113163800">The fix was to add the 'text' specifier to the call to copyBindingsToWidget in tree.setTabBindings.</t>
<t tx="ekr.20060113170919">@nocolor

Hitting Backspace immediately put the focus in the log. Another backspace put
the focus in the body pane.

The problem was in log.clearTab.  It must do call t.update().</t>
<t tx="ekr.20060113170919.1">- create-chapter, destroy-chapter, select-chapter, etc.

- find-character-on-line, find-word-on-line, etc.

- extend-to-word, extend-to-paragraph, extend-to-sentence, etc.</t>
<t tx="ekr.20060114052626"></t>
<t tx="ekr.20060114055611">- It should recolor the text.
- Does it not stick sometimes?</t>
<t tx="ekr.20060114055714"></t>
<t tx="ekr.20060114060100">@nocolor

- enter-x-mode doesn't get shortcuts.  Try putting @mode nodes last?

- Add @string active-keyset setting?

- The mode tab should present commands first, bindings second.

- Modes should persist, unless we have a mode binding like:

command-name -&gt; enter-x-mode = binding

- Have bindings for top-level vim mode like this:

show-completion-list = Tab
show-completion-list = BackSpace

Bugs:

** Must stay in mode until we leave explictly.
** @mode must bind shortcuts.
</t>
<t tx="ekr.20060114060100.1"></t>
<t tx="ekr.20060114061826">@nocolor

The fix is easy: extensionHelper resets movePoint any time there is no selection.

@color
</t>
<t tx="ekr.20060114080203"></t>
<t tx="ekr.20060114080424">@nocolor

Scroll should work in body pane too.</t>
<t tx="ekr.20060114091359">@ To do:
    
- inverseCommandsDict should be a list too.
- getShortcutForCommandName should return a list.</t>
<t tx="ekr.20060114103244"></t>
<t tx="ekr.20060114104119"></t>
<t tx="ekr.20060114104119.1"></t>
<t tx="ekr.20060114110141">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,k.prettyPrintKey(shortcut),commandName)</t>
<t tx="ekr.20060114115648">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060114163130"></t>
<t tx="ekr.20060114171910">def traceBinding (self,bunch,shortcut,w):

    k = self ; c = k.c

    if not c.config.getBool('trace_bindings'): return
    
    theFilter = c.config.getString('trace_bindings_filter') or ''
    if theFilter and shortcut.lower().find(theFilter.lower()) == -1: return
    
    pane_filter = c.config.getString('trace_bindings_pane_filter')
    
    if not pane_filter or pane_filter.lower() == bunch.pane:
         g.trace(bunch.pane,k.prettyPrintKey(shortcut),bunch.commandName,w._name)</t>
<t tx="ekr.20060114180908"></t>
<t tx="ekr.20060114183604">@nocolor

The fix was simply to call endUpdate() rather than endUpdate(changed) in onHeadChanged.
This should be safe: The change-all command could always enclose the code in begin/endUpdate.</t>
<t tx="ekr.20060114215112">
</t>
<t tx="ekr.20060115091804.2"></t>
<t tx="ekr.20060115091804.3"></t>
<t tx="ekr.20060115092257">@nocolor

Standard keys (Windows defaults in parens)

F1 help
Windows key + F1 Windows Help
F2 find-tab-find-prev (Rename)
F3 find-tab-find (Find Files)
F4 None (Address bar in Windows Explorer)
F5 None (Refresh, Reload in Windows Explorer)
F6 None (Should cycle from window to window)
F7 open-spell-tab (Spell in Word)
Shift-F7 None (Thesaurus in Word)
F8 None (Safe mode)
F9 None
F10 None (Activate menu bar in many programs)
F11 None (Toggle full screen mode in explorer)
F12 None

You can use F10 to highlight the first menu choice, and then use the arrow keys to move around the menus. Pressing the Shift key while pressing F10 will bring up the shortcut menu. This is similar to right-clicking on an object.</t>
<t tx="ekr.20060115095641"></t>
<t tx="ekr.20060115100407"></t>
<t tx="ekr.20060115100841"></t>
<t tx="ekr.20060115100841.1"></t>
<t tx="ekr.20060115102006.1"></t>
<t tx="ekr.20060115103349"></t>
<t tx="ekr.20060115134337"></t>
<t tx="ekr.20060115162515">To do: specify what mode to enter after each command:

- command-name -&gt; mode-name = binding

will specify what mode to enter after each command.
At present, all commands exit to the top-level mode.</t>
</tnodes>
</leo_file>
