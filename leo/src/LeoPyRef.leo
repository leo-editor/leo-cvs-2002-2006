<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="7204" clone_windows="0"/>
<globals body_outline_ratio="0.426193118757">
	<global_window_position top="30" left="364" height="901" width="846"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933" a="M"
marks="ekr.20040701152235.15,ekr.20040701152235.16,EKR.20040424154804,ekr.20031218072017.1733,EKR.20040424154804,ekr.20031218072017.1733,ekr.20031218072017.1863,ekr.20040711135244.10,EKR.20040424154804,ekr.20031218072017.1733,ekr.20031218072017.2865,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936" a="E"
marks="ekr.20040831092540,ekr.20031218072017.1863,"
expanded="EKR.20040609091327,ekr.20040919101448,"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20041113115748"><vh>@button spellpyx</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2415"><vh> Scripts</vh>
<v t="ekr.20040327103735.2"><vh>Script Tools (leoGlobals.py)</vh>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20040321065415"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
</v>
<v t="EKR.20040502195524"><vh>@thin ../scripts/leoScripts.txt</vh></v>
<v t="EKR.20040502194930"><vh>@thin ../scripts/tangle_done.py</vh></v>
<v t="ekr.20031218072017.2537"><vh>@thin ../scripts/untangle_done.py</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"
expanded="ekr.20031218072017.1605,"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,ekr.20031218072017.2865,ekr.20040711135244.10,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20031218072017.3018"
marks="ekr.20031218072017.1863,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
<v t="ekr.20031218072017.3001"><vh>@thin leoConfig.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20031218072017.3626"><vh>@thin leoColorPanel.py</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3652"><vh>@thin leoFontPanel.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3812"><vh>@thin leoPrefs.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3822"><vh>@thin leoTkinterColorPanels.py</vh></v>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3909"><vh>@thin leoTkinterFontPanel.py</vh></v>
<v t="ekr.20031218072017.3939"
marks="EKR.20040424154804,ekr.20031218072017.1733,"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20031218072017.4122"><vh>@thin leoTkinterPrefs.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
<v t="ekr.20031218072017.828"><vh>(Rewrite the config manager)</vh>
<v t="ekr.20041116164151"><vh>Plan</vh></v>
<v t="ekr.20041115111203"><vh>What I did</vh></v>
<v t="ekr.20041115110846"><vh>New strategy</vh></v>
<v t="ekr.20041115165553"><vh>@settings trees prototype</vh>
<v t="ekr.20041115165553.1"><vh>@settings</vh>
<v t="ekr.20041115191203.2"><vh>General configuration options</vh>
<v t="ekr.20041115191203.3"><vh>&lt;&lt; .leo file options &gt;&gt;</vh></v>
<v t="ekr.20041115191203.4"><vh>&lt;&lt; command options &gt;&gt;</vh></v>
<v t="ekr.20041115191203.5"><vh>&lt;&lt; directory options &gt;&gt;</vh></v>
<v t="ekr.20041115191203.6"><vh>&lt;&lt; derived files options &gt;&gt;</vh></v>
<v t="ekr.20041115191203.7"><vh>&lt;&lt; plugins options &gt;&gt;</vh></v>
<v t="ekr.20041115191203.8"><vh>&lt;&lt; tangle options &gt;&gt;</vh></v>
<v t="ekr.20041115191203.9"><vh>&lt;&lt; unicode encoding options &gt;&gt;</vh></v>
</v>
<v t="ekr.20041115191203.11"><vh>Compare Panel defaults</vh>
<v t="ekr.20041115192810"><vh>@page Options specifying files</vh></v>
<v t="ekr.20041115192810.1"><vh>@page Options related to directory compares.</vh></v>
<v t="ekr.20041115192810.2"><vh>@page Options related to file compares.</vh></v>
</v>
<v t="ekr.20041115191203.12"><vh>@page Find/Change Panel defaults</vh></v>
<v t="ekr.20041115191203.13"><vh>Keyboard shortcuts</vh>
<v t="ekr.20041115191203.14"><vh>About keyboard shortcuts</vh></v>
<v t="ekr.20041115191203.15"><vh>Alt and Shift-Alt</vh></v>
<v t="ekr.20041115191203.16"><vh>Control</vh></v>
<v t="ekr.20041115191203.17"><vh>Shift-Control</vh></v>
<v t="ekr.20041115191203.18"><vh>F-keys and others</vh></v>
<v t="ekr.20041115191203.19"><vh>None</vh></v>
</v>
<v t="ekr.20041115191203.20"><vh>@page Preferences Panel defaults</vh>
<v t="ekr.20041115192810.3"><vh>default_tangle_directory</vh></v>
<v t="ekr.20041115192810.4"><vh>default_target_language</vh></v>
<v t="ekr.20041115192810.5"><vh>tab_width</vh></v>
<v t="ekr.20041115192810.6"><vh>page_width</vh></v>
<v t="ekr.20041115192810.7"><vh>output_doc_chunks</vh></v>
<v t="ekr.20041115192810.8"><vh>tangle_outputs_header</vh></v>
<v t="ekr.20041115192810.9"><vh>run_tangle_done.py</vh></v>
<v t="ekr.20041115192810.10"><vh>run_untangle_done.py</vh></v>
</v>
<v t="ekr.20041115191203.22"><vh>Window options...</vh>
<v t="ekr.20041115191203.23"><vh>body pane options</vh></v>
<v t="ekr.20041115191203.24"><vh>outline pane options</vh></v>
<v t="ekr.20041115191203.25"><vh>@page log pane options</vh></v>
<v t="ekr.20041115191203.26"><vh>@page Options for new windows</vh></v>
<v t="ekr.20041115191203.27"><vh>Options for newly opened windows</vh></v>
<v t="ekr.20041115191203.28"><vh>@page splitter options</vh>
<v t="ekr.20041115192810.11"><vh>split_bar_color</vh></v>
<v t="ekr.20041115192810.12"><vh>split_bar_relief</vh></v>
<v t="ekr.20041115192810.13"><vh>split_bar_width</vh></v>
</v>
</v>
<v t="ekr.20041115165553.2"><vh>Syntax coloring options</vh>
<v t="ekr.20041115165553.3"><vh>@page Options</vh>
<v t="ekr.20041115165553.4"><vh>color_cweb_doc_parts_with_latex</vh></v>
<v t="ekr.20041115165553.5"><vh>color_cweb_comments_with_latex</vh></v>
<v t="ekr.20041115165553.6"><vh>color_directives_in_plain_text</vh></v>
<v t="ekr.20041115165553.7"><vh>underline_undefined_section_names</vh></v>
<v t="ekr.20041115165553.8"><vh>use_hyperlinks</vh></v>
</v>
<v t="ekr.20041115165553.9"><vh>@page Colors</vh>
<v t="ekr.20041115165553.11"><vh>comment_color</vh></v>
<v t="ekr.20041115165553.12"><vh>cweb_section_name_color</vh></v>
<v t="ekr.20041115165553.13"><vh>directive_color</vh></v>
<v t="ekr.20041115165553.14"><vh>doc_part_color</vh></v>
<v t="ekr.20041115165553.15"><vh>keyword_color</vh></v>
<v t="ekr.20041115165553.16"><vh>leo_keyword_color</vh></v>
<v t="ekr.20041115170155"><vh>section_name_color</vh></v>
<v t="ekr.20041115170155.1"><vh>section_name_brackets_color</vh></v>
<v t="ekr.20041115170155.2"><vh>show_invisibles_space_background_color</vh></v>
<v t="ekr.20041115170155.3"><vh>show_invisibles_tab_foreground_color</vh></v>
<v t="ekr.20041115170155.4"><vh>string_color</vh></v>
<v t="ekr.20041115170155.5"><vh>undefined_section_name_color</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20041115094721"><vh>To do</vh>
<v t="ekr.20041115104519"><vh>Define g.app.homeDir and g.app.globalDir</vh>
<v t="ekr.20041115103456.1"><vh>How to define g.app.homeDir</vh></v>
<v t="ekr.20041115105258"><vh>Look for .leoConfig.txt (dot) and leoConfig.txt (no dot)</vh></v>
<v t="ekr.20040919075839"><vh>How to load leoConfig.txt &amp; .leoID.txt from $HOME</vh></v>
<v t="ekr.20040213060739"><vh>Config stuff: write protected leoConfig.txt</vh></v>
</v>
<v t="ekr.20040922073523"><vh>Define g.app.leoID before loading plugins</vh>
<v t="ekr.20040924081853"><vh>more comments</vh></v>
<v t="ekr.20040928085738"><vh>still more comments</vh></v>
</v>
<v t="ekr.20041002150740.1"><vh>Multiple copies (names?) of leoConfig.txt</vh>
<v t="ekr.20040212094034"><vh>Please put all global config options in one place</vh></v>
<v t="ekr.20031218072017.655"><vh>multiple copies (names??) for leoConfig.txt</vh></v>
<v t="ekr.20040225061559"><vh>Look at older config files when reading config data the first time for a new install</vh></v>
<v t="ekr.20040327050211"><vh>Fix problems with updating leoConfig.txt</vh>
<v t="ekr.20040124073801"><vh>Add nullConfig class?</vh></v>
</v>
<v t="ekr.20031218072017.656"><vh>Allow different fonts settings for Linux/Mac</vh></v>
</v>
<v t="ekr.20041115105258.1"><vh>Other problems</vh>
<v t="EKR.20040422132037.4"><vh>config problem on Linux</vh></v>
<v t="ekr.20040330092305"><vh>Preserve comments in config files (so we can use sentinels!)</vh></v>
<v t="EKR.20040606193130"><vh>(Fix problems with negative tab width in prefs)</vh>
<v t="EKR.20040606193323"><vh>Report</vh></v>
<v t="ekr.20031218072017.2062"><vh>getPrefs</vh>
<v t="ekr.20031218072017.2063"><vh>getTargetLanguage</vh></v>
</v>
</v>
<v t="ekr.20031218072017.653"><vh>EKR posting: problems with ConfigParse</vh></v>
</v>
<v t="ekr.20040226105601"><vh>Language-specific modes</vh></v>
<v t="ekr.20031218072017.651"><vh>Let config gui be a plugin defining @config-file nodes</vh></v>
</v>
<v t="ekr.20041115110846.1"><vh>Code</vh>
<v t="ekr.20031218072017.1145"><vh>update (config)</vh>
<v t="ekr.20031218072017.1146"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2083"><vh>updateRecentFiles</vh></v>
<v t="ekr.20041115110846.2"><vh>From leoFileCommands</vh>
<v t="ekr.20031218072017.2064"><vh>getFindPanelSettings</vh>
<v t="ekr.20031218072017.2065"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2062"><vh>getPrefs</vh>
<v t="ekr.20031218072017.2063"><vh>getTargetLanguage</vh></v>
</v>
<v t="ekr.20031218072017.3035"><vh>putFindSettings</vh>
<v t="ekr.20031218072017.3036"><vh>&lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2066"><vh>putPrefs</vh>
<v t="ekr.20031218072017.2067"><vh>&lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt; (putPrefs)</vh>
<v t="ekr.20031218072017.2068"><vh>&lt;&lt; put default directory &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040324080819"><vh>&lt;&lt; update leoConfig.txt &gt;&gt;</vh></v>
</v>
<v t="ekr.20041115110846.3"><vh>From leoTkinterPrefs</vh>
<v t="ekr.20031218072017.4134"><vh>onOK, onCancel, onRevert</vh></v>
</v>
<v t="ekr.20041115110846.4"><vh>Apply Config command</vh>
<v t="ekr.20031218072017.3774"><vh>&lt;&lt; define help menu tables &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2944"><vh>applyConfig</vh></v>
</v>
</v>
<v t="ekr.20041116091233" a="E"><vh>Config postings</vh>
<v t="ekr.20041116091233.2"><vh>Key principle &amp; corollaries</vh></v>
<v t="ekr.20041116091233.10"><vh>The shape of the new design</vh></v>
<v t="ekr.20041116091233.11"><vh>Format of the @settings tree</vh></v>
<v t="ekr.20041116125049"><vh>Improvements</vh></v>
</v>
</v>
<v t="ekr.20041117062700" a="TV"><vh>leoNewConfig.py</vh>
<v t="ekr.20041117062700.2"><vh>Old code (ref)</vh>
<v t="ekr.20041117062700.3"><vh>OLD define defaultsDict</vh></v>
<v t="ekr.20041117062700.4"><vh>config.__init__</vh>
<v t="ekr.20041117062700.5"><vh>&lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt; (leoConfig)</vh></v>
<v t="ekr.20041117062700.6"><vh>&lt;&lt; initialize ivars that may be set by config options &gt;&gt;</vh></v>
</v>
<v t="ekr.20041117062700.7" a="E"><vh>getters/setters</vh>
<v t="ekr.20041117062700.8"><vh>get...FromDict &amp; setDict</vh></v>
<v t="ekr.20041117062700.9"><vh>get/setColors</vh></v>
<v t="ekr.20041117062700.10"><vh>get/setComparePref</vh></v>
<v t="ekr.20041117062700.11"><vh>get/setFindPref</vh></v>
<v t="ekr.20041117062700.12"><vh>get/setPref</vh></v>
<v t="ekr.20041117062700.13"><vh>get/setRecentFiles</vh></v>
<v t="ekr.20041117062700.14"><vh>get/setWindowPrefs</vh></v>
<v t="ekr.20041117062700.15"><vh>config.getFontFromParams</vh></v>
<v t="ekr.20041117062700.16"><vh>getShortcut (config)</vh></v>
<v t="ekr.20041117062700.17"><vh>init/Boolean/ConfigParam</vh></v>
<v t="ekr.20041117062700.18"><vh>setCommandsFindIvars</vh></v>
<v t="ekr.20041117062700.19"><vh>setCommandsIvars</vh>
<v t="ekr.20041117062700.20"><vh>&lt;&lt; set prefs ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20041117062700.21"><vh>setConfigFindIvars</vh></v>
<v t="ekr.20041117062700.22"><vh>c.setConfigIvars</vh></v>
</v>
<v t="ekr.20041117062700.23" a="E"><vh>open</vh>
<v t="ekr.20041117062700.24"><vh>&lt;&lt; get config options &gt;&gt;</vh></v>
<v t="ekr.20041117062700.25"><vh>&lt;&lt; get recent files &gt;&gt;</vh></v>
<v t="ekr.20041117062700.26"><vh>&lt;&lt; create rawKeysDict without ampersands &gt;&gt; (config)</vh></v>
<v t="ekr.20041117062700.27"><vh>&lt;&lt; convert find/change options to unicode &gt;&gt;</vh></v>
<v t="ekr.20041117062700.28"><vh>&lt;&lt; print options &gt;&gt;</vh></v>
</v>
<v t="ekr.20041117062700.29" a="E"><vh>update (config)</vh>
<v t="ekr.20041117062700.30"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="ekr.20041117062700.31"><vh>update_section</vh></v>
</v>
<v t="ekr.20041117062700.1"><vh>TO DO</vh></v>
<v t="ekr.20041117093009"><vh>Move to gui code</vh>
<v t="ekr.20041117062717.27"><vh>update (config)</vh>
<v t="ekr.20041117062717.28"><vh>&lt;&lt; write recent files section &gt;&gt;</vh></v>
</v>
<v t="ekr.20041117062717.29"><vh>update_section </vh></v>
</v>
<v t="ekr.20041117090429"><vh> To be moved out of this class</vh>
<v t="ekr.20041117062717.16"><vh>setCommandsFindIvars</vh></v>
<v t="ekr.20041117062717.20"><vh>c.setConfigIvars PROBABLY WILL NOT BE USED</vh></v>
<v t="ekr.20041117062717.25"><vh>&lt;&lt; convert find/change options to unicode &gt;&gt;</vh></v>
<v t="ekr.20041117062717.19"><vh>setConfigFindIvars PROBABLY WILL NOT BE USED</vh></v>
<v t="ekr.20041117062717.17" a="E"><vh>setCommandsIvars</vh></v>
</v>
<v t="ekr.20041117062700.32" a="E"><vh>New code</vh>
<v t="ekr.20041117062717.1"><vh>&lt;&lt; define defaultsDict &gt;&gt;</vh></v>
<v t="ekr.20041117072055"><vh>&lt;&lt; define ivarsDict &gt;&gt;</vh></v>
<v t="ekr.20041117083202"><vh>Birth...</vh>
<v t="ekr.20041117062717.2"><vh>ctor &amp; init</vh></v>
<v t="ekr.20041117065611.1"><vh>initEncoding</vh></v>
<v t="ekr.20041117065611"><vh>initIvar</vh></v>
<v t="ekr.20041117065611.2"><vh>initIvarsFromSettings</vh></v>
<v t="ekr.20041117062717.24"><vh>initRawKeysDict</vh></v>
<v t="ekr.20041117083202.2"><vh>initRecentFiles (revise)</vh></v>
<v t="ekr.20041117083857"><vh>initSettingsFiles</vh></v>
<v t="ekr.20041117085625"><vh>openSettingsFile</vh></v>
</v>
<v t="ekr.20041117081009"><vh>Getters...</vh>
<v t="ekr.20041117083141"><vh>get</vh></v>
<v t="ekr.20041117081009.3"><vh>getBool</vh></v>
<v t="ekr.20041117093009.1"><vh>getDirectory</vh></v>
<v t="ekr.20041117081513"><vh>getInt</vh></v>
<v t="ekr.20041117082135" a="E"><vh>getFloat</vh></v>
<v t="ekr.20041117093009.2"><vh>getLanguage TODO</vh></v>
<v t="ekr.20041117062717.11"><vh>getRecentFiles</vh></v>
<v t="ekr.20041117081009.4"><vh>getString</vh></v>
<v t="ekr.20041117062717.13"><vh>getFontFromParams</vh></v>
<v t="ekr.20041117062717.14"><vh>getShortcut</vh></v>
</v>
<v t="ekr.20041117093246" a="E"><vh>Scanning @settings</vh>
<v t="ekr.20041117083857.1" a="E"><vh>readSettings TO DO</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040422132037.4">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2373816
By: sbeards

A related issue is that leoConfig.txt gets auto-tangled and overwritten on startup.
This will be a problem if Leo is run by a non-root user or the file is not readable.
For example, I get the following traceback after starting Leo (when leoConfig.txt
is read-only):

Traceback (most recent call last):
  File "/usr/local/share/leo-4.1-rc3/src/leoConfig.py", line 672, in update
    cf = open(self.configFileName,mode)
IOError: [Errno 13] Permission denied:
'/usr/local/share/leo-4.1-rc3/src/../config/leoConfig.txt'

Is there a reason leoConfig.txt gets auto-tangled on startup? Is there anyway
to disable this? Is this by design?
</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040606193130"></t>
<t tx="EKR.20040606193323">@nocolor

Open discussion
http://sourceforge.net/forum/message.php?msg_id=2603738

I always set tabs to -4 in the config. when you open the prefs it says 4 but
there is a checkmark for convert tabs to space. open a new leo, open prefs. its
not checked! open another leo, its checked.

The problem is that tab_width is usually stored in leoConfig.txt, not the .leo file.
I'm going to ignore this problem for now...</t>
<t tx="ekr.20031218072017.651">http://sourceforge.net/forum/message.php?msg_id=2312787
By: RodrigoB.

let the configuration interface be a Plugin defining @config-file nodes.

When selecting such nodes (or descendents) the body, the body text is parsed to construct a tk dialog directly into the
body pane, replacing the text view (or as a window element in the text.)

When modifying the menu, the text is changed. If something go wrong with the
text format, an error is raised and the original text is show.

Advantages:

- Easier to devellop and integrates well with leoConfig.leo.
- Allows the configuration to be a hierarchy of nodes, similar to the linux kernel configuration.

The text format could be:

option1 = 1 # checkbox (type data for plugin)
option2 = bla # [bla, blo, bli] (plugins show a combo box with bla, blo, bli
option3 = rodrigo # text  etc.

The comment after the option could allow to specify python code for conditions,
etc, etc

Cmments can be placed, the line before, or the line after, or under what ever format required.</t>
<t tx="ekr.20031218072017.653">@nocolor

Visually, jEdit's "Global Options" dialogs are impressive.  There is a tree view on the left, with a unique panel on the left for each item in the tree view.  All options are set visually.

I like the opening up leoConfig.leo and setting options in a typical Leo window.  The advantage of leoConfig.leo is that there is plenty of room to explain what each setting does.

Leo's Set Colors and Set Font dialogs can and should affect the settings in leoConfig.leo, but at present they only affect leoConfig.txt, which is most annoying, and basically wrong.

EKR:

Most of Leo's difficulties with configuration options stems from me trying to work around the limitations of Python's ConfigParser module.  Relying on this module may be the worst mistake I have made in the Python version of Leo.  This mistake has had several ramifications:

-  leoConfig.leo uses @root trees rather than @file trees because ConfigParser deletes all comments when writing leoConfig.txt.  Suppose instead that Leo would read and write leoConfig.txt without the "help" of the ConfigParser module.  For reading, all that is needed is that Leo parse leoConfig.txt into a single configuration dictionary.  This would, in fact, be very easy to do.

- Leo needs to do a better job of ensuring that leoConfig.txt always matches the settings in effect.  This can be done if Leo can _rewrite_ leoConfig.txt as it was (with all comments and especially sentinel lines), merely substituting new settings for old.  This is only slightly harder to do.

Other improvements come to mind, not directly related to the problems with ConfigParser:

- There should be a separate Settings Menu.  This would have the Set Colors and Set Font commands, as well as the following commands: Edit Settings (Same as present Open leoConfig.leo command) and Use Default Settings command (rewrites leoConfig.txt using preset defaults) and possibly Set Default Settings, Apply Settings and Revert Settings commands.

- All classes that use configuration settings should implement a configure method that immediately updates settings to the values just written to leoConfig.txt.  This includes the commands, frame and tree classes, and others.

With this long background, there are two main approaches to improving how Leo handles options:

1. Use a graphical scheme like jEdit does, and dispense with leoConfig.leo entirely.  leoConfig.txt would be the only repository for options.  This graphical scheme would use typical Apply, Revert, OK and Cancel buttons, much like the present Set Colors and Set Font dialogs.

2. Improve how Leo handles leoConfig.leo and leoConfig.txt so that leoConfig.leo can use @file trees and so that settings are _reliably_ updated when the user would expect them to be.

At present, I favor the second scheme.  It is simple to implement, it is the most Leonine, and moreover it allows for full discussion of all options.  True, the graphical way is good looking, but that is about all it has going for it.  I suppose a help feature could be added to the graphical way, but we are talking about a lot of effort for very little real value to the user.

Actually though, the issues of keeping leoConfig.txt up-to-date and of applying settings immediately remain mostly the same regardless of which way is chosen.  In particular, without the "help" of the ConfigParser module Leo could maintain options much more easily.

Anyway, this is how I see matters.  Any comments?

Edward
</t>
<t tx="ekr.20031218072017.655">@nocolor

&gt; It just leaves still the problem of merging ones personal settings of leoConfig.txt 
with the ones in the new distribution. 

I am going to work on this just after 3.11b1 goes out the door. I think what I shall do is have Leo looks for several different files: first leoConfig.txt, then leoSiteConfig.txt, with the latter overriding the former. That way you can have stable settings (leoSiteConfig.txt won't be part of distributions). 

I may also have Leo look for leoLinuxConfig.txt, leoWinConfig.txt and leoMacConfig.txt, depending on the platform, so you can have stable platform settings as well. </t>
<t tx="ekr.20031218072017.656">@nocolor

By: sanori ( Joo-won Jung ) 
 How about split font config for win and unix?   
2003-02-10 12:02  
Developer Forum

How about split the font's configurations like IDLE, python IDE? 
Because the 10pt size in Windows and Unix (X window, exactly) is not the same. Moreover, the font set that the OS provides does not the same. 

I'm using leo on both windows and Linux, and leo is in the vfat partition to use it both OS. Of course, I can change the font size by using the font dialog. But, I want leo to be more comportable. :)

-Sanori 
</t>
<t tx="ekr.20031218072017.828"></t>
<t tx="ekr.20031218072017.1145"># Before 4.3: called when writing .leo file.  This had various unpleasant consequences.
# After  4.3: called immediately when a setting changes, and never when writing .leo files.

def update (self,verbose=False):
    
    g.trace()
    """Write the entire config file from ivars."""
    # Do nothing if the file does not exist, or if read_only.
    if self.read_only:
        if verbose:
            g.es("Read only config file",color="blue")
        return
    if not g.os_path_exists(self.configFileName):
        if verbose:
            g.es("No config file",color="blue")
        return
    
    config = ConfigParser.ConfigParser()
    self.config = config
    try:
        # 9/1/02: apparently Linux requires w+ and XP requires w.
        mode = g.choose(sys.platform=="win32","wb","wb+")
        cf = open(self.configFileName,mode)
        config.readfp(cf)
        &lt;&lt; write recent files section &gt;&gt;
        for section,dict in self.sectionInfo:
            if dict:
                self.update_section(config,section,dict)
        config.write(cf)
        cf.flush()
        cf.close()
    except:
        g.es("exception writing: " + self.configFileName)
        g.es_exception()
    self.config = None</t>
<t tx="ekr.20031218072017.1146">section = self.recentFilesSection
files = self.recentFiles

section = g.toEncodedString(section,"utf-8") # 10/31/03

if config.has_section(section):
    config.remove_section(section)
config.add_section(section)

if 0: # elegant, but may be a security hole.
    config.set(section,"recentFiles",files)
else: # easier to read in the config file.
    for i in xrange(len(files)):
        f = g.toEncodedString(files[i],self.config_encoding) # 10/31/03
        config.set(section, "file"+str(i), f)</t>
<t tx="ekr.20031218072017.2062">def getPrefs (self):

    c = self.c ; config = g.app.config
    
    if self.getOpenTag("&lt;preferences"):
        return # &lt;preferences/&gt; seeen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))
    
    done = False
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("/&gt;"):
                done = True ; break
            if self.matchTag("&gt;"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    if not done: # 8/31/04
        while 1:
            if self.matchTag("&lt;defaultDirectory&gt;"):
                # New in version 0.16.
                c.tangle_directory = self.getEscapedString()
                self.getTag("&lt;/defaultDirectory&gt;")
                if not g.os_path_exists(c.tangle_directory):
                    g.es("default tangle directory not found:" + c.tangle_directory)
            elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
                self.getEscapedString() # ignored
                self.getTag("&lt;/TSyntaxMemo_options&gt;")
            else: break
        self.getTag("&lt;/preferences&gt;")

    # Override .leo file's preferences if settings are in leoConfig.txt.
    if config.configsExist:
        config.setCommandsIvars(c)</t>
<t tx="ekr.20031218072017.2063">def getTargetLanguage (self):
    
    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language
            
    return "c" # default</t>
<t tx="ekr.20031218072017.2064">def getFindPanelSettings (self):

    c = self.c ; config = g.app.config ; findFrame = g.app.findFrame
    &lt;&lt; Set defaults of all flags &gt;&gt;
    if not self.getOpenTag("&lt;find_panel_settings"):
        while 1:
            if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
            elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
            elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
            elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
            elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
            elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
            elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
            elif self.matchTag("script_change="): c.script_change_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("script_search="): c.script_search_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
            elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
            elif self.matchTag("selection_only="): c.selection_only_flag = self.getDqBool() # 11/9/03
            elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
            elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
            elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
            elif self.matchTag("&gt;"): break
            else: self.getUnknownTag() # New in 4.1: ignore all other tags.

        # # 7/31/04: Allow only &lt;find_string&gt; or &lt;find_string/&gt;
        if self.getOpenTag("&lt;find_string&gt;"): 
            c.find_text = ""
        else:
            c.find_text = self.getEscapedString()
            self.getTag("&lt;/find_string&gt;")
        # 7/31/04: Allow only &lt;change_string&gt; or &lt;change_string/&gt;
        if self.getOpenTag("&lt;change_string&gt;"): 
            c.change_text = ""
        else:
            c.change_text = self.getEscapedString()
            self.getTag("&lt;/change_string&gt;")
        #
        self.getTag("&lt;/find_panel_settings&gt;")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    config.setCommandsFindIvars(c)
    # Update the settings immediately.
    if g.app.gui.guiName() == "tkinter":
        g.app.findFrame.init(c)</t>
<t tx="ekr.20031218072017.2065">if g.app.gui.guiName() == "tkinter":

    for var in findFrame.intKeys:
        attr = "%s_flag" % (var)
        setattr(c,attr,False)
        # g.trace(attr)
</t>
<t tx="ekr.20031218072017.2066">def putPrefs (self):

    c = self.c ; config = g.app.config
    
    if 1: # New in 4.3:  This settings never get written here.
        self.put("&lt;preferences/&gt;") ; self.put_nl()
    else:
        self.put("&lt;preferences")
        if 0:
            self.put(" allow_rich_text=") ; self.put_dquoted_bool(0) # no longer used
        &lt;&lt; put prefs that may exist in leoConfig.txt &gt;&gt;
        self.put("&lt;/preferences&gt;") ; self.put_nl()</t>
<t tx="ekr.20031218072017.2067">language = c.target_language
for name in xml_language_names:
    s = string.lower(name)
    s = string.replace(s,"/","")
    if s == language:
        language = name ; break

if config.configsExist and not config.read_only: # 8/6/02
    pass # config.update has already been called.
else:
    self.put(" defaultTargetLanguage=") ; self.put_in_dquotes(language)
    self.put(" node_only=") ; self.put_dquoted_bool(c.node_only_flag)
    self.put(" output_doc_chunks=") ; self.put_dquoted_bool(c.output_doc_flag)
    self.put(" page_width=") ; self.put_in_dquotes(str(c.page_width))
    self.put(" tab_width=") ; self.put_in_dquotes(str(c.tab_width))
    self.put(" tangle_bat=") ; self.put_dquoted_bool(c.tangle_batch_flag)
    self.put(" untangle_bat=") ; self.put_dquoted_bool(c.untangle_batch_flag)
    self.put(" use_header_flag=") ; self.put_dquoted_bool(c.use_header_flag)

self.put("&gt;") ; self.put_nl()
# New in version 0.16
&lt;&lt; put default directory &gt;&gt;</t>
<t tx="ekr.20031218072017.2068">if config.configsExist:
    pass # Has been done earlier.
elif len(c.tangle_directory) &gt; 0:
    self.put_tab()
    self.put("&lt;defaultDirectory&gt;")
    self.putEscapedString(c.tangle_directory)
    self.put("&lt;/defaultDirectory&gt;")
    self.put_nl()</t>
<t tx="ekr.20031218072017.2083">def updateRecentFiles (self,fileName):
    
    """Create the RecentFiles menu.  May be called with Null fileName."""
    
    # g.trace(fileName)
    
    # Update the recent files list in all windows.
    if fileName:
        normFileName = g.os_path_norm(fileName)
        for frame in g.app.windowList:
            c = frame.c
            # Remove all versions of the file name.
            for name in c.recentFiles:
                if normFileName == g.os_path_norm(name):
                    c.recentFiles.remove(name)
            c.recentFiles.insert(0,fileName)
            # Recreate the Recent Files menu.
            frame.menu.createRecentFilesMenuItems()
    else: # 12/01/03
        for frame in g.app.windowList:
            frame.menu.createRecentFilesMenuItems()
        
    # Update the config file.
    g.app.config.setRecentFiles(self.recentFiles) # Use self, _not_ c.
    g.app.config.update()</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
lst: a list (Do _not_ use list, it is a Python global!)
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode

For more documentation, see the node called "Overview of Leo's code" in LeoDocs.leo.</t>
<t tx="ekr.20031218072017.2415"></t>
<t tx="ekr.20031218072017.2418">def initScriptFind(findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
    
    import leoTest
    import leoGlobals as g
    
    # Find the scripts.
    c = g.top() ; p = c.currentPosition()
    u = leoTest.testUtils()
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    g.app.findFrame.init(c)
    c.findPanel()</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2944">def applyConfig (self):

    c = self
    g.app.config.init()
    c.frame.reconfigureFromConfig()</t>
<t tx="ekr.20031218072017.3035">def putFindSettings (self):

    c = self.c ; config = g.app.config
    
    if 1: # New in 4.3:  This settings never get written here.
        self.put("&lt;find_panel_settings/&gt;") ; self.put_nl()
    else:
        self.put("&lt;find_panel_settings")
        &lt;&lt; put find settings that may exist in leoConfig.txt &gt;&gt;
        self.put("&lt;/find_panel_settings&gt;") ; self.put_nl()</t>
<t tx="ekr.20031218072017.3036">if config.configsExist and not config.read_only:
    pass # config.update has already been called.
else:
    self.put_flag(c.batch_flag,"batch")
    self.put_flag(c.ignore_case_flag,"ignore_case")
    self.put_flag(c.mark_changes_flag,"mark_changes")
    self.put_flag(c.mark_finds_flag,"mark_finds")
    self.put_flag(c.pattern_match_flag,"pattern_match")
    self.put_flag(c.reverse_flag,"reverse")
    self.put_flag(c.search_headline_flag,"search_headline")
    self.put_flag(c.search_body_flag,"search_body")
    self.put_flag(c.suboutline_only_flag,"suboutline_only")
    self.put_flag(c.whole_word_flag,"whole_word")
    self.put_flag(c.wrap_flag,"wrap")
    self.put_flag(c.node_only_flag,"node_only")

self.put("&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
    self.put_tab()
    self.put("&lt;find_string&gt;&lt;/find_string&gt;") ; self.put_nl()
else:
    self.put_tab()
    self.put("&lt;find_string&gt;") ; self.putEscapedString(c.find_text)
    self.put("&lt;/find_string&gt;") ; self.put_nl()

if config.configsExist and not config.read_only: # 8/6/02
    self.put_tab()
    self.put("&lt;change_string&gt;&lt;/change_string&gt;") ; self.put_nl()
else:
    self.put_tab()
    self.put("&lt;change_string&gt;") ; self.putEscapedString(c.change_text)
    self.put("&lt;/change_string&gt;") ; self.put_nl()</t>
<t tx="ekr.20031218072017.3625"></t>
<t tx="ekr.20031218072017.3774">self.helpMenuTopTable = (
    ("&amp;About Leo...",None,c.about),
    ("Online &amp;Home Page",None,c.leoHome),
    ("-",None,None),
    ("Open Online &amp;Tutorial",None,c.leoTutorial),
)
    
self.helpMenuTop2Table = (
    ("Open &amp;Offline Tutorial",None,f.leoHelp),
)
    
self.helpMenuTop3Table = (
    ("Open Leo&amp;Docs.leo",None,c.leoDocumentation),
    ("-",None,None),
    ("Open Leo&amp;Config.leo",None,c.leoConfig),
    # ("Apply &amp;Settings",None,c.applyConfig),
)</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.4134">def onOK (self):
    """Handle a click in the OK button in the tkinter Prefs panel."""
    g.app.config.setConfigIvars(self.c)
    g.app.config.update()
    self.hide()

def onCancel (self):
    """Handle a click in the Cancel button in the tkinter Prefs panel."""
    c = self.c
    self.restoreOptions()
    self.init(c)
    self.set_ivars(c)
    self.hide()

def onRevert (self):
    """Handle a click in the Revert button in the tkinter Prefs panel."""
    c = self.c
    self.restoreOptions()
    self.init(c)
    self.set_ivars(c)</t>
<t tx="ekr.20040124073801"></t>
<t tx="ekr.20040212094034">@nocolor
http://sourceforge.net/forum/message.php?msg_id=2420426
By: dalcolmo

Please move all global configuration options to one place. Currently, besides
having to edit leoConfig.leo, I have also to edit leoPlugins.leo or
pluginsManager.txt

I believe, these should also be configuration settings.

Best regards - Josef Dalcolmo</t>
<t tx="ekr.20040213060739">By: nobody ( Nobody/Anonymous ) 
 RE: 4.1rc4 Plug-in Bug?   
2004-02-13 03:32  

If you write protect leoconfig.txt you also notice via traceback that it opens for write on entry too, not sure if it actually writes anything at that time.</t>
<t tx="ekr.20040225061559">@nocolor

Is there a way that a "new" Leo installation could query the older one for config data?

Every time I get a new copy, I need to do a side-by-side compare and edit with the previous leoConfig.leo in order to change the settings to the way I want them. It would be really nice if this could be automated in some fashion.</t>
<t tx="ekr.20040226105601">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2434323
By: Tom

In Alpha, like Emacs, their are "modes" specfic to each language that give you
useful functionality when you are editing code in that language.

- Each mode has its own namespace (e.g. 'pyth' for the python Mode) that hold
all the variables and functions that provide the functionality mentioned above.

- There is a set of variables and functions that form a sort of "global mode"
that would be useful in editing plain text, and provides values and simple
editting bahavior if no such simularly named things exists in the pyth
namespace, if these do exist, them overide these global values &amp; functions when
in that editting mode.

- Modes are held in a directory named "Modes", in Leo this would probably be a
subdirectory of 'plugins'. In Alpha a simple mode can be defined in a single
file, Leo should proabably use the multi-file method, each mode is given its own
subdirectory (e.g. ...\plugins\Modes\Python Mode\), then various files to define
that mode's functionality would be placed in that directory. Thus you could
include the syntax files directly from jEdit here. 

Alpha only loads modes as needed. For example, if a user never edits a c++ file
in a session, Alpha never loads in the details of the C Mode (which includes
c++), it knows it has a C Mode, what file extensions it should activate for &amp;
has a short description to give if the users ask for help on the mode, but only
loads the rest of the code that defines the mode if it is called on to edit a c
or c++ file. It does this by scanning all of the subdirectories files for a
function call that has all this info as parameters. These are gathered into a
cache (a script file) that gets executed when alpha starts up. This cache has a
dictionary of filenames to modification dates so that the cache remains valid as
long as the files scanned are already in the dictionary and have the same
modification dates. Any conflict gets caught at start-up and triggers a
rescanning. 

Alpha has a function, 'newPref', that builds dictionaries of various kinds of
variables, consisting of variable_name to a tuple. That tuple varies according
to the type of variable, but has as a minimum, the default value and the
namespace it is to be created in. Other parts of the tuple might include a list
of the possible values, or a series of tuples (&lt;text to present in drop down
box&gt;, &lt;value&gt;). Any change by the user to a value other than the default gets
that choice written to a cache that gets loaded the first time a mode is
activated. When newPref executes it checks to see if the variable already
exists, and only creates that variable and intializes it to the default if it
doesn't. A further wrinkle is that any comment immediately preceding a newPref
call gets stored as help text for that variable.

These dictionaries are used to allow the configuration dialog for a mode be
automatically created on the fly. Flag dictionaries get their keys dumped and
sorted to create an array of checkboxes, their stored comments forms a "tooltip"
box of text displayed when the arrow hovers over the checkbox.

Other dictionaries drive other types of widgets in the dialog panes.

Much of this could be adapted to Leo. Other things to check out
are the keysetting dialogs, an example of which is under "Config-&gt;Special
Keys...".

File structure: Alpha has the equivalent of a plugin directory, however, the
actual plug-ins are organized in subdirectories; files that tell alpha how to
support languages are placed in the "Modes" directory, files that add
functionality exposed primarily through an add-in menu are placed in the "Menus"
directory (Leo might use "Menus &amp; Widgets" to include things like the new search
plug-in), other code that provides functionality that is not tied to a
particular language, and is not primarily invoked via a menu are placed in the
"Packages" directory, (e.g. the completion package that provide general word
completion).

This helps out when someone wants to roll their own code, if you want to add a
language look at the examples that are in the 'Modes' directory, you can quickly
cobble together elementary support and then extend it over time.

Installing a plug-in is really just a matter of putting the files in the right
place and have Alpha update its indexes. Now that does not mean that the new
features are enabled (other than for a language, those activate whenever Alpha
realises that it is editting a file of that language), if you go to
"Config-&gt;Global-Setup-&gt;Features" or "Config-&gt;Global-Setup-&gt;Menus", you get a
panel of checkboxes for Features or Menus that you can check to enable Globally,
(i.e. no matter what mode is currently active). Note that a tooltip box giving a
description is available whenever you hover the mouse over the feature/menu
name. These are built dynamically, are sorted alphabetically, and continued on
another page whenever their are too many to position on a single page. This
means no carefully redesign of a dialog box is needed to accomadate new
features.

The preferences for a language are only settable when a given mode is active.
Although in Alpha this is dependent on the file you are editing, Leo can be
thought of as in a given language mode dependent on what language directive is
in effect for the current cursor position. Once you are in a mode, the
"Config-&gt;&lt;mode&gt; Mode Prefs" Menu becomes active, Allowing you to choose what
Menus &amp; Feature you would like available when you are in this mode. You also
have access to the Preferences that are available in that mode.

Note that any preference, feature set, menus that you chose are all store in a
cache of code that sets them to your chosen values whenever you start Alpha.
These values can be saved and used when you upgade to a new version (of Alpha or
any of its packages), conversely, discarded the Prefs directory restores you to
all the defaults as orginally specified. Mechanisms exist to prune out cached
values that are no longer used, and to ensure that a new variable that has been
added is set if it needs to be before some code gets executed.</t>
<t tx="ekr.20040321065415">def findNodeInTree(p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    c = p.c
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(headline):
    
    c = g.top()
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(headline):
    
    c = g.top()
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20040324080819">if 0: # Not done in 4.3.
    c.setIvarsFromFind()
    config.setConfigFindIvars(c)
    c.setIvarsFromPrefs()
    config.setCommandsIvars(c)
    config.update()</t>
<t tx="ekr.20040327050211"></t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040330092305">@nocolor

&gt; I don't know how to read [an @file-nosent config] file into the body of that node.

You can't, at least not automatically.  Leo needs sentinels in order to read a derived file, that is, in order to update the outline using information in a derived file.

I've been dithering about exactly what to do about configuration files.  Your question reminds me that we would prefer to have sentinels in config files.  In order to do that, Leo must preserve comments in config files, which of course would be much better than the present pathetic situation in which Python's configParser module strips comments.  As I have said before, using configParser was a blunder. 

Edward</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.2 final, build %s, September 20, 2004" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.173 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = g.app.config.getWindowPref("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, %s" % (n1,n2,n3,tkLevel,sys.platform))
    g.enl()</t>
<t tx="ekr.20040919075839">By: Stephen Schaefer - thyrsus
RE: 4.2 rc1 released  
2004-09-18 05:32

It took me two hours to track it down, but I did manage to get leoConfit.txt and .leoID.txt to be taken from $HOME/.leoconfig

I created that file with the following contents (. for leading space):

@color

import sys
import os
try:
    sys.leo_config_directory = os.environ['HOME'] + '/.leoconfig'
except KeyError:
    sys.leo_config_directory = None
    
@nocolor

If I were more sophisticated, I would check that $HOME/.leoconfig was a directory, and if not also set sys.leo_config_directory to None.

- It doesn't seem appropriate to insist that anyone using python 2.3.2 for any reason whatsoever would be forced to have a .leoconfig in their home directory (think of a limited account that doesn't have a writable home directory)

- It would be appropriate for leo to create $HOME/.leoconfig if it weren't present and set sys.leo_config_directory at that point -- indeed the entire logic could be handled outside of sitecustomize.py. I'll post code for the above if someone else doesn't beat me to it :-).</t>
<t tx="ekr.20040922073523">@killcolor
http://sourceforge.net/forum/message.php?msg_id=2769775
By: nobody

Leo should make it a priority to determine leoID
and users HOME and other dir of interest
before plugins are loaded

g.app.leoID not defined but g.app.loadDir and many others are.

</t>
<t tx="ekr.20040924081853">https://sourceforge.net/forum/message.php?msg_id=2771155
By: nobody

&gt;&gt;I'll get everything correct eventually :-)

with no doubt many security and data integrity
roadblocks along the way. I stumbled on to
the leoID not being set yet in htmlize.
rather than only adding a leoID to the temp file
created in %tmp% I would much prefer to
put the file into the users %HOME% to avoid
using %tmp% as it shows up on the bugtrack
as a security hole in so many apps.
lets not have Leo get its widest exposure that way.
plugins should not have to roll their own access to the same areas the config
will later need anyway. for now, I will just defer creating such
filenames till the first time they are needed.

e
</t>
<t tx="ekr.20040928085738">https://sourceforge.net/forum/message.php?msg_id=2776098
By: nobody

do we not discuss config options after every release?
it is worth taking the time to get it right.

&gt;&gt;This is a happy development. It means that there is now a natural way to keep
three kinds of configuration options:
per-project options in .leo files, per-user options in a leoConfig.txt file
in the user's home directory, and per-installation in a leoConfig.txt file in
Leo's installation directory.

the exact details of conflict resolution to be announced?
the leo, then the user, then the system. for everything?
can the leo specify its local plugin directory, leoID?
that could have implications for downloading a leo.
the local leo options would seem to need an override.
a ./config in the same dir, env variable or commandline.
maybe if the leoID is different than the users
all destructive options should be overridden.
it would then be up to the user only to determine
if the leoID is different than their own to be safe.
safe meaning no reads or writes outside the current dir.
probably a long list of other restrictions.


I noticed this in docutils doc's
see the docutils config help file, paraphrased:

"The default implicit config file paths can be overridden by the DOCUTILSCONFIG
environment variable. DOCUTILSCONFIG should contain a colon-separated
(semicolon-separated on Windows) sequence of config file paths to search
 ...
In addition, a configuration file may be explicitly specified with the "--config"
command-line option. "

continuing: "docutils uses ConfigParser"

I wonder if subclassing and adding support
for comments (a glaring oversight) would improve things.
although, I see mentioned in docutils config page,
Lines beginning with "#" or ";" are ignored and may be used to provide comments.
perhaps I misremember ConfigParser eating comments.
maybe it doesn't rewrite them in the correct order?
I dont think many programs rewrite their configs, so
this is probably not a problem for them.

the rearranging of rewritten config options is wrong.
but as with many of the config methods utilizing an
undecorated dict, it would have to be determined
if useful enough to go through the trouble to maintain
the origional order. and then, what happens to new values,
are they inserted or appended. the comments saved too.
are the section names themselves rearanged in the file?
many of us will in a pinch hand edit or machine generate
or read config files and the less surprize the better.

there are about 5 other config modules out there
attempting to fix various problems in ConfigParser.
some projects subclass ConfigParser to their own design,
(from memory) pygame, distutils among others.
I realize the "not invented here syndrome" will preclude
using any of these in Leo, but perhaps like twisted often
does, they can be branched into Leo and worked on directly.
plugin ini files should be able to use 
(but not required to use) what Leo knows 
to parse config files or use config options
as early as possible while the plugins are loading.
storing them in ../plugins makes them global to all users.
the user might even want their own plugins dir. 
concider Leo is installed not writable to a user.
they can then not use any custom plugins.
the ability to turn off plugins already loaded
would require Leo to support unhook of some kind
and loading plugins on demand when apply config
could be a problem on some plugins.
how far should the new config go with plugins?
pluginManager.txt isn't very user friendly, forcing
all leo's to have the same plugins all the time.

&lt;http://docutils.sf.net/docs/config.htm&gt;
&lt;http://www.tundraware.com/Software/tconfpy&gt;
&lt;https://sourceforge.net/projects/config-py/&gt;  
  attempting to be a replacement for ConfigParser
  no mention of comments in the config files though.
&lt;http://cvs.zope.org/%2Acheckout%2A/ZODB3/ZConfig/doc/zconfig.pdf?rev=HEAD
ZConfig&gt;
  I haven't looked at it, but,
  can be used separately and has distro on pypi
     &lt;http://www.python.org/pypi&gt;
     &lt;http://www.zope.org/Members/fdrake/zconfig/&gt;
&lt;http://www.voidspace.org.uk/atlantibots/pythonutils.html&gt;
   configobj does support comments.

I don't know which if any of these support unicode, 
in later version of ConfigParser, unicode may be ok.
filenames on many systems are unicode, Leo is unicode
aware, that would seem to be a necessary option.

py-tconfpy being the most ambitious and flexible,
does support comments. in addition to the standard
config type use, it has a kind of limited python syntax.
worth a look. offloading some of the user customization
smarts into the config file itself is unproven controlable.
the more complicated the config file is, the easier it is
to mess up and the harder it is to recover from mistakes.

&gt;&gt;. In other words it is like blocking the users from setting certain things. 
or from shooting yourself in the foot as root.

e

______________________________________________________________________
You are receiving this email because you elected to monitor this forum.
To stop monitoring this forum, login to SourceForge.net and visit: 
https://sourceforge.net/forum/unmonitor.php?forum_id=10226

</t>
<t tx="ekr.20041002150740.1">@nocolor

</t>
<t tx="ekr.20041113115748">import leoGlobals as g
import leoPlugins

def check():
    import spellpyx
    spellpyx.spellFrame.checkSpelling()

if leoPlugins.isLoaded("spellpyx"):
    check()
else:
    result = leoPlugins.loadOnePlugin("spellpyx")
    if result is None:
        g.es("can not load spellpyx plugin",color="blue")
    else:
        g.es("loaded spellpxy plugin",color="blue")
        check()</t>
<t tx="ekr.20041115094721">@killcolor

- @config tree like hoist?

1. Remove immediate source of update problems

    - (done) Eliminate writes to leoConfig.txt when writing .leo files.
    
    - (done) Eliminate apply settings command.
        (Use the essence of this command in other ways)

    - Have Font/Coloring options update leoConfig.txt immediately.

- Tell g.app.config where to write files.

- Simplest graphical interface

- Listbox of all files.
- Enable, Disable, Revert, Cancel, OK buttons, Enable All, Disable All.
- Selecting an item in the Listbox enables one of the Enable/Disable buttons
- Selecting OK rewrites the file "in place" without altering comment lines.
- Opening file creates one entry for each .py file in plugins directory.

** Decouple leoConfig.txt &amp; leoConfig.leo ??
    - Use leoConfig.leo to specify defaults, panels, etc??
    - Always edit settings using gui.
    - Write a script to "parse" leoConfig.leo?
        - Similar to RidrigoB's idea.</t>
<t tx="ekr.20041115103456.1">@nocolor


@color

dotDir = g.os_path_normabs('./')
home = os.getenv('HOME',default=dotDir)
g.app.homeDir = g.os_path_normabs(home)

@nocolor

on windows this can point many places
best to set HOME if you want it in a specific place.
otherwise it can be %WINDIR%/APPDATA or %ROOT%/APPDATA
APPDATA can be an env variable, probably win2k or later.

# abspath resolves './' sometimes returned curdir
import user, os
print os.path.abspath(user.home) 
print os.path.abspath(os.path.expanduser("~"))

obviously this will need allot of work to get
crossplatform and bulletproof. you would think
it would be easy to know where everything should go
or how to nail down how to find everything.
no such luck, all I've seen is bits and pieces.

</t>
<t tx="ekr.20041115104519">- define g.app.homeDir and g.app.globalDir

Load order first to last: g.app.loadDir, g.app.homeDir, g.app.globalDir
</t>
<t tx="ekr.20041115105258">https://sourceforge.net/forum/message.php?msg_id=2355843
By: rodrigo_b

The better would be to have

$HOME/.leo/
$HOME/.leo/leoConfig.txt
$HOME/.leo/plugins/pluginManager.txt
$HOME/.leo/plugins/&lt;myplugins&gt;.py

look for .leoConfig.txt, then leoConfig.txt</t>
<t tx="ekr.20041115105258.1"></t>
<t tx="ekr.20041115110846">@killcolor

- Do not call app.config.update when writing files.
    - find/change defaults do not change, a _good_ thing.
    - per-file preferences will be stored in an @setting tree

- At present:
    - config.update is called to update recent files...
    - config.update is NOT called after updating colors, prefs, etc.

** Settings must be infinitely flexible.
    - Initial format of body text in @settings tree will be very simple.
    - Creating gui from @setting tree must be customizeable.

New commands:
    - Edit global, user, local prefs.
    - Show @settings outline.
    - Open global leoSettings.leo
    - Open user leoSettings.leo</t>
<t tx="ekr.20041115110846.1"></t>
<t tx="ekr.20041115110846.2"></t>
<t tx="ekr.20041115110846.3"></t>
<t tx="ekr.20041115110846.4"></t>
<t tx="ekr.20041115111203">@killcolor

- Disabled ill-fated Apply Settings command.

- Removed call to config.update from leoFileCommands.write code.

- Write only vestigial &lt;find settings/&gt;

- Write only vestigial &lt;preferences/&gt;
    - Will store prefs in @settings trees.

*** NO changes to the read code.  This ensures compatibility.</t>
<t tx="ekr.20041115165553">@nocolor

@settings outlines are "source code"
    - On startup, traverse these trees to create settings.
    - Create dialogs using these trees
    - Can change defaults/settings by editing this file or via gui.

@setting: delimits outline (usually hidden).  Showing this outline is like a hoist.

Settings outline (in gui) is just a copy of the @settings outline.

Exception:  @page nodes create a single 

Headline is the variable name.  Body has the form:
line 1:  type: value
line 2 (optional): name: name (used to translate)
following lines:  comments

Nodes whose first line is not a type line are organizer nodes.

Gui creates body pane when each outline node is selected.

Types:  string,bool,int,color,font,directory,language,shortcut</t>
<t tx="ekr.20041115165553.1"></t>
<t tx="ekr.20041115165553.2"></t>
<t tx="ekr.20041115165553.3"></t>
<t tx="ekr.20041115165553.4">bool: True

True:  Leo colors @space, @* and @** sections in cweb mode as black with LaTeX keywords highlighted.
False: Leo colors @space, @* and @** sections in cweb mode as comments (default is red).

Note: this setting does not affect how Leo colors noweb section references and defintions.</t>
<t tx="ekr.20041115165553.5">bool: true

True:  Leo colors C language comments in cweb mode as black with LaTeX keywords highlighted.
Flase: Leo colors C language comments in cweb mode as comments (default red).

Note: this setting does not affect how Leo colors noweb section references and defintions.</t>
<t tx="ekr.20041115165553.6">bool: True

True:  Leo colors @directives when @language plain is in effect.
False: Leo colors everything black when @language plain is in effect.</t>
<t tx="ekr.20041115165553.7">bool: True

True: Underline undefined section names
Only functional if use_hyperlinks = 0

</t>
<t tx="ekr.20041115165553.8">bool: False

True:  underline "live" links.
False: (recommended): Underline undefined section names.</t>
<t tx="ekr.20041115165553.9">Syntax colors may be any valid Tk color name or color value.

For example, "00aa00" is the dark green used by IDLE.

See http://www.tcl.tk/man/tcl8.3/TkCmd/colors.htm for a list of valid color
names. These names are case sensitive, for example: BlanchedAlmond.</t>
<t tx="ekr.20041115165553.11">color: firebrick3

The color of comments in code parts.</t>
<t tx="ekr.20041115165553.12">color: red

The color of name in @&lt;name@&gt;</t>
<t tx="ekr.20041115165553.13">color: blue

The color of C/C++ preprocessor directive lines.</t>
<t tx="ekr.20041115165553.14">color: firebrick3

The color of text in doc parts.</t>
<t tx="ekr.20041115165553.15">color: blue

The color of keywords of the present language.
For example, the color of "if", "try" and "except" in Python.</t>
<t tx="ekr.20041115165553.16">color: #00aa00

The color of Leo keywords such as @ignore, @color, etc.</t>
<t tx="ekr.20041115170155">color: red

The color of name in &lt; &lt; name &gt; &gt; when name is defined.</t>
<t tx="ekr.20041115170155.1">color: blue

The color of the double angle brackets in &lt;&lt; name &gt;&gt;

</t>
<t tx="ekr.20041115170155.2">color: Gray90

The background color that represents spaces and tabs when Show Invisibles mode is in effect.</t>
<t tx="ekr.20041115170155.3">color: Gray80

The foreground color that represents spaces and tabs when Show Invisibles mode is in effect.</t>
<t tx="ekr.20041115170155.4">color: #00aa00

The color of strings and their delimiters.

</t>
<t tx="ekr.20041115170155.5">color: red

The color of name in &lt;&lt; name &gt;&gt; when name is undefined.</t>
<t tx="ekr.20041115191203.2">
[config options]

read_only = 0
# 0: Leo writes this file, clearing all comments in the process.
# 1: Leo writes nothing to this file.
#    Syntax errors in this file set this file to read-only.

use_psyco = 0
# 1: use pscho module if it has been installed.
# 0: don't use psyco module

&lt;&lt; .leo file options &gt;&gt;
&lt;&lt; command options &gt;&gt;
&lt;&lt; directory options &gt;&gt;
&lt;&lt; derived files options &gt;&gt;
&lt;&lt; plugins options &gt;&gt;
&lt;&lt; tangle options &gt;&gt;
&lt;&lt; unicode encoding options &gt;&gt;</t>
<t tx="ekr.20041115191203.3">output_initial_comment =
# Example:
# Created by Leo at @date
# A comment to be iserted in derived files just after the initial @+leo line.
# The comment will appear in an @comment sentinel.
# Notes:
# 1. Leo replaces @date with the date and time that the derived file was created.
# 2. Use \n to separate lines.
# 3. This must be empty for compatibility with older versions of Leo.
# 4. Please use an empty comment when updating to CVS!

stylesheet =
# A string, s.  If present, .leo files will contain an xml-stylesheet line following
# the opening xml line. 
# For example:
#   &lt;?xml ....?&gt; 
#   &lt;?xml-stylesheet s?&gt;
# Note 1: The string s should contain any needed XML escapes.
#       Leo simply copies this line as given.
# Note 2: Please set this field empty when uploading to CVS.
# Note 3: This field must be empty for compatibility with older versions of Leo.</t>
<t tx="ekr.20041115191203.4">redirect_execute_script_output_to_log_pane = 0
# 0: Print sends its output to stdout (console) when doing Execute Script command.
# 1: Print redirected to Leo's log pane when doing Execute Script command.

remove_sentinels_extension = .txt
# The string to be appended to file names resulting from the Remove Sentinels command.
# If the value starts with . the extension is appended to the original file name.
# Otherwise, the extension is appended before the file extension.
# Example 1:
#   File name x.y
#   remove_sentinels_extension = _ns
#   Result: x_ns.y
# Example 2:
#   File name x.y
#   remove_sentinels_extension = .txt
#   Result: x.y.txt

save_clears_undo_buffer = 0
# 1: Save command clears undo buffer.
# 0: Undo buffer persists across saves.</t>
<t tx="ekr.20041115191203.5">create_nonexistent_directories = 0
# 1: Leo attempts to create directories if they do not exist.
# 0: Leo never attempts to create directories
# This option applies to directories specified in filenames in
# @file, @rawfile, @root and @silentfile trees, and to filenames
# speicied in the @path directory.

relative_path_base_directory = .
# The directory to be used as a prefix for &lt;filename&gt; in
# @path &lt;filename&gt; and @file &lt;filename&gt; and @root &lt;filename&gt;
# when &lt;filename&gt; is a relative path.
#
# Valid values for this option:
#   "!" means relative to the location leo.py (the default).
#   "." means relative to the location of the .leo file in the top window.
#   An absolute path (in platform-dependent format).
#
# Relative paths are not allowed:
#   Relative paths would be dangerous because their meaning
#   would depend on the changing value of the current working directory.
</t>
<t tx="ekr.20041115191203.6">output_newline = nl
#
# nl or lf: The default: all lines end with "\n"
# cr:       All lines end with "\r"
# crlf:     All lines end with "\r\n"
# platform: Lines end in platform-specific way, i.e.,
#   Leo opens output files in "w" mode rather than "wb" mode and writes '\n'
#
# Please specify nl when uploading files to Leo's CVS site.

trailing_body_newlines = one
# The number of trailing newlines Leo retains at the end of each body text.
#
# asis: Leo retains the number of newlines contained in each body text.
#       Note: Leo sometimes has problems determining which ending newlines are "real".
# zero: Leo removes all trailing whitespace from body text.
# one:  Leo ends each non-empty body text with exactly one trailing newline.

use_gnx = 1
# TO BE REMOVED
# 1:    tnode indices in .leo files have the form id.timestamp.n (n optional)
#       Strongly recommended when using cvs.
# 0:    tnode indices in .leo files are integers.
#       For compatibility with Leo 3.x file format.

write_old_format_derived_files = 0
# TO BE REMOVED
# 1: Write all derived files using pre-4.0 format.
# 0: Write all derived files using 4.0 format.
# Please write 4.0 derived files when uploading code to cvs.
# The use of pre-4.0 derived files is deprecated.

write_strips_blank_lines = 1
# 1:    Leo strips blanks and tabs from otherwise blank lines.
# 0:    Leo retains whitespace even in otherwise blank lines.</t>
<t tx="ekr.20041115191203.7">use_plugins = 0
# 1:    Leo enables plugins.
#       Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files.
#       See further warnings in LeoDocs.leo.
# 0:    Leo disables all plugins.</t>
<t tx="ekr.20041115191203.8">at_root_bodies_start_in_doc_mode = 1
# 1:    Body text in @root trees start in doc mode.
#       (This is the way @root trees always worked prior to version 3.10.)
# 0:    Body text in @root trees start in code mode.
#      (This way makes @root trees more compatible with @file trees.)</t>
<t tx="ekr.20041115191203.9">config_encoding = utf-8
# The encoding for leoConfig.txt:
# Default is utf-8
# iso-8859-1 would be a popular alternative.

default_derived_file_encoding = UTF-8
# The encoding used for derived files if no @encoding directive is in effect.
# This setting is also used to encode files created by the Tangle commands.
# Default is UTF-8 (case not important).

new_leo_file_encoding = UTF-8
# The encoding specified in the following line of new .leo files:
#   &lt;?xml version="1.0" encoding="UTF-8"&gt;
# Default is UTF-8 (upper case for compatibility for old versions of Leo).
# iso-8859-1 would be a popular alternative.
# Important:
#   Once a .leo file is created the &lt;?xml..."&gt; line can only be changed by hand.
#   Changing the &lt;?xml..."&gt; line by hand may cause unicode errors the next time the .leo file is loaded,
#   So you should change the &lt;?xml..."&gt; line by hand only when first creating a .leo file.

tk_encoding =
# The encoding that Tk text widgets are assumed for non-ascii character strings.
# You would typically use this setting only in an emergency.
# Leo assumes that Tk text widgets return:
# 1. The value specified by the tk_encoding parameter, if it exists.
# 2. locale.getdefaultlocale()[1] if it is exists.
# 3. sys.getdefaultencoding()</t>
<t tx="ekr.20041115191203.11">These correspond to the keyword parameters of the leoCompare constructor.
Exception: there are no keywords for compare file names in the constructor.</t>
<t tx="ekr.20041115191203.12">change_string = 
# The change string (without the quotes unless quotes are part of the string).
# N.B. Leo requires utf-8 encoding for any non-ascii characters.

find_string = 
# The find string (without the quotes unless quotes are part of the string).
# N.B. Leo requires utf-8 encoding for any non-ascii characters.

# 0/1 settings for checkboxes in the Find/Change panel....
batch = 0
ignore_case = 0
mark_changes = 0
mark_finds = 0
pattern_match = 0
reverse = 0
search_body = 1
search_headline = 0
suboutline_only = 0
whole_word = 1
wrap = 0
node_only = 0</t>
<t tx="ekr.20041115191203.13">@ Keyboard shortcuts for menu commands.

A shortcut specification has the form:
    
commandName = shortcutSpecifier

where commandName is the name of the command in the menu with all non-alphabetic characters removed.
    
If the shortcut specifier is None no shortcut is used. Otherwise, the shortcut specifier consists of a head followed by a tail.  The head may be empty, or may be a concatenation of the following: Shift+, Alt+, Control+ or Ctrl+.

Note: If you don't want a shortcut for a command that presently has a shortcut, make sure to set the shortcut to None rather than just deleting or commenting out the entry for that command.  If you don't set the shortcut to None any default setting will be in effect, and that may cause a conflict with your own settings.

Case is ignored in commandName, and in the head of the shortcutSpecifier. Case is significant in multi-character tails.  Also, - may be used instead of + in heads.  The following are all equivalent:
    
    Ctrl+A
    Ctrl-a
    Control+A

The following are not equivalent:
    
    Ctrl+-
    Ctrl-+

and the following are not equivalent:

    Ctrl+Tab (may be valid)
    Ctrl+tab (will never be valid)
    
See the section called "About keyboard shortcuts" for a full discussion of what may appear in the tail of a shortcut.
@c

# 
# Values are command names with all whitespace deleted.
# Case is ignored.

[keyboard shortcuts]

&lt;&lt; About keyboard shortcuts &gt;&gt;
&lt;&lt; Alt and Shift-Alt &gt;&gt;
&lt;&lt; Control &gt;&gt;
&lt;&lt; F-keys and others &gt;&gt;
&lt;&lt; Shift-Control &gt;&gt;
&lt;&lt; None &gt;&gt;
</t>
<t tx="ekr.20041115191203.14">The following special single characters may be used in the tails of shortcuts.  They are listed along with their associated Tk binding value.  Leo contains special code to handle these characters.  No other single characters may be specified.

For example, you could specify Ctrl+! as a shortcut, and Leo will create a binding for &lt;Control+exclam&gt;.  Some of these values may be invalid on some machines.

! exclam
" quotedbl
# numbersign
$ dollar
% percent
&amp; ampersand
' quoteright
( parenleft
) parenright
* asterisk
+ plus
, comma
- minus
. period
/ slash
: colon
; semicolon
&lt; less
= equal
&gt; greater
? question
@ at
[ bracketleft
\ backslash
] bracketright
^ asciicircum
_ underscore
` quoteleft
{ braceleft
| bar
} braceright
~ asciitilde

Leo recognizes the following mult-character names, and translates the indicated strings in the menu items:
    
"bksp"     : "BkSp"
"dnarrow"  : "DnArrow"
"ltarrow"  : "LtArrow"
"rtarrow"  : "RtArrow"
"uparrow"  : "UpArrow"
"pageup"   : "PgUp"),
"pagedn"   : "PgDn")

For example, "Ctrl-uparrow"  will appear as "Ctrl+UpArrow" in the menu.

Leo passes all other mult-character names verbatim to Tk, so on some platforms you may be able to use any of the following.  Most appear on the numeric keypad. For example, the following may work on some systems:
    
"Ctrl+BackSpace"

Don't use these if you want to be sure that the binding work on all platforms. The complete list of names may be found at: http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
    
F1, F2, F3, F4, F5, F6, F7, F8, F9, F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab, 
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator, KP_Space, KP_Subtract, KP_Tab,
KP_F1, KP_F2, KP_F3, KP_F4,
KP_0, KP_1, KP_2, KP_3, KP_4, KP_5, KP_6, KP_7, KP_8, KP_9</t>
<t tx="ekr.20041115191203.15">ExpandNextLevel   = Alt+=
ExpandNode        = Alt+]
ExpandPrevLevel   = Alt+.
ContractAll       = Alt+-
ContractNode      = Alt+[
ContractOrGoLeft  = Alt+LtArrow
ContractParent    = Alt+0
ExpandOrGoRight   = Alt+RtArrow
ExpandToLevel1    = Alt+1
ExpandToLevel2    = Alt+2
ExpandToLevel3    = Alt+3
ExpandToLevel4    = Alt+4
ExpandToLevel5    = Alt+5
ExpandToLevel6    = Alt+6
ExpandToLevel7    = Alt+7
ExpandToLevel8    = Alt+8
ExpandAll         = Alt+9

SortSiblings     = Alt-A
MarkChangedItems = Alt+C
GoToNextChanged  = Alt+D
# Reserved         Alt+E  (Opens Edit Menu)
# Reserved         Alt+F  (Opens File Menu)
GoToLineNumber   = Alt+G
# Reserved         Alt+H  (Opens Help Menu)
MarkClones       = Alt+K
GoToNextMarked   = Alt+M
GoToNextCloned   = Alt+N
# Reserved         Alt+O  (Opens Outline Menu)
OpenPythonWindow = Alt+P
MarkChangedRoots = Alt+R
MarkSubheads     = Alt+S
UnmarkAll        = Alt+U
ShowInvisibles   = Alt+V
# Reserved         Alt+W  (Opens Window Menu)

# EKR: I set the following in customizeLeo.py
CheckSpelling    = Alt+Shift+A
# Idle           = Alt+Shift+I
# Word           = Alt+Shift+W
# WordPad        = Alt+Shift+T
SetColors        = Alt+Shift+C
#                = Alt+Shift+E
SetFont          = Alt+Shift+F

GoToFirstNode    = Alt+Shift+G
GoToLastNode     = Alt+Shift+H
GoToParent       = Alt+Shift+P
GoToPrevSibling  = Alt+Shift+R
GoToNextSibling  = Alt+Shift+S

GoToNextVisible  = Alt+DnArrow
GoToPrevVisible  = Alt+UpArrow
GoToPrevNode     = Alt+Shift+UpArrow
GoToNextNode     = Alt+Shift+DnArrow</t>
<t tx="ekr.20041115191203.16">CloneNode        = Ctrl+`
Replace          = Ctrl+=
ReplaceThenFind  = Ctrl+-
Indent           = Ctrl+]
Unindent         = Ctrl+[
Promote          = Ctrl+{
Demote           = Ctrl+}

SelectAll        = Ctrl+A
# Unused         = Ctrl+B
Copy             = Ctrl+C
MoveDown         = Ctrl+D
ExecuteScript    = Ctrl+E
FindPanel        = Ctrl+F
# It is no longer possible to specify two shortcuts for the same command.
# Unused         = Ctrl+G
EditHeadline     = Ctrl+H
InsertNode       = Ctrl+I
# Unused         = Ctrl+J
MatchBrackets    = Ctrl+K
MoveLeft         = Ctrl+L
Mark             = Ctrl+M
New              = Ctrl+N
Open             = Ctrl+O
# Unused         = Ctrl+P
Exit             = Ctrl-Q
MoveRight        = Ctrl+R
Save             = Ctrl+S
ToggleActivePane = Ctrl+T
MoveUp           = Ctrl+U
Paste            = Ctrl+V
Close            = Ctrl+W
Cut              = Ctrl+X
Preferences      = Ctrl+Y
CantUndo         = Ctrl+Z</t>
<t tx="ekr.20041115191203.17">DeleteNode      = Shift+Ctrl+BkSp

TangleAll       = Shift+Ctrl+A
ConvertBlanks   = Shift+Ctrl+B
CopyNode        = Shift+Ctrl+C
Extract         = Shift+Ctrl+D
ExtractSection  = Shift+Ctrl+E
ImportTofile    = Shift+Ctrl+F
InsertBodyTimeDate     = Shift+Ctrl+G
InsertHeadlineTimeDate = Shift+Ctrl+H
# Unused        = Shift+Ctrl+I
ConvertTabs     = Shift+Ctrl+J
# Unused        = Shift+Ctrl+K
# Unused        = Shift+Ctrl+L
TangleMarked    = Shift+Ctrl+M
ExtractNames    = Shift+Ctrl+N
# Unused        = Shift+Ctrl+O
ReformatParagraph = Shift+Ctrl+P
WriteDirtyAtFileNodes = Shift+Ctrl+Q
ReadOutlineOnly = Shift+Ctrl+R
SaveAs          = Shift+Ctrl+S
Tangle          = Shift+Ctrl+T
Untangle        = Shift+Ctrl+U
PasteNode       = Shift+Ctrl+V
WritefileNodes  = Shift+Ctrl+W
CutNode         = Shift+Ctrl+X
CantRedo        = Shift+Ctrl+Z</t>
<t tx="ekr.20041115191203.18"># F4 seems to interfere with Alt-F4 processing on windows.  Sigh.

FindNext     = F3
FindPrevious = F2

AbortEditHeadline = Shift+Esc
EndEditHeadline = Esc
</t>
<t tx="ekr.20041115191203.19"># These entries explicitly overrides whatever default exists.

AboutLeo                = None
EqualSizedPanes         = None

@ These are all comments.  They don't override any defaults...

ApplySettings           = None
Cascade                 = None
ContractAllChildren     = None
ContractChildren        = None
DeHoist                 = None
ExpandAllChildren       = None
ExpandChildren          = None
ExpandToLevel1          = None
FlattenOutline          = None
GoBack                  = None
GoForward               = None
Hoist                   = None
ImportCWEBFiles         = None
ImportFlattenedOutline  = None
ImportNowebFiles        = None
ImportToroot            = None
MinimizeAll             = None
OnlineHomePage          = None
OpenLeoConfigLeo        = None
OpenLeoDocsLeo          = None
OpenOfflineTutorial     = None
OpenOnlineTutorial      = None
OpenCompareWindow       = None
OpenfileWith            = None
OutlineToCWEB           = None
OutlineToNoweb          = None
PasteRetainingClones    = None
ReadfileNodes           = None
ReferenceLeoDocsleo     = None
RemoveSentinels         = None
RevertToSaved           = None
SaveTo                  = None
SortChildren            = None
ToggleAngleBrackets     = None
ToggleSplitDirection    = None
UntangleAll             = None
UntangleMarked          = None
Weave                   = None
WriteOutlineOnly        = None</t>
<t tx="ekr.20041115191203.20"></t>
<t tx="ekr.20041115191203.22">@ Options that affect the appearance of windows.

Options that require pixel values can be any Python expression that yields an int.
Warning: the number of pixels per inch varies...
@c

[window options]

&lt;&lt; body pane options &gt;&gt;
&lt;&lt; outline pane options &gt;&gt;
&lt;&lt; log pane options &gt;&gt;
&lt;&lt; Options for new windows &gt;&gt;
&lt;&lt; Options for newly opened windows &gt;&gt;
&lt;&lt; Options for the bar that separates panes in the Leo window &gt;&gt;</t>
<t tx="ekr.20041115191203.23">body_pane_wraps = 1
# 0/1: Wrap body text if 1.

additional_body_text_border = 0
# Additional border in body text pane, in pixels (must be an integer).

body_text_foreground_color =
body_text_background_color =
# Foreground and background colors of body text.

body_cursor_foreground_color =
body_cursor_background_color =
# Foreground and background colors for the cursor in body text.

body_insertion_cursor_color =
# Color of insertion cursor

body_text_font_family = Courier New
# Font family for body text.
# Default is default font for Tk.Text widgets.
# Invalid font names are translated to a font in a system-dependent way.

body_text_font_size = None
# Size of body text. Must be an integer.
# Default is 12 for Linux, 9 for Windows.

body_text_font_slant = roman
# The Tk -slant setting: roman or italic.  Default is roman.

body_text_font_weight = normal
# The Tk -weight setting: normal or bold.  Default is normal.

body_time_format_string = %m/%d/%Y %H:%M:%S
# The format string used when creating the Time/Date string for the Insert Time/Date command.
# See the Python documentation for time.strftime for full details.
# Examples:
# 1/30/2003 8:31:55
#   %m/%d/%y %H:%M:%S
# Thu, 30 Jan 2003 16:57:12
#   %a, %d %b %Y %H:%M:%S

body_gmt_time = 0
# 1: use gmt time
# 0: use local time.

smart_auto_indent = 0
# 1: auto-indent aligns with open ({[ brackets
# 0: auto-indent increases indentation by one tab for Python only.</t>
<t tx="ekr.20041115191203.24">allow_clone_drags = 0
# 1: Allows control-dragging to create clones.
# 0: All drags move nodes.
# See also: look_for_control_drag_on_mouse_down
# Setting this setting to 0 allows Leo to be used on Aqua.

enable_drag_messages = 0
# 1: Tell whether drags will move nodes or clone nodes.
# 0: Don't issue such messages.

expanded_click_area = 1
# 1: Click near a node expands or contracts the node.
# 0: Only clicks in a node's plus/minus box expands or contracts the node.

headline_text_unselected_foreground_color = black
headline_text_unselected_background_color = white
# Foreground and background colors of unselected headline text.
# Both must be specified for either to take effect.

headline_text_selected_foreground_color = black
headline_text_selected_background_color = gray80
# Foreground and background colors of selected headline text that is not being edited.
# Both must be specified for either to take effect.

headline_text_editing_foreground_color = black
headline_text_editing_background_color = white
# Foreground and background colors of unselected headline text in a headline that is being edited.
# Both must be specified for either to take effect.

headline_text_editing_selection_foreground_color = white
headline_text_editing_selection_background_color = DarkBlue
# Foreground and background colors of selected text headline text in a headline that is being edited.
# Both must be specified for either to take effect.

headline_time_format_string = %m/%d
# The format string used when creating the Time/Date string for the Insert Time/Date command.
# See the Python documentation for time.strftime for full details.
# Examples:
# 1/30
#   %m/%d
# 1/30/03 8:31:02
#   %m/%d/%y %H:%M:%S
# Thu, 30 Jan 2003 16:57:12
# %a, %d %b %Y %H:%M:%S

headline_gmt_time = 0
# 1: use gmt time
# 0: use local time.

outline_pane_background_color =
# Background color of outline pane itself.

headline_text_font_family =
# Font family for headline text.
# Default is default font for Tk.Text widgets.
# Invalid font names are translated to a font in a system-dependent way.

headline_text_font_size = None
# Size of headline text. Must be an integer.
# Default is 12 for Linux, 9 for Windows.

headline_text_font_slant = roman
# The Tk -slant setting: roman or italic. Default is roman.

headline_text_font_weight = normal
# The Tk -weight setting: normal or bold.  Default is normal.

look_for_control_drag_on_mouse_down = 1
# This option control the interpretation of the control key when dragging nodes in the outline pane.
# 1: A drag is a control-drag if the control key is down at the start of the drag.
# 0: A drag is a control-drag if the control key is down at the end of the drag.

outline_pane_scrolls_horizontally = 0
# 0/1: 1: Use horizontal scrollbar in outline pane.</t>
<t tx="ekr.20041115191203.25">log_error_color = red
# Color for error messages written to the log window.
# Must be a valid Tk color name.

log_pane_wraps = 0
# 0/1: Wrap body text if 1.

log_text_foreground_color =
log_text_background_color =
# Foreground and background colors of log text.

log_text_font_family =
# Font family for text in the log pane.
# Default is default font for Tk.Text widgets.
# Invalid font names are translated to a font in a system-dependent way.

log_text_font_size = None
# Size of text in the log pane. Must be an integer.
# Default is 12 for Linux, 8 otherwise.

log_text_font_slant = roman
# The Tk -slant setting: roman or italic. Default is roman.

log_text_font_weight = normal
# The Tk -weight setting: normal or bold.  Default is normal.</t>
<t tx="ekr.20041115191203.26"># Leo now properly opens windows for existing files where they were last positioned.

initial_window_height = 600
# Height of window in pixels. (must be an integer).
    
initial_window_width = 800
# Width window in pixels. (must be an integer).

initial_window_left = 20
# Distance from left of screen of window, in pixels (must be an integer).

initial_window_top = 20
# Distance from top of screen of window, in pixels (must be an integer).</t>
<t tx="ekr.20041115191203.27">initial_splitter_orientation = v
# Defines the primary splitter orientation.
# The primary panes are the body pane and the secondary pane.
# The secondary pane contains the outline and log panes.

# valid values: h or horizontal or v or vertical.
# (Actually, anything but h or horizontal is considered vertical.)
# vertical: body pane below outline and log panes.
# horizontal: body pane to left of outline and log panes.

# Note: this is _not_ saved in .leo files, but the body/outline ratio _is_ saved.
# This will lead to confusing results when this file is read only:
# 1. Changes to orientation caused by Toggle Split Direction are not changed, but
# 2. Changes to body/outline ratio _are_ changed.

initial_vertical_ratio = 0.5
# The ratio of tree pane size to body pane size when splitting primary panes vertically.
# Applies only to new windows. Overridden by ratio in .leo files.
# Valid values: 0.0 to 1.0.

initial_horizontal_ratio = 0.3
# The ratio of tree pane size to body pane size when
# splitting primary panes horizontally.

# Applies only to new windows. Overridden by ratio in .leo files.
# Valid values: 0.0 to 1.0.

initial_horizontal_secondary_ratio = 0.5
# The ratio of outline pane size to log pane size when
# splitting the primary panes horizontally.

# Applies to all newly opened windows.
# Valid values: 0.0 to 1.0.

initial_vertical_secondary_ratio = 0.7
# The ratio of tree pane size to body pane size when
# splitting the primary panes vertically.

# Applies to all newly opened windows.
# Valid values: 0.0 to 1.0.</t>
<t tx="ekr.20041115191203.28"></t>
<t tx="ekr.20041115192810">compare_file_1 =
# Path to the first file or directory to be compared.
# Directory compares ignore a filename part of the path, if present.
# E.g., c:/directory1/spam.py is valid for directory compares.

compare_file_2 =
# Path to the second file or directory to be compared.
# Directory compares ignore a filename part of the path, if present.
# E.g., c:/directory2/spam.py is valid for directory compares

output_file =
# Path to the output file.
# Leo will silently write to this file, regardless of whether it already exists.
# Leo will write to the log pane if this path is empty or invalid.

append_output_to_output_file = 0
# 0: Replace output file with results of compare.
# 1: Append output to output file.

</t>
<t tx="ekr.20041115192810.1">These options has no effect when comparing files.

limit_directory_search_extension = .py
# Limit directory searches to files with the given file extension.
# Examples:
#  None Compare all files when comparing directories.
#  .py   Compare .py files when comparing directories.</t>
<t tx="ekr.20041115192810.2"># These options have no effect when comparing directories.

ignore_blank_lines = 1
# 1: Ignore blanks lines when comparing files.

ignore_first_line_of_file_1 = 0
# 1: Ignore the first line of compare_file_1 when comparing files.

ignore_first_line_of_file_2 = 0
# 1: Ignore the first line of compare_file_2 when comparing files.

ignore_interior_whitespace = 0
# 1: Ignore whitespace after the leading whitespace of a line when comparing files.

ignore_leading_whitespace = 0
# 1: Ignore leading whitespace of each line when comparing files.
# Not recommended when comparing .py files.

ignore_sentinel_lines = 0
# 1: Ignore sentinel lines when comparing files.
# Leo sets sentinel comment delimiters from the first line of each file.
# This option has no effect if the first line is not a @+leo line.

# The following options affecting how Leo shows the results of file compares...
# Leo gathers statistics regardless of these options.

limit_count = 9
# 0: Show lines regardless of the number of mismatches.
# n: Stop showing lines after n mismatches.

make_whitespace_visible = 0
# 1: Show blanks as [ ] and tabs as [t]

print_both_lines_for_matches = 0
# 0: Print only the line of compare_file_1 when showing matching lines.
# 1: Print lines of both files when showing matching lines.

print_matching_lines = 0
# 1: Print lines that match using the print_both_lines_for_matches option.

print_mismatching_lines = 1
# 1: Print lines that do not compare equal to each other.

print_trailing_lines = 1
# 1: Print lines all lines in one file after an end-of-file is seen on the other file.</t>
<t tx="ekr.20041115192810.3">directory: None

DEPRECATED

The default directory used if no directory specified in @path, @root or @file directives.

</t>
<t tx="ekr.20041115192810.4">language: Python

The default language if no @language or @comment is in effect.

</t>
<t tx="ekr.20041115192810.5">int: -4

The width of tabs on the screen.

This setting is also used when writing doc parts.

Valid values: Any nonzero integer.

Negative tab widths (recommended) cause Leo to convert tabs to blanks when typing.</t>
<t tx="ekr.20041115192810.6">int: 80

The page width for wrapping doc parts in derived files.
Valid values: any nonzero positive integer.</t>
<t tx="ekr.20041115192810.7">bool: True

True: Explicit Tangle commands output doc parts.</t>
<t tx="ekr.20041115192810.8">bool: True

True: Explicit Tangle commands output file header.</t>
<t tx="ekr.20041115192810.9">bool: False

True: Run tangle_done.py after explicit Tangle commands.</t>
<t tx="ekr.20041115192810.10">bool: False

True: Run tangle_done.py after explicit Untangle commands.</t>
<t tx="ekr.20041115192810.11">color: LightSteelBlue2

The color of the split bar. gray90 also looks good.</t>
<t tx="ekr.20041115192810.12">string[raised, sunken, flat, ridge, solid, groove]: groove

The Tk -relief option for the split bar.</t>
<t tx="ekr.20041115192810.13">int: 6

The width of the split bar, in pixels (must be an integer).</t>
<t tx="ekr.20041116091233">@nocolor</t>
<t tx="ekr.20041116091233.2">Yesterday I realized that the fundamental design principle underlying the new configuration manager is this:

** Settings must be infinitely flexible **

There is no way that I can predict what people and plugins are going to want to do.  Rather than trying to "figure it all out" Leo must let people and plugins do whatever they want.  This turns out to be the easiest way.  You could say it is the only way.

There are several direct corollaries of this principle:

- Only outlines can structure settings.  Tabbed notebooks are not general enough.

- We must be able to add any kind of new setting without changing the format of .leo files.  The xml structure of .leo files must not depend on settings.  In particular, the &lt;preferences&gt; element must become vestigial.

- Leo can not use flat configuration files.  There is no way flat configuration files can do what is required.  Say bye bye to ConfigParser and all it's spawn.

I understand some people like flat config files.  Plugins can still use them.  However, using flat config files is simply not feasible if Leo is to have an extensible structure.

- Leo's configuration manager must be entirely rewritten and substantial changes to Leo's core may be coming.  This can't be helped; much of the structure of leoConfig.txt is hard-wired into leoConfig.py.

- The new configuration manager must allow plugins to create and reorganize settings.  As we shall see in a later posting, this will be surprisingly easy to do.

- Leo must use Leo outlines in a new way to organize settings.

It would be extremely foolish not to take advantage of Leo's organizational capabilities.  However, using leoConfig.leo to create leoConfig.txt created endless problems.  Something _much_ better is needed.  As we shall see in the next posting, there is, in fact, a much better way.

Edward</t>
<t tx="ekr.20041116091233.10">The shape of the 4.3 design

Given the fundamental design principle for the new configuration manager, viz., settings must be infinitely flexible, the shape of a powerful and flexible design starts to emerge from the shadows:

- Leo will support at least the local, user and per-Leo-file settings.

Plugins may create other kinds of settings.  The new configuration manager will support this.

- Settings must be contained _in Leo outlines_.

It would be extremely wasteful and foolish not to use Leo's superb data organizing features.  Flat configuration files can not begin to do what must be done.  I shall have no further use for ConfigParser.  Plugins can, of course, use ConfigParser if they like.

Global and user settings will be contained in files called leoSettings.leo.  The big difference between leoSettings.leo and leoConfig.leo is that the leoSettings.leo files never get tangled.  Instead, Leo will _parse_ these files on startup to create settings.  As we shall see, this parsing is trivial to do.

Per-file settings will be contained _in the outline to which the settings apply_.  These settings will be contained in an @settings tree.

N.B. This @settings tree is just part of the outline. In particular:

a) all nodes of this tree will be easily accessible to scripts and plugins.  For example, c.settingsRoot() will return the root of this tree.

b) no part of Leo's xml file format needs to change in order to create additional settings.

- The @settings tree will normally be hidden.

The Show @settings command will hide the "regular" outline and show only the @settings outline.  This command will work pretty much like the hoist command.  The corresponding Hide @settings command will work like the De-Hoist command.  leoSettings.leo files will contain nothing but the @settings tree, so this tree will be visible by default.

- Users will usually view and change settings using a _settings dialog_.

The supremely valuable Configurator.py script is the inspiration for this idea.

The Edit Global Prefs, Edit User Prefs, and Edit Local Prefs commands will bring up these dialogs.  These settings dialog will (and must) be organized as in jEdit.  There will be an extensible outline to organize settings and a separate page area to examine and change settings.   Selecting an item in the outline will select a page.

BTW, Leo will change settings files _only_ as the result of such commands.  In particular, Leo will no longer change settings when saving a .leo file. 

- User _will_ be able to view and change the @settings tree.

So there are two views of the @settings tree.  The normal view is the gui view.  The "expert" view is the @settings outline itself.  The expert view allows users to create new settings, to reorganize settings, and to do other things that can't be done in the gui view.

The outline part of the settings dialog will be a Tix or Pmw megawidget.  There will be no need to use the leoTkinterTree class.  However, the @settings tree _is_ part of a regular Leo outline, so the @settings tree itself can use clones.  The megawidget outline won't allow changes, but that does not make the scheme any less flexible; changes can be made in the @settings "view".  Do you see how clever this is?

- Leo will create settings dialogs _using information contained in the @settings trees_. 

Again, this idea comes from the Configurator.py script.  Parsing @settings trees is trivial because the parser has full access to @settings tree, just as any script does.  Furthermore, the structure of settings is mirrored in the structure of this tree, so discovering hierarchical relationships in the settings is also trivial.

I'll discuss the actual format of @settings tree in a later posting.  Suffice it to say here that

a) The format is simple, yet powerful and flexible;
b) plugins could easily extend this format.

- The Open Global Settings and Open User Settings commands will open the appropriate leoSettings.leo files and automatically show the @settings trees. (There is nothing else to show).

- Leo will update settings only in response to saving leoSettings.leo files or .leo files containing @settings trees.  There will be no _derived_ settings files to update.  This will eliminate all the confusion arising from leoConfig.txt getting out of synch with leoConfig.leo.

Conclusion

I am pleased with this design.  It is simple, powerful, flexible.  

Just as one example of what can be done, this design makes translating Leo into foreign languages about as easy as can be imagined.  I haven't discussed all the details of this, but clearly translating @settings dialog entries can be done without fuss.  The "infinitely extensible" principle guarantees that plugins can create whatever translation data is needed in an @setting tree somewhere.  Because this tree is an regular part of the Leo outline, a plugin could create this tree from other data.

Acknowledgments

Besides the Configurator.py script, another crucial influence on my thinking was the plugin_manager plugin.  This showed that it is indeed possible to have a "dual" view of data, both as text (or outline) and as a dialog.  RodrigoB's suggestion concerning @config-file nodes is the direct precursor of @settings trees.  However, I probably would not have been able to understand Rodrigo's suggestion without Configurator.py script and plugin_manager.py.  Also, Tom Fetherston's long postings convinced me that configuration must be infinitely extensible.  This was another key aha.  So thanks to you all; this would not have happened without you.

Edward</t>
<t tx="ekr.20041116091233.11">Some nodes in the @setting tree will organize the settings.  All other nodes nodes will represent individual settings in a very simple way as follows:

- The headline contains the name of the setting, optionally followed by its translation for other languages.

- The body text contains the expected type of the settings, its present value, and comments.  Leo will use these fields to create an area in the gui dialog in which the user can examine and change the setting.

The first line of the body text contains type:value.  The type determines the type of the option and thus the kind of widget used to show the setting in the dialog.  Typical types will be bool, int, string, color, font, directory etc.

All other lines of the body text contains comments that will appear in the dialog.

Leo can easily use this information to create dialog entries.  Bool settings create radio buttons, string entries, create Text boxes, color entries create color pickers, etc.

There will be other details forthcoming, but this is enough to show that a simple scheme can be extremely powerful in an outline context.

Edward</t>
<t tx="ekr.20041116125049">- @page creates a single dialog page.

- Use @int:name=val in headline.

The advantage is that the body text will contain only comment text.
The disadvantage is that parsing the headline is a little harder.

Similarly for @string, @color, etc.

- Allow @trans translation in child nodes

- Non-@ headlines just create nodes in outline mega-widget.</t>
<t tx="ekr.20041116164151">@nocolor

- Rewrite config module
    - Use list of dicts
        - default settings at end of list.
        - getters/setters
        - algorithm to search list.
        - algorithm to search leoSettings.leo
    - Settings names must be unique?
        - If so, there is only one setter.
            - Create abbreviations for old setters.
        - Dicts will have type info: api.getters check that the type matches.
        
   

- Support @setting tree.

    - Hide @setting node when drawing
    - Add Show/Hide Local Settings command.

- Draw gui using @settings tree.</t>
<t tx="ekr.20041117062700">@language python
@tabwidth -4

import leoGlobals as g
import exceptions
import os
import string
import sys

class baseConfig:
    """The base class for Leo's configuration handler."""
    &lt;&lt; define defaultsDict &gt;&gt;
    &lt;&lt; define ivarsDict &gt;&gt;
    @others
    
class config (baseConfig):
    """A class to manage configuration settings."""
    pass</t>
<t tx="ekr.20041117062700.1">@nocolor

- Use g.app.globalDir, g.app.homeDir to load leoSettings.leo

- How to handle recent files?
    - Save in @settings tree

- Support new types:

@color

("directory","!")
("language","Python"),
("newline-type","nl"), # asis,nl,lf,platform, etc.
("ratio",0.5), # 0.0 to 1.0
("undo_granularity" : ("undo_granularity","word"), # "char","word","line","node"
("unicode-encoding","UTF-8"),

("tk-color","LightSteelBlue2"),
("tk-font-family","Courier"),
("tk-font-size",defaultBodyFontSize),
("tk-font-slant","roman"),
("tk-font-weight","normal"),
("tk-pixel",600),
# tk-orientation = "string[vertical,horizontal]"
("tk-orientation","vertical"),
("tk-relief","groove"),

@nocolor</t>
<t tx="ekr.20041117062700.2"></t>
<t tx="ekr.20041117062700.3">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

# Defaults for ivars are specified in the ctor, _not_ here.

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : 1,
    "limit_count" : 9,
    "print_mismatching_lines" : 1,
    "print_trailing_lines" : 1,
    # find/change options...
    "search_body" : 1,
    "whole_word" : 1,
    # Prefs panel.
    "default_target_language" : "Python",
    "tab_width" : -4,
    "page_width" : 132,
    "output_doc_chunks" : 1,
    "tangle_outputs_header" : 1,
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : 1,
    "underline_undefined_section_names" : 1,
    # Window options...
    "allow_clone_drags" : 1,
    "body_pane_wraps" : 1,
    "body_text_font_family" : "Courier",
    "body_text_font_size" : defaultBodyFontSize,
    "body_text_font_slant" : "roman",
    "body_text_font_weight" : "normal",
    "enable_drag_messages" : 1,
    "headline_text_font_size" : defaultTreeFontSize,
    "headline_text_font_slant" : "roman",
    "headline_text_font_weight" : "normal",
    "log_text_font_size" : defaultLogFontSize,
    "log_text_font_slant" : "roman",
    "log_text_font_weight" : "normal",
    "initial_window_height" : 600, # 7/24/03: In pixels.
    "initial_window_width" :  800, # 7/24/03: In pixels.
    "initial_window_left" : 10,
    "initial_window_top" : 10,
    "initial_splitter_orientation" : "vertical",
    "initial_vertical_ratio" : 0.5,
    "initial_horizontal_ratio" : 0.3,
    "initial_horizontal_secondary_ratio" : 0.5,
    "initial_vertical_secondary_ratio" : 0.7,
    "outline_pane_scrolls_horizontally" : 0,
    "split_bar_color" : "LightSteelBlue2",
    "split_bar_relief" : "groove",
    "split_bar_width" : 7 }</t>
<t tx="ekr.20041117062700.4">def __init__ (self):

    self.init()

def init (self):

    try:
        self.configDir = sys.leo_config_directory
    except:
        self.configDir = g.os_path_join(g.app.loadDir,"..","config")

    self.configFileName = g.os_path_join(self.configDir,"leoConfig.txt")

    self.configsExist = False # True when we successfully open leoConfig.txt.
    
    # These are now set in gui.getDefaultConfigFont
    self.defaultFont = None
    self.defaultFontFamily = None
    
    &lt;&lt; initialize constant ivars, lists &amp; dicts &gt;&gt;
    &lt;&lt; initialize ivars that may be set by config options &gt;&gt;

    self.open() # read and process the configuration file.</t>
<t tx="ekr.20041117062700.5"># Names of sections.
self.configSection = "config options"
self.compareSection = "compare options"
self.findSection = "find/change options"
self.keysSection = "keyboard shortcuts"
self.prefsSection = "prefs panel options"
self.recentFilesSection = "recent files"
self.colorsSection = "syntax coloring options"
self.windowSection = "window options"

# List of recent files.
self.recentFiles = []

# Section dictionaries
self.compareDict = {}
self.configDict = {} # 10/11/02: we use a dict even for ivars.
self.findDict = {}
self.keysDict = {} ; self.rawKeysDict = {} # 2/8/04
self.prefsDict = {}
self.colorsDict = {}
self.windowDict = {}

# Associations of sections and dictionaries.
self.sectionInfo = (
    (self.configSection,self.configDict),
    (self.compareSection,self.compareDict),
    (self.findSection,self.findDict),
    (self.keysSection,self.keysDict),
    (self.prefsSection,self.prefsDict),
    (self.recentFilesSection,None),
    (self.colorsSection,self.colorsDict),
    (self.windowSection,self.windowDict) )</t>
<t tx="ekr.20041117062700.6"># Defaults for these ivaars are specified here, _not_ in defaultsDict.

self.at_root_bodies_start_in_doc_mode = True # For compatibility with previous versions.
self.config = None # The current instance of ConfigParser
self.config_encoding = "utf-8" # Encoding used for leoConfig.txt.
self.create_nonexistent_directories = False
self.default_derived_file_encoding = "utf-8"
self.new_leo_file_encoding = "UTF-8" # Upper case for compatibility with previous versions.
self.output_initial_comment = "" # "" or None for compatibility with previous versions.
self.output_newline = "nl"
self.read_only = True # Make sure we don't alter an illegal leoConfig.txt file!
self.redirect_execute_script_output_to_log_pane = False
self.relative_path_base_directory = "!"
self.remove_sentinels_extension = ".txt"
self.save_clears_undo_buffer = False
self.stylesheet = None
self.tkEncoding = None # Defaults to None so it doesn't override better defaults.
self.trailing_body_newlines = "asis"
self.use_plugins = False # Should never be True here!
self.use_psyco = False
self.undo_granularity = "word" # "char","word","line","node"
self.write_strips_blank_lines = False</t>
<t tx="ekr.20041117062700.7"></t>
<t tx="ekr.20041117062700.8">def getBoolFromDict (self,name,dict):
    val = self.getIntFromDict(name,dict)
    if val != None:
        if val: val = 1
        else: val = 0
    return val

def getFloatFromDict (self,name,dict):
    val = self.getFromDict(name,dict)
    if val:
        try: val = float(val)
        except: val = None
    return val

def getFromDict (self,name,dict):
    val = dict.get(name)
    if val == "ignore":
        val = None
    elif val == None:
        val = self.defaultsDict.get(name)
        val = g.toUnicode(val,self.config_encoding) # 10/31/03
    return val

def getIntFromDict (self,name,dict):
    val = self.getFromDict(name,dict)
    try:
        return int(val)
    except:
        return 0

def setDict (self,name,val,dict):
    dict [name] = val
        
getStringFromDict = getFromDict</t>
<t tx="ekr.20041117062700.9">def getBoolColorsPref (self,name):
    return self.getBoolFromDict(name,self.colorsDict)
    
# Basic getters and setters.

def getColorsPref (self,name):
    return self.getFromDict(name,self.colorsDict)

def setColorsPref (self,name,val):
    self.setDict(name,val,self.colorsDict)
    
getStringColorsPref = getColorsPref</t>
<t tx="ekr.20041117062700.10">def getBoolComparePref (self,name):
    return self.getBoolFromDict(name,self.compareDict)
    
def getIntComparePref (self,name):
    return self.getIntFromDict(name,self.compareDict)

# Basic getters and setters.

def getComparePref (self,name):
    return self.getFromDict(name,self.compareDict)

def setComparePref (self,name,val):
    self.setDict(name,val,self.compareDict)
    
getStringComparePref = getComparePref</t>
<t tx="ekr.20041117062700.11">def getBoolFindPref (self,name):
    return self.getBoolFromDict(name,self.findDict)

# Basic getters and setters.

def getFindPref (self,name):
    return self.getFromDict(name,self.findDict)

def setFindPref (self,name,val):
    self.setDict(name,val,self.findDict)
    
getStringFindPref = getFindPref</t>
<t tx="ekr.20041117062700.12">def getBoolPref (self,name):
    return self.getBoolFromDict(name,self.prefsDict)

def getIntPref (self,name):
    return self.getIntFromDict(name,self.prefsDict)
    
# Basic getters and setters.

def getPref (self,name):
    return self.getFromDict(name,self.prefsDict)

def setPref (self,name,val):
    self.setDict(name,val,self.prefsDict)
    
getStringPref = getPref</t>
<t tx="ekr.20041117062700.13">def getRecentFiles (self):
    
    return self.recentFiles

def setRecentFiles (self,files):

    self.recentFiles = files
</t>
<t tx="ekr.20041117062700.14">def getBoolWindowPref (self,name):
    return self.getBoolFromDict(name,self.windowDict)
    
def getFloatWindowPref (self,name):
    return self.getFloatFromDict(name,self.windowDict)
    
def getIntWindowPref (self,name):
    return self.getIntFromDict(name,self.windowDict)
    
# Basic getters and setters.

def getWindowPref (self,name):
    return self.getFromDict(name,self.windowDict)

def setWindowPref (self,name,val):
    self.setDict(name,val,self.windowDict)
    
getStringWindowPref = getWindowPref</t>
<t tx="ekr.20041117062700.15">def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag=""):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.getWindowPref(family)
    if family in (None,""):
        # print tag,"using default"
        family = self.defaultFontFamily
        
    size = self.getIntWindowPref(size)
    if size in (None,0): size = defaultSize
    
    slant = self.getWindowPref(slant)
    if slant in (None,""): slant = "roman"
    
    weight = self.getWindowPref(weight)
    if weight in (None,""): weight = "normal"
    
    # if g.app.trace: g.trace(tag,family,size,slant,weight)
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)</t>
<t tx="ekr.20041117062700.16">def getShortcut (self,name):
    
    if 1: # 2/8/04: allow &amp; in keys.
        val = self.rawKeysDict.get(name.replace('&amp;',''))
        if val:
            rawKey,shortcut = val
            return rawKey,shortcut
        else:
            return None,None
    else:
        val = self.keysDict.get(name)
        
        # 7/19/03: Return "None" if the setting is "None"
        # This allows settings to disable a default shortcut.
        return val</t>
<t tx="ekr.20041117062700.17">def initConfigParam (self,name,defaultVal):
    try:
        val = self.config.get(self.configSection,name,raw=1) # 2/4/03
    except:
        val = defaultVal
    return val

def initBooleanConfigParam (self,name,defaultVal):
    try:
        val = self.config.getboolean(self.configSection,name)
    except:
        val = defaultVal
    return val
</t>
<t tx="ekr.20041117062700.18"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsFindIvars (self,c):
    
    if g.app.gui.guiName() != "tkinter":
        return

    config = self ; findFrame = g.app.findFrame

    # N.B.: separate c.ivars are much more convenient than a dict.
    for s in findFrame.intKeys:
        val = config.getBoolFindPref(s)
        if val != None: # 10/2/03
            setattr(c,s+"_flag",val)
            # g.trace(s+"_flag",val)
            
    val = config.getStringFindPref("change_string")
    if val: c.change_text = val
    
    val = config.getStringFindPref("find_string")
    if val: c.find_text = val

    g.app.findFrame.init(c)</t>
<t tx="ekr.20041117062700.19"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

    config = self
    &lt;&lt; set prefs ivars &gt;&gt;</t>
<t tx="ekr.20041117062700.20">val = config.getIntPref("tab_width")
if val: c.tab_width = val

val = config.getIntPref("page_width")
if val: c.page_width = val

val = config.getIntPref("run_tangle_done.py")
if val: c.tangle_batch_flag = val

val = config.getIntPref("run_untangle_done.py")
if val: c.untangle_batch_flag = val

val = config.getIntPref("output_doc_chunks")
if val: c.output_doc_flag = val

val = config.getIntPref("tangle_outputs_header")
if val: c.use_header_flag = val

val = config.getPref("default_tangle_directory")
if val: c.tangle_directory = val

c.target_language = "python" # default
val = config.getPref("default_target_language")
if val:
    try:
        val = string.lower(val)
        val = string.replace(val,"/","")
        if g.app.language_delims_dict.get(val):
            c.target_language = val
        
    except: pass</t>
<t tx="ekr.20041117062700.21">def setConfigFindIvars (self,c):
    
    """Set the config ivars from the commander."""
    
    findFrame = g.app.findFrame

    # N.B.: separate c.ivars are much more convenient than a dict.
    for s in findFrame.intKeys: # These _are_ gui-independent.
        val = getattr(c,s+"_flag")
        self.setFindPref(s,val)
        # g.trace(s,val)
    
    self.setFindPref("change_string",c.change_text)
    self.setFindPref("find_string",c.find_text)</t>
<t tx="ekr.20041117062700.22"># Sets config ivars from c.

def setConfigIvars (self,c):
    
    if c.target_language and g.app.language_delims_dict.get(c.target_language):
        language = c.target_language
    else:
        language = "plain"
    self.setPref("default_tangle_directory",c.tangle_directory)
    self.setPref("default_target_language",language)
    self.setPref("output_doc_chunks",str(c.output_doc_flag))
    self.setPref("page_width",str(c.page_width))
    self.setPref("run_tangle_done.py",str(c.tangle_batch_flag))
    self.setPref("run_untangle_done.py",str(c.untangle_batch_flag))
    self.setPref("tab_width",str(c.tab_width))
    self.setPref("tangle_outputs_header",str(c.use_header_flag))
    
    self.setFindPref("batch",str(c.batch_flag))
    self.setFindPref("ignore_case",str(c.ignore_case_flag))
    self.setFindPref("mark_changes",str(c.mark_changes_flag))
    self.setFindPref("mark_finds",str(c.mark_finds_flag))
    self.setFindPref("pattern_match",str(c.pattern_match_flag))
    self.setFindPref("reverse",str(c.reverse_flag))
    self.setFindPref("script_change",str(c.script_change_flag))
    self.setFindPref("script_search",str(c.script_search_flag))
    self.setFindPref("search_body",str(c.search_body_flag))
    self.setFindPref("search_headline",str(c.search_headline_flag))
    self.setFindPref("selection_only",str(c.selection_only_flag)) # 11/9/03
    self.setFindPref("suboutline_only",str(c.suboutline_only_flag))
    self.setFindPref("wrap",str(c.wrap_flag))
    self.setFindPref("whole_word",str(c.whole_word_flag))
    
    self.setFindPref("change_string",c.change_text)
    self.setFindPref("find_string",c.find_text)</t>
<t tx="ekr.20041117062700.23">def open (self):
    
    config = ConfigParser.ConfigParser()
    self.config = config
    try:
        cf = open(self.configFileName)
        config.readfp(cf)
        &lt;&lt; get config options &gt;&gt;
        &lt;&lt; get recent files &gt;&gt;
        for section, dict in self.sectionInfo:
            if dict != None:
                try:
                    for opt in config.options(section):
                        val = config.get(section,opt,raw=1)
                        val = g.toUnicode(val,self.config_encoding) # 10/31/03
                        dict[string.lower(opt)]= val
                except: pass
        &lt;&lt; create rawKeysDict without ampersands &gt;&gt;
        &lt;&lt; convert find/change options to unicode &gt;&gt;
        &lt;&lt; print options &gt;&gt;
        cf.close()
        self.configsExist = True
    except IOError:
        pass
    except:
        g.es("Exception opening " + self.configFileName)
        g.es_exception()
        pass
    self.config = None
</t>
<t tx="ekr.20041117062700.24">@ Rewritten 10/11/02 as follows:

1. We call initConfigParam and initBooleanConfigParam to get the values.

The general purpose code will enter all these values into configDict.  This allows update() to write the configuration section without special case code.  configDict is not accessible by the user.  Rather, for greater speed the user access these values via the ivars of this class.

2. We pass the ivars themselves as params so that default initialization is done in the ctor, as would normally be expected.
@c

self.at_root_bodies_start_in_doc_mode = self.initBooleanConfigParam(
    "at_root_bodies_start_in_doc_mode",self.at_root_bodies_start_in_doc_mode)
    
encoding = self.initConfigParam(
    "config_encoding",self.config_encoding)
    
if g.isValidEncoding(encoding):
    self.config_encoding = encoding
else:
    g.es("bad config_encoding: " + encoding)
    
self.create_nonexistent_directories = self.initBooleanConfigParam(
    "create_nonexistent_directories",self.create_nonexistent_directories)
    
encoding = self.initConfigParam(
    "default_derived_file_encoding",self.default_derived_file_encoding)

if g.isValidEncoding(encoding):
    self.default_derived_file_encoding = encoding
else:
    g.es("bad default_derived_file_encoding: " + encoding)
    
encoding = self.initConfigParam(
    "new_leo_file_encoding",
    self.new_leo_file_encoding)

if g.isValidEncoding(encoding):
    self.new_leo_file_encoding = encoding
else:
    g.es("bad new_leo_file_encoding: " + encoding)

self.output_initial_comment = self.initConfigParam(
    "output_initial_comment",self.output_initial_comment)

self.output_newline = self.initConfigParam(
    "output_newline",self.output_newline)

self.read_only = self.initBooleanConfigParam(
    "read_only",self.read_only)

self.relative_path_base_directory = self.initConfigParam(
    "relative_path_base_directory",self.relative_path_base_directory)
    
self.redirect_execute_script_output_to_log_pane = self.initBooleanConfigParam(
    "redirect_execute_script_output_to_log_pane",
    self.redirect_execute_script_output_to_log_pane)
    
self.remove_sentinels_extension = self.initConfigParam(
    "remove_sentinels_extension",self.remove_sentinels_extension)

self.save_clears_undo_buffer = self.initBooleanConfigParam(
    "save_clears_undo_buffer",self.save_clears_undo_buffer)
    
self.stylesheet = self.initConfigParam(
    "stylesheet",self.stylesheet)
    
encoding = self.initConfigParam(
    "tk_encoding",self.tkEncoding)
    
if encoding and len(encoding) &gt; 0: # May be None.
    if g.isValidEncoding(encoding):
        self.tkEncoding = encoding
    else:
        g.es("bad tk_encoding: " + encoding)
        
# New in 4.2
self.trailing_body_newlines = self.initConfigParam(
    "trailing_body_newlines",self.trailing_body_newlines)
    
self.use_plugins = self.initBooleanConfigParam(
    "use_plugins",self.use_plugins)

self.use_psyco = self.initBooleanConfigParam(
    "use_psyco",self.use_psyco)
    
self.undo_granularity = self.initConfigParam(
    "undo_granularity",self.undo_granularity)

# New in 4.2
self.write_strips_blank_lines = self.initBooleanConfigParam(
    "write_strips_blank_lines",self.write_strips_blank_lines)
    
#g.trace("write_strips_blank_lines",self.write_strips_blank_lines)
#g.trace("trailing_body_newlines",self.trailing_body_newlines)</t>
<t tx="ekr.20041117062700.25">section = self.recentFilesSection

if 0: # elegant, but may be a security hole.
    self.recentFiles = eval(config.get(section,"recentFiles",raw=1)) # 2/4/03
else: # easier to read in the config file.
    try:
        for i in xrange(10):
            f = config.get(section,"file" + str(i),raw=1)
            f = g.toUnicode(f,"utf-8") # 10/31/03
            self.recentFiles.append(f)
    except: pass</t>
<t tx="ekr.20041117062700.26"># 2/8/04: New code.
for key in self.keysDict.keys():
    newKey = key.replace('&amp;','')
    self.rawKeysDict[newKey] = key,self.keysDict[key]
    
if 0: #trace
    keys = self.rawKeysDict.keys()
    keys.sort()
    for key in keys:
        print self.rawKeysDict[key]</t>
<t tx="ekr.20041117062700.27">find = self.findDict.get("find_string")
if find:
    # Leo always writes utf-8 encoding, but users may not.
    find = g.toUnicode(find,"utf-8")
    self.findDict["find_string"] = find

change = self.findDict.get("change_string")
if change:
    # Leo always writes utf-8 encoding, but users may not.
    change = g.toUnicode(change,"utf-8")
    self.findDict["change_string"] = change
</t>
<t tx="ekr.20041117062700.28">if 0:
    print "\n\ncolorsDict:\n" ,self.colorsDict
    print "\n\ncompareDict:\n",self.compareDict
    print "\n\nfindDict:\n"   ,self.findDict
    print "\n\nprefsDict:\n"  ,self.prefsDict
    print "\n\nwindowDict:\n" ,self.windowDict
if 0:
    print "\n\nkeysDict:\n\n"
    for i in self.keysDict.items():
        print i
if 0:
    print "\n\nwindowDict:\n\n"
    for i in self.windowDict.keys():
        print i</t>
<t tx="ekr.20041117062700.29"># Before 4.3: called when writing .leo file.  This had various unpleasant consequences.
# After  4.3: called immediately when a setting changes, and never when writing .leo files.

def update (self,verbose=False):
    
    g.trace()
    """Write the entire config file from ivars."""
    # Do nothing if the file does not exist, or if read_only.
    if self.read_only:
        if verbose:
            g.es("Read only config file",color="blue")
        return
    if not g.os_path_exists(self.configFileName):
        if verbose:
            g.es("No config file",color="blue")
        return
    
    config = ConfigParser.ConfigParser()
    self.config = config
    try:
        # 9/1/02: apparently Linux requires w+ and XP requires w.
        mode = g.choose(sys.platform=="win32","wb","wb+")
        cf = open(self.configFileName,mode)
        config.readfp(cf)
        &lt;&lt; write recent files section &gt;&gt;
        for section,dict in self.sectionInfo:
            if dict:
                self.update_section(config,section,dict)
        config.write(cf)
        cf.flush()
        cf.close()
    except:
        g.es("exception writing: " + self.configFileName)
        g.es_exception()
    self.config = None</t>
<t tx="ekr.20041117062700.30">section = self.recentFilesSection
files = self.recentFiles

section = g.toEncodedString(section,"utf-8") # 10/31/03

if config.has_section(section):
    config.remove_section(section)
config.add_section(section)

if 0: # elegant, but may be a security hole.
    config.set(section,"recentFiles",files)
else: # easier to read in the config file.
    for i in xrange(len(files)):
        f = g.toEncodedString(files[i],self.config_encoding) # 10/31/03
        config.set(section, "file"+str(i), f)</t>
<t tx="ekr.20041117062700.31">def update_section (self,config,section,dict):
    
    section = g.toEncodedString(section,self.config_encoding) # 10/31/03

    if config.has_section(section):
        config.remove_section(section)
    config.add_section(section)
    
    keys = dict.keys()
    keys.sort() # Not effective.
    for name in keys:
        val = dict [name]
        val  = g.toEncodedString(val,self.config_encoding)
        name = g.toEncodedString(name,self.config_encoding) # 10/31/03
        config.set(section,name,val)</t>
<t tx="ekr.20041117062700.32"></t>
<t tx="ekr.20041117062717.1">@ This contains only the "interesting" defaults.
Ints and bools default to 0, floats to 0.0 and strings to "".
@c

defaultBodyFontSize = g.choose(sys.platform=="win32",9,12)
defaultLogFontSize  = g.choose(sys.platform=="win32",8,12)
defaultTreeFontSize = g.choose(sys.platform=="win32",9,12)

defaultsDict = {
    # compare options...
    "ignore_blank_lines" : ("bool",True),
    "limit_count" : ("int",9),
    "print_mismatching_lines" : ("bool",True),
    "print_trailing_lines" : ("bool",True),
    # find/change options...
    "search_body" : ("bool",True),
    "whole_word" : ("bool",True),
    # Prefs panel.
    "default_target_language" : ("language","Python"),
    "tab_width" : ("int",-4),
    "page_width" : ("int",132),
    "output_doc_chunks" : ("bool",True),
    "tangle_outputs_header" : ("bool",True),
    # Syntax coloring options...
    # Defaults for colors are handled by leoColor.py.
    "color_directives_in_plain_text" : ("bool",True),
    "underline_undefined_section_names" : ("bool",True),
    # Window options...
    "allow_clone_drags" : ("bool",True),
    "body_pane_wraps" : ("bool",True),
    "body_text_font_family" : ("tk-font-family","Courier"),
    "body_text_font_size" : ("tk-font-size",defaultBodyFontSize),
    "body_text_font_slant" : ("tk-font-slant","roman"),
    "body_text_font_weight" : ("tk-font-weight","normal"),
    "enable_drag_messages" : ("bool",True),
    "headline_text_font_size" : ("tk-font-size",defaultLogFontSize),
    "headline_text_font_slant" : ("tk-font-slant","roman",
    "headline_text_font_weight" : ("tk-font-weight","normal",
    "log_text_font_size" : ("tk-font-size",defaultLogFontSize),
    "log_text_font_slant" : ("tk-font-slant","roman"),
    "log_text_font_weight" : ("tk-font-weight","normal"),
    "initial_window_height" : ("tk-pixel",600),
    "initial_window_width" :  ("tk-pixel",800),
    "initial_window_left" : ("tk-pixel",10),
    "initial_window_top" : ("tk-pixel",10),
    "initial_splitter_orientation" : ("tk-orientation","vertical"),
    "initial_vertical_ratio" : ("ratio",0.5),
    "initial_horizontal_ratio" : ("ratio",0.3),
    "initial_horizontal_secondary_ratio" : ("ratio",0.5),
    "initial_vertical_secondary_ratio" : ("ratio",0.7),
    "outline_pane_scrolls_horizontally" : ("bool",False),
    "split_bar_color" : ("tk-color","LightSteelBlue2"),
    "split_bar_relief" : ("tk-relief","groove"),
    "split_bar_width" : ("int",7),
}</t>
<t tx="ekr.20041117062717.2">def __init__ (self):

    self.init()

def init (self):
    
    # These are now set in gui.getDefaultConfigFont
    self.defaultFont = None
    self.defaultFontFamily = None

    self.dictList = [self.defaultsDict] # List of dictionaries.
    self.recentFiles = [] # List of recent files.
    
    self.initSettingsFiles()
    self.initRecentFiles()
    self.initRawKeysDict()
    
    # Init settings from leoSettings.leo files.
    for path in (self.globalsFile, self.homeFile,self.loadFile):
        if path:
            c = openSettingsFile(path)
            if c:
                self.readSettings(c)</t>
<t tx="ekr.20041117062717.11">def getRecentFiles (self):
    
    return self.recentFiles</t>
<t tx="ekr.20041117062717.13">def getFontFromParams(self,family,size,slant,weight,defaultSize=12,tag=""):

    """Compute a font from font parameters.

    Arguments are the names of settings to be use.
    We default to size=12, slant="roman", weight="normal".

    We return None if there is no family setting so we can use system default fonts."""

    family = self.getString(family)
    if family in (None,""):
        family = self.defaultFontFamily
        
    size = self.getInt(size)
    if size in (None,0): size = defaultSize
    
    slant = self.getString(slant)
    if slant in (None,""): slant = "roman"
    
    weight = self.getString(weight)
    if weight in (None,""): weight = "normal"
    
    # if g.app.trace: g.trace(tag,family,size,slant,weight)
    
    return g.app.gui.getFontFromParams(family,size,slant,weight)</t>
<t tx="ekr.20041117062717.14">def getShortcut (self,name):
    
    # Allow '&amp;' in keys.
    val = self.rawKeysDict.get(name.replace('&amp;',''))
    if val:
        rawKey,shortcut = val
        return rawKey,shortcut
    else:
        return None,None</t>
<t tx="ekr.20041117062717.16">def setCommandsFindIvars (self,c):
    
    """Set c.name_flag for each name in findFrame.intKeys."""
    
    if g.app.gui.guiName() != "tkinter":
        return

    findFrame = g.app.findFrame

    for s in findFrame.intKeys:
        val = self.getBool(s)
        if val != None: # 10/2/03
            setattr(c,s+"_flag",val)
            # g.trace(s+"_flag",val)
            
    for name in ("change_string","find_string"):
        val = self.getString(name)
        if val:
            settattr(c,name,val)

    g.app.findFrame.init(c)</t>
<t tx="ekr.20041117062717.17"># Sets ivars of c that can be overridden by leoConfig.txt

def setCommandsIvars (self,c):

    data = (
        ("default_tangle_directory","tangle_directory","directory"),
        ("default_target_language","target_language","language"),
        ("output_doc_chunks","output_doc_flag","bool"),
        ("page_width","page_width","int"),
        ("run_tangle_done.py","tangle_batch_flag","bool"),
        ("run_untangle_done.py","untangle_batch_flag","bool"),
        ("tab_width","tab_width","int"),
        ("tangle_outputs_header","use_header_flag","bool"),
    )
    
    for setting,ivar,theType in data:
        val = g.app.config.get(setting,theType)
        if val is None:
            if not hasattr(c,setting):
                setattr(c,setting,None)
        else:
            setattr(c,setting,val)</t>
<t tx="ekr.20041117062717.19">def setConfigFindIvars (self,c):
    
    """Set the config ivars from the commander."""
    
    config = g.app.config

    # N.B.: separate c.ivars are much more convenient than a dict.
    for s in g.app.findFrame.intKeys: # These _are_ gui-independent.
        val = getattr(c,s+"_flag")
        config.setPref(s,val)
        # g.trace(s,val)
    
    config.setPref("change_string",c.change_text)
    config.setPref("find_string",c.find_text)</t>
<t tx="ekr.20041117062717.20"># Sets config ivars from c.

def setConfigIvars (self,c):
    
    config = g.app.config
    
    if c.target_language and g.app.language_delims_dict.get(c.target_language):
        language = c.target_language
    else:
        language = "plain"

    self.setPref("default_tangle_directory",c.tangle_directory)
    self.setPref("default_target_language",language)
    self.setPref("output_doc_chunks",str(c.output_doc_flag))
    self.setPref("page_width",str(c.page_width))
    self.setPref("run_tangle_done.py",str(c.tangle_batch_flag))
    self.setPref("run_untangle_done.py",str(c.untangle_batch_flag))
    self.setPref("tab_width",str(c.tab_width))
    self.setPref("tangle_outputs_header",str(c.use_header_flag))
    
    self.setPref("batch",str(c.batch_flag))
    self.setPref("ignore_case",str(c.ignore_case_flag))
    self.setPref("mark_changes",str(c.mark_changes_flag))
    self.setPref("mark_finds",str(c.mark_finds_flag))
    self.setPref("pattern_match",str(c.pattern_match_flag))
    self.setPref("reverse",str(c.reverse_flag))
    self.setPref("script_change",str(c.script_change_flag))
    self.setPref("script_search",str(c.script_search_flag))
    self.setPref("search_body",str(c.search_body_flag))
    self.setPref("search_headline",str(c.search_headline_flag))
    self.setPref("selection_only",str(c.selection_only_flag)) # 11/9/03
    self.setPref("suboutline_only",str(c.suboutline_only_flag))
    self.setPref("wrap",str(c.wrap_flag))
    self.setPref("whole_word",str(c.whole_word_flag))
    
    self.setPref("change_string",c.change_text)
    self.setPref("find_string",c.find_text)</t>
<t tx="ekr.20041117062717.24">def initRawKeysDict (self):

    for key in self.keysDict.keys():
        newKey = key.replace('&amp;','')
        self.rawKeysDict[newKey] = key,self.keysDict[key]

    if 0: #trace
        keys = self.rawKeysDict.keys()
        keys.sort()
        for key in keys:
            print self.rawKeysDict[key]</t>
<t tx="ekr.20041117062717.25">find = self.findDict.get("find_string")
if find:
    # Leo always writes utf-8 encoding, but users may not.
    find = g.toUnicode(find,"utf-8")
    self.findDict["find_string"] = find

change = self.findDict.get("change_string")
if change:
    # Leo always writes utf-8 encoding, but users may not.
    change = g.toUnicode(change,"utf-8")
    self.findDict["change_string"] = change</t>
<t tx="ekr.20041117062717.27"># Before 4.3: called when writing .leo file.  This had various unpleasant consequences.
# After  4.3: called immediately when a setting changes, and never when writing .leo files.

def update (self,verbose=False):
    
    g.trace()
    """Write the entire config file from ivars."""
    # Do nothing if the file does not exist, or if read_only.
    if self.read_only:
        if verbose:
            g.es("Read only config file",color="blue")
        return
    if not g.os_path_exists(self.configFileName):
        if verbose:
            g.es("No config file",color="blue")
        return
    
    config = ConfigParser.ConfigParser()
    self.config = config
    try:
        # 9/1/02: apparently Linux requires w+ and XP requires w.
        mode = g.choose(sys.platform=="win32","wb","wb+")
        cf = open(self.configFileName,mode)
        config.readfp(cf)
        &lt;&lt; write recent files section &gt;&gt;
        for section,dict in self.sectionInfo:
            if dict:
                self.update_section(config,section,dict)
        config.write(cf)
        cf.flush()
        cf.close()
    except:
        g.es("exception writing: " + self.configFileName)
        g.es_exception()
    self.config = None</t>
<t tx="ekr.20041117062717.28">section = self.recentFilesSection
files = self.recentFiles

section = g.toEncodedString(section,"utf-8") # 10/31/03

if config.has_section(section):
    config.remove_section(section)
config.add_section(section)

if 0: # elegant, but may be a security hole.
    config.set(section,"recentFiles",files)
else: # easier to read in the config file.
    for i in xrange(len(files)):
        f = g.toEncodedString(files[i],self.config_encoding) # 10/31/03
        config.set(section, "file"+str(i), f)</t>
<t tx="ekr.20041117062717.29">def update_section (self,config,section,dict):
    
    section = g.toEncodedString(section,self.config_encoding) # 10/31/03

    if config.has_section(section):
        config.remove_section(section)
    config.add_section(section)
    
    keys = dict.keys()
    keys.sort() # Not effective.
    for name in keys:
        val = dict [name]
        val  = g.toEncodedString(val,self.config_encoding)
        name = g.toEncodedString(name,self.config_encoding) # 10/31/03
        config.set(section,name,val)</t>
<t tx="ekr.20041117065611">def initIvar(self,ivarName):
    
    val,error = self.getSetting(ivarName)
    if not error:
        setattr(self,ivarName,val)</t>
<t tx="ekr.20041117065611.1">def initEncoding (self,encodingName):
    
    encoding = self.getSetting(encodingName)

    if g.isValidEncoding(encoding):
        setattr(self,encodingName,encoding)
    else:
        g.es("bad %s: %s" % (encodingName,encoding))</t>
<t tx="ekr.20041117065611.2">def initIvarsFromSettings (self):

    self.initIvar    ("at_root_bodies_start_in_doc_mode")
    self.initEncoding("config_encoding")
    self.initIvar    ("create_nonexistent_directories")
    self.initEncoding("default_derived_file_encoding")
    self.initEncoding("new_leo_file_encoding")
    self.initIvar    ("output_initial_comment")
    self.initIvar    ("output_newline")
    self.initIvar    ("read_only")
    self.initIvar    ("relative_path_base_directory")
    self.initIvar    ("redirect_execute_script_output_to_log_pane")
    self.initIvar    ("remove_sentinels_extension")
    self.initIvar    ("save_clears_undo_buffer")
    self.initIvar    ("stylesheet")
    self.initEncoding("tk_encoding")
    self.initIvar    ("trailing_body_newlines")
    self.initIvar    ("use_plugins")
    self.initIvar    ("use_psyco")
    self.initIvar    ("undo_granularity")
    self.initIvar    ("write_strips_blank_lines")</t>
<t tx="ekr.20041117072055"># Same as defaults dict, except that changing the setting sets the corresponding ivar.
ivarsDict = {
    "at_root_bodies_start_in_doc_mode" : ("bool",True), # For compatibility with previous versions.
    "config_encoding" : ("unicode-encoding","utf-8"), # Encoding used for leoConfig.txt.
    "create_nonexistent_directories" : ("bool",False),
    "default_derived_file_encoding" : ("unicode-encoding","utf-8"),
    "new_leo_file_encoding" : ("unicode-encoding","UTF-8"), # Upper case for compatibility with previous versions.
    "output_initial_comment" : ("string",""), # "" for compatibility with previous versions.
    "output_newline" : ("newline-type","nl"),
    "read_only" : ("bool",True), # Make sure we don't alter an illegal leoConfig.txt file!
    "redirect_execute_script_output_to_log_pane" : ("bool",False),
    "relative_path_base_directory" : ("directory","!"),
    "remove_sentinels_extension" : ("string",".txt"),
    "save_clears_undo_buffer" : ("bool",False),
    "stylesheet" : ("string",None),
    "tkEncoding" : ("unicode-encoding",None) # Defaults to None so it doesn't override better defaults.
    "trailing_body_newlines" : ("newline-type","asis"),
    "use_plugins" : ("bool",False), # Should never be True here!
    "use_psyco" : ("bool",False),
    "undo_granularity" : ("undo_granularity","word"), # "char","word","line","node"
    "write_strips_blank_lines" : ("bool",False),
}
</t>
<t tx="ekr.20041117081009"></t>
<t tx="ekr.20041117081009.3">def getBool (self,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    return self.get(setting,"bool")

getBoolColorsPref = getBool
getBoolComparePref = getBool
getBoolFindPref = getBool
getBoolPref = getBool
getBoolWindowPref = getBool</t>
<t tx="ekr.20041117081009.4">def getString (self,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
     return self.get(setting,"string")

getStringColorsPref = getString
getStringComparePref = getString
getStringFindPref = getString
getStringPref = getString
getStringWindowPref = getString</t>
<t tx="ekr.20041117081513">def getInt (self,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
     return self.get(setting,"int")

getIntComparePref = getInt
getIntPref = getInt
getIntWindowPref = getInt</t>
<t tx="ekr.20041117082135">def getFloat (self,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
     return self.get(setting,"float")

getFloatWindowPref = getFloat</t>
<t tx="ekr.20041117083141">def get (self,name,type):
    
    """Get the setting and make sure its type matches the expected type."""
    
    pass</t>
<t tx="ekr.20041117083202"></t>
<t tx="ekr.20041117083202.2">def initRecentFiles (self):

    try:
        for i in xrange(10):
            f = config.get(section,"file" + str(i),raw=1)
            f = g.toUnicode(f,"utf-8") # 10/31/03
            self.recentFiles.append(f)
    except: pass
    
def initRecentFiles (self,files):

    self.recentFiles = files
</t>
<t tx="ekr.20041117083857">def initSettingsFiles (self):
    
    """Set self.globalsFile, self.homeFile, self.loadFile, self.openFile"""

    dirs = [] # Directories that have already been searched.
    
    for ivar,dir in (
        ("globalsFile",g.app.globalDir),
        ("homeFile",g.app.homeDir),
        "loadFile",g.app.loadDir),
    ):

        if dir not in dirs:
            dirs.append(dir)
            path = g.os_path_join(dir,"leoSettings.leo")
            if g.os_path_exists(path):
                setattr(self,ivar,path)
            else:
                setattr(self,ivar,None)</t>
<t tx="ekr.20041117083857.1"># Called to read all leoSettings.leo file.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    pass</t>
<t tx="ekr.20041117085625">def openSettingsFile (self,path):
    
    pass</t>
<t tx="ekr.20041117090429"></t>
<t tx="ekr.20041117093009"></t>
<t tx="ekr.20041117093009.1">def getDirectory (self,setting):
    
    """Search all dictionaries for the setting &amp; check it's type"""
    
    dir = self.getString(setting)
    if g.os_path_exists(dir):
         return dir
    else:
        return None</t>
<t tx="ekr.20041117093009.2">def getLanguage (self,setting):
    
    """Return the setting whose value should be a language known to Leo."""
    
    language = self.getString(setting)

    if language in xxx:
        return language
    else:
        return None</t>
<t tx="ekr.20041117093246"></t>
</tnodes>
</leo_file>
