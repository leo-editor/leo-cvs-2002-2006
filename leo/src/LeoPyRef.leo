<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="8651" clone_windows="0"/>
<globals body_outline_ratio="0.593548387097">
	<global_window_position top="10" left="380" height="930" width="880"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20051125080855,ekr.20031218072017.1810,ekr.20051218122116,ekr.20051218121447,ekr.20051218171457,ekr.20051213094517,ekr.20050920084036.137,ekr.20051218133207.1,ekr.20051218133207,ekr.20050920084036.136,ekr.20051218174113,ekr.20040803072955.128,ekr.20031218072017.2950,ekr.20031218072017.2373,ekr.20050920084036.145,ekr.20051019201809.6,ekr.20051125080855,ekr.20051026092433.1,ekr.20051218122116,ekr.20051218121447,ekr.20051218171457,ekr.20051213094517,ekr.20050920084036.137,ekr.20051218133207.1,ekr.20051218133207,ekr.20050920084036.136,ekr.20051218174113,ekr.20051218122116,ekr.20051218121447,ekr.20051218171457,ekr.20051213094517,ekr.20050920084036.137,ekr.20051218133207.1,ekr.20051218133207,ekr.20050920084036.136,ekr.20051218174113,ekr.20051125080855,ekr.20051026092433.1,ekr.20051125080855,ekr.20040803072955.128,ekr.20051023181449,ekr.20051025120920,ekr.20050120092028,ekr.20031218072017.2373,ekr.20051024173701,ekr.20051018102027,ekr.20051018061932.1,ekr.20051016101724.1,ekr.20051006092617.1,ekr.20051006092617.1,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20050831131028"><vh>opml</vh>
<v t="ekr.20050831131452"><vh>Original post</vh></v>
<v t="ekr.20050831131452.1"><vh>opml attributes v elements</vh></v>
<v t="ekr.20050912063133"><vh>@url http://sourceforge.net/forum/message.php?msg_id=3273977</vh></v>
<v t="ekr.20050912065811"><vh>@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)</vh></v>
<v t="ekr.20050915062404"><vh>My post</vh></v>
</v>
<v t="ekr.20040117181936"
marks="ekr.20031218072017.1810,ekr.20051202102752.2,ekr.20051202102752.3,ekr.20051202102752.4,ekr.20051023181449,ekr.20051025120920,ekr.20031218072017.1810,ekr.20031218072017.2373,ekr.20051127105431,ekr.20051126123149,ekr.20051127065601,ekr.20051127105102,ekr.20051127070018,ekr.20051023181449,ekr.20051020120306.27,ekr.20051025071455,ekr.20051025120920,ekr.20031218072017.1810,ekr.20051210111121.1,ekr.20051025071455,ekr.20051025120920,ekr.20051202102752.2,ekr.20051202102752.3,ekr.20051202102752.4,"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20051010062551.1"><vh>(key dicts)</vh></v>
<v t="ekr.20051206111317"><vh>4.4a5 projects</vh>
<v t="ekr.20051219200934"><vh>cvs snapshot 1</vh>
<v t="ekr.20051208102436"><vh>Bugs fixed</vh>
<v t="ekr.20051206082343"><vh>Made sure focus doesn't go to log during tab completion or after writes to log</vh>
<v t="ekr.20031218072017.1473"><vh>put</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051208091305"><vh>Fixed problem with getScript in batch mode</vh>
<v t="EKR.20040614071102.1"><vh>g.getScript &amp; tests</vh>
<v t="ekr.20050211100535"><vh>test_g_getScript_strips_crlf</vh></v>
</v>
</v>
<v t="ekr.20051207180807"><vh>Select text box in goto-line-number command</vh>
<v t="ekr.20051208102107"><vh>Report</vh></v>
<v t="ekr.20031218072017.3878"><vh>tkinterAskOKCancelNumber.createFrame</vh></v>
</v>
<v t="ekr.20051209081445.2"><vh>Restored headkey hooks</vh>
<v t="ekr.20051209083903"><vh>Report</vh></v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20051209085227"><vh>Restored bodykey hooks</vh>
<v t="ekr.20051209085227.1"><vh>Report</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
<v t="ekr.20051125080855" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
</v>
<v t="ekr.20051209081445"><vh>Fixed ancient bug in read error logic that hung Leo</vh>
<v t="ekr.20051209081445.1"><vh>Report &amp; what I did</vh></v>
<v t="ekr.20041005105605.127"><vh>readError</vh></v>
<v t="ekr.20041005105605.220"><vh>atFile.error</vh></v>
<v t="ekr.20041005105605.27"><vh>readOpenFile</vh>
<v t="ekr.20041005105605.28"><vh>&lt;&lt; handle first and last lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.74"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20041005105605.75"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20041005105605.76"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20041005105605.77"><vh>readNormalLine</vh>
<v t="ekr.20041005105605.78"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20041005105605.79"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.80"><vh>start sentinels</vh>
<v t="ekr.20041005105605.81"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20041005105605.82"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20041005105605.83"><vh>readStartLeo</vh></v>
<v t="ekr.20041005105605.84"><vh>readStartMiddle</vh></v>
<v t="ekr.20041005105605.85"><vh>readStartNode (4.x)</vh>
<v t="ekr.20041005105605.86"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20041005105605.87"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20041005105605.88"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.89"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20041005105605.90"><vh>end sentinels</vh>
<v t="ekr.20041005105605.91"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20041005105605.92"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20041005105605.93"><vh>readEndLeo</vh></v>
<v t="ekr.20041005105605.94"><vh>readEndMiddle</vh></v>
<v t="ekr.20041005105605.95"><vh>readEndNode (4.x)</vh>
<v t="ekr.20041005105605.96"><vh>&lt;&lt; indicate that the node has been changed &gt;&gt;</vh>
<v t="ekr.20041005105605.97"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041005105605.98"><vh>readEndOthers</vh></v>
<v t="ekr.20041005105605.99"><vh>readLastDocLine</vh></v>
</v>
<v t="ekr.20041005105605.100"><vh>Unpaired sentinels</vh>
<v t="ekr.20041005105605.101"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20041005105605.102"><vh>readAfterRef</vh></v>
<v t="ekr.20041005105605.103"><vh>readClone</vh></v>
<v t="ekr.20041005105605.104"><vh>readComment</vh></v>
<v t="ekr.20041005105605.105"><vh>readDelims</vh></v>
<v t="ekr.20041005105605.106"><vh>readDirective (@@)</vh>
<v t="ekr.20041005105605.107"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="ekr.20041005105605.108"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.109"><vh>readNl</vh></v>
<v t="ekr.20041005105605.110"><vh>readNonl</vh></v>
<v t="ekr.20041005105605.111"><vh>readRef</vh></v>
<v t="ekr.20041005105605.112"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20041005105605.113"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20051213060647.1"><vh>Fixed minor headline problems</vh>
<v t="ekr.20051206082304.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20051216114320"><vh>Fixed problem in reformatParagraph</vh></v>
<v t="ekr.20051217091236"><vh>Investigated secondary ratio problems</vh>
<v t="ekr.20051217112605"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3689"><vh>initialRatios</vh></v>
</v>
<v t="ekr.20051216170531"><vh>Installed LeoUsers patch for the Read @file Nodes command</vh>
<v t="ekr.20051218102312"><vh>What I did</vh></v>
<v t="ekr.20041005105605.8"><vh>atFile.__init__ &amp; initIvars</vh>
<v t="ekr.20041005105605.9"><vh>&lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</vh></v>
</v>
<v t="ekr.20041005105605.72"><vh>createThinChild4</vh></v>
<v t="ekr.20051218100605.1"><vh>atFile.__init__ and initIvars NEW</vh>
<v t="ekr.20051218100605.2"><vh> define the dispatch dictionary used by scanText4</vh></v>
</v>
<v t="ekr.20051218100605.3"><vh>createThinChild4 NEW</vh></v>
</v>
<v t="ekr.20051219090231"><vh>Fixed bug: clicking in the expand/contract box didn't save the headline</vh>
<v t="ekr.20040803072955.79"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20051218110553"><vh>Installed LeoUser's patch for Read derived files</vh>
<v t="ekr.20051219122720"><vh>atFile.forceGnxOnPosition</vh></v>
<v t="ekr.20031218072017.1810" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20040930135204"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20051208100903.1"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
</v>
<v t="ekr.20051208102436.1"><vh>New features</vh>
<v t="ekr.20051208091816"><vh>created ut.leo, ut.py and ut.bat</vh></v>
<v t="ekr.20051207120838.1"><vh>Added modes/*.xml to distribution</vh></v>
<v t="ekr.20051216110817"><vh>Added 'insert' keyword to setTextSelection methods</vh>
<v t="ekr.20031218072017.4089"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20051217135340"><vh>(Revised cursor movement commands and added selection-extension commands)</vh>
<v t="ekr.20050920084036.55"><vh> getPublicCommands (editCommandsClass)</vh></v>
<v t="ekr.20050929114218"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20051218170358"><vh> helpers</vh>
<v t="ekr.20051218122116" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20051218121447" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20051218171457" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20051213094517" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20050920084036.137" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20051218133207.1" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20051218133207" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20050920084036.136" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20051218174113" a="M"><vh>extendMode</vh></v>
<v t="ekr.20050920084036.148"><vh>buffers</vh></v>
<v t="ekr.20051213080533"><vh>characters</vh></v>
<v t="ekr.20051218141237"><vh>lines</vh></v>
<v t="ekr.20050920084036.140"><vh>movePastClose (test)</vh></v>
<v t="ekr.20050920084036.102"><vh>paragraphs</vh></v>
<v t="ekr.20050920084036.131"><vh>sentences</vh></v>
<v t="ekr.20050920084036.149"><vh>words</vh></v>
</v>
</v>
</v>
<v t="ekr.20051217102943"><vh>Code changes</vh>
<v t="ekr.20051214125834"><vh>(Rewrote cut/copy/paste code)</vh>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
</v>
</v>
<v t="ekr.20051214113546.2"><vh>(Revised headline handlers)</vh>
<v t="ekr.20051214125235"><vh> What I did</vh>
<v t="ekr.20051216085517"><vh>Replaced calls to onHeadChanged by calls to c.endEditing</vh>
<v t="ekr.20031218072017.3975"><vh>OnActivateBody (tkFrame)</vh></v>
<v t="ekr.20031218072017.3982"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20050920084036.43"><vh>renameBuffer</vh></v>
</v>
</v>
<v t="ekr.20051216084926"><vh>Notes</vh></v>
<v t="ekr.20040803072955.125"><vh>Selecting &amp; editing... (tkTree)</vh>
<v t="ekr.20040803072955.126"><vh>tree.endEditLabel</vh></v>
<v t="ekr.20040803072955.127"><vh>editLabel</vh></v>
<v t="ekr.20040803072955.128" a="M"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.134"><vh>tree.set...LabelState</vh>
<v t="ekr.20040803072955.135"><vh>setEditLabelState</vh></v>
<v t="ekr.20040803072955.136"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20040803072955.138"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20040803072955.139"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20040803072955.140"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20040803072955.141"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20040803072955.142"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20040803072955.143"><vh>tree.expandAllAncestors</vh></v>
</v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051216083932"><vh>Calls to tree.endEditLabel</vh>
<v t="ekr.20031218072017.2992"><vh>c.endEditing (calls tree.endEditLabel)</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.80"><vh>Icon Box...</vh>
<v t="ekr.20040803072955.81"><vh>onIconBoxClick</vh></v>
<v t="ekr.20040803072955.89"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20040803072955.82"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20040803072955.83"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20051216080913.1"><vh>Calls to onHeadChanged</vh>
<v t="ekr.20031218072017.2290"><vh>toggleAngleBrackets</vh></v>
<v t="ekr.20031218072017.3070"><vh>changeSelection</vh></v>
<v t="ekr.20031218072017.3983"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20051216081742"><vh>Should *not* call onHeadChanged</vh>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
</v>
<v t="ekr.20051216125001"><vh>(Restored c.begin/endUpdate)</vh>
<v t="ekr.20051216160935"><vh>What I did</vh></v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20051026143009"><vh>removeTrailingNewlines</vh></v>
</v>
<v t="ekr.20031218072017.2949"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20031218072017.2950" a="M"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20031218072017.2951"><vh>c.bringToFront</vh></v>
<v t="ekr.20031218072017.2953"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20051216171520"><vh>c.recolor_now</vh></v>
<v t="ekr.20031218072017.2954"><vh>c.redraw_now</vh></v>
</v>
<v t="ekr.20040803072955.35"><vh>Drawing... (tkTree)</vh>
<v t="ekr.20051216155728"><vh>tree.begin/endUpdate</vh></v>
<v t="ekr.20040803072955.58"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20040803072955.59"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20040803072955.61"><vh>idle_second_redraw</vh></v>
<v t="ekr.20051105073850"><vh>drawX...</vh>
<v t="ekr.20040803072955.36"><vh>drawBox</vh></v>
<v t="ekr.20040803072955.37"><vh>drawClickBox</vh>
<v t="ekr.20040803072955.38"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.39"><vh>drawIcon</vh>
<v t="ekr.20040803072955.40"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.41"><vh>drawLine</vh></v>
<v t="ekr.20040803072955.42"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040803072955.43"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20040803072955.44"><vh>drawText</vh>
<v t="ekr.20040803072955.45"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.46"><vh>drawUserIcons</vh></v>
<v t="ekr.20040803072955.47"><vh>drawUserIcon</vh>
<v t="ekr.20040803072955.48"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20040803072955.49"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20040803072955.50"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20040803072955.51"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.52"><vh>drawTopTree</vh></v>
<v t="ekr.20040803072955.53"><vh>drawTree</vh></v>
</v>
<v t="ekr.20040803072955.62"><vh>Helpers...</vh>
<v t="ekr.20040803072955.63"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20040803072955.64"><vh>getIconImage</vh></v>
<v t="ekr.20040803072955.65"><vh>scrollTo</vh>
<v t="ekr.20040803072955.66"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040803072955.67"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.68"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20040803072955.70"><vh>yoffset</vh></v>
</v>
</v>
<v t="ekr.20051216155029"><vh>@@button insert begin/endUpdate</vh></v>
</v>
</v>
<v t="ekr.20051212135654"><vh>(Revised key binding code)</vh>
<v t="ekr.20051214082024"><vh>Notes</vh>
<v t="ekr.20051213073224"><vh>Create commands for all Tk defaults key</vh></v>
<v t="ekr.20051207140933"><vh>Create selection mode</vh>
<v t="ekr.20051207140933.1"><vh>Posting</vh></v>
</v>
<v t="ekr.20051214075028"><vh>Problems</vh>
<v t="ekr.20051213100651"><vh>forward-sentence-extend-selection doesn't work when invoked by long name</vh></v>
<v t="ekr.20051213100651.1"><vh>Backspace  deletes 2 chars everywhere</vh></v>
</v>
<v t="ekr.20051214082024.1"><vh>Make arrow keys work properly both in the canvas and in headlines</vh></v>
</v>
<v t="ekr.20031218072017.4059"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20031218072017.844"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20031218072017.845"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20031218072017.846"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20031218072017.4060"><vh>Dialog</vh>
<v t="ekr.20031218072017.4061"><vh>get_window_info</vh></v>
<v t="ekr.20031218072017.4062"><vh>center_dialog</vh></v>
<v t="ekr.20031218072017.4063"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20031218072017.4064"><vh>Focus</vh>
<v t="ekr.20031218072017.4065"><vh>get_focus</vh></v>
<v t="ekr.20031218072017.2373" a="M"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20050210082320"><vh>widget_wants_focus (tk.gui)</vh></v>
</v>
<v t="ekr.20031218072017.4066"><vh>Font</vh>
<v t="ekr.20031218072017.2187"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20031218072017.4067"><vh>Icons</vh>
<v t="ekr.20031218072017.4068"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20031218072017.4069"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4070"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4071"><vh>Idle Time</vh>
<v t="ekr.20031218072017.4072"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20031218072017.4073"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20031218072017.4074"><vh>Indices (Tk)</vh>
<v t="ekr.20031218072017.4075"><vh>firstIndex</vh></v>
<v t="ekr.20031218072017.4076"><vh>lastIndex</vh></v>
<v t="ekr.20031218072017.4077"><vh>moveIndexBackward</vh></v>
<v t="ekr.20031218072017.4078"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20031218072017.4079"><vh>compareIndices</vh></v>
<v t="ekr.20031218072017.4080"><vh>getindex</vh></v>
</v>
<v t="ekr.20031218072017.4081"><vh>Insert Point</vh>
<v t="ekr.20031218072017.4082"><vh>getInsertPoint</vh></v>
<v t="ekr.20031218072017.4083"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20031218072017.4084"><vh>Selection</vh>
<v t="ekr.20031218072017.4085"><vh>getSelectionRange (to be deleted?)</vh></v>
<v t="ekr.20051126125950"><vh>getSelectedText</vh></v>
<v t="ekr.20031218072017.4086"><vh>getTextSelection</vh></v>
<v t="ekr.20051126171929"><vh>hasSelection</vh></v>
<v t="ekr.20031218072017.4088"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20031218072017.4089"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20031218072017.4090"><vh>Text</vh>
<v t="ekr.20031218072017.4091"><vh>getAllText</vh></v>
<v t="ekr.20031218072017.4092"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20031218072017.4093"><vh>getCharAtIndex</vh></v>
<v t="ekr.20031218072017.4094"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20031218072017.4095"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20031218072017.4096"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20031218072017.4097"><vh>Visibility</vh>
<v t="ekr.20031218072017.4098"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20051220144507"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20050920084036.53"><vh>class editCommandsClass</vh>
<v t="ekr.20050929155208"><vh> birth</vh>
<v t="ekr.20050920084036.54"><vh> ctor</vh></v>
<v t="ekr.20050920084036.55"><vh> getPublicCommands (editCommandsClass)</vh></v>
</v>
<v t="ekr.20050920084036.57"><vh>capitalization &amp; case</vh>
<v t="ekr.20051015114221"><vh>capitalizeWord &amp; up/downCaseWord</vh></v>
<v t="ekr.20050920084036.145" a="M"><vh>changePreviousWord</vh></v>
<v t="ekr.20051015114221.1"><vh>capitalizeHelper</vh></v>
</v>
<v t="ekr.20051019183105"><vh>color &amp; font</vh>
<v t="ekr.20051019183105.1"><vh>show-colors</vh>
<v t="ekr.20051019183105.2"><vh>&lt;&lt; define colors &gt;&gt;</vh></v>
<v t="ekr.20051019183105.3"><vh>createColorPicker</vh>
<v t="ekr.20051019183105.4"><vh>&lt;&lt; create optionMenu and callback &gt;&gt;</vh></v>
<v t="ekr.20051019183105.5"><vh>&lt;&lt; create picker button and callback &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051019201809"><vh>show-fonts &amp; helpers</vh>
<v t="ekr.20051019201809.1"><vh>createFontPicker</vh>
<v t="ekr.20051019202139"><vh>&lt;&lt; create the frames &gt;&gt;</vh></v>
<v t="ekr.20051019201809.2"><vh>&lt;&lt; create the family combo box &gt;&gt;</vh></v>
<v t="ekr.20051019201809.3"><vh>&lt;&lt; create the size entry &gt;&gt;</vh></v>
<v t="ekr.20051019201809.4"><vh>&lt;&lt; create the weight combo box &gt;&gt;</vh></v>
<v t="ekr.20051019201809.5"><vh>&lt;&lt; create the slant combo box&gt;&gt;</vh></v>
<v t="ekr.20051019202139.1"><vh>&lt;&lt; create the sample text widget &gt;&gt;</vh></v>
<v t="ekr.20051019202328"><vh>&lt;&lt; create and bind the callbacks &gt;&gt;</vh></v>
</v>
<v t="ekr.20051019201809.6" a="M"><vh>getFont</vh></v>
<v t="ekr.20051019201809.7"><vh>setFont</vh></v>
</v>
</v>
<v t="ekr.20050920084036.132"><vh>comment column...</vh>
<v t="ekr.20050920084036.133"><vh>setCommentColumn</vh></v>
<v t="ekr.20050920084036.134"><vh>indentToCommentColumn</vh></v>
</v>
<v t="ekr.20050920084036.58"><vh>dynamic abbreviation...</vh>
<v t="ekr.20050920084036.59"><vh>dynamicExpansion</vh></v>
<v t="ekr.20050920084036.60"><vh>dynamicExpansion2</vh></v>
<v t="ekr.20050920084036.61"><vh>getDynamicList (helper)</vh></v>
</v>
<v t="ekr.20050920084036.62"><vh>esc methods for Python evaluation</vh>
<v t="ekr.20050920084036.63"><vh>watchEscape (Revise)</vh></v>
<v t="ekr.20050920084036.64"><vh>escEvaluate (Revise)</vh></v>
</v>
<v t="ekr.20050920084036.65"><vh>evalExpression</vh></v>
<v t="ekr.20051022142249"><vh>focus (editCommandsClass)</vh>
<v t="ekr.20051022144825"><vh>focusToBody/Log/Tree/Minibuffer</vh></v>
<v t="ekr.20051022144825.1"><vh>cycleFocus</vh></v>
</v>
<v t="ekr.20050920084036.66"><vh>fill column and centering</vh>
<v t="ekr.20050920084036.67"><vh>centerLine</vh></v>
<v t="ekr.20050920084036.68"><vh>setFillColumn</vh></v>
<v t="ekr.20050920084036.69"><vh>centerRegion</vh></v>
<v t="ekr.20050920084036.70"><vh>setFillPrefix</vh></v>
<v t="ekr.20050920084036.71"><vh>_addPrefix</vh></v>
</v>
<v t="ekr.20050920084036.72"><vh>goto...</vh>
<v t="ekr.20050929115226"><vh>gotoCharacter</vh></v>
<v t="ekr.20050929124234"><vh>gotoLine</vh></v>
</v>
<v t="ekr.20050920084036.74"><vh>indent... (To do: undo)</vh>
<v t="ekr.20050920084036.75"><vh>backToIndentation</vh></v>
<v t="ekr.20050920084036.76"><vh>deleteIndentation</vh></v>
<v t="ekr.20050920084036.77"><vh>insertNewLineIndent</vh></v>
<v t="ekr.20050920084036.78"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20050920084036.85"><vh>insert &amp; delete...</vh>
<v t="ekr.20051125080855" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
<v t="ekr.20051026092433.1" a="M"><vh>backwardDeleteCharacter (ok)</vh>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.87"><vh>deleteNextChar (ok)</vh></v>
<v t="ekr.20050920084036.135"><vh>deleteSpaces</vh></v>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20050920084036.138"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20050920084036.86"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20050920084036.139"><vh>insertParentheses</vh></v>
</v>
<v t="ekr.20050920084036.79"><vh>info...</vh>
<v t="ekr.20050920084036.80"><vh>howMany</vh></v>
<v t="ekr.20050920084036.81"><vh>lineNumber</vh></v>
<v t="ekr.20050920084036.83"><vh>viewLossage</vh></v>
<v t="ekr.20050920084036.84"><vh>whatLine</vh></v>
</v>
<v t="ekr.20050920084036.88"><vh>line...</vh>
<v t="ekr.20050920084036.90"><vh>flushLines</vh></v>
<v t="ekr.20051002095724"><vh>keepLines</vh></v>
<v t="ekr.20050920084036.92"><vh>linesHelper</vh></v>
</v>
<v t="ekr.20050920084036.147"><vh>measure</vh></v>
<v t="ekr.20050929114218"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20051218170358"><vh> helpers</vh>
<v t="ekr.20051218122116" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20051218121447" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20051218171457" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20051213094517" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20050920084036.137" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20051218133207.1" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20051218133207" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20050920084036.136" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20051218174113" a="M"><vh>extendMode</vh></v>
<v t="ekr.20050920084036.148"><vh>buffers</vh></v>
<v t="ekr.20051213080533"><vh>characters</vh></v>
<v t="ekr.20051218141237"><vh>lines</vh></v>
<v t="ekr.20050920084036.140"><vh>movePastClose (test)</vh></v>
<v t="ekr.20050920084036.102"><vh>paragraphs</vh></v>
<v t="ekr.20050920084036.131"><vh>sentences</vh></v>
<v t="ekr.20050920084036.149"><vh>words</vh></v>
</v>
<v t="ekr.20050920084036.95"><vh>paragraph...</vh>
<v t="ekr.20050920084036.99"><vh>backwardKillParagraph</vh></v>
<v t="ekr.20050920084036.103"><vh>fillParagraph</vh></v>
<v t="ekr.20050920084036.100"><vh>fillRegion</vh></v>
<v t="ekr.20050920084036.104"><vh>fillRegionAsParagraph</vh></v>
<v t="ekr.20050920084036.98"><vh>killParagraph (Test)</vh></v>
<v t="ekr.20050920084036.96"><vh>selectParagraph &amp; helper</vh>
<v t="ekr.20050920084036.97"><vh>selectParagraphHelper</vh></v>
</v>
</v>
<v t="ekr.20050920084036.105"><vh>region...</vh>
<v t="ekr.20050920084036.106"><vh>setRegion</vh>
<v t="ekr.20051002102410"><vh>down</vh></v>
<v t="ekr.20051002102410.1"><vh>extend</vh></v>
<v t="ekr.20051002102410.2"><vh>truncate</vh></v>
<v t="ekr.20051002102410.3"><vh>up</vh></v>
</v>
<v t="ekr.20050920084036.107"><vh>indentRegion</vh></v>
<v t="ekr.20050920084036.108"><vh>tabIndentRegion</vh></v>
<v t="ekr.20050920084036.109"><vh>countRegion</vh></v>
<v t="ekr.20050920084036.110"><vh>reverseRegion</vh></v>
<v t="ekr.20050920084036.111"><vh>up/downCaseRegion &amp; helper</vh></v>
</v>
<v t="ekr.20050920084036.112"><vh>replace...</vh>
<v t="ekr.20050920084036.113"><vh>replaceString</vh>
<v t="ekr.20050920084036.114"><vh>&lt;&lt; do the replace &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.115"><vh>activateReplaceRegex</vh></v>
</v>
<v t="ekr.20050920084036.116"><vh>scrollUp/Down</vh></v>
<v t="ekr.20050920084036.117"><vh>sort...</vh>
<v t="ekr.20050920084036.118"><vh>sortLines</vh></v>
<v t="ekr.20050920084036.119"><vh>sortColumns</vh></v>
<v t="ekr.20050920084036.120"><vh>sortFields</vh></v>
</v>
<v t="ekr.20050920084036.121"><vh>swap/transpose...</vh>
<v t="ekr.20050920084036.122"><vh>transposeLines</vh></v>
<v t="ekr.20050920084036.123"><vh>swapWords &amp; transposeWords</vh></v>
<v t="ekr.20050920084036.124"><vh>swapCharacters &amp; transeposeCharacters</vh></v>
</v>
<v t="ekr.20050920084036.126"><vh>tabify &amp; untabify</vh></v>
</v>
<v t="ekr.20050929114218"><vh>move... (leoEditCommands) (ok)</vh>
<v t="ekr.20051218170358"><vh> helpers</vh>
<v t="ekr.20051218122116" a="M"><vh>moveToHelper</vh></v>
<v t="ekr.20051218121447" a="M"><vh>moveWordHelper</vh></v>
<v t="ekr.20051218171457" a="M"><vh>movePastCloseHelper</vh></v>
<v t="ekr.20051213094517" a="M"><vh>backSentenceHelper</vh></v>
<v t="ekr.20050920084036.137" a="M"><vh>forwardSentenceHelper</vh></v>
<v t="ekr.20051218133207.1" a="M"><vh>forwardParagraphHelper</vh></v>
<v t="ekr.20051218133207" a="M"><vh>backwardParagraphHelper</vh></v>
</v>
<v t="ekr.20050920084036.136" a="M"><vh>exchangePointMark</vh></v>
<v t="ekr.20051218174113" a="M"><vh>extendMode</vh></v>
<v t="ekr.20050920084036.148"><vh>buffers</vh></v>
<v t="ekr.20051213080533"><vh>characters</vh></v>
<v t="ekr.20051218141237"><vh>lines</vh></v>
<v t="ekr.20050920084036.140"><vh>movePastClose (test)</vh></v>
<v t="ekr.20050920084036.102"><vh>paragraphs</vh></v>
<v t="ekr.20050920084036.131"><vh>sentences</vh></v>
<v t="ekr.20050920084036.149"><vh>words</vh></v>
</v>
<v t="ekr.20050920084036.85"><vh>insert &amp; delete...</vh>
<v t="ekr.20051125080855" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
<v t="ekr.20051026092433.1" a="M"><vh>backwardDeleteCharacter (ok)</vh>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.87"><vh>deleteNextChar (ok)</vh></v>
<v t="ekr.20050920084036.135"><vh>deleteSpaces</vh></v>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20050920084036.138"><vh>insertNewLine (not undoable)</vh></v>
<v t="ekr.20050920084036.86"><vh>insertNewLineAndTab</vh></v>
<v t="ekr.20050920084036.139"><vh>insertParentheses</vh></v>
</v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh></v>
</v>
<v t="ekr.20051214115158"><vh>(Revised general text widget handlers)</vh>
<v t="ekr.20051023182326"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20051125080855" a="M"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
<v t="ekr.20051214113546.1"><vh>k.onTextWidgetKey &amp; insertString</vh></v>
</v>
<v t="ekr.20051217074031"><vh>(Moved headline coloring code out of endEditLabel and into select)</vh>
<v t="ekr.20051217082130"><vh>What I did</vh></v>
<v t="ekr.20040803072955.128" a="M"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3982"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20040803072955.126"><vh>tree.endEditLabel</vh></v>
</v>
</v>
</v>
<v t="ekr.20051220091742"><vh>Bugs</vh>
<v t="ekr.20051220090650"><vh>Fixed crasher in backwardDeleteCharacter</vh></v>
<v t="ekr.20051219125559"><vh>Fixed recent bug: dialogs now get focus properly when first opened.</vh></v>
<v t="ekr.20051221100114.1"><vh>Made sure shortcuts are printed clearly by k.registerCommand</vh>
<v t="ekr.20051122104219"><vh>prettyPrintKey</vh></v>
<v t="ekr.20051015110547"><vh>k.registerCommand</vh></v>
</v>
</v>
<v t="ekr.20051220091742.1"><vh>Code level</vh>
<v t="ekr.20051219124309"><vh>Removed calls to update followed by xWantsFocus</vh></v>
<v t="ekr.20051220145225"><vh>Added g.app.gui.isTextWidget</vh>
<v t="ekr.20051220144507"><vh>isTextWidget</vh></v>
</v>
</v>
<v t="ekr.20051220093312"><vh>New features</vh>
<v t="ekr.20051123055200"><vh>*** Allow multiple bindings to the same command</vh>
<v t="ekr.20051220070321.1"><vh>To do</vh></v>
<v t="ekr.20051220063601"><vh>From leoConfig.py</vh>
<v t="ekr.20041119204700"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20041120112043"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20041120113848"><vh>doShortcut</vh></v>
<v t="ekr.20041120105609"><vh>doShortcuts</vh></v>
<v t="ekr.20041227071423"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20041117062717.14"><vh>getShortcut (config)</vh></v>
</v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.11"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20050920085536.12"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20051023182326"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20050923174229.1"><vh>makeHardBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20031218072017.2098"><vh>canonicalizeShortcut</vh>
<v t="ekr.20031218072017.2102"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2099"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20031218072017.2100"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2101"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2103"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20051220064128"><vh>Calls to getShortcut</vh>
<v t="ekr.20051023181449" a="M"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051025120920" a="M"><vh>createBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20051220070321"><vh>Settings command is now the same as open-leoettings-leo</vh>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
<v t="ekr.20031218072017.2086"><vh>preferences</vh></v>
</v>
</v>
<v t="ekr.20051111065016"><vh>(Moving focus out of limbo)</vh>
<v t="ekr.20051022152427"><vh>Focus</vh>
<v t="ekr.20050120083053"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20050120092028" a="M"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20050120092028.1"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20031218072017.2373" a="M"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20051113080509"><vh>Find methods</vh>
<v t="ekr.20031218072017.3089"><vh>restore</vh></v>
<v t="ekr.20031218072017.3091"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20031218072017.4039"><vh>class leoTkinterLog</vh>
<v t="ekr.20051016095907"><vh>tkLog Birth</vh>
<v t="ekr.20031218072017.4040"><vh>tkLog.__init__</vh></v>
<v t="ekr.20031218072017.4042"><vh>tkLog.createControl</vh></v>
<v t="ekr.20051016103459"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20051019134106.1"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20051016095907.1"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20031218072017.4041"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20031218072017.4043"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20041222043017"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20041222043017.1"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20041217135735.2"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20031218072017.4046"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20051016095907.2"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20031218072017.4045"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20031218072017.4044"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20051016101927"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20031218072017.1473"><vh>put</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20051016101927.1"><vh>putnl</vh></v>
</v>
<v t="ekr.20051018061932"><vh>Tab (TkLog)</vh>
<v t="ekr.20051017212057"><vh>clearTab</vh></v>
<v t="ekr.20051024173701" a="M"><vh>createTab</vh>
<v t="ekr.20051020075416"><vh>&lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;</vh></v>
<v t="ekr.20051018072306"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20051018102027" a="M"><vh>deleteTab</vh></v>
<v t="ekr.20051027114433"><vh>getSelectedTab</vh></v>
<v t="ekr.20051018061932.1" a="M"><vh>lower/raiseTab</vh></v>
<v t="ekr.20051019170806"><vh>renameTab</vh></v>
<v t="ekr.20051016101724.1" a="M"><vh>selectTab</vh></v>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051019134106"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20051019134422"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20051019140004.1"><vh>newTabFromMenu</vh></v>
<v t="ekr.20051019165401"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20051019172811"><vh>getTabName</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051014161015"><vh>Full input modes</vh>
<v t="ekr.20060103104509"><vh>To do</vh></v>
<v t="ekr.20060104154253"><vh>Ahas</vh></v>
<v t="ekr.20060103133740"><vh>Prototypes</vh>
<v t="ekr.20051017140811.1"><vh>@url http://vimdoc.sourceforge.net/htmldoc/usr_03.html</vh></v>
</v>
<v t="ekr.20060103113002"><vh>What I did</vh></v>
<v t="ekr.20060102134206.1"><vh>From leoConfig.py</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060105085031"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060102103625"><vh>createModeCommand</vh></v>
<v t="ekr.20060102103625.1"><vh>doMode</vh></v>
<v t="ekr.20041120105609"><vh>doShortcuts</vh></v>
</v>
<v t="ekr.20060102134206.2"><vh>From leoKeys.py</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060105085031"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>finishCreate (keyHandler) &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20050920085536.63"><vh>keyboardQuit</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051001051355"><vh>Dispatching...</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20050920085536.58"><vh>quickCommand  (ctrl-c) &amp; helpers</vh>
<v t="ekr.20051004102314"><vh>rCommand</vh></v>
<v t="ekr.20050923183943.4"><vh>processKey</vh>
<v t="ekr.20050923183943.6"><vh>processAbbreviation</vh></v>
</v>
</v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060104120602"><vh>matchKeys</vh></v>
<v t="ekr.20060102135349.2"><vh>enterNamedMode &amp;helpers</vh>
<v t="ekr.20060104110233"><vh>generalModeHandler</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp/Helper</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20050921094025"><vh>4.4 To do</vh>
<v t="ekr.20060103102115"><vh>Improve word-export plugin</vh></v>
<v t="ekr.20051217135340.2"><vh>Create find-options panel</vh></v>
<v t="ekr.20051217175058"><vh>Get chapters plugin working</vh></v>
<v t="ekr.20051202094427"><vh>Prototype for resolve cvs conflicts</vh></v>
<v t="ekr.20051027105304"><vh>Next release: a5</vh>
<v t="ekr.20060104083551"><vh>New commands for mouseless Leo (LeoUser)</vh></v>
<v t="ekr.20051207130701"><vh>Fix newly reported problems</vh>
<v t="ekr.20051207125933.3"><vh>Keys not sticking</vh>
<v t="ekr.20051207125933.4"><vh>Post 2</vh></v>
</v>
<v t="ekr.20051208081641"><vh>Fix undo problems</vh>
<v t="ekr.20051208081641.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051208100903"><vh>Install Brian's patch for Import Derived files</vh>
<v t="ekr.20031218072017.1810" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20040930135204"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20051208100903.1"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
</v>
<v t="ekr.20051202102337"><vh>Minibuffer commands notes</vh>
<v t="ekr.20051202102337.1"><vh>abbrevCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102337.2"><vh>bufferCommandsClass Inot ready yet)</vh></v>
<v t="ekr.20051202102337.3"><vh>controlCommandsClass (ok)</vh></v>
<v t="ekr.20051202102337.4"><vh>editCommandsClass</vh></v>
<v t="ekr.20051202102337.6"><vh>editFileCommandsClass</vh></v>
<v t="ekr.20051202102752.1"><vh>keyHandlerCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102752.2" a="M"><vh>killBufferCommandsClass</vh></v>
<v t="ekr.20051202102752.3" a="M"><vh>macroCommandsClass</vh></v>
<v t="ekr.20051202102752.4" a="M"><vh>queryReplaceCommandsClass</vh></v>
<v t="ekr.20051202102752.5"><vh>rectangleCommandsClass (ok)</vh></v>
<v t="ekr.20051202102752.6"><vh>registerCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.7"><vh>searchCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.8"><vh>spellCommandsClass (ok)</vh></v>
</v>
<v t="ekr.20051207093612.1"><vh>Add commands to extend selections</vh>
<v t="ekr.20051210111021"><vh>Report 1</vh></v>
<v t="ekr.20051207125933.1"><vh>Report 2</vh></v>
</v>
<v t="ekr.20051017111216"><vh>Fix bugs in commands</vh>
<v t="ekr.20051120181015"><vh>To do</vh></v>
<v t="ekr.20051120180644"><vh>What I did</vh></v>
<v t="ekr.20051120180644.1"><vh>Rewritten/revised commands</vh>
<v t="ekr.20031218072017.1830"><vh>indentBody</vh></v>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20050920084036.75"><vh>backToIndentation</vh></v>
<v t="ekr.20050920084036.78"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20051120180644.2"><vh>Reference</vh>
<v t="ekr.20051106040126"><vh>c.executeMinibufferCommand</vh></v>
<v t="ekr.20031218072017.1838"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20031218072017.2884"><vh>Edit Body submenu</vh>
<v t="ekr.20031218072017.1704"><vh>convertAllBlanks</vh></v>
<v t="ekr.20031218072017.1705"><vh>convertAllTabs</vh></v>
<v t="ekr.20031218072017.1821"><vh>convertBlanks</vh></v>
<v t="ekr.20031218072017.1822"><vh>convertTabs</vh></v>
<v t="ekr.20031218072017.1823"><vh>createLastChildNode</vh></v>
<v t="ekr.20031218072017.1824"><vh>dedentBody</vh></v>
<v t="ekr.20031218072017.1706"><vh>extract</vh></v>
<v t="ekr.20031218072017.1708"><vh>extractSection</vh>
<v t="ekr.20031218072017.1709"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1710"><vh>extractSectionNames</vh>
<v t="ekr.20031218072017.1711"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1825"><vh>findBoundParagraph</vh>
<v t="ekr.20031218072017.1826"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1827"><vh>findMatchingBracket</vh>
<v t="ekr.20031218072017.1828"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20031218072017.1829"><vh>getBodyLines</vh></v>
<v t="ekr.20031218072017.1830"><vh>indentBody</vh></v>
<v t="ekr.20031218072017.1831"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20031218072017.1832"><vh>getTime</vh></v>
</v>
<v t="ekr.20050312114529"><vh>insert/removeComments</vh>
<v t="ekr.20050312114529.1"><vh>addComments</vh></v>
<v t="ekr.20050312114529.2"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20031218072017.1833"><vh>reformatParagraph</vh>
<v t="ekr.20031218072017.1834"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1835"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1836"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1837"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1838"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20051121060445"><vh>Indent help</vh></v>
</v>
<v t="ekr.20050920084036.219"><vh>findNextMatch</vh>
<v t="ekr.20051005155611"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20051005160923"><vh>&lt;&lt; handle plain search &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051123055200"><vh>*** Allow multiple bindings to the same command</vh>
<v t="ekr.20051220070321.1"><vh>To do</vh></v>
<v t="ekr.20051220063601"><vh>From leoConfig.py</vh>
<v t="ekr.20041119204700"><vh> ctor (parserBaseClass)</vh></v>
<v t="ekr.20041120112043"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20041120113848"><vh>doShortcut</vh></v>
<v t="ekr.20041120105609"><vh>doShortcuts</vh></v>
<v t="ekr.20041227071423"><vh>setShortcut (ParserBaseClass)</vh></v>
<v t="ekr.20041117062717.14"><vh>getShortcut (config)</vh></v>
</v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.11"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20050920085536.12"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20051023182326"><vh>copyBindingsToWidget &amp; textBindingsRedirectionCallback</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20050923174229.1"><vh>makeHardBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20031218072017.2098"><vh>canonicalizeShortcut</vh>
<v t="ekr.20031218072017.2102"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2099"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20031218072017.2100"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2101"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2103"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20051220064128"><vh>Calls to getShortcut</vh>
<v t="ekr.20051023181449" a="M"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051025120920" a="M"><vh>createBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20051103094005"><vh>Fix bugs</vh>
<v t="ekr.20051104152338"><vh>Fix bug in Remove Sentinels command</vh>
<v t="ekr.20051104152338.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051014152256"><vh>Fix long-standing bug in import code</vh>
<v t="ekr.20040930075711"><vh>Handle underindented lines</vh></v>
<v t="ekr.20040722132104"><vh>Write script to report underindented lines</vh></v>
</v>
<v t="ekr.20051112080017"><vh>Problem removing script buttons on the mac</vh></v>
<v t="ekr.20051207130701"><vh>Fix newly reported problems</vh>
<v t="ekr.20051207125933.3"><vh>Keys not sticking</vh>
<v t="ekr.20051207125933.4"><vh>Post 2</vh></v>
</v>
<v t="ekr.20051208081641"><vh>Fix undo problems</vh>
<v t="ekr.20051208081641.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051208100903"><vh>Install Brian's patch for Import Derived files</vh>
<v t="ekr.20031218072017.1810" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20040930135204"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20051208100903.1"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20051210111121"><vh>Before b1</vh>
<v t="ekr.20051126122638"><vh>Autocompletion tab</vh>
<v t="ekr.20051205093049"><vh>Use dir for auto-complete ?</vh></v>
<v t="ekr.20051025144611"><vh>Reference (Do not delete)</vh>
<v t="ekr.20051025144611.1"><vh>Configuration</vh>
<v t="ekr.20051025144611.2"><vh>autocompleter.ini</vh></v>
<v t="ekr.20051025144611.3"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20051025144611.4"><vh>autocompleter.py</vh>
<v t="ekr.20051025144611.5"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20051025144611.6"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051025144611.7"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20051025144611.8"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="ekr.20051025144611.10"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="ekr.20051025144611.11"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20051025144611.12"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="ekr.20051025144611.13"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20051025144611.14"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20051025170832"><vh>Initialization</vh>
<v t="ekr.20051025144611.15"><vh>init</vh></v>
<v t="ekr.20051025170832.1"><vh>Config stuff</vh>
<v t="ekr.20051025144611.24"><vh>has read config file meths</vh></v>
<v t="ekr.20051025144611.25"><vh>readConfigFile</vh></v>
<v t="ekr.20051025144611.26"><vh>createConfigFile</vh></v>
<v t="ekr.20051025144611.27"><vh>readLanguageFiles</vh></v>
<v t="ekr.20051025144611.28"><vh>readOutline</vh></v>
</v>
<v t="ekr.20051025144611.16"><vh>watcher</vh></v>
<v t="ekr.20051025144611.23"><vh>initialScan</vh></v>
</v>
<v t="ekr.20051025144611.17"><vh>scanText</vh></v>
<v t="ekr.20051025144611.18"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20051025144611.19"><vh>scanForCallTip</vh></v>
<v t="ekr.20051025144611.20"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20051025144611.21"><vh>_getCleanString</vh></v>
<v t="ekr.20051025144611.22"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20051025144611.29"><vh>reducer</vh></v>
<v t="ekr.20051025144611.30"><vh>unbind</vh></v>
<v t="ekr.20051025144611.31"><vh>moveSelItem</vh></v>
<v t="ekr.20051025144611.32"><vh>processKeyStroke</vh></v>
<v t="ekr.20051025144611.33"><vh>testForUnbind</vh></v>
<v t="ekr.20051025144611.34"><vh>processAutoBox</vh></v>
<v t="ekr.20051025144611.35"><vh>add_item</vh></v>
<v t="ekr.20051025144611.36"><vh>add_bindings</vh></v>
<v t="ekr.20051025144611.37"><vh>configureAutoBox</vh></v>
<v t="ekr.20051025144611.38"><vh>calculatePlace</vh></v>
<v t="ekr.20051025144611.39"><vh>setLanguage</vh></v>
<v t="ekr.20051025144611.40"><vh>newCreateControl</vh></v>
<v t="ekr.20051025144611.41"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20051025144611.42"><vh>onOpenWindow</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4059"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20031218072017.844"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20031218072017.845"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20031218072017.846"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20031218072017.4060"><vh>Dialog</vh>
<v t="ekr.20031218072017.4061"><vh>get_window_info</vh></v>
<v t="ekr.20031218072017.4062"><vh>center_dialog</vh></v>
<v t="ekr.20031218072017.4063"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20031218072017.4064"><vh>Focus</vh>
<v t="ekr.20031218072017.4065"><vh>get_focus</vh></v>
<v t="ekr.20031218072017.2373" a="M"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20050210082320"><vh>widget_wants_focus (tk.gui)</vh></v>
</v>
<v t="ekr.20031218072017.4066"><vh>Font</vh>
<v t="ekr.20031218072017.2187"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20031218072017.4067"><vh>Icons</vh>
<v t="ekr.20031218072017.4068"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20031218072017.4069"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4070"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4071"><vh>Idle Time</vh>
<v t="ekr.20031218072017.4072"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20031218072017.4073"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20031218072017.4074"><vh>Indices (Tk)</vh>
<v t="ekr.20031218072017.4075"><vh>firstIndex</vh></v>
<v t="ekr.20031218072017.4076"><vh>lastIndex</vh></v>
<v t="ekr.20031218072017.4077"><vh>moveIndexBackward</vh></v>
<v t="ekr.20031218072017.4078"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20031218072017.4079"><vh>compareIndices</vh></v>
<v t="ekr.20031218072017.4080"><vh>getindex</vh></v>
</v>
<v t="ekr.20031218072017.4081"><vh>Insert Point</vh>
<v t="ekr.20031218072017.4082"><vh>getInsertPoint</vh></v>
<v t="ekr.20031218072017.4083"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20031218072017.4084"><vh>Selection</vh>
<v t="ekr.20031218072017.4085"><vh>getSelectionRange (to be deleted?)</vh></v>
<v t="ekr.20051126125950"><vh>getSelectedText</vh></v>
<v t="ekr.20031218072017.4086"><vh>getTextSelection</vh></v>
<v t="ekr.20051126171929"><vh>hasSelection</vh></v>
<v t="ekr.20031218072017.4088"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20031218072017.4089"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20031218072017.4090"><vh>Text</vh>
<v t="ekr.20031218072017.4091"><vh>getAllText</vh></v>
<v t="ekr.20031218072017.4092"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20031218072017.4093"><vh>getCharAtIndex</vh></v>
<v t="ekr.20031218072017.4094"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20031218072017.4095"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20031218072017.4096"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20031218072017.4097"><vh>Visibility</vh>
<v t="ekr.20031218072017.4098"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20051220144507"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20051126123249"><vh>class autoCompleterClass (prototype)</vh>
<v t="ekr.20051126123759"><vh> birth</vh>
<v t="ekr.20051126123759.1"><vh> ctor</vh></v>
<v t="ekr.20051126123759.2"><vh> getPublicCommands (autoCommandsClass)</vh></v>
</v>
<v t="ekr.20051127105431" a="M"><vh>abort</vh></v>
<v t="ekr.20051126122952.1"><vh>autoComplete</vh></v>
<v t="ekr.20051126123149" a="M"><vh>computeCompletionList (autoCompleter)</vh></v>
<v t="ekr.20051126131103"><vh>doBackSpace</vh></v>
<v t="ekr.20051126123249.1"><vh>doTabCompletion (autoCompleter)</vh></v>
<v t="ekr.20051127065601" a="M"><vh>extendSelection</vh></v>
<v t="ekr.20051127105102" a="M"><vh>finish</vh></v>
<v t="ekr.20051127070018" a="M"><vh>setSelection</vh></v>
<v t="ekr.20051126124705"><vh>stateHandler (autoCompleter)</vh></v>
</v>
</v>
<v t="ekr.20051028061611.1"><vh>Unify all search commands</vh>
<v t="ekr.20051112075511"><vh>Idea for improving search command code</vh></v>
<v t="ekr.20051023094009"><vh>Search classes (ok, i-search is limited)</vh>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__</vh>
<v t="ekr.20051020120306.12"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449" a="M"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051020120306.13"><vh>createFrame (findTab)</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.19"><vh>find.init</vh>
<v t="ekr.20051020120306.20"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020120306.21"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020120306.22"><vh>find.update_ivars</vh></v>
<v t="ekr.20051023183028"><vh>findButtonCallback</vh></v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.27" a="M"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020120306.28"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20051020120306.1"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020120306.2"><vh>__init__</vh>
<v t="ekr.20051020120306.3"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.4"><vh>bindHotKey</vh></v>
<v t="ekr.20051020120306.5"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051022211617"><vh>find tab...</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>commands...</vh></v>
</v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler &amp; helper</vh>
<v t="ekr.20051002120125"><vh>&lt;&lt; do a non-incremental search &gt;&gt;</vh></v>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
</v>
<v t="ekr.20050920084036.267"><vh>non-incremental search...</vh>
<v t="ekr.20050920084036.269"><vh>seachForward/Backward &amp; helper</vh>
<v t="ekr.20050920084036.268"><vh>plainSearchHelper</vh></v>
</v>
<v t="ekr.20051002111614"><vh>wordSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.272"><vh>wordSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.274"><vh>reSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.275"><vh>reSearchHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051012053017.4"><vh>Search improvements</vh></v>
</v>
<v t="ekr.20051202094427"><vh>Prototype for resolve cvs conflicts</vh></v>
<v t="ekr.20051217135340.2"><vh>Create find-options panel</vh></v>
<v t="ekr.20051202095626"><vh>Add help-command</vh></v>
<v t="ekr.20051012054228"><vh>Vim mode (k.vimMode)</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
<v t="ekr.20051202100658"><vh>Filename completion</vh></v>
<v t="ekr.20050928144501.1"><vh>Mouseless Leo</vh>
<v t="ekr.20050707085637"><vh>Suggestions from an emacs user</vh></v>
<v t="ekr.20050712092501.1"><vh>xemacs variables</vh>
<v t="ekr.20050712092501.2"><vh>top, bottom, left, right, horizontal vertical, gutter</vh></v>
<v t="ekr.20050712092501.5"><vh>prev...</vh>
<v t="ekr.20050712092501.6"><vh>*</vh></v>
<v t="ekr.20050712092501.7"><vh>:</vh></v>
<v t="ekr.20050712092501.8"><vh>abbrev-</vh></v>
<v t="ekr.20050712092501.9"><vh>after-</vh></v>
<v t="ekr.20050712092501.10"><vh>auto-</vh></v>
<v t="ekr.20050712092501.11"><vh>backup-</vh></v>
<v t="ekr.20050712092501.12"><vh>bbdb</vh></v>
<v t="ekr.20050712092501.13"><vh>before-</vh></v>
<v t="ekr.20050712092501.14"><vh>browse-url-</vh></v>
<v t="ekr.20050712092501.15"><vh>buffer</vh></v>
<v t="ekr.20050712092501.16"><vh>buffers-</vh></v>
<v t="ekr.20050712092501.17"><vh>cl-</vh></v>
<v t="ekr.20050712092501.18"><vh>command-</vh></v>
<v t="ekr.20050712092501.19"><vh>comment-</vh></v>
<v t="ekr.20050712092501.20"><vh>compilation</vh></v>
<v t="ekr.20050712092501.21"><vh>completion</vh></v>
<v t="ekr.20050712092501.22"><vh>configure</vh></v>
<v t="ekr.20050712092501.23"><vh>dabbrev- and dabbrev--</vh></v>
<v t="ekr.20050712094115"><vh>debug-</vh></v>
<v t="ekr.20050712094115.1"><vh>default-</vh></v>
<v t="ekr.20050712094115.2"><vh>global</vh></v>
<v t="ekr.20050712094115.3"><vh>help</vh></v>
<v t="ekr.20050712092501.24"><vh>isearch-</vh></v>
</v>
<v t="ekr.20050712092501.25"><vh>lisp</vh></v>
<v t="ekr.20050712092501.26"><vh>list-</vh></v>
<v t="ekr.20050712094115.4"><vh>load-</vh></v>
<v t="ekr.20050712092501.27"><vh>mail</vh></v>
<v t="ekr.20050712094115.5"><vh>message-</vh></v>
<v t="ekr.20050712092501.28"><vh>minibuffer-</vh></v>
<v t="ekr.20050712092501.29"><vh>mode-</vh></v>
<v t="ekr.20050712092501.30"><vh>modeline-</vh></v>
<v t="ekr.20050712092501.31"><vh>mouse-</vh></v>
<v t="ekr.20050712092501.32"><vh>mswindows-</vh></v>
<v t="ekr.20050712092501.33"><vh>package- &amp; packages-</vh></v>
<v t="ekr.20050712094115.6"><vh>paths-</vh></v>
<v t="ekr.20050712092501.34"><vh>regexp- &amp; search-</vh></v>
<v t="ekr.20050712092501.35"><vh>toolbar-</vh></v>
<v t="ekr.20050712094115.7"><vh>xwem</vh></v>
</v>
</v>
<v t="ekr.20051220062654"><vh>Open .leo file in new process</vh></v>
</v>
<v t="ekr.20051129095023"><vh>Before 4.4 final</vh>
<v t="ekr.20051121070552"><vh>Add Cmds menu</vh></v>
<v t="ekr.20051202095626"><vh>Add help-command</vh></v>
<v t="ekr.20051012054228"><vh>Vim mode (k.vimMode)</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
<v t="ekr.20051202100658"><vh>Filename completion</vh></v>
<v t="ekr.20050925105522"><vh>Big</vh>
<v t="ekr.20050928144501.1"><vh>Mouseless Leo</vh>
<v t="ekr.20050707085637"><vh>Suggestions from an emacs user</vh></v>
<v t="ekr.20050712092501.1"><vh>xemacs variables</vh>
<v t="ekr.20050712092501.2"><vh>top, bottom, left, right, horizontal vertical, gutter</vh></v>
<v t="ekr.20050712092501.5"><vh>prev...</vh>
<v t="ekr.20050712092501.6"><vh>*</vh></v>
<v t="ekr.20050712092501.7"><vh>:</vh></v>
<v t="ekr.20050712092501.8"><vh>abbrev-</vh></v>
<v t="ekr.20050712092501.9"><vh>after-</vh></v>
<v t="ekr.20050712092501.10"><vh>auto-</vh></v>
<v t="ekr.20050712092501.11"><vh>backup-</vh></v>
<v t="ekr.20050712092501.12"><vh>bbdb</vh></v>
<v t="ekr.20050712092501.13"><vh>before-</vh></v>
<v t="ekr.20050712092501.14"><vh>browse-url-</vh></v>
<v t="ekr.20050712092501.15"><vh>buffer</vh></v>
<v t="ekr.20050712092501.16"><vh>buffers-</vh></v>
<v t="ekr.20050712092501.17"><vh>cl-</vh></v>
<v t="ekr.20050712092501.18"><vh>command-</vh></v>
<v t="ekr.20050712092501.19"><vh>comment-</vh></v>
<v t="ekr.20050712092501.20"><vh>compilation</vh></v>
<v t="ekr.20050712092501.21"><vh>completion</vh></v>
<v t="ekr.20050712092501.22"><vh>configure</vh></v>
<v t="ekr.20050712092501.23"><vh>dabbrev- and dabbrev--</vh></v>
<v t="ekr.20050712094115"><vh>debug-</vh></v>
<v t="ekr.20050712094115.1"><vh>default-</vh></v>
<v t="ekr.20050712094115.2"><vh>global</vh></v>
<v t="ekr.20050712094115.3"><vh>help</vh></v>
<v t="ekr.20050712092501.24"><vh>isearch-</vh></v>
</v>
<v t="ekr.20050712092501.25"><vh>lisp</vh></v>
<v t="ekr.20050712092501.26"><vh>list-</vh></v>
<v t="ekr.20050712094115.4"><vh>load-</vh></v>
<v t="ekr.20050712092501.27"><vh>mail</vh></v>
<v t="ekr.20050712094115.5"><vh>message-</vh></v>
<v t="ekr.20050712092501.28"><vh>minibuffer-</vh></v>
<v t="ekr.20050712092501.29"><vh>mode-</vh></v>
<v t="ekr.20050712092501.30"><vh>modeline-</vh></v>
<v t="ekr.20050712092501.31"><vh>mouse-</vh></v>
<v t="ekr.20050712092501.32"><vh>mswindows-</vh></v>
<v t="ekr.20050712092501.33"><vh>package- &amp; packages-</vh></v>
<v t="ekr.20050712094115.6"><vh>paths-</vh></v>
<v t="ekr.20050712092501.34"><vh>regexp- &amp; search-</vh></v>
<v t="ekr.20050712092501.35"><vh>toolbar-</vh></v>
<v t="ekr.20050712094115.7"><vh>xwem</vh></v>
</v>
</v>
</v>
<v t="ekr.20051012062458.1"><vh>Minor</vh>
<v t="ekr.20051110155735.1"><vh>Improve Spell tab</vh>
<v t="ekr.20051028061546"><vh>Improve spell tab</vh></v>
<v t="ekr.20051025071455" a="M"><vh>Spell classes (ok)</vh>
<v t="ekr.20051025071455.6"><vh>class Aspell</vh>
<v t="ekr.20051025071455.7"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.8"><vh>__init__</vh></v>
</v>
<v t="ekr.20051025071455.10"><vh>processWord</vh></v>
<v t="ekr.20051025071455.11"><vh>updateDictionary</vh></v>
</v>
<v t="ekr.20051025071455.1"><vh>class spellCommandsClass</vh>
<v t="ekr.20051025080056"><vh>ctor</vh></v>
<v t="ekr.20051025080420"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051025080633"><vh>openSpellTab</vh></v>
<v t="ekr.20051025080420.1"><vh>commands...</vh></v>
</v>
<v t="ekr.20051025071455.18"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20051025071455.19"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.20"><vh>spellTab.__init__</vh></v>
<v t="ekr.20051025094004"><vh>init_aspell</vh></v>
<v t="ekr.20051025071455.22"><vh>createSpellTab</vh>
<v t="ekr.20051113090322"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051025071455.23"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20051025071455.24"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025120920" a="M"><vh>createBindings</vh></v>
<v t="ekr.20051025071455.16"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20051025071455.29"><vh>Buttons</vh>
<v t="ekr.20051025071455.30"><vh>onAddButton</vh></v>
<v t="ekr.20051025071455.31"><vh>onIgnoreButton</vh></v>
<v t="ekr.20051025071455.32"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20051025071455.33"><vh>onFindButton</vh></v>
<v t="ekr.20051025071455.34"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20051025071455.36"><vh>Commands</vh>
<v t="ekr.20051025071455.37"><vh>add</vh></v>
<v t="ekr.20051025071455.38"><vh>change</vh></v>
<v t="ekr.20051025071455.40"><vh>find</vh></v>
<v t="ekr.20051025121408"><vh>hide</vh></v>
<v t="ekr.20051025071455.41"><vh>ignore</vh></v>
</v>
<v t="ekr.20051025071455.42"><vh>Helpers</vh>
<v t="ekr.20051025071455.43"><vh>bringToFront</vh></v>
<v t="ekr.20051025071455.44"><vh>fillbox</vh></v>
<v t="ekr.20051025071455.45"><vh>findNextMisspelledWord</vh>
<v t="ekr.20051025071455.46"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025071455.47"><vh>findNextWord</vh></v>
<v t="ekr.20051025071455.48"><vh>getSuggestion</vh></v>
<v t="ekr.20051025071455.49"><vh>onMap</vh></v>
<v t="ekr.20051025071455.50"><vh>onSelectListBox</vh></v>
<v t="ekr.20051025071455.51"><vh>update</vh></v>
<v t="ekr.20051025071455.52"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050713105353"><vh>Add configuration setting to set menu fonts</vh>
<v t="ekr.20050713105353.1"><vh>Email from Martin Moncrieffe &lt;mcm35@cam.ac.uk&gt;</vh></v>
</v>
<v t="ekr.20050512031131"><vh>Use global_log_window_position to specify outline/log ratio?</vh></v>
<v t="ekr.20050916180203"><vh>Make more commands undoable</vh></v>
<v t="ekr.20051016155819"><vh>treat plugins/options.py  differently?</vh></v>
<v t="ekr.20051101161545"><vh>Allow multiple bindings for the same minibuffer command</vh></v>
</v>
</v>
<v t="ekr.20051023192433"><vh>Maybe...</vh>
<v t="ekr.20051104051733"><vh>Use focus-in binding?</vh></v>
<v t="ekr.20051103091115.1"><vh>Report</vh></v>
<v t="ekr.20051207130144"><vh>Investigate Tk DnD</vh>
<v t="ekr.20051207130144.1"><vh>@url http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html</vh></v>
</v>
<v t="ekr.20060102092148.2"><vh>auto-install docutils?</vh></v>
<v t="ekr.20060103101524"><vh>Improve command-line handling</vh></v>
</v>
<v t="ekr.20051219151756"><vh>Next</vh>
<v t="ekr.20051217175058"><vh>Get chapters plugin working</vh></v>
<v t="ekr.20051221101851"><vh>Add commands to simulate clicks</vh>
<v t="ekr.20051221101851.1"><vh>Request</vh></v>
</v>
<v t="ekr.20051017111216"><vh>Fix bugs in commands</vh>
<v t="ekr.20051120181015"><vh>To do</vh></v>
<v t="ekr.20051120180644"><vh>What I did</vh></v>
<v t="ekr.20051120180644.1"><vh>Rewritten/revised commands</vh>
<v t="ekr.20031218072017.1830"><vh>indentBody</vh></v>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20050920084036.75"><vh>backToIndentation</vh></v>
<v t="ekr.20050920084036.78"><vh>indentRelative</vh></v>
</v>
<v t="ekr.20051120180644.2"><vh>Reference</vh>
<v t="ekr.20051106040126"><vh>c.executeMinibufferCommand</vh></v>
<v t="ekr.20031218072017.1838"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
<v t="ekr.20031218072017.2884"><vh>Edit Body submenu</vh>
<v t="ekr.20031218072017.1704"><vh>convertAllBlanks</vh></v>
<v t="ekr.20031218072017.1705"><vh>convertAllTabs</vh></v>
<v t="ekr.20031218072017.1821"><vh>convertBlanks</vh></v>
<v t="ekr.20031218072017.1822"><vh>convertTabs</vh></v>
<v t="ekr.20031218072017.1823"><vh>createLastChildNode</vh></v>
<v t="ekr.20031218072017.1824"><vh>dedentBody</vh></v>
<v t="ekr.20031218072017.1706"><vh>extract</vh></v>
<v t="ekr.20031218072017.1708"><vh>extractSection</vh>
<v t="ekr.20031218072017.1709"><vh>&lt;&lt; Set headline for extractSection &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1710"><vh>extractSectionNames</vh>
<v t="ekr.20031218072017.1711"><vh>&lt;&lt; Find the next section name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1825"><vh>findBoundParagraph</vh>
<v t="ekr.20031218072017.1826"><vh>&lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1827"><vh>findMatchingBracket</vh>
<v t="ekr.20031218072017.1828"><vh>findMatchingBracket</vh></v>
</v>
<v t="ekr.20031218072017.1829"><vh>getBodyLines</vh></v>
<v t="ekr.20031218072017.1830"><vh>indentBody</vh></v>
<v t="ekr.20031218072017.1831"><vh>insertBodyTime &amp; allies</vh>
<v t="ekr.20031218072017.1832"><vh>getTime</vh></v>
</v>
<v t="ekr.20050312114529"><vh>insert/removeComments</vh>
<v t="ekr.20050312114529.1"><vh>addComments</vh></v>
<v t="ekr.20050312114529.2"><vh>deleteComments</vh></v>
</v>
<v t="ekr.20031218072017.1833"><vh>reformatParagraph</vh>
<v t="ekr.20031218072017.1834"><vh>&lt;&lt; compute vars for reformatParagraph &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1835"><vh>&lt;&lt; compute the leading whitespace &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1836"><vh>&lt;&lt; compute the result of wrapping all lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1837"><vh>&lt;&lt; update the body, selection &amp; undo state &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1838"><vh>updateBodyPane (handles changeNodeContents)</vh></v>
</v>
<v t="ekr.20051121060445"><vh>Indent help</vh></v>
</v>
<v t="ekr.20050920084036.219"><vh>findNextMatch</vh>
<v t="ekr.20051005155611"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20051005160923"><vh>&lt;&lt; handle plain search &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051121070552"><vh>Add Cmds menu</vh></v>
<v t="ekr.20060102092148"><vh>put optparse.py in leo/extensions</vh></v>
</v>
<v t="ekr.20051103094005"><vh>Fix bugs</vh>
<v t="ekr.20051104152338"><vh>Fix bug in Remove Sentinels command</vh>
<v t="ekr.20051104152338.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051014152256"><vh>Fix long-standing bug in import code</vh>
<v t="ekr.20040930075711"><vh>Handle underindented lines</vh></v>
<v t="ekr.20040722132104"><vh>Write script to report underindented lines</vh></v>
</v>
<v t="ekr.20051112080017"><vh>Problem removing script buttons on the mac</vh></v>
<v t="ekr.20051207130701"><vh>Fix newly reported problems</vh>
<v t="ekr.20051207125933.3"><vh>Keys not sticking</vh>
<v t="ekr.20051207125933.4"><vh>Post 2</vh></v>
</v>
<v t="ekr.20051208081641"><vh>Fix undo problems</vh>
<v t="ekr.20051208081641.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051208100903"><vh>Install Brian's patch for Import Derived files</vh>
<v t="ekr.20031218072017.1810" a="M"><vh>importDerivedFiles</vh>
<v t="ekr.20040930135204"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20051208100903.1"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051210111121.1" a="M"><vh>Other</vh>
<v t="ekr.20060104083736"><vh>Improve how headline widtth gets computed</vh></v>
<v t="ekr.20050713105353"><vh>Add configuration setting to set menu fonts</vh>
<v t="ekr.20050713105353.1"><vh>Email from Martin Moncrieffe &lt;mcm35@cam.ac.uk&gt;</vh></v>
</v>
<v t="ekr.20051110155735.1"><vh>Improve Spell tab</vh>
<v t="ekr.20051028061546"><vh>Improve spell tab</vh></v>
<v t="ekr.20051025071455" a="M"><vh>Spell classes (ok)</vh>
<v t="ekr.20051025071455.6"><vh>class Aspell</vh>
<v t="ekr.20051025071455.7"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.8"><vh>__init__</vh></v>
</v>
<v t="ekr.20051025071455.10"><vh>processWord</vh></v>
<v t="ekr.20051025071455.11"><vh>updateDictionary</vh></v>
</v>
<v t="ekr.20051025071455.1"><vh>class spellCommandsClass</vh>
<v t="ekr.20051025080056"><vh>ctor</vh></v>
<v t="ekr.20051025080420"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051025080633"><vh>openSpellTab</vh></v>
<v t="ekr.20051025080420.1"><vh>commands...</vh></v>
</v>
<v t="ekr.20051025071455.18"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20051025071455.19"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.20"><vh>spellTab.__init__</vh></v>
<v t="ekr.20051025094004"><vh>init_aspell</vh></v>
<v t="ekr.20051025071455.22"><vh>createSpellTab</vh>
<v t="ekr.20051113090322"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051025071455.23"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20051025071455.24"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025120920" a="M"><vh>createBindings</vh></v>
<v t="ekr.20051025071455.16"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20051025071455.29"><vh>Buttons</vh>
<v t="ekr.20051025071455.30"><vh>onAddButton</vh></v>
<v t="ekr.20051025071455.31"><vh>onIgnoreButton</vh></v>
<v t="ekr.20051025071455.32"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20051025071455.33"><vh>onFindButton</vh></v>
<v t="ekr.20051025071455.34"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20051025071455.36"><vh>Commands</vh>
<v t="ekr.20051025071455.37"><vh>add</vh></v>
<v t="ekr.20051025071455.38"><vh>change</vh></v>
<v t="ekr.20051025071455.40"><vh>find</vh></v>
<v t="ekr.20051025121408"><vh>hide</vh></v>
<v t="ekr.20051025071455.41"><vh>ignore</vh></v>
</v>
<v t="ekr.20051025071455.42"><vh>Helpers</vh>
<v t="ekr.20051025071455.43"><vh>bringToFront</vh></v>
<v t="ekr.20051025071455.44"><vh>fillbox</vh></v>
<v t="ekr.20051025071455.45"><vh>findNextMisspelledWord</vh>
<v t="ekr.20051025071455.46"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025071455.47"><vh>findNextWord</vh></v>
<v t="ekr.20051025071455.48"><vh>getSuggestion</vh></v>
<v t="ekr.20051025071455.49"><vh>onMap</vh></v>
<v t="ekr.20051025071455.50"><vh>onSelectListBox</vh></v>
<v t="ekr.20051025071455.51"><vh>update</vh></v>
<v t="ekr.20051025071455.52"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060102092148.1"><vh>--safe option</vh></v>
</v>
<v t="ekr.20051220063217"><vh>Docs</vh>
<v t="ekr.20060103100430"><vh>Documentation for installing aspell plugin</vh></v>
<v t="ekr.20051202102337"><vh>Minibuffer commands notes</vh>
<v t="ekr.20051202102337.1"><vh>abbrevCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102337.2"><vh>bufferCommandsClass Inot ready yet)</vh></v>
<v t="ekr.20051202102337.3"><vh>controlCommandsClass (ok)</vh></v>
<v t="ekr.20051202102337.4"><vh>editCommandsClass</vh></v>
<v t="ekr.20051202102337.6"><vh>editFileCommandsClass</vh></v>
<v t="ekr.20051202102752.1"><vh>keyHandlerCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102752.2" a="M"><vh>killBufferCommandsClass</vh></v>
<v t="ekr.20051202102752.3" a="M"><vh>macroCommandsClass</vh></v>
<v t="ekr.20051202102752.4" a="M"><vh>queryReplaceCommandsClass</vh></v>
<v t="ekr.20051202102752.5"><vh>rectangleCommandsClass (ok)</vh></v>
<v t="ekr.20051202102752.6"><vh>registerCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.7"><vh>searchCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.8"><vh>spellCommandsClass (ok)</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1" a="M"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"
marks="ekr.20031218072017.2619,"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20031218072017.2817,ekr.20040629121554.1,ekr.20040629121554.2,ekr.20040711135244.11,ekr.20031218072017.2950,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"
marks="ekr.20041119203941.2,ekr.20041119204700.1,"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20051127105431,ekr.20051126123149,ekr.20051127065601,ekr.20051127105102,ekr.20051127070018,ekr.20050920084036.39,ekr.20050920084036.145,ekr.20051019201809.6,ekr.20051125080855,ekr.20051026092433.1,ekr.20051218122116,ekr.20051218121447,ekr.20051218171457,ekr.20051213094517,ekr.20050920084036.137,ekr.20051218133207.1,ekr.20051218133207,ekr.20050920084036.136,ekr.20051218174113,ekr.20050920084036.189,ekr.20051023181449,ekr.20051020120306.27,ekr.20051025071455,ekr.20051025120920,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"
marks="ekr.20031218072017.2052,ekr.20050503112513.7,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"
marks="ekr.20031218072017.1810,"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"
marks="ekr.20051006092617.1,ekr.20050920085536.62,"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"
marks="ekr.20051104075904.12,"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"
marks="ekr.20031218072017.2410,"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"
marks="ekr.20050120092028,ekr.20051024173701,ekr.20051018102027,ekr.20051018061932.1,ekr.20051016101724.1,"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"
marks="ekr.20031218072017.2373,"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"
marks="ekr.20040803072955.128,"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
<v t="ekr.20051014161015" a="E"><vh>Full input modes</vh>
<v t="ekr.20060103104509" a="TV"><vh>To do</vh></v>
<v t="ekr.20060104154253"><vh>Ahas</vh></v>
<v t="ekr.20060103133740"><vh>Prototypes</vh>
<v t="ekr.20051017140811.1"><vh>@url http://vimdoc.sourceforge.net/htmldoc/usr_03.html</vh></v>
</v>
<v t="ekr.20060103113002"><vh>What I did</vh></v>
<v t="ekr.20060102134206.1"><vh>From leoConfig.py</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060105085031"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060102103625"><vh>createModeCommand</vh></v>
<v t="ekr.20060102103625.1"><vh>doMode</vh></v>
<v t="ekr.20041120105609"><vh>doShortcuts</vh></v>
</v>
<v t="ekr.20060102134206.2"><vh>From leoKeys.py</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1" a="M"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh>
<v t="ekr.20060105085031"><vh>&lt;&lt; set self.unboundKeyAction &gt;&gt;</vh></v>
</v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>finishCreate (keyHandler) &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20050920085536.63"><vh>keyboardQuit</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051001051355"><vh>Dispatching...</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20050920085536.58"><vh>quickCommand  (ctrl-c) &amp; helpers</vh>
<v t="ekr.20051004102314"><vh>rCommand</vh></v>
<v t="ekr.20050923183943.4"><vh>processKey</vh>
<v t="ekr.20050923183943.6"><vh>processAbbreviation</vh></v>
</v>
</v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060104120602"><vh>matchKeys</vh></v>
<v t="ekr.20060102135349.2"><vh>enterNamedMode &amp;helpers</vh>
<v t="ekr.20060104110233"><vh>generalModeHandler</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp/Helper</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040423082910">if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)

# New in 4.4b1: Restore the focus to a standard place.
frame = self.c.frame
focus_widget = g.app.gui.get_focus(frame)
name = g.app.gui.widget_name(focus_widget)
for kind in ('body','head','canvas'):
    if name.startswith(kind): break
else:
    focus_widget = frame.body.bodyCtrl

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)
frame.widgetWantsFocus(focus_widget)
</t>
<t tx="EKR.20040423082910.1">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040614071102.1">def getScript (c,p,useSelectedText=True,forcePythonSentinels=True):
    
    '''Return the expansion of the selected text of node p.
    Return the expansion of all of node p's body text if there
    is p is not the current node or if there is no text selection.'''

    at = c.atFileCommands
    if not p:
        p = c.currentPosition()
    try:
        if g.app.batchMode:
            s = p.bodyString()
        elif p == c.currentPosition():
            if useSelectedText and c.frame.body.hasTextSelection():
                s = c.frame.body.getSelectedText()
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
        # Remove extra leading whitespace so the user may execute indented code.
        s = g.removeExtraLws(s,c.tab_width)
        if s.strip():
            g.app.scriptDict["script1"]=s
            script = at.writeFromString(p.copy(),s,
                forcePythonSentinels=forcePythonSentinels)
            script = script.replace("\r\n","\n") # Use brute force.
            g.app.scriptDict["script2"]=script
        else: script = ''
    except Exception:
        s = "unexpected exception in g.getScript"
        g.es_print(s)
        g.es_exception()
        script = ''

    return script</t>
<t tx="ekr.20031218072017.840"></t>
<t tx="ekr.20031218072017.844">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20031218072017.845">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20031218072017.846">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20031218072017.1329"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    # g.trace(removeTrailing,repr(ch),repr(newText))
    c.undoer.setUndoTypingParams(p,undoType,
        oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
</t>
<t tx="ekr.20031218072017.1473"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;</t>
<t tx="ekr.20031218072017.1704">def convertAllBlanks (self):
    
    c = self ; u = c.undoer ; undoType = 'Convert All Blanks'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    d = g.scanDirectives(c)
    tabWidth  = d.get("tabwidth")
    c.beginUpdate()
    try: # In update...
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            # g.trace(p.headString(),tabWidth)
            innerUndoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = c.convertBlanks()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                changed = False ; result = []
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,abs(tabWidth)) + line[i:] # use positive width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,innerUndoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("blanks converted to tabs in %d nodes" % count) # Must come before c.endUpdate().
    finally:
        c.endUpdate(count &gt; 0)</t>
<t tx="ekr.20031218072017.1705">def convertAllTabs (self):

    c = self ; u = c.undoer ; undoType = 'Convert All Tabs'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    c.beginUpdate()
    try: # In update:
        count = 0 ; dirtyVnodeList = []
        u.beforeChangeGroup(current,undoType)
        for p in current.self_and_subtree_iter():
            undoData = u.beforeChangeNodeContents(p)
            if p == current:
                changed,dirtyVnodeList2 = self.convertTabs()
                if changed:
                    count += 1
                    dirtyVnodeList.extend(dirtyVnodeList2)
            else:
                result = [] ; changed = False
                text = p.t.bodyString
                assert(g.isUnicode(text))
                lines = string.split(text, '\n')
                for line in lines:
                    i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
                    s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
                    if s != line: changed = True
                    result.append(s)
                if changed:
                    count += 1
                    dirtyVnodeList2 = p.setDirty()
                    dirtyVnodeList.extend(dirtyVnodeList2)
                    result = string.join(result,'\n')
                    p.setTnodeText(result)
                    u.afterChangeNodeContents(p,undoType,undoData)
        u.afterChangeGroup(current,undoType,dirtyVnodeList=dirtyVnodeList)
        g.es("tabs converted to blanks in %d nodes" % count)
    finally:
        c.endUpdate(count &gt; 0)</t>
<t tx="ekr.20031218072017.1706">def extract(self):

    c = self ; u = c.undoer ; undoType = 'Extract'
    current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return
    headline = lines[0].strip() ; del lines[0]
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return

    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20031218072017.1708">def extractSection(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section'
    current = c.currentPosition()

    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    line1 = '\n' + lines[0]
    headline = lines[0].strip() ; del lines[0]
    &lt;&lt; Set headline for extractSection &gt;&gt;
    
    if not lines:
        g.es("Nothing follows section name",color="blue")
        return
    
    # Remove leading whitespace from all body lines.
    junk, ws = g.skip_leading_ws_with_indent(lines[0],0,c.tab_width)
    strippedLines = [g.removeLeadingWhitespace(line,ws,c.tab_width)
        for line in lines]
    newBody = string.join(strippedLines,'\n')
    if head: head = head.rstrip()

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            undoData = u.beforeInsertNode(current)
            p = c.createLastChildNode(current,headline,newBody)
            u.afterInsertNode(p,undoType,undoData)
            c.updateBodyPane(head+line1,None,tail,undoType,oldSel,oldYview,setSel=False)
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20031218072017.1709">if len(headline) &lt; 5:
    oops = True
else:
    head1 = headline[0:2] == '&lt;&lt;'
    head2 = headline[0:2] == '@&lt;'
    tail1 = headline[-2:] == '&gt;&gt;'
    tail2 = headline[-2:] == '@&gt;'
    oops = not (head1 and tail1) and not (head2 and tail2)

if oops:
    g.es("Selected text should start with a section name",color="blue")
    return</t>
<t tx="ekr.20031218072017.1710">def extractSectionNames(self):

    c = self ; u = c.undoer ; undoType = 'Extract Section Names'
    body = c.frame.body ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    if not lines: return

    c.beginUpdate()
    try: # In update...
        u.beforeChangeGroup(current,undoType)
        if 1: # In group...
            found = False
            for s in lines:
                &lt;&lt; Find the next section name &gt;&gt;
                if name:
                    undoData = u.beforeInsertNode(current)
                    p = self.createLastChildNode(current,name,None)
                    u.afterInsertNode(p,undoType,undoData)
                    found = True
            c.selectPosition(current)
            c.validateOutline()
            if not found:
                g.es("Selected text should contain one or more section names",color="blue")
        u.afterChangeGroup(current,undoType)
    finally:
        c.endUpdate()

    # Restore the selection.
    body.setTextSelection(oldSel)
    body.setFocus()</t>
<t tx="ekr.20031218072017.1711">head1 = string.find(s,"&lt;&lt;")
if head1 &gt; -1:
    head2 = string.find(s,"&gt;&gt;",head1)
else:
    head1 = string.find(s,"@&lt;")
    if head1 &gt; -1:
        head2 = string.find(s,"@&gt;",head1)
        
if head1 == -1 or head2 == -1 or head1 &gt; head2:
    name = None
else:
    name = s[head1:head2+2]</t>
<t tx="ekr.20031218072017.1723">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        &lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)</t>
<t tx="ekr.20031218072017.1725"># First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunchList = c.config.getShortcut(commandName)
bunch = bunchList and bunchList[0]
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    &lt;&lt; compute emacs_name &gt;&gt;
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunchList = c.config.getShortcut(emacs_name)
        bunch = bunchList and bunchList[0]
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20031218072017.1728">if rawKey:
    amp_index = rawKey.find("&amp;")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&amp;")</t>
<t tx="ekr.20031218072017.1810">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20031218072017.1821">def convertBlanks (self):

    c = self ; undoType = 'Convert Blanks'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = c.getBodyLines(expandSelection=True)
    result = [] ; changed = False

    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        s = g.optimizeLeadingWhitespace(line,abs(tabWidth)) # Use positive width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []

    return changed,dirtyVnodeList</t>
<t tx="ekr.20031218072017.1822">def convertTabs (self):

    c = self ; undoType = 'Convert Tabs'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return False

    head,lines,tail,oldSel,oldYview = self.getBodyLines(expandSelection=True)
    result = [] ; changed = False
    
    # Use the relative @tabwidth, not the global one.
    theDict = g.scanDirectives(c)
    tabWidth  = theDict.get("tabwidth")
    if not tabWidth: return False

    for line in lines:
        i,w = g.skip_leading_ws_with_indent(line,0,tabWidth)
        s = g.computeLeadingWhitespace(w,-abs(tabWidth)) + line[i:] # use negative width.
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        dirtyVnodeList = c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview) # Handles undo
    else:
        dirtyVnodeList = []
        
    return changed,dirtyVnodeList</t>
<t tx="ekr.20031218072017.1823">def createLastChildNode (self,parent,headline,body):
    
    '''A helper function for the three extract commands.'''
    
    c = self
    
    if body and len(body) &gt; 0:
        body = string.rstrip(body)
    if not body or len(body) == 0:
        body = ""

    p = parent.insertAsLastChild()
    p.initHeadString(headline)
    p.setTnodeText(body)
    p.setDirty()
    c.validateOutline()
    return p</t>
<t tx="ekr.20031218072017.1824">def dedentBody (self):
    
    c = self ; undoType = 'Unindent' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    
    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width-abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20031218072017.1825">def findBoundParagraph (self):
    
    c = self
    head,ins,tail = c.frame.body.getInsertLines()

    if not ins or ins.isspace() or ins[0] == '@':
        return None,None,None,None # DTHEIN 18-JAN-2004
        
    head_lines = g.splitLines(head)
    tail_lines = g.splitLines(tail)

    if 0:
        &lt;&lt; trace head_lines, ins, tail_lines &gt;&gt;

    # Scan backwards.
    i = len(head_lines)
    while i &gt; 0:
        i -= 1
        line = head_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            i += 1 ; break

    pre_para_lines = head_lines[:i]
    para_head_lines = head_lines[i:]

    # Scan forwards.
    i = 0
    trailingNL = False # DTHEIN 18-JAN-2004: properly capture terminating NL
    while i &lt; len(tail_lines):
        line = tail_lines[i]
        if len(line) == 0 or line.isspace() or line[0] == '@':
            trailingNL = line.endswith(u'\n') or line.startswith(u'@') # DTHEIN 21-JAN-2004
            break
        i += 1
        
#	para_tail_lines = tail_lines[:i]
    para_tail_lines = tail_lines[:i]
    post_para_lines = tail_lines[i:]
    
    head = g.joinLines(pre_para_lines)
    result = para_head_lines 
    result.extend([ins])
    result.extend(para_tail_lines)
    tail = g.joinLines(post_para_lines)

    # DTHEIN 18-JAN-2004: added trailingNL to return value list
    return head,result,tail,trailingNL # string, list, string, bool</t>
<t tx="ekr.20031218072017.1826">if 0:
    print ; print "head_lines"
    for line in head_lines: print line
    print ; print "ins", ins
    print ; print "tail_lines"
    for line in tail_lines: print line
else:
    g.es("head_lines: ",head_lines)
    g.es("ins: ",ins)
    g.es("tail_lines: ",tail_lines)</t>
<t tx="ekr.20031218072017.1827">def findMatchingBracket (self):
    
    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("Match Brackets")
        return

    brackets = "()[]{}&lt;&gt;"
    ch1 = body.getCharBeforeInsertPoint()
    ch2 = body.getCharAtInsertPoint()

    # Prefer to match the character to the left of the cursor.
    if ch1 in brackets:
        ch = ch1 ; index = body.getBeforeInsertionPoint()
    elif ch2 in brackets:
        ch = ch2 ; index = body.getInsertionPoint()
    else:
        return
    
    index2 = self.findSingleMatchingBracket(ch,index)
    if index2:
        if body.compareIndices(index,"&lt;=",index2):
            adj_index = body.adjustIndex(index2,1)
            body.setTextSelection(index,adj_index)
        else:
            adj_index = body.adjustIndex(index,1)
            body.setTextSelection(index2,adj_index)
        adj_index = body.adjustIndex(index2,1)
        body.setInsertionPoint(adj_index)
        body.makeIndexVisible(adj_index)
    else:
        g.es("unmatched '%s'",ch)</t>
<t tx="ekr.20031218072017.1828"># To do: replace comments with blanks before scanning.
# Test  unmatched())
def findSingleMatchingBracket(self,ch,index):
    
    c = self ; body = c.frame.body
    open_brackets  = "([{&lt;" ; close_brackets = ")]}&gt;"
    brackets = open_brackets + close_brackets
    matching_brackets = close_brackets + open_brackets
    forward = ch in open_brackets
    # Find the character matching the initial bracket.
    for n in xrange(len(brackets)):
        if ch == brackets[n]:
            match_ch = matching_brackets[n]
            break
    level = 0
    while 1:
        if forward and body.compareIndices(index,"&gt;=","end"):
            # g.trace("not found")
            return None
        ch2 = body.getCharAtIndex(index)
        if ch2 == ch:
            level += 1 #; g.trace(level,index)
        if ch2 == match_ch:
            level -= 1 #; g.trace(level,index)
            if level &lt;= 0:
                return index
        if not forward and body.compareIndices(index,"&lt;=","1.0"):
            # g.trace("not found")
            return None
        adj = g.choose(forward,1,-1)
        index = body.adjustIndex(index,adj)
    return 0 # unreachable: keeps pychecker happy.
# Test  (
# ([(x){y}]))
# Test  ((x)(unmatched</t>
<t tx="ekr.20031218072017.1829">def getBodyLines (self,expandSelection=False):

    c = self ; body = c.frame.body
    oldVview = body.getYScrollPosition()
    oldSel   = body.getTextSelection()

    if expandSelection: # 12/3/03
        lines = body.getAllText()
        head = tail = None
    else:
        # Note: lines is the entire line containing the insert point if no selection.
        head,lines,tail = body.getSelectionLines()

    lines = string.split(lines,'\n') # It would be better to use splitLines.

    return head,lines,tail,oldSel,oldVview</t>
<t tx="ekr.20031218072017.1830">def indentBody (self):
    
    '''The indent-region command indents each line of the selected body text,
    or each line of a node if there is no selected text. The @tabwidth directive
    in effect determines amount of indentation. (not yet) A numeric argument
    specifies the column to indent to.'''

    c = self ; undoType = 'Indent Region' ; current = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return

    d = g.scanDirectives(c,current) # Support @tab_width directive properly.
    tab_width = d.get("tabwidth",c.tab_width)
    head,lines,tail,oldSel,oldYview = self.getBodyLines()

    result = [] ; changed = False
    for line in lines:
        i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
        s = g.computeLeadingWhitespace(width+abs(tab_width),tab_width) + line[i:]
        if s != line: changed = True
        result.append(s)

    if changed:
        result = string.join(result,'\n')
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20031218072017.1831">def insertBodyTime (self):
    
    c = self ; undoType = 'Insert Body Time'
    
    if g.app.batchMode:
        c.notValidInBatchMode(undoType)
        return
    
    oldSel = c.frame.body.getTextSelection()
    c.frame.body.deleteTextSelection() # Works if nothing is selected.
    s = self.getTime(body=True)

    c.frame.body.insertAtInsertPoint(s)
    c.frame.body.onBodyChanged(undoType,oldSel=oldSel)</t>
<t tx="ekr.20031218072017.1832">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getString("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt     = c.config.getString("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoConfig.txt.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20031218072017.1833">def reformatParagraph(self):

    """Reformat a text paragraph in a Tk.Text widget

Wraps the concatenated text to present page width setting. Leading tabs are
sized to present tab width setting. First and second line of original text is
used to determine leading whitespace in reformatted text. Hanging indentation
is honored.

Paragraph is bound by start of body, end of body, blank lines, and lines
starting with "@". Paragraph is selected by position of current insertion
cursor."""

    c = self ; body = c.frame.body
    
    if g.app.batchMode:
        c.notValidInBatchMode("xxx")
        return

    if body.hasTextSelection():
        g.es("Text selection inhibits Reformat Paragraph",color="blue")
        return

    &lt;&lt; compute vars for reformatParagraph &gt;&gt;
    if lines:
        &lt;&lt; compute the leading whitespace &gt;&gt;
        &lt;&lt; compute the result of wrapping all lines &gt;&gt;
        &lt;&lt; update the body, selection &amp; undo state &gt;&gt;</t>
<t tx="ekr.20031218072017.1834">theDict = g.scanDirectives(c)
pageWidth = theDict.get("pagewidth")
tabWidth  = theDict.get("tabwidth")

original = body.getAllText()
oldSel   = body.getTextSelection()
oldYview = body.getYScrollPosition()
head,lines,tail,trailingNL = c.findBoundParagraph() # DTHEIN 18-JAN-2004: add trailingNL</t>
<t tx="ekr.20031218072017.1835">indents = [0,0] ; leading_ws = ["",""]

for i in (0,1):
    if i &lt; len(lines):
        # Use the original, non-optimized leading whitespace.
        leading_ws[i] = ws = g.get_leading_ws(lines[i])
        indents[i] = g.computeWidth(ws,tabWidth)
        
indents[1] = max(indents)
if len(lines) == 1:
    leading_ws[1] = leading_ws[0]
</t>
<t tx="ekr.20031218072017.1836"># Remember whether the last line ended with a newline.
lastLine = lines[-1]
if 0: # DTHEIN 18-JAN-2004: removed because findBoundParagraph now gives trailingNL
    trailingNL = lastLine and lastLine[-1] == '\n'

# Remove any trailing newlines for wraplines.
lines = [line[:-1] for line in lines[:-1]]
if lastLine and not trailingNL:
    lastLine = lastLine[:-1]
lines.extend([lastLine])

# Wrap the lines, decreasing the page width by indent.
result = g.wrap_lines(lines,
    pageWidth-indents[1],
    pageWidth-indents[0])

# DTHEIN 	18-JAN-2004
# prefix with the leading whitespace, if any
paddedResult = []
paddedResult.append(leading_ws[0] + result[0])
for line in result[1:]:
    paddedResult.append(leading_ws[1] + line)

# Convert the result to a string.
result = '\n'.join(paddedResult) # DTHEIN 	18-JAN-2004: use paddedResult
if 0: # DTHEIN 18-JAN-2004:  No need to do this.
    if trailingNL:
        result += '\n'
</t>
<t tx="ekr.20031218072017.1837">sel_start, sel_end = body.setSelectionAreas(head,result,tail)

changed = original != head + result + tail
undoType = g.choose(changed,"Reformat Paragraph",None)
body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

# Advance the selection to the next paragraph.
newSel = sel_end, sel_end
body.setTextSelection(newSel)
body.makeIndexVisible(sel_end)

c.recolor()</t>
<t tx="ekr.20031218072017.1838">def updateBodyPane (self,head,middle,tail,undoType,oldSel,oldYview,setSel=True):
    
    c = self ; body = c.frame.body ; p = c.currentPosition()
    
    # g.trace(undoType)

    # Update the text and notify the event handler.
    body.setSelectionAreas(head,middle,tail)

    if setSel and oldSel:
        body.setTextSelection(oldSel)

    # This handles the undo.
    body.onBodyChanged(undoType,oldSel=oldSel,oldYview=oldYview)

    # Update the changed mark and icon.
    c.beginUpdate()
    try: # In update...
        c.setChanged(True)
        if p.isDirty():
            dirtyVnodeList = []
        else:
            dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    # Scroll as necessary.
    if oldYview:
        body.setYScrollPosition(oldYview)
    else:
        body.makeInsertPointVisible()

    body.setFocus()
    c.recolor()
    return dirtyVnodeList</t>
<t tx="ekr.20031218072017.2086">def preferences(self):
    
    '''Handle the preferences command.'''
    
    c = self

    if 1: # New in Leo 4.4a5: just open leoSettings.leo.
        c.openLeoSettings()
    
    elif 1: # Previous.
        # Replace the body pane by the preferences setters.
        leoConfig.settingsController(c,replaceBody=True)

    else: # Old code...
        # Show the Preferences Panel, creating it if necessary.
        frame = c.frame
    
        if not frame.prefsPanel:
            frame.prefsPanel = g.app.gui.createPrefsPanel(c)
            
        frame.prefsPanel.bringToFront()</t>
<t tx="ekr.20031218072017.2098">@ This code "canonicalizes" both the shortcuts that appear in menus and the
arguments to bind, mostly ignoring case and the order in which special keys are
specified.

For example, Ctrl+Shift+a is the same as Shift+Control+A. Each generates
Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print repr(shortcut),repr(bind_shortcut),repr(menu_shortcut)
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20031218072017.2099">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20031218072017.2100"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20031218072017.2101"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9</t>
<t tx="ekr.20031218072017.2102">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20031218072017.2103">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20031218072017.2187">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20031218072017.2290">def toggleAngleBrackets (self):
    
    c = self ; v = c.currentVnode()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Toggle Angle Brackets")
        return
        
    c.endEditing()

    s = v.headString().strip()
    if (s[0:2] == "&lt;&lt;"
        or s[-2:] == "&gt;&gt;"): # Must be on separate line.
        if s[0:2] == "&lt;&lt;": s = s[2:]
        if s[-2:] == "&gt;&gt;": s = s[:-2]
        s = s.strip()
    else:
        s = g.angleBrackets(' ' + s + ' ')
    
    c.frame.tree.editLabel(v)
    w = v.edit_widget()
    if w:
        w.delete("1.0","end")
        w.insert("1.0",s)
        c.frame.tree.onHeadChanged(v,'Toggle Angle Brackets')</t>
<t tx="ekr.20031218072017.2373">def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # I am not happy with this, but it seems preferable to trying to figure out
            # all the places where the code must call update()
            
            # New in 4.4b1: the place to call update is *after* log pane operations.
            w.update() 

        w.focus_set()</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2884"></t>
<t tx="ekr.20031218072017.2949"></t>
<t tx="ekr.20031218072017.2950">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self, flag=True):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20031218072017.2951">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20031218072017.2953">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20031218072017.2954">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20031218072017.2992"># Ends the editing in the outline.

def endEditing(self):

    self.frame.tree.endEditLabel()
</t>
<t tx="ekr.20031218072017.3070"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    gui.replaceSelectionRangeWithText(t,          start,end,self.change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,self.change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    c.frame.widgetWantsFocus(t)

    # No redraws here: they would destroy the headline selection.
    c.beginUpdate()
    try:
	    if self.mark_changes:
	        p.setMarked()
	    if self.in_headline:
	        c.frame.tree.onHeadChanged(p,'Change')
	    else:
	        c.frame.body.onBodyChanged('Change',oldSel=oldSel)
    finally:
        c.endUpdate(False)
        c.frame.tree.drawIcon(p) # redraw only the icon.
     
    return True
</t>
<t tx="ekr.20031218072017.3089"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    if not in_headline:

        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
        c.frame.widgetWantsFocus(t)</t>
<t tx="ekr.20031218072017.3091">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
	    c.selectPosition(p)
    finally:
        c.endUpdate()
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    gui.setInsertPoint(t,insert)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos)
    if self.reverse:
        gui.setInsertPoint(t,pos)
    gui.makeIndexVisible(t,insert)
    c.frame.widgetWantsFocus(t)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3689">def initialRatios (self):
    
    c = self.c

    s = c.config.get("initial_splitter_orientation","string")
    verticalFlag = s == None or (s != "h" and s != "horizontal")

    if verticalFlag:
        r = c.config.getRatio("initial_vertical_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.5
        r2 = c.config.getRatio("initial_vertical_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8
    else:
        r = c.config.getRatio("initial_horizontal_ratio")
        if r == None or r &lt; 0.0 or r &gt; 1.0: r = 0.3
        r2 = c.config.getRatio("initial_horizontal_secondary_ratio")
        if r2 == None or r2 &lt; 0.0 or r2 &gt; 1.0: r2 = 0.8

    # g.trace(r,r2)
    return verticalFlag,r,r2</t>
<t tx="ekr.20031218072017.3757">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3878">def createFrame (self,message):
    
    """Create the frame for a number dialog."""
    
    if g.app.unitTesting: return
    
    f = self.frame
    
    lab = Tk.Label(f,text=message)
    lab.pack(pady=10,side="left")
    
    self.number_entry = t = Tk.Entry(f,width=20)
    t.pack(side="left")
    
    g.app.gui.set_focus(self.c,t)</t>
<t tx="ekr.20031218072017.3975">def OnActivateBody (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        frame = self ; c = frame.c
        c.endEditing() # Required.
        g.app.setLog(frame.log,"OnActivateBody")
        w = g.app.gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            frame.tree.OnDeactivate()
        frame.bodyWantsFocus()
    except:
        g.es_event_exception("activate body")
        
    return 'break'</t>
<t tx="ekr.20031218072017.3982">def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        c.endEditing()
        
        if 1: # This command always moves into the body pane.
            c.frame.bodyWantsFocus()
        else:
            if c.frame.tree.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()</t>
<t tx="ekr.20031218072017.3983">def insertHeadlineTime (self):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setEditLabelState(p)
    w = p.edit_widget()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')</t>
<t tx="ekr.20031218072017.4039">class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others</t>
<t tx="ekr.20031218072017.4040">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
</t>
<t tx="ekr.20031218072017.4041">def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)</t>
<t tx="ekr.20031218072017.4042">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl</t>
<t tx="ekr.20031218072017.4043">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font</t>
<t tx="ekr.20031218072017.4044">def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl</t>
<t tx="ekr.20031218072017.4045">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20031218072017.4046">def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass</t>
<t tx="ekr.20031218072017.4059"></t>
<t tx="ekr.20031218072017.4060"></t>
<t tx="ekr.20031218072017.4061"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4062">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4063"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20031218072017.4064"></t>
<t tx="ekr.20031218072017.4065">def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()</t>
<t tx="ekr.20031218072017.4066"></t>
<t tx="ekr.20031218072017.4067"></t>
<t tx="ekr.20031218072017.4068">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20031218072017.4069">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20031218072017.4070"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20031218072017.4071"></t>
<t tx="ekr.20031218072017.4072">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4073">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4074"></t>
<t tx="ekr.20031218072017.4075">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20031218072017.4076">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20031218072017.4077">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20031218072017.4078">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20031218072017.4079">def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)</t>
<t tx="ekr.20031218072017.4080">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20031218072017.4081"></t>
<t tx="ekr.20031218072017.4082">def getInsertPoint(self,t):

    return t.index("insert")</t>
<t tx="ekr.20031218072017.4083">def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)</t>
<t tx="ekr.20031218072017.4084"></t>
<t tx="ekr.20031218072017.4085">def getSelectionRange (self,t):

    return t.tag_ranges("sel")</t>
<t tx="ekr.20031218072017.4086">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    sel = t.tag_ranges("sel")  ## Do not remove:  remove entire routine instead!!
    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20031218072017.4088">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20031218072017.4089">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20031218072017.4090"></t>
<t tx="ekr.20031218072017.4091">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4092">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4093">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4094">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4095">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4096">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20031218072017.4097"></t>
<t tx="ekr.20031218072017.4098">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20040303163330">def setDirty (self,setDescendentsDirty=True):
    
    '''Mark a node and all ancestor @file nodes dirty.'''

    p = self ; c = p.c ; dirtyVnodeList = []

    if not p.v.t.isDirty():
        p.v.t.setDirty()
        dirtyVnodeList.append(p.v)

    # Important: this must be called even if p.v is already dirty.
    # Typing can change the @ignore state!
    dirtyVnodeList2 = p.setAllAncestorAtFileNodesDirty(setDescendentsDirty)
    dirtyVnodeList.extend(dirtyVnodeList2)
   
    return dirtyVnodeList</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 alpha 5 cvs-snapshot 1, build %s, December 5, 2005" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.356 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040722132104"></t>
<t tx="ekr.20040803072955.35"></t>
<t tx="ekr.20040803072955.36">def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId</t>
<t tx="ekr.20040803072955.37">def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20040803072955.38">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040803072955.39">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20040803072955.40">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20040803072955.41">def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
</t>
<t tx="ekr.20040803072955.42">def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20040803072955.43">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20040803072955.44">def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        &lt;&lt; highlight text widget on enter events &gt;&gt;
   
    self.configureTextState(p)

    return self.line_height</t>
<t tx="ekr.20040803072955.45"># t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040803072955.46">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20040803072955.47">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20040803072955.48">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20040803072955.49">pass</t>
<t tx="ekr.20040803072955.50">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20040803072955.51">pass</t>
<t tx="ekr.20040803072955.52">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20040803072955.53">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20040803072955.58"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c
    
    if not g.app.unitTesting and c.config.getBool('trace_redraw_now'):
        g.trace(self.redrawCount,g.callers())
        # g.print_stats()
        # g.clear_stats()
        
    # Do the actual redraw.
    self.redrawCount += 1
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20040803072955.59">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20040803072955.61">def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount</t>
<t tx="ekr.20040803072955.62"></t>
<t tx="ekr.20040803072955.63">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20040803072955.64">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20040803072955.65">def scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()
        
idle_scrollTo = scrollTo # For compatibility.</t>
<t tx="ekr.20040803072955.66">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20040803072955.67">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20040803072955.68">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20040803072955.70">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20040803072955.79">def onClickBoxClick (self,event):
    
    c = self.c ; p = self.eventToPosition(event)

    c.beginUpdate()
    try:
	    if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
	        if p.isExpanded(): p.contract()
	        else:              p.expand()
	        self.active = True
	        self.select(p)
	        if c.frame.findPanel:
	            c.frame.findPanel.handleUserClick(p)
	        if self.stayInTree:
	            c.frame.treeWantsFocus()
	        else:
	            c.frame.bodyWantsFocus()
	    g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20040803072955.80"></t>
<t tx="ekr.20040803072955.81">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel() # Bug fix: 11/30/05
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040803072955.82">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20040803072955.83">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.88">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20040803072955.89">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.90"></t>
<t tx="ekr.20040803072955.91"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
	    if changed:
	        # g.trace('changed: old',repr(oldRevert),'new',repr(s))
	        undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
	        if not c.changed: c.setChanged(True)
	        dirtyVnodeList = p.setDirty()
	        u.afterChangeNodeContents(p,undoType,undoData,
	            dirtyVnodeList=dirtyVnodeList)
	    else:
	        pass # g.trace('not changed')
    finally:
        c.endUpdate(changed)
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20040803072955.94"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20040803072955.125"></t>
<t tx="ekr.20040803072955.126">def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)</t>
<t tx="ekr.20040803072955.127">def editLabel (self,p):
    
    """Start editing p's headline."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p) # That is, self._editPosition = p
    
    # g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget!'))

    if p and p.edit_widget():
        self.setEditLabelState(p) # Sets the focus immediately.
        self.frame.headlineWantsFocus(p) # Make sure the focus sticks.</t>
<t tx="ekr.20040803072955.128">@ Warning:
Do **not** try to "optimize" this by returning if p==tree.currentPosition.
@c

def select (self,p,updateBeadList=True):
    
    '''Select a node.  Never redraws outline, but may change coloring of individual headlines.'''
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        if old_p:
            &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                # p is NOT c.currentPosition() here!
                self.canvas.update_idletasks() # Essential.
                self.scrollTo(p)
            except Exception: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    c.setCurrentPosition(p)
    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)</t>
<t tx="ekr.20040803072955.129"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p != p:
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p) # 12/17/04

if old_p.edit_widget():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20040803072955.130"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)
    
# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20040803072955.131">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20040803072955.132"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20040803072955.133">self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()</t>
<t tx="ekr.20040803072955.134"></t>
<t tx="ekr.20040803072955.135">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20040803072955.136">def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20040803072955.138">def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20040803072955.139">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.140">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.141">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.142"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setSelectedLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20040803072955.143">def expandAllAncestors (self,p):
    
    '''Expand all ancestors without redrawing.
    
    Return a flag telling whether a redraw is needed.'''
    
    c = self.c ; redraw_flag = False

    c.beginUpdate()
    try:
	    for p in p.parents_iter():
	        if not p.isExpanded():
	            p.expand()
	            redraw_flag = True
    finally:
        c.endUpdate(False)

    return redraw_flag</t>
<t tx="ekr.20040930075711">@nocolor

Leo can't represent some files using nodes!

I call this the "underindented blank line" problem.

Example:

@color

class aClass:
    def spam(): pass
# comment line
    def eggs(): pass
    
@nocolor

Leo's import code can't handle this:
    
- If the import code puts the comment line in a node, the line won't be output with the proper indentation!!

- Having the comment line stop the scanning of aClass is even worse.

- This usually shows up with an unindented blank line instead of the comment line.</t>
<t tx="ekr.20040930135204">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20041005105605.8">def __init__(self,c):

    # Note: Pychecker complains if we assign to at.x instead of self.x.
    
    # **Warning**: all these ivars must **also** be inited in initCommonIvars.
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = False # True: enable additional checks.
    self.errors = 0 # Make sure at.error() works even when not inited.
    # New in Leo 4.4a5: For createThinChild4 (LeoUser).
    self._forcedGnxPositionList = []
        # Must be here, putting it in initReadIvars doesn't work.

    &lt;&lt; define the dispatch dictionary used by scanText4 &gt;&gt;</t>
<t tx="ekr.20041005105605.9">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20041005105605.27">def readOpenFile(self,root,theFile,fileName):
    
    """Read an open derived file, either 3.x or 4.x."""
    
    at = self

    firstLines,read_new,isThinDerivedFile = at.scanHeader(theFile,fileName)

    if read_new:
        lastLines = at.scanText4(theFile,fileName,root)
    else:
        lastLines = at.scanText3(theFile,root,[],at.endLeo)
        
    root.v.t.setVisited() # Disable warning about set nodes.

    &lt;&lt; handle first and last lines &gt;&gt;</t>
<t tx="ekr.20041005105605.28">try:
    body = root.v.t.tempBodyString
except:
    body = ""

lines = body.split('\n')
at.completeFirstDirectives(lines,firstLines)
at.completeLastDirectives(lines,lastLines)
s = '\n'.join(lines).replace('\r', '')
root.v.t.tempBodyString = s</t>
<t tx="ekr.20041005105605.72">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    
    # New in Leo 4.4a5: Solve Read @file nodes problem (by LeoUser)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove(last)

    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20041005105605.74">def scanText4 (self,theFile,fileName,p,verbose=False):
    
    """Scan a 4.x derived file non-recursively."""
    
    __pychecker__ = '--no-argsused' # fileName,verbose might be used for debugging.

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(theFile)
        if len(s) == 0: break
        kind = at.sentinelKind4(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == at.noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart4(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20041005105605.75"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p.copy() # Bug fix: 12/10/05
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [at.endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20041005105605.76">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20041005105605.77">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20041005105605.78">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20041005105605.79">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20041005105605.80"></t>
<t tx="ekr.20041005105605.81">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(at.endAll)</t>
<t tx="ekr.20041005105605.82">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = at.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(at.endDoc)
    
def skipToEndSentinel(self,s,i):
    at = self
    end = at.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20041005105605.83">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20041005105605.84">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="ekr.20041005105605.85">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild4(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild4(headline)
    
    at.endSentinelStack.append(at.endNode)</t>
<t tx="ekr.20041005105605.86"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="ekr.20041005105605.87"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20041005105605.88">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20041005105605.89">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(at.endOthers)</t>
<t tx="ekr.20041005105605.90"></t>
<t tx="ekr.20041005105605.91">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.
    
    at = self
    at.popSentinelStack(at.endAll)</t>
<t tx="ekr.20041005105605.92">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(at.endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i not used, but must be present.

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(at.endDoc)
    at.inCode = True</t>
<t tx="ekr.20041005105605.93">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.inputFile)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20041005105605.94">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="ekr.20041005105605.95">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""
    
    __pychecker__ = '--no-argsused' # i not used, but must be present.

    at = self ; c = at.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        # 9/4/04: Suppress this warning for the root: @first complicates matters.
        if old and not g.app.unitTesting and at.t != at.root.t:
            &lt;&lt; indicate that the node has been changed &gt;&gt;
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(at.endNode)</t>
<t tx="ekr.20041005105605.96">if at.perfectImportRoot:
    &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
    # p.setMarked()
    at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
    at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
    at.c.setChanged(True)
else:
    if not at.updateWarningGiven:
        at.updateWarningGiven = True
        # print "***",at.t,at.root.t
        g.es("Warning: updating changed text in %s" %
            (at.root.headString()),color="blue")
    # g.es("old...\n%s\n" % old)
    # g.es("new...\n%s\n" % s)
    # Just set the dirty bit. Ancestors will be marked dirty later.
    at.t.setDirty()
    if 1: # We must avoid the full setChanged logic here!
        c.changed = True
    else: # Far too slow for mass changes.
        at.c.setChanged(True)</t>
<t tx="ekr.20041005105605.97"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20041005105605.98">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    __pychecker__ = '--no-argsused' # s,i unused, but must be present.
    
    at = self
    at.popSentinelStack(at.endOthers)</t>
<t tx="ekr.20041005105605.99">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    # Remove the @doc or @space.  We'll add it back at the end.
    if g.match(s,0,tag):
        s = s[len(tag):]
    else:
        at.readError("Missing start of doc part")
        return

    if end:
        # 9/3/04: Remove leading newline.
        if s[0] == '\n': s = s[1:]
        # Remove opening block delim.
        if g.match(s,0,start):
            s = s[len(start):]
        else:
            at.readError("Missing open block comment")
            g.trace(s)
            return
        # Remove trailing newline.
        if s[-1] == '\n': s = s[:-1]
        # Remove closing block delim.
        if s[-len(end):] == end:
            s = s[:-len(end)]
        else:
            at.readError("Missing close block comment")
            g.trace(s)
            g.trace(end)
            g.trace(start)
            return

    at.out.append(tag + s)
    at.docOut = []
    </t>
<t tx="ekr.20041005105605.100"></t>
<t tx="ekr.20041005105605.101">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    __pychecker__ = '--no-argsused' # i unused, but must be present.
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20041005105605.102">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile)
    at.out.append(s)</t>
<t tx="ekr.20041005105605.103">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="ekr.20041005105605.104">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20041005105605.105">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20041005105605.106">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    # g.trace(g.get_line(s,i))
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
        
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if 0: # New in 4.2.1: never change comment delims here...
        if g.match_word(s,i,"@language"):
            &lt;&lt; handle @language &gt;&gt;
        elif g.match_word(s,i,"@comment"):
            &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20041005105605.107"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

g.trace(g.get_line(s,i))
g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="ekr.20041005105605.108">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="ekr.20041005105605.109">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20041005105605.110">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20041005105605.111">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20041005105605.112">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.inputFile) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20041005105605.113">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    s = "Ignoring %s sentinel.  Expecting %s" % (
        at.sentinelName(at.endSentinelStack[-1]),
        at.sentinelName(expectedKind))
    at.readError(s)
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20041005105605.127">def readError(self,message):

    # This is useful now that we don't print the actual messages.
    if self.errors == 0:
        self.printError("----- error reading @file: %s" % self.targetFileName)
        
    # g.trace(self.root,g.callers())
    
    self.error(message)
    
    # Bug fix: 12/10/05: Delete all of root's tree.
    self.root.v.t._firstChild = None
    
    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20041005105605.220">def error(self,message):

    if message:
        self.printError(message)

    self.errors += 1

    # g.trace('errors',self.errors)</t>
<t tx="ekr.20041117062717.14">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.
    
    if 1:
        bunchList = self.get(c,key,"shortcut")
        if bunchList:
            bunchList = [bunch for bunch in bunchList
                if bunch.val and bunch.val.lower() != 'none']
            return key,bunchList
        else:
            return key,[]
    else:
        bunch = self.get(c,key,"shortcut")
        if bunch and bunch.val:
            # g.trace(bunch.pane,key,repr(bunch.val))
            if bunch.val.lower() == 'none':
                return key,None
            else:
                return key,bunch
        else:
            return key,None</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041119204700">def __init__ (self,c):
    
    self.c = c
    self.recentFiles = [] # List of recent files.
    self.shortcutsDict = {}
        # Keys are cononicalized shortcut names, values are bunches.
    
    # Keys are canonicalized names.
    self.dispatchDict = {
        'bool':         self.doBool,
        'color':        self.doColor,
        'directory':    self.doDirectory,
        'font':         self.doFont,
        'if':           self.doIf,
        'ifgui':        self.doIfGui,
        'ifplatform':   self.doIfPlatform,
        'ignore':       self.doIgnore,
        'int':          self.doInt,
        'ints':         self.doInts,
        'float':        self.doFloat,
        'mode':         self.doMode, # New in 4.4b1.
        'path':         self.doPath,
        'page':         self.doPage,
        'ratio':        self.doRatio,
        'shortcut':     self.doShortcut,
        'shortcuts':    self.doShortcuts,
        'string':       self.doString,
        'strings':      self.doStrings,
    }</t>
<t tx="ekr.20041120105609">def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind,val not used.
    
    # g.trace(self.c.fileName(),p.headString(),g.callers())
    
    d = self.shortcutsDict # To detect duplicates.
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # g.trace(name,bunch)
            if bunch is not None:
                # New in 4.4a5:
                bunchList = d.get(name,[])
                bunchList.append(bunch)
                d [name] = bunchList
                self.set(p,"shortcut",name,bunchList)
                self.setShortcut(name,bunchList)</t>
<t tx="ekr.20041120112043">def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(pane=pane,val=val)</t>
<t tx="ekr.20041120113848">def doShortcut(self,p,kind,name,val):
    
    # Note:  kind,name,val are as returned from self.parseHeadline(p.headString())

    self.set(p,kind,name,val)
    self.setShortcut(name,val)</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041217135735.2">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20041222043017">def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)</t>
<t tx="ekr.20041222043017.1">def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d</t>
<t tx="ekr.20041227071423">def setShortcut (self,name,bunch):
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",bunch)
    
    # g.trace(bunch.pane,rawKey,bunch.val)</t>
<t tx="ekr.20050120083053">@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.</t>
<t tx="ekr.20050120092028">def bodyWantsFocus(self):
    w = self.body and self.body.bodyCtrl
    self.set_focus(w)
        
def headlineWantsFocus(self,p):
    w = p and p.edit_widget()
    self.set_focus(w)
    
def logWantsFocus(self):
    w = self.log and self.log.logCtrl
    self.set_focus(w)

def minibufferWantsFocus(self):
    # Important! We must preserve body selection!
    if 1:
        self.bodyWantsFocus()
    else:
        w = self.c.miniBufferWidget
        self.set_focus(w)

def treeWantsFocus(self):
    w = self.tree and self.tree.canvas
    self.set_focus(w)
    
def widgetWantsFocus(self,w):
    self.set_focus(w)
</t>
<t tx="ekr.20050120092028.1"># New in Leo 4.4a3: nothing happens at idle time.

def set_focus(self,w):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c

    if c.config.getBool('trace_g.app.gui.set_focus'): # A *very* effective trace.
        name = w and hasattr(w,'_name') and w._name or '&lt;no name&gt;'
        g.trace(name,g.callers(7)) 

    if w:
        self.wantedWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20050208133438">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()</t>
<t tx="ekr.20050210082320">def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus</t>
<t tx="ekr.20050211100535">def test_g_getScript_strips_crlf():

    script = g.getScript(c,p) # This will get the text of this node.
    assert script.find('\r\n') == -1, repr(script)</t>
<t tx="ekr.20050312114529"></t>
<t tx="ekr.20050312114529.1">def addComments (self):

    c = self ; undoType = 'Add Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            result.append('%s%s %s' % (line[0:i],d1,line[i:]))
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                result.append('%s%s %s' % (line[0:j],d2,line[j:]))
            if i == n-1:
                j = len(line.rstrip())
                result.append('%s %s' % (line[0:j],d3))

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050312114529.2">def deleteComments (self):

    c = self ; undoType = 'Delete Comments' ; p = c.currentPosition()
    
    d = g.scanDirectives(c,p)
    # d1 is the line delim.
    d1,d2,d3 = d.get('delims')

    head,lines,tail,oldSel,oldYview = self.getBodyLines()
    result = []
    if not lines:
        g.es('No text selected',color='blue')
        return
    
    if d1:
        # Append the single-line comment delim in front of each line
        for line in lines:
            i = g.skip_ws(line,0)
            if g.match(line,i,d1):
                j = g.skip_ws(line,i + len(d1))
                result.append(line[0:i] + line[j:])
            else:
                result.append(line)
    else:
        n = len(lines)
        for i in xrange(n):
            line = lines[i]
            if i not in (0,n-1):
                result.append(line)
            if i == 0:
                j = g.skip_ws(line,0)
                if g.match(line,j,d2):
                    k = g.skip_ws(line,j + len(d2))
                    result.append(line[0:j] + line[k:])
                else:
                    g.es("'%s' not found" % (d2),color='blue')
                    return
            if i == n-1:
                if i == 0:
                    line = result[0] ; result = []
                s = line.rstrip()
                if s.endswith(d3):
                    result.append(s[:-len(d3)].rstrip())
                else:
                    g.es("'%s' not found" % (d3),color='blue')
                    return

    result = string.join(result,'\n')
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050512031131"></t>
<t tx="ekr.20050707085637">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3237845
By: eichin

First, I'd like to thank Mr. Ream for presenting at EuroPython; I've been an
emacs user 'forever' (anyone else remember CCA emacs?) and have seen enough
"this could change your world as much as emacs did" sorts of comments, finally
seeing it on-screen live finally kicked me into trying it myself.

My overall experience was mixed; some of this may be due to my laziness (I just
unpacked 4-3-1 on my mac and ran src/leo.py, which got me a window so I counted
it as working.)  I did the original version of this in leo to attempt to get
some experience with it...

I am an emacs user.  So of course, I will use emacs bindings first - and since
some of them work (c-f, c-b) I get in trouble because the others then don't
(c-p pops up a python shell, c-a does something dramatic.)  *definitely* needs
at least a simple "you're an emacs user, here is basic editing in emacs bindings,
the leo-specific stuff is pushed out of the way."  Note that this is not actually
odd for a mac user - most of the basic emacs bindings work in text entry boxes,
like the Safari textarea I'm typing this in now - I'm not asking for m-x, but
for c-f/c-b/c-n/c-p/c-a/c-e and maybe a few more, but those are key.

Pure keyboard usage is also key - one thing that worried me watching the demo
was that Mr. Ream kept switching back and forth, keyboard to mouse, and that's
bad - and when I say bad, I mean that Raskin's book had a good footnote pointing
to a clinical study showing that RSIs correllated with *mouse* usage, not keyboard
usage, in a mainstream computer user context.  Note that I don't really mean
emacs-level keyboard-only use - just that in a typical hour of leo usage, I
shouldn't need the mouse for anything I use twice.  Having unusual stuff only
menus is fine.  Not having keybindings that I could find for *next-node* and
*prev-node* is *not* fine.  Frankly, just logging everything *you* use in an
hour and adding bindings for it might be enough...

Similarly, think of simple use-cases/workflows and make them easier.  Can node-titles
actually be multiple lines?  If not, why not have hitting return in a node title
take me to the text window? (This is just one example I tried and was surprised
didn't work.)  More critically, I couldn't find any keystroke at all to take
me from editing nodes to editing text, but I may have been confused at that
point.

For another, mac-specific case: *don't steal system bindings*.  M-`
(command-backtick, in macspeak) should cycle windows (M-~ the other direction.)
Breaking this dooms you on the Mac; even if that's an important binding on other
platforms, you just *have* to make it different on the mac - or you will only
have cross platform occasional mac users and *never* have any users who are
primarily mac users.  I suppose I should submit that one as a direct bug report.

Minor nit - on startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.

Defaulting to python-mode: sure, maybe it's just coloring, but coming into it
expecting it to be primarily a text-in-outlines editor, that confused me a lot.
I don't actually have an answer here - you can't cheat the way emacs does and
use an extension or #! line to decide "this is python code", though you may
be able to use other tricks - but a first time user is probably going to start
with bits of text and *then* move on to code, and if there's a sane way to support
that, please consider it.

More mac nits: two HELP menus, one is empty; "open leo docs.leo" from the help
menu gives a window that doesn't fit on-screen on my mac (tiger 10.4.1 12" powerbook)
and this leaves the resize control off-screen, so I can't fix it either.

Also (not so mac specific, but more glaring on the mac than elsewhere) - no
context-menu on nodes or text, and I couldn't seem to drag nodes with the mouse
at all (one of the things the mouse *is* obviously useful for, especially if
I'm doing a bunch of rearrangement in one place and *not* going back and forth.)

Finally, one comment from the talk that bothered me for a while and didn't click
until later - "emacs doesn't really have an outline mode".  This is true, at
face value - outline mode in fact is just some regexp and hiding kludging, powerful
in it's own way but not "deep".  However, the operations felt familiar, and
it wasn't until I went home and checked mail that I caught it -- *GNUS* is actually
surprisingly close in function set to an outliner.  Not in any immediately useful
way, but it both clarifies why I think emacs could work this way *and* possibly
clarifies why gnus users are so engaged by the interface :-)  Though that does
mean gnus might be a reasonable source of suggestions for key bindings...

Again, thanks for the demo.  It at least inspired a lot of interest, if not
actually a new convert, but I'll be watching more closely, at least.

_Mark_</t>
<t tx="ekr.20050712092501.1">@killcolor

Buffer-menu-buffer-column
Buffer-menu-mode-map
Buffer-menu-popup-menu

Info-default-directory-list
Info-directory-list
Info-frame-plist

Installation-string
Mouse-track-gensym
X-default-timeout
__buffer-dedicated-frame
_history_

abbreviated-calendar-year
abbreviated-home-dir
abbrevs-changed

activate-menubar-hook
activate-popup-menu-hook
ad-default-compilation-action
ad-redefinition-action

adaptive-fill-function
adaptive-fill-mode
adaptive-fill-regexp

add-log-c-like-modes
add-log-lisp-like-modes
add-log-tex-like-modes

adjust-frame-function

all-christian-calendar-holidays
all-hebrew-calendar-holidays
all-islamic-calendar-holidays

allow-deletion-of-last-visible-frame
allow-remote-paths

american-calendar-display-form
american-date-diary-pattern
apache-file-patterns

appt-audible
appt-display-duration
appt-display-mode-line
appt-issue-message

atomic-extent-goto-char-p
autoload-file-name
backward-delete-function
backward-word-regexp
balloon-help-mode
bar-cursor

bdf-directory-list
bell-inhibit-time
bell-volume

binary-file-regexps
binary-process-input
binary-process-output

binhex-begin-line

blink-cursor-mode
blink-matching-delay
blink-matching-paren
blink-matching-paren-distance
blink-matching-paren-dont-ignore-comments
blink-matching-paren-on-screen
blink-paren-function

block-comment-end
block-comment-start
block-movement-size

bookmark-map

bq-at-flag
bq-at-marker
bq-backquote-marker
bq-backtick-marker
bq-comma-flag
bq-comma-marker
bq-dot-flag
bq-dot-marker

built-in-face-specifiers
built-in-glyph-specifiers
busy-pointer-glyph
c++-mode-syntax-table
c-mode-syntax-table

calc-autoload-directory
calc-gnuplot-name
calc-gnuplot-plot-command
calc-gnuplot-print-command
calc-info-filename

calendar-latitude
calendar-load-hook
calendar-location-name
calendar-longitude
calendar-offset
calendar-setup
calendar-time-display-form
calendar-week-start-day

call-count-profile-table
camldebug-command-name
case-fold-search
case-replace
cd-path
cdpath-previous
change-major-mode-hook
change-major-mode-with-file-name
character-set-property
christian-holidays

coding-keymap
coding-system-for-read
coding-system-for-write
colon-double-space
column-number-mode
column-number-start-at-one

complex-buffers-menu-p

continuation-glyph
continue-save-buffer-hooks-tail

control-arrow-glyph

create-console-hook
create-device-hook
create-frame-hook

ctl-arrow
ctl-x-4-map
ctl-x-5-map
ctl-x-map

current-display-table
current-load-list
current-menubar
current-minibuffer-contents
current-minibuffer-point
current-mouse-event
current-prefix-arg

cursor-in-echo-area

custom-background-mode
custom-define-hook
custom-face-attributes
custom-file
custom-file-base
custom-group-hash-table
custom-known-themes
custom-loaded-themes
custom-local-buffer
custom-print-functions

data-directory
data-directory-list


defining-kbd-macro
defun-prompt-regexp
degrees-to-radians

delete-auto-save-files
delete-console-hook
delete-device-hook
delete-dialog-box-hook
delete-exited-processes
delete-frame-hook
delete-key-deletes-forward
delete-old-versions

describe-function-show-arglist
deselect-frame-hook

dialog-frame-plist

diary-display-hook
diary-file
diary-hook
diary-include-string
diary-list-include-blanks
diary-nonmarking-symbol

diff-switches
dir

directory-abbrev-alist
directory-sep-char

dired-backup-if-overwrite
dired-chown-program
dired-compression-method
dired-compression-method-alist
dired-copy-preserve-time
dired-dwim-target
dired-find-file-compare-truenames
dired-find-subdir
dired-gnutar-program
dired-kept-versions
dired-listing-switches
dired-local-variables-file
dired-ls-program
dired-mail-reader
dired-no-confirm
dired-omit-files
dired-refresh-automatically
dired-unshar-program
dired-use-file-transformers
dired-use-ls-dired

disable-animated-pixmaps
disable-auto-save-when-buffer-shrinks
disabled-command-hook

display-buffer-function
display-time-day-and-date
display-warning-minimum-level
display-warning-suppressed-classes
display-warning-tick

divider-pointer-glyph
doc-directory
dont-record-current-mark

drag-divider-event-lag
drag-modeline-event-lag

dragdrop-autoload-tm-view
dragdrop-drop-at-point
dragdrop-drop-log
dragdrop-drop-log-buffer
dragdrop-drop-log-name
dragdrop-protocols

e

early-package-load-path
early-packages

easy-menu-all-popups
ecb-running-emacs-21
ecb-running-xemacs
echo-keystrokes

edebug-all-defs
edebug-all-forms

ediff-menu
ediff-merge-menu
ediff-misc-menu

edit-abbrevs-map
edit-tab-stops-buffer
edit-tab-stops-map

efs-auto-save
efs-auto-save-remotely
efs-path-root-regexp

eldoc-mode

emacs-beta-version
emacs-build-system
emacs-build-time
emacs-lisp-byte-compile-dir-interactive-p
emacs-lisp-mode-hook
emacs-lisp-mode-map
emacs-lisp-mode-menubar-menu
emacs-lisp-mode-popup-menu
emacs-lisp-mode-syntax-table
emacs-major-version
emacs-minor-version
emacs-patch-level
emacs-priority
emacs-program-name
emacs-program-version
emacs-roots
emacs-version

enable-local-eval
enable-local-variables
enable-multibyte-characters
enable-recursive-minibuffers

enter-window-hook
epatch-menu
erc-ctcp-query-DCC-hook
errors-deactivate-region
esc-map
eshell-directory-name
european-calendar-display-form
european-calendar-style
european-date-diary-pattern

eval-expr-error-message-delay
eval-expr-honor-debug-on-error
eval-expr-print-length
eval-expr-print-level
eval-expr-prompt
eval-interactive-verbose

exec-directory
exec-path
exec-suffix-list

executing-kbd-macro
executing-macro
experimental-dragdrop-drop-functions
face-frob-from-locale-first
facemenu-keymap
facemenu-menu
fast-lock-mode
features

file-coding-system
file-coding-system-alist
file-coding-system-for-read
file-name-coding-system
file-name-handler-alist
file-name-history
file-precious-flag

fill-column
fill-individual-varying-indent
fill-paragraph-function
fill-prefix

find-file-compare-truenames
find-file-existing-other-name
find-file-hooks
find-file-not-found-hooks
find-file-not-true-dirname-list
find-file-run-dired
find-file-use-truenames
find-file-visit-truename

first-change-hook
float-epsilon
float-negative-epsilon
float-output-format
flyspell-mode
flyspell-mode-line-string
flyspell-mode-map
focus-follows-mouse

folding-default-keys-function
folding-default-mouse-keys-function
folding-inside-mode-name
folding-mode
folding-mode-hook-no-regexp
folding-mode-marks-alist
folding-mode-string

font-lock-auto-fontify
font-lock-fontify-string-delimiters
font-lock-keywords
font-lock-maximum-decoration
font-lock-maximum-size
font-lock-mode
font-lock-mode-disable-list
font-lock-mode-enable-list
font-lock-mode-hook
font-lock-syntactic-keywords
font-lock-use-colors
font-lock-use-fonts
font-lock-use-maximal-decoration
font-menu-ignore-scaled-fonts
font-menu-this-frame-only-p

footnote-minor-mode-map
footnote-mode-line-string
footnote-mode-map
footnote-prefix

force-dialog-box-use
format-alist
fortran-tab-mode-default
forward-word-regexp

frame
frame-background-mode
frame-icon-glyph
frame-icon-title-format
frame-initial-frame
frame-initial-frame-plist
frame-initial-geometry-arguments
frame-title-format

function-history
function-key-map
fundamental-mode-abbrev-table
gc-cons-threshold
gc-message
gc-pointer-glyph
gdb-command-name
general-holidays
generated-modeline-string

get-frame-for-buffer-default-frame-name
get-frame-for-buffer-default-instance-limit
get-frame-for-buffer-default-to-current

gnats::mode-name

gnus-outlook-deuglify-unwrap-max
gnus-outlook-deuglify-unwrap-min
gnus-outlook-display-hook

gnuserv-frame
goal-column
grep-null-device
grep-regexp-alist
gui-button-shadow-thickness

hack-local-variables-hook
has-modeline-p
haskell-doc-mode
haskell-mode-hook

hebrew-diary-entry-symbol
hebrew-holidays
hebrew-holidays-1
hebrew-holidays-2
hebrew-holidays-3
hebrew-holidays-4

hide-ifdef-initially
hide-ifdef-lines
hide-ifdef-mode-map
hide-ifdef-read-only

hippie-expand-ignore-buffers
hippie-expand-max-buffers
hippie-expand-try-functions-list
hippie-expand-verbose

history
holidays-in-diary-buffer

hs-hide-comments-when-hiding-all
hs-special-modes-alist
hscroll-glyph
html-font-lock-keywords

hyper-apropos-apropos-buf
hyper-apropos-currently-showing
hyper-apropos-face-history
hyper-apropos-help-buf
hyper-apropos-help-history
hyper-apropos-help-map
hyper-apropos-junk-regexp
hyper-apropos-last-regexp
hyper-apropos-map
hyper-apropos-mode-hook
hyper-apropos-prettyprint-long-values
hyper-apropos-programming-apropos
hyper-apropos-regexp-history
hyper-apropos-show-brief-docs
hyper-apropos-shrink-window

hyperb:emacs19-p
hyperb:kotl-p
hyperb:microcruft-os-p
hyperb:mouse-buttons
hyperb:xemacs-p

hypropos-help-map
hypropos-map
hypropos-prettyprint-long-values
hypropos-programming-apropos
hypropos-show-brief-docs
hypropos-shrink-window

icon-name
iconification-data
idl-mode-syntax-table
ignored-local-variables
image-formats-alist
imenu-generic-expression
in-shifted-motion-command

indent-line-function
indent-region-function
indent-tabs-mode

inhibit-auto-save-session
inhibit-autoloads
inhibit-default-init
inhibit-early-packages
inhibit-file-name-handlers
inhibit-file-name-operation
inhibit-first-line-modes-regexps
inhibit-first-line-modes-suffixes
inhibit-help-echo
inhibit-input-event-recording
inhibit-quit
inhibit-read-only
inhibit-site-lisp
inhibit-site-modules
inhibit-startup-message
inhibit-warning-display

init-face-from-resources
init-file-debug
init-file-had-error
init-file-loaded
init-file-user
init-x-toolbar-list

initial-calendar-window-hook
initial-contents
initial-frame-alist
initial-frame-plist
initial-frame-unmapped-p
initial-major-mode
initial-minibuffer-history-position
initial-scratch-message
initial-toolbar-spec
initial-window-system

initialize-face-resources
insert-default-directory
insert-directory-program
insert-file-contents-access-hook
insert-file-contents-error-hook
insert-file-contents-post-hook
insert-file-contents-pre-hook
internal-doc-file-name
internal-error-checking
interpreter-mode-alist
interprogram-cut-function
interprogram-paste-function
invisible-text-glyph
invocation-directory
invocation-name
invocation-path

islamic-diary-entry-symbol
islamic-holidays
iso8859/1-case-table

ispell-dictionary-alist
ispell-dictionary-alist-1
ispell-dictionary-alist-2
ispell-dictionary-alist-3
ispell-dictionary-alist-4
ispell-dictionary-alist-5
ispell-dictionary-alist-6
ispell-html-skip-alists
ispell-local-dictionary-alist
ispell-menu-map
ispell-menu-map-needed
ispell-menu-xemacs
ispell-personal-dictionary
ispell-skip-region-alist
ispell-tex-skip-alists

itimer-edit-map
itimer-edit-start-marker
itimer-inside-driver
itimer-list
itimer-next-wakeup
itimer-process
itimer-short-interval
itimer-timer
itimer-timer-last-wakeup
itimer-version

java-mode-syntax-table
jde-version
jde-which-method-mode
kept-new-versions
kept-old-versions
key-translation-map
keyboard-coding-system
keyboard-translate-table
keyboard-type
keymap
keymap-tick

kill-buffer-hook
kill-buffer-query-functions
kill-emacs-hook
kill-emacs-query-functions
kill-hooks
kill-ring
kill-ring-max
kill-ring-yank-pointer
kill-whole-line

killed-rectangle
kimport:mode-alist
kimport:suffix-alist
last

last-abbrev
last-abbrev-location
last-abbrev-text
last-command
last-command-char
last-command-event
last-command-event-time
last-command-properties
last-error
last-exact-completion
last-help-echo-object
last-input-char
last-input-event
last-input-time
last-kbd-macro
last-package-load-path
last-packages
last-popup-menu-event
last-pressed-toolbar-button
last-undo-buffer

late-package-load-path
late-packages
lazy-lock-mode
lazy-shot-mode
least-negative-float
least-negative-normalized-float
least-positive-float
least-positive-normalized-float
leave-window-hook

ledit-go-to-lisp-string
ledit-go-to-liszt-string
ledit-save-files

lib-complete:cache
lib-complete:max-cache-size
line-move-ignore-invisible
line-number-mode

local-abbrev-table
local-holidays
local-write-file-hooks

log-message-filter-function
log-message-ignore-labels
log-message-ignore-regexps
log-message-max-size
log-warning-minimum-level
log-warning-suppressed-classes

lookup-syntax-properties
lost-selection-hooks
lpr-command
lpr-lp-system
lpr-switches
lpr-windows-system

major-mode
make-annotation-hook
make-backup-files
manual-program
map-frame-hook

mark-diary-entries-hook
mark-diary-entries-in-calendar
mark-holidays-in-calendar
mark-ring
mark-ring-max
mark-ring-unrecorded-commands

max-lisp-eval-depth
max-specpdl-size
mconfig

menu-accelerator-enabled
menu-accelerator-map
menu-accelerator-modifiers
menu-accelerator-prefix
menu-bar-bookmark-map
menu-no-selection-hook

menubar-configuration
menubar-pointer-glyph
menubar-show-keybindings

menubar-visible-p

meta-prefix-char
mh-lib
mh-libs
mh-progs

minimum-line-ascent
minimum-line-descent
minor-mode-alist
minor-mode-map-alist

modifier-keys-are-sticky
modifier-keys-sticky-time

module-directory
module-load-path

most-negative-fixnum
most-negative-float
most-positive-fixnum
most-positive-float
motion-keys-for-shifted-motion

mule-lisp-directory
native-sound-only-on-console
network-coding-system-alist
news-inews-program
news-path
next-line-add-newlines
next-screen-context-lines
nil
no-redraw-on-reenter
nongregorian-diary-listing-hook
nongregorian-diary-marking-hook
noninteractive
nontext-pointer-glyph
normal-auto-fill-function
nroff-electric-mode
nt-fake-unix-uid
null-device
number-of-diary-entries
obarray
objc-mode-syntax-table

occur-buffer
occur-mode-map
occur-nlines
occur-pos-list

oconfig
octal-escape-glyph
oframe
old-whitespace-incremental-mode-line-string
old-whitespace-mode-line-string
only-global-abbrevs
options-save-faces
oriental-holidays
other-holidays
other-window-scroll-buffer
outline-minor-mode
overlay-arrow-position
overlay-arrow-string

overriding-file-coding-system
overriding-local-map
overriding-terminal-local-map

overwrite-mode
overwrite-mode-binary
overwrite-mode-textual
owindow

page-delimiter

paragraph-ignore-fill-prefix
paragraph-separate
paragraph-start

paren-mode
parens-require-spaces
parse-sexp-ignore-comments
parse-sexp-lookup-properties
path-separator
pathname-coding-system

pending-delete-mode
pending-undo-list
permanent-buffers-mode
php-file-patterns
pi
pike-mode-syntax-table
pixel-horizontal-clip-threshold
pixel-vertical-clip-threshold
point-before-scroll

pop-up-frame-alist
pop-up-frame-function
pop-up-frame-plist
pop-up-frames
pop-up-windows

popup-menu-titles
post-command-hook
post-gc-hook
pre-abbrev-expand-hook
pre-command-hook
pre-display-buffer-function
pre-gc-hook
pre-idle-hook
predicate
prefix-arg
prefix-help-command
preloaded-file-list
primary-selection-extent

print-diary-entries-hook
print-escape-newlines
print-gensym
print-gensym-alist
print-length
print-level
print-message-label
print-readably
print-string-length

printer-current-device
printer-name
printer-page-footer
printer-page-header

process-coding-system-alist
process-connection-type
process-environment

progress-abort-glyph
progress-feedback-popup-period
progress-feedback-style
progress-feedback-use-echo-area
progress-gauge-instantiator
progress-glyph-height
progress-layout-glyph
progress-layout-instantiator
progress-stack
progress-text-instantiator

prompt
ps-multibyte-buffer
ps-page-dimensions-database
ps-paper-type
ps-print-color-p
purify-flag
put-buffer-names-in-file-menu
query-replace-help
query-replace-history
query-replace-interactive
query-replace-map
quit-flag
radians-to-degrees

read-command-history
read-expression-history
read-expression-map
read-file-name-map
read-file-name-must-match-map
read-shell-command-map

readp
redisplay-cache-adjustment
redisplay-end-trigger-functions

register-alist
remote-shell-program
remove-message-hook
replace-re-search-function
replace-search-function
require-final-newline
require-match
ret
retry-undefined-key-binding-unshifted
revert-buffer-function
revert-buffer-insert-file-contents-function
revert-buffer-internal-hook
revert-without-query

rmail-default-dont-reply-to-names
rmail-delete-after-output
rmail-dont-reply-to-names
rmail-file-name
rmail-ignored-headers
rmail-last-file
rmail-mail-new-frame
rmail-primary-inbox-list
rmail-retry-setup-hook
rmail-spool-directory

ruby-mode-hook
running-xemacs
same-window-buffer-names
same-window-regexps
save-abbrevs
save-options-file
save-options-init-file
save-some-buffers-query-display-buffer

scroll-conservatively
scroll-on-clipped-lines
scroll-step
scrollbar-height
scrollbar-on-left-p
scrollbar-on-top-p
scrollbar-pointer-glyph
scrollbar-width
scrollbars-visible-p

scsh-program-name

secondary-selection-extent
select-frame-hook
selected-text-type

selection-appender-alist
selection-buffer-killed-alist
selection-coercible-types
selection-coercion-alist
selection-converter-alist
selection-converter-in-alist
selection-converter-out-alist
selection-pointer-glyph
selection-sets-clipboard

selective-display
selective-display-ellipses

self-insert-face
self-insert-face-command
semanticdb-global-mode
send-mail-function
sendmail-program
sentence-end
sentence-end-double-space
sexp-diary-entry-symbol
shared-lisp-mode-map

shell-command-history
shell-command-switch
shell-dumb-shell-regexp
shell-file-name

shifted-motion-keys-select-region
signal-error-on-buffer-boundary

site-directory
site-load-package-file
site-load-packages
site-module-directory
site-start-file

skeleton-filter
solar-holidays
sound-alist

special-display-buffer-names
special-display-frame-alist
special-display-frame-plist
special-display-function
special-display-regexps

splash-frame-static-body
splash-frame-timeout

split-height-threshold
split-width-threshold
split-window-keep-point

stack-trace-on-error
stack-trace-on-signal
standard-indent
standard-input
standard-output
startup-message-timeout
startup-presentation-hack-keymap
status
strokes-mode
suppress-early-error-handler-backtrace
synchronize-minibuffers
synchronous-sounds
system-configuration
system-configuration-options
system-type
t

tab-stop-list
tab-width

table
tar-regexp

teach-extended-commands-p
teach-extended-commands-timeout

temp-buffer-max-height
temp-buffer-show-function
temp-buffer-show-hook
temp-buffer-shrink-to-fit

temporary-goal-column
term-file-prefix
term-setup-hook

terminal-coding-system
terminal-console
terminal-device
terminal-frame

texinfo-close-quote
texinfo-open-quote

text-cursor-visible-p
text-mode-abbrev-table
text-mode-hook
text-mode-map
text-mode-syntax-table
text-mode-variant
text-pointer-glyph

this-command
this-command-properties

three-step-help
today-invisible-calendar-hook
today-visible-calendar-hook
toggle-where-was-i

trace-buffer
track-eol

tramp-completion-file-name-regexp
tramp-completion-file-name-regexp-separate
tramp-completion-file-name-regexp-unified
tramp-file-name-regexp
tramp-file-name-regexp-separate
tramp-file-name-regexp-unified
tramp-unified-filenames

truncate-lines
truncate-partial-width-windows
truncation-glyph

tshell-prompt-pattern
tutorial-supported-languages
uncapitalized-title-word-regexp
uncapitalized-title-words
undo-high-threshold
undo-threshold
universal-argument-map
universal-argument-num-events
unmap-frame-hook
unread-command-event
unread-command-events
unshifted-motion-keys-deselect-region
use-dialog-box
use-hard-newlines
use-left-overflow
use-right-overflow

user-full-name
user-home-init-file-base-list
user-init-directory
user-init-directory-base
user-init-file
user-init-file-base
user-init-file-base-list
user-mail-address

v
values
variable-history
vc-annotate-mode-hook
vc-before-checkin-hook
vc-checkin-hook
vc-cvs-program
vc-log-template
vc-populate-vc-log-hook
version-control
version18p
version20p

view-calendar-holidays-initially
view-default-lines
view-diary-entries-initially
view-lossage-key-count
view-lossage-message-count
view-minor-mode
view-minor-mode-map
view-mode-map
view-search-arg
view-search-string
visible-bell
w3-configuration-directory
warning-count
warning-level-alist
warning-marker
widget-border-width

win32-pipe-read-delay
win32-quote-process-args
win32-start-process-share-console
win32-start-process-show-window

window
window-config-stack-max
window-min-height
window-min-width
window-pixel-scroll-increment
window-scroll-functions
window-setup-hook
window-size-change-functions
window-system

windowed-process-io
words-include-escapes

write-contents-hooks
write-file-data-hooks
write-file-hooks
write-region-annotate-functions
write-region-annotations-so-far
write-region-post-hook
write-region-pre-hook

x-busy-pointer-shape
x-gc-pointer-shape
x-library-search-path
x-mode-pointer-shape
x-nontext-pointer-shape
x-pointer-shape
x-selection-pointer-shape
x-toolbar-pointer-shape

xemacs-betaname
xemacs-codename
xemacs-logo
xemacs-praise-message
xemacs-praise-sound-file
xemacsp

xlib-version
xpm-color-symbols

xslt-process-additional-classpath
xslt-process-key-binding
xslt-process-mode
xslt-process-mode-line-string
xslt-process-mode-map

zenirc-command-queue
zenirc-last-command-queue-exec

zmacs-activate-region-hook
zmacs-deactivate-region-hook
zmacs-region-active-p
zmacs-region-extent
zmacs-region-rectangular-p
zmacs-region-stays
zmacs-regions
</t>
<t tx="ekr.20050712092501.2">bottom-gutter
bottom-gutter-border-width
bottom-gutter-height
bottom-gutter-visible-p

bottom-toolbar
bottom-toolbar-border-width
bottom-toolbar-height
bottom-toolbar-visible-p

gutter-buffers-tab
gutter-buffers-tab-enabled
gutter-buffers-tab-orientation
gutter-buffers-tab-visible-p
gutter-element-visibility-changed-hook

horizontal-scrollbar-visible-p

left-gutter
left-gutter-border-width
left-gutter-visible-p
left-gutter-width

left-margin
left-margin-width

left-toolbar
left-toolbar-border-width
left-toolbar-visible-p
left-toolbar-width

right-gutter
right-gutter-border-width
right-gutter-visible-p
right-gutter-width

right-margin-width

right-toolbar
right-toolbar-border-width
right-toolbar-visible-p
right-toolbar-width

top-gutter
top-gutter-border-width
top-gutter-height
top-gutter-visible-p

top-level

top-toolbar
top-toolbar-border-width
top-toolbar-height
top-toolbar-visible-p

vertical-divider-always-visible-p
vertical-divider-line-width
vertical-divider-map
vertical-divider-shadow-thickness
vertical-divider-spacing
vertical-scrollbar-visible-p</t>
<t tx="ekr.20050712092501.5"></t>
<t tx="ekr.20050712092501.6">*gensym-counter*
*random-state*</t>
<t tx="ekr.20050712092501.7">:
:accelerator
:activate-callback
:active
:active-opstring
:allow-multi-select
:allow-other-keys
:allow-pages
:allow-selection
:args
:author-version
:autoload-end
:autosize
:background
:background-pixmap
:bold
:border
:buttons
:callback
:callback-ex
:color
:color-symbols
:completion-string
:complex
:config
:cost
:count
:create-prompt-on-nonexistent
:dangerous
:data
:deletion
:description
:descriptor
:device
:dim
:duration
:enable
:end
:end1
:end2
:error
:extra-offset
:face
:face-reset-string
:face-set-string
:family
:file
:file-must-exist
:filter
:filter-list
:foreground
:format
:from-end
:full
:full-name
:get
:greedy
:group
:height
:help
:help-echo
:help-string
:horizontally-justify
:hotspot-x
:hotspot-y
:if
:if-not
:image
:immediate
:included
:initial-directory
:initial-filename
:initial-focus
:initial-value
:initialize
:inline
:interactive
:inverse-video
:italic
:items
:justify
:key
:key-sequence
:keys
:label
:link
:load
:margin-width
:mark
:mask-data
:mask-file
:match
:match-alternatives
:maybe
:menu-tag
:modal
:modifier-p
:must-match
:name
:nick
:no-network-button
:no-read-only-return
:opstring
:options
:orientation
:overwrite-prompt
:pageno
:parent
:password
:pitch
:pixel-height
:pixel-width
:port
:prefix
:printer-name
:printer-settings
:properties
:props
:question
:reader
:reference-buffer
:rehash-size
:rehash-threshold
:require
:resource-id
:resource-type
:selected
:selected-page-button
:server
:set
:set-after
:short-description
:size
:sound
:spec
:start
:start-time
:start1
:start2
:strikethru
:style
:suffix
:summarizer
:tag
:tags
:test
:test-not
:text
:title
:type
:underline
:user-data
:validate
:value
:variable-reset-string
:variable-set-string
:version
:vertically-justify
:volume
:weakness
:width
:window
:window-height
:window-width</t>
<t tx="ekr.20050712092501.8">abbrev-all-caps
abbrev-file-name
abbrev-mode
abbrev-start-location
abbrev-start-location-buffer
abbrev-table
abbrev-table-name-list</t>
<t tx="ekr.20050712092501.9">after-change-function
after-change-functions
after-delete-annotation-hook
after-find-file-from-revert-buffer
after-init-hook
after-insert-file-functions
after-load-alist
after-revert-hook
after-save-hook
after-set-visited-file-name-hooks</t>
<t tx="ekr.20050712092501.10">auto-fill-chars
auto-fill-function
auto-fill-inhibit-regexp
auto-gc-threshold
auto-lower-frame
auto-mode-alist
auto-raise-frame
auto-revert-mode
auto-save-default
auto-save-directory
auto-save-directory-fallback
auto-save-file-format
auto-save-hash-directory
auto-save-hash-p
auto-save-interval
auto-save-list-file-name
auto-save-list-file-prefix
auto-save-offer-delete
auto-save-reserved-chars
auto-save-timeout
auto-save-version
auto-save-visited-file-name
auto-show-inhibiting-commands
auto-show-mode
auto-show-shift-amount
auto-show-show-left-margin-threshold</t>
<t tx="ekr.20050712092501.11">backup-by-copying
backup-by-copying-when-linked
backup-by-copying-when-mismatch
backup-enable-predicate
backup-inhibited</t>
<t tx="ekr.20050712092501.12">bbdb-get-addresses-headers
bbdb-get-only-first-address-p
bbdb-sound-volume
bbdb-sounds-directory
bbdb-update-records-mode
bbdb/vm-set-auto-folder-alist-field</t>
<t tx="ekr.20050712092501.13">before-change-function
before-change-functions
before-delete-annotation-hook
before-init-deferred-warnings
before-init-hook
before-revert-hook</t>
<t tx="ekr.20050712092501.14">browse-url-browser-display
browse-url-browser-function
browse-url-galeon-program
browse-url-generic-program
browse-url-grail
browse-url-mozilla-program
browse-url-new-window-flag
browse-url-new-window-p
browse-url-save-file</t>
<t tx="ekr.20050712092501.15">buffer
buffer-auto-save-file-name
buffer-backed-up
buffer-file-coding-system
buffer-file-coding-system-for-read
buffer-file-format
buffer-file-name
buffer-file-number
buffer-file-numbers-unique
buffer-file-truename
buffer-history
buffer-invisibility-spec
buffer-list-changed-hook
buffer-offer-save
buffer-quit-function
buffer-read-only
buffer-saved-size
buffer-string
buffer-undo-list</t>
<t tx="ekr.20050712092501.16">buffers-menu-format-buffer-line-function
buffers-menu-grouping-function
buffers-menu-max-size
buffers-menu-omit-chars-list
buffers-menu-omit-function
buffers-menu-sort-function
buffers-menu-submenus-for-groups-p
buffers-menu-switch-to-buffer-function
buffers-tab-default-buffer-line-length
buffers-tab-face
buffers-tab-filter-functions
buffers-tab-format-buffer-line-function
buffers-tab-grouping-regexp
buffers-tab-max-buffer-line-length
buffers-tab-max-size
buffers-tab-omit-function
buffers-tab-selection-function
buffers-tab-sort-function
buffers-tab-switch-to-buffer-function</t>
<t tx="ekr.20050712092501.17">cl-builtin-clrhash
cl-builtin-gethash
cl-builtin-maphash
cl-builtin-remhash
cl-closure-vars
cl-compiling-file
cl-emacs-type
cl-hacked-flag
cl-macro-environment
cl-macroexpand-cmacs
cl-old-macroexpand
cl-optimize-safety
cl-optimize-speed
cl-proclaims-deferred
cl-struct-Print-context-tags</t>
<t tx="ekr.20050712092501.18">command-debug-status
command-history
command-line-args
command-line-args-left
command-line-default-directory
command-line-processed
command-loop-level
command-switch-alist</t>
<t tx="ekr.20050712092501.19">comment-column
comment-end
comment-indent-function
comment-indent-hook
comment-line-break-function
comment-multi-line
comment-start
comment-start-skip</t>
<t tx="ekr.20050712092501.20">compilation-buffer-name-function
compilation-finish-function
compilation-minor-mode
compilation-minor-mode-map
compilation-mode-hook
compilation-search-path
compilation-shell-minor-mode
compilation-shell-minor-mode-map
compilation-window-height</t>
<t tx="ekr.20050712092501.21">completion
completion-auto-help
completion-base-size
completion-default-help-string
completion-display-completion-list-function
completion-highlight-first-word-only
completion-ignore-case
completion-ignored-extensions
completion-list-mode-abbrev-table
completion-list-mode-map
completion-list-mode-syntax-table
completion-reference-buffer
completion-regexp-list
completion-setup-hook</t>
<t tx="ekr.20050712092501.22">configure-data-directory
configure-doc-directory
configure-exec-directory
configure-exec-prefix-directory
configure-info-directory
configure-info-path
configure-lisp-directory
configure-mail-lock-method
configure-module-directory
configure-mule-lisp-directory
configure-package-path
configure-prefix-directory
configure-site-directory
configure-site-module-directory</t>
<t tx="ekr.20050712092501.23">dabbrev--abbrev-char-regexp
dabbrev--check-other-buffers
dabbrev--eliminate-newlines
dabbrev--friend-buffer-list
dabbrev--last-abbrev-location
dabbrev--last-abbreviation
dabbrev--last-buffer
dabbrev--last-buffer-found
dabbrev--last-case-pattern
dabbrev--last-completion-buffer
dabbrev--last-direction
dabbrev--last-expansion
dabbrev--last-expansion-location
dabbrev--last-obarray
dabbrev--last-table
dabbrev-abbrev-char-regexp
dabbrev-abbrev-skip-leading-regexp
dabbrev-backward-only
dabbrev-case-distinction
dabbrev-case-fold-search
dabbrev-case-replace
dabbrev-check-all-buffers
dabbrev-check-other-buffers
dabbrev-friend-buffer-function
dabbrev-ignored-buffer-names
dabbrev-ignored-buffer-regexps
dabbrev-limit
dabbrev-search-these-buffers-only
dabbrev-select-buffers-function
dabbrev-upcase-means-case-search</t>
<t tx="ekr.20050712092501.24">isearch-adjusted
isearch-barrier
isearch-buffer
isearch-case-fold-search
isearch-cmds
isearch-extent
isearch-fixed-case
isearch-forward
isearch-hide-immediately
isearch-highlight
isearch-highlight-all-matches
isearch-highlight-extents
isearch-highlight-last-case-fold-search
isearch-highlight-last-regexp
isearch-highlight-last-string
isearch-invalid-regexp
isearch-just-started
isearch-message
isearch-mode
isearch-mode-end-hook
isearch-mode-hook
isearch-mode-map
isearch-new-forward
isearch-nonincremental
isearch-op-fun
isearch-opoint
isearch-other-end
isearch-recursive-edit
isearch-regexp
isearch-selected-frame
isearch-slow-terminal-mode
isearch-small-window
isearch-string
isearch-success
isearch-unhidden-extents
isearch-window-configuration
isearch-window-end
isearch-window-start
isearch-within-brackets
isearch-word
isearch-wrapped
isearch-yank-flag</t>
<t tx="ekr.20050712092501.25">lisp-body-indent
lisp-directory
lisp-imenu-generic-expression
lisp-indent-function
lisp-indent-offset
lisp-interaction-mode-map
lisp-interaction-mode-menubar-menu
lisp-interaction-mode-popup-menu
lisp-mode-abbrev-table
lisp-mode-map
lisp-mode-syntax-table</t>
<t tx="ekr.20050712092501.26">list-buffers-directory
list-buffers-header-line
list-buffers-identification
list-diary-entries-hook
list-directory-brief-switches
list-directory-verbose-switches
list-matching-lines-default-context-lines
list-matching-lines-whole-buffer
list-mode-extent
list-mode-extent-old-point
list-mode-hook
list-mode-map</t>
<t tx="ekr.20050712092501.27">mail-abbrev-mailrc-file
mail-alias-file
mail-aliases
mail-archive-file-name
mail-default-directory
mail-default-reply-to
mail-from-style
mail-header-separator
mail-host-address
mail-interactive
mail-lock-method
mail-lock-methods
mail-self-blind
mail-signature
mail-specify-envelope-from
mail-use-rfc822
mail-user-agent
mail-yank-ignored-headers
mail-yank-prefix</t>
<t tx="ekr.20050712092501.28">minibuffer-completion-confirm
minibuffer-completion-predicate
minibuffer-completion-table
minibuffer-confirm-incomplete
minibuffer-default
minibuffer-electric-file-name-behavior
minibuffer-exit-hook
minibuffer-frame-alist
minibuffer-frame-plist
minibuffer-help-form
minibuffer-history
minibuffer-history-minimum-string-length
minibuffer-history-position
minibuffer-history-search-history
minibuffer-history-sexp-flag
minibuffer-history-uniquify
minibuffer-history-variable
minibuffer-local-completion-map
minibuffer-local-isearch-map
minibuffer-local-map
minibuffer-local-must-match-map
minibuffer-max-depth
minibuffer-scroll-window
minibuffer-setup-hook
minibuffer-smart-completion-tracking-behavior</t>
<t tx="ekr.20050712092501.29">mode-compile-after-compile-hook
mode-compile-after-kill-hook
mode-compile-always-save-buffer-p
mode-compile-before-compile-hook
mode-compile-before-kill-hook
mode-compile-chosen-compiler
mode-compile-default-make-options
mode-compile-expert-p
mode-compile-ignore-makefile-backups
mode-compile-ignore-makerule-regexp
mode-compile-make-options
mode-compile-make-program
mode-compile-never-edit-command-p
mode-compile-other-frame-p
mode-compile-preferred-default-makerule
mode-compile-reading-time
mode-compile-save-all-p
mode-compile-version
mode-for-help
mode-line-buffer-identification
mode-line-format
mode-line-map
mode-line-menu
mode-line-modified
mode-line-process
mode-motion-extent
mode-motion-help-echo-string
mode-motion-hook
mode-name
mode-popup-menu
mode-specific-map</t>
<t tx="ekr.20050712092501.30">modeline-3d-p
modeline-buffer-id-extent
modeline-buffer-id-left-extent
modeline-buffer-id-left-map
modeline-buffer-id-right-extent
modeline-buffer-id-right-map
modeline-buffer-identification
modeline-click-swaps-buffers
modeline-format
modeline-map
modeline-menu
modeline-minor-mode-extent
modeline-minor-mode-map
modeline-modified
modeline-modified-extent
modeline-modified-map
modeline-mousable-minor-mode-extent
modeline-multibyte-status
modeline-narrowed-extent
modeline-narrowed-map
modeline-pointer-glyph
modeline-process
modeline-scrolling-method
modeline-shadow-thickness</t>
<t tx="ekr.20050712092501.31">mouse-avoidance-mode
mouse-avoidance-mode-line-string
mouse-enter-frame-hook
mouse-grabbed-buffer
mouse-highlight-priority
mouse-highlight-text
mouse-leave-frame-hook
mouse-motion-handler
mouse-track-activate-strokes
mouse-track-cleanup-hook
mouse-track-click-count
mouse-track-click-hook
mouse-track-down-hook
mouse-track-drag-hook
mouse-track-drag-up-hook
mouse-track-multi-click-time
mouse-track-rectangle-p
mouse-track-scroll-delay
mouse-track-timeout-id
mouse-track-up-hook
mouse-track-up-time
mouse-track-up-x
mouse-track-up-y
mouse-track-x-threshold
mouse-track-y-threshold
mouse-yank-at-point
mouse-yank-function</t>
<t tx="ekr.20050712092501.32">mswindows-alt-by-itself-activates-menu
mswindows-bitmap-file-path
mswindows-construct-process-command-line-alist
mswindows-downcase-file-names
mswindows-dynamic-frame-resize
mswindows-font-regexp
mswindows-get-true-file-attributes
mswindows-ls-round-file-size
mswindows-ls-sort-case-insensitive
mswindows-match-one-cmd-exe-token-regexp
mswindows-mouse-button-max-skew-x
mswindows-mouse-button-max-skew-y
mswindows-mouse-button-tolerance
mswindows-num-mouse-buttons
mswindows-post-win-initted
mswindows-pre-win-initted
mswindows-start-process-inherit-error-mode
mswindows-start-process-share-console
mswindows-system-shells
mswindows-use-system-frame-size-defaults
mswindows-win-initted</t>
<t tx="ekr.20050712092501.33">package-get-base
package-get-download-sites

packages-data-path-depth
packages-hardcoded-lisp
packages-hierarchy-depth
packages-load-path-depth
packages-no-package-hierarchy-regexp
packages-package-list
packages-special-base-regexp
packages-unbytecompiled-lisp
packages-useful-lisp</t>
<t tx="ekr.20050712092501.34">regexp-history
regexp-search-ring
regexp-search-ring-max
regexp-search-ring-yank-pointer

search-caps-disable-folding
search-dialog
search-dialog-direction
search-dialog-regexp
search-exit-option
search-highlight
search-invisible
search-nonincremental-instead
search-ring
search-ring-max
search-ring-update
search-ring-yank-pointer
search-slow-speed
search-slow-window-lines
search-whitespace-regexp</t>
<t tx="ekr.20050712092501.35">toolbar-active
toolbar-blank-press-function
toolbar-buttons-captioned-p
toolbar-captioned-p
toolbar-compile-icon
toolbar-copy-function
toolbar-copy-icon
toolbar-cut-function
toolbar-cut-icon
toolbar-debug-icon
toolbar-dired-function
toolbar-disk-icon
toolbar-file-icon
toolbar-folder-icon
toolbar-help-enabled
toolbar-icon-directory
toolbar-info-frame
toolbar-info-frame-plist
toolbar-info-icon
toolbar-info-use-separate-frame
toolbar-ispell-function
toolbar-last-win-icon
toolbar-mail-commands-alist
toolbar-mail-icon
toolbar-mail-reader
toolbar-map
toolbar-news-commands-alist
toolbar-news-frame
toolbar-news-frame-plist
toolbar-news-frame-properties
toolbar-news-icon
toolbar-news-reader
toolbar-news-use-separate-frame
toolbar-next-win-icon
toolbar-open-function
toolbar-paste-function
toolbar-paste-icon
toolbar-pointer-glyph
toolbar-print-function
toolbar-printer-icon
toolbar-replace-function
toolbar-replace-icon
toolbar-save-function
toolbar-spell-icon
toolbar-undo-function
toolbar-undo-icon
toolbar-vector-compile
toolbar-vector-copy
toolbar-vector-cut
toolbar-vector-debug
toolbar-vector-dired
toolbar-vector-info
toolbar-vector-mail
toolbar-vector-news
toolbar-vector-open
toolbar-vector-paste
toolbar-vector-print
toolbar-vector-replace
toolbar-vector-save
toolbar-vector-spell
toolbar-vector-undo
toolbar-visible-p</t>
<t tx="ekr.20050712094115">debug-ignored-errors
debug-mswindows-process-command-lines
debug-on-error
debug-on-next-call
debug-on-quit
debug-on-signal
debug-paths
debugger</t>
<t tx="ekr.20050712094115.1">default
default-abbrev-mode
default-buffer-file-coding-system
default-case-fold-search
default-ctl-arrow
default-custom-frame-properties
default-directory
default-directory-function
default-file-dialog-filter-alist
default-fill-column
default-frame-alist
default-frame-name
default-frame-plist
default-function-key-map
default-gutter
default-gutter-border-width
default-gutter-height
default-gutter-position
default-gutter-position-changed-hook
default-gutter-visible-p
default-gutter-width
default-justification
default-left-margin
default-major-mode
default-menubar
default-minibuffer-frame
default-mode-line-format
default-modeline-format
default-mouse-track-adjust
default-mouse-track-down-event
default-mouse-track-extent
default-mouse-track-max-anchor
default-mouse-track-min-anchor
default-mouse-track-normalize-point-function
default-mouse-track-previous-point
default-mouse-track-result
default-mouse-track-type
default-mouse-track-type-list
default-mouse-track-window
default-msprinter-frame-plist
default-mswindows-frame-plist
default-popup-menu
default-profiling-interval
default-tab-width
default-text-properties
default-toolbar
default-toolbar-border-width
default-toolbar-height
default-toolbar-position
default-toolbar-visible-p
default-toolbar-width
default-truncate-lines</t>
<t tx="ekr.20050712094115.2">global-abbrev-table
global-auto-revert-mode
global-map
global-mark-ring
global-mark-ring-max
global-mode-string
global-popup-menu
global-semantic-auto-parse-mode
global-semantic-show-dirty-mode
global-semantic-show-unmatched-syntax-mode
global-semantic-summary-mode
global-senator-minor-mode</t>
<t tx="ekr.20050712094115.3">help-buffer-list
help-buffer-prefix-string
help-char
help-echo-owns-message
help-form
help-map
help-max-help-buffers
help-mode-abbrev-table
help-mode-map
help-mode-syntax-table
help-selects-help-window
help-sticky-window
help-symbol-function-and-variable-context-menu
help-symbol-function-context-menu
help-symbol-regexp
help-symbol-variable-context-menu
help-window-config
</t>
<t tx="ekr.20050712094115.4">load-file-name
load-force-doc-strings
load-history
load-home-init-file
load-ignore-elc-files
load-in-progress
load-path
load-read-function
load-user-init-file-p
load-warn-when-source-newer
load-warn-when-source-only
</t>
<t tx="ekr.20050712094115.5">message-archive-header
message-archive-note
message-citation-line-function
message-cite-function
message-cross-post-default
message-cross-post-note
message-cross-post-note-function
message-followup-to-note
message-from-style
message-indent-citation-function
message-mark-insert-begin
message-mark-insert-end
message-send-mail-function
message-signature
message-signature-file
message-signature-insert-empty-line
message-signature-separator
message-stack
message-user-organization-file
message-yank-prefix</t>
<t tx="ekr.20050712094115.6">paths-core-load-path-depth
paths-default-info-directories

paths-el-original-directory-abbrev-alist
paths-el-original-manual-program
paths-el-original-mh-libs
paths-el-original-mh-progs
paths-el-original-news-inews-program
paths-el-original-remote-shell-program
paths-el-original-rmail-spool-directory
paths-el-original-sendmail-program

paths-lisp-filename-regexp
paths-mule-load-path-depth
paths-no-lisp-directory-regexp
paths-site-load-path-depth
paths-version-control-filename-regexp</t>
<t tx="ekr.20050712094115.7">xwem-after-init-hook
xwem-after-init-wins-hook
xwem-applications-alist
xwem-before-init-hook
xwem-before-init-wins-hook
xwem-cl-activate-hook
xwem-cl-change-hook
xwem-cl-create-hook
xwem-cl-deactivate-hook
xwem-cl-destroy-hook
xwem-cl-iconify-hook
xwem-cl-mark-ring
xwem-cl-refit-hook
xwem-cl-state-change-hook
xwem-cl-withdraw-hook
xwem-clgen-map
xwem-client-default-properties
xwem-client-deselect-hook
xwem-client-select-hook
xwem-config-read-hook
xwem-debug-routines
xwem-dedicated-frame-defalut-properties
xwem-default-focus-mode
xwem-default-parent-map
xwem-dir
xwem-embedded-frame-default-properties
xwem-frame-default-properties
xwem-global-map
xwem-help-key
xwem-icons-dir
xwem-icons-list
xwem-kbd-now-grabbing
xwem-kbd-quit-hook
xwem-keyboard-echo-keystrokes
xwem-keyboard-init-hook
xwem-load-hook
xwem-manage-default-properties
xwem-manage-expectances
xwem-manage-list
xwem-messages-ignore-labels
xwem-minibuffer-focusin-hook
xwem-minibuffer-focusout-hook
xwem-override-local-map
xwem-override-map
xwem-post-command-hook
xwem-pre-command-hook
xwem-prefix-arg
xwem-prefix-help-command
xwem-quit-command
xwem-quit-key
xwem-sound-alist
xwem-sound-list
xwem-started
xwem-tabber-click-cl
xwem-tabber-click-frame
xwem-universal-key
xwem-version
xwem-win-min-height
xwem-win-min-width
xwem-win-split-hook
xwem-worklog-load-hook
xwem-worklog-login-hook
xwem-worklog-logout-hook
xwem-worklog-task-pause-hook
xwem-worklog-task-resume-hook
xwem-worklog-task-start-hook
xwem-worklog-task-stop-hook
xwem-worklog-tasks-description</t>
<t tx="ekr.20050713105353"></t>
<t tx="ekr.20050713105353.1">@nocolor

I have looked into leo's code and managed to figure out how to change 
some fonts. Here's what I did to change the menu fonts for example.

Fonts for the menu can be set in Code-&gt;Gui Tkinter classes-&gt;@thin 
leoTkinterMenu.py-&gt;Tkinter menu bindings-&gt;Routines with Tk 
spellings-&gt;new_menu

so to use the system font (linux) I changed the return statement to:

return Tk.Menu(parent,tearoff=tearoff, font=("System",11))

I'll try using .leo_xresources file and see if that works as well.</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050831131028"></t>
<t tx="ekr.20050831131452">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3280949
By: billp9619

&gt;&gt;Making Leo a friendly part of the opml world has the potential to be very
important to Leo. &lt;&lt;

This is probably point 5. and covers the implementation of opml features as
exposed in Leo.

Because Leo is highly scripted there may be many requests... currently out on
the OPML list... that are solveable....such as how to see their outlines as
HTML without passing thru the OPML web server /host. BTW...all this new opml
stuff is only a week or two in production. The first message on
http://groups.yahoo.com/group/opml-newbies/
is July 25.

&gt;&gt; The question of whether to duplicate body text in &lt;outline&gt; elements
is minor&lt;&lt;

Good. 

Really, the opml tools are pretty much raw text/xml  and I was thinking the
default fallback is ... all clone text is "duplicate". If you want clones then
you will take care to only edit them in Leo. But if opml users all know and
use clones routinely in other editors,  then this is good news for opml
as technology.

&gt;&gt;more complicated than it needs to be&lt;&lt;

Well, both Leo and opml have only a few elements and each primarilly uses one
which recusively nests to make up the outline portion. I suppose body nodes
could be included more directly in headlines ... allowing un-numbered headlines
basically, ... but I am not sure that the current way is inferior
or complicated.

 A simpler (forgiving?) format might make it easier to create with external
apps and encourage transforming other xml to Leo via XSLT. It would have to
just "work".

(One thing about Leo's bias towards elements to contain markup, versus attributes,
is that ...you can cheat a little on escaping &amp;quot; in vh or t nodes ?...which
makes code blocks smaller in the Leo xml.)

Your list above is pretty much how I see it as well.

regards,

bill p

</t>
<t tx="ekr.20050831131452.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3282460
By: billp9619

Looking at some discussion of outline formats there was a remark that because
opml places all text in attributes it is limited in not being able to contan
other elements. On xml-dev I also saw some advice about opml followed by the
comment that it is not a good format.

opml is crippled in this regard but  Leo only restricts itself as a choice in
order to  discern leo xml from content.(out of necessity we know).

Of course with xml you can mix vocabularies based on the use of namespaces.
By becoming namespace aware Leo could be adapted for non-escaped markup. The
purpose then is xml parsing of leo as a standard container of other xml. I do
not believe this is unthinkable  for some future capabilities... especially
if such nodes would contain exclusively xml from another namespace.

Just interesting that leo's format is more versatile than opml, 
but, ...by choice for its own purposes, ...
 is in this part "backward" compatible with opml. :)  

regards,

bill p
</t>
<t tx="ekr.20050912063133"></t>
<t tx="ekr.20050912065811"></t>
<t tx="ekr.20050915062404">@nocolor

Hi,

I am the author of Leo http://webpages.charter.net/edreamleo/front.html an outline editor supporting clones http://webpages.charter.net/edreamleo/intro.html#clones-views.

I am interested in having Leo be able to read and write opml files.  My understanding is that applications are free to use attributes of &lt;outline&gt; elements as they please, but I am wondering whether there are guidelines or existing conventions for representing clones.  Have any namespaces been defined for that purpose?

Thanks.

Edward
</t>
<t tx="ekr.20050916180203"></t>
<t tx="ekr.20050920084036.43">def renameBuffer (self,event):
    
    self.k.setLabelBlue('Rename buffer from: ')
    self.getBufferName(self.renameBufferFinisher1)
    
def renameBufferFinisher1 (self,name):
    
    self.fromName = name
    self.k.setLabelBlue('Rename buffer from: %s to: ' % (name))
    self.getBufferName(self.renameBufferFinisher2)
    
def renameBufferFinisher2 (self,name):
    
    c = self.c ; p = self.findBuffer(self.fromName)
    if p:
        c.frame.tree.editLabel(p)
        w = p.edit_widget()
        if w:
            w.delete("1.0","end")
            w.insert("1.0",name)
            c.endEditing()
            ### c.frame.tree.onHeadChanged(p,'rename-buffer %s' % p.headString())</t>
<t tx="ekr.20050920084036.53">class editCommandsClass (baseEditCommandsClass):
    
    '''Contains editing commands with little or no state.'''

    @others</t>
<t tx="ekr.20050920084036.54">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.ccolumn = '0'   # For comment column functions.
    self.dynaregex = re.compile(r'[%s%s\-_]+'%(string.ascii_letters,string.digits))
        # For dynamic abbreviations
    self.extendMode = False # True: all cursor move commands extend the selection.
    self.fillPrefix = '' # For fill prefix functions.
    self.fillColumn = 70 # For line centering.
    self.store ={'rlist':[], 'stext':''} # For dynamic expansion.
    self.swapSpots = []
    self._useRegex = False # For replace-string and replace-regex
    self.widget = None # For use by state handlers.</t>
<t tx="ekr.20050920084036.55">def getPublicCommands (self):        

    k = self.k

    return {
        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
        'capitalize-word':                      self.capitalizeWord,
        'center-line':                          self.centerLine,
        'center-region':                        self.centerRegion,
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-up':                            self.scrollUp,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'sort-columns':                         self.sortColumns,
        'sort-fields':                          self.sortFields,
        'sort-lines':                           self.sortLines,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
        'upcase-region':                        self.upCaseRegion,
        'upcase-word':                          self.upCaseWord,
        'view-lossage':                         self.viewLossage,
        'what-line':                            self.whatLine,
    }
</t>
<t tx="ekr.20050920084036.57"></t>
<t tx="ekr.20050920084036.58"></t>
<t tx="ekr.20050920084036.59">def dynamicExpansion (self,event): #, store = {'rlist': [], 'stext': ''} ):

    k = self.k ; w = event.widget
    rlist = self.store ['rlist']
    stext = self.store ['stext']
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    dA = w.tag_ranges('dA')
    w.tag_delete('dA')
    def doDa (txt,from_='insert -1c wordstart',to_='insert -1c wordend'):
        w.delete(from_,to_)
        w.insert('insert',txt,'dA')

    if dA:
        dA1, dA2 = dA
        dtext = w.get(dA1,dA2)
        if dtext.startswith(stext) and i2 == dA2:
            #This seems reasonable, since we cant get a whole word that has the '-' char in it, we do a good guess
            if rlist:
                txt = rlist.pop()
            else:
                txt = stext
                w.delete(dA1,dA2)
                dA2 = dA1 # since the text is going to be reread, we dont want to include the last dynamic abbreviation
                self.getDynamicList(w,txt,rlist)
            doDa(txt,dA1,dA2) ; return
        else: dA = None

    if not dA:
        self.store ['stext'] = txt
        self.store ['rlist'] = rlist = []
        self.getDynamicList(w,txt,rlist)
        if not rlist: return
        txt = rlist.pop()
        doDa(txt)
</t>
<t tx="ekr.20050920084036.60">def dynamicExpansion2 (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert -1c wordstart')
    i2 = w.index('insert -1c wordend')
    txt = w.get(i,i2)
    rlist = []
    self.getDynamicList(w,txt,rlist)
    dEstring = reduce(g.longestCommonPrefix,rlist)
    if dEstring:
        w.delete(i,i2)
        w.insert(i,dEstring)</t>
<t tx="ekr.20050920084036.61">def getDynamicList (self,w,txt,rlist):

     ttext = w.get('1.0','end')
     items = self.dynaregex.findall(ttext) #make a big list of what we are considering a 'word'
     if items:
         for word in items:
             if not word.startswith(txt) or word == txt: continue #dont need words that dont match or == the pattern
             if word not in rlist:
                 rlist.append(word)
             else:
                 rlist.remove(word)
                 rlist.append(word)</t>
<t tx="ekr.20050920084036.62"></t>
<t tx="ekr.20050920084036.63">def watchEscape (self,event):

    k = self.k

    if not k.inState():
        k.setState('escape','start',handler=self.watchEscape)
        k.setLabelBlue('Esc ')
    elif k.getStateKind() == 'escape':
        state = k.getState('escape')
        hi1 = k.keysymHistory [0]
        hi2 = k.keysymHistory [1]
        if state == 'esc esc' and event.keysym == 'colon':
            self.evalExpression(event)
        elif state == 'evaluate':
            self.escEvaluate(event)
        elif hi1 == hi2 == 'Escape':
            k.setState('escape','esc esc')
            k.setLabel('Esc Esc -')
        elif event.keysym not in ('Shift_L','Shift_R'):
            k.keyboardQuit(event)</t>
<t tx="ekr.20050920084036.64">def escEvaluate (self,event):

    k = self.k ; w = event.widget

    if k.getLabel() == 'Eval:':
        k.setLabel('')

    if event.keysym == 'Return':
        expression = k.getLabel()
        try:
            ok = False
            result = eval(expression,{},{})
            result = str(result)
            w.insert('insert',result)
            ok = True
        finally:
            k.keyboardQuit(event)
            if not ok:
                k.setLabel('Error: Invalid Expression')
    else:
        k.updateLabel(event)</t>
<t tx="ekr.20050920084036.65">def evalExpression (self,event):

    k = self.k ; state = k.getState('eval-expression')
    
    if state == 0:
        k.setLabelBlue('Eval: ',protect=True)
        k.getArg(event,'eval-expression',1,self.evalExpression)
    else:
        k.clearState()
        try:
            e = k.arg
            result = str(eval(e,{},{}))
            k.setLabelGrey('Eval: %s -&gt; %s' % (e,result))
        except Exception:
            k.setLabelGrey('Invalid Expression: %s' % e)</t>
<t tx="ekr.20050920084036.66">@
These methods are currently just used in tandem to center the line or region within the fill column.
for example, dependent upon the fill column, this text:

cats
raaaaaaaaaaaats
mats
zaaaaaaaaap

may look like

                                 cats
                           raaaaaaaaaaaats
                                 mats
                             zaaaaaaaaap
after an center-region command via Alt-x.


@c


@others</t>
<t tx="ekr.20050920084036.67">def centerLine (self,event):

    '''Centers line within current fillColumn'''

    k = self.k ; w = event.widget

    ind = w.index('insert linestart')
    txt = w.get('insert linestart','insert lineend')
    txt = txt.strip()
    if len(txt) &gt;= self.fillColumn: return

    amount = (self.fillColumn-len(txt)) / 2
    ws = ' ' * amount
    col, nind = ind.split('.')
    ind = w.search('\w','insert linestart',regexp=True,stopindex='insert lineend')
    if ind:
        w.delete('insert linestart','%s' % ind)
        w.insert('insert linestart',ws)</t>
<t tx="ekr.20050920084036.68">def setFillColumn (self,event):

    k = self.k ; state = k.getState('set-fill-column')
    
    if state == 0:
        k.setLabelBlue('Set Fill Column: ')
        k.getArg(event,'set-fill-column',1,self.setFillColumn)
    else:
        k.clearState()
        try:
            n = int(k.arg)
            k.setLabelGrey('fill column is: %d' % n)
            k.commandName = 'set-fill-column %d' % n
        except ValueError:
            k.resetLabel()</t>
<t tx="ekr.20050920084036.69">def centerRegion( self, event ):

    '''This method centers the current region within the fill column'''

    k = self.k ; w = event.widget
    start = w.index( 'sel.first linestart' )
    sindex , x = start.split( '.' )
    sindex = int( sindex )
    end = w.index( 'sel.last linestart' )
    eindex , x = end.split( '.' )
    eindex = int( eindex )
    while sindex &lt;= eindex:
        txt = w.get( '%s.0 linestart' % sindex , '%s.0 lineend' % sindex )
        txt = txt.strip()
        if len( txt ) &gt;= self.fillColumn:
            sindex = sindex + 1
            continue
        amount = ( self.fillColumn - len( txt ) ) / 2
        ws = ' ' * amount
        ind = w.search( '\w', '%s.0' % sindex, regexp = True, stopindex = '%s.0 lineend' % sindex )
        if not ind: 
            sindex = sindex + 1
            continue
        w.delete( '%s.0' % sindex , '%s' % ind )
        w.insert( '%s.0' % sindex , ws )
        sindex = sindex + 1</t>
<t tx="ekr.20050920084036.70">def setFillPrefix( self, event ):

    w = event.widget
    txt = w.get( 'insert linestart', 'insert' )
    self.fillPrefix = txt</t>
<t tx="ekr.20050920084036.71">def _addPrefix (self,ntxt):

    ntxt = ntxt.split('.')
    ntxt = map(lambda a: self.fillPrefix+a,ntxt)
    ntxt = '.'.join(ntxt)
    return ntxt</t>
<t tx="ekr.20050920084036.72"></t>
<t tx="ekr.20050920084036.74"></t>
<t tx="ekr.20050920084036.75">def backToIndentation (self,event):
    
    '''The back-to-indentation command, given anywhere on a line,
    positions the point at the first non-blank character on the line.'''

    w = event.widget
    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)</t>
<t tx="ekr.20050920084036.76">def deleteIndentation (self,event):

    k = self.k ; w = event.widget

    txt = w.get('insert linestart','insert lineend')
    txt = ' %s' % txt.lstrip()
    w.delete('insert linestart','insert lineend +1c')
    i = w.index('insert - 1c')
    w.insert('insert -1c',txt)
    w.mark_set('insert',i)</t>
<t tx="ekr.20050920084036.77">def insertNewLineIndent (self,event):

    w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = self.getWSString(txt)
    i = w.index('insert')
    w.insert(i,txt)
    w.mark_set('insert',i)
    self.insertNewLine(event)
</t>
<t tx="ekr.20050920084036.78">def indentRelative (self,event):
    
    '''The indent-relative command indents at the point based on the previous
    line (actually, the last non-empty line.) It inserts whitespace at the
    point, moving point, until it is underneath an indentation point in the
    previous line.
    
    An indentation point is the end of a sequence of whitespace or the end of
    the line. If the point is farther right than any indentation point in the
    previous line, the whitespace before point is deleted and the first
    indentation point then applicable is used. If no indentation point is
    applicable even then whitespace equivalent to a single tab is inserted.'''
    
    c = self.c ; undoType = 'Indent Relative'
    
    k = self.k ; w = event.widget
    i = w.index('insert')
    oldSel = (i,i)
    line, col = i.split('.')
    c2 = int(col)
    l2 = int(line) -1
    if l2 &lt; 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) &lt;= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                
    i = w.index('insert')
    result = w.get('1.0','end')
    head = tail = oldYview = None
    c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)
    w.mark_set('insert',i)</t>
<t tx="ekr.20050920084036.79"></t>
<t tx="ekr.20050920084036.80">def howMany (self,event):
    
    k = self.k ; w = event.widget ; state = k.getState('how-many')
    
    if state == 0:
        k.setLabelBlue('How many: ',protect = True)
        k.getArg(event,'how-many',1,self.howMany)
    else:
        k.clearState()
        s = w.get('1.0','end')
        reg = re.compile(k.arg)
        i = reg.findall(s)
        k.setLabelGrey('%s occurances of %s' % (len(i),k.arg))</t>
<t tx="ekr.20050920084036.81">def lineNumber (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    i1, i2 = i.split('.')
    c = w.get('insert','insert + 1c')
    txt = w.get('1.0','end')
    txt2 = w.get('1.0','insert')
    perc = len(txt) * .01
    perc = int(len(txt2)/perc)
    k.setLabelGrey('Char: %s point %s of %s(%s%s)  Column %s' % (c,len(txt2),len(txt),perc,'%',i1))</t>
<t tx="ekr.20050920084036.83">def viewLossage (self,event):

    k = self.k
    loss = ''.join(leoKeys.keyHandlerClass.lossage)
    k.setLabel(loss)</t>
<t tx="ekr.20050920084036.84">def whatLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    k.keyboardQuit(event)
    k.setLabel("Line %s" % i1)</t>
<t tx="ekr.20050920084036.85"></t>
<t tx="ekr.20050920084036.86">def insertNewLineAndTab (self,event):

    '''Insert a newline and tab'''

    k = self.k ; w = event.widget
    self.insertNewLine(event)
    i = w.index('insert +1c')
    w.insert(i,'\t')
    w.mark_set('insert','%s lineend' % i)</t>
<t tx="ekr.20050920084036.87">def deleteNextChar (self,event):

    c = self.c ; w = event.widget

    g.trace(g.app.gui.widget_name(w))
    
    self.beginCommand('delete-char')
    
    i,j = g.app.gui.getTextSelection(w)

    if i != j:
        w.delete(i,j)
    else:
        w.delete(i)
        
    self.endCommand()</t>
<t tx="ekr.20050920084036.88"></t>
<t tx="ekr.20050920084036.90">def flushLines (self,event):

    '''Delete each line that contains a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('flush-lines')
    
    if state == 0:
        k.setLabelBlue('Flush lines regexp: ',protect=True)
        k.getArg(event,'flush-lines',1,self.flushLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'flush')
        k.commandName = 'flush-lines %s' % k.arg</t>
<t tx="ekr.20050920084036.92">def linesHelper (self,event,pattern,which):

    k = self.k ; w = event.widget
   
    if w.tag_ranges('sel'):
        i = w.index('sel.first') ; end = w.index('sel.last')
    else:
         i = w.index('insert') ; end = 'end'
    txt = w.get(i,end)
    tlines = txt.splitlines(True)
    if which == 'flush':    keeplines = list(tlines)
    else:                   keeplines = []

    try:
        regex = re.compile(pattern)
        for n, z in enumerate(tlines):
            f = regex.findall(z)
            if which == 'flush' and f:
                keeplines [n] = None
            elif f:
                keeplines.append(z)
    except Exception, x:
        return
    if which == 'flush':
        keeplines = [x for x in keeplines if x != None]
    w.delete(i,end)
    w.insert(i,''.join(keeplines))
    w.mark_set('insert',i)</t>
<t tx="ekr.20050920084036.95">@others</t>
<t tx="ekr.20050920084036.96">def selectParagraph (self,event):

    k = self.k ; w = event.widget
    txt = w.get('insert linestart','insert lineend')
    txt = txt.lstrip().rstrip()
    i = w.index('insert')

    if not txt:
        while 1:
            i = w.index('%s + 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if txt:
                self.selectParagraphHelper(w,i) ; break
            if w.index('%s lineend' % i) == w.index('end'):
                return

    if txt:
        while 1:
            i = w.index('%s - 1 lines' % i)
            txt = w.get('%s linestart' % i,'%s lineend' % i)
            txt = txt.lstrip().rstrip()
            if not txt or w.index('%s linestart' % i) == w.index('1.0'):
                if not txt: i = w.index('%s + 1 lines' % i)
                self.selectParagraphHelper(w,i)
                break</t>
<t tx="ekr.20050920084036.97">def selectParagraphHelper (self,w,start):

    i2 = start
    while 1:
        txt = w.get('%s linestart' % i2,'%s lineend' % i2)
        if w.index('%s lineend' % i2) == w.index('end'):
            break
        txt = txt.lstrip().rstrip()
        if not txt: break
        else:
            i2 = w.index('%s + 1 lines' % i2)

    w.tag_add('sel','%s linestart' % start,'%s lineend' % i2)
    w.mark_set('insert','%s lineend' % i2)</t>
<t tx="ekr.20050920084036.98">def killParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    txt = w.get('insert linestart','insert lineend')

    if not txt.rstrip().lstrip():
        i = w.search(r'\w',i,regexp=True,stopindex='end')

    self.selectParagraphHelper(w,i)
    i2 = w.index('insert')
    c.killBufferCommands.kill(event,i,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20050920084036.99">def backwardKillParagraph (self,event):

    k = self.k ; c = k.c ; w = event.widget
    i = w.index('insert')
    i2 = i
    txt = w.get('insert linestart','insert lineend')
    if not txt.rstrip().lstrip():
        self.backwardParagraph(event)
        i2 = w.index('insert')
    self.selectParagraph(event)
    i3 = w.index('sel.first')
    c.killBufferCommands.kill(event,i3,i2)
    w.mark_set('insert',i)
    w.selection_clear()</t>
<t tx="ekr.20050920084036.100">def fillRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    s1 = w.index('sel.first')
    s2 = w.index('sel.last')
    w.mark_set('insert',s1)
    self.backwardParagraph(event)
    if w.index('insert linestart') == '1.0':
        self.fillParagraph(event)
    while 1:
        self.forwardParagraph(event)
        if w.compare('insert','&gt;',s2):
            break
        self.fillParagraph(event)</t>
<t tx="ekr.20050920084036.102">def backwardParagraph (self,event):
    
    self.backwardParagraphHelper (event,extend=False)
    
def backwardParagraphExtendSelection (self,event):
    
    self.backwardParagraphHelper (event,extend=True)
    
def forwardParagraph (self,event):

    self.forwardParagraphHelper(event,extend=False)
    
def forwardParagraphExtendSelection (self,event):
    
    self.forwardParagraphHelper(event,extend=True)</t>
<t tx="ekr.20050920084036.103">def fillParagraph( self, event ):
    k = self.k ; w = event.widget
    txt = w.get( 'insert linestart', 'insert lineend' )
    txt = txt.lstrip().rstrip()
    if txt:
        i = w.index( 'insert' )
        i2 = i
        txt2 = txt
        while txt2:
            pi2 = w.index( '%s - 1 lines' % i2)
            txt2 = w.get( '%s linestart' % pi2, '%s lineend' % pi2 )
            if w.index( '%s linestart' % pi2 ) == '1.0':
                i2 = w.search( '\w', '1.0', regexp = True, stopindex = 'end' )
                break
            if txt2.lstrip().rstrip() == '': break
            i2 = pi2
        i3 = i
        txt3 = txt
        while txt3:
            pi3 = w.index( '%s + 1 lines' %i3 )
            txt3 = w.get( '%s linestart' % pi3, '%s lineend' % pi3 )
            if w.index( '%s lineend' % pi3 ) == w.index( 'end' ):
                i3 = w.search( '\w', 'end', backwards = True, regexp = True, stopindex = '1.0' )
                break
            if txt3.lstrip().rstrip() == '': break
            i3 = pi3
        ntxt = w.get( '%s linestart' %i2, '%s lineend' %i3 )
        ntxt = self._addPrefix( ntxt )
        w.delete( '%s linestart' %i2, '%s lineend' % i3 )
        w.insert( i2, ntxt )
        w.mark_set( 'insert', i )</t>
<t tx="ekr.20050920084036.104">def fillRegionAsParagraph (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i1 = w.index('sel.first linestart')
    i2 = w.index('sel.last lineend')
    txt = w.get(i1,i2)
    txt = self._addPrefix(txt)
    w.delete(i1,i2)
    w.insert(i1,txt)</t>
<t tx="ekr.20050920084036.105">@others</t>
<t tx="ekr.20050920084036.106">def setRegion (self,event):

    mrk = 'sel'
    w = event.widget

    @others

    extend(event)
    w.bind('&lt;Right&gt;',extend,'+')
    w.bind('&lt;Left&gt;',truncate,'+')
    w.bind('&lt;Up&gt;',up,'+')
    w.bind('&lt;Down&gt;',down,'+')

    return 'break'</t>
<t tx="ekr.20050920084036.107">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20050920084036.108">def tabIndentRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    i = w.index('sel.first')
    i2 = w.index('sel.last')
    i = w.index('%s linestart' % i)
    i2 = w.index('%s linestart' % i2)
    while 1:
        w.insert(i,'\t')
        if i == i2: break
        i = w.index('%s + 1 lines' % i)</t>
<t tx="ekr.20050920084036.109">def countRegion (self,event):

    k = self.k ; w = event.widget

    txt = w.get('sel.first','sel.last')
    lines = 1 ; chars = 0
    for z in txt:
        if z == '\n': lines += 1
        else:         chars += 1

    k.setLabelGrey('Region has %s lines, %s character%s' % (
        lines,chars,g.choose(chars==1,'','s')))</t>
<t tx="ekr.20050920084036.110">def reverseRegion (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    txt.reverse()
    istart = is1.split('.')
    istart = int(istart[0])
    for z in txt:
        w.insert('%s.0' % istart,'%s\n' % z)
        istart = istart + 1
    w.mark_set('insert',ins)
    k.clearState()
    k.resetLabel()</t>
<t tx="ekr.20050920084036.111">def downCaseRegion (self,event):
    self.caseHelper(event,'low')

def upCaseRegion (self,event):
    self.caseHelper(event,'up')

def caseHelper (self,event,way):

    w = event.widget ; trange = w.tag_ranges('sel')

    if len(trange) != 0:
        text = w.get(trange[0],trange[-1])
        i = w.index('insert')
        if text == ' ': return
        w.delete(trange[0],trange[-1])
        if way == 'low': text = text.lower()
        if way == 'up':  text = text.upper()
        w.insert('insert',text)
        w.mark_set('insert',i)

    self.removeRKeys(w)</t>
<t tx="ekr.20050920084036.112"></t>
<t tx="ekr.20050920084036.113">def replaceString (self,event):

    k = self.k ; state = k.getState('replace-string')
    prompt = 'Replace ' + g.choose(self._useRegex,'Regex','String')

    if state == 0:
        self.widget = event.widget
        self._sString = self._rpString = ''
        s = '%s: ' % prompt
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',1,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',2,self.replaceString)
    elif state == 2:
        k.clearState()
        self._rpString = k.arg ; w = self.widget
        &lt;&lt; do the replace &gt;&gt;
        k.setLabelGrey('Replaced %s occurance%s' % (count,g.choose(count==1,'','s')))
        self._useRegex = False</t>
<t tx="ekr.20050920084036.114"># g.es('%s %s by %s' % (prompt,repr(self._sString),repr(self._rpString)),color='blue')
i = 'insert' ; end = 'end' ; count = 0
if w.tag_ranges('sel'):
    i = w.index('sel.first')
    end = w.index('sel.last')
if self._useRegex:
    txt = w.get(i,end)
    try:
        pattern = re.compile(self._sString)
    except:
        k.keyboardQuit(event)
        k.setLabel("Illegal regular expression")
        return
    count = len(pattern.findall(txt))
    if count:
        ntxt = pattern.sub(self._rpString,txt)
        w.delete(i,end)
        w.insert(i,ntxt)
else:
    # Problem: adds newline at end of text.
    txt = w.get(i,end)
    count = txt.count(self._sString)
    if count:
        ntxt = txt.replace(self._sString,self._rpString)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20050920084036.115">def activateReplaceRegex( self ):
    
    '''This method turns regex replace on for replaceString'''

    self._useRegex = True
    return True</t>
<t tx="ekr.20050920084036.116">def scrollDown (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) + chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')

def scrollUp (self,event):

    k = self.k ; w = event.widget
    chng = self.measure(w)
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) - chng [0]
    w.mark_set('insert','%s.%s' % (i1,i2))
    w.see('insert')</t>
<t tx="ekr.20050920084036.117">'''XEmacs provides several commands for sorting text in a buffer.  All
operate on the contents of the region (the text between point and the
mark).  They divide the text of the region into many "sort records",
identify a "sort key" for each record, and then reorder the records
using the order determined by the sort keys.  The records are ordered so
that their keys are in alphabetical order, or, for numerical sorting, in
numerical order.  In alphabetical sorting, all upper-case letters `A'
through `Z' come before lower-case `a', in accordance with the ASCII
character sequence.

   The sort commands differ in how they divide the text into sort
records and in which part of each record they use as the sort key.
Most of the commands make each line a separate sort record, but some
commands use paragraphs or pages as sort records.  Most of the sort
commands use each entire sort record as its own sort key, but some use
only a portion of the record as the sort key.

`M-x sort-lines'
     Divide the region into lines and sort by comparing the entire text
     of a line.  A prefix argument means sort in descending order.

`M-x sort-paragraphs'
     Divide the region into paragraphs and sort by comparing the entire
     text of a paragraph (except for leading blank lines).  A prefix
     argument means sort in descending order.

`M-x sort-pages'
     Divide the region into pages and sort by comparing the entire text
     of a page (except for leading blank lines).  A prefix argument
     means sort in descending order.

`M-x sort-fields'
     Divide the region into lines and sort by comparing the contents of
     one field in each line.  Fields are defined as separated by
     whitespace, so the first run of consecutive non-whitespace
     characters in a line constitutes field 1, the second such run
     constitutes field 2, etc.

     You specify which field to sort by with a numeric argument: 1 to
     sort by field 1, etc.  A negative argument means sort in descending
     order.  Thus, minus 2 means sort by field 2 in reverse-alphabetical
     order.

`M-x sort-numeric-fields'
     Like `M-x sort-fields', except the specified field is converted to
     a number for each line and the numbers are compared.  `10' comes
     before `2' when considered as text, but after it when considered
     as a number.

`M-x sort-columns'
     Like `M-x sort-fields', except that the text within each line used
     for comparison comes from a fixed range of columns.  An explanation
     is given below.

   For example, if the buffer contains:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     whether the file has changed on disk since it was last visited or
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.

then if you apply `M-x sort-lines' to the entire buffer you get:

     On systems where clash detection (locking of files being edited) is
     implemented, XEmacs also checks the first time you modify a buffer
     saved.  If it has, you are asked to confirm that you want to change
     the buffer.
     whether the file has changed on disk since it was last visited or

where the upper case `O' comes before all lower case letters.  If you
apply instead `C-u 2 M-x sort-fields' you get:

     saved.  If it has, you are asked to confirm that you want to change
     implemented, XEmacs also checks the first time you modify a buffer
     the buffer.
     On systems where clash detection (locking of files being edited) is
     whether the file has changed on disk since it was last visited or

where the sort keys were `If', `XEmacs', `buffer', `systems', and `the'.

   `M-x sort-columns' requires more explanation.  You specify the
columns by putting point at one of the columns and the mark at the other
column.  Because this means you cannot put point or the mark at the
beginning of the first line to sort, this command uses an unusual
definition of `region': all of the line point is in is considered part
of the region, and so is all of the line the mark is in.

   For example, to sort a table by information found in columns 10 to
15, you could put the mark on column 10 in the first line of the table,
and point on column 15 in the last line of the table, and then use this
command.  Or you could put the mark on column 15 in the first line and
point on column 10 in the last line.

   This can be thought of as sorting the rectangle specified by point
and the mark, except that the text on each line to the left or right of
the rectangle moves along with the text inside the rectangle.  *Note
Rectangles::.

'''
</t>
<t tx="ekr.20050920084036.118">def sortLines (self,event,which=None): # event IS used.

    k = self.k ; w = event.widget
    if not self._chckSel(event):
        return
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20050920084036.119">def sortColumns (self,event):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    sint1, sint2 = is1.split('.')
    sint2 = int(sint2)
    sint3, sint4 = is2.split('.')
    sint4 = int(sint4)
    txt = w.get('%s.0' % sint1,'%s.0 lineend' % sint3)
    w.delete('%s.0' % sint1,'%s.0 lineend' % sint3)
    columns = []
    i = int(sint1)
    i2 = int(sint3)
    while i &lt;= i2:
        t = w.get('%s.%s' % (i,sint2),'%s.%s' % (i,sint4))
        columns.append(t)
        i = i + 1
    txt = txt.split('\n')
    zlist = zip(columns,txt)
    zlist.sort()
    i = int(sint1)
    for z in xrange(len(zlist)):
         w.insert('%s.0' % i,'%s\n' % zlist[z][1])
         i = i + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20050920084036.120">def sortFields (self,event,which=None):

    k = self.k ; w = event.widget
    if not self._chckSel(event): return

    ins = w.index('insert')
    is1 = w.index('sel.first')
    is2 = w.index('sel.last')
    txt = w.get('%s linestart' % is1,'%s lineend' % is2)
    txt = txt.split('\n')
    fields = []
    fn = r'\w+'
    frx = re.compile(fn)
    for z in txt:
        f = frx.findall(z)
        if not which:
            fields.append(f[0])
        else:
            i = int(which)
            if len(f) &lt; i: return
            i = i-1
            fields.append(f[i])
    nz = zip(fields,txt)
    nz.sort()
    w.delete('%s linestart' % is1,'%s lineend' % is2)
    i = is1.split('.')
    int1 = int(i[0])
    for z in nz:
        w.insert('%s.0' % int1,'%s\n' % z[1])
        int1 = int1 + 1
    w.mark_set('insert',ins)</t>
<t tx="ekr.20050920084036.121"></t>
<t tx="ekr.20050920084036.122">def transposeLines (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = str(int(i1)-1)

    if i1 != '0':
        l2 = w.get('insert linestart','insert lineend')
        w.delete('insert linestart-1c','insert lineend')
        w.insert(i1+'.0',l2+'\n')
    else:
        l2 = w.get('2.0','2.0 lineend')
        w.delete('2.0','2.0 lineend')
        w.insert('1.0',l2+'\n')</t>
<t tx="ekr.20050920084036.123">def swapWords (self,event,swapspots):

    w = event.widget
    txt = w.get('insert wordstart','insert wordend')
    if txt == ' ': return
    i = w.index('insert wordstart')
    if len(swapspots) != 0:
        if w.compare(i,'&gt;',swapspots[1]):
            self.swapHelper(w,i,txt,swapspots[1],swapspots[0])
        elif w.compare(i,'&lt;',swapspots[1]):
            self.swapHelper(w,swapspots[1],swapspots[0],i,txt)
    else:
        swapspots.append(txt)
        swapspots.append(i)

def transposeWords (self,event):
    self.swapWords(event,self.swapSpots)

def swapHelper (self,w,find,ftext,lind,ltext):
    w.delete(find,'%s wordend' % find)
    w.insert(find,ltext)
    w.delete(lind,'%s wordend' % lind)
    w.insert(lind,ftext)
    self.swapSpots.pop()
    self.swapSpots.pop()
</t>
<t tx="ekr.20050920084036.124">def swapCharacters (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    c1 = w.get('insert','insert +1c')
    c2 = w.get('insert -1c','insert')
    w.delete('insert -1c','insert')
    w.insert('insert',c1)
    w.delete('insert','insert +1c')
    w.insert('insert',c2)
    w.mark_set('insert',i)

transposeCharacters = swapCharacters</t>
<t tx="ekr.20050920084036.126">def tabify (self,event):
    self.tabifyHelper (event,which='tabify')
    
def untabify (self,event):
    self.tabifyHelper (event,which='untabify')

def tabifyHelper (self,event,which):

    k = self.k ; w = event.widget
    if w.tag_ranges('sel'):
        i = w.index('sel.first')
        end = w.index('sel.last')
        txt = w.get(i,end)
        if which == 'tabify':
            pattern = re.compile(' {4,4}') # Huh?
            ntxt = pattern.sub('\t',txt)
        else:
            pattern = re.compile('\t')
            ntxt = pattern.sub('    ',txt)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20050920084036.131">def backSentence (self,event):
    
    self.backSentenceHelper(event,extend=False)
    
def backSentenceExtendSelection (self,event):
    
    self.backSentenceHelper(event,extend=True)
    
def forwardSentence (self,event):
    
    self.forwardSentenceHelper(event,extend=False)
    
def forwardSentenceExtendSelection (self,event):
    
    self.forwardSentenceHelper(event,extend=True)</t>
<t tx="ekr.20050920084036.132"></t>
<t tx="ekr.20050920084036.133">def setCommentColumn (self,event):

    cc = event.widget.index('insert')
    cc1, cc2 = cc.split('.')
    self.ccolumn = cc2</t>
<t tx="ekr.20050920084036.134">def indentToCommentColumn (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert lineend')
    i1, i2 = i.split('.')
    i2 = int(i2)
    c1 = int(self.ccolumn)

    if i2 &lt; c1:
        wsn = c1- i2
        w.insert('insert lineend',' '*wsn)
    if i2 &gt;= c1:
        w.insert('insert lineend',' ')
    w.mark_set('insert','insert lineend')</t>
<t tx="ekr.20050920084036.135">def deleteSpaces (self,event,insertspace=False):

    c = self.c
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    name = g.app.gui.widget_name(w)
    char = w.get('insert','insert + 1c ')
    if not char.isspace(): return
    
    if name.startswith('body'):
        oldText = w.get('1.0','end')
        oldSel = g.app.gui.getTextSelection(w)
        i = w.index('insert')
        wf = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
        wb = w.search(r'\w',i,stopindex='%s linestart' % i,regexp=True,backwards=True)
        if '' in (wf,wb): return
        w.delete('%s +1c' % wb,wf)
        if insertspace: w.insert('insert',' ')
        
        c.frame.body.onBodyChanged(undoType='delete-spaces',
            oldSel=oldSel,oldText=oldText,oldYview=None)</t>
<t tx="ekr.20050920084036.136">def exchangePointMark (self,event):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=False)
    if i != j:
        ins = w.index('insert')
        ins = g.choose(ins==i,j,i)
        g.app.gui.setInsertPoint(w,ins)
        g.app.gui.setTextSelection(w,i,j,insert=None)</t>
<t tx="ekr.20050920084036.137">def forwardSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    ins = w.index('insert')
    sel_i,sel_j = g.app.gui.getTextSelection(w)
    i = w.search('.','insert',stopindex='end')
    ins = i and '%s +1c' % i or 'end'
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20050920084036.138">def insertNewLine (self,event):

    k = self.k ; w = event.widget
    i = w.index('insert')
    w.insert('insert','\n')
    w.mark_set('insert',i)

insertNewline = insertNewLine
</t>
<t tx="ekr.20050920084036.139">def insertParentheses (self,event):

    k = self.k ; w = event.widget
    w.insert('insert','()')
    w.mark_set('insert','insert -1c')</t>
<t tx="ekr.20050920084036.140">def movePastClose (self,event):
    
    self.movePastCloseHelper(event,extend=False)
    
def movePastCloseExtendSelection (self,event):
    
    self.movePastCloseHelper(event,extend=True)</t>
<t tx="ekr.20050920084036.141">def removeBlankLines (self,event):
    
    '''The remove-blank-lines command removes lines containing nothing but
    whitespace. If there is a text selection, only lines within the selected
    text are affected; otherwise all blank lines in the selected node are
    affected.'''
    
    c = self.c ; undoType = 'Remove Blank Lines' ; p = c.currentPosition()
    result = []
    body = p.bodyString()
    hasSelection = c.frame.body.hasTextSelection()
    
    if hasSelection:
        head,lines,tail,oldSel,oldYview = c.getBodyLines()
        joinChar = '\n'
    else:
        head = tail = oldYview = None
        lines = g.splitLines(body)
        oldSel = ('1.0','1.0')
        joinChar = ''

    for line in lines:
        if line.strip():
            result.append(line)

    result = joinChar.join(result)
    
    if result != body:
        c.updateBodyPane(head,result,tail,undoType,oldSel,oldYview)</t>
<t tx="ekr.20050920084036.145">def changePreviousWord (self,event):

    k = self.k ; stroke = k.stroke ; w = event.widget
    i = w.index('insert')

    self.moveWordHelper(event,extend=False,forward=False)

    if stroke == '&lt;Alt-c&gt;':
        self.capitalizeWord(event)
    elif stroke == '&lt;Alt-u&gt;':
         self.upCaseWord(event)
    elif stroke == '&lt;Alt-l&gt;':
        self.downCaseWord(event)

    w.mark_set('insert',i)</t>
<t tx="ekr.20050920084036.147">def measure (self,w):
    i = w.index('insert')
    i1, i2 = i.split('.')
    start = int(i1)
    watch = 0
    ustart = start
    pone = 1
    top = i
    bottom = i
    while pone:
        ustart = ustart-1
        if ustart &lt; 0:
            break
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            top = ds
            watch = watch + 1
    pone = 1
    ustart = start
    while pone:
        ustart = ustart + 1
        ds = '%s.0' % ustart
        pone = w.dlineinfo(ds)
        if pone:
            bottom = ds
            watch = watch + 1

    return watch, top, bottom</t>
<t tx="ekr.20050920084036.148">def beginningOfBuffer (self,event):
    
    self.moveToHelper(event,'1.0',extend=False)
    
def beginningOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'1.0',extend=True)

def endOfBuffer (self,event):
    
    self.moveToHelper(event,'end',extend=False)
    
def endOfBufferExtendSelection (self,event):
    
    self.moveToHelper(event,'end',extend=True)
</t>
<t tx="ekr.20050920084036.149">def backwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=False)
    
def backwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=False)

def forwardWord (self,event):
    
    self.moveWordHelper(event,extend=False,forward=True)
    
def forwardWordExtendSelection (self,event):
    
    self.moveWordHelper(event,extend=True,forward=True)
</t>
<t tx="ekr.20050920084036.219">def findNextMatch (self,event):
    
    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k ; w = event.widget
    
    w.tag_delete('qR')

    if self.regexp:
        &lt;&lt; handle regexp &gt;&gt;
    else:
        &lt;&lt; handle plain search &gt;&gt;</t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    
    self.forward = True
    self.regexp = False

    # For replace-string and replace-regexp
    self._sString = ''
    self._rpString = ''
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':            self.hideFindTab,
        'open-find-tab':            self.openFindTab,
        'find-tab-find':            self.findTabFindNext,
        'find-tab-find-prev':       self.findTabFindPrev,
        'find-tab-change':          self.findTabChange,
        'find-tab-change-then-find':self.findTabChangeThenFind,

        'isearch-forward':          self.isearchForward,
        'isearch-backward':         self.isearchBackward,
        'isearch-forward-regexp':   self.isearchForwardRegexp,
        'isearch-backward-regexp':  self.isearchBackwardRegexp,
        
        're-search-forward':        self.reSearchForward,
        're-search-backward':       self.reSearchBackward,
        
        'search-forward':           self.searchForward,
        'search-backward':          self.searchBackward,
        'word-search-forward':      self.wordSearchForward,
        'word-search-backward':     self.wordSearchBackward,
    }</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.frame.minibufferWantsFocus()</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    s = k.getLabel(ignorePrompt=True)
    # g.trace(forward,repr(s))
    if s:
        try:
            if forward:
                i = w.search(s,"insert + 1c",stopindex='end',regexp=regexp)
                if not i:
                    # Start again at the top of the buffer.
                    i = w.search(s,'1.0',stopindex='insert',regexp=regexp)
            else:
                i = w.search(s,'insert',backwards=True,stopindex='1.0',regexp=regexp)
                if not i:
                    # Start again at the bottom of the buffer.
                    i = w.search(s,'end',backwards=True,stopindex='insert',regexp=regexp)
            
        except: pass

        if i and not i.isspace():
            w.mark_set('insert',i)
            w.see('insert')</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w ; keysym = event.keysym
    if keysym == 'Control_L': return
    
    c.frame.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        if 0: # Doesn't do anything at present.
            &lt;&lt; do a non-incremental search &gt;&gt;
        k.resetLabel()
        k.clearState()
        return

    if event.char == '\b':
        g.trace('backspace not handled yet')
        return
    
    if event.char:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        z = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if not z:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d
    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20050920084036.267"></t>
<t tx="ekr.20050920084036.268">def plainSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w ; i = w.index('insert')

    try:
        if forward:
            s = w.search(pattern,i,stopindex='end')
            if s: s = w.index('%s +%sc' % (s,len(pattern)))
        else:
            s = w.search(pattern,i,stopindex='1.0',backwards=True)
    except Exception:
        return

    if s:
        w.mark_set('insert',s)</t>
<t tx="ekr.20050920084036.269">def searchBackward (self,event):

    k = self.k ; state = k.getState('search-backward')
    if state == 0:
        k.setLabelBlue('Search Backward: ',protect=True)
        k.getArg(event,'search-backward',1,self.searchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=False)

def searchForward (self,event):

    k = self.k ; state = k.getState('search-forward')
    if state == 0:
        k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,'search-forward',1,self.searchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.272">def wordSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w ; i = w.index('insert')
    words = pattern.split()
    sep = '[%s%s]+' % (string.punctuation,string.whitespace)
    pattern = sep.join(words)
    cpattern = re.compile(pattern)
    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        if not match: return
        end = match.end()
    else:
        txt = w.get('1.0','insert') #initially the reverse words formula for Python Cookbook was going to be used.
        a = re.split(pattern,txt) #that didnt quite work right.  This one apparently does.
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return
        
    s = g.choose(forward,'insert +%sc','insert -%sc')
    w.mark_set('insert',s % end)
    w.see('insert')
</t>
<t tx="ekr.20050920084036.274">def reSearchBackward (self,event):

    k = self.k ; state = k.getState('re-search-backward')
    if state == 0:
        k.setLabelBlue('Regexp Search backward:',protect=True)
        k.getArg(event,'re-search-backward',1,self.reSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=False)

def reSearchForward (self,event):

    k = self.k ; state = k.getState('re-search-forward')
    if state == 0:
        k.setLabelBlue('Regexp Search:',protect=True)
        k.getArg(event,'re-search-forward',1,self.reSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.275">def reSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w
    cpattern = re.compile(pattern)

    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        end = match.end()
    else:
        # The reverse words formula for Python Cookbook didn't quite work.
        txt = w.get('1.0','insert') 
        a = re.split(pattern,txt)
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return

    if end:
        s = g.choose(forward,'insert +%sc','insert -%sc')
        w.mark_set('insert',s % end)
        w.see('insert')</t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20050920085536.11">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20050920085536.12">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c 

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    ## if shortcut == '&lt;None&gt;': return
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        # g.trace('Not bound',shortcut)
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return
        
    # g.trace(pane,shortcut,commandName)

    try:
        &lt;&lt; bind callback to shortcut in pane &gt;&gt;

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20050920085536.41">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20050920085536.45">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20050920085536.58">def quickCommand (self,event):
    
    '''Handle 'quick-command' (control-c) mode.'''
    
    k = self ; stroke = k.stroke ; state = k.getState('quick-command')
    
    if state == 0:
        k.setState('quick-command',1,handler=k.quickCommand)
        k.setLabelBlue('quick command: ',protect=True)
    else:
        k.previous.insert(0,event.keysym)
        if len(k.previous) &gt; 10: k.previous.pop()
        
        # g.trace('stroke',stroke,event.keysym)
        if stroke == '&lt;Key&gt;' and event.keysym == 'r':
            k.rCommand(event)
        elif stroke in ('&lt;Key&gt;','&lt;Escape&gt;'):
            if k.processKey(event): # Weird command-specific stuff.
                k.clearState()
        elif stroke in k.xcommands:
            k.clearState()
            k.xcommands [stroke](event)

        k.endCommand(event,stroke)
        
    return 'break'</t>
<t tx="ekr.20050920085536.63">def keyboardQuit (self,event):

    '''This method clears the state and the minibuffer label.
    
    k.endCommand handles all other end-of-command chores.'''
    
    k = self ; c = k.c

    if g.app.quitting:
        return
        
    c.frame.log.deleteTab('Completion')
    c.frame.log.deleteTab('Mode')
    k.inputModeName = None
        
    k.clearState()
    k.resetLabel()
    
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '&lt;Key&gt;'
    
    if c.config.getBool('trace_masterCommand'):
        g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        val = func(event)
        k.funcReturn = k.funcReturn or val # For unit tests.
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if 0: # Hurray.  This was a massive kludge.
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)</t>
<t tx="ekr.20050921094025">@nocolor</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.1">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
    
    self.rCommandDict = {
        'space':    c.registerCommands.pointToRegister,
        'a':        c.registerCommands.appendToRegister,
        'i':        c.registerCommands.insertRegister,
        'j':        c.registerCommands.jumpToRegister,
        'n':        c.registerCommands.numberToRegister,
        'p':        c.registerCommands.prependToRegister,
        'r':        c.rectangleCommands.enterRectangleState,
        's':        c.registerCommands.copyToRegister,
        'v':        c.registerCommands.viewRegister,
        'plus':     c.registerCommands.incrementRegister,
    }
    
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }
    
    self.xcommands = {
        '&lt;Control-t&gt;':  c.editCommands.transposeLines,
        '&lt;Control-u&gt;':  c.editCommands.upCaseRegion,
        '&lt;Control-l&gt;':  c.editCommands.downCaseRegion,
        '&lt;Control-o&gt;':  c.editCommands.removeBlankLines,
        '&lt;Control-i&gt;':  c.editFileCommands.insertFile,
        '&lt;Control-s&gt;':  c.editFileCommands.saveFile,
        '&lt;Control-x&gt;':  c.editCommands.exchangePointMark,
        '&lt;Control-c&gt;':  c.controlCommands.shutdown,
        '&lt;Control-b&gt;':  c.bufferCommands.listBuffers,
        '&lt;Control-Shift-at&gt;': lambda event: event.widget.selection_clear(),
        '&lt;Delete&gt;':     c.killBufferCommands.backwardKillSentence,
    }</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20050923183943.4">def processKey (self,event):
    
    '''Handle special keys in quickCommand mode.
    Return True if we should exit quickCommand mode.'''

    k = self ; c = k.c ; previous = k.previous
    
    if event.keysym in ('Shift_L','Shift_R'): return False
    # g.trace(event.keysym)

    func = k.variety_commands.get(event.keysym)
    if func:
        k.keyboardQuit(event)
        func(event)
        return True

    if event.keysym in ('a','i','e'):
        if k.processAbbreviation(event):
            return False # 'a e' or 'a i e' typed.
        
    if event.keysym == 'g': # Execute the abbreviation in the minibuffer.
        s = k.getLabel(ignorePrompt=True)
        if k.abbreviationFuncDict.has_key(s):
            k.clearState()
            k.keyboardQuit(event)
            k.abbreviationFuncDict [s](event)
            return True
    
    if event.keysym == 'e': # Execute the last macro.
        k.keyboardQuit(event)
        c.macroCommands.callLastKeyboardMacro(event)
        return True

    if event.keysym == 'x' and previous [1] not in ('Control_L','Control_R'):
        event.keysym = 's'
        k.setState('quick-command',1)
        c.registerCommands.setNextRegister(event)
        return True

    if event.keysym == 'Escape' and len(previous) &gt; 1 and previous [1] == 'Escape':
        k.repeatComplexCommand(event)
        return True
        
    else:
        return False</t>
<t tx="ekr.20050923183943.6">def processAbbreviation (self,event):
    
    '''Handle a e or a i e.
    Return True when the 'e' has been seen.'''
    
    k = self ; char = event.char

    if k.getLabel() != 'a' and event.keysym == 'a':
        k.setLabel('a')
        return False

    elif k.getLabel() == 'a':

        if char == 'i':
            k.setLabel('a i')
            return False
        elif char == 'e':
            event.char = ''
            k.expandAbbrev(event)
            return True
            
    return False</t>
<t tx="ekr.20050923213858"># Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20050925105522"></t>
<t tx="ekr.20050928144501.1">Needed to support 'mouseless-Leo':

- Set options from the keyboard.
    - set-variable sets a (Python) variable using an minibuffer-style variable name.
- Drive all tabs/dialogs from the keyboard,
- Scroll outline pane up/down
- Control all Leo commands &amp; widgets using only key commands.
- focus-in-body/tree/log/dialog.
- cycle-active-pane and cycle-active-widget (in a single pane) commands.
- activate-xxx-menu commands.  (alternative to XP Alt-f, Alt-E, etc.)
- create-tab, clear-tab commands, etc.
    These might get the tab name from the minibuffer...</t>
<t tx="ekr.20050929114218"></t>
<t tx="ekr.20050929115226">def gotoCharacter (self,event):

    k = self.k ; state = k.getState('goto-char')

    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto character: ')
        k.getArg(event,'goto-char',1,self.gotoCharacter)
    else:
        n = k.arg ; w = self.widget
        if n.isdigit():
            w.mark_set('insert','1.0 +%sc' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20050929124234">def gotoLine (self,event):

    k = self.k ; state = k.getState('goto-line')
    
    if state == 0:
        self.widget = event.widget
        k.setLabelBlue('Goto line: ')
        k.getArg(event,'goto-line',1,self.gotoLine)
    else:
        n = k.arg ;  w = self.widget
        if n.isdigit():
            w.mark_set('insert','%s.0' % n)
            w.see('insert')
        k.resetLabel()
        k.clearState()</t>
<t tx="ekr.20050929155208"></t>
<t tx="ekr.20051001050607">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not hasattr(c,'currentPosition'): return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20051001051355"></t>
<t tx="ekr.20051002095724">def keepLines (self,event):

    '''Delete each line that does not contain a match for regexp, operating on the text after point.

    In Transient Mark mode, if the region is active, the command operates on the region instead.'''

    k = self.k ; state = k.getState('keep-lines')
    
    if state == 0:
        k.setLabelBlue('Keep lines regexp: ',protect=True)
        k.getArg(event,'keep-lines',1,self.keepLines)
    else:
        k.clearState()
        k.resetLabel()
        self.linesHelper(event,k.arg,'keep')
        k.commandName = 'keep-lines %s' % k.arg</t>
<t tx="ekr.20051002102410">def down (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert','insert lineend')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)+1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert linestart -1c','insert')
        if self.inRange(w,mrk,l='-1c',r='+1c'):
            w.tag_remove(mrk,'1.0','insert')

    return 'break'</t>
<t tx="ekr.20051002102410.1">def extend (event):

    w = event.widget
    w.mark_set('insert','insert + 1c')

    if self.inRange(w,mrk):
        w.tag_remove(mrk,'insert -1c')
    else:
        w.tag_add(mrk,'insert -1c')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'

</t>
<t tx="ekr.20051002102410.2">def truncate (event):

    w = event.widget
    w.mark_set('insert','insert -1c')

    if self.inRange(w,mrk):
        self.testinrange(w)
        w.tag_remove(mrk,'insert')
    else:
        w.tag_add(mrk,'insert')
        w.tag_configure(mrk,background='lightgrey')
        self.testinrange(w)

    return 'break'</t>
<t tx="ekr.20051002102410.3">def up (event):

    w = event.widget

    if self.testinrange(w):
        w.tag_add(mrk,'insert linestart','insert')
        i = w.index('insert')
        i1, i2 = i.split('.')
        i1 = str(int(i1)-1)
        w.mark_set('insert',i1+'.'+i2)
        w.tag_add(mrk,'insert','insert lineend + 1c')
        if self.inRange(w,mrk,l='-1c',r='+1c') and w.index('insert') != '1.0':
            w.tag_remove(mrk,'insert','end')

    return 'break'</t>
<t tx="ekr.20051002111614">def wordSearchBackward (self,event):

    k = self.k ; state = k.getState('word-search-backward')
    if state == 0:
        k.setLabelBlue('Word Search Backward: ',protect=True)
        k.getArg(event,'word-search-backward',1,self.wordSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=False)

def wordSearchForward (self,event):

    k = self.k ; state = k.getState('word-search-forward')
    if state == 0:
        k.setLabelBlue('Word Search: ',protect=True)
        k.getArg(event,'word-search-forward',1,self.wordSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20051002120125">s = k.getLabel(ignorePrompt=True)

if s:
    if self.forward:
        if self.regexp: self.reSearchForward(event)
        else:           self.searchForward(event)
    else:
        if self.regexp: self.reSearchBackward(event)
        else:           self.searchBackward(event)</t>
<t tx="ekr.20051004102314">def rCommand (self,event):
    
    k = self ; state = k.getState('r-command') ; ch = event.keysym
    if state == 0:
        k.setLabel ('quick-command r: ',protect=True)
        k.setState('r-command',1,k.rCommand)
    elif ch in ('Control_L','Alt_L','Shift_L'):
        return
    else:
        k.clearState()
        
        # g.trace(repr(ch))
        func = k.rCommandDict.get(ch)
        if func:
            k.commandName = 'quick-command r: '
            k.resetLabel()
            func(event)
        else:
            k.setLabelGrey('Unknown r command: %s' % repr(ch))</t>
<t tx="ekr.20051005155611">try:
    regex = re.compile(self.qQ)
except:
    self.quitSearch(event,'Illegal regular expression')
    return False

txt = w.get('insert','end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    w.mark_set('insert','insert +%sc' % start)
    ### w.update_idletasks()
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    txt = w.get('insert','insert +%sc' % length)
    return True
else:
    self.quitSearch(event)
    return False</t>
<t tx="ekr.20051005160923">i = w.search(self.qQ,'insert',stopindex='end')
if i:
    w.mark_set('insert',i)
    ###w.update_idletasks()
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False</t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
&lt;&lt; set self.unboundKeyAction &gt;&gt;</t>
<t tx="ekr.20051006125633"></t>
<t tx="ekr.20051006125633.1">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20051007080058">def makeAllBindings (self):
    
    k = self ; c = k.c
    
    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings()
    k.makeBindingsFromCommandsDict()
    k.add_ekr_altx_commands()
    k.addModeCommands()
    k.checkBindings()</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20051008134059">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20051008135051.1">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20051008152134">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20051010062551.1">@

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.
    
inverseBindingsDict (computed by computeInverseBindingDict)
    keys are emacs command names, values are shortcuts.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are g.bunch(func,name,warningGiven)
</t>
<t tx="ekr.20051011072049.2">def cutText (self):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    
    # Update the widget and set the clipboard text.
    if i != j:
        s = w.get(i,j)
        w.delete(i,j)
        g.app.gui.replaceClipboardWith(s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Cut',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass

OnCutFromMenu = cutText</t>
<t tx="ekr.20051011072903.2">def copyText (self):
    
    '''Copy the selected text from the widget to the clipboard.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    if not w: return

    # Set the clipboard text.
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        s = w.get(i,j)
        g.app.gui.replaceClipboardWith(s)
        
OnCopyFromMenu = copyText</t>
<t tx="ekr.20051011072903.5">def pasteText (self):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = f.getFocus()
    if not w: return
    name = g.app.gui.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    
    if name.startswith('head'):
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
    
    # Update the widget.
    if i != j:
        w.delete(i,j)
    w.insert(i,s)

    if name.startswith('body'):
        c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
    elif name.startswith('head'):
        s = w.get('1.0','end')
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]
        # The headline is not officially changed yet.
        # p.initHeadString(s)
        w.configure(width=f.tree.headWidth(s=s))
    else: pass
    
OnPasteFromMenu = pasteText</t>
<t tx="ekr.20051011103654">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20051012053017.4">** Important: search headline option.
    
[iqr] incremental,query,regex
[fb] forward,back
[w] word
[c] case-sensitive
[hat] headline,all,body
[osn] outline,subtree,node

*Set defaults for all the above using commands.
set-word-search-on/off
set-search-case-on/off
set-regexp-search-on/off
set-wrap-search-on/off
set-search-scope-to-outline/subtree/node

** Search mode: Control keys could change these options *after* starting the search command.

- Script-search commands
script-search  (can we abort the search somehow?)
set-find-script
set-change-script

Apply incremental search commands to headlines.  This might be fast, but is it useful if nodes aren't visible?</t>
<t tx="ekr.20051012054228">- k.vimMode controls whether full-command keeps mini-buffer open after a command complete.

- k.fullCommand sets k.sets k.vimMode = c.config.getBool('vim-mode') on entry.

- Commands (like vim-insert-mode) clear k.vimMode to return to the body pane.

- control-g does not alter k.vimMode.

- Shift-control-g clears k.vimMode.
</t>
<t tx="ekr.20051012062458.1"></t>
<t tx="ekr.20051014152256">Improve import code so it handles stufff like this from Ipyton/iplib

### This should *not* terminate the function!

    self.LOGHEAD = Itpl(
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = $self.rc.opts
#log# args = $self.rc.args
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
""")

- Handle blanks better in imports:
    - Add tab_width keyword arg to import command.
    - Convert tabs to blanks if tab width &lt; 0.
- Ignore position of blank lines wrt sentinels.
- Ignore (optionally?) underindented blank lines.
- Use pyclbr to parse Python imports?</t>
<t tx="ekr.20051014161015"></t>
<t tx="ekr.20051015110547">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
        if verbose and ok:
             g.es_print('Registered %s bound to %s' % (
                commandName,k.prettyPrintKey(shortcut)),color='blue')
    else:
        if verbose:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20051015114221">def capitalizeWord (self,event):
    self.capitalizeHelper(event,'cap')

def downCaseWord (self,event):
    self.capitalizeHelper(event,'low')

def upCaseWord (self,event):
    self.capitalizeHelper(event,'up')</t>
<t tx="ekr.20051015114221.1">def capitalizeHelper (self,event,which):

    w = event.widget
    text = w.get('insert wordstart','insert wordend')
    i = w.index('insert')
    if text == ' ': return
    w.delete('insert wordstart','insert wordend')
    if which == 'cap':
        text = text.capitalize()
    if which == 'low':
        text = text.lower()
    if which == 'up':
        text = text.upper()
    w.insert('insert',text)
    w.mark_set('insert',i)
    
</t>
<t tx="ekr.20051016095907"></t>
<t tx="ekr.20051016095907.1"></t>
<t tx="ekr.20051016095907.2"></t>
<t tx="ekr.20051016101724.1">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    # c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    
    # New in 4.4b1: call update *after* creating the tab.
    tabFrame and tabFrame.update()

    return tabFrame</t>
<t tx="ekr.20051016101927">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...</t>
<t tx="ekr.20051016101927.1">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20051016103459">def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log</t>
<t tx="ekr.20051016155819"></t>
<t tx="ekr.20051017111216"></t>
<t tx="ekr.20051017140811.1"></t>
<t tx="ekr.20051017212057">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')</t>
<t tx="ekr.20051018061932"></t>
<t tx="ekr.20051018061932.1">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        logCtrl and logCtrl.update()
        self.c.frame.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        
        # New in 4.4b1: call update explicitly.
        logCtrl = self.textDict.get(tabName)
        if logCtrl:
            logCtrl.update()
            self.c.frame.widgetWantsFocus(logCtrl)</t>
<t tx="ekr.20051018072306">textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("&lt;Button-1&gt;",self.onActivateLog)
textWidget.tag_config('black',foreground='black')</t>
<t tx="ekr.20051018102027">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051019134106"></t>
<t tx="ekr.20051019134106.1">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu</t>
<t tx="ekr.20051019134422">def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)</t>
<t tx="ekr.20051019140004.1">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)</t>
<t tx="ekr.20051019165401">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)</t>
<t tx="ekr.20051019170806">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20051019172811">def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20051019183105"></t>
<t tx="ekr.20051019183105.1">def showColors (self,event):
    
    c = self.c ; log = c.frame.log ; tabName = 'Colors'
    
    &lt;&lt; define colors &gt;&gt;
    
    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        f = log.frameDict.get(tabName)
        self.createColorPicker(f,colors)
</t>
<t tx="ekr.20051019183105.2">colors = (
    "gray60", "gray70", "gray80", "gray85", "gray90", "gray95",
    "snow1", "snow2", "snow3", "snow4", "seashell1", "seashell2",
    "seashell3", "seashell4", "AntiqueWhite1", "AntiqueWhite2", "AntiqueWhite3",
    "AntiqueWhite4", "bisque1", "bisque2", "bisque3", "bisque4", "PeachPuff1",
    "PeachPuff2", "PeachPuff3", "PeachPuff4", "NavajoWhite1", "NavajoWhite2",
    "NavajoWhite3", "NavajoWhite4", "LemonChiffon1", "LemonChiffon2",
    "LemonChiffon3", "LemonChiffon4", "cornsilk1", "cornsilk2", "cornsilk3",
    "cornsilk4", "ivory1", "ivory2", "ivory3", "ivory4", "honeydew1", "honeydew2",
    "honeydew3", "honeydew4", "LavenderBlush1", "LavenderBlush2",
    "LavenderBlush3", "LavenderBlush4", "MistyRose1", "MistyRose2",
    "MistyRose3", "MistyRose4", "azure1", "azure2", "azure3", "azure4",
    "SlateBlue1", "SlateBlue2", "SlateBlue3", "SlateBlue4", "RoyalBlue1",
    "RoyalBlue2", "RoyalBlue3", "RoyalBlue4", "blue1", "blue2", "blue3", "blue4",
    "DodgerBlue1", "DodgerBlue2", "DodgerBlue3", "DodgerBlue4", "SteelBlue1",
    "SteelBlue2", "SteelBlue3", "SteelBlue4", "DeepSkyBlue1", "DeepSkyBlue2",
    "DeepSkyBlue3", "DeepSkyBlue4", "SkyBlue1", "SkyBlue2", "SkyBlue3",
    "SkyBlue4", "LightSkyBlue1", "LightSkyBlue2", "LightSkyBlue3",
    "LightSkyBlue4", "SlateGray1", "SlateGray2", "SlateGray3", "SlateGray4",
    "LightSteelBlue1", "LightSteelBlue2", "LightSteelBlue3",
    "LightSteelBlue4", "LightBlue1", "LightBlue2", "LightBlue3",
    "LightBlue4", "LightCyan1", "LightCyan2", "LightCyan3", "LightCyan4",
    "PaleTurquoise1", "PaleTurquoise2", "PaleTurquoise3", "PaleTurquoise4",
    "CadetBlue1", "CadetBlue2", "CadetBlue3", "CadetBlue4", "turquoise1",
    "turquoise2", "turquoise3", "turquoise4", "cyan1", "cyan2", "cyan3", "cyan4",
    "DarkSlateGray1", "DarkSlateGray2", "DarkSlateGray3",
    "DarkSlateGray4", "aquamarine1", "aquamarine2", "aquamarine3",
    "aquamarine4", "DarkSeaGreen1", "DarkSeaGreen2", "DarkSeaGreen3",
    "DarkSeaGreen4", "SeaGreen1", "SeaGreen2", "SeaGreen3", "SeaGreen4",
    "PaleGreen1", "PaleGreen2", "PaleGreen3", "PaleGreen4", "SpringGreen1",
    "SpringGreen2", "SpringGreen3", "SpringGreen4", "green1", "green2",
    "green3", "green4", "chartreuse1", "chartreuse2", "chartreuse3",
    "chartreuse4", "OliveDrab1", "OliveDrab2", "OliveDrab3", "OliveDrab4",
    "DarkOliveGreen1", "DarkOliveGreen2", "DarkOliveGreen3",
    "DarkOliveGreen4", "khaki1", "khaki2", "khaki3", "khaki4",
    "LightGoldenrod1", "LightGoldenrod2", "LightGoldenrod3",
    "LightGoldenrod4", "LightYellow1", "LightYellow2", "LightYellow3",
    "LightYellow4", "yellow1", "yellow2", "yellow3", "yellow4", "gold1", "gold2",
    "gold3", "gold4", "goldenrod1", "goldenrod2", "goldenrod3", "goldenrod4",
    "DarkGoldenrod1", "DarkGoldenrod2", "DarkGoldenrod3", "DarkGoldenrod4",
    "RosyBrown1", "RosyBrown2", "RosyBrown3", "RosyBrown4", "IndianRed1",
    "IndianRed2", "IndianRed3", "IndianRed4", "sienna1", "sienna2", "sienna3",
    "sienna4", "burlywood1", "burlywood2", "burlywood3", "burlywood4", "wheat1",
    "wheat2", "wheat3", "wheat4", "tan1", "tan2", "tan3", "tan4", "chocolate1",
    "chocolate2", "chocolate3", "chocolate4", "firebrick1", "firebrick2",
    "firebrick3", "firebrick4", "brown1", "brown2", "brown3", "brown4", "salmon1",
    "salmon2", "salmon3", "salmon4", "LightSalmon1", "LightSalmon2",
    "LightSalmon3", "LightSalmon4", "orange1", "orange2", "orange3", "orange4",
    "DarkOrange1", "DarkOrange2", "DarkOrange3", "DarkOrange4", "coral1",
    "coral2", "coral3", "coral4", "tomato1", "tomato2", "tomato3", "tomato4",
    "OrangeRed1", "OrangeRed2", "OrangeRed3", "OrangeRed4", "red1", "red2", "red3",
    "red4", "DeepPink1", "DeepPink2", "DeepPink3", "DeepPink4", "HotPink1",
    "HotPink2", "HotPink3", "HotPink4", "pink1", "pink2", "pink3", "pink4",
    "LightPink1", "LightPink2", "LightPink3", "LightPink4", "PaleVioletRed1",
    "PaleVioletRed2", "PaleVioletRed3", "PaleVioletRed4", "maroon1",
    "maroon2", "maroon3", "maroon4", "VioletRed1", "VioletRed2", "VioletRed3",
    "VioletRed4", "magenta1", "magenta2", "magenta3", "magenta4", "orchid1",
    "orchid2", "orchid3", "orchid4", "plum1", "plum2", "plum3", "plum4",
    "MediumOrchid1", "MediumOrchid2", "MediumOrchid3", "MediumOrchid4",
    "DarkOrchid1", "DarkOrchid2", "DarkOrchid3", "DarkOrchid4", "purple1",
    "purple2", "purple3", "purple4", "MediumPurple1", "MediumPurple2",
    "MediumPurple3", "MediumPurple4", "thistle1", "thistle2", "thistle3",
    "thistle4" )</t>
<t tx="ekr.20051019183105.3">def createColorPicker (self,parent,colors):
    
    colors = list(colors)
    bg = parent.cget('background')
    
    outer = Tk.Frame(parent,background=bg)
    outer.pack(side='top',fill='both',expand=1,pady=10)
    
    f = Tk.Frame(outer)
    f.pack(side='top',expand=0,fill='x')
    f1 = Tk.Frame(f) ; f1.pack(side='top',expand=0,fill='x')
    f2 = Tk.Frame(f) ; f2.pack(side='top',expand=1,fill='x')
    f3 = Tk.Frame(f) ; f3.pack(side='top',expand=1,fill='x')
    
    label = Tk.Text(f1,height=1,width=20)
    label.insert('1.0','Color name or value...')
    label.pack(side='left',pady=6)

    &lt;&lt; create optionMenu and callback &gt;&gt;
    &lt;&lt; create picker button and callback &gt;&gt;</t>
<t tx="ekr.20051019183105.4">colorBox = Pmw.ComboBox(f2,scrolledlist_items=colors)
colorBox.pack(side='left',pady=4)

def colorCallback (newName): 
    label.delete('1.0','end')
    label.insert('1.0',newName)
    try:
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=newName)
    except: pass # Ignore invalid names.

colorBox.configure(selectioncommand=colorCallback)</t>
<t tx="ekr.20051019183105.5">def pickerCallback ():
    rgb,val = tkColorChooser.askcolor(parent=parent,initialcolor=f.cget('background'))
    if rgb or val:
        # label.configure(text=val)
        label.delete('1.0','end')
        label.insert('1.0',val)
        for theFrame in (parent,outer,f,f1,f2,f3):
            theFrame.configure(background=val)

b = Tk.Button(f3,text="Color Picker...",
    command=pickerCallback,background=bg)
b.pack(side='left',pady=4)</t>
<t tx="ekr.20051019201809">def showFonts (self,event):

    c = self.c ; log = c.frame.log ; tabName = 'Fonts'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.createFontPicker(f)</t>
<t tx="ekr.20051019201809.1">def createFontPicker (self,parent):

    bg = parent.cget('background')
    font = self.getFont()
    &lt;&lt; create the frames &gt;&gt;
    &lt;&lt; create the family combo box &gt;&gt;
    &lt;&lt; create the size entry &gt;&gt;
    &lt;&lt; create the weight combo box &gt;&gt;
    &lt;&lt; create the slant combo box &gt;&gt;
    &lt;&lt; create the sample text widget &gt;&gt;
    &lt;&lt; create and bind the callbacks &gt;&gt;</t>
<t tx="ekr.20051019201809.2">names = tkFont.families()
names = list(names)
names.sort()
names.insert(0,'&lt;None&gt;')

familyBox = Pmw.ComboBox(f1,
    labelpos="we",label_text='Family:',label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=names)

familyBox.selectitem(0)
familyBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20051019201809.3">Tk.Label(f2,text="Size:",width=10,background=bg).pack(side="left")

sizeEntry = Tk.Entry(f2,width=4) ##,textvariable=sv)
sizeEntry.pack(side="left",padx=2,pady=2)
</t>
<t tx="ekr.20051019201809.4">weightBox = Pmw.ComboBox(f3,
    labelpos="we",label_text="Weight:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','normal','bold'])

weightBox.selectitem(0)
weightBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20051019201809.5">slantBox = Pmw.ComboBox(f4,
    labelpos="we",label_text="Slant:",label_width=10,
    label_background=bg,
    arrowbutton_background=bg,
    scrolledlist_items=['&lt;None&gt;','roman','italic'])

slantBox.selectitem(0)
slantBox.pack(side="left",padx=2,pady=2)</t>
<t tx="ekr.20051019201809.6">def getFont(self,family=None,size=12,slant='roman',weight='normal'):
    
    try:
        return tkFont.Font(family=family,size=size,slant=slant,weight=weight)
    except Exception:
        g.es("exception setting font")
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20051019201809.7">def setFont(self,familyBox,sizeEntry,slantBox,weightBox,label):
    
    d = {}
    for box,key in (
        (familyBox, 'family'),
        (None,      'size'),
        (slantBox,  'slant'),
        (weightBox, 'weight'),
    ):
        if box: val = box.get()
        else:
            val = sizeEntry.get().strip() or ''
            try: int(val)
            except ValueError: val = None
        if val and val.lower() not in ('none','&lt;none&gt;',):
            d[key] = val

    family=d.get('family',None)
    size=d.get('size',12)
    weight=d.get('weight','normal')
    slant=d.get('slant','roman')
    font = self.getFont(family,size,slant,weight)
    label.configure(font=font)</t>
<t tx="ekr.20051019202139">f = Tk.Frame(parent,background=bg) ; f.pack (side='top',expand=0,fill='both')
f1 = Tk.Frame(f,background=bg)     ; f1.pack(side='top',expand=1,fill='x')
f2 = Tk.Frame(f,background=bg)     ; f2.pack(side='top',expand=1,fill='x')
f3 = Tk.Frame(f,background=bg)     ; f3.pack(side='top',expand=1,fill='x')
f4 = Tk.Frame(f,background=bg)     ; f4.pack(side='top',expand=1,fill='x')</t>
<t tx="ekr.20051019202139.1">sample = Tk.Text(f,height=20,width=80,font=font)
sample.pack(side='left')

s = 'The quick brown fox\njumped over the lazy dog.\n0123456789'
sample.insert('1.0',s)</t>
<t tx="ekr.20051019202328">def fontCallback(event=None):
    self.setFont(familyBox,sizeEntry,slantBox,weightBox,sample)

for w in (familyBox,slantBox,weightBox):
    w.configure(selectioncommand=fontCallback)

sizeEntry.bind('&lt;Return&gt;',fontCallback)</t>
<t tx="ekr.20051020075416">menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)
        
    self.findTabHandler.bringToFront()</t>
<t tx="ekr.20051020120306.1">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020120306.2">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020120306.3">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020120306.4">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20051020120306.5"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind.leoFind):

    """A class that implements Leo's tkinter find tab."""

    @others</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None # To keep pychecker happy.
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020120306.12">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)

    for w in buttons:
        w.bindHotKey(ftxt)
        w.bindHotKey(ctxt)</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

# Use bigger boxes for scripts.
self.find_ctrl = ftxt = Tk.Text(
    fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
self.change_ctrl = ctxt = Tk.Text(
    cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") 
ftxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    c = self.c
    c.frame.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&amp;Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap &amp;Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ('Clone Find All',  self.dict['clone_find_all']),
    ("Mark Finds",      self.dict["mark_finds"]),
    ("Mark &amp;Changes",   self.dict["mark_changes"]),
    ('Show Context',    self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051020120306.19">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020120306.20">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020120306.21">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20051020120306.22">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.frame.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.frame.widgetWantsFocus(t)</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"</t>
<t tx="ekr.20051020120306.28">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl	
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051021091958">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20051022094136"># Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or '').lower(),[])

if shortcut == '&lt;Key&gt;':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20051022142249"></t>
<t tx="ekr.20051022144825">def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus()

def focusToLog (self,event):

    self.c.frame.logWantsFocus()
    
def focusToMinibuffer (self,event):
    
    self.c.frame.minibufferWantsFocus()

def focusToTree (self,event):
    
    self.c.frame.treeWantsFocus()</t>
<t tx="ekr.20051022144825.1">def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i &gt;= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane)</t>
<t tx="ekr.20051022152427"></t>
<t tx="ekr.20051022162730">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    w = self.textDict.get(tabName)

    if k and w:
        k.copyBindingsToWidget(['all','log','text'],w)

        # A wretched kludge: put the bindings in the tab!
        # We can't seem to get focus away from it.
        tab = self.nb.tab(tabName) # b is a Tk.Button.
        k.copyBindingsToWidget(['all','log','text'],tab)</t>
<t tx="ekr.20051022211617"></t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)
</t>
<t tx="ekr.20051023182326">def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes

    # Keys are requests, values are list of panes that match.
    matchingPanesDict = {
        'all':  ['all','body','log','mini','text','tree'],
        'body': ['all','body'],
        'log':  ['all','log'],
        # 'menu': [menu], # Not used.  Probably dubious.
        'mini': ['all','mini'],                   
        'text': ['all','body','log','text'],  # Text = body+log
        'tree': ['all','tree'],
    }

    matchingPanes = []
    for pane in panes:
        matches = matchingPanesDict.get(pane,[])
        for match in matches:
            if match not in matchingPanes:
                matchingPanes.append(match)

    # g.trace(widget._name,'matchingPanes',matchingPanes,g.callers(3))
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in matchingPanes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('**binding',bunch.pane,shortcut,commandName,widget._name)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                __pychecker__ = '--no-argsused' # widget and commandName.
                # g.trace(commandName,func,g.app.gui.widget_name(widget))
                func(event)
                return 'break'

            widget.bind(shortcut,textBindingsRedirectionCallback)
            
    # New in 4.4a5: create the all-purpose binding.
    # This allows Leo always to return 'break' in key handlers.
    widget.bind('&lt;Key&gt;',k.onTextWidgetKey)</t>
<t tx="ekr.20051023183028">def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'</t>
<t tx="ekr.20051023192433">- Convert Emacs-Style Names to Menu Style Names when creating undo name.

- Examine scheme for duplicate shortcuts.
        - At present, a single command can be bound only once.
        - It's not a horrible restriction...
    
- The colerer is calling c.config too much?</t>
<t tx="ekr.20051024102724"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas,name='dummyHeadBindingWidget')
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20051024173701">def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    &lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;
    &lt;&lt; Create the tab's text widget &gt;&gt;
    self.setTabBindings(tabName)
    
    # New in 4.4b1: call update explicitly.
    textWidget and textWidget.update()</t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.change()
    
def changeThenFindCommand(self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.changeThenFind()</t>
<t tx="ekr.20051025071455">@others
</t>
<t tx="ekr.20051025071455.1">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others</t>
<t tx="ekr.20051025071455.6">class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others

</t>
<t tx="ekr.20051025071455.7"></t>
<t tx="ekr.20051025071455.8">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = c.config.getString('aspell_dir')
    self.aspell_bin_dir = c.config.getString('aspell_bin_dir')

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)
        
    self.aspell = aspell
    if aspell:
        self.sc = aspell.spell_checker(prefix=self.aspell_dir,lang=local_language_code)
        self.local_language_code = local_language_code
        self.local_dictionary_file = local_dictionary_file
        self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file) [0]</t>
<t tx="ekr.20051025071455.10">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it    
    """

    if self.sc.check(word):
        return None
    else:
        return self.sc.suggest(word)</t>
<t tx="ekr.20051025071455.11">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False</t>
<t tx="ekr.20051025071455.16">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d</t>
<t tx="ekr.20051025071455.18">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others</t>
<t tx="ekr.20051025071455.19"></t>
<t tx="ekr.20051025071455.20">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()</t>
<t tx="ekr.20051025071455.22">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20051025071455.23">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')</t>
<t tx="ekr.20051025071455.24"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="ekr.20051025071455.29"></t>
<t tx="ekr.20051025071455.30">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()</t>
<t tx="ekr.20051025071455.31">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()</t>
<t tx="ekr.20051025071455.32">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
</t>
<t tx="ekr.20051025071455.33">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    self.find()
    self.updateButtons()
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025071455.34">def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()</t>
<t tx="ekr.20051025071455.36"></t>
<t tx="ekr.20051025071455.37">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.38">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.frame.widgetWantsFocus(t)
            return True

    # The focus must never leave the body pane.
    c.frame.widgetWantsFocus(t)
    return False</t>
<t tx="ekr.20051025071455.40">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.frame.bodyWantsFocus()
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])</t>
<t tx="ekr.20051025071455.41">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.42"></t>
<t tx="ekr.20051025071455.43">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')</t>
<t tx="ekr.20051025071455.44">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1) 

</t>
<t tx="ekr.20051025071455.45">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word</t>
<t tx="ekr.20051025071455.46">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue</t>
<t tx="ekr.20051025071455.47"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as é.  I don't know what the solution is.
    word_start = string.letters
    word_end   = string.letters + string.digits
    word_chars = string.letters + string.digits + "`" + "'" + "_"
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and line[i] not in word_start:
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.</t>
<t tx="ekr.20051025071455.48">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None</t>
<t tx="ekr.20051025071455.49">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)</t>
<t tx="ekr.20051025071455.50">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.frame.bodyWantsFocus()
</t>
<t tx="ekr.20051025071455.51">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025071455.52">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')</t>
<t tx="ekr.20051025080056">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.</t>
<t tx="ekr.20051025080420">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }</t>
<t tx="ekr.20051025080420.1"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.frame.bodyWantsFocus()

def ignore (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()</t>
<t tx="ekr.20051025080633">def openSpellTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()</t>
<t tx="ekr.20051025094004">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = Aspell(c,dictionaryFileName,self.local_language_code)
    
    if not self.aspell.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
</t>
<t tx="ekr.20051025120920">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            if 1:
                junk, bunchList = c.config.getShortcut(commandName)
                for bunch in bunchList:
                    accel = bunch.val
                    shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                    if shortcut:
                        # g.trace(shortcut,commandName)
                        w.bind(shortcut,func)
            else:
                junk, bunch = c.config.getShortcut(commandName)
                accel = bunch and bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
                    
                </t>
<t tx="ekr.20051025121408">def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []</t>
<t tx="ekr.20051025144611"></t>
<t tx="ekr.20051025144611.1">@nocolor</t>
<t tx="ekr.20051025144611.2">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="ekr.20051025144611.3">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="ekr.20051025144611.4">&lt;&lt; docstring &gt;&gt;
&lt;&lt;imports&gt;&gt;
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;

#These two global determine if the autocompleter and calltip systems are used.  Default is on.
useauto = 1
usecall = 1

&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others</t>
<t tx="ekr.20051025144611.5">'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''</t>
<t tx="ekr.20051025144611.6">## import leoTkinterFrame 

import sets 
import threading
import weakref</t>
<t tx="ekr.20051025144611.7">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.</t>
<t tx="ekr.20051025144611.8">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="ekr.20051025144611.10">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information

context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode</t>
<t tx="ekr.20051025144611.11">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.</t>
<t tx="ekr.20051025144611.12">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20051025144611.13">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
</t>
<t tx="ekr.20051025144611.14"># This section defines patterns for calltips.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats ['python'] = re.compile(r'def\s+%s' % end)

pats ['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
        space, space, end))

pats ['perl'] = re.compile(r'sub\s+%s' % end)

pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (space,end))

pats ['c'] = re.compile(r'\w+%s%s' % (space,end))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits + string.letters + r

ripout = string.punctuation + string.whitespace + '\n'
ripout = ripout.replace('_','')

okchars = {}
for z in string.ascii_letters:
    okchars [z] = z
okchars ['_'] = '_'</t>
<t tx="ekr.20051025144611.15">def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20051025144611.16">watchitems = ('.',')')
txt_template = '%s%s%s'

def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.
    Certain chars activate the text scanning code.'''
    global lang
    if not (event.char.isspace() or event.char in watchitems):
        return
        
@
This if statement ensures that attributes set in another node are put in the
database.Of course the user has to type a whitespace to make sure it happens.
We try to be selective so that we dont burn through the scanText def for  every
whitespace char entered.This will help when the nodes become big.
@c
    bCtrl = event.widget
    if event.char.isspace():
        # Do nothing if the previous char was a whitespace
        if bCtrl.get('insert -1c').isspace(): return
        if bCtrl.get('insert -1c wordstart -1c') != '.': return
    c = bCtrl.commander
    lang = c.frame.body.getColorizer().language
    txt = txt_template % (
        bCtrl.get("1.0",'insert'),
        event.char, bCtrl.get('insert',"end"))
        # Add the newest char; its not in the bCtrl yet
    scanText(txt)</t>
<t tx="ekr.20051025144611.17">def scanText (txt):

    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)</t>
<t tx="ekr.20051025144611.18">def scanForAutoCompleter (txt):
    
    '''This function scans text for the autocompleter database.'''

    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b )
            # we are using the experimental DictSet class here.
            # usage removed the above statements
            # notice we have cut it down to one line of code here!</t>
<t tx="ekr.20051025144611.19">def scanForCallTip (txt):

    '''this function scans text for calltip info'''

    # pat2 = pats['python']
    # if lang:
        # if pats.has_key(lang):
            # pat2 = pats[lang]

    pat2 = pats.get(lang or 'python')
    g2 = pat2.findall(txt) or []

    for z in g2:
        if isinstance(z,tuple):
            z = z [0]
        pieces2 = z.split('(')
        pieces2 [0] = pieces2 [0].split() [ -1]
        a, b = pieces2 [0], pieces2 [1]
        calltips [lang][a].add(z)</t>
<t tx="ekr.20051025144611.20">def makeAutocompletionList (a,b,glist):
    
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 

</t>
<t tx="ekr.20051025144611.21">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20051025144611.22">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20051025144611.23">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
</t>
<t tx="ekr.20051025144611.24">#These functions determine if the config and language files have been read or not.
# No need to read it more than once.

def hasReadConfig():
    return configfilesread

def setReadConfig():
    global configfilesread
    configfilesread = True</t>
<t tx="ekr.20051025144611.25">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20051025144611.26">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="ekr.20051025144611.27">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20051025144611.28">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20051025144611.29">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20051025144611.30">def unbind (context):

    '''This method turns everything off and removes the calltip and autobox from the canvas.'''

    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map(context.unbind,(
            "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;", "&lt;Alt_R&gt;"))
        context.unbind_all('&lt;Button&gt;')
        context.update_idletasks()</t>
<t tx="ekr.20051025144611.31">def moveSelItem (event, context ):

    '''Move the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1  ## Can't be correct.
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:
        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="ekr.20051025144611.32">def processKeyStroke (event,context,body):

    '''Take action based on the state of context (a Tk.Canvas) and the event'''
    
    autobox = context.autobox

    if not context.on or event.keysym in ("??","Shift_L","Shift_R"):
        return None
    elif testForUnbind(event,context):
        unbind(context)
        return None
    elif context.which == 1:
        return None # It is calltip time.
        
    index = body.index('insert-1c wordstart')
    pat = body.get(index,'insert') + event.char
    pat = pat.lstrip('.')
    ww = list(autobox.get(0,'end'))
    aList = reducer(ww,pat)
    if not aList: return None
    # Select which item to select based on what the user has typed.
    i = ww.index(aList[0])
    # Set the current selection to match what the user has typed.
    autobox.select_clear(0,'end') 
    autobox.select_set(i)
    autobox.see(i)
    return 'break'</t>
<t tx="ekr.20051025144611.33">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="ekr.20051025144611.34">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20051025144611.35">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="ekr.20051025144611.36">def add_bindings( context, body ):
    
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''
    
    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )
</t>
<t tx="ekr.20051025144611.37">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20051025144611.38">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20051025144611.39">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20051025144611.40">def newCreateControl (self,frame,parentFrame):
    '''A decoration of the createControl def.
    We set up the ancestory of the control so we can draw
    widgets over the Text editor without disturbing the text.'''

@
Creating the background:
- We now use a placer: simpler to use and more efficient.
- We have to decorate the Tk.Text widget with a constructor that creates an
  intermediate Frame for the Text to be placed instead of packed.
  Had no idea that the placer could do this so nicely.
  With a couple changes in 3 places, we are using the placer !
@c
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init (self,master,*args,**kwords):

        context = Tk.Frame(master)
            #This is what we need to put in before the text to make place work.
        orig_init(self,context,*args,**kwords)

    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame,parentFrame) #orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init

    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack(expand=1,fill='both',after=frame.bodyBar) #We have to add it to the environment, since we pass on it in the __init__
    body.place(relwidth=1.0,relheight=1.0)
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets(context)
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler (event,context=context,body=body):
        processKeyStroke(event,context,body)
    def addItemHandler (event,context=context,body=body,colorizer=frame.body):
        add_item(event,context,body,colorizer.getColorizer())

    for z in (watcher,processKeyStrokeHandler,addItemHandler):
        context.bind("&lt;Key&gt;",z,'+')

    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr(context,'autobox'):
        ignore.append(context.autobox.component('listbox'))
        ignore.append(context.autobox.component('vertscrollbar'))
    def do_unbind (event):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind(context)

    context.do_unbind = do_unbind

    # This part protects this plugin from others that use Alt-Up, Alt-Down.
    # The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt (event):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ('&lt;Alt-Up&gt;','&lt;Alt-Down&gt;'): context.block_alt.bind(z,block_alt)

    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append(context.bindtags()[0])
    ctags.append(context.block_alt.bindtags()[0])
    ctags.extend(body.bindtags())
    body.bindtags(tuple(ctags))

    return body

</t>
<t tx="ekr.20051025144611.41">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []

    if useauto:
        context.autobox = Pmw.ScrolledListBox(
            context ,hscrollmode='none',
            listbox_selectbackground='#FFE7C6',
            listbox_selectforeground='blue',
            listbox_background='white',
            listbox_foreground='blue',
            vertscrollbar_background='#FFE7C6',
            vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):
        #This def makes removing the autobox or calltip label easy.
        # No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()

    context.clean_editor = clean_editor</t>
<t tx="ekr.20051025144611.42">def onOpenWindow ():

    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="ekr.20051025170832"></t>
<t tx="ekr.20051025170832.1"></t>
<t tx="ekr.20051026083544">def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = g.app.gui.widget_name(w)
   
    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        return c.editCommands.selfInsertCommand(event)
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20051026083544.2">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20051026083733.6">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20051026083733.7">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20051026092433">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20051026092433.1">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget or g.app.gui.get_focus(c.frame)
    if not g.app.gui.isTextWidget(w): return
    
    name = g.app.gui.widget_name(w)
    oldText = w.get('1.0','end')
    i,j = oldSel = g.app.gui.getTextSelection(w)
  
    if name.startswith('body'):
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        if i != j:
            w.delete(i,j)
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        c.frame.body.onBodyChanged(undoType='Typing',
            oldSel=oldSel,oldText=oldText,oldYview=None)
    else:
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')</t>
<t tx="ekr.20051026092746">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20051026143009">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True</t>
<t tx="ekr.20051026171121">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20051026171121.1"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20051027105304"></t>
<t tx="ekr.20051027114433">def getSelectedTab (self):
    
    return self.tabName</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20051028061546"></t>
<t tx="ekr.20051028061611.1">Revise:
    moveWordHelper
    findNextMatch

- Options to tell search commands whether search a single node, a subtree or the entire outline.

- (Maybe) a default-search-command.

- Expand 'point' so it indicates node as well as text location.</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051101161545"></t>
<t tx="ekr.20051103091115.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3411067
By: rogererens

Also, in the settings of Find/Change, I would choose for grouping the settings
node_only, search_body, search_headline, wrap (and possibly the whole_word option
also) together under search extent radio buttons. Although this organizational
mode mentions radio buttons, check boxes are used for selection_only and
suboutline_only, which I can enable both at the same time.
It's also not (yet?) very clear to me how selection_only, suboutline_only, node_only
(should) interact...</t>
<t tx="ekr.20051103094005"></t>
<t tx="ekr.20051104051733">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3412640
By: btheado

Currently clicking on the minibuffer and typing text has no effect.  Kinda confusing
until the Alt-x binding I discovered that Alt-x is the way to access the minibuffer
command mode.

It would be nice if the &lt;FocusIn&gt; binding on the minibuffer widget were equivilent
to Alt-x.</t>
<t tx="ekr.20051104152338"></t>
<t tx="ekr.20051104152338.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3413805
By: nobody

I thought this might be for 4.4a2, but I see the same effect w/ 
Leo 4.3.3, build  1.282 , September 17, 2005
Python 2.3.5, Tk 8.4.7, win32

I haven't used Leo for code, but just started to try to re-organize some Perl
I inherited.

Leo apears to remove sentinels, AND preceding newlines, so the effect is something
like this:

.... some code....

   next line;
}
#@ leo sentinel here...
#

    If  ( something ) {
      more code;
......

becomes:

.... some code....

   next line;
} If  ( something ) {
      more code;
......

Now, that may be annoying, but mildly so - it still runs.
When this:

#
#@ sentinel
if () {

turns to this:

# if() {

code just breaks.</t>
<t tx="ekr.20051105073850"></t>
<t tx="ekr.20051106040126">def executeMinibufferCommand (self,commandName):
    
    c = self ; k = c.keyHandler
    
    func = c.commandsDict.get(commandName)
    
    if func:
        event = g.Bunch(char='',keysym=None,widget=c.frame.body.bodyCtrl)
        stroke = None
        k.masterCommand(event,func,stroke)
        return k.funcReturn
    else:
        g.trace('no such command: %s' % (commandName),color='red')
        return None</t>
<t tx="ekr.20051110155735.1">@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color</t>
<t tx="ekr.20051111065016">@ Ripping focus away from widgets is odious and bug prone.

A much better solution: call update *after* log-pane operations.</t>
<t tx="ekr.20051112075511">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3424153
By: rogererens

Perhaps you've got this already lurking, but let me offer one other suggestion:

When reverting the search direction, it would be better to place the cursor
'on the other side' of the current hit, and then proceed to find the next occurrence
of &lt;pattern&gt;. At the current state of affairs, searching in the reverse direction
first finds the current occurrence _again_, just placing the cursor on the other
side of the higlighted selection.

This suggestion is based on the way searching in Vim works.
</t>
<t tx="ekr.20051112080017">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?

EKR: This is on the list of unfixable bugs, but I have a hard time believing there is no workaround.</t>
<t tx="ekr.20051113080509"></t>
<t tx="ekr.20051113090322">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)</t>
<t tx="ekr.20051120180644"></t>
<t tx="ekr.20051120180644.1"></t>
<t tx="ekr.20051120180644.2"></t>
<t tx="ekr.20051120181015"></t>
<t tx="ekr.20051121060445">@nocolor

   `C-M-o' (`split-line') moves the text from point to the end of the
line vertically down, so that the current line becomes two lines.
`C-M-o' first moves point forward over any spaces and tabs.  Then it
inserts after point a newline and enough indentation to reach the same
column point is on.  Point remains before the inserted newline; in this
regard, `C-M-o' resembles `C-o'.

   To join two lines cleanly, use the `Meta-^' (`delete-indentation')
command to delete the indentation at the front of the current line, and
the line boundary as well.  Empty spaces are replaced by a single
space, or by no space if at the beginning of a line, before a close
parenthesis, or after an open parenthesis.  To delete just the
indentation of a line, go to the beginning of the line and use `Meta-\'
(`delete-horizontal-space'), which deletes all spaces and tabs around
the cursor.

`indent-rigidly' moves all the lines in the region right by its
argument (left, for negative arguments).  The whole group of lines moves
rigidly sideways, which is how the command gets its name.

</t>
<t tx="ekr.20051121070552"></t>
<t tx="ekr.20051122104219">def prettyPrintKey (self,key):
    
    '''Convert whatever-Z to whatever-Shift-Z'''
    
    if not key:
        return ''
        
    ch = key[-2]

    if ch in string.ascii_uppercase:
        return '%sShift-%s&gt;' % (key[:-2],ch.lower())
    else:
        return key</t>
<t tx="ekr.20051123055200"></t>
<t tx="ekr.20051125080855">def selfInsertCommand(self,event):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20051126122638">- Use typing completion to select desired word.
- No auto-scan: use database instead.
- Scan button does manual scan.
- Use import or inspect instead of text scan.
- @strings autocompleter-info
list of names for which classes are known: c,frame,g,k,p,t,tree,v etc.
  (Autocompleter may already do this)
</t>
<t tx="ekr.20051126122952.1">def autoComplete (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    self.widget = w = event and event.widget 
    self.prefix = gui.getSelectedText(w) or ''
    self.text = gui.getAllText(w)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.
    self.membersList = c.commandsDict.keys() ## Testing only.
    k.setState('auto-completer',1,handler=self.stateHandler)
    self.computeCompletionList()</t>
<t tx="ekr.20051126123149">def computeCompletionList (self):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.frame.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    if s:
        self.tabList,common_prefix = g.itemsMatchingPrefixInList(s,self.membersList)
        c.frame.log.clearTab('Completion') # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            g.es('%s' % (name),tabName='Completion')</t>
<t tx="ekr.20051126123249">class autoCompleterCommandsClass (baseEditCommandsClass):
    
    '''Similar to typing completion in the minibuffer,
    but the presently selected completion is shown in the widget itself.'''

    @others</t>
<t tx="ekr.20051126123249.1">def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051126123759"></t>
<t tx="ekr.20051126123759.1">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.c = c
    self.k = c.keyHandler
    self.membersList = None
    self.prefix = None
    self.tabList = []
    self.tabListIndex = -1
    self.text = None # For Escape.
    self.widget = None</t>
<t tx="ekr.20051126123759.2">def getPublicCommands (self):

    k = self.k

    return {
        'auto-complete':    self.autoComplete,
    }</t>
<t tx="ekr.20051126124705">def stateHandler (self,event):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.widget
    keysym = event and event.keysym
    ch = event and event.char or ''
    # g.trace(repr(ch),repr(keysym))
    if keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.finish()
    elif keysym == 'Escape':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif ch in string.printable:
        self.extendSelection(ch)
        s = gui.getSelectedText(w)
        if s.startswith(self.prefix):
            self.prefix = self.prefix + ch
            # g.trace('prefix',self.prefix)
        self.computeCompletionList()</t>
<t tx="ekr.20051126125950">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return None</t>
<t tx="ekr.20051126131103">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    self.prefix = self.prefix[:-1]
    self.setSelection(self.prefix)
    self.computeCompletionList()</t>
<t tx="ekr.20051126171929">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20051127065601">def extendSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
    else:
        i = j = gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127070018">def setSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = gui.getInsertPoint(w)
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127105102">def finish (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    i,j = gui.getTextSelection(w)
    if i != j:
        gui.setTextSelection(w,j,j)</t>
<t tx="ekr.20051127105431">def abort (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    
    c.frame.widgetWantsFocus(w)

    w.delete('1.0','end')
    w.insert('1.0',self.text)
    gui.setTextSelection(w,'1.0','1.0')</t>
<t tx="ekr.20051129095023"></t>
<t tx="ekr.20051202094427">Investigate meld:  http://meld.sourceforge.net/</t>
<t tx="ekr.20051202095626">Use docstrings as the help message.</t>
<t tx="ekr.20051202100658"></t>
<t tx="ekr.20051202102337">@nocolor</t>
<t tx="ekr.20051202102337.1">auto-complete command is merely a prototype.</t>
<t tx="ekr.20051202102337.2">ok:

list-buffers

Not ready yet:

append-to-buffer
copy-to-buffer
insert-to-buffer
kill-buffer
prepend-to-buffer
rename-buffer       probably should change headline too
switch-to-buffer    use typing completion to get node name (headline)</t>
<t tx="ekr.20051202102337.3">advertised-undo
keyboard-quit
iconify-frame
save-buffers-kill-leo
shell-command
shell-command-on-region
suspend</t>
<t tx="ekr.20051202102337.4">back-sentence
back-to-indentation
backward-char
backward-delete-char
backward-kill-paragraph
backward-paragraph
backward-word
beginning-of-buffer
beginning-of-line
capitalize-word
center-line
center-region
count-region
cycle-focus
dabbrev-completion
dabbrev-expands
delete-char
delete-indentation
delete-spaces
downcase-region
downcase-word
end-of-buffer
end-of-line
escape
eval-expression
exchange-point-mark
fill-paragraph
fill-region
fill-region-as-paragraph
flush-lines
focus-to-body
focus-to-log
focus-to-minibuffer
focus-to-tree
forward-char
forward-paragraph
forward-sentence
forward-word
goto-char
goto-line
how-many
# Use indentBody in leoCommands.py
#indent-region
indent-relative
indent-rigidly
indent-to-comment-column
insert-newline
insert-parentheses
keep-lines
kill-paragraph
line-number
move-past-close
newline-and-indent
next-line
previous-line
remove-blank-lines
replace-regex
replace-string
reverse-region
scroll-down
scroll-up
select-paragraph
# Exists, but can not be executed via the minibuffer.
# self-insert-command
set-comment-column
set-fill-column
set-fill-prefix
set-mark-command
show-colors
show-fonts
# save-buffer
sort-columns
sort-fields
sort-lines
split-line
tabify
transpose-chars
transpose-lines
transpose-words
untabify
upcase-region
upcase-word
view-lossage
what-line</t>
<t tx="ekr.20051202102337.6">delete-file
diff
insert-file
make-directory
remove-directory
save-file</t>
<t tx="ekr.20051202102752.1">digit-argument
help
hide-mini-buffer
negative-argument
number-command
number-command-0
number-command-1
number-command-2
number-command-3
number-command-4
number-command-5
number-command-6
number-command-7
number-command-8
number-command-9
print-bindings
print-commands
repeat-complex-command
show-mini-buffer
toggle-mini-buffer
universal-argument</t>
<t tx="ekr.20051202102752.2">backward-kill-sentence
backward-kill-word
kill-line
kill-word
kill-sentence
kill-region
kill-region-save
yank
yank-pop
zap-to-character</t>
<t tx="ekr.20051202102752.3">call-last-keyboard-macro
end-kbd-macro
name-last-kbd-macro
load-file
insert-keyboard-macro 
start-kbd-macro</t>
<t tx="ekr.20051202102752.4">query-replace
query-replace-regex</t>
<t tx="ekr.20051202102752.5">clear-rectangle
close-rectangle
delete-rectangle
kill-rectangle
open-rectangle
string-rectangle
yank-rectangle</t>
<t tx="ekr.20051202102752.6">append-to-register
copy-rectangle-to-register
copy-to-register
increment-register
insert-register
jump-to-register
number-to-register not used: used copy-to-register insead.
point-to-register
prepend-to-register
view-register

To do:

point-to-register should write an 'expanded point' so inter-node jumps are possible.</t>
<t tx="ekr.20051202102752.7">hide-find-tab
open-find-tab
find-tab-find
find-tab-find-prev
find-tab-change
find-tab-change-then-find

isearch-forward
isearch-backward
isearch-forward-regexp
isearch-backward-regexp

re-search-forward
re-search-backward

search-forward
search-backward
word-search-forward
word-search-backward</t>
<t tx="ekr.20051202102752.8">ok:

hide-spell-tab
open-spell-tab
spell-find
spell-change
spell-change-then-find
spell-ignore</t>
<t tx="ekr.20051205093049">@nocolor

Working throught the IronPython tutorial just now I saw how useful the dir function could be, especially dir(object)

I'm thinking that Leo might use dir(object) to discover members for the auto-complete command.  It's not clear if or how this can be made to work, but it might be slick.</t>
<t tx="ekr.20051206082304.1">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3461068
By: vpe

1) Strange behaviour after pasting in headlines:
Start editing a headline in outline pane. Let's say it's 'Settings and
buttons'.
Select all text and copy (ctrl+c).
Place cursor at the end and paste (ctrl+v). What I see is 'Settings and
buttonsSetti'. That is text area does not expand to accomodate new text length.
And I cannot move beyond that point.
If I move to another headline I see that pasting was done correctly. 

2) (done) I always make these changes without any problems:
Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt;Config
&amp; Measuring...--&gt;headWidth &amp; widthInPixels
return max(self.minimum_headline_width,5 + len(s))  ##change to 1

Code--&gt;Gui Tkinter classes--&gt;@thin leoTkinterTree.py--&gt; Birth...
(tkTree)--&gt;__init__--&gt;&lt;&lt; define drawing constants &gt;&gt;
self.minimum_headline_width = 20 # In characters. ##change to 2


Leo 4.4 alpha 4, build  1.346 , December 5, 2005
Python 2.4.2, Tk 8.4.7, Pmw 1.2
Windows 5, 0, 2195, 2, Service Pack 4    &lt;--- nice!
</t>
<t tx="ekr.20051206082343"></t>
<t tx="ekr.20051206111317"></t>
<t tx="ekr.20051207093612.1"></t>
<t tx="ekr.20051207120838.1"></t>
<t tx="ekr.20051207125933.1"></t>
<t tx="ekr.20051207125933.3">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3458482
By: nobody

The assert isn't tripped except for the first time. after I run a few other unit
tests from the @button unit test this one has no error.

If I executeScript, the assert is always hit and fails.  This matches my
experiance of delete not sticking in the body.

Setting a list of usual keys for delete,
^x, Del, whatever emacs binding uses,
and running the test in a loop
and adding a reload of testLeo might
finally expose the problem.
I am not sure off hand how to change
the binding programatically in a loop.

I see similar problems with paste not sticking sometimes.</t>
<t tx="ekr.20051207125933.4">@nocolor
 
http://sourceforge.net/forum/message.php?msg_id=3458548
By: nobody

  File "C:\C\PY\PYTHON22\lib\lib-tk\Tkinter.py", line 897, in bind
    return self._bind(('bind', self._w), sequence, func, add)
  File "C:\C\PY\PYTHON22\lib\lib-tk\Tkinter.py", line 852, in _bind
    self.tk.call(what + (sequence, cmd))
TclError: bad event type or keysym "Del"

seems py2.2 using Tk8.3 or py2.4 using Tk8.4
doesn't have some keysyms
Del and Ins has to be Delete and Insert for starters.
this could have been contributing factor, although
the keys still do what I expected because default
binding from Tk are passed though.
I haven't tested if this fixes the problem yet.

these errors were getting masked/missed in py2.4
but generate failure to start Leo Tk errors in py2.2
this could be a problem, if the only way you have to fix
errors in bindings is editing a leo and you can't start Leo!

error, ignoring duplicate @shortcuts entry: cut-text
would be helpful if the keys getting ignored was also printed

for py2.2, leoEditCommands.py needs:
from __future__ import generators

trace_tags plugin isn't really detailed enough
to help track down what is happening here.
trace_keys isn't working at all.
I'm going to try to add output overwrite to file.
printing everything slows Leo down too much.

e
</t>
<t tx="ekr.20051207130144">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3460955
By: nobody

I found this link:
http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html
TkinterDnD

so if Edward is interested in adding drag and drop support for regular leo,
this might be a path to do so.  It looks like an active project.

leouser
</t>
<t tx="ekr.20051207130144.1"></t>
<t tx="ekr.20051207130701"></t>
<t tx="ekr.20051207140933"></t>
<t tx="ekr.20051207140933.1">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3464605
leouser

You really need to think about using Ctrl-Space for starting selection mode.
Its a wonderful thing.  Once in selection mode you just move around with your
arrows and things get selected.  Or if you want to move quickly you can do stuff
like Ctrl-a or Ctrl-e or Ctrl-&lt; or Ctrl-&gt;.  Combining selection mode and fast
movement keystrokes is good...</t>
<t tx="ekr.20051207180807"></t>
<t tx="ekr.20051208081641"></t>
<t tx="ekr.20051208081641.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3465251
By: e

after a save, undo last typing event
doesn't mark leo changed.
you can go up and down the undo redo list
and still the leo is not marked changed.
the changes in the body do stick.
didn't try other undo like insert node.

I had a weird undo that I wasn't able to repeat
after a reboot, when I had 2 leos open and
and the undo after a save in one would display
the last undo in a node body from the other leo.</t>
<t tx="ekr.20051208091305"></t>
<t tx="ekr.20051208091816"></t>
<t tx="ekr.20051208100903"></t>
<t tx="ekr.20051208100903.1">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20051208102107">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3464874
By: davidmcnab

* The 'goto line number' dialog pops up without the text field active, so I'm
forced into a Compulsory Mouse Click to activate the field before I can type
in the line number (I'm one who regards unnecessary Compulsory Mouse Clicks as bugs).</t>
<t tx="ekr.20051208102436"></t>
<t tx="ekr.20051208102436.1"></t>
<t tx="ekr.20051209081445"></t>
<t tx="ekr.20051209081445.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3467558
By: ktenney

Current CVS, W2K

I open a small Leo file, and from File-&gt;Open, select
..\src\LeoPyRef.py. the log pane shows;

----- error reading @file: ../doc/leoToDo.txt
Ignoring @-node sentinel. Expecting @-all

At this point Leo locks up tight, must kill process.

What I did:

** atFile.readError delete's root's entire subtree.
** atFile.read only warns about unvisited node if there is no error.
</t>
<t tx="ekr.20051209081445.2">@

New in Leo 4.4: Leo calls the 'headkey1' and 'headkey2' hooks only when the user
completes the editing of a headling, and ch is always '\r', regardless of
platform.</t>
<t tx="ekr.20051209083903">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3466412
By: ktenney

&gt;Use the read_only_nodes plugin. 

It has a great feature list, but I can't get it to
update after the file changes on the filesystem.

I then looked at at_view.py, and the @view node
plugin. (which I worked on way back when :-])

It also doesn't work.
I put a g.es(..) at the top of the icondclick2 method which is registered in
the onCreate method
of at_view.py;

leoPlugins.registerHandler("icondclick2", myView.icondclick2)

It seems that the method does not get called
when the icon is doubleclicked.

Could this behaviour be related to recent changes
in Leo?
</t>
<t tx="ekr.20051209085227"></t>
<t tx="ekr.20051209085227.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3462294
By: nobody

apparently the bodykey hooks are no longer used
is why trace_keys plugin doesn't work.
in leoKeys.py I see this trace can be turned on:
.   if c.config.getBool('trace_masterCommand'):</t>
<t tx="ekr.20051210111021"></t>
<t tx="ekr.20051210111121"></t>
<t tx="ekr.20051210111121.1">- Review the posting about making positions permanent, or recording vnode
indicies. It's probably time to do this.

- Make sure there is some way of executing script find/changes.

-@link-unl/url/etc.

- Put About dialog (all? dialogs) in tab.

- Create minibuffer commands to close tabs by name.

- the cycle-focus command should cycle through all log tabs.

- Something cool that can be bound to alt-tab.

- Strip quotes from color, font settings.

- Specify &amp; for most menu items.</t>
<t tx="ekr.20051212135654">No change was actually needed, just new bindings.

What I did:
    
- fixed a bug in copyBindingsToWidget
- textBindingsRedirectionCallback now returns 'break', not None.</t>
<t tx="ekr.20051213060647.1"></t>
<t tx="ekr.20051213073224"></t>
<t tx="ekr.20051213080533">def backCharacter (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=False)
    
def backCharacterExtendSelection (self,event):
    
    self.moveToHelper(event,'insert-1c',extend=True)
    
def forwardCharacter (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=False)
    
def forwardCharacterExtendSelection (self,event):
    
    self.moveToHelper (event,'insert+1c',extend=True)
</t>
<t tx="ekr.20051213094517">def backSentenceHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = w.search('.',i,backwards=True,stopindex='1.0')
        if i2:
            ins = w.search('\w',i2,stopindex=i,regexp=True) or i2
        else:
            ins = '1.0'
    else:
        ins = '1.0'
    if ins:
        self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20051213100651"></t>
<t tx="ekr.20051213100651.1"></t>
<t tx="ekr.20051214075028"></t>
<t tx="ekr.20051214082024">@nocolor

Key bindings

Leo must have commands to do what Tk text widgets do for all their standard bindings.  This is the only way I know of to allow users to choose different bindings for those actions.

Therefore, Leo should pass *no* key events to Tk for 'default' handling.  That is, all of Leo's key handlers will return 'break', not None.  In particular, all text widgets must have something like selfInsertCommand so they can handle ordinary keystrokes.

Typing in headlines *still* does not always stick.  The present event handlers for headlines have way too many paths through them.  The problems are caused in large part by the abort-edit-headline command: it requires state info.  I may add a beginEditHeadline command that will remember the state.  This will allow Leo to save the headline text on *every* keystroke, rather than only at the end.  This is *much* safer than trying to ensure that endEditHeadline gets called on every path.  The new endEditHeadline will have no responsibility for state except to clear the info set by beginEditHeadline.  Nothing much bad will ever happen if endEditHeadline doesn't get called once in a while.

I hope to get all the necessary bindings and commands done this week.

Undo

Undo is well defined only for headlines and body text.  There is little or no use, alas, for event.widget in leoEditCommands.py.  Brian's suggestion of having beginUndo/endUndo markers makes a lot of sense: such markers simplify the code and hide implementation and policy details that should be hidden.

Focus

Getting focus exactly right is crucial: some of the present commands in leoEditCommands.py don't work if they are invoked by their long name rather than from a keystroke.

In short, the combination of bindings, undo and focus creates a lot of problems that must be handled with extreme care.  It's frustrating to rewrite essentially every line of Brian's temacs code, but I believe it must be done.

And we are not done yet.  Leo creates an environment different from Emacs:  incremental search must be expanded to move from node to node, the notion of the 'mark' must be generalized (in some, but not all situations), etc.  Sometimes, though, the generalization is also a simplification: as I have said before, Leo's nodes can and should be treated as exactly synonymous with Emacs's buffers.

Edward
</t>
<t tx="ekr.20051214082024.1">make the default bindings work differently when editing
the headline as opposed to when traversing the tree with the arrow keys.</t>
<t tx="ekr.20051214113546.1">def onTextWidgetKey (self,event):
    
    '''This is the default key handler for all text widgets.
    It should never be called for keys bound to any command.'''

    ch = event and event.char or ''
    w  = event and event.widget

    if w and ch:
        i,j = g.app.gui.getTextSelection(w)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)

    return 'break'</t>
<t tx="ekr.20051214113546.2"></t>
<t tx="ekr.20051214115158"></t>
<t tx="ekr.20051214125235">@nocolor

- As before, tree.select always sets tree.revertHeadline.  This is the revert point.

- endEditLabel now simply unselects the widget.  It has *no* responsibility for keeping the headline in synch with p.headString.  This is a major advance in reliability.

- tree.onHeadChanged sets changed = s != oldRevert.  This is more reliable than previously.</t>
<t tx="ekr.20051214125834"></t>
<t tx="ekr.20051216080913.1"></t>
<t tx="ekr.20051216081742"></t>
<t tx="ekr.20051216083932"></t>
<t tx="ekr.20051216084926">@nocolor

Bug 1: OnActivateBody *must* call onHeadChanged: select is not always called!

But 2: c.endEditing and tree.endEditLabel **must** call tree.onHeadChanged.</t>
<t tx="ekr.20051216085517"></t>
<t tx="ekr.20051216110817">@
The change was logical, but it caused problems.

The new 'insert' keyword arg must have the value 'sel.end' for compatibility with old code.</t>
<t tx="ekr.20051216114320">@nocolor

The problem was caused by the recent change to g.app.gui.setTextSelection.

The default for the new 'insert' keyword must be sel.end for compatibility with old code.</t>
<t tx="ekr.20051216125001"></t>
<t tx="ekr.20051216155029">u = c.undoer ; w = c.frame.body.bodyCtrl

s1 = '''\
    c.beginUpdate()
    try:'''
s2 = '''\
    finally:
        c.endUpdate()'''

b = u.beforeChangeNodeContents(p)

i, j = g.app.gui.getTextSelection(w)
if i != j:
    s = w.get(i,j)
    s = ''.join(['\t'+line for line in g.splitLines(s)])
    w.delete(i,j)
    w.insert(i,s1+'\n'+s+'\n'+s2)
else:
    w.insert(i,s1+'\n\t\t\n'+s2)

c.recolor()
u.afterChangeNodeContents(p,'add-begin/endUpdate',b)</t>
<t tx="ekr.20051216155728">def beginUpdate (self):
    
    self.updateCount += 1
    
def endUpdate (self,flag):
    
    self.updateCount -= 1
    if self.updateCount &lt;= 0:
        if flag:
            self.redraw_now()
        if self.updateCount &lt; 0:
            g.trace("Can't happen: negative updateCount")</t>
<t tx="ekr.20051216160935">@nocolor

To do:

- Test abortEditLabelCommand.

- c.redraw() redraws conditionally.
- Create c.xxx methods that call the corresponding c.frame.tree methods.

** Find is not selecting headlines properly.
- Test drags.

What I did:

- Made c.begin/endUpdate and tree.begin/endUpdate functional again.
- Created a script to add c.begin/endUpdate().
- Removed redraw_flag from deleteOutline.
- Tested undo/redo delete node.
- Removed redraw_flag from insertHeadline.
- Removed redraw_flag from onBodyChanged.
- c.redraw_now() redraws undconditionally: it is used seldom.
- Replaced c.redraw_now by c.redraw or c.begin/endUpdate.
- Removed redraw_flag from c.selectPosition, tree.select, tree.onHeadChanged, body.onBodyChanged.

</t>
<t tx="ekr.20051216170531"># From Brian re Read @file nodes w/o creating copy of root node</t>
<t tx="ekr.20051216171520">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20051217074031"></t>
<t tx="ekr.20051217082130">@nocolor

- &lt;&lt; unselect the old node &gt;&gt; in tree.select now calls
    self.setUnselectedLabelState(old_p)

- tree.endEditLabel no longer calls setUnselectedLabelState.
    (This is important)</t>
<t tx="ekr.20051217091236"></t>
<t tx="ekr.20051217102943"></t>
<t tx="ekr.20051217112605">@nocolor

I've just investigated how Leo handles pane settings, and I believe all is
working as intended. This is somewhat confusing, but there has been no change in
this code for a long time: it has nothing whatever to do with the 4.4 code
base.

The so-called 'primary' ratio is the ratio between the body pane and the pane
containing the other two panes. The so-called secondary ratio is the ratio
between sizes of the log pane and the outline pane.

The thing to keep in mind is that Leo saves *only* the primary ratio in .leo
files. Leo does not save the so-called 'secondary' ratio in .leo files, because
doing so would change Leo's file format.

Because Leo **does** save the primary ratio in .leo files, Leo will open a file
with the same primary ratio that you had when you last saved the file.

Because Leo does **not** save the secondary ratio in the .leo file Leo
determines the relative sizes of the log and outline panes from settings in
leoSettings.leo. One of the two settings is used:

- initial_horizontal_secondary_ratio or

- initial_vertical_secondary_ratio

Which one is used depends on the initial_splitter_orientation setting.

**Important** If you change these settings you must restart Leo for them to take effect.

I have been able to set the secondary ratio as I please from leoSettings.leo,
and have observed that Leo properly saves and restores the primary ratio in .leo
files.

In short, everything works as it should.</t>
<t tx="ekr.20051217135340"></t>
<t tx="ekr.20051217135340.2"></t>
<t tx="ekr.20051217175058">Use the zip file stuff initially.  We can add support for chapters to Leo's core later.</t>
<t tx="ekr.20051218100605.1">def __init__(self,c):
    
    # Note: Pychecker complains if about module attributes if we assign at.x instead of self.x.
    leoBaseAtFile.__init__( self )
    self.c = c
    self.debug = False
    self.fileCommands = c.fileCommands
    self.testing = True # True: enable additional checks.
    self._forcedGnxPositionList = [] #This has to be here, puttin it in initReadIvars renders it useless

    c.checksums = {}
    self.md5 = None
    @others</t>
<t tx="ekr.20051218100605.2">self.dispatch_dict = {
    # Plain line.
    self.noSentinel: self.readNormalLine,
    # Starting sentinels...
    self.startAll:    self.readStartAll,
    self.startAt:     self.readStartAt,
    self.startDoc:    self.readStartDoc,
    self.startLeo:    self.readStartLeo,
    self.startMiddle: self.readStartMiddle,
    self.startNode:   self.readStartNode,
    self.startOthers: self.readStartOthers,
    # Ending sentinels...
    self.endAll:    self.readEndAll,
    self.endAt:     self.readEndAt,
    self.endDoc:    self.readEndDoc,
    self.endLeo:    self.readEndLeo,
    self.endMiddle: self.readEndMiddle,
    self.endNode:   self.readEndNode,
    self.endOthers: self.readEndOthers,
    # Non-paired sentinels.
    self.startAfterRef:  self.readAfterRef,
    self.startClone:     self.readClone,
    self.startComment:   self.readComment,
    self.startDelims:    self.readDelims,
    self.startDirective: self.readDirective,
    self.startNl:        self.readNl,
    self.startNonl:      self.readNonl,
    self.startRef:       self.readRef,
    self.startVerbatim:  self.readVerbatim,
    # Ignored 3.x sentinels
    self.endBody:               self.ignoreOldSentinel,
    self.startBody:             self.ignoreOldSentinel,
    self.startVerbatimAfterRef: self.ignoreOldSentinel }</t>
<t tx="ekr.20051218100605.3">def createThinChild4 (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    if self._forcedGnxPositionList and last in self._forcedGnxPositionList:
        last.fileIndex = lastIndex=  gnx
        self._forcedGnxPositionList.remove( last )
        
    if 0:
        g.trace("last",last,last.t.fileIndex)
        g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.


    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        child.vid = gnxString
        #print 'gnxString is %s' % gnxString
        leoNodes.vid_vnode[ gnxString ] = child
        leoNodes.tid_tnode[ gnxString ] = t
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace('creating last child %s\nof parent%s\n' % (child,parent))

    return child</t>
<t tx="ekr.20051218102312">@nocolor

- self._forcedGnxPositionList = [] in ctor.

- </t>
<t tx="ekr.20051218110553">@

This handles the root node properly so that Leo draws no duplicate node. The
code is from LeoUser; thanks Brian.

I also fixed a recent bugs: the screen was not being redrawn afterwards.</t>
<t tx="ekr.20051218121447">def moveWordHelper (self,event,extend,forward):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return
    
    c.frame.widgetWantsFocus(w)
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'
    self.moveToHelper(event,nind,extend)</t>
<t tx="ekr.20051218122116">def moveToHelper (self,event,spot,extend):
    
    '''Common helper method for commands the move the cursor
    in a way that can be described by a Tk Text expression.'''
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i,j = g.app.gui.getTextSelection(w,sort=True)
    spot = w.index(spot) # Capture initial value.
    ins = w.index('insert')
    w.mark_set('insert',spot)
    if extend or self.extendMode:
        if w.compare(spot,'&lt;=',i):
            g.app.gui.setTextSelection (w,spot,j,insert=None)
        else:
            g.app.gui.setTextSelection (w,i,spot,insert=None)
    w.see(spot)</t>
<t tx="ekr.20051218133207">def backwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20051218133207.1">def forwardParagraphHelper (self,event,extend):
    
    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.index('insert')
    while 1:
        txt = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if txt:
            i = w.index('%s + 1 lines' % i)
            if w.index('%s linestart' % i) == w.index('end'):
                i = w.search(r'\w','end',backwards=True,regexp=True,stopindex='1.0')
                i = '%s + 1c' % i
                break
        else:
            i = w.search(r'\w',i,regexp=True,stopindex='end')
            i = '%s' % i
            break
    if i:
        self.moveToHelper(event,i,extend)</t>
<t tx="ekr.20051218141237">def beginningOfLine (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=False)
    
def beginningOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert linestart',extend=True)
    
def endOfLine (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=False)
    
def endOfLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert lineend',extend=True)

def nextLine (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=False)
    
def nextLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert + 1line',extend=True)
    
def prevLine (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=False)
    
def prevLineExtendSelection (self,event):
    
    self.moveToHelper(event,'insert - 1line',extend=True)</t>
<t tx="ekr.20051218170358"></t>
<t tx="ekr.20051218171457">def movePastCloseHelper (self,event,extend):

    c = self.c ; w = event.widget
    if not g.app.gui.isTextWidget(w): return

    c.frame.widgetWantsFocus(w)
    i = w.search('(','insert',backwards=True,stopindex='1.0')
    if '' == i: return

    icheck = w.search(')','insert',backwards=True,stopindex='1.0')
    if icheck:
        ic = w.compare(i,'&lt;',icheck)
        if ic: return

    i2 = w.search(')','insert',stopindex='end')
    if '' == i2: return

    i2check = w.search('(','insert',stopindex='end')
    if i2check:
        ic2 = w.compare(i2,'&gt;',i2check)
        if ic2: return
    
    ins = '%s+1c' % i2
    self.moveToHelper(event,ins,extend)</t>
<t tx="ekr.20051218174113">def clearExtendMode (self,event):
    
    self.extendMode = False
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)

def setExtendMode (self,event):
    
    self.extendMode = True
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)
    
def toggleExtendMode (self,event):
    
    self.extendMode = not self.extendMode
    
    c = self.c ; w = event.widget
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20051219090231"></t>
<t tx="ekr.20051219122720">def forceGnxOnPosition (self,p):
    
    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20051219124309"></t>
<t tx="ekr.20051219125559"></t>
<t tx="ekr.20051219151756"></t>
<t tx="ekr.20051219200934"></t>
<t tx="ekr.20051220062654">An alternative to test.leo!</t>
<t tx="ekr.20051220063217"></t>
<t tx="ekr.20051220063601"></t>
<t tx="ekr.20051220064128"></t>
<t tx="ekr.20051220070321">@ This is the end of the ill-fated settings dialog.

Important: you can use the show-colors and show-fonts commands to help set
colors and fonts in leoSettings.leo.</t>
<t tx="ekr.20051220070321.1"></t>
<t tx="ekr.20051220083410">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(stroke,accel,shortcut,func.__name__)
    if pane == 'mini' and func != k.keyboardQuit:
        # Call a strange callback that bypasses k.masterCommand.
        def minibufferKeyCallback(event,func=func,shortcut=shortcut):
            k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

        k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
        # Create two-levels of callbacks.
        def specialCallback (event,func=func):
            return func(event)

        def keyCallback (event,func=specialCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)

        k.bindKey(pane,shortcut,keyCallback,commandName)

    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20051220090650">Error: 1
AttributeError Exception in Tk callback
  Function: &lt;function keyCallback2 at 0x01378630&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x034905D0&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 814, in keyCallback2
    def keyCallback2 (event,func=menuFuncCallback,stroke=shortcut):
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1143, in masterCommand
    if stroke == k.abortAllModesKey: # 'Control-g'
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 811, in menuFuncCallback
    def menuFuncCallback (event,command=command):
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 2250, in backwardDeleteCharacter
    oldText = w.get('1.0','end')
AttributeError: Canvas instance has no attribute 'get'

</t>
<t tx="ekr.20051220091742"></t>
<t tx="ekr.20051220091742.1"></t>
<t tx="ekr.20051220093312"></t>
<t tx="ekr.20051220144507">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20051220145225"></t>
<t tx="ekr.20051221100114.1"></t>
<t tx="ekr.20051221101851"></t>
<t tx="ekr.20051221101851.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3487424
By: p_michalczyk

Does anybody know how to double-click headline in outline panel using only keyboard
(that is how to simulate double-click through keyboard shortcut) ?
I need it to execute @run nodes from keyboard.

EKR: This can be done with @command nodes, but Leo should have official commands to do this too.</t>
<t tx="ekr.20060102092148">put optparse.py in leo/extensions for py2.2

</t>
<t tx="ekr.20060102092148.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3501193
By: nobody

::improving how Leo handle's arguments? 

Leo only needs a few simple options.
I don't think option handling would
work correctly in the IPYthon case either.

put optparse.py in leo/extensions for py2.2
docutils installs it if it isn't available.
its been the standard since py2.3
adding new options will be much less painfull.
some kind of --safe startup to allow editing
of leoSettings.leo, no @buttons or @scripts
might be a good thing.

Leo should allow scripts to set sys.argv for
commands they create. its very difficult to do now.

e

</t>
<t tx="ekr.20060102092148.2">docutils installs it if it isn't available.
</t>
<t tx="ekr.20060102103625">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060102103625.1">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060102134206.1"></t>
<t tx="ekr.20060102134206.2"></t>
<t tx="ekr.20060102135349.2">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName)
</t>
<t tx="ekr.20060103100430"></t>
<t tx="ekr.20060103101524">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3501995
By: nobody

::But I don't understand why it's difficult to edit leoSettings.leo

--safe would use default settings,
maybe you set all body fg/bg to the same color
by mistake and you don't have a backup leoSettings to use. as a dumb example.

another nice option would be to override a setting
--set something=whatever
this could breakdown easy and on (older?) windows.
there is a limit to how many chars on a command line.
this would add another layer of choice
yet another chicken egg problem, 
parsing settings before settings can be parsed.

what about override @settings file, its a standard thing.
many people will expect this is possible 
and try it
or even leo.py -? 
help you get for free w/optparse.
--keys emacs anyone? 
especially the first time
untill you can get a chance to edit leoSettings.leo

I have already started enabling optparse
for leo.py so I can try various profile options.
I will post it when it works.

have to check how it handles filenames with spaces
seems that is all Leo is currently doing 
with multiple args, if there is no problem.
and later checking for -batch -script etc.

not to minimize how much work this would be.
parsing options is probably the least difficult part.

e
</t>
<t tx="ekr.20060103102115">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3495741
By: stano_paska

Hi.

In plugin word_export encoding is defined:

encoding = dict.get("encoding",None)
if encoding == None:
    encoding = c.config.default_derived_file_encoding

I have default_derived_file_encoding set to UTF-8 but when exporting to word
some national characters are not encoded correctly (Slovak).

I think it is better get encoding for word from somewhere else.

In Slovak environment word uses cp1250.

When I used:

import sys
encoding = sys.getdefaultencoding() # 'cp1250'

everything goes fine.</t>
<t tx="ekr.20060103104509">@nocolor

* Run pychecker.
- Fancier mode-help.
- Use tabs in print-commands &amp; print-bindings.

* Handle k.unboundKeyAction in handleDefaultChar.
- Complete vim emulation

Cleanup
- Default modes should set the label.
- Create tkinterKeyHandler.

Docs
- Document @mode and how to use it.
- Move most settings docs to Customizing chapter.

Tests
- Test cursor commands in Find panel.</t>
<t tx="ekr.20060103113002">@nocolor

- Created enter-xxx-mode command in c.config.createModeCommand.

- Removed c.setFocusHelper

- Read initial_unbound_key_binding when creating keyHandler class.

- Implemented mode-changing commands:
    enter-ignore-mode,enter-insert-mode,enter-replace-mode
    These simply set k.unboundKeyAction to 'ignore','insert' or 'replace'.

Created general mode handler code.
- It uses the existing state machinery.
- It only honors the mode bindings, plus perhaps a few universal bindings.
- It restores focus by default (can be overridden by focus-shifting commands).
- It leaves existing bindings alone (because it is called from masterCommand).
- It supports typing completion: a list of valid keystrokes in the mode.

Created mode-help command.</t>
<t tx="ekr.20060103133740">- Create prototype of ekr-vim mode
    - initial_unbound_key_binding = ignore
    - plain key bindings for:
        - most useful commands:
            cursor move/extend, scroll, goto-inner-modes.
        - inner modes:
            options, search options, search, file,

- Create prototype of vim.
    - initial_unbound_key_binding = ignore
    - plain key bindings for:
        -all normal vim commands.
        -all vim temporary modes.</t>
<t tx="ekr.20060104083551">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3488030

Some examples are:
selected text --&gt; press space bar.  A space is added to all the selected lines
at the beginning. tab does 4 spaces

selected text --&gt; hit back space.  A space is removed from the start of each
line.  If a space is not available in one of the lines, nothing is done.

selected text --&gt; hit keypad '-', selected text gets moved up one line.  The
selection is swapped with the line above it.  If we are at the top of a node,
the node identified by threadBack() is selected and the text is moved to the
bottom of the node.

selected text --&gt; hit keypad '+', selected text gets moved down one line.  The
selection is swapped with the line below it.  If we are at the bottom of the
node, the node identified by threadNext() is selected and the text is moved
to the top of the node.

in all cases of movement the text remains selected, even with node traversals.

- and + are arbitrary, you should be able to bind any key to these actions.
space, backspace and tab probably should always retain their convential meaning.

Also note, they we dont have to be in a mode to make this happen, it just happens.
So you can do keyboard selection or even mouse selection and it works.  What
matters is that something is selected.

Code wise, my implementation is totally based on the JTextPane's Document structure.
I rely heavily on the Paragraph Elements identified between the selection start
and end.  Im not sure what would be the equivilent in Tk.  The concept is clear
enough I hope that you could map out some functionality.  Having these large
structures to work with makes it much simpler to do the movement right.

leouser</t>
<t tx="ekr.20060104083736">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3488438
By: btheado

&gt; len(p.headString()) doesn't work for wide 
&gt; characters

According to this:
http://www.tcl.tk/man/tcl8.4/TkCmd/text.htm#M15

"If the font doesn't have a uniform width then the width of the character '0'
is used in translating from character units to screen units."

Here is some Tcl code that can get an exact fit for the text widget width:

pack [text .t]
set font [.t cget -font]
set widechars WWWWWWWW
.t insert end $widechars
set strpixels [font measure $font $widechars]
set zeropixels [font measure $font 0]
set width [expr int(ceil(double($strpixels) / $zeropixels))]
.t configure -width $width


Summary of code: Set the width to be the pixel size of the text widget string
divided by the pixel size of the '0' char.
</t>
<t tx="ekr.20060104110233">def generalModeHandler (self,event,name=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c ; f = c.frame
    modeName = name or k.inputModeName
    commandName = 'enter-' + modeName
    state = k.getState(modeName)
    keysym = event and event.keysym or ''
    # g.trace(modeName,'state',state)
    
    d = g.app.config.modeCommandsDict.get(commandName)
    if not d:
        g.trace("can't happen")
    elif state == 0:
        k.inputModeName = modeName
        k.modeWidget = event and event.widget
        k.setState(name,1,handler=k.generalModeHandler)
        k.setLabelBlue(name,protect=True)
        k.modeCompletionList = d.keys()
    else:
        for key in d.keys():
            bunchList = d.get(key)
            for bunch in bunchList:
                if k.matchKeys(event,bunch.val):
                    func = c.commandsDict.get(key)
                    # g.trace('calling',func)
                    if key != 'mode-help':
                        # This must be done first because commands can change windows.
                        k.clearState()
                        k.resetLabel()
                        k.endCommand(event,k.stroke)
                        k.inputModeName = None
                        c.frame.log.deleteTab('Mode')
                        c.frame.widgetWantsFocus(k.modeWidget)
                    func(event)
                    return 'break'
        k.modeHelpHelper(d)
        f.minibufferWantsFocus()
        
    return 'break'</t>
<t tx="ekr.20060104120602">def matchKeys (self,event,shortcut):
    
    '''Return true if a binding matches the key specified by the event.'''
    
    k = self ; c = k.c
    
    if not k.stroke or not event: return False
    
    stroke = k.stroke ; keysym = event.keysym
    shortcut2, junk = c.frame.menu.canonicalizeShortcut(shortcut)
    
    if stroke == '&lt;Key&gt;':
        val = shortcut == keysym or shortcut.startswith('Key-') and shortcut.endswith(keysym)
    else:
        val = stroke == shortcut2
        
    if 0:
        g.trace('returns',val,
            'stroke',stroke,'keysym',keysym,
            'shortcut',shortcut,'shortcuts',shortcut2)
        
    return val</t>
<t tx="ekr.20060104125946">def modeHelpHelper (self,d):
    
    k = self ; c = k.c
    
    c.frame.log.clearTab('Mode')
    
    for key in d.keys():
        bunchList = d.get(key)
        bunch = bunchList and bunchList[0]
        shortcut = bunch.val
        if shortcut not in (None,'None'):
            if shortcut.startswith('Key-'):
                shortcut = shortcut[4:]
                if len(shortcut) == 1:
                    ch = shortcut[0]
                    if ch in string.ascii_uppercase:
                        shortcut = 'Shift-%s' % ch.lower()
            g.es('%s\t%s' % (shortcut,key),tabName='Mode')</t>
<t tx="ekr.20060104154253">- User can bind &lt;Backspace&gt; to an enter-mode command.
- User can bind &lt;Tab&gt; to show-mode-help command.
</t>
<t tx="ekr.20060104154937">def addModeCommands (self):
    
    '''Add commands created by @mode settings..'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060104164523">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self

    if k.inputModeName:
        commandName = 'enter-' + k.inputModeName
        d = g.app.config.modeCommandsDict.get(commandName)
        k.modeHelpHelper(d)
    else:
        g.es('Not in any mode')





</t>
<t tx="ekr.20060105085031">defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
defaultAction.lower()
if defaultAction in ('insert','replace','ignore'):
    self.unboundKeyAction = defaultAction
else:
    g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultMode)
    self.unboundKeyAction = 'insert'</t>
</tnodes>
</leo_file>
