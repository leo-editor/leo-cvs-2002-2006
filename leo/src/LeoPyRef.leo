<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="8668" clone_windows="0"/>
<globals body_outline_ratio="0.435536294691">
	<global_window_position top="8" left="478" height="923" width="771"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20040803072955.139,ekr.20040803072955.141,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20050921103230,ekr.20050921103230,ekr.20050921103230,ekr.20050921103230,ekr.20051010062551.1,"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20060117091600"><vh>4.4b2 projects</vh>
<v t="ekr.20060117091430.1"><vh>Fixed crasher in Save button</vh></v>
<v t="ekr.20060117201349.1"><vh>Made modes work</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051001051355"><vh>Dispatching...</vh>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
</v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20041120112043"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120082630"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20060119063223.1"><vh>computeKeysym_numDicts</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120071949"><vh>isPlainKey</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060115103349"><vh>Modes</vh>
<v t="ekr.20060102135349.2"><vh>enterNamedMode</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060104110233"><vh>generalModeHandler &amp; helpers</vh>
<v t="ekr.20060117202916"><vh>badMode</vh></v>
<v t="ekr.20060119150624"><vh>createModeBindings</vh>
<v t="ekr.20060118181341"><vh>&lt;&lt; define modeCallback &gt;&gt;</vh></v>
<v t="ekr.20060119145631"><vh>&lt;&lt; define modeHelpCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060117202916.1"><vh>initMode</vh></v>
<v t="ekr.20060117202916.2"><vh>endMode</vh></v>
</v>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20060120193743"><vh>showInputState</vh></v>
</v>
</v>
<v t="ekr.20060119201356"><vh>Disabled plain-key bindings in insert/overwrite modes</vh>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20051125080855"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120082630"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20060119063223.1"><vh>computeKeysym_numDicts</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120071949"><vh>isPlainKey</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20060120105247"><vh>Fixed minor bugs &amp; made minor improvements</vh>
<v t="ekr.20060120110341"><vh>Fixed two annoying headline glitches</vh>
<v t="ekr.20040803072955.134"><vh>tree.set...LabelState</vh>
<v t="ekr.20040803072955.135"><vh>setEditLabelState</vh></v>
<v t="ekr.20040803072955.136"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20040803072955.138"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20040803072955.139" a="M"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20040803072955.140"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20040803072955.141" a="M"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20040803072955.79"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20060120103549"><vh>Insert headline didn't redraw headline properly in vim mode</vh>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060115103349"><vh>Modes</vh>
<v t="ekr.20060102135349.2"><vh>enterNamedMode</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060104110233"><vh>generalModeHandler &amp; helpers</vh>
<v t="ekr.20060117202916"><vh>badMode</vh></v>
<v t="ekr.20060119150624"><vh>createModeBindings</vh>
<v t="ekr.20060118181341"><vh>&lt;&lt; define modeCallback &gt;&gt;</vh></v>
<v t="ekr.20060119145631"><vh>&lt;&lt; define modeHelpCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060117202916.1"><vh>initMode</vh></v>
<v t="ekr.20060117202916.2"><vh>endMode</vh></v>
</v>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20060120193743"><vh>showInputState</vh></v>
</v>
</v>
<v t="ekr.20060119201657"><vh>Improved printBindings, printCommands &amp; modeHelp</vh>
<v t="ekr.20050920085536.32"><vh>Externally visible commands</vh>
<v t="ekr.20050930080419"><vh>digitArgument &amp; universalArgument</vh></v>
<v t="ekr.20051014170754"><vh>k.help</vh></v>
<v t="ekr.20051014155551"><vh>k.show/hide/toggleMinibuffer</vh></v>
<v t="ekr.20050920085536.68"><vh>negativeArgument (redo?)</vh></v>
<v t="ekr.20050920085536.77"><vh>numberCommand</vh></v>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20051014061332"><vh>printCommands</vh></v>
<v t="ekr.20050920085536.48"><vh>repeatComplexCommand &amp; helper</vh></v>
</v>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20051014061332"><vh>printCommands</vh></v>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20050921094025"><vh>4.4 To do</vh>
<v t="ekr.20060120105445"><vh>Fix recent bugs</vh></v>
<v t="ekr.20060117201349"><vh>Latest</vh>
<v t="ekr.20051023094009"><vh>Search classes</vh>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__</vh>
<v t="ekr.20051020120306.12"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051020120306.13"><vh>createFrame (findTab)</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.19"><vh>find.init</vh>
<v t="ekr.20051020120306.20"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020120306.21"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020120306.22"><vh>find.update_ivars</vh></v>
<v t="ekr.20051023183028"><vh>findButtonCallback</vh></v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.27"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020120306.28"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20051020120306.1"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020120306.2"><vh>__init__</vh>
<v t="ekr.20051020120306.3"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.4"><vh>bindHotKey</vh></v>
<v t="ekr.20051020120306.5"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051022211617"><vh>find tab...</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>commands...</vh></v>
</v>
<v t="ekr.20060117181301"><vh>Common helpers</vh>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
<v t="ekr.20050920084036.268"><vh>plainSearchHelper</vh></v>
<v t="ekr.20050920084036.272"><vh>wordSearchHelper</vh></v>
<v t="ekr.20050920084036.275"><vh>reSearchHelper</vh></v>
</v>
<v t="ekr.20060117181301.1"><vh>searchAgain &amp; changeAgain </vh></v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler &amp; helper</vh>
<v t="ekr.20051002120125"><vh>&lt;&lt; do a non-incremental search &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
</v>
<v t="ekr.20050920084036.267"><vh>non-incremental search...</vh>
<v t="ekr.20050920084036.269"><vh>seachForward/Backward &amp; helper</vh></v>
<v t="ekr.20051002111614"><vh>wordSearchBackward/Forward &amp; helper</vh></v>
<v t="ekr.20050920084036.274"><vh>reSearchBackward/Forward &amp; helper</vh></v>
</v>
</v>
</v>
<v t="ekr.20051121070552"><vh>Add Cmds menu</vh>
<v t="ekr.20060117112444"><vh>What I did</vh></v>
<v t="ekr.20060117114903"><vh>Others</vh>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3753"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20050711091931"><vh>defineEditMenuEditCursorTable</vh></v>
<v t="ekr.20031218072017.3754"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20031218072017.3755"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3759"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20031218072017.3760"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20031218072017.3761"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20031218072017.3762"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20031218072017.3763"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20031218072017.3764"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20031218072017.3765"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20031218072017.3766"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20050921103230" a="M"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable (to do)</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060117095212.5"><vh>defineCmdsMenuCenterTable  </vh></v>
<v t="ekr.20060117095212.4"><vh>defineCmdsMenuChangeCaseTable</vh></v>
<v t="ekr.20060117095212.6"><vh>defineCmdsMenuIndentTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable(to do)</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable(to do)</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable(to do)</vh></v>
<v t="ekr.20060117095212.3"><vh>defineCmdsMenuSortTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
</v>
<v t="ekr.20031218072017.3773"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20031218072017.3774"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20031218072017.3785"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20031218072017.3790"><vh>createFileMenuFromTable</vh>
<v t="ekr.20031218072017.3791"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3792"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3793"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3794"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3795"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3796"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3786"><vh>createEditMenuFromTable</vh>
<v t="ekr.20031218072017.3787"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3788"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3789"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3797"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20040711140738.1"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3798"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3799"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3800"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3801"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20031218072017.3802"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20031218072017.3803"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060117123143"><vh>editing commands</vh></v>
<v t="ekr.20050921103230" a="M"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable (to do)</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060117095212.5"><vh>defineCmdsMenuCenterTable  </vh></v>
<v t="ekr.20060117095212.4"><vh>defineCmdsMenuChangeCaseTable</vh></v>
<v t="ekr.20060117095212.6"><vh>defineCmdsMenuIndentTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable(to do)</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable(to do)</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable(to do)</vh></v>
<v t="ekr.20060117095212.3"><vh>defineCmdsMenuSortTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
</v>
</v>
<v t="ekr.20060116084755"><vh>Urgent: mouseless Leo</vh>
<v t="ekr.20060116091116"><vh>Mousless Leo: First</vh>
<v t="ekr.20060120105605.1"><vh>Fixed problems with plain keys</vh>
<v t="ekr.20060120200529"><vh>Notes</vh></v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20060120193743"><vh>showInputState</vh></v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120082630"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
</v>
<v t="ekr.20060116085649"><vh>find-word-on-line, find-character-on-line (forward &amp; backward)</vh></v>
<v t="ekr.20060116085217"><vh>scroll-pane-up/down</vh></v>
<v t="ekr.20060116074839.2"><vh>extend-to-word, extend-to-paragraph, extend-to-sentence, etc.</vh></v>
<v t="ekr.20060116083359.1"><vh>expand-pane &amp; contract-pane</vh></v>
<v t="ekr.20051012053017.4"><vh>Search mode</vh></v>
</v>
<v t="ekr.20060116091116.1"><vh>Next</vh>
<v t="ekr.20060116091236"><vh>Unify all search commands</vh></v>
<v t="ekr.20060116090357.2"><vh>Search options: create find-options panel</vh>
<v t="ekr.20051103091115.1"><vh>Reorganize Find/Change settings</vh></v>
</v>
<v t="ekr.20060114055611"><vh>Fix sort-lines problems</vh></v>
<v t="ekr.20051112075511"><vh>Switch cursor when changing search direction</vh></v>
<v t="ekr.20060113090042"><vh>open-outline-by-name &amp; filename completion</vh></v>
<v t="ekr.20060116080040.2"><vh>activate-xxx-menu commands</vh></v>
<v t="ekr.20051221101851"><vh>commands to simulate clicks in outlines</vh>
<v t="ekr.20051221101851.1"><vh>Request</vh></v>
</v>
<v t="ekr.20060116084526.1"><vh>insert/remove spaces/tabs from lines (LeoUser)</vh></v>
<v t="ekr.20060104083551"><vh>move-line-up/down (LeoUser)</vh></v>
<v t="ekr.20060116090428"><vh>Expand 'point' so it indicates node as well as text location</vh></v>
<v t="ekr.20060116080040.3"><vh>set-option</vh></v>
<v t="ekr.20060116074450"><vh>Drive tabs from keyboard</vh></v>
<v t="ekr.20060109183500.1"><vh>execute-named-script</vh></v>
<v t="ekr.20060116083359"><vh>Drive dialogs from keyboard</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
</v>
<v t="ekr.20060117124457"><vh>New bugs</vh>
<v t="ekr.20060117131228"><vh>Fix crash in if mode definition isn't correct</vh>
<v t="ekr.20060104110233"><vh>generalModeHandler &amp; helpers</vh>
<v t="ekr.20060117202916"><vh>badMode</vh></v>
<v t="ekr.20060119150624"><vh>createModeBindings</vh>
<v t="ekr.20060118181341"><vh>&lt;&lt; define modeCallback &gt;&gt;</vh></v>
<v t="ekr.20060119145631"><vh>&lt;&lt; define modeHelpCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060117202916.1"><vh>initMode</vh></v>
<v t="ekr.20060117202916.2"><vh>endMode</vh></v>
</v>
</v>
<v t="ekr.20060117115212"><vh>Rename buffer doesn't seem to work</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051022211617"><vh>find tab...</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>commands...</vh></v>
</v>
<v t="ekr.20060117181301"><vh>Common helpers</vh>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
<v t="ekr.20050920084036.268"><vh>plainSearchHelper</vh></v>
<v t="ekr.20050920084036.272"><vh>wordSearchHelper</vh></v>
<v t="ekr.20050920084036.275"><vh>reSearchHelper</vh></v>
</v>
<v t="ekr.20060117181301.1"><vh>searchAgain &amp; changeAgain </vh></v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler &amp; helper</vh>
<v t="ekr.20051002120125"><vh>&lt;&lt; do a non-incremental search &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
</v>
<v t="ekr.20050920084036.267"><vh>non-incremental search...</vh>
<v t="ekr.20050920084036.269"><vh>seachForward/Backward &amp; helper</vh></v>
<v t="ekr.20051002111614"><vh>wordSearchBackward/Forward &amp; helper</vh></v>
<v t="ekr.20050920084036.274"><vh>reSearchBackward/Forward &amp; helper</vh></v>
</v>
</v>
</v>
<v t="ekr.20060116073938"><vh>4.4b2</vh>
<v t="ekr.20060116084755"><vh>Urgent: mouseless Leo</vh>
<v t="ekr.20060116091116"><vh>Mousless Leo: First</vh>
<v t="ekr.20060120105605.1"><vh>Fixed problems with plain keys</vh>
<v t="ekr.20060120200529"><vh>Notes</vh></v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20060120193743"><vh>showInputState</vh></v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120082630"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
</v>
<v t="ekr.20060116085649"><vh>find-word-on-line, find-character-on-line (forward &amp; backward)</vh></v>
<v t="ekr.20060116085217"><vh>scroll-pane-up/down</vh></v>
<v t="ekr.20060116074839.2"><vh>extend-to-word, extend-to-paragraph, extend-to-sentence, etc.</vh></v>
<v t="ekr.20060116083359.1"><vh>expand-pane &amp; contract-pane</vh></v>
<v t="ekr.20051012053017.4"><vh>Search mode</vh></v>
</v>
<v t="ekr.20060116091116.1"><vh>Next</vh>
<v t="ekr.20060116091236"><vh>Unify all search commands</vh></v>
<v t="ekr.20060116090357.2"><vh>Search options: create find-options panel</vh>
<v t="ekr.20051103091115.1"><vh>Reorganize Find/Change settings</vh></v>
</v>
<v t="ekr.20060114055611"><vh>Fix sort-lines problems</vh></v>
<v t="ekr.20051112075511"><vh>Switch cursor when changing search direction</vh></v>
<v t="ekr.20060113090042"><vh>open-outline-by-name &amp; filename completion</vh></v>
<v t="ekr.20060116080040.2"><vh>activate-xxx-menu commands</vh></v>
<v t="ekr.20051221101851"><vh>commands to simulate clicks in outlines</vh>
<v t="ekr.20051221101851.1"><vh>Request</vh></v>
</v>
<v t="ekr.20060116084526.1"><vh>insert/remove spaces/tabs from lines (LeoUser)</vh></v>
<v t="ekr.20060104083551"><vh>move-line-up/down (LeoUser)</vh></v>
<v t="ekr.20060116090428"><vh>Expand 'point' so it indicates node as well as text location</vh></v>
<v t="ekr.20060116080040.3"><vh>set-option</vh></v>
<v t="ekr.20060116074450"><vh>Drive tabs from keyboard</vh></v>
<v t="ekr.20060109183500.1"><vh>execute-named-script</vh></v>
<v t="ekr.20060116083359"><vh>Drive dialogs from keyboard</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
</v>
<v t="ekr.20060117124457"><vh>New bugs</vh>
<v t="ekr.20060117131228"><vh>Fix crash in if mode definition isn't correct</vh>
<v t="ekr.20060104110233"><vh>generalModeHandler &amp; helpers</vh>
<v t="ekr.20060117202916"><vh>badMode</vh></v>
<v t="ekr.20060119150624"><vh>createModeBindings</vh>
<v t="ekr.20060118181341"><vh>&lt;&lt; define modeCallback &gt;&gt;</vh></v>
<v t="ekr.20060119145631"><vh>&lt;&lt; define modeHelpCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060117202916.1"><vh>initMode</vh></v>
<v t="ekr.20060117202916.2"><vh>endMode</vh></v>
</v>
</v>
<v t="ekr.20060117115212"><vh>Rename buffer doesn't seem to work</vh></v>
</v>
</v>
<v t="ekr.20060116073938.1"><vh>Next</vh>
<v t="ekr.20060116173818"><vh>Fix vampire nodes</vh></v>
<v t="ekr.20051121070552"><vh>Add Cmds menu</vh>
<v t="ekr.20060117112444"><vh>What I did</vh></v>
<v t="ekr.20060117114903"><vh>Others</vh>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3753"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20050711091931"><vh>defineEditMenuEditCursorTable</vh></v>
<v t="ekr.20031218072017.3754"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20031218072017.3755"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3759"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20031218072017.3760"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20031218072017.3761"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20031218072017.3762"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20031218072017.3763"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20031218072017.3764"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20031218072017.3765"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20031218072017.3766"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20050921103230" a="M"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable (to do)</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060117095212.5"><vh>defineCmdsMenuCenterTable  </vh></v>
<v t="ekr.20060117095212.4"><vh>defineCmdsMenuChangeCaseTable</vh></v>
<v t="ekr.20060117095212.6"><vh>defineCmdsMenuIndentTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable(to do)</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable(to do)</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable(to do)</vh></v>
<v t="ekr.20060117095212.3"><vh>defineCmdsMenuSortTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
</v>
<v t="ekr.20031218072017.3773"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20031218072017.3774"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20031218072017.3785"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20031218072017.3790"><vh>createFileMenuFromTable</vh>
<v t="ekr.20031218072017.3791"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3792"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3793"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3794"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3795"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3796"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3786"><vh>createEditMenuFromTable</vh>
<v t="ekr.20031218072017.3787"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3788"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3789"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3797"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20040711140738.1"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3798"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3799"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3800"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3801"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20031218072017.3802"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20031218072017.3803"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060117123143"><vh>editing commands</vh></v>
<v t="ekr.20050921103230" a="M"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable (to do)</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060117095212.5"><vh>defineCmdsMenuCenterTable  </vh></v>
<v t="ekr.20060117095212.4"><vh>defineCmdsMenuChangeCaseTable</vh></v>
<v t="ekr.20060117095212.6"><vh>defineCmdsMenuIndentTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable(to do)</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable(to do)</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable(to do)</vh></v>
<v t="ekr.20060117095212.3"><vh>defineCmdsMenuSortTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
</v>
</v>
<v t="ekr.20060116092801"><vh>Code cleanup</vh>
<v t="ekr.20060114215112"><vh>Make sure all (or most) callbacks call masterCommand</vh>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060115100407"><vh>Found: callback</vh>
<v t="ekr.20060115100841"><vh>Do call masterCommand</vh>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20060115100841.1"><vh>Don't (yet) call masterCommand</vh>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
</v>
</v>
</v>
<v t="ekr.20060111134901"><vh>Implement c.es etc.</vh></v>
<v t="ekr.20050707085637"><vh>Suggestions from an emacs user</vh>
<v t="ekr.20060116082302.1"><vh>Use os.getenv('User") if it exists to get initial cvs name</vh></v>
<v t="ekr.20060116083043"><vh>Two help menus on the Mac</vh></v>
<v t="ekr.20060116083043.1"><vh>No context-menu on nodes or text</vh></v>
</v>
</v>
<v t="ekr.20051217175058"><vh>*** Add chapters  to Leo's core</vh></v>
<v t="ekr.20060115091804.2"><vh>Finish support for @mode nodes</vh>
<v t="ekr.20060116075549"><vh>Notes</vh></v>
<v t="ekr.20051010062551.1" a="M"><vh>&lt;&lt; about key dicts &gt;&gt;</vh></v>
<v t="ekr.20060115134337"><vh>From leoConfig</vh>
<v t="ekr.20060102103625"><vh>createModeCommand</vh></v>
<v t="ekr.20060102103625.1"><vh>doMode</vh></v>
</v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120082630"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20060119063223.1"><vh>computeKeysym_numDicts</vh></v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
<v t="ekr.20060120071949"><vh>isPlainKey</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh>
<v t="ekr.20051220083410"><vh>makeSpecialBinding</vh></v>
</v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060115103349"><vh>Modes</vh>
<v t="ekr.20060102135349.2"><vh>enterNamedMode</vh></v>
<v t="ekr.20060104164523"><vh>modeHelp</vh>
<v t="ekr.20060104125946"><vh>modeHelpHelper</vh></v>
</v>
<v t="ekr.20060104110233"><vh>generalModeHandler &amp; helpers</vh>
<v t="ekr.20060117202916"><vh>badMode</vh></v>
<v t="ekr.20060119150624"><vh>createModeBindings</vh>
<v t="ekr.20060118181341"><vh>&lt;&lt; define modeCallback &gt;&gt;</vh></v>
<v t="ekr.20060119145631"><vh>&lt;&lt; define modeHelpCallback &gt;&gt;</vh></v>
</v>
<v t="ekr.20060117202916.1"><vh>initMode</vh></v>
<v t="ekr.20060117202916.2"><vh>endMode</vh></v>
</v>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20060120193743"><vh>showInputState</vh></v>
</v>
</v>
<v t="ekr.20060117074259"><vh>Handle Mac issues</vh>
<v t="ekr.20060117074259.1"><vh>Report</vh></v>
</v>
</v>
<v t="ekr.20060116074839"><vh>Important</vh>
<v t="ekr.20051126122638"><vh>Autocompletion tab</vh>
<v t="ekr.20051205093049"><vh>Use dir for auto-complete ?</vh></v>
<v t="ekr.20051025144611"><vh>Reference (Do not delete)</vh>
<v t="ekr.20051025144611.1"><vh>Configuration</vh>
<v t="ekr.20051025144611.2"><vh>autocompleter.ini</vh></v>
<v t="ekr.20051025144611.3"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20051025144611.4"><vh>autocompleter.py</vh>
<v t="ekr.20051025144611.5"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20051025144611.6"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051025144611.7"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20051025144611.8"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="ekr.20051025144611.10"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="ekr.20051025144611.11"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20051025144611.12"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="ekr.20051025144611.13"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20051025144611.14"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20051025170832"><vh>Initialization</vh>
<v t="ekr.20051025144611.15"><vh>init</vh></v>
<v t="ekr.20051025170832.1"><vh>Config stuff</vh>
<v t="ekr.20051025144611.24"><vh>has read config file meths</vh></v>
<v t="ekr.20051025144611.25"><vh>readConfigFile</vh></v>
<v t="ekr.20051025144611.26"><vh>createConfigFile</vh></v>
<v t="ekr.20051025144611.27"><vh>readLanguageFiles</vh></v>
<v t="ekr.20051025144611.28"><vh>readOutline</vh></v>
</v>
<v t="ekr.20051025144611.16"><vh>watcher</vh></v>
<v t="ekr.20051025144611.23"><vh>initialScan</vh></v>
</v>
<v t="ekr.20051025144611.17"><vh>scanText</vh></v>
<v t="ekr.20051025144611.18"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20051025144611.19"><vh>scanForCallTip</vh></v>
<v t="ekr.20051025144611.20"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20051025144611.21"><vh>_getCleanString</vh></v>
<v t="ekr.20051025144611.22"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20051025144611.29"><vh>reducer</vh></v>
<v t="ekr.20051025144611.30"><vh>unbind</vh></v>
<v t="ekr.20051025144611.31"><vh>moveSelItem</vh></v>
<v t="ekr.20051025144611.32"><vh>processKeyStroke</vh></v>
<v t="ekr.20051025144611.33"><vh>testForUnbind</vh></v>
<v t="ekr.20051025144611.34"><vh>processAutoBox</vh></v>
<v t="ekr.20051025144611.35"><vh>add_item</vh></v>
<v t="ekr.20051025144611.36"><vh>add_bindings</vh></v>
<v t="ekr.20051025144611.37"><vh>configureAutoBox</vh></v>
<v t="ekr.20051025144611.38"><vh>calculatePlace</vh></v>
<v t="ekr.20051025144611.39"><vh>setLanguage</vh></v>
<v t="ekr.20051025144611.40"><vh>newCreateControl</vh></v>
<v t="ekr.20051025144611.41"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20051025144611.42"><vh>onOpenWindow</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4059"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20031218072017.844"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20031218072017.845"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20031218072017.846"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20031218072017.4060"><vh>Dialog</vh>
<v t="ekr.20031218072017.4061"><vh>get_window_info</vh></v>
<v t="ekr.20031218072017.4062"><vh>center_dialog</vh></v>
<v t="ekr.20031218072017.4063"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20031218072017.4064"><vh>Focus</vh>
<v t="ekr.20031218072017.4065"><vh>get_focus</vh></v>
<v t="ekr.20031218072017.2373"><vh>set_focus (app.gui)</vh></v>
<v t="ekr.20050210082320"><vh>widget_wants_focus (tk.gui)</vh></v>
</v>
<v t="ekr.20031218072017.4066"><vh>Font</vh>
<v t="ekr.20031218072017.2187"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20031218072017.4067"><vh>Icons</vh>
<v t="ekr.20031218072017.4068"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20031218072017.4069"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4070"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4071"><vh>Idle Time</vh>
<v t="ekr.20031218072017.4072"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20031218072017.4073"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20031218072017.4074"><vh>Indices (Tk)</vh>
<v t="ekr.20031218072017.4075"><vh>firstIndex</vh></v>
<v t="ekr.20031218072017.4076"><vh>lastIndex</vh></v>
<v t="ekr.20031218072017.4077"><vh>moveIndexBackward</vh></v>
<v t="ekr.20031218072017.4078"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20031218072017.4079"><vh>compareIndices</vh></v>
<v t="ekr.20031218072017.4080"><vh>getindex</vh></v>
</v>
<v t="ekr.20031218072017.4081"><vh>Insert Point</vh>
<v t="ekr.20031218072017.4082"><vh>getInsertPoint</vh></v>
<v t="ekr.20031218072017.4083"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20031218072017.4084"><vh>Selection</vh>
<v t="ekr.20031218072017.4085"><vh>getSelectionRange (to be deleted?)</vh></v>
<v t="ekr.20051126125950"><vh>getSelectedText</vh></v>
<v t="ekr.20031218072017.4086"><vh>getTextSelection</vh></v>
<v t="ekr.20051126171929"><vh>hasSelection</vh></v>
<v t="ekr.20031218072017.4088"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20031218072017.4089"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20031218072017.4090"><vh>Text</vh>
<v t="ekr.20031218072017.4091"><vh>getAllText</vh></v>
<v t="ekr.20031218072017.4092"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20031218072017.4093"><vh>getCharAtIndex</vh></v>
<v t="ekr.20031218072017.4094"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20031218072017.4095"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20031218072017.4096"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20031218072017.4097"><vh>Visibility</vh>
<v t="ekr.20031218072017.4098"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20051220144507"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20051126123249"><vh>class autoCompleterClass (prototype)</vh>
<v t="ekr.20051126123759"><vh> birth</vh>
<v t="ekr.20051126123759.1"><vh> ctor</vh></v>
<v t="ekr.20051126123759.2"><vh> getPublicCommands (autoCommandsClass)</vh></v>
</v>
<v t="ekr.20051127105431"><vh>abort</vh></v>
<v t="ekr.20051126122952.1"><vh>autoComplete</vh></v>
<v t="ekr.20051126123149"><vh>computeCompletionList (autoCompleter)</vh></v>
<v t="ekr.20051126131103"><vh>doBackSpace</vh></v>
<v t="ekr.20051126123249.1"><vh>doTabCompletion (autoCompleter)</vh></v>
<v t="ekr.20051127065601"><vh>extendSelection</vh></v>
<v t="ekr.20051127105102"><vh>finish</vh></v>
<v t="ekr.20051127070018"><vh>setSelection</vh></v>
<v t="ekr.20051126124705"><vh>stateHandler (autoCompleter)</vh></v>
</v>
</v>
<v t="ekr.20060108120501"><vh>Add @find node to scripting plugin</vh></v>
<v t="ekr.20060111152145"><vh>Improve scripts menu plugin</vh></v>
<v t="ekr.20051202095626"><vh>help-for-command</vh></v>
<v t="ekr.20050916180203"><vh>Make more commands undoable</vh></v>
<v t="ekr.20060116073539"><vh>Fix bugs in new minibuffer commands</vh>
<v t="ekr.20051202102337"><vh>Minibuffer commands notes</vh>
<v t="ekr.20051202102337.1"><vh>abbrevCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102337.2"><vh>bufferCommandsClass Inot ready yet)</vh></v>
<v t="ekr.20051202102337.3"><vh>controlCommandsClass (ok)</vh></v>
<v t="ekr.20051202102337.4"><vh>editCommandsClass</vh></v>
<v t="ekr.20051202102337.6"><vh>editFileCommandsClass</vh></v>
<v t="ekr.20051202102752.1"><vh>keyHandlerCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102752.2"><vh>killBufferCommandsClass</vh></v>
<v t="ekr.20051202102752.3"><vh>macroCommandsClass</vh></v>
<v t="ekr.20051202102752.4"><vh>queryReplaceCommandsClass</vh></v>
<v t="ekr.20051202102752.5"><vh>rectangleCommandsClass (ok)</vh></v>
<v t="ekr.20051202102752.6"><vh>registerCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.7"><vh>searchCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.8"><vh>spellCommandsClass (ok)</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060116073229"><vh>4.4.1</vh>
<v t="ekr.20051202094427"><vh>Resolve cvs conflicts</vh>
<v t="ekr.20031218072017.658"><vh>Resolve CVS Conflicts command (Stepen Schaefer)</vh>
<v t="ekr.20050501111900"><vh>Stephen Schaefer</vh></v>
<v t="ekr.20031218072017.659"><vh>Jonathon 1</vh></v>
<v t="ekr.20031218072017.660"><vh>Jonathan 2</vh></v>
<v t="ekr.20031218072017.661"><vh>Gil 1</vh></v>
<v t="ekr.20031218072017.662"><vh>Gil 2</vh></v>
</v>
</v>
<v t="ekr.20060116074450.2"><vh>Make positions permanent?</vh></v>
<v t="ekr.20060116074450.1"><vh>Bugs</vh>
<v t="ekr.20051104152338"><vh>Fix bug in Remove Sentinels command</vh>
<v t="ekr.20051104152338.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051014152256"><vh>Fix long-standing bug in import code</vh>
<v t="ekr.20040930075711"><vh>Handle underindented lines</vh></v>
<v t="ekr.20040722132104"><vh>Write script to report underindented lines</vh></v>
</v>
<v t="ekr.20060107082929"><vh>Fix problem reporting indentation errors</vh></v>
</v>
<v t="ekr.20060116073938.2"><vh>Other</vh>
<v t="ekr.20060110102039"><vh>--script option</vh>
<v t="ekr.20060110102239.1"><vh>leomain.py</vh>
<v t="ekr.20060110102239.2"><vh>def profile</vh></v>
<v t="ekr.20060110102239.3"><vh>def parseopts(argv)</vh></v>
<v t="ekr.20060110102239.4"><vh>concatate(sys.argv)</vh></v>
<v t="ekr.20060110102239.5"><vh>test run manual</vh></v>
<v t="ekr.20060110102239.6"><vh>notes</vh></v>
</v>
<v t="ekr.20060110102239.7"><vh>Leo hprof script</vh>
<v t="ekr.20060110102239.8"><vh>try: psyco</vh></v>
</v>
</v>
<v t="ekr.20060111134004"><vh>Run Idle in a separate process</vh>
<v t="ekr.20060111103821"><vh>This would fix weird crasher in Plugins Manager plugin</vh>
<v t="ekr.20060111103821.1"><vh>Report</vh></v>
</v>
<v t="ekr.20060111134004.1"><vh>Posting</vh></v>
<v t="ekr.20031218072017.2932"><vh>openPythonWindow (Dave Hein)</vh>
<v t="ekr.20031218072017.2933"><vh>&lt;&lt; open idle in Linux &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2934"><vh>&lt;&lt; open idle in Windows &gt;&gt;</vh>
<v t="ekr.20031218072017.2936"><vh>&lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2935"><vh>&lt;&lt; Try to open idle in Python 2.2 systems&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2937"><vh>leoPyShellMain</vh></v>
</v>
</v>
<v t="ekr.20051012062458.1"><vh>Strip quotes from color, font settings.</vh></v>
<v t="ekr.20060116074450.3"><vh>Put about dialog in a tab?</vh></v>
<v t="ekr.20051112080017"><vh>Problem removing script buttons on the mac</vh></v>
<v t="ekr.20060111103821.2"><vh>Fix problems with universalScrolling pluing</vh>
<v t="ekr.20060111103821.3"><vh>Report</vh></v>
</v>
<v t="ekr.20051110155735.1"><vh>Improve Spell tab</vh>
<v t="ekr.20051025071455"><vh>Spell classes (ok)</vh>
<v t="ekr.20051025071455.6"><vh>class Aspell</vh>
<v t="ekr.20051025071455.7"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.8"><vh>__init__</vh></v>
</v>
<v t="ekr.20051025071455.10"><vh>processWord</vh></v>
<v t="ekr.20051025071455.11"><vh>updateDictionary</vh></v>
</v>
<v t="ekr.20051025071455.1"><vh>class spellCommandsClass</vh>
<v t="ekr.20051025080056"><vh>ctor</vh></v>
<v t="ekr.20051025080420"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051025080633"><vh>openSpellTab</vh></v>
<v t="ekr.20051025080420.1"><vh>commands...</vh></v>
</v>
<v t="ekr.20051025071455.18"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20051025071455.19"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.20"><vh>spellTab.__init__</vh></v>
<v t="ekr.20051025094004"><vh>init_aspell</vh></v>
<v t="ekr.20051025071455.22"><vh>createSpellTab</vh>
<v t="ekr.20051113090322"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051025071455.23"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20051025071455.24"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025120920"><vh>createBindings (spellTab)</vh></v>
<v t="ekr.20051025071455.16"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20051025071455.29"><vh>Buttons</vh>
<v t="ekr.20051025071455.30"><vh>onAddButton</vh></v>
<v t="ekr.20051025071455.31"><vh>onIgnoreButton</vh></v>
<v t="ekr.20051025071455.32"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20051025071455.33"><vh>onFindButton</vh></v>
<v t="ekr.20051025071455.34"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20051025071455.36"><vh>Commands</vh>
<v t="ekr.20051025071455.37"><vh>add</vh></v>
<v t="ekr.20051025071455.38"><vh>change</vh></v>
<v t="ekr.20051025071455.40"><vh>find</vh></v>
<v t="ekr.20051025121408"><vh>hide</vh></v>
<v t="ekr.20051025071455.41"><vh>ignore</vh></v>
</v>
<v t="ekr.20051025071455.42"><vh>Helpers</vh>
<v t="ekr.20051025071455.43"><vh>bringToFront</vh></v>
<v t="ekr.20051025071455.44"><vh>fillbox</vh></v>
<v t="ekr.20051025071455.45"><vh>findNextMisspelledWord</vh>
<v t="ekr.20051025071455.46"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025071455.47"><vh>findNextWord</vh></v>
<v t="ekr.20051025071455.48"><vh>getSuggestion</vh></v>
<v t="ekr.20051025071455.49"><vh>onMap</vh></v>
<v t="ekr.20051025071455.50"><vh>onSelectListBox</vh></v>
<v t="ekr.20051025071455.51"><vh>update</vh></v>
<v t="ekr.20051025071455.52"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060103101524"><vh>Improve command-line handling</vh></v>
<v t="ekr.20050713105353"><vh>Add configuration setting to set menu fonts</vh>
<v t="ekr.20050713105353.1"><vh>Email from Martin Moncrieffe &lt;mcm35@cam.ac.uk&gt;</vh></v>
</v>
<v t="ekr.20050512031131"><vh>Use global_log_window_position to specify outline/log ratio?</vh></v>
<v t="ekr.20051016155819"><vh>treat plugins/options.py  differently?</vh></v>
<v t="ekr.20060102092148.1"><vh>--safe option</vh></v>
</v>
</v>
<v t="ekr.20051023192433"><vh>Maybe or never</vh>
<v t="ekr.20060120084705"><vh>Overwrite mode doesn't work in headllines</vh></v>
<v t="ekr.20060114052626"><vh>@alias nodes set minibuffer aliases</vh></v>
<v t="ekr.20060105143454.2"><vh>Convert Emacs-Style Names to Menu Style Names when creating undo name</vh></v>
<v t="ekr.20051220062654"><vh>Open .leo file in new process</vh></v>
<v t="ekr.20051207130144"><vh>Investigate Tk DnD</vh>
<v t="ekr.20051207130144.1"><vh>@url http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html</vh></v>
</v>
<v t="ekr.20051104051733"><vh>Make Focus-in in minibuffer widget equivalent to Alt-x</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3749"
marks="ekr.20031218072017.3781,ekr.20050921103230,"><vh>@thin leoMenu.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
</v>
</v>
<v t="ekr.20040803072955"
marks="ekr.20040803072955.139,ekr.20040803072955.141,"><vh>@thin leoTkinterTree.py</vh></v>
<v t="ekr.20031218072017.3748"
marks="ekr.20051010062551.1,"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20060116091116"><vh>Mousless Leo: First</vh>
<v t="ekr.20060120105605.1"><vh>Fixed problems with plain keys</vh>
<v t="ekr.20060120200529"><vh>Notes</vh></v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20060120193743"><vh>showInputState</vh></v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120082630"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
</v>
<v t="ekr.20060116085649"><vh>find-word-on-line, find-character-on-line (forward &amp; backward)</vh></v>
<v t="ekr.20060116085217"><vh>scroll-pane-up/down</vh></v>
<v t="ekr.20060116074839.2"><vh>extend-to-word, extend-to-paragraph, extend-to-sentence, etc.</vh></v>
<v t="ekr.20060116083359.1"><vh>expand-pane &amp; contract-pane</vh></v>
<v t="ekr.20051012053017.4"><vh>Search mode</vh></v>
</v>
<v t="ekr.20060120105605.1" a="TV"><vh>Fixed problems with plain keys</vh>
<v t="ekr.20060120200529"><vh>Notes</vh></v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060105132013"><vh>set-xxx-State &amp; setInputState</vh>
<v t="ekr.20060120200818"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20060120193743"><vh>showInputState</vh></v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
<v t="ekr.20051022094136"><vh>bindKeyHelper</vh></v>
<v t="ekr.20060120082630"><vh>plainKeyTag</vh></v>
</v>
<v t="ekr.20051023182326"><vh>k.copyBindingsToWidget &amp; helper</vh>
<v t="ekr.20060113062832.1"><vh>copyBindingsHelper</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.658">@nocolor

There have been a couple different suggestions on how to obtain a .leo file
that presents the conflicts for resolution.  My initial thought was to have
some sort of external file containing only the structure information of interest.
Edward has suggested that we could process the CVS created .leo file with all
its conflict indicators.

I'd like to offer another alternative: based on the ad-hoc procedure that Edward
is currently using, i.e.,

* Save your work to foo.leo file.
* copy your foo.leo file to fooCvsTmp.leo
* cvs ci
* if there are no conflicts (hurray)
*    remove fooCvsTmp.leo; finished
* otherwise
*    remove foo.leo
*    cvs up foo.leo
*    read foo.leo into an internal directed acyclic graph (DAG)
*    generate the conflict resolution DAG from the proposed new leo internal
DAG (which Leo already has as a matter of course) and the CVS derived DAG
*    present for editting
*    when you are satisfied and want to try to check in again, repeat.

From the user's point of view, a CVS check in either succeeds or requires that
the conflicts be resolved, after which another check in may be attempted.  If
we're somehow interrupted in the middle of the process, the fooCvsTmp.leo file
preserves the users work.
</t>
<t tx="ekr.20031218072017.659">https://sourceforge.net/forum/message.php?msg_id=1803722
By: jmgilligan

What is the intended behavior when foo.leo has a cloned node that appears several
times in a derived (or multiple derived files) and the user edits this file
or files to change two or more instances of the cloned node in different ways.

Example:

@file foo.py
****begin tnode
@others
****end tnode
...definition of procedure a
***begin tnode
def a:
...print "a:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

...definition of procedure b
***begin tnode
def b:
...print "b:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

...definition of procedure c
***begin tnode
def c:
...print "a:", &lt;&lt;bar&gt;&gt;
***end tnode
...&lt;&lt;bar&gt;&gt;
****begin tnode
"bar"
****end tnode

In the .leo, if I edit &lt;&lt;bar&gt;&gt;, it will change simultaneously in each place,
always in synch. However, suppose I edit foo.py in a text editor and change
foo.py to read:

#@+leo
#@+node:0::@file foo.py
#@+body
#@+others
#@+node:1::definition of a
#@+body
print "a:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"bar"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:1::definition of a
#@+node:2::definition of b
#@+body
print "b:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"variation b"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:2::definition of b
#@+node:3::definition of c
#@+body
print "c:", 
#@&lt;&lt;bar&gt;&gt;
#@+node:1::&lt;&lt;bar&gt;&gt;
#@+body
"variation c"
#@-body
#@-node:1::&lt;&lt;bar&gt;&gt;
#@-body
#@-node:3::definition of c
#@-others
#@-body
#@-node:0::@file foo.py
#@-leo

Now what is supposed to happen when leo tries to read foo.py back in? It seems
that there are three possible behaviors:

1) leo reports a conflict that the user needs to resolve.
2) leo breaks the clone: the three nodes become separate vnodes, not clones
of the same one.
3) leo arbitrarily takes one of the tnodes to be the new tnode for all of the
clones. This is currently what happens. It creates something like a race condition,
where the last node in the derived file determines what the final result will
be. In this case, all three tnodes get text "variation c".

This general question of how Leo should deal with conflicts in clone nodes seems
to me that it needs to be addressed, particularly with respect to trying to
avoid cvs conflicts via thick/thin modes.

Note that this can become quite a subtle question because the same node can
be cloned across several different derived files, in which case a serious race
condition may pertain.

At the least, I would like to see leo perform consistency checking on cloned
nodes when it reads a derived file back in and warn the user if cloned nodes
are inconsistent.

Note that the issue also occurs with OpenWith: I can open each instance of a
cloned node as a separate file in the external text editor. Which version is
read back into leo depends on the order in which I save them from the external
editor.
</t>
<t tx="ekr.20031218072017.660">By: jmgilligan ( Jonathan M. Gilligan ) 
 Possible solution   
2003-01-13 20:55  
One possible solution for the conflicting clones problem is to have Leo, when it detects a conflicting clone, generate a text file (perhaps named LeoConflict_NNNN.leo, where NNNN is the gid of the node in question), which contains all the different versions of the node in question, output in leo XML format. 

The vnode would then be marked with a "conflict" flag that would prevent the user from opening it in Leo until the conflict is resolved. See below for how the user resolves the conflict. 

What I have in mind is something similar to the CVS conflict file, where a conflict between two versions is marked 

&lt;&lt;&lt;&lt;&lt;&lt;&lt; 
blah blah blah? 
======= 
blah blah blah! 
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 

Except that we would output this file in Leo XML format. The reason for XML format would be to avoid problems of how to generically delimit the different sections (different versions of the cloned node). Here leo's XML tags can unambiguously delimit the sections. 

The user would then edit the conflict file and delete all but the desired version. Then he would tell leo to resolve the conflict by reading the corrected file in and replacing the contents of the conflicting node with the contents of the LeoConflict_NNNN.leo file. 

On the down side, this may well be too baroque a fix for a problem that most users may never encounter. If so, perhaps it's best left alone until more pressing problems are solved. I know what I am doing with Leo and am always careful NOT to generate conflicting clones when I edit in an external text editor, so I don't absolutely need a resolution to this problem. I raised it because it's good for a program to have well-defined behavior when presented with anomalous input. 

In this sense, perhaps the best thing is to allow users to generate code from clones (what Allan Holub referred to as "enough rope to shoot yourself in the foot"), but to tell them that this practice is frowned upon.  

 
</t>
<t tx="ekr.20031218072017.661">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1836117
By: gilshwartz

Edward, now that conflicting clones may not be the result of bad style, I would
like to propose yet another solution that I have been thinking of for a while.

My basic approach is that cloning is not just a convenience tool, it may also
reflect some of the properties of the code/code set. Therefore my goal is for
clone links to remain even if they are conflicting, and let the user resolve
them at any convenient time. I also think that Leo's user interface is the best
tool to resolve such conflicts.

Thus here is my view of clone management and resolution inside Leo. Anytime
content is loaded into Leo, if a clone set agrees (i.e. have the same content)
all clone copies are marked "green". When one green clone is edited, all green
clones are changed. This is Leo as it is now.

If at some point conflicting clones are loaded, Leo decides on some representing
content (may be based on policies like most occurring content, or latest timestamp,
etc.) and provides visual clues for the conflict. The visual clue is give by
a double node box, e.g.

+---------------+
+ clone org +
+---------------+
+ resolution +
+---------------+

such that it is a single node in the tree, but has two content node, the original
text, and the possibly arbitrary resolution.

The resolution pseudo node is marked "blue", while the original text is either
"green", if it is identical to the blue node, or "red", if it is not. To emphasis,
the red/green nodes contain the specific (possibly) unique code associated with
the derived file, while the pseudo blue node contains the shared clone content.
During save to derived files, only the red/green content is saved, so effectively
the file is not changed and the conflict is not resolved until the user chooses
to do so. However, the clone relationship (via the gti) remains.

During editing, changes to red/green clones are local and do not propagate to
other clone copies (actually any change to a green node would turn it red).
Changes to the blue nodes do propagate since it is a single view of the clone.
A node pair may be converted to a regular node, effectively getting a new gti
and eliminating the blue copy. Or, it may be converted to the shared copy,
effectively forgetting its original content (leaving only the blue node). Once
there are no more red nodes in a clone set, all its nodes become green again
and the conflict is resolved.

Some additional clone actions I think are useful are:

1. Go to next/prev clone.
2. Go to next/prev green clone (useful when there are red ones).
3. Convert all green copies to a new clone group (useful when some clone copies
needs to remain clones, but break from the original clone set, thus getting
a new clone gti)

Action 3 enables the user to partition its clone set to several clone groups
by copying a clone's original content to its blue copy and finding matching
(green) clones.

What do we gain by all this?

1. We can have conflicting clones without catastrophes.
2. We get tools to handle conflicts and resolve them.
3. We keep on working is Leo's environment, which is the most supportive one
we can expect.

Gil

(By the way, I have a feeling that it would be useful to include along with
the gti a hash of its node content, which could tell Leo is a node was changed
outside of it. Also, including a timestamp in the opening sentinel, indicating
when Leo last saved it. These may help having intelligent decisions by Leo in
cases like conflicting clones.)
</t>
<t tx="ekr.20031218072017.662">Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=1804169
By: gilshwartz

Another thing to think about is what should happen when close heading is changing.
Right now, if you are inside Leo, all headings will be changed, and if you try
to change by hand it in the derived file, clone links are removed (after some
error reporting). This is quite reasonable in the current scheme of things,
where one is not really expected to mess up with Leo sentinels.

However, if/when @include is implemented, one would probably edit some files
with clones that may extend to other files and changing the clone node name
(via Leo) is quite feasible. Note that the gti for the cloned node would probably
not change. So

1. Do Leo resync the clone content based on the gti?
2. Does it break cloning and allocates a new gti for one (arbitrary?) clone
set?
3. Let the user resolve manually, offer undoable auto-resolution with reporting,
other?

More things to think about.

Gil
</t>
<t tx="ekr.20031218072017.839">def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &amp;U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &amp;R reserved for Redo
        ("-",None),
        ("Cu&amp;t",f.OnCutFromMenu), 
        ("Cop&amp;y",f.OnCopyFromMenu),
        ("&amp;Paste",f.OnPasteFromMenu),
        ("&amp;Delete",c.editCommands.backwardDeleteCharacter),
        ("Select &amp;All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v</t>
<t tx="ekr.20031218072017.844">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20031218072017.845">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20031218072017.846">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20031218072017.1723">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName,minibufferCommand)
        realLabel = self.getRealMenuName(label)
        &lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)</t>
<t tx="ekr.20031218072017.1725"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
if minibufferCommand:
    commandName = command
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        bunch = bunchList and bunchList[0]
        accel = bunch and bunch.val
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    bunch = bunchList and bunchList[0]
    accel = bunch and bunch.val
    
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            bunch = bunchList and bunchList[0]
            accel = bunch and bunch.val
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)
    </t>
<t tx="ekr.20031218072017.1728">if rawKey:
    amp_index = rawKey.find("&amp;")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&amp;")</t>
<t tx="ekr.20031218072017.2187">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20031218072017.2373">def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if w:
        if c.config.getBool('trace_g.app.gui.set_focus'):
            g.trace('GUI',g.app.gui.widget_name(w),g.callers())
            
        if 0:
            w2 = c.frame.outerFrame.focus_get()
            w2 and g.trace(g.app.gui.widget_name(name2),c)

        if 0:
            # A fix to the cursed problems with Pmw.Notebook.
            # I am not happy with this, but it seems preferable to trying to figure out
            # all the places where the code must call update()
            
            # New in 4.4b1: the place to call update is *after* log pane operations.
            w.update() 

        w.focus_set()</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2932">def openPythonWindow(self):

    if sys.platform == "linux2":
        &lt;&lt; open idle in Linux &gt;&gt;
    else:
        &lt;&lt; open idle in Windows &gt;&gt;
</t>
<t tx="ekr.20031218072017.2933"># 09-SEP-2002 DHEIN: Open Python window under linux

try:
    pathToLeo = g.os_path_join(g.app.loadDir,"leo.py")
    sys.argv = [pathToLeo]
    from idlelib import idle
    if g.app.idle_imported:
        reload(idle)
    g.app.idle_imported = True
except:
    try:
        g.es("idlelib could not be imported.")
        g.es("Probably IDLE is not installed.")
        g.es("Run Tools/idle/setup.py to build idlelib.")
        g.es("Can not import idle")
        g.es_exception() # This can fail!!
    except: pass
</t>
<t tx="ekr.20031218072017.2934"># Initialize argv: the -t option sets the title of the Idle interp window.
sys.argv = ["leo"] # ,"-t","Leo"]

ok = False
if g.CheckVersion(sys.version,"2.3"):
    &lt;&lt; Try to open idle in Python 2.3 systems &gt;&gt;
else:
    &lt;&lt; Try to open idle in Python 2.2 systems &gt;&gt;

if not ok:
    g.es("Can not import idle")
    if idle_dir and idle_dir not in sys.path:
        g.es("Please add '%s' to sys.path" % idle_dir)</t>
<t tx="ekr.20031218072017.2935">try:
    executable_dir = g.os_path_dirname(sys.executable)
    idle_dir = g.os_path_join(executable_dir,"Tools","idle")

    # 1/29/04: sys.path doesn't handle unicode in 2.2.
    idle_dir = str(idle_dir) # May throw an exception.

    # 1/29/04: must add idle_dir to sys.path even when using importFromPath.
    if idle_dir not in sys.path:
        sys.path.insert(0,idle_dir)

    if 1:
        import PyShell
    else: # Works, but is not better than import.
        PyShell = g.importFromPath("PyShell",idle_dir)

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    if 1: # Mostly works, but causes problems when opening other .leo files.
        PyShell.main()
    else: # Doesn't work: destroys all of Leo when Idle closes.
        self.leoPyShellMain()
    ok = True
except ImportError:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20031218072017.2936">try:
    idle_dir = None
    
    import idlelib.PyShell

    if g.app.idle_imported:
        reload(idle)
        g.app.idle_imported = True
        
    idlelib.PyShell.main()
    ok = True

except:
    ok = False
    g.es_exception()</t>
<t tx="ekr.20031218072017.2937">@ The key parts of Pyshell.main(), but using Leo's root window instead of a new Tk root window.

This does _not_ work well.  Using Leo's root window means that Idle will shut down Leo without warning when the Idle window is closed!
@c

def leoPyShellMain(self):
    
    import PyShell
    root = g.app.root
    PyShell.fixwordbreaks(root)
    flist = PyShell.PyShellFileList(root)
    shell = PyShell.PyShell(flist)
    flist.pyshell = shell
    shell.begin()</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3752">def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()</t>
<t tx="ekr.20031218072017.3753">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()</t>
<t tx="ekr.20031218072017.3754">def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &amp;Section",c.extractSection),
        ("Extract &amp;Names",c.extractSectionNames),
        ("&amp;Extract",c.extract),
        ("-",None,None),
        ("Convert All B&amp;lanks",c.convertAllBlanks),
        ("Convert All T&amp;abs",c.convertAllTabs),
        ("Convert &amp;Blanks",c.convertBlanks),
        ("Convert &amp;Tabs",c.convertTabs),
        ("Insert Body Time/&amp;Date",c.insertBodyTime),
        ("&amp;Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&amp;Indent",c.indentBody),
        ("&amp;Unindent",c.dedentBody),
        ("&amp;Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u</t>
<t tx="ekr.20031218072017.3755">def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &amp;Headline",c.editHeadline),
        ("&amp;End Edit Headline",f.endEditLabelCommand),
        ("&amp;Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&amp;Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]</t>
<t tx="ekr.20031218072017.3756">def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    if 1: # Bind to the Find tab.
        sc = c.searchCommands
        self.editMenuFindMenuTable = [
            ("&amp;Show Find Tab",sc.openFindTab),
            ("&amp;Hide Find Tab",sc.hideFindTab),
            ("-",None),
            ("Find &amp;Next",          sc.findTabFindNext),
            ("Find &amp;Previous",      sc.findTabFindPrev),
            ("&amp;Replace",            sc.findTabChange),
            ("Replace, &amp;Then Find", sc.findTabChangeThenFind),
        ]
    else: # Bind to deprecated Find dialog.
        self.editMenuFindMenuTable = [
            ("&amp;Find Panel",c.showFindPanel),
            ("-",None),
            ("Find &amp;Next",c.findNext),
            ("Find &amp;Previous",c.findPrevious),
            ("&amp;Replace",c.replace),
            ("Replace, &amp;Then Find",c.replaceThenFind),
        ]</t>
<t tx="ekr.20031218072017.3757">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20031218072017.3758">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()</t>
<t tx="ekr.20031218072017.3759">def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&amp;New",c.new),
        ("&amp;Open...",c.open),
    ]</t>
<t tx="ekr.20031218072017.3760">def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&amp;Close",c.close),
        ("&amp;Save",c.save),
        ("Save &amp;As",c.saveAs),
        ("Save To",c.saveTo), # &amp;Tangle
        ("Re&amp;vert To Saved",c.revert), # &amp;Read/Write
    ]</t>
<t tx="ekr.20031218072017.3761">def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&amp;Read Outline Only",c.readOutlineOnly),
        ("Read @file &amp;Nodes",c.readAtFileNodes),
        ("-",None),
        ("Write &amp;Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &amp;Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &amp;Outline Only",fc.writeOutlineOnly),
        ("&amp;Write @file Nodes",fc.writeAtFileNodes),
    ]</t>
<t tx="ekr.20031218072017.3762">def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &amp;All",c.tangleAll),
        ("Tangle &amp;Marked",c.tangleMarked),
        ("&amp;Tangle",c.tangle),
    ]</t>
<t tx="ekr.20031218072017.3763">def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &amp;All",c.untangleAll),
        ("Untangle &amp;Marked",c.untangleMarked),
        ("&amp;Untangle",c.untangle),
    ]</t>
<t tx="ekr.20031218072017.3764">def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&amp;file",c.importAtFile),
        ("Import To @&amp;root",c.importAtRoot),
        ("Import &amp;CWEB Files",c.importCWEBFiles),
        ("Import &amp;noweb Files",c.importNowebFiles),
        ("Import Flattened &amp;Outline",c.importFlattenedOutline),
    ]</t>
<t tx="ekr.20031218072017.3765">def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &amp;Headlines",c.exportHeadlines),
        ("Outline To &amp;CWEB",c.outlineToCWEB),
        ("Outline To &amp;Noweb",c.outlineToNoweb),
        ("&amp;Flatten Outline",c.flattenOutline),
        ("&amp;Remove Sentinels",c.removeSentinels),
        ("&amp;Weave",c.weave),
    ]</t>
<t tx="ekr.20031218072017.3766">def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&amp;xit",g.app.onQuit),
    ]</t>
<t tx="ekr.20031218072017.3767">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()</t>
<t tx="ekr.20031218072017.3768">def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&amp;ut Node",c.cutOutline),
        ("C&amp;opy Node",c.copyOutline),
        ("&amp;Paste Node",c.pasteOutline),
        ("Pas&amp;te Node As Clone",c.pasteOutlineRetainingClones),
        ("&amp;Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&amp;Insert Node",c.insertHeadline),
        ("&amp;Clone Node",c.clone),
        ("Sort Childre&amp;n",c.sortChildren), # Conflicted with Hoist.
        ("&amp;Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&amp;Hoist",c.hoist),
        ("D&amp;e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x</t>
<t tx="ekr.20031218072017.3769">def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&amp;Contract All",c.contractAllHeadlines),
        ("Contract &amp;Node",c.contractNode),
        ("Contract &amp;Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&amp;rev Level",c.expandPrevLevel),
        ("Expand N&amp;ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &amp;1",c.expandLevel1),
        ("Expand To Level &amp;2",c.expandLevel2),
        ("Expand To Level &amp;3",c.expandLevel3),
        ("Expand To Level &amp;4",c.expandLevel4),
        ("Expand To Level &amp;5",c.expandLevel5),
        ("Expand To Level &amp;6",c.expandLevel6),
        ("Expand To Level &amp;7",c.expandLevel7),
        ("Expand To Level &amp;8",c.expandLevel8),
        ("-",None),
        ("Expand &amp;All",c.expandAllHeadlines),
        ("Expand N&amp;ode",c.expandNode),
    ]</t>
<t tx="ekr.20031218072017.3770">def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &amp;Down",c.moveOutlineDown),
        ("Move &amp;Left",c.moveOutlineLeft),
        ("Move &amp;Right",c.moveOutlineRight),
        ("Move &amp;Up",c.moveOutlineUp),
        ("-",None),
        ("&amp;Promote",c.promote),
        ("&amp;Demote",c.demote),
    ]</t>
<t tx="ekr.20031218072017.3771">def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&amp;Mark",c.markHeadline),
        ("Mark &amp;Subheads",c.markSubheads),
        ("Mark Changed &amp;Items",c.markChangedHeadlines),
        ("Mark Changed &amp;Roots",c.markChangedRoots),
        ("Mark &amp;Clones",c.markClones),
        ("&amp;Unmark All",c.unmarkAll),
    ]</t>
<t tx="ekr.20031218072017.3772">def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]</t>
<t tx="ekr.20031218072017.3773">def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&amp;Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &amp;Active Pane",f.toggleActivePane),
        ("Toggle &amp;Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&amp;de",f.cascade),
        ("&amp;Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &amp;Compare Window",c.openCompareWindow),
        ("Open &amp;Python Window",c.openPythonWindow),
    ]</t>
<t tx="ekr.20031218072017.3774">def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&amp;About Leo...",c.about),
        ("Online &amp;Home Page",c.leoHome),
        ("Open Online &amp;Tutorial",c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &amp;Offline Tutorial",f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&amp;Docs.leo",c.leoDocumentation),
        ("Open Leo&amp;Plugins.leo",c.openLeoPlugins),
        ("Open Leo&amp;Settings.leo",c.openLeoSettings),
    ]</t>
<t tx="ekr.20031218072017.3785">def createMenusFromTables (self):
    
    c = self.c
    
    self.defineMenuTables()
    
    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()
    
    g.doHook("create-optional-menus",c=c)
    
    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()</t>
<t tx="ekr.20031218072017.3786">def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&amp;Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    &lt;&lt; create the edit body submenu &gt;&gt;
    &lt;&lt; create the edit headline submenu &gt;&gt;
    &lt;&lt; create the find submenu &gt;&gt;
    
    self.createMenuEntries(editMenu,self.editMenuTop2Table)</t>
<t tx="ekr.20031218072017.3787">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)</t>
<t tx="ekr.20031218072017.3788">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)</t>
<t tx="ekr.20031218072017.3789">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)</t>
<t tx="ekr.20031218072017.3790">def createFileMenuFromTable (self):
    
    c = self.c
    fileMenu = self.createNewMenu("&amp;File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &amp;With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    &lt;&lt; create the recent files submenu &gt;&gt;
    self.add_separator(fileMenu)
    &lt;&lt; create the read/write submenu &gt;&gt;
    &lt;&lt; create the tangle submenu &gt;&gt;
    &lt;&lt; create the untangle submenu &gt;&gt;
    &lt;&lt; create the import submenu &gt;&gt;
    &lt;&lt; create the export submenu &gt;&gt;
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)</t>
<t tx="ekr.20031218072017.3791">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()</t>
<t tx="ekr.20031218072017.3792">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)</t>
<t tx="ekr.20031218072017.3793">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)</t>
<t tx="ekr.20031218072017.3794">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)</t>
<t tx="ekr.20031218072017.3795">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)</t>
<t tx="ekr.20031218072017.3796">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)</t>
<t tx="ekr.20031218072017.3797">def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&amp;Outline")
    
    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)
    
    &lt;&lt; create check submenu &gt;&gt;
    &lt;&lt; create expand/contract submenu &gt;&gt;
    &lt;&lt; create move submenu &gt;&gt;
    &lt;&lt; create mark submenu &gt;&gt;
    &lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="ekr.20031218072017.3798">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)</t>
<t tx="ekr.20031218072017.3799">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)</t>
<t tx="ekr.20031218072017.3800">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)</t>
<t tx="ekr.20031218072017.3801">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)</t>
<t tx="ekr.20031218072017.3802">def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&amp;Window")
    
    self.createMenuEntries(windowMenu,self.windowMenuTopTable)</t>
<t tx="ekr.20031218072017.3803">def createHelpMenuFromTable (self):

    helpMenu = self.createNewMenu("&amp;Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTopTable)
    
    if sys.platform=="win32":
        self.createMenuEntries(helpMenu,self.helpMenuTop2Table)
    
    self.createMenuEntries(helpMenu,self.helpMenuTop3Table)</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.4059"></t>
<t tx="ekr.20031218072017.4060"></t>
<t tx="ekr.20031218072017.4061"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4062">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4063"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20031218072017.4064"></t>
<t tx="ekr.20031218072017.4065">def get_focus(self,frame):
    
    """Returns the widget that has focus, or body if None."""

    return frame.top.focus_displayof()</t>
<t tx="ekr.20031218072017.4066"></t>
<t tx="ekr.20031218072017.4067"></t>
<t tx="ekr.20031218072017.4068">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20031218072017.4069">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20031218072017.4070"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20031218072017.4071"></t>
<t tx="ekr.20031218072017.4072">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4073">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4074"></t>
<t tx="ekr.20031218072017.4075">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20031218072017.4076">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20031218072017.4077">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20031218072017.4078">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20031218072017.4079">def compareIndices (self,t,n1,rel,n2):
    return t.compare(n1,rel,n2)</t>
<t tx="ekr.20031218072017.4080">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20031218072017.4081"></t>
<t tx="ekr.20031218072017.4082">def getInsertPoint(self,t):

    return t.index("insert")</t>
<t tx="ekr.20031218072017.4083">def setInsertPoint (self,t,pos):

    return t.mark_set("insert",pos)</t>
<t tx="ekr.20031218072017.4084"></t>
<t tx="ekr.20031218072017.4085">def getSelectionRange (self,t):

    return t.tag_ranges("sel")</t>
<t tx="ekr.20031218072017.4086">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20031218072017.4088">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20031218072017.4089">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    
    # New in 4.4a5: this logic ensures compatibility with previous code.
    if insert == 'sel.end':
        g.app.gui.setInsertPoint(t,end)
    elif insert is not None:
        g.app.gui.setInsertPoint(t,insert)
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20031218072017.4090"></t>
<t tx="ekr.20031218072017.4091">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""
    
    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4092">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4093">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4094">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4095">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4096">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20031218072017.4097"></t>
<t tx="ekr.20031218072017.4098">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self,command,name,minibufferCommand):
    
    if minibufferCommand:
        
        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')
        
        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label,event)
    
        return minibufferMenuCallback
        
    else:
    
        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label)
    
        return legacyMenuCallback</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 beta 1, build %s, January 17, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.377 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040711140738">def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &amp;Outline",c.checkOutline),
        ("&amp;Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &amp;All Python Code",c.checkAllPythonCode),
        ("&amp;Check Python &amp;Code",c.checkPythonCode),
        ("-",None),
        ("Pretty P&amp;rint All Python Code",c.prettyPrintAllPythonCode),
        ("&amp;Pretty Print Python Code",c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r</t>
<t tx="ekr.20040711140738.1">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)</t>
<t tx="ekr.20040722132104"></t>
<t tx="ekr.20040803072955.79">def onClickBoxClick (self,event):
    
    c = self.c ; p1 = c.currentPosition()
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing() # Bug fix: 12/19/05
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.frame.treeWantsFocus()
            else:
                c.frame.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20040803072955.88">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20040803072955.90"></t>
<t tx="ekr.20040803072955.91"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; frame = c.frame ; u = c.undoer
    w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        # g.trace(repr(s),g.callers())
        if changed:
            # g.trace('changed: old',repr(oldRevert),'new',repr(s))
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
        else:
            pass # g.trace('not changed')
    finally:
        c.endUpdate()
        if self.stayInTree:
            frame.treeWantsFocus()
        else:
            frame.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)</t>
<t tx="ekr.20040803072955.94"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20040803072955.134"></t>
<t tx="ekr.20040803072955.135">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.frame.widgetWantsFocus(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20040803072955.136">def setSelectedLabelState (self,p): # selected, disabled

    if p and p.edit_widget():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20040803072955.138">def setUnselectedLabelState (self,p): # not selected.

    if p and p.edit_widget():
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20040803072955.139">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")

    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.140">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color") or 'white'
    selbg = c.config.getColor("headline_text_editing_selection_background_color") or 'black'
    
    try: # Use system defaults for selection foreground/background
        w.configure(state="normal",highlightthickness=1,
        fg=fg,bg=bg,selectforeground=selfg,selectbackground=selbg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.141">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_widget()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg,
            selectbackground=bg,selectforeground=fg,highlightbackground=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040930075711">@nocolor

Leo can't represent some files using nodes!

I call this the "underindented blank line" problem.

Example:

@color

class aClass:
    def spam(): pass
# comment line
    def eggs(): pass
    
@nocolor

Leo's import code can't handle this:
    
- If the import code puts the comment line in a node, the line won't be output with the proper indentation!!

- Having the comment line stop the scanning of aClass is even worse.

- This usually shows up with an unindented blank line instead of the comment line.</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041120112043">def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = nextMode = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
    
    # New in Leo 4.4b2.
    i = g.skip_ws(s,i)
    if g.match(s,i,'-&gt;'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+2)
        i = g.skip_id(s,j)
        nextMode = s[j:i]
        if not nextMode.strip(): nextMode = 'none'
    else: nextMode = 'none'
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace.
    comment = ''
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            # comment = val[i:].strip()
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(nextMode=nextMode,pane=pane,val=val)</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20050210082320">def widget_wants_focus(self,c,widget):

    """Indicate that a widget want to get focus."""
    
    c and c.frame.widgetWantsFocus(widget)
        
widgetWantsFocus = widget_wants_focus</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050501111900">@killcolor
https://sourceforge.net/forum/message.php?msg_id=3125092
By: thyrsus

About a month ago, I posted a screed on how @thin was inadequate to address
my needs; that what I needed to collaborate on via version control was exactly
the essence of Leo's value: the multiple expressions of structure, which by
their nature must exist outside of @thin.  I said I was going to live the pain
to discover a modus vivendi.

Having done that, let me now say:

AAAAAAAAAAAAGGGGGGGGHHHHHHHHHH!

But the exercise has led me to a vision, which I will implement to the extent
my nonexistent spare time and paltry programming talents permit.

The essence of the pain is "conflicts", which become more  certain to occur
as the leo file encompases ever more related files.  As I work on a change to
the Linux configuration, my colleague works on a change to the Solaris configuration,
and one of us checks in our version of the leo file documenting the site
configuration first, and the other cannot check in his version of that file.
The conflict must be resolved by the human.  Using the "diff" tool on the .leo
XML is not an answer (though thank Heaven and Ed for gnxs).  The resolution
needs two levels of support: outline and node.

With the .leo file declared binary, in the event of a conflict CVS leaves you
with the most recent CVS version and your rejected version, and you're responsible
for performing a reconciliation and then resubmitting that.  Leo will recognize
the problem, and present both versions of the project, side by side, splitting
the outline pane.  The parallel trees will scroll/expand/contract in unison.
Outline branches present in CVS and not yours will display as blank space in
your version; nodes present in your version and not CVS will display as blank
space in the CVS version. The CVS version will be read only, your version editable.
The same node with differences in its text or in its children will be highlighted.
You will be able to drag nodes from the CVS version into your version. If the
text of a selected node has conflicts, the text area will split in two, showing
the CVS version and your version, with differences highlighted, both sides of
the pane scrolling in unison, the CVS side read-only, and you can copy from
that side to your side.  I intend to take as many ideas as I can from tkdiff
(http://sourceforge.net/projects/tkdiff/ - see also
http://freshmeat.net/screenshots/10602/ ).  (I have begun translating tkdiff
from from tcl to python - nearly 9000 lines and I'm still learning both languages,
so draw your own timeline.)  You edit your nodes, you edit your tree, you hit
the "reconcile" button, and your reconciliation of the conflict goes into CVS.
If, meanwhile, another one of your over-achieving colleages has again updated
CVS, the process repeats with the most current CVS version.  Or you can hit
the "abandon" button to give up on your changes.

As the Hebrews say at Passover: "Next year in Jerusalem."</t>
<t tx="ekr.20050512031131"></t>
<t tx="ekr.20050707085637">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3237845
By: eichin

Finally, one comment from the talk that bothered me for a while and didn't click
until later - "emacs doesn't really have an outline mode".  This is true, at
face value - outline mode in fact is just some regexp and hiding kludging, powerful
in it's own way but not "deep".  However, the operations felt familiar, and
it wasn't until I went home and checked mail that I caught it -- *GNUS* is actually
surprisingly close in function set to an outliner.  Not in any immediately useful
way, but it both clarifies why I think emacs could work this way *and* possibly
clarifies why gnus users are so engaged by the interface :-)  Though that does
mean gnus might be a reasonable source of suggestions for key bindings...</t>
<t tx="ekr.20050711091931">def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]</t>
<t tx="ekr.20050713105353"></t>
<t tx="ekr.20050713105353.1">@nocolor

I have looked into leo's code and managed to figure out how to change 
some fonts. Here's what I did to change the menu fonts for example.

Fonts for the menu can be set in Code-&gt;Gui Tkinter classes-&gt;@thin 
leoTkinterMenu.py-&gt;Tkinter menu bindings-&gt;Routines with Tk 
spellings-&gt;new_menu

so to use the system font (linux) I changed the return statement to:

return Tk.Menu(parent,tearoff=tearoff, font=("System",11))

I'll try using .leo_xresources file and see if that works as well.</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050916180203"></t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    
    # The last kind of search
    
    self.forward = True
    self.incremental = True
    self.regexp = False
    self.word = True
    self.searchString = ''
    self.replaceString = '' # Not used yet.
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':            self.hideFindTab,
        'open-find-tab':            self.openFindTab,
        'find-tab-find':            self.findTabFindNext,
        'find-tab-find-prev':       self.findTabFindPrev,
        'find-tab-change':          self.findTabChange,
        'find-tab-change-all':      self.findTabChangeAll,
        'find-tab-change-then-find':self.findTabChangeThenFind,

        'isearch-forward':          self.isearchForward,
        'isearch-backward':         self.isearchBackward,
        'isearch-forward-regexp':   self.isearchForwardRegexp,
        'isearch-backward-regexp':  self.isearchBackwardRegexp,
        
        're-search-forward':        self.reSearchForward,
        're-search-backward':       self.reSearchBackward,
        
        'search-again':             self.searchAgain,
        'search-forward':           self.searchForward,
        'search-backward':          self.searchBackward,
        'word-search-forward':      self.wordSearchForward,
        'word-search-backward':     self.wordSearchBackward,
    }</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.frame.minibufferWantsFocus()</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    s = k.getLabel(ignorePrompt=True)
    
    self.incremental = True
    self.forward = forward
    self.regexp = regexp
    # g.trace(forward,repr(s))
    if s:
        try:
            if forward:
                i = w.search(s,"insert + 1c",stopindex='end',regexp=regexp)
                if not i:
                    # Start again at the top of the buffer.
                    i = w.search(s,'1.0',stopindex='insert',regexp=regexp)
            else:
                i = w.search(s,'insert',backwards=True,stopindex='1.0',regexp=regexp)
                if not i:
                    # Start again at the bottom of the buffer.
                    i = w.search(s,'end',backwards=True,stopindex='insert',regexp=regexp)
            
        except: pass

        if i and not i.isspace():
            w.mark_set('insert',i)
            w.see('insert')</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.frame.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        if 0: # Doesn't do anything at present.
            &lt;&lt; do a non-incremental search &gt;&gt;
        k.resetLabel()
        k.clearState()
        return

    if ch == '\b':
        g.trace('backspace not handled yet')
        return
    
    if ch:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        z = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if not z:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d
    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20050920084036.267"></t>
<t tx="ekr.20050920084036.268">def plainSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w ; i = w.index('insert')
    
    self.forward = forward
    self.incremental = False
    self.regexp = False
    self.searchString = pattern
    self.word = False

    try:
        if forward:
            s = w.search(pattern,i,stopindex='end')
            if s: s = w.index('%s +%sc' % (s,len(pattern)))
        else:
            s = w.search(pattern,i,stopindex='1.0',backwards=True)
    except Exception:
        return

    if s:
        w.mark_set('insert',s)</t>
<t tx="ekr.20050920084036.269">def searchBackward (self,event):

    k = self.k ; state = k.getState('search-backward')
    if state == 0:
        k.setLabelBlue('Search Backward: ',protect=True)
        k.getArg(event,'search-backward',1,self.searchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self._word = False
        self.forward = False
        self.plainSearchHelper(event,k.arg,forward=False)

def searchForward (self,event):

    k = self.k ; state = k.getState('search-forward')
    if state == 0:
        k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,'search-forward',1,self.searchForward)
    else:
        k.clearState()
        k.resetLabel()
        self._word = False
        self.forward = True
        self.plainSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.272">def wordSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w ; i = w.index('insert')
    
    self.forward = forward
    self.incremental = False
    self.regexp = False
    self.searchString = pattern
    self.word = True
    
    words = pattern.split()
    sep = '[%s%s]+' % (string.punctuation,string.whitespace)
    pattern = sep.join(words)
    cpattern = re.compile(pattern)
    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        if not match: return
        end = match.end()
    else:
        txt = w.get('1.0','insert') #initially the reverse words formula for Python Cookbook was going to be used.
        a = re.split(pattern,txt) #that didnt quite work right.  This one apparently does.
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return
        
    s = g.choose(forward,'insert +%sc','insert -%sc')
    w.mark_set('insert',s % end)
    w.see('insert')
</t>
<t tx="ekr.20050920084036.274">def reSearchBackward (self,event):

    k = self.k ; state = k.getState('re-search-backward')
    if state == 0:
        k.setLabelBlue('Regexp Search backward:',protect=True)
        k.getArg(event,'re-search-backward',1,self.reSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=False)

def reSearchForward (self,event):

    k = self.k ; state = k.getState('re-search-forward')
    if state == 0:
        k.setLabelBlue('Regexp Search:',protect=True)
        k.getArg(event,'re-search-forward',1,self.reSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.275">def reSearchHelper (self,event,pattern,forward):

    k = self.k ; w = self.w
    cpattern = re.compile(pattern)
    
    self.forward = forward
    self.incremental = False
    self.regexp = True
    self.searchString = pattern
    # self.word = self.word

    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        end = match.end()
    else:
        # The reverse words formula for Python Cookbook didn't quite work.
        txt = w.get('1.0','insert') 
        a = re.split(pattern,txt)
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return

    if end:
        s = g.choose(forward,'insert +%sc','insert -%sc')
        w.mark_set('insert',s % end)
        w.see('insert')</t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunchList = k.bindingsDict.get(shortcut,[])
    k.computeKeysym_numDicts(shortcut)
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyHelper(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        k.bindingsDict [shortcut] = bunchList
        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20050920085536.32"></t>
<t tx="ekr.20050920085536.41">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; f = c.frame ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.completionFocusWidget = g.app.gui.get_focus(c.frame)
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        f.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        c.frame.widgetWantsFocus(k.completionFocusWidget) # Important, so cut-text works, e.g.
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        f.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        f.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        f.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20050920085536.45">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20050920085536.48">def repeatComplexCommand (self,event):

    k = self

    if k.mb_history:
        k.setState('last-altx',1,handler=k.doLastAltX)
        k.setLabelBlue("Redo: %s" % k.mb_history[0])
    return 'break'
    
def doLastAltX (self,event):
    
    k = self ; c = k.c

    if event.keysym == 'Return' and k.mb_history:
        last = k.mb_history [0]
        c.commandsDict [last](event)
        return 'break'
    else:
        return k.keyboardQuit(event)</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    k.func = func
    k.funcReturn = None # For unit testing.
    if commandName is None:
        commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None or ch != '' # or stroke != '&lt;Key&gt;'
    
    if trace and interesting:
        g.trace(
            'c',c,
            'stroke:',stroke,'ch:',repr(ch),'keysym:',repr(keysym),
            'widget:',w and g.app.gui.widget_name(w),'func',func,
            g.callers())

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if k.inState():
        val = k.callStateFunction(event) # Calls end-command.
        if val != 'do-func': return 'break'
        g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('leoCallback') or commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920085536.68">def negativeArgument (self,event):

    k = self ; state = k.getState('neg-arg')

    if state == 0:
        k.setLabelBlue('Negative Argument: ',protect=True)
        k.setState('neg-arg',1,k.negativeArgument)
    else:
        k.clearState()
        k.resetLabel()
        func = k.negArgFunctions.get(k.stroke)
        if func:
            func(event)

    return 'break'</t>
<t tx="ekr.20050920085536.77">def numberCommand (self,event,stroke,number):

    k = self ; k.stroke = stroke ; w = event.widget

    k.universalDispatcher(event)
    w.event_generate('&lt;Key&gt;',keysym=number)

    return 'break'

def numberCommand0 (self,event): return self.numberCommand (event,None,0)
def numberCommand1 (self,event): return self.numberCommand (event,None,1)
def numberCommand2 (self,event): return self.numberCommand (event,None,2)
def numberCommand3 (self,event): return self.numberCommand (event,None,3)
def numberCommand4 (self,event): return self.numberCommand (event,None,4)
def numberCommand5 (self,event): return self.numberCommand (event,None,5)
def numberCommand6 (self,event): return self.numberCommand (event,None,6)
def numberCommand7 (self,event): return self.numberCommand (event,None,7)
def numberCommand8 (self,event): return self.numberCommand (event,None,8)
def numberCommand9 (self,event): return self.numberCommand (event,None,9)</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)</t>
<t tx="ekr.20050921094025">@nocolor</t>
<t tx="ekr.20050921103230">def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()
    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
</t>
<t tx="ekr.20050921103736">def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&amp;mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table,sep in (
        ('Abbrev...',       self.cmdsMenuAbbrevTable,       False),
        ('Buffers...',      self.cmdsMenuBuffersTable,      False),
        ('Center...',       self.cmdsMenuCenterTable,       False),
        ('Change Case...',  self.cmdsMenuChangeCaseTable,   False),
        ('Indent...',       self.cmdsMenuIndentTable,       False),
        ('Macro...',        self.cmdsMenuMacroTable,        False),
        ('Rectangles...',   self.cmdsMenuRectanglesTable,   False),
        ('Registers...',    self.cmdsMenuRegistersTable,    False),
        ('Sort...',         self.cmdsMenuSortTable,         False),
        ('Spell Check...',  self.cmdsMenuSpellCheckTable,   False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20050923213858">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0

# For modes
self.modeBunch = None</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20050930080419">def universalArgument (self,event):
    
    '''Begin a numeric argument for the following command.'''
    
    k = self
    k.setLabelBlue('Universal Argument: ',protect=True)
    k.universalDispatcher(event)
    
def digitArgument (self,event):

    k = self
    k.setLabelBlue('Digit Argument: ',protect=True)
    k.universalDispatcher(event)</t>
<t tx="ekr.20051001050607">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    # The command may have closed the window.
    if g.app.quitting or not c.exists: return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        if 0: # Do *not* call this by default.  It interferes with undo.
            c.frame.body.onBodyChanged(undoType='Typing')</t>
<t tx="ekr.20051001051355"></t>
<t tx="ekr.20051002111614">def wordSearchBackward (self,event):

    k = self.k ; state = k.getState('word-search-backward')
    if state == 0:
        k.setLabelBlue('Word Search Backward: ',protect=True)
        k.getArg(event,'word-search-backward',1,self.wordSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.forward = False
        self.wordSearchHelper(event,k.arg,forward=False)

def wordSearchForward (self,event):

    k = self.k ; state = k.getState('word-search-forward')
    if state == 0:
        k.setLabelBlue('Word Search: ',protect=True)
        k.getArg(event,'word-search-forward',1,self.wordSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.forward = True
        self.wordSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20051002120125">s = k.getLabel(ignorePrompt=True)

if s:
    if self.forward:
        if self.regexp: self.reSearchForward(event)
        else:           self.searchForward(event)
    else:
        if self.regexp: self.reSearchBackward(event)
        else:           self.searchBackward(event)</t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.keysym_numberDict = {}
    # Keys are keysym_num's.  Values are strokes.
self.keysym_numberInverseDict = {}
    # Keys are strokes, values are keysym_num's.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20051006125633"></t>
<t tx="ekr.20051006125633.1">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)
    
    # if k.isPlainKey(shortcut):
        # g.trace('Ignoring plain key binding of %s to %s' % (shortcut,commandName))
        # return

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback1 (event,k=k,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
            
        keyCallback = keyCallback1
    else:
        
        # g.trace(commandName,shortcut,g.callers())

        def menuFuncCallback (event,command=command,commandName=commandName):
            return command(event)

        def keyCallback2 (event,k=k,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke,commandName=commandName)
            
        keyCallback = keyCallback2
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20051007080058">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    k.makeSpecialBindings()
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.checkBindings()
    
    if 0:
    
        # Print the keysym_num dicts.
        d = k.keysym_numberInverseDict
        keys = d.keys() ; keys.sort()
        for key in key():
            n = d.get(key)
            # print 'keysym_num for %s = %d' % (key,n)</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008134059">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val
            if accel:
                bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
                k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
                if 0:
                    if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
                    else:     g.trace(commandName)</t>
<t tx="ekr.20051008135051.1">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20051008152134">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        #('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        # ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        # ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        # ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        # ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        # ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunchList = c.config.getShortcut(commandName)
        # g.trace(commandName,bunchList)
        if bunchList:
            for bunch in bunchList:
                accel = (bunch and bunch.val)
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)
        else:
            accel = stroke
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            self.makeSpecialBinding(commandName,func,ivar,pane,shortcut,stroke)

    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20051010062551.1">@nocolor
@

ivars:

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are *lists* of g.bunch(func,name,warningGiven)

g.app.keysym_numberDict:
    Keys are keysym_num's.  Values are strokes.

g.app.keysym_numberInverseDict
    Keys are strokes, values are keysym_num's.

not an ivar (computed by computeInverseBindingDict):

inverseBindingDict
    keys are emacs command names, values are *lists* of shortcuts.</t>
<t tx="ekr.20051011103654">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20051012053017.4">[iqr] incremental,query,regex
[fb] forward,back
[w] word
[c] case-sensitive
[hat] headline,all,body
[osn] outline,subtree,node

Apply incremental search commands to headlines?</t>
<t tx="ekr.20051012062458.1">- 

- </t>
<t tx="ekr.20051012201831">def printBindings (self,event,brief=False):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    d = k.bindingsDict ; tabName = 'Bindings'
    keys = d.keys() ; keys.sort()
    c.frame.log.clearTab(tabName)

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key,[])
        for b in bunchList:
            if not brief or k.isPlainKey(key):
                pane = g.choose(b.pane=='all','',' [%s]' % (b.pane))
                s1 = k.prettyPrintKey(key) + pane
                s2 = b.commandName
                n = max(n,len(s1))
                data.append((s1,s2),)
    
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
                   
    state = k.unboundKeyAction 
    k.showStateAndMode()
                    
    g.es('\n----- input state: %s' % (state),tabName=tabName)</t>
<t tx="ekr.20051014061332">def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c ; tabName = 'Commands'
    
    c.frame.log.clearTab(tabName)
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    data = [] ; n = 20
    for commandName in commandNames:
        shortcutList = inverseBindingDict.get(commandName,[''])
        for shortcut in shortcutList:
            s1 = commandName
            s2 = k.prettyPrintKey(shortcut)
            n = max(n,len(s1))
            data.append((s1,s2),)
                
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+1),s1,s2),tabName=tabName)
</t>
<t tx="ekr.20051014152256">Improve import code so it handles stufff like this from Ipyton/iplib

### This should *not* terminate the function!

    self.LOGHEAD = Itpl(
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = $self.rc.opts
#log# args = $self.rc.args
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
""")

- Handle blanks better in imports:
    - Add tab_width keyword arg to import command.
    - Convert tabs to blanks if tab width &lt; 0.
- Ignore position of blank lines wrt sentinels.
- Ignore (optionally?) underindented blank lines.
- Use pyclbr to parse Python imports?</t>
<t tx="ekr.20051014155551">def hideMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.hideMinibuffer()
    
    g.es('Minibuffer hidden',color='red')

    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('%s is bound to: %s' % (commandName,shortcut))
    
    
def showMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.showMinibuffer()
    
def toggleMinibuffer (self,event):
    
    k = self ; c = k.c
    
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)</t>
<t tx="ekr.20051014170754">def help (self,event):
    
    k = self ; c = k.c
    commands = (
        k.fullCommand,
        k.quickCommand,
        k.universalArgument,
        k.keyboardQuit,
        # negative-argument
        # repeat-complex-command
    )
    shortcuts = [
        k.getShortcutForCommand(command)
        for command in commands]

    # A bug in Leo: triple quotes puts indentation before each line.
    s = '''
The mini-buffer is intended to be like the Emacs buffer:

%s: Just like Emacs Alt-x: starts minibuffer. The prompt is 'full-command' Type a
full command name, then hit &lt;Return&gt; to execute the command. Tab completion
works, but not for file names.

%s: Like Emacs Control-C: (Ctrl-C conflicts with XP cut). starts minibuffer.
The prompt is 'quick-command'. This mode is not completed, but stuff like
`Ctrl-C r` and `Ctrl r r` do work.

%s: Like Emacs Ctrl-u: (Ctrl-u conflicts with move-outline-up). Add a repeat
count for later command. Ctrl-u 999 a adds 999 a's, but many features remain
unfinished.

%s: Just like Emacs Ctrl-g: Closes the mini-buffer.
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.
    s = s % (shortcuts[0],shortcuts[1],shortcuts[2],shortcuts[3])
    g.es_print(s)</t>
<t tx="ekr.20051016155819"></t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)
        
    self.findTabHandler.bringToFront()</t>
<t tx="ekr.20051020120306.1">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020120306.2">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020120306.3">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020120306.4">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20051020120306.5"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind.leoFind):

    """A class that implements Leo's tkinter find tab."""

    @others</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None # To keep pychecker happy.
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020120306.12">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)

    for w in buttons:
        w.bindHotKey(ftxt)
        w.bindHotKey(ctxt)</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

# Use bigger boxes for scripts.
self.find_ctrl = ftxt = Tk.Text(
    fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
self.change_ctrl = ctxt = Tk.Text(
    cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") 
ftxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    c = self.c
    c.frame.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&amp;Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap &amp;Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ('Clone Find All',  self.dict['clone_find_all']),
    ("Mark Finds",      self.dict["mark_finds"]),
    ("Mark &amp;Changes",   self.dict["mark_changes"]),
    ('Show Context',    self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051020120306.19">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020120306.20">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020120306.21">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20051020120306.22">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.frame.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.frame.widgetWantsFocus(t)</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"</t>
<t tx="ekr.20051020120306.28">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051021091958">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20051022094136">def bindKeyHelper(self,pane,shortcut,callback,commandName):

    k = self ; c = k.c
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    menu = c.frame.menu
    minibuffer = c.miniBufferWidget
    tree = c.frame.tree.canvas
    
    d = {
        'all':  [body,log,tree], # Probably not wise: menu
        'body': [body],
        'log':  [log],
        'menu': [menu],         # Not used, and probably dubious.
        'mini': [minibuffer],   # Needed so ctrl-g will work in the minibuffer!
        'text': [body,log],
        'tree': [tree],
    }
    
    # if pane: g.trace('%4s %20s %s' % (pane, shortcut,commandName))
    
    widgets = d.get((pane or '').lower(),[])
    
    # Binding to 'menu' causes problems with multiple pastes in the Find Tab.
    # There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
    if shortcut == '&lt;Key&gt;':
        # Important.  We must make this binding if the minibuffer can ever get focus.
        if self.useTextWidget:
            widgets.append(minibuffer)
        for w in widgets:
            w.bind(shortcut,callback,'+')
    else:
        # Put *everything* in a bindtag set specific to this commander.
        tag = k.plainKeyTag()
        body.bind_class(tag,shortcut,callback)
        
        # Put everything *except* plain keys in a normal binding.
        if not k.isPlainKey(shortcut):
            for w in widgets:
                w.bind(shortcut,callback)
            # Get rid of the default binding in the menu. (E.g., Alt-f)
            menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20051022211617"></t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-all', self.changeAllCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)</t>
<t tx="ekr.20051023182326">def copyBindingsToWidget (self,paneOrPanes,w):
    
    '''Copy all bindings for the given panes to widget w.
    
    paneOrPanes may be  pane name (a string) or a list of pane names in priority order.'''
    
    # g.trace(paneOrPanes,g.app.gui.widget_name(w),g.callers())

    k = self ; d = k.bindingsDict
    bindings = {}
    keys = d.keys() ; keys.sort()
    if type(paneOrPanes) == type('abc'):
        panes = [paneOrPanes] # list(paneOrPanes) does not work.
    else:
        panes = paneOrPanes
    # g.trace(panes)

    for shortcut in keys:
        # Do not copy plain key bindings.
        if not k.isPlainKey(shortcut):
            shortcutsBunchList = []
            for pane in panes:
                old_panes = bindings.get(shortcut,[])
                assert(type(old_panes)==type([]))
                if old_panes and pane in old_panes:
                    # This should have been caught earlier, but another check doesn't hurt.
                    g.trace('*** redefining %s in %s' % (shortcut,pane))
                else:
                    bunchList = d.get(shortcut,[])
                    for bunch in bunchList:
                        if bunch.pane == pane:
                            shortcutsBunchList.append(bunch)
                            old_panes.append(pane)
                            bindings [shortcut] = old_panes
            # Create bindings for the shortcut in all panes.
            if shortcutsBunchList:
                self.copyBindingsHelper(shortcutsBunchList,shortcut,w)        
                                
    # Bind all other keys to k.masterCommand.
    def generalTextKeyCallback (event,k=self):
        k.masterCommand(event,func=None,stroke='&lt;Key&gt;',commandName=None)

    w.bind('&lt;Key&gt;',generalTextKeyCallback)</t>
<t tx="ekr.20051023183028">def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'</t>
<t tx="ekr.20051023192433"></t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.change()
    
def changeAllCommand (self,event=None):
    c = self.c
    self.setup_command(c)
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.changeThenFind()</t>
<t tx="ekr.20051025071455">@others
</t>
<t tx="ekr.20051025071455.1">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others</t>
<t tx="ekr.20051025071455.6">class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others

</t>
<t tx="ekr.20051025071455.7"></t>
<t tx="ekr.20051025071455.8">def __init__ (self,c,local_dictionary_file,local_language_code):

    """Ctor for the Aspell class."""

    self.c = c

    self.aspell_dir = c.config.getString('aspell_dir')
    self.aspell_bin_dir = c.config.getString('aspell_bin_dir')

    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        theDir = g.choose(sys.platform=='darwin',self.aspell_dir,self.aspell_bin_dir)
        aspell = g.importFromPath('aspell',theDir,pluginName=__name__,verbose=True)
        
    self.aspell = aspell
    if aspell:
        self.sc = aspell.spell_checker(prefix=self.aspell_dir,lang=local_language_code)
        self.local_language_code = local_language_code
        self.local_dictionary_file = local_dictionary_file
        self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file) [0]</t>
<t tx="ekr.20051025071455.10">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; «original» «count» «offset»: «miss», «miss», ... 
    None: 
    # «original» «offset» 
    simplifyed to not create the string then make a list from it    
    """

    if self.sc.check(word):
        return None
    else:
        return self.sc.suggest(word)</t>
<t tx="ekr.20051025071455.11">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_bin_dir, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False</t>
<t tx="ekr.20051025071455.16">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d</t>
<t tx="ekr.20051025071455.18">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others</t>
<t tx="ekr.20051025071455.19"></t>
<t tx="ekr.20051025071455.20">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.outerScrolledFrame = None
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()</t>
<t tx="ekr.20051025071455.22">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20051025071455.23">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')</t>
<t tx="ekr.20051025071455.24"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="ekr.20051025071455.29"></t>
<t tx="ekr.20051025071455.30">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()</t>
<t tx="ekr.20051025071455.31">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()</t>
<t tx="ekr.20051025071455.32">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
</t>
<t tx="ekr.20051025071455.33">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    self.find()
    self.updateButtons()
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025071455.34">def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()</t>
<t tx="ekr.20051025071455.36"></t>
<t tx="ekr.20051025071455.37">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.38">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            c.frame.body.onBodyChanged("Change",oldSel=oldSel)
            c.frame.widgetWantsFocus(t)
            return True

    # The focus must never leave the body pane.
    c.frame.widgetWantsFocus(t)
    return False</t>
<t tx="ekr.20051025071455.40">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.frame.bodyWantsFocus()
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])</t>
<t tx="ekr.20051025071455.41">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.42"></t>
<t tx="ekr.20051025071455.43">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')</t>
<t tx="ekr.20051025071455.44">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1) 

</t>
<t tx="ekr.20051025071455.45">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word</t>
<t tx="ekr.20051025071455.46">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue</t>
<t tx="ekr.20051025071455.47"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as é.  I don't know what the solution is.
    word_start = string.letters
    word_end   = string.letters + string.digits
    word_chars = string.letters + string.digits + "`" + "'" + "_"
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and line[i] not in word_start:
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.</t>
<t tx="ekr.20051025071455.48">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None</t>
<t tx="ekr.20051025071455.49">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)</t>
<t tx="ekr.20051025071455.50">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    c = self.c
    self.updateButtons()
    c.frame.bodyWantsFocus()
</t>
<t tx="ekr.20051025071455.51">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025071455.52">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')</t>
<t tx="ekr.20051025080056">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.</t>
<t tx="ekr.20051025080420">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }</t>
<t tx="ekr.20051025080420.1"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()
        
def changeAll(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeAll()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.frame.bodyWantsFocus()

def ignore (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()</t>
<t tx="ekr.20051025080633">def openSpellTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()</t>
<t tx="ekr.20051025094004">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = Aspell(c,dictionaryFileName,self.local_language_code)
    
    if not self.aspell.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True
</t>
<t tx="ekr.20051025120920">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget(['text','all'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
           </t>
<t tx="ekr.20051025121408">def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []</t>
<t tx="ekr.20051025144611"></t>
<t tx="ekr.20051025144611.1">@nocolor</t>
<t tx="ekr.20051025144611.2">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="ekr.20051025144611.3">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="ekr.20051025144611.4">&lt;&lt; docstring &gt;&gt;
&lt;&lt;imports&gt;&gt;
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;

#These two global determine if the autocompleter and calltip systems are used.  Default is on.
useauto = 1
usecall = 1

&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others</t>
<t tx="ekr.20051025144611.5">'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''</t>
<t tx="ekr.20051025144611.6">## import leoTkinterFrame 

import sets 
import threading
import weakref</t>
<t tx="ekr.20051025144611.7">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.</t>
<t tx="ekr.20051025144611.8">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="ekr.20051025144611.10">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information

context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode</t>
<t tx="ekr.20051025144611.11">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.</t>
<t tx="ekr.20051025144611.12">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20051025144611.13">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
</t>
<t tx="ekr.20051025144611.14"># This section defines patterns for calltips.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats ['python'] = re.compile(r'def\s+%s' % end)

pats ['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
        space, space, end))

pats ['perl'] = re.compile(r'sub\s+%s' % end)

pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (space,end))

pats ['c'] = re.compile(r'\w+%s%s' % (space,end))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits + string.letters + r

ripout = string.punctuation + string.whitespace + '\n'
ripout = ripout.replace('_','')

okchars = {}
for z in string.ascii_letters:
    okchars [z] = z
okchars ['_'] = '_'</t>
<t tx="ekr.20051025144611.15">def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20051025144611.16">watchitems = ('.',')')
txt_template = '%s%s%s'

def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.
    Certain chars activate the text scanning code.'''
    global lang
    if not (event.char.isspace() or event.char in watchitems):
        return
        
@
This if statement ensures that attributes set in another node are put in the
database.Of course the user has to type a whitespace to make sure it happens.
We try to be selective so that we dont burn through the scanText def for  every
whitespace char entered.This will help when the nodes become big.
@c
    bCtrl = event.widget
    if event.char.isspace():
        # Do nothing if the previous char was a whitespace
        if bCtrl.get('insert -1c').isspace(): return
        if bCtrl.get('insert -1c wordstart -1c') != '.': return
    c = bCtrl.commander
    lang = c.frame.body.getColorizer().language
    txt = txt_template % (
        bCtrl.get("1.0",'insert'),
        event.char, bCtrl.get('insert',"end"))
        # Add the newest char; its not in the bCtrl yet
    scanText(txt)</t>
<t tx="ekr.20051025144611.17">def scanText (txt):

    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)</t>
<t tx="ekr.20051025144611.18">def scanForAutoCompleter (txt):
    
    '''This function scans text for the autocompleter database.'''

    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b )
            # we are using the experimental DictSet class here.
            # usage removed the above statements
            # notice we have cut it down to one line of code here!</t>
<t tx="ekr.20051025144611.19">def scanForCallTip (txt):

    '''this function scans text for calltip info'''

    # pat2 = pats['python']
    # if lang:
        # if pats.has_key(lang):
            # pat2 = pats[lang]

    pat2 = pats.get(lang or 'python')
    g2 = pat2.findall(txt) or []

    for z in g2:
        if isinstance(z,tuple):
            z = z [0]
        pieces2 = z.split('(')
        pieces2 [0] = pieces2 [0].split() [ -1]
        a, b = pieces2 [0], pieces2 [1]
        calltips [lang][a].add(z)</t>
<t tx="ekr.20051025144611.20">def makeAutocompletionList (a,b,glist):
    
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 

</t>
<t tx="ekr.20051025144611.21">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20051025144611.22">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20051025144611.23">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
</t>
<t tx="ekr.20051025144611.24">#These functions determine if the config and language files have been read or not.
# No need to read it more than once.

def hasReadConfig():
    return configfilesread

def setReadConfig():
    global configfilesread
    configfilesread = True</t>
<t tx="ekr.20051025144611.25">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20051025144611.26">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="ekr.20051025144611.27">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20051025144611.28">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20051025144611.29">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20051025144611.30">def unbind (context):

    '''This method turns everything off and removes the calltip and autobox from the canvas.'''

    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map(context.unbind,(
            "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;", "&lt;Alt_R&gt;"))
        context.unbind_all('&lt;Button&gt;')
        context.update_idletasks()</t>
<t tx="ekr.20051025144611.31">def moveSelItem (event, context ):

    '''Move the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1  ## Can't be correct.
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:
        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="ekr.20051025144611.32">def processKeyStroke (event,context,body):

    '''Take action based on the state of context (a Tk.Canvas) and the event'''
    
    autobox = context.autobox

    if not context.on or event.keysym in ("??","Shift_L","Shift_R"):
        return None
    elif testForUnbind(event,context):
        unbind(context)
        return None
    elif context.which == 1:
        return None # It is calltip time.
        
    index = body.index('insert-1c wordstart')
    pat = body.get(index,'insert') + event.char
    pat = pat.lstrip('.')
    ww = list(autobox.get(0,'end'))
    aList = reducer(ww,pat)
    if not aList: return None
    # Select which item to select based on what the user has typed.
    i = ww.index(aList[0])
    # Set the current selection to match what the user has typed.
    autobox.select_clear(0,'end') 
    autobox.select_set(i)
    autobox.see(i)
    return 'break'</t>
<t tx="ekr.20051025144611.33">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="ekr.20051025144611.34">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20051025144611.35">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="ekr.20051025144611.36">def add_bindings( context, body ):
    
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''
    
    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )
</t>
<t tx="ekr.20051025144611.37">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20051025144611.38">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20051025144611.39">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20051025144611.40">def newCreateControl (self,frame,parentFrame):
    '''A decoration of the createControl def.
    We set up the ancestory of the control so we can draw
    widgets over the Text editor without disturbing the text.'''

@
Creating the background:
- We now use a placer: simpler to use and more efficient.
- We have to decorate the Tk.Text widget with a constructor that creates an
  intermediate Frame for the Text to be placed instead of packed.
  Had no idea that the placer could do this so nicely.
  With a couple changes in 3 places, we are using the placer !
@c
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init (self,master,*args,**kwords):

        context = Tk.Frame(master)
            #This is what we need to put in before the text to make place work.
        orig_init(self,context,*args,**kwords)

    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame,parentFrame) #orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init

    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack(expand=1,fill='both',after=frame.bodyBar) #We have to add it to the environment, since we pass on it in the __init__
    body.place(relwidth=1.0,relheight=1.0)
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets(context)
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler (event,context=context,body=body):
        processKeyStroke(event,context,body)
    def addItemHandler (event,context=context,body=body,colorizer=frame.body):
        add_item(event,context,body,colorizer.getColorizer())

    for z in (watcher,processKeyStrokeHandler,addItemHandler):
        context.bind("&lt;Key&gt;",z,'+')

    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr(context,'autobox'):
        ignore.append(context.autobox.component('listbox'))
        ignore.append(context.autobox.component('vertscrollbar'))
    def do_unbind (event):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind(context)

    context.do_unbind = do_unbind

    # This part protects this plugin from others that use Alt-Up, Alt-Down.
    # The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt (event):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ('&lt;Alt-Up&gt;','&lt;Alt-Down&gt;'): context.block_alt.bind(z,block_alt)

    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append(context.bindtags()[0])
    ctags.append(context.block_alt.bindtags()[0])
    ctags.extend(body.bindtags())
    body.bindtags(tuple(ctags))

    return body

</t>
<t tx="ekr.20051025144611.41">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []

    if useauto:
        context.autobox = Pmw.ScrolledListBox(
            context ,hscrollmode='none',
            listbox_selectbackground='#FFE7C6',
            listbox_selectforeground='blue',
            listbox_background='white',
            listbox_foreground='blue',
            vertscrollbar_background='#FFE7C6',
            vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):
        #This def makes removing the autobox or calltip label easy.
        # No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()

    context.clean_editor = clean_editor</t>
<t tx="ekr.20051025144611.42">def onOpenWindow ():

    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="ekr.20051025170832"></t>
<t tx="ekr.20051025170832.1"></t>
<t tx="ekr.20051026083544">def handleDefaultChar(self,event):
    
    c = self.c
    w = event and event.widget
    name = g.app.gui.widget_name(w)

    if name.startswith('body'):
        # For Leo 4.4a4: allow Tk defaults.
        # But this is dangerous, and should be removed.
        action = self.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass
            # g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None
</t>
<t tx="ekr.20051026083544.2">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20051026092433">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20051026171121">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20051026171121.1"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051103091115.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3411067
By: rogererens

Also, in the settings of Find/Change, I would choose for grouping the settings
node_only, search_body, search_headline, wrap (and possibly the whole_word option
also) together under search extent radio buttons. Although this organizational
mode mentions radio buttons, check boxes are used for selection_only and
suboutline_only, which I can enable both at the same time.
It's also not (yet?) very clear to me how selection_only, suboutline_only, node_only
(should) interact...</t>
<t tx="ekr.20051104051733">FocusIn does nothing for Label widgets.

http://sourceforge.net/forum/message.php?msg_id=3412640
By: btheado

Currently clicking on the minibuffer and typing text has no effect.  Kinda confusing
until the Alt-x binding I discovered that Alt-x is the way to access the minibuffer
command mode.

It would be nice if the &lt;FocusIn&gt; binding on the minibuffer widget were equivilent
to Alt-x.</t>
<t tx="ekr.20051104152338"></t>
<t tx="ekr.20051104152338.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3413805
By: nobody

I thought this might be for 4.4a2, but I see the same effect w/ 
Leo 4.3.3, build  1.282 , September 17, 2005
Python 2.3.5, Tk 8.4.7, win32

I haven't used Leo for code, but just started to try to re-organize some Perl
I inherited.

Leo apears to remove sentinels, AND preceding newlines, so the effect is something
like this:

.... some code....

   next line;
}
#@ leo sentinel here...
#

    If  ( something ) {
      more code;
......

becomes:

.... some code....

   next line;
} If  ( something ) {
      more code;
......

Now, that may be annoying, but mildly so - it still runs.
When this:

#
#@ sentinel
if () {

turns to this:

# if() {

code just breaks.</t>
<t tx="ekr.20051110155735.1">@nocolor

- Per-pane key bindings. (arrows, etc.)
- Try default fonts for spell buttons.
- Select the first entry.

@color</t>
<t tx="ekr.20051112075511">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3424153
By: rogererens

When reversing the search direction, it would be better to place the cursor
'on the other side' of the current hit, and then proceed to find the next occurrence
of &lt;pattern&gt;. At the current state of affairs, searching in the reverse direction
first finds the current occurrence _again_, just placing the cursor on the other
side of the higlighted selection.

This suggestion is based on the way searching in Vim works.</t>
<t tx="ekr.20051112080017">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3423121
By: nobody

Hi! I need help removing script buttons. It says I should right click the ofending
button. I have a mac and Ctl-click, Command-click, etc doesn't work. What should
I do?

EKR: This is on the list of unfixable bugs, but I have a hard time believing there is no workaround.</t>
<t tx="ekr.20051113090322">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)</t>
<t tx="ekr.20051121070552"></t>
<t tx="ekr.20051125080855">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = g.app.gui.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20051126122638">- Use typing completion to select desired word.
- No auto-scan: use database instead.
- Scan button does manual scan.
- Use import or inspect instead of text scan.
- @strings autocompleter-info
list of names for which classes are known: c,frame,g,k,p,t,tree,v etc.
  (Autocompleter may already do this)
</t>
<t tx="ekr.20051126122952.1">def autoComplete (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    self.widget = w = event and event.widget 
    self.prefix = gui.getSelectedText(w) or ''
    self.text = gui.getAllText(w)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.
    self.membersList = c.commandsDict.keys() ## Testing only.
    k.setState('auto-completer',1,handler=self.stateHandler)
    self.computeCompletionList()</t>
<t tx="ekr.20051126123149">def computeCompletionList (self):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.frame.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    if s:
        self.tabList,common_prefix = g.itemsMatchingPrefixInList(s,self.membersList)
        c.frame.log.clearTab('Completion') # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            g.es('%s' % (name),tabName='Completion')</t>
<t tx="ekr.20051126123249">class autoCompleterCommandsClass (baseEditCommandsClass):
    
    '''Similar to typing completion in the minibuffer,
    but the presently selected completion is shown in the widget itself.'''

    @others</t>
<t tx="ekr.20051126123249.1">def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051126123759"></t>
<t tx="ekr.20051126123759.1">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.c = c
    self.k = c.keyHandler
    self.membersList = None
    self.prefix = None
    self.tabList = []
    self.tabListIndex = -1
    self.text = None # For Escape.
    self.widget = None</t>
<t tx="ekr.20051126123759.2">def getPublicCommands (self):

    k = self.k

    return {
        'auto-complete':    self.autoComplete,
    }</t>
<t tx="ekr.20051126124705">def stateHandler (self,event):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.widget
    keysym = event and event.keysym
    ch = event and event.char or ''
    # g.trace(repr(ch),repr(keysym))
    if keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.finish()
    elif keysym == 'Escape':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif ch in string.printable:
        self.extendSelection(ch)
        s = gui.getSelectedText(w)
        if s.startswith(self.prefix):
            self.prefix = self.prefix + ch
            # g.trace('prefix',self.prefix)
        self.computeCompletionList()</t>
<t tx="ekr.20051126125950">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""</t>
<t tx="ekr.20051126131103">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    self.prefix = self.prefix[:-1]
    self.setSelection(self.prefix)
    self.computeCompletionList()</t>
<t tx="ekr.20051126171929">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20051127065601">def extendSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
    else:
        i = j = gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127070018">def setSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = gui.getInsertPoint(w)
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127105102">def finish (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.frame.widgetWantsFocus(w)
    
    i,j = gui.getTextSelection(w)
    if i != j:
        gui.setTextSelection(w,j,j)</t>
<t tx="ekr.20051127105431">def abort (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    
    c.frame.widgetWantsFocus(w)

    w.delete('1.0','end')
    w.insert('1.0',self.text)
    gui.setTextSelection(w,'1.0','1.0')</t>
<t tx="ekr.20051202094427">Investigate meld:  http://meld.sourceforge.net/</t>
<t tx="ekr.20051202095626">Use docstrings as the help message.</t>
<t tx="ekr.20051202102337">@nocolor</t>
<t tx="ekr.20051202102337.1">auto-complete command is merely a prototype.</t>
<t tx="ekr.20051202102337.2">ok:

list-buffers

Not ready yet:

append-to-buffer
copy-to-buffer
insert-to-buffer
kill-buffer
prepend-to-buffer
rename-buffer       probably should change headline too
switch-to-buffer    use typing completion to get node name (headline)</t>
<t tx="ekr.20051202102337.3">advertised-undo
keyboard-quit
iconify-frame
save-buffers-kill-leo
shell-command
shell-command-on-region
suspend</t>
<t tx="ekr.20051202102337.4">back-sentence
back-to-indentation
backward-char
backward-delete-char
backward-kill-paragraph
backward-paragraph
backward-word
beginning-of-buffer
beginning-of-line
capitalize-word
center-line
center-region
count-region
cycle-focus
dabbrev-completion
dabbrev-expands
delete-char
delete-indentation
delete-spaces
downcase-region
downcase-word
end-of-buffer
end-of-line
escape
eval-expression
exchange-point-mark
fill-paragraph
fill-region
fill-region-as-paragraph
flush-lines
focus-to-body
focus-to-log
focus-to-minibuffer
focus-to-tree
forward-char
forward-paragraph
forward-sentence
forward-word
goto-char
goto-line
how-many
# Use indentBody in leoCommands.py
#indent-region
indent-relative
indent-rigidly
indent-to-comment-column
insert-newline
insert-parentheses
keep-lines
kill-paragraph
line-number
move-past-close
newline-and-indent
next-line
previous-line
remove-blank-lines
replace-regex
replace-string
reverse-region
scroll-down
scroll-up
select-paragraph
# Exists, but can not be executed via the minibuffer.
# self-insert-command
set-comment-column
set-fill-column
set-fill-prefix
set-mark-command
show-colors
show-fonts
# save-buffer
sort-columns
sort-fields
sort-lines
split-line
tabify
transpose-chars
transpose-lines
transpose-words
untabify
upcase-region
upcase-word
view-lossage
what-line</t>
<t tx="ekr.20051202102337.6">delete-file
diff
insert-file
make-directory
remove-directory
save-file</t>
<t tx="ekr.20051202102752.1">digit-argument
help
hide-mini-buffer
negative-argument
number-command
number-command-0
number-command-1
number-command-2
number-command-3
number-command-4
number-command-5
number-command-6
number-command-7
number-command-8
number-command-9
print-bindings
print-commands
repeat-complex-command
show-mini-buffer
toggle-mini-buffer
universal-argument</t>
<t tx="ekr.20051202102752.2">backward-kill-sentence
backward-kill-word
kill-line
kill-word
kill-sentence
kill-region
kill-region-save
yank
yank-pop
zap-to-character</t>
<t tx="ekr.20051202102752.3">call-last-keyboard-macro
end-kbd-macro
name-last-kbd-macro
load-file
insert-keyboard-macro 
start-kbd-macro</t>
<t tx="ekr.20051202102752.4">query-replace
query-replace-regex</t>
<t tx="ekr.20051202102752.5">clear-rectangle
close-rectangle
delete-rectangle
kill-rectangle
open-rectangle
string-rectangle
yank-rectangle</t>
<t tx="ekr.20051202102752.6">append-to-register
copy-rectangle-to-register
copy-to-register
increment-register
insert-register
jump-to-register
number-to-register not used: used copy-to-register insead.
point-to-register
prepend-to-register
view-register

To do:

point-to-register should write an 'expanded point' so inter-node jumps are possible.</t>
<t tx="ekr.20051202102752.7">hide-find-tab
open-find-tab
find-tab-find
find-tab-find-prev
find-tab-change
find-tab-change-then-find

isearch-forward
isearch-backward
isearch-forward-regexp
isearch-backward-regexp

re-search-forward
re-search-backward

search-forward
search-backward
word-search-forward
word-search-backward</t>
<t tx="ekr.20051202102752.8">ok:

hide-spell-tab
open-spell-tab
spell-find
spell-change
spell-change-then-find
spell-ignore</t>
<t tx="ekr.20051205093049">@nocolor

Working throught the IronPython tutorial just now I saw how useful the dir function could be, especially dir(object)

I'm thinking that Leo might use dir(object) to discover members for the auto-complete command.  It's not clear if or how this can be made to work, but it might be slick.</t>
<t tx="ekr.20051207130144">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3460955
By: nobody

I found this link:
http://www.8ung.at/klappnase/TkinterDnD/TkinterDnD.html
TkinterDnD

so if Edward is interested in adding drag and drop support for regular leo,
this might be a path to do so.  It looks like an active project.

leouser
</t>
<t tx="ekr.20051207130144.1"></t>
<t tx="ekr.20051217175058">Study jyLeo's chapters code

show-chapters
hide-chapters
add-chapter
delete-this-chapter</t>
<t tx="ekr.20051220062654">An alternative to test.leo!</t>
<t tx="ekr.20051220083410">def makeSpecialBinding (self,commandName,func,ivar,pane,shortcut,stroke):
    
    k = self
    
    # g.trace(commandName,shortcut,stroke)
    
    if pane == 'mini' and func != k.keyboardQuit:
        if 0:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)
    
            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
    else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)
    
            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)
    
            k.bindKey(pane,shortcut,keyCallback,commandName)
    
    if ivar:
        setattr(k,ivar,shortcut)</t>
<t tx="ekr.20051220144507">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20051221101851"></t>
<t tx="ekr.20051221101851.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3487424
By: p_michalczyk

Does anybody know how to double-click headline in outline panel using only keyboard
(that is how to simulate double-click through keyboard shortcut) ?
I need it to execute @run nodes from keyboard.

EKR: This can be done with @command nodes, but Leo should have official commands to do this too.</t>
<t tx="ekr.20060102092148.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3501193
By: nobody

::improving how Leo handle's arguments? 

Leo only needs a few simple options.
I don't think option handling would
work correctly in the IPYthon case either.

put optparse.py in leo/extensions for py2.2
docutils installs it if it isn't available.
its been the standard since py2.3
adding new options will be much less painfull.
some kind of --safe startup to allow editing
of leoSettings.leo, no @buttons or @scripts
might be a good thing.

Leo should allow scripts to set sys.argv for
commands they create. its very difficult to do now.

e</t>
<t tx="ekr.20060102103625">def createModeCommand (self,name,modeDict):

    # c = self.c ; k = c.keyHandler
    commandName = 'enter-' + name
    commandName = commandName.replace(' ','-')
        
    # Save the info for k.finishCreate and k.makeAllBindings.
    d = g.app.config.modeCommandsDict
    
    # g.trace(modeDict.keys())

    if d.get(name):
        g.trace('Ignoring duplicate mode: %s' % commandName)
    else:
        d [commandName] = modeDict</t>
<t tx="ekr.20060102103625.1">def doMode(self,p,kind,name,val):
    
    '''Parse an @mode node and create the enter-&lt;name&gt;-mode command.'''
    
    c = self.c ; k = c.keyHandler

    # Compute the mode name.
    name = name.strip().lower()
    if name.endswith('mode'):
        name = name[:-4].strip()
    if name.endswith('-'):
        name = name[:-1]
    name = name + '-mode'
    # g.trace(name)
    
    # Check for duplicate mode names.
    if g.app.config.modeCommandsDict.get(name):
        g.trace('Ignoring duplicate @mode setting: %s' % name)
        return
    
    # Call doShortcuts with a temp dict.
    d = self.shortcutsDict
    self.shortcutsDict = {}
    self.doShortcuts(p,kind,name,val)
    
    # Remember the mode dict.
    d2 = self.shortcutsDict
    
    # Restore the global dict.
    self.shortcutsDict = d
    
    # Change the pane of all entries to 'mode-name'.
    # This will disable warnings about duplicate bindings.
    for key in d2.keys():
        bunchList = d2.get(key,[])
        for bunch in bunchList:
            bunch.pane = name
    
    # Create the command, but not any bindings to it.
    self.createModeCommand(name,d2)</t>
<t tx="ekr.20060102135349.2">def enterNamedMode (self,event,commandName):
    
    k = self ; c = k.c
    modeName = commandName[6:]
    
    k.generalModeHandler(event,modeName=modeName)
</t>
<t tx="ekr.20060103101524">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3501995
By: nobody

::But I don't understand why it's difficult to edit leoSettings.leo

--safe would use default settings,
maybe you set all body fg/bg to the same color
by mistake and you don't have a backup leoSettings to use. as a dumb example.

another nice option would be to override a setting
--set something=whatever
this could breakdown easy and on (older?) windows.
there is a limit to how many chars on a command line.
this would add another layer of choice
yet another chicken egg problem, 
parsing settings before settings can be parsed.

what about override @settings file, its a standard thing.
many people will expect this is possible 
and try it
or even leo.py -? 
help you get for free w/optparse.
--keys emacs anyone? 
especially the first time
untill you can get a chance to edit leoSettings.leo

I have already started enabling optparse
for leo.py so I can try various profile options.
I will post it when it works.

have to check how it handles filenames with spaces
seems that is all Leo is currently doing 
with multiple args, if there is no problem.
and later checking for -batch -script etc.

not to minimize how much work this would be.
parsing options is probably the least difficult part.

e</t>
<t tx="ekr.20060104083551">http://sourceforge.net/forum/message.php?msg_id=3488030

move-region-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-region-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.</t>
<t tx="ekr.20060104110233">def generalModeHandler (self,event,
    bunch=None,commandName=None,func=None,modeName=None):
    
    '''Handle a mode defined by an @mode node in leoSettings.leo.'''

    k = self ; c = k.c
    state = k.getState(modeName)
    
    # g.trace(modeName,state)
   
    if state == 0:
        
        self.initMode(event,modeName)
        k.setState(modeName,1,handler=k.generalModeHandler)
        if c.config.getBool('showHelpWhenEnteringModes'):
            k.modeHelp(event)
        else:
            c.frame.log.deleteTab('Mode')
    elif not func:
        # g.trace('No func: improper key binding')
        # We were called from k.masterCommand because of an @settings key.
        return 'do-func' # Tell the 
    else:
        # g.trace(modeName,state,commandName)
        if commandName == 'mode-help':
            func(event)
        else:
            nextMode = bunch.nextMode
            self.endMode(event)
            func(event)
            if nextMode == 'none':
                # Do *not* clear k.inputModeName or the focus here.
                # func may have put us in *another* mode.
                pass
            elif nextMode == 'same':
                self.initMode(event,modeName) # Re-enter this mode.
                k.setState(modeName,1,handler=k.generalModeHandler)
            else:
                self.initMode(event,nextMode) # Enter another mode.

    return 'break'

</t>
<t tx="ekr.20060104125946">def modeHelpHelper (self,d):
    
    k = self ; c = k.c ; tabName = 'Mode'
    c.frame.log.clearTab(tabName)
    keys = d.keys() ; keys.sort()

    data = [] ; n = 20
    for key in keys:
        bunchList = d.get(key)
        for bunch in bunchList:
            shortcut = bunch.val
            if shortcut not in (None,'None'):
                s1 = key
                s2 = k.prettyPrintKey(shortcut)
                n = max(n,len(s1))
                data.append((s1,s2),)
        
    # This isn't perfect in variable-width fonts.
    for s1,s2 in data:
        g.es('%*s\t%s' % (-(n+3),s1,s2),tabName=tabName)
        
    g.es('\n----- %s' % (k.inputModeName),tabName=tabName)</t>
<t tx="ekr.20060104154937">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key</t>
<t tx="ekr.20060104164523">def modeHelp (self,event):

    '''The mode-help command.
    
    A possible convention would be to bind &lt;Tab&gt; to this command in most modes,
    by analogy with tab completion.'''
    
    k = self ; c = k.c
    
    c.endEditing(restoreFocus=True)
    
    if k.inputModeName:
        d = g.app.config.modeCommandsDict.get('enter-'+k.inputModeName)
        k.modeHelpHelper(d)
    else:
        k.printBindings(event,brief=True)

    return 'break'</t>
<t tx="ekr.20060105132013">def setIgnoreState (self,event):

    self.setInputState('ignore')

def setInsertState (self,event):

    self.setInputState('insert')

def setOverwriteState (self,event):

    self.setInputState('overwrite')

</t>
<t tx="ekr.20060105143454.2"></t>
<t tx="ekr.20060107082929">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3510448
By: ktenney

Howdy,

I'm executing a script in a Leo node which has
an indentation error. I get the following report,
which doesn't help locate the error.

Pardon me if this is well known issue, I don't
remember discussion of it.

Thanks,
Kent

################################################
exception executing script
Traceback (most recent call last):
  File "C:\python24\lib\site-packages\leo\src\leoCommands.py", line 1277, in
executeScript
    exec script in d
IndentationError: unindent does not match any outer indentation level (line
103)
--------------------
  line 1276:                     # g.trace(script)
* line 1277:                     exec script in d
  line 1278:                     if not script1 and not silent:
  line 1279:                         g.es("end of script",color="purple")

</t>
<t tx="ekr.20060108120501">This is the easy way to do script finds!</t>
<t tx="ekr.20060109183500.1">execute-named-script executes script in leo/scripts.</t>
<t tx="ekr.20060110102039">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3505544
By: nobody

this topic deserves another thread, rather 
than hijack the IPython one in the main forum.

presently Leo has a few options documented,
--script has a required parameter filename
batch mode also requires a filename.
why are they not documented in the same place?
why is batch mode option called --script?
is it too late to change to --batch ?

filenames in windows that have spaces will 
have to be quoted if they follow an option.
otherwise there will be no telling the filename
after a --script from a possibly 'file name.leo'

luckily, there was no need to force everyone 
on windows to quote leo names or use -fsome.leo,
especially when other options aren't used.
a little tricky, but I think it works.

the --script could as well load the leo itself
for that matter maybe all the args after --script 
should be assumed to be part of the scripts options
and Leo should only process up to the --script fname.
maybe there can be another option to collect
options for the script to batch process.
not necessary to decide now.

optparse can verify option parameters 
with callbacks. like does a filename exist,
is there enough free diskspace etc etc.
and provide a standard usage menu on exit.
rather than a roll your own wherever it happens.
I am not familiar enough with Leo startup to say
how is the best way to verify filenames or to
pass the filenames to run or set ivars.
import leoGlobals as I have might not be possible
this early in startup. need to get version info too.

leo -script whatever.py  error or not? typo? fixable?
leo --script whatever.py is ['script', 'whatever.py'] 
coming up with a comprehensive set of input args and
expected outcomes will be necessary for testing.
I'll do that next.

what about encoding problems, should check optparse archive.
what about py2.2 using optparse from 2.4? trust but verify.
this also has to be well tested.

--help -? or -h all work.
wasn't able to mimic the /help  /?
windows world method of option entry.
probably someone knows how.
hope its not a registry setting!

profile options might only be available if you
enter -xpert mode, to avoid confusing anyone who 
thinks they may need to run it because it is there.
and be removed from the help menu as well.

here is the proof of concept leomain.py,
all it does is process commandline args and 
print what command it will run or var it will set.
nothing is actually opened or run.

$ \c\py\python22\python leomain.py some.leo
run(some.leo)

$ \c\py\python22\python leomain.py some.leo -P
profile(leoProfile.txt,some.leo)

$ python leomain.py -profile=/tmp/proFile.txt my favorite.leo
profile(rofile=/tmp/proFile.txt,my favorite.leo)

woops! not sure how to guard against that.
verifing is valid creatable filename could help.
that should have been:

$ python leomain.py --profile=/tmp/proFile.txt my favorite.leo
profile(/tmp/proFile.txt,my favorite.leo)

$ python leomain.py --script some.py some.leo
script some.py
run(some.leo)

$ python leomain.py --script some.py
script some.py
run()

that's the basics.
needless to add, some of the code default 
choices and wording of help messages 
will have to be fine tuned. 
have at it.

post a note if something breaks.
I know of a few typos already.

[http://rclick.netfirms.com/leomain.py.htm]

e
</t>
<t tx="ekr.20060110102239.1">@color
"""  to run, add your path to leo below if not already set.

proposed modification to leo.py for hprof or hotshot profile 
giving standard help options from the commandline
and making additional options or combinations less work.

using optparse for commandline parsing
for py2.2 will use optik if installed, but not critical
requires copy of optparse.py from py2.4 in leo/extensions
no problem for py2.3+ already in the stdlib
this also need seperate testing, unittests to follow.

to use from command or shell window:
python leomain.py some args, see what happens.
nothing except print will happen, no open or file creation.
presently use a copy of sys.argv but that would be mutated.
if something is not obvious it should be fixed.


comments presently are interspersed throughout the file
will be collected and shortened as bugs are removed.
getting all options and filenames correctly is complicated
by the possibility of unicode or spaces in filenames.
some options require filenames for later processing in run()
and a leo may be specified or even more than one at some point
wildcard handling is not especially cross platform compatible.

want to make it possible to enter filenames w/o quoting
but will be impossible for now for batch &amp; script option params.
they have to have quotes if there are spaces in the filenames on win.

also somewhat ambiguous, -sscript filename
will actually parse as --script cript filename
this could be a source of error and questions.
not sure if it can be avoided if there is to be longword args.

another point, -script is a possible typo to document at least.

a script like this could actually be some kind of leo launcher.
an option could popup a filedialog to get a leo, so it could in Leo.
or open the last leo that has been modified on the local filesystem.
as well as be a test bed for optparse &amp; profile, read from ini file.
not dependant on changing leo.py, just import leo, then leo.run(fname)

for scripting, ability to set argv should be possible somehow.
maybe set sys.argv = [] before run

maybe just breeze through argv trying to concatenate filenames
then try to parse it. and let parseopts save a copy
later calls to parseopts w/o argv will use the saved attribute copy.
probably passing opts+args to run() is cleaner though.


this is the kind of merge that can give cvs merge a bad name, 
good luck!
leoGlobals and change of sys.path used only for testing.
import leoGlobals may not work for the real leo.py this early
before g.app is created. some refactoring is inevitable

why check for win before trying to make filename w/spaces?
does other os not have problem w/spaces in argv w/o quotes?
and why win32? is there no win64 in Leo's user base
or does it not have the space problem w/argv
are single and double quotes around filename the same for other os?
for windows they don't work like double quotes.


the order of parameters might have to be significant
but as it is, the.leo can appear anywhere
and on win, all unused args are joined with spaces just in case
if you do strange stuff possibly you get what you ask for.

does Leo try to find filename.leo if filename is sans the extension?
does it cause an overwrite existing file y/n/c or pass silently overwriting?

-d datadir might be useful if you want to have other than the some.leo same dir
-set somesetting=this like for outline bg color in script playback mode

if leo is started from another shell, argv[0] might not be python or might be
it could be IPython or something else, but there might be its args
as well as the program it started that started Leo
so really, argv should be [find(leo.py'):]
and for some associations or os, no .py or .pyw required
for that matter import leo; leo.run() bypasses option parsing altogether!
this is another problem now that I think of it...
but only if you also expected to get --script or some other option parsed
if you import leo you probably know what you are doing
you would have to set some global options, args I guess is what __main__ will do.
searching to cut back sys.argv for python or python.exe leo etc etc 
is bound to failure, too many cross platform possibilities.

__file__ can also be unreliable when started from py2exe or freeze or a zip

can't so far get /h (a default windows help option) to trigger --help.
seems like if there is no -h option defined, -hanything gets help
could be a source of typo errors 
if other longword no param option started w/'h' 
optparse doesn't handle word-otherword conversion to word_otherword
may be reading the doc wrong on that.
but will handle -sb scriptfile batchfile combining
says -s outfile equivalent to --script=outfile
but what about --script outfile?
carefully avoiding too much smart processing.


hopefully a test suite will expose any anomalies.
the default help output has a few more inconsistencies.
strange there are no bug reports about it in 2 years!
also want to give default values in help, maybe there is a %default

help gets cutoff at 80 chars, 79 according to a lone bugtrack entry
but that was for optparse, nd maybe its base0 counting.
maybe its still bug tracked as optik.sf.net, the original project name.

for future editors, and I sense there will be future edits,
if an individual help entry is longer than ~79 it will get formated ok.


see if we can avoid the ridiculous problem on win where on error
you get an exit and see nothing unless started from console!
source of some forum traffic as well.
maybe, if sys.platform etc: raw_input('press any key to exit')
and for pythonw maybe should popup an alert somehow...
one can dream.

proof of concept, still missing pasing args to run somehow
or seetting an ivar or whatever to get script/batchmode filenames
from main to where it is required. that should be easy enough.



filename is be mandatory for both and it should exist
its checked for batch in leo.py already so checking should be more generic
haven't looked up where --script is processed
didn't rewtrite getbatchfile or whatever its called.
that will be replaced with a check if tobatch has a filename
decide if optparse callback should check for valid existing file
and exit or continue accordingly.

and for an opposing view, if you are scripting leo from another script
then want to enter script mode or batch mode
what has to be available is to intercept the call to read the file.
and pass it a string of the script or batch, w/o problem.
a seperate function instead of hardwireing the read at least.



if I've forgotten anything please post a note to the forums.
beyond that, I don't know what to tell you.
this is proto typical alpha proof of concept pseudo code
although tested somewhat and worked as I expect it to,
it can't be expected to do everything unforseen as well.
and I can't be sure some transmission error hasn't occured.
hold me harmless or hit delete now.

"""

#replace w/Leo's real version assuming it can be known this early
#won't be much use if its leo.py's version
__version__ = '4.4a5' #w06104p01:34 optparse &amp; profile for Leo

import sys, os

#####for testing use only, obviously don't add to leo.py
k = os.path.normpath(os.path.abspath(r"C:\c\leo\V43leos\leo-4-4-\src"))

#path being unicode can affect less than py2.3
if sys.version_info[:2] &lt; (2, 3):
    k = str(k)

#might not be found in sys path on win9x, there is no unicode paths
if k not in sys.path:
    sys.path.append(k)
del k
#needed in profile()too
import leoGlobals as g


@others

#replace from here to end, sans comments
if __name__ == "__main__":


@

    #print os.environ #('IPYTHON') #thought they had this!
    #there is no IPY env var when @run is used -p shell?
    #for IPy need to trim sys.argv
    #sys.argv = sys.argv[2:]
@c


    #not the final configuration FIXME FIXME, danger will robinson
    leofile = None
    argvtight = []

    #going to have to decide to build OptionParser seperatly
    #before parsing so concatate can have access to it.
    #concatate() should be here but is problematic
    #needs to know too much about options.

    #no sense if there are no options or no args.
    #there are ways this can fail though probably rare 
    #dir name w/trailing space + filename leading minus sign
    #and have to decide if slash is ok for option indicator
    #assume no complains if not win argv[1] is ok
    if sys.argv &gt; 1:
        if not [x for x in sys.argv if x[0] == '-']:  #in '-/'
            if sys.platform=="win32": # 
                leofile = ' '.join(sys.argv[1:])
            else:
                leofile = sys.argv[1]
        else:
            #just a test, don't trust it yet
            #may not even need it after all.
            #argvtight = concatate(sys.argv)
            argvtight = sys.argv[1:]
            #print 'concatate arg', argvtight

    #might have to add these to g.app or some kind of global?
    #they are needed in other parts of Leo before it completely starts
    #may need to pass to run and through profile into run as well.

    opts, args = parseopts(argvtight)

    if args and not leofile: leofile = ' '.join(args)
    elif args:
        print &gt;&gt; sys.stderr, 'too many args, try --help'
        #maybe print usage too? except its defined in parseopts
        raise SystemExit(2)

    #print 'past parse_args', `args`, 'leo=', `leofile`

    #for testing only, don't merge exactly
    if opts.tobatch:
        #w/filename hopefully w/o spaces
        print 'batch', opts.tobatch
    if opts.toscript:
        #w/filename hopefully w/o spaces
        print 'script', opts.toscript

    #assume run can get the options it needs at some later point
    #the profile run might require other options 
    #like print sorted stats report to file after exit
    #maybe delay start gathering for 20 seconds but continue

    #maybe should pass run a dict of the options 
    #rather than a static function attribute or global 
    #or just add to globals?

    if opts.toprofile:
        #will probably require filename arg
        #can take a leofile arg as well, default to ''
        #have to use keywords in case leofile is '' or drop coma
        #the actual call may be different, print is for ease of testing
        if leofile is None:  leofile = ''
        else:  leofile  = ','+ leofile
        #must be -P otherwise would be a string filename
        if opts.toprofile == True: opts.toprofile = 'leoProfile.txt'
        print 'profile(%s%s)'%(opts.toprofile, leofile)

    else:
        if leofile is None:  leofile = ''
        print 'run(%s)'%leofile


#e

</t>
<t tx="ekr.20060110102239.2">def profile (statfile='/tmp/leoProfile.txt', leofile= ''):
    
    """Gather and print statistics about Leo
    using new speedy hprof 
    http://www.planetsoc.com
    http://www.soton.ac.uk/~fb102/Python/hprof-0.1.0.tar.gz
    needs a blank __init__.py in the hprof dir

    or hotshot 
    even older profile if you want to go that far back
    add option to force profile, hotshot, hprof or lstat

    valid combined w/script or batch mode as well.
    
    may have the default args and calling sequence wrong
    refactored too much too fast with no time for testing
    should be easily fixed though. it did work yesterday!
    """

    #import profile, pstats
    try:
        from hprof.hprofile import Profile
    except ImportError:
        from hotshot import Profile

    import time

    start = time.time()
    #print "start %s seconds"%((start))


    prof = Profile(statfile)
    prof.run('run(%s)' % leofile)
    prof.close()

    stop = time.time()
    print 'Profile process ', statfile
    print "took %7.3f seconds"%((stop-start)),
    print "or %7.3f min"%((stop-start)/60)

    #skip the profile stats output after run
    #use scriptButton hprof in your work leo
    #may add option to generate stats after the run
</t>
<t tx="ekr.20060110102239.3">def parseopts(argv):
    """  
    should verify leo.py is [0]? optparse ignores [:1] if no argv passed
    except as %prog  in usage help
    running test in commandline manually too, 
    maybe need a maintest.py based on optik unit tests?

    &gt;&gt;&gt; import sys
    &gt;&gt;&gt; print 'argv:',`sys.argv`
    'before sys set'
    &gt;&gt;&gt; sys.argv = ["leo.py", "b", "b.txt"]
    &gt;&gt;&gt; sys.argv = ["leo.py", "b", "-?"]
    &gt;&gt;&gt; print 'argv:',`sys.argv`
    'after sys set'
    &gt;&gt;&gt; parseopts(sys.argv)
    profile
    """    
    import leoGlobals as g
    try:
        #was the original name available for py2.2
        import optik as optparse
    except ImportError:
        #using py2.3+ optparse
        optparse = g.importExtension('optparse')

    #description is in addition to normal help
    #any way to get description to be the help w/o subclassing?
    #later can use parser.usage= '%prog [-h,-n etc  defaults: -c ]'
    
    #if a filename doesn't have leo extension is it assumed?
    #I think some of the comments are starting to repeat.
    #maybe come will get closer to the point of active choice
    #and I can delete the impostor comments.

    descript = 'Leo the python scriptable literate programming editor '
        
    #usage  and description mutually exclusive?
    #usage alone is printed on unknown option or maybe other error
    #no wrap in that case

    #getting this cross platform correct could be difficult
    #especially with variations in associations
    #and isn't and can't be complete wrt paths and pythonpath
    #maybe point to the webspace and docs is enough
    #.py not required for some , python not required for others
    #maybe no choice but to generate some os specific strings
    
    #doesn't mac also have pythonw and can we detect running under wine?
    #has to be some way of embedding \n 

    #-s file -sfile --script=file or --script file all the same?
    
    usage = r'''options [-s/--script scriptfile -b/--batch batchfile leofile]
        more options [-h, --help  and --version]
        problems: try quoting any filenames
        if there is still a problem: please report it with any details
   http://webpages.charter.net/edreamleo/front.html  Leo version %s'''% __version__

    #prog name assumed eventually to be leo.py
    if sys.platform[:3] == 'win':
        usage = 'python -i %%prog leofile.leo  no console pythonw leo.py'+ usage
    else:
        usage = 'python %%prog leofile.leo  -h or --help' + usage
        
    
    parser = optparse.OptionParser(version='%%prog %s' % __version__, 
                        description=descript, usage= usage)

    #how to require a filename? and how to specify it is possibly w/spaces
    #is -s:filename acceptable? that is a common arg convention.
    #ideally tobatch would be None or be the filename
    #and because of spaces con-cation will have to happen outside the parser

    #please comment out any options that are not implemented yet.

    for (l,w,a,t,d,f,h) in (

        # -help does work because its just -h, gets me every time!
        ('-?', '--hepl', "help", "", "", "",
            "help message"),

        ("-q", "--quiet", "store_true", "int", "verbose", 0,
            "don't print status or trace messages"),

        #    -script invalid option
        ("-s", "--script", "store", "string", "toscript", None,
            " script.py to run on startup"),

        ("-b", "--batch", "store", "string", "tobatch", None,
            "batch.py to run, no GUI"),

        #if validate callback for script &amp; batch filename exists, 
        #could happen here if Leo is going to quit later anyway
        #and --safe may be mutually exclusive, confused -s being --script
        #so validate has to wait for parsing to complete, would it?

        #for profile filename is it valid? have permissions/disk space?
        #may want to force hotshot even if hprof or lprof installed
        #maybe only show these options if expert mode is on
        #no need to get a flood of forum reports about profile results
        #maybe leox.py has these options. oh, the possibilitiies.
        #this is for the 5 other people interested in this...
        #not something you want to do every day unless under duress.
        #combined with script and/or batch mode should be very powerful
        ("-p", "--profile", "store", "string", "toprofile", "",
            " save  profile results in outfile.ext       DEFAULT:\
            hprof or hotshot"),

        #a conflicting option repeat of -p won't work, so upcased it
        ("-P", "--Profile", "store_true", "", "toprofile", 0,
            " save  profile results in leoProfile.txt in the leo dir"),

        ):



        #add --settings add -home for change of home maybe -temp maybe -set
        #--settingsneeds leo/config as well as -home which one is germain


        if a == 'help':
            parser.add_option(l, w, action=a)

        elif a != 'store':
            parser.add_option(l, w, action=a,
                        dest= d, default= f, help= h )
        else:
            parser.add_option(l, w, action=a,
                type= t, dest= d, default= f, help= h )
#


@

    parser.add_option("--no-trace",action="store_false",
                  dest="trace", 
                  help="Don't print commands before executing them.") 


    #may want to subclass OptionParser to provide a Leo error exit

    #is there a generic way to check for / used as an option trigger?
    #is // even valid as a trigger
    

    #woops, if -h in argv a little too good
    #better not prevent -high 20 or something similar
    if '-h' in argv or '--help' in argv
           
    #for the win nubiee, / is the default win option starter
    #have to check every arg individually, py2.2 no substring in
    #definate bug that -? is not expected as help in optparse.
    #able to enter -? as an option though.
    
    #can't seem to get /h to trigger help
    for h in argv:
        for i in ('-?', '/help', '/h', '/?'):
            if i == h:
                #parser.error("does this help?")
                #parser.print_help()
                parser.print_usage()
                #print "didn't already exit!"
                raise SystemExit(2)
@c
                

    (opts, args) = parser.parse_args(argv)

    #can I just trap error: no such option: -? and set help=True

    return opts, args</t>
<t tx="ekr.20060110102239.4">#### may have to skip this whole concatate thing ###
#please ignore the comments too
def concatate(argv, paramdict={}):
    """
    paramdict is a dict of single letter keys and
    item = [T/F, 'longname'] set [1] as True/False for require param
    
    walk the list concatate anything with a space
    to the previous item if it doesn't look like a valid option.
    what are the valid options? we don't care...
    is - s filename parseable as -s:filename ??
    this has got to have generated lots of point counterpoint over the years.
    should do some research... 
    have to decide if will accept / as option seperator or if optparse does
    this may not be doable if we alow options to also have spaces in filenames
    does optparse resolve -ffilename as well as -f:filenname the same?

    lets assume an options param can't have spaces, just get it working for now.
    if you enter an option you better quote it if you need to
    leave the space correcting behaviour for default or trailing filenames only
    
    now there is a problem need to know which oiptions have required params
    otherwise can't decide how to concate, unless the space was preserved (it isn't)
    I think on win or anywhere argv[n][0] is never going to be a space
    dito for argv[n][-1]
    so, its a simple FSM with 2 states, an option or a param
    cancel concatate space if previous was an option
    but here we go again, what about options that don't have params?
    optparse doc talks at length about options not having optional params.
    in Leo's case we may need to pass it a list of options that have no params?
    maybe optparse team needs to gix this not the module user
    maybe someone filed a patch already? more study!
    if not who is going to need optparse after this gets done?
    
    maybe just concatate all trailing args till an option, process backward
    its looking moore like a parser than a FSM now and I need to know too much.
    maybe assume all options have required params for now untill imp paramdict
    what about "-script=name, the doc implys that this may be valid?
    
    all validm but they don't mention -file=outfile, maybe is a typo missing -?
    &lt;yourscript&gt; -f outfile --quiet
    &lt;yourscript&gt; --quiet --file outfile
    &lt;yourscript&gt; -q -foutfile
    &lt;yourscript&gt; -qfoutfile
    damm, this is not going to even be worth trying
    seems -script == --script criptm 
    that could be confusing and error prone


    &gt;&gt;&gt; concatate(['1','2','3'])
    ['1 2 3']
    &gt;&gt;&gt; concatate(['-1','2','3'])  #rule option param can't have spaces
    ['-1', '2', '3']
    &gt;&gt;&gt; concatate(['-s','2','3' '4']) #-s has required param
    ['-s', '2', '3 4']
    &gt;&gt;&gt; # a little trickier -ffilename default arg, 
    &gt;&gt;&gt; #optparse won't do this? getopt probably would,
    &gt;&gt;&gt; concatate(['-1',' 2','3' '4'])
    ['-1', '2', '3 4']

    &gt;&gt;&gt; #fix for extra credit, user probably screwed up? should ask them?
    &gt;&gt;&gt; concatate(['1','- 2','3'])
    ['1', '- 2', '3']
    
    """

    #preparse sys.argv concating filenames w/spaces 
    #as appropriate for --script and --batch and any leofilename
    #or is this something parseopts should be doing?
    #not so simple really 
    #if argc ==1 then no options or filename
    #if any options start w/ - or / then it gets dicey
    # could be a space in the last part of a directory in seperate items
    #we may not be able to cover every concievable case
    
    prev = ''
    lst = []
    
    for x in argv:

        if x[0] == '-':  #or '/' or x in '/-'
            lst.append(x)
            if prev:
                lst.append(prev)
                prev = ''
        else:
            if prev: prev = prev + ' ' + x
            else:    prev = x
        
        #print 'droped thru x:prev', `x`, `prev`
    else:
        if prev:
            lst.append(prev)

    return lst
    

</t>
<t tx="ekr.20060110102239.5">@
make into a real series of tests
I made the name leo\smain.py because my associateions for py are to open editor
so this could never run leo then open main.py even if I was in leo/src


$ python leo main.py
C:\C\PY\PYTHON~1\PYTHON.EXE: can't open file 'leo'

$ python "leo main.py"
past parse_args ['leo main.py']
leo.run()

$ python 'leo main.py'
C:\C\PY\PYTHON~1\PYTHON.EXE: can't open file ''leo'

$ python "leo main.py" filename
past parse_args ['leo main.py', 'filename']
leo.run()

$ python "leo main.py" c:/filename /help/some.leo
processed arg ['leo main.py', 'c:/filename', '/help/some.leo']
past parse_args ['leo main.py', 'c:/filename', '/help/some.leo']
leo.run()

$ python "leo main.py" "c:/filename /help/some.leo"
processed arg ['leo main.py', 'c:/filename /help/some.leo']
past parse_args ['leo main.py', 'c:/filename /help/some.leo']
leo.run()

$ python "leo main.py" "c:/filename /help/some.leo"
processed arg ['leo main.py', 'c:/filename /help/some.leo']
past parse_args ['leo main.py', 'c:/filename /help/some.leo'] leo= c:/filename /
help/some.leo
leo.run(c:/filename /help/some.leo)

$ python "leo main.py" c:/filename /help/some.leo
processed arg ['leo main.py', 'c:/filename', '/help/some.leo']
past parse_args ['leo main.py', 'c:/filename', '/help/some.leo'] leo= c:/filenam
e /help/some.leo
leo.run(c:/filename /help/some.leo)

-script works for --script cript it seems
and that could be a typo missing --script so the next filename
gets concatated into the leo name which I guess can't be helped

OTOH, if you use the default version=
then --versions works but -v or -version doesn't


$ \c\py\python24\python "leo main.py" test.leo -p whatever else
concatate arg ['test.leo', '-p', 'whatever', 'else']
past parse_args ['test.leo', 'else'] leo= 'test.leo else'
profile(whatever, test.leo else)
this is the thing that is still hard to avoid. on win, has to be
$ \c\py\python24\python "leo main.py" test.leo -p "whatever else"

really need to get this tested on other than old win9x,





@killcolor
</t>
<t tx="ekr.20060110102239.6">@
will it handle spaces in filenames w/o quotes?

leo.py --script filename.leo is not good
leo.py -script filename is not good, which is it a scriptfile or a leo to be?

as error for -profile as an option, going to have to subclass override error
AttributeError Values instance has no attribute 'profile' ["__module__ = 'exceptions' .", "__doc__ = 'Attribute not found.' ."] 
this was a programmer error though, the var is toprofile

little hard to test this as a script, can't control argv
update, sys.argv = seems now to be working from doctest
better readup, haven't used this in a while
haven't read the docs in a while either, a good read.
especially the origional optik.sf.net


need to make this a function to call returning a dict maybe?
at least to doctest it better w/o needing to create a test module 
and then run it saving stdout

its also going to be a little trickier to --script or --batch with --profile
and what is exactly the difference with --batch and --script?
one has no GUI maybe?


- is valid in a filename, so primitive argv parsing
will be difficult to distinguish in a filename w./spaces
since the spaces cause seperate items and just a join
is not good because you have to know if it is a valid arg
what if it is a valid arg? this is a nightmare in any case...


need a timer on operations while getting a profile
expandall, contrract all so can be output with the pstats

need to set options in a seperate function
so can generate test for all functions and params on the fly
this will be good in the general case for other programs

anyone already depending on case insensitive args?

default file for profile not working out
comprimise -P as an option w/o param uses default leoProfile.txt

if -p file name -s some.py will be difficult to get right w/o quoting
will anyone ever expect a default? 
unless thats in the leodir or something?
dito for script and batch but what possible default could they have, 



does x is None work on py2.2?

</t>
<t tx="ekr.20060110102239.7">@color
@
hprof from google summer of code replace hotshot &amp; profile
much faster on the uptake and output!
has compatibility modules so can use mostly the same calls
this script uses the hprof calls. didn't mod leo.py yet
as I am not able to compile _hotshot.c to pyd or .so
it will use hotshot created profile ok.

added psyco, need to create batch file so can automate &amp; timeit.
also have modified leoGlobals match and a few other things already
and proven You can shave at lest a few seconds overall,

can combine add more than one profile run to get better data
but I don;t do that in this script.

and pypy has lstat which also didn't compile for me
and possibly isn't windows compatible yet
along with another mentioned in this past weeks py-dev summary.


need something to compare the diff of 2 profiles
sorted the same way, something to add comments to the
profile, maybe a simple flatfile to manage profiling.
seems this would have been a project for someone already?

chg leo.py profile to create hotshot profile file
then run, copy a node from library
expand/contract a few times then exit.

takes a few minutes to process the hotshot file
then prints enormous amout of stats...
you see a few leoGlobals called a few hundred thousand times
on a run of 5 or 10 minutes.

        Stats('foo', 'goo').strip_dirs().sort_stats('calls').\
                            print_stats(5).print_callers(5)
              "calls"     : (((1,-1),              ), "call count"),
              "cumulative": (((3,-1),              ), "cumulative time"),
              "file"      : (((4, 1),              ), "file name"),
              "line"      : (((5, 1),              ), "line number"),
              "module"    : (((4, 1),              ), "file name"),
              "name"      : (((6, 1),              ), "function name"),
              "nfl"       : (((6, 1),(4, 1),(5, 1),), "name/file/line"),
              "pcalls"    : (((0,-1),              ), "call count"),
              "stdname"   : (((7, 1),              ), "standard name"),
              "time"      : (((2,-1),              ), "internal time"),

@c
from dyna_menu import dtef
@others 

 
def showstats():
    """ log sort of stops printing when you type! or grab scrollbars.
    need to print to copybuffer, redirect io to log print very slow
    may actually be faster if you minimize leo
    also can make the log window very small
    in Leo4.4 you can multitask a little when it starts to print.
    """
    import leoGlobals as g
    #import profile, pstats
    try:
        from hprof.hpstats import Stats
    except ImportError:
        from hotshot import Stats
    import sys
    
    name = "/tmp/leoProfile.txt"
    print 'processing ', name

    #profile.run('leo.run()',name)
    #prof = hotshot.Profile(name)
    #prof.runcall(run)
    #prof.close()

    #p = pstats.Stats(name)
    #p.strip_dirs()
    #p.sort_stats('cum','file','name')
    #p.print_stats()

    
    #would be nicer if strip_dirs left one more level of dir
    #or even better took an int to leave how many levels
    #several modules have similar def names, __init__ etc
    #will have to override that.
    
    s = Stats(name).strip_dirs()

    #need to reverse or trap stdout to file    
    #why does g. not have a simple command to do this?
    #whydoes stats.print not take a filename? 
    #weird no one thinks of these things. is it just me?

#    sys.stdout = g.fileLikeObject()
    
    print 'start.sort', dtef(c),
    s.sort_stats("time").print_stats()  #.print_callers()
@
    stat = sys.stdout.get()
    sys.stdout.close()
    sys.stdout = sys.__stdout__

    #attempt to get a better strip_dirs later
    for k,v in repdict.iteritems():
        stat = stat.replace(k,v)
    print stat[:400]
@c    

print 'start', dtef(c),
showstats()
print 'done', dtef(c)</t>
<t tx="ekr.20060110102239.8">try:
    if 1:#1/0  If present, use psyco to accelerate the program
        import psyco
        psyco.full()  #carefull with this in py2.3 esp w/leo 
        #shows alot of time in tkinter and other plain leo routines!
        #though this was per module only 
        #from psyco.classes import *

        #psyco.log(logfile='c:/temp/sb1.log', mode='w', top=30)
        #psyco.profile(0.2)
        #psyco.profile( watermark=0.09, halflife=0.5, pollfreq=20,  parentframe=0.25, memory=None, time=None, memorymax=None, timemax=None) 
        #psyco.bind(searchButton) #not in scope, put after def
        #psyco.bind(gen_nodes)  #generators 
except ImportError: pass
</t>
<t tx="ekr.20060111103821"></t>
<t tx="ekr.20060111103821.1">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3517023
By: ktenney

W2K, recent CVS (Sourceforge is asking for a
passwords and refusing to let me update)

Window - Open Python Window

Close the Python Window

Plugins - Core - Plugin Manager causes traceback;

exception executing command
Traceback (most recent call last):
  File "C:\python24\lib\site-packages\leo\src\leoCommands.py", line 238, in
doCommand
    val = command()
  File "C:\python24\lib\site-packages\leo\plugins\plugins_menu.py", line 548,
in callback
    p.hastoplevel()
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 231,
in topLevelMenu
    dlg = ManagerDialog(True)
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 777,
in __init__
    self.plugin_view = PluginView(self.upper, self.file_text)
  File "C:\python24\lib\site-packages\leo\plugins\plugin_manager.py", line 282,
in __init__
    labelpos = 'w',label_text = 'Name:')
  File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwEntryField.py", line
73, in __init__
    sequences = root.bind_class(tag)
AttributeError: 'NoneType' object has no attribute 'bind_class'
</t>
<t tx="ekr.20060111103821.2"></t>
<t tx="ekr.20060111103821.3">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3517180
By: rich_ries

With Universal Scrolling, the Right mouse button works (scrolls up) but the
Left mouse button (scroll down) does not. (Yes, I made sure I had a Leo file
I could scroll up/down in.)

--Rich
P.S. -- Is there any way for the "select-node-on-mouse-click" feature to be
disabled during scrolling? When I'm scrolling along, and I come to a long node,
the scrolling stops and the long node is selected. NOT what I want! FWIW, my
workaround is to locate the mouse on the far left side of the Outline Pane.</t>
<t tx="ekr.20060111134004"></t>
<t tx="ekr.20060111134004.1">Leo's Open Python Window command should take care to run Idle in a separate process.

The present code is essentially:

import idlelib.PyShell
idlelib.PyShell.main()

As the present problems with the Plugins manager show, this has the potential for mischief.  Indeed, idle is a Tkinter process, so Idle's shutdown code could interfere with Tkinter, Pmw, g.app or all three.

It's no good blaming Pmw or Idle or whatever, there needs to be a solid way of avoiding problems, both now and in the future.  The obvious way is to use os.system or subprocess to keep Idle at arm's length.  If necessary we can use settings in leoSettings.leo to tell Leo exactly how to start Idle.</t>
<t tx="ekr.20060111134901"></t>
<t tx="ekr.20060111152145">- Organize scripts menu from subfolders of leo/scripts folder.

- Create minibuffer commands for each script?</t>
<t tx="ekr.20060113062832.1">def copyBindingsHelper(self,bunchList,shortcut,w):

    k = self ; c = k.c

    textBunch = treeBunch = None
    for bunch in bunchList:
        if bunch.pane == 'tree' and treeBunch is None:
            treeBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif bunch.pane != 'tree' and textBunch is None:
            textBunch = bunch
            k.traceBinding (bunch,shortcut,w)
        elif c.config.getBool('trace_bindings'):
            g.trace('ignoring %s in %s' % (shortcut,bunch.pane))
            
    if textBunch and treeBunch:
        def textAndTreeKeyCallback(event,c=c,
            textFunc=textBunch.func,treeFunc=treeBunch.func):
            w = c.currentPosition().edit_widget()
            if w and w.cget('state') == 'disabled':
                treeFunc(event)
            else:
                textFunc(event)
            return 'break'

        w.bind(shortcut,textAndTreeKeyCallback)
        
    elif textBunch or treeBunch:

        def textOrTreeKeyCallback(event,func=bunch.func):
            func(event)
            return 'break'

        w.bind(shortcut,textOrTreeKeyCallback)</t>
<t tx="ekr.20060113090042"></t>
<t tx="ekr.20060114052626">This is not needed with Ctrl-C mode.</t>
<t tx="ekr.20060114055611">- It should recolor the text.
- Does it not stick sometimes?</t>
<t tx="ekr.20060114110141">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,k.prettyPrintKey(shortcut),commandName)</t>
<t tx="ekr.20060114115648">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060114215112">
</t>
<t tx="ekr.20060115091804.2"></t>
<t tx="ekr.20060115100407"></t>
<t tx="ekr.20060115100841"></t>
<t tx="ekr.20060115100841.1"></t>
<t tx="ekr.20060115103349"></t>
<t tx="ekr.20060115134337"></t>
<t tx="ekr.20060116073229"></t>
<t tx="ekr.20060116073539"></t>
<t tx="ekr.20060116073938"></t>
<t tx="ekr.20060116073938.1">Not necessarily important, but should be done first.</t>
<t tx="ekr.20060116073938.2"></t>
<t tx="ekr.20060116074450">- create-tab
- clear-tab
- delete-tab
- hide-tab

These might get the tab name from the minibuffer...</t>
<t tx="ekr.20060116074450.1"># These are minor</t>
<t tx="ekr.20060116074450.2">- Review the posting about making positions permanent, or recording vnode
indicies. It's probably time to do this.</t>
<t tx="ekr.20060116074450.3"></t>
<t tx="ekr.20060116074839"></t>
<t tx="ekr.20060116074839.2"></t>
<t tx="ekr.20060116075549">Specify what mode to enter after each command:

- command-name -&gt; mode-name = binding

will specify what mode to enter after each command.
At present, all commands exit to the top-level mode.

- Add @string active-keyset setting?</t>
<t tx="ekr.20060116080040.2">These would be an alternative to XP Alt-f, Alt-E, etc.
</t>
<t tx="ekr.20060116080040.3">set-option sets a (Python) variable using an minibuffer-style variable name.</t>
<t tx="ekr.20060116082302.1">On startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.</t>
<t tx="ekr.20060116083043">More mac nits: two HELP menus, one is empty; </t>
<t tx="ekr.20060116083043.1"></t>
<t tx="ekr.20060116083359">- dismiss-about-dialog</t>
<t tx="ekr.20060116083359.1"></t>
<t tx="ekr.20060116084526.1">http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space is added to start of all selected lines.

add-tab-to-line         Adds 4 spaces to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a space from start of all selected lines.</t>
<t tx="ekr.20060116084755">Note: focus commands already exist.</t>
<t tx="ekr.20060116085217">@nocolor

Urgent for outline pane, find panel, etc.

The following commands already work in the body pane.

scroll-down
scroll-down-extend-selection  
scroll-up
scroll-up-extend-selection

Note: arrow keys scroll the outline as needed, so there *is* a way to scroll the outline without the UniversalScrolling plugin.

@color</t>
<t tx="ekr.20060116085649"></t>
<t tx="ekr.20060116090357.2">set-increment-search-on/off
set-regexp-search-on/off
set-search-body-on/off
set-search-case-on/off
set-search-headline-on/off
set-search-scope-to-outline/subtree/node
set-word-search-on/off
set-wrap-search-on/off

set-default-search-options: Sets the default search options to the present search options.

Control keys could change these options *after* starting the search command?
Or use 'Options' tab?


</t>
<t tx="ekr.20060116090428"></t>
<t tx="ekr.20060116091116"></t>
<t tx="ekr.20060116091116.1"></t>
<t tx="ekr.20060116091236"></t>
<t tx="ekr.20060116092801"></t>
<t tx="ekr.20060116173818"></t>
<t tx="ekr.20060117074259"></t>
<t tx="ekr.20060117074259.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3526056
By: nobody

Hi Edward. I've been using the linux and windows version but would like to try
leo on the mac. The install instructions seem a bit out of date. I take it any
additional downloading of TclTkAqua is unneccessary?

I have python2.4 in addition to the stock python 2.3.5 that comes with osx 10.4.
Launching leo like so:  "python2.4 leo.py", as I do on linux, seems to run just
fine.

I don't know if this was fixed on osx or in leo in general, but moving the mouse
to each of the panes and scrolling with the wheel works just great now. Thanks.

Plugin manager: the plugin text font is really tiny, and the window opens to
a default width such that the 'Installed Plugins' button reads 'talled Plugi'.
Resizing the window does stretch the buttons horizontally.

Ok -- here's maybe a big issue. I open a new leo file (File-&gt;New) and type in:

for i in range(3):

I hit return after the colon, but a newline is not entered.

Stephen
</t>
<t tx="ekr.20060117091430.1">@nocolor

Must check for c.exists in c.executeScript after executing the script.</t>
<t tx="ekr.20060117091600"></t>
<t tx="ekr.20060117094955">def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat Last Complex Command','repeat-complex-command'),
        ('Execute Named Command','full-command'),
        ("-",None),
    ]
</t>
<t tx="ekr.20060117094955.1">def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117095212">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('Append To Buffer',             'append-to-buffer'),
        ('Kill Buffer',                  'kill-buffer'),
        ('List Buffers',                 'list-buffers'),
        ('List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('Prepend To Buffer',            'prepend-to-buffer'),
        ('Rename Buffer',                'rename-buffer'),
        ('Switch To Buffer',             'switch-to-buffer'),
    ]</t>
<t tx="ekr.20060117095212.1">def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117095212.2">def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117095212.3">def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort Columns',    'sort-columns'),
        ('Sort Fields',     'sort-fields'),
        ('Sort Lines',      'sort-lines'),
    ]</t>
<t tx="ekr.20060117095212.4">def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('Capitalize Word', 'capitalize-word'),
        ('Downcase Region', 'downcase-region'),
        ('Downcase Word',   'downcase-word'),
        ('Upcase Region',   'upcase-region'), # Crashes.
        ('Upcase Word',     'upcase-word'),
    ]
    </t>
<t tx="ekr.20060117095212.5">def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center Line',     'center-line'),
        ('Center Region',   'center-region'),
    ]</t>
<t tx="ekr.20060117095212.6">def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('Indent Region',   'indent-region'),
        ('Indent Relative', 'indent-relative'),
        ('Indent Rigidly',  'indent-rigidly'),
        ('Unindent Region', 'unindent-region'),
    ]</t>
<t tx="ekr.20060117095212.7">def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check Spelling',      'open-spell-tab'),
        ('Change',              'spell-change'),
        ('Change, Then Find',   'spell-change-then-find'),
        ('Find',                'spell-find'),
        ('Ignore',              'spell-ignore'),
    ]</t>
<t tx="ekr.20060117112444">@nocolor

- Call menu.defineMenuTables from menu.createMenusFromTables.
  This ensures the keyHandler class has been created.

- Added support for using minibuffer command names instead of command in menu
tables. This is a signal that the command is a new-style minibuffer command
rather than a legacy command. This required minor changes in createMenu entries
and defineMenuCallback.</t>
<t tx="ekr.20060117114315">def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117114903"></t>
<t tx="ekr.20060117115212"></t>
<t tx="ekr.20060117123143">        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
       
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
      
</t>
<t tx="ekr.20060117124457">@nocolor

isearch-forward should leave cursor at right end.
isearch-backward should leave cursor at left end.

unindent-region should do nothing if not in body pane, or it should work in all panes.

** Change background color of tree when it is active.

@color</t>
<t tx="ekr.20060117131228">AttributeError Exception in Tk callback
  Function: &lt;function allKeysCallback at 0x01548C30&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x015F7738&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "C:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1748, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 679, in allKeysCallback
    return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 804, in masterCommand
    k.callStateFunction(event) # Calls end-command.
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 847, in callStateFunction
    val = k.state.handler(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1032, in generalModeHandler
    if k.matchKeys(event,bunch.val):
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1884, in matchKeys
    val = shortcut == keysym or shortcut.startswith('Key-') and shortcut.endswith(keysym)
AttributeError: 'NoneType' object has no attribute 'startswith'</t>
<t tx="ekr.20060117181301"></t>
<t tx="ekr.20060117181301.1">def searchAgain (self,event):

    if self.incremental:
        self.iSearchHelper(event,self.forward,self.regexp)
    elif self.regexp:
        self.reSearchHelper(event,self.searchString,self.forward)
    elif self.word:
        self.wordSearchHelper(event,self.searchString,self.forward)
    else:
        self.plainSearchHelper(event,self.searchString,self.forward)
</t>
<t tx="ekr.20060117201349"></t>
<t tx="ekr.20060117201349.1"></t>
<t tx="ekr.20060117202916">def badMode(self,modeName):
    
    k = self

    k.clearState()
    if modeName.endswith('-mode'): modeName = modeName[:-5]
    k.setLabelGrey('@mode %s is not defined (or is empty)' % modeName)</t>
<t tx="ekr.20060117202916.1">def initMode (self,event,modeName):

    k = self ; c = k.c
    
    if not modeName:
        g.trace('No mode name')
        return

    k.inputModeName = modeName
    d = g.app.config.modeCommandsDict.get('enter-'+modeName)
    if not d:
        self.badMode(modeName)
        return
        
    t = c.frame.body.bodyCtrl
    k.savedBindtags = t.bindtags()
    tagName = '%s-%s' % (modeName,c.fileName())
    t.bindtags(tuple([tagName]))
    # g.trace(modeName,tagName,t.bindtags())
        
    # Note: we much create separate bindings for each commander.
    modeBindings = k.bindtagsDict.get(tagName)
    if not modeBindings:
        # g.trace('created mode bindings: %s' % (tagName))
        k.createModeBindings(modeName,tagName,d)
        k.bindtagsDict[tagName] = True

    k.setLabelBlue(modeName+': ',protect=True)
    # Do *not* change the focus here!</t>
<t tx="ekr.20060117202916.2">def endMode(self,event):
    
    k = self ; c = k.c
    
    w = g.app.gui.get_focus(c.frame)

    # Restore the bind tags.
    t = c.frame.body.bodyCtrl
    t.bindtags(k.savedBindtags)

    k.endCommand(event,k.stroke)
    k.inputModeName = None
    k.clearState()
    k.resetLabel()
    # k.setLabelGrey('top-level mode')
    
    # Do *not* change the focus: the command may have changed it.
    c.frame.widgetWantsFocus(w)</t>
<t tx="ekr.20060118181341"># g.trace('Mode %s: binding %s to %s' % (modeName,stroke,commandName))

def modeCallback (event,k=k,
    bunch=bunch,commandName=commandName,func=func,modeName=modeName,stroke=stroke):
        
    __pychecker__ = '--no-argsused' # stroke
    
    # g.trace(stroke)
    return k.generalModeHandler(event,bunch,commandName,func,modeName)

# k.bindKey('all',stroke,modeCallback,commandName)

t.bind_class(tagName,stroke,modeCallback)</t>
<t tx="ekr.20060119063223.1">def computeKeysym_numDicts (self,shortcut):
    
    k = self
    
    if shortcut == '&lt;Key&gt;': return
    
    n = k.keysym_numberInverseDict.get(shortcut)
    if n is not None:
        # print 'keysym_num for %s = %d' % (shortcut,n)
        return
        
    def callback (event,shortcut=shortcut):
        n = event.keysym_num
        # Trace causes problems.
        print '%5d = %s' % (n,shortcut)
        k.keysym_numberDict [n] = shortcut
        k.keysym_numberInverseDict [shortcut] = n
        
    if 0:  # This causes all sorts of problems.
        t = Tk.Text(k.c.frame.outerFrame)
        t = k.c.frame.body.bodyCtrl
        t.bind(shortcut,callback)
        t.event_generate(shortcut)
        # t.update()
        # t.unbind(shortcut)</t>
<t tx="ekr.20060119145631">def modeHelpCallback (event,k=k):
    
    if event and event.char != '':
        return k.modeHelp(event)
    else:
        return 'break'

# k.bindKey('all',stroke,modeHelpCallback,commandName)

t.bind_class(tagName,'&lt;Key&gt;',modeHelpCallback,'+')</t>
<t tx="ekr.20060119150624">def createModeBindings (self,modeName,tagName,d):
    
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    for commandName in d.keys():
        func = c.commandsDict.get(commandName)
        if func:
            bunchList = d.get(commandName,[])
            for bunch in bunchList:
                shortcut = bunch.val
                if shortcut and shortcut not in ('None','none',None):
                    stroke, junk = c.frame.menu.canonicalizeShortcut(shortcut)
                    # g.trace(stroke,shortcut)
                    &lt;&lt; define modeCallback &gt;&gt;
        else:
            g.trace('No such command: %s' % commandName)

    &lt;&lt; define modeHelpCallback &gt;&gt;</t>
<t tx="ekr.20060119201356"></t>
<t tx="ekr.20060119201657"></t>
<t tx="ekr.20060120071949">def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''
    
    shortcut1 = shortcut[:]

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('&lt;'):   shortcut = shortcut[1:]
    if shortcut.endswith('&gt;'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]
    
    # if len(shortcut) == 1:
        # g.trace(shortcut1)

    return len(shortcut) == 1</t>
<t tx="ekr.20060120082630">def plainKeyTag (self):
    
    return '%s-%s' % ('plain-key',self.c.fileName())</t>
<t tx="ekr.20060120084705"></t>
<t tx="ekr.20060120103549">@nocolor

What I did:
    
- endMode must not change focus.

- modeHelp calls c.endEditing(retainFocus=True)

@color</t>
<t tx="ekr.20060120105247">@nocolor

- keyboard-quit now ends editing.

- print-bindings shows plain keys only in 'ignore' mode.

- Removed k.add_ekr_altx_commands and k.makeHardBindings.

- Added binding to vim plain shortcuts: mode-help = h

- Print the initial mode when first creating a window.
  The change had to be made in g.openWithFileName because of the UNL plugin.

- Improved print-bindings &amp; mode help.

- endMode retains the widget on entry, so e.g., inserting a new node retaings the headline editing state.

@color
</t>
<t tx="ekr.20060120105445"></t>
<t tx="ekr.20060120105605.1"></t>
<t tx="ekr.20060120110341">@nocolor

- Added initialClickExpandsOrContractsNode settings.  Clicking an node expands or contracts the node if this setting is True.  EKR much prefers False. 

- Selecting a headline should not select text in it.

@color
</t>
<t tx="ekr.20060120193743">def showStateAndMode(self):
    
    k = self ; frame = k.c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind() or 'none'
   

    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        put('state: ',color='blue')
        put(state)
        put(' mode: ',color='blue')
        put(mode)</t>
<t tx="ekr.20060120200529">@nocolor

What I did:

- bindKeyHelper copies *all* bindings to the bindtag set.
  This prevents control-i from matching the &lt;i&gt; binding.  Sheesh.

- bindKeyHelper makes widget bindings for all bindings *except* plain key bindings.

- copyBindingsToWidget does not copy plain key bindings.

- k.setMode and k.setInputState call k.showInputState, so the state and mode are alway updated.</t>
<t tx="ekr.20060120200818">def setInputState (self,state):
    k = self ; c = k.c ; t = c.frame.body.bodyCtrl
    
    tag = k.plainKeyTag()
    try: # Will fail for nullBody.
        tags = list(t.bindtags())
        w = g.app.gui.get_focus(c.frame)
    except AttributeError:
        tags = [] ; w = None
        
    if tags:
        if state == 'ignore':
            if tag not in tags:
                tags.insert(0,tag)
                t.bindtags(tuple(tags))
        else:
            if tag in tags:
                tags.remove(tag)
                t.bindtags(tuple(tags))
    elif w:
        g.trace("***** can't happen")

    # g.trace('%s-state' % (state),'plain key functions are',g.choose(tag in tags,'enabled','disabled'))
    k.unboundKeyAction = state
    k.showStateAndMode()
   
    # These commands never change focus.
    w and c.frame.widgetWantsFocus(w)</t>
</tnodes>
</leo_file>
