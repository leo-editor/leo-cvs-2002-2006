<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="9078" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="48" left="451" height="870" width="793"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936" a="E"
expanded="ekr.20060210140415,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601" descendentTnodeUnknownAttributes="7d71005814000000656b722e32303036303230313135303534372e3871017d710255092f3e0d0a3c742074787103551a7a6f7263616e6461212e32303035303932353136303131382e31710473732e"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20060203112912.1"><vh>Initing</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3941"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20031218072017.1801"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20031218072017.1802"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3942"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20041221122440"><vh>f.component &amp; components</vh></v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20051121092320"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20041221071131"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20041221071131.1"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050119210541"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041221123325"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20041223130032"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20041221195402"><vh>Pmw...</vh>
<v t="ekr.20041221073427"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20031218072017.3946"><vh>resizePanesToRatio</vh>
<v t="ekr.20050104084531"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221075743"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20041221185246"><vh>Tk...</vh>
<v t="ekr.20041221073427.1"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20031218072017.3947"><vh>bindBar</vh></v>
<v t="ekr.20031218072017.3949"><vh>divideAnySplitter</vh></v>
<v t="ekr.20031218072017.3950"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20031218072017.3951"><vh>onDrag...</vh></v>
<v t="ekr.20031218072017.3952"><vh>placeSplitter</vh></v>
<v t="ekr.20031218072017.998"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3964"><vh>Destroying the frame</vh>
<v t="ekr.20031218072017.1975"><vh>destroyAllObjects</vh>
<v t="ekr.20031218072017.1976"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3965"><vh>destroyAllPanels</vh></v>
<v t="ekr.20031218072017.1974"><vh>destroySelf (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
</v>
<v t="ekr.20060214140930"><vh>4.4b3 projects</vh>
<v t="ekr.20060214140930.1"><vh>Restored some legacy bindings</vh></v>
</v>
</v>
<v t="ekr.20060116073938" a="EV"><vh>To do 4.4b3</vh>
<v t="ekr.20060213164147"><vh>Fix crasher in Go To Line command</vh></v>
<v t="ekr.20060213151411"><vh>Fix problems with unicode characters &amp; caps lock</vh>
<v t="ekr.20060213160417"><vh>Report</vh></v>
</v>
<v t="ekr.20051126122638"><vh>Autocompletion tab</vh>
<v t="ekr.20060214110318"><vh>Options</vh></v>
<v t="ekr.20051205093049"><vh>Use dir for auto-complete ?</vh></v>
<v t="ekr.20051025144611"><vh>Reference (Do not delete)</vh>
<v t="ekr.20051025144611.1"><vh>Configuration</vh>
<v t="ekr.20051025144611.2"><vh>autocompleter.ini</vh></v>
<v t="ekr.20051025144611.3"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20051025144611.4"><vh>autocompleter.py</vh>
<v t="ekr.20051025144611.5"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20051025144611.6"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051025144611.7"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20051025144611.8"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="ekr.20051025144611.10"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="ekr.20051025144611.11"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20051025144611.12"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="ekr.20051025144611.13"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20051025144611.14"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20051025170832"><vh>Initialization</vh>
<v t="ekr.20051025144611.15"><vh>init</vh></v>
<v t="ekr.20051025170832.1"><vh>Config stuff</vh>
<v t="ekr.20051025144611.24"><vh>has read config file meths</vh></v>
<v t="ekr.20051025144611.25"><vh>readConfigFile</vh></v>
<v t="ekr.20051025144611.26"><vh>createConfigFile</vh></v>
<v t="ekr.20051025144611.27"><vh>readLanguageFiles</vh></v>
<v t="ekr.20051025144611.28"><vh>readOutline</vh></v>
</v>
<v t="ekr.20051025144611.16"><vh>watcher</vh></v>
<v t="ekr.20051025144611.23"><vh>initialScan</vh></v>
</v>
<v t="ekr.20051025144611.17"><vh>scanText</vh></v>
<v t="ekr.20051025144611.18"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20051025144611.19"><vh>scanForCallTip</vh></v>
<v t="ekr.20051025144611.20"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20051025144611.21"><vh>_getCleanString</vh></v>
<v t="ekr.20051025144611.22"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20051025144611.29"><vh>reducer</vh></v>
<v t="ekr.20051025144611.30"><vh>unbind</vh></v>
<v t="ekr.20051025144611.31"><vh>moveSelItem</vh></v>
<v t="ekr.20051025144611.32"><vh>processKeyStroke</vh></v>
<v t="ekr.20051025144611.33"><vh>testForUnbind</vh></v>
<v t="ekr.20051025144611.34"><vh>processAutoBox</vh></v>
<v t="ekr.20051025144611.35"><vh>add_item</vh></v>
<v t="ekr.20051025144611.36"><vh>add_bindings</vh></v>
<v t="ekr.20051025144611.37"><vh>configureAutoBox</vh></v>
<v t="ekr.20051025144611.38"><vh>calculatePlace</vh></v>
<v t="ekr.20051025144611.39"><vh>setLanguage</vh></v>
<v t="ekr.20051025144611.40"><vh>newCreateControl</vh></v>
<v t="ekr.20051025144611.41"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20051025144611.42"><vh>onOpenWindow</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4059"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20031218072017.844"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20031218072017.845"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20031218072017.846"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20031218072017.4060"><vh>Dialog</vh>
<v t="ekr.20031218072017.4061"><vh>get_window_info</vh></v>
<v t="ekr.20031218072017.4062"><vh>center_dialog</vh></v>
<v t="ekr.20031218072017.4063"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20031218072017.4064"><vh>Focus</vh>
<v t="ekr.20031218072017.4065"><vh>get_focus</vh></v>
<v t="ekr.20031218072017.2373"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20031218072017.4066"><vh>Font</vh>
<v t="ekr.20031218072017.2187"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20031218072017.4067"><vh>Icons</vh>
<v t="ekr.20031218072017.4068"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20031218072017.4069"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4070"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4071"><vh>Idle Time</vh>
<v t="ekr.20031218072017.4072"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20031218072017.4073"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20031218072017.4074"><vh>Indices (Tk)</vh>
<v t="ekr.20031218072017.4075"><vh>firstIndex</vh></v>
<v t="ekr.20031218072017.4076"><vh>lastIndex</vh></v>
<v t="ekr.20031218072017.4077"><vh>moveIndexBackward</vh></v>
<v t="ekr.20031218072017.4078"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20031218072017.4079"><vh>compareIndices</vh></v>
<v t="ekr.20031218072017.4080"><vh>getindex</vh></v>
</v>
<v t="ekr.20031218072017.4081"><vh>Insert Point</vh>
<v t="ekr.20031218072017.4082"><vh>getInsertPoint</vh></v>
<v t="ekr.20031218072017.4083"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20031218072017.4084"><vh>Selection</vh>
<v t="ekr.20031218072017.4085"><vh>getSelectionRange</vh></v>
<v t="ekr.20051126125950"><vh>getSelectedText</vh></v>
<v t="ekr.20031218072017.4086"><vh>getTextSelection</vh></v>
<v t="ekr.20051126171929"><vh>hasSelection</vh></v>
<v t="ekr.20031218072017.4088"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20031218072017.4089"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20031218072017.4090"><vh>Text</vh>
<v t="ekr.20031218072017.4091"><vh>getAllText</vh></v>
<v t="ekr.20031218072017.4092"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20031218072017.4093"><vh>getCharAtIndex</vh></v>
<v t="ekr.20031218072017.4094"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20031218072017.4095"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20031218072017.4096"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20031218072017.4097"><vh>Visibility</vh>
<v t="ekr.20031218072017.4098"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20051220144507"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20051126123249"><vh>class autoCompleterClass (prototype)</vh>
<v t="ekr.20051126123759"><vh> birth</vh>
<v t="ekr.20051126123759.1"><vh> ctor</vh></v>
<v t="ekr.20051126123759.2"><vh> getPublicCommands (autoCommandsClass)</vh></v>
</v>
<v t="ekr.20051127105431"><vh>abort</vh></v>
<v t="ekr.20051126122952.1"><vh>autoComplete</vh></v>
<v t="ekr.20051126123149"><vh>computeCompletionList (autoCompleter)</vh></v>
<v t="ekr.20051126131103"><vh>doBackSpace</vh></v>
<v t="ekr.20051126123249.1"><vh>doTabCompletion (autoCompleter)</vh></v>
<v t="ekr.20051127065601"><vh>extendSelection</vh></v>
<v t="ekr.20051127105102"><vh>finish</vh></v>
<v t="ekr.20051127070018"><vh>setSelection</vh></v>
<v t="ekr.20051126124705"><vh>stateHandler (autoCompleter)</vh></v>
</v>
</v>
<v t="ekr.20060214110318.1"><vh>After autocompleter</vh>
<v t="ekr.20060209201859.1"><vh>Trap AttributeErrors in dummy base classes</vh></v>
<v t="ekr.20060122183544"><vh>Improve isearch</vh></v>
<v t="ekr.20060214072931"><vh>Improve unit testing</vh></v>
<v t="ekr.20060213094300"><vh>Fix problems with open with</vh>
<v t="ekr.20060213145539"><vh>The causes</vh></v>
<v t="ekr.20060213144352"><vh>Report</vh></v>
<v t="ekr.20031218072017.1315"><vh>idle time functions (leoGlobals)</vh>
<v t="EKR.20040602125018"><vh>enableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.1"><vh>disableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.2"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20031218072017.2823"><vh>openWith and allies</vh>
<v t="ekr.20031218072017.2824"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2825"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20031218072017.2826"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2827"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20031218072017.2828"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2829"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2830"><vh>createOpenWithTempFile</vh>
<v t="ekr.20031218072017.2831"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2832"><vh>c.openWithTempFilePath</vh></v>
</v>
</v>
<v t="ekr.20060211184834"><vh>Review all commands in leoEditCommands.py</vh>
<v t="ekr.20060122185244.2"><vh>Fix unindent command</vh></v>
</v>
<v t="ekr.20060213151918"><vh>Add baloons</vh>
<v t="ekr.20060212125650"><vh>createBalloon</vh></v>
</v>
<v t="ekr.20060116083043"><vh>Use special Help menu on the Mac</vh>
<v t="ekr.20031218072017.3803"><vh>createHelpMenuFromTable</vh></v>
<v t="ekr.20031218072017.4113"><vh>new_menu</vh></v>
<v t="ekr.20031218072017.3804"><vh>createNewMenu (contains Tk code)</vh></v>
<v t="ekr.20031218072017.3807"><vh>getMenu, setMenu, destroyMenu</vh></v>
<v t="ekr.20060211144330.1"><vh>getMacHelpMenu</vh></v>
</v>
<v t="ekr.20060211100150"><vh>Fix chapters plugin</vh></v>
<v t="ekr.20060122185507"><vh>New commands</vh>
<v t="ekr.20060210140415" a="E"><vh>Most important</vh>
<v t="ekr.20060211093935"><vh>Support for @list and on-enter-mode</vh></v>
<v t="ekr.20060113090042"><vh>open-outline-by-name &amp; filename completion</vh></v>
<v t="ekr.20060122194643"><vh>isearch-headline (forward &amp; backward)</vh></v>
<v t="ekr.20060116085649"><vh>find-word-on-line, find-character-on-line (forward &amp; backward)</vh></v>
<v t="ekr.20060206103922"><vh>Minibuffer interface for GoToLine number</vh></v>
<v t="ekr.20060116074839.2"><vh>extend-to-word</vh></v>
<v t="ekr.20060117115212"><vh>Rename buffer doesn't seem to work</vh></v>
<v t="ekr.20060123091352"><vh>Incremental search in switch-to-buffer</vh></v>
<v t="ekr.20060104083551"><vh>move-line-up/down (LeoUser)</vh></v>
<v t="ekr.20060116084526.1"><vh>insert/remove spaces/tabs from lines (LeoUser)</vh></v>
<v t="ekr.20060123095316"><vh>clear-selection</vh></v>
<v t="ekr.20051202095626"><vh>help-for-command</vh></v>
<v t="ekr.20060116090428"><vh>Expand 'point' so it indicates node as well as text location</vh></v>
<v t="ekr.20060214140221"><vh>update-settings-file command</vh></v>
</v>
<v t="ekr.20060210140415.1"><vh>Others</vh>
<v t="ekr.20060209105218.2"><vh>contract-all-except-present-tree</vh></v>
<v t="ekr.20060206114203"><vh>toggle-find-tab-views</vh></v>
<v t="ekr.20060206104205"><vh>Finish query-replace</vh></v>
<v t="ekr.20060109183500.1"><vh>execute-named-script</vh></v>
<v t="ekr.20060116074450"><vh>Drive tabs from keyboard</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
</v>
<v t="ekr.20060202231708.1"><vh>Use minibuffer names for all menu entries</vh></v>
<v t="ekr.20051121070552"><vh>Finish Cmds menu</vh>
<v t="ekr.20060117112444"><vh>What I did</vh></v>
<v t="ekr.20060117114903"><vh>Others</vh>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3753"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20050711091931"><vh>defineEditMenuEditCursorTable</vh></v>
<v t="ekr.20031218072017.3754"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20031218072017.3755"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3759"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20031218072017.3760"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20031218072017.3761"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20031218072017.3762"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20031218072017.3763"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20031218072017.3764"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20031218072017.3765"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20031218072017.3766"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20050921103230"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable (to do)</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060117095212.5"><vh>defineCmdsMenuCenterTable</vh></v>
<v t="ekr.20060117095212.4"><vh>defineCmdsMenuChangeCaseTable</vh></v>
<v t="ekr.20060117095212.6"><vh>defineCmdsMenuIndentTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable(to do)</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable(to do)</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable(to do)</vh></v>
<v t="ekr.20060117095212.3"><vh>defineCmdsMenuSortTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
</v>
<v t="ekr.20031218072017.3773"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20031218072017.3774"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20031218072017.3785"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20031218072017.3790"><vh>createFileMenuFromTable</vh>
<v t="ekr.20031218072017.3791"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3792"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3793"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3794"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3795"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3796"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3786"><vh>createEditMenuFromTable</vh>
<v t="ekr.20031218072017.3787"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3788"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3789"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3797"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20040711140738.1"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3798"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3799"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3800"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3801"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20031218072017.3802"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20031218072017.3803"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createCmndsMenuFromTable</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20060117123143"><vh>editing commands</vh></v>
<v t="ekr.20050921103230"><vh>defineCmdsMenuTables &amp; helpers</vh>
<v t="ekr.20060117094955"><vh> defineCmdsMenuTopTable</vh></v>
<v t="ekr.20060117094955.1"><vh>defineCmdsMenuAbbrevTable (to do)</vh></v>
<v t="ekr.20060117095212"><vh>defineCmdsMenuBufferTable</vh></v>
<v t="ekr.20060117095212.5"><vh>defineCmdsMenuCenterTable</vh></v>
<v t="ekr.20060117095212.4"><vh>defineCmdsMenuChangeCaseTable</vh></v>
<v t="ekr.20060117095212.6"><vh>defineCmdsMenuIndentTable</vh></v>
<v t="ekr.20060117114315"><vh>defineCmdsMenuMacroTable(to do)</vh></v>
<v t="ekr.20060117095212.2"><vh>defineCmdsMenuRectanglesTable(to do)</vh></v>
<v t="ekr.20060117095212.1"><vh>defineCmdsMenuRegistersTable(to do)</vh></v>
<v t="ekr.20060117095212.3"><vh>defineCmdsMenuSortTable</vh></v>
<v t="ekr.20060117095212.7"><vh>defineCmdsMenuSpellCheckTable</vh></v>
</v>
</v>
</v>
<v t="ekr.20060206104841"><vh>New features</vh>
<v t="ekr.20060116083043.1"><vh>Add context-menus on nodes or text</vh></v>
<v t="ekr.20060122184114"><vh>Support the exectution of a command when entering a mode</vh></v>
<v t="ekr.20060202235215.1"><vh>Make sure the user doesn't specify Enter and Leave bindings by mistake</vh></v>
<v t="ekr.20051112075511"><vh>Switch cursor when changing search direction</vh></v>
<v t="ekr.20060125113540"><vh>Specify open-with bindings from settings</vh></v>
<v t="ekr.20060203165231"><vh>Change outline or body text background when changing panes.</vh></v>
<v t="ekr.20060202141338.4"><vh>Add support for widget bindings</vh></v>
<v t="ekr.20060116085217"><vh>Make scroll-pane-up/down work in tree</vh></v>
<v t="ekr.20060206131908.1"><vh>set-first-search-node command (indicate it in the find tab)</vh></v>
</v>
<v t="ekr.20060116173818"><vh>*** Fix vampire nodes</vh></v>
</v>
<v t="ekr.20060122184800"><vh>Later</vh>
<v t="ekr.20060117074259"><vh>Handle Mac issues</vh>
<v t="ekr.20060117074259.1"><vh>Report</vh></v>
</v>
<v t="ekr.20060111152145"><vh>Improve scripts menu plugin</vh></v>
<v t="ekr.20060108120501"><vh>Add @find node to scripting plugin</vh></v>
<v t="ekr.20051202102337"><vh>Finish minibuffer commands</vh>
<v t="ekr.20051202102337.1"><vh>abbrevCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102337.2"><vh>bufferCommandsClass Inot ready yet)</vh></v>
<v t="ekr.20051202102337.3"><vh>controlCommandsClass (ok)</vh></v>
<v t="ekr.20051202102337.4"><vh>editCommandsClass</vh></v>
<v t="ekr.20051202102337.6"><vh>editFileCommandsClass</vh></v>
<v t="ekr.20051202102752.1"><vh>keyHandlerCommandsClass (not ready yet)</vh></v>
<v t="ekr.20051202102752.2"><vh>killBufferCommandsClass</vh></v>
<v t="ekr.20051202102752.3"><vh>macroCommandsClass</vh></v>
<v t="ekr.20051202102752.4"><vh>queryReplaceCommandsClass</vh></v>
<v t="ekr.20051202102752.5"><vh>rectangleCommandsClass (ok)</vh></v>
<v t="ekr.20051202102752.6"><vh>registerCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.7"><vh>searchCommandsClass (ok, but could be expanded)</vh></v>
<v t="ekr.20051202102752.8"><vh>spellCommandsClass (ok)</vh></v>
</v>
<v t="ekr.20050916180203"><vh>Make more commands undoable</vh></v>
<v t="ekr.20060202235215.3"><vh>Remove deprecation warning</vh>
<v t="EKR.20040627114602"><vh>getDescendentUnknownAttributes</vh></v>
</v>
<v t="ekr.20060207085518"><vh>Improve c.insertHeadline (minor)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20051022142249,"><vh>@thin leoEditCommands.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040602125018">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.</t>
<t tx="EKR.20040602125018.1"># Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False</t>
<t tx="EKR.20040602125018.2"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args &amp; keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None</t>
<t tx="EKR.20040627114602"># Only @thin vnodes have the descendentTnodeUnknownAttributes field.
# The question is: what are we to do about this?

def getDescendentUnknownAttributes (self,s):
    
    try:
        bin = binascii.unhexlify(s) # Throws a TypeError if val is not a hex string.
        val = pickle.loads(bin)
        return val

    except (TypeError,pickle.UnpicklingError,ImportError):
        g.trace('oops: getDescendentUnknownAttributes')
        return None</t>
<t tx="ekr.20031218072017.839">def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &amp;U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &amp;R reserved for Redo
        ("-",None),
        ("Cu&amp;t",f.OnCutFromMenu), 
        ("Cop&amp;y",f.OnCopyFromMenu),
        ("&amp;Paste",f.OnPasteFromMenu),
        ("&amp;Delete",c.editCommands.backwardDeleteCharacter),
        ("Select &amp;All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v</t>
<t tx="ekr.20031218072017.844">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20031218072017.845">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20031218072017.846">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20031218072017.998">def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20031218072017.1315"></t>
<t tx="ekr.20031218072017.1723">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('&lt;').rstrip('&gt;')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)</t>
<t tx="ekr.20031218072017.1725"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20031218072017.1801">def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    &lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</t>
<t tx="ekr.20031218072017.1802"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None</t>
<t tx="ekr.20031218072017.1974">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20031218072017.1975">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)</t>
<t tx="ekr.20031218072017.1976"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="ekr.20031218072017.2176">def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    # f.enableTclTraces()</t>
<t tx="ekr.20031218072017.2187">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20031218072017.2373">set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.2823">def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20031218072017.2824">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20031218072017.2825">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20031218072017.2826">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20031218072017.2827">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20031218072017.2828">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20031218072017.2829">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20031218072017.2830">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.2831">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20031218072017.2832">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3752">def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineCmdsMenuTables()

    self.defineHelpMenuTables()</t>
<t tx="ekr.20031218072017.3753">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()</t>
<t tx="ekr.20031218072017.3754">def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &amp;Section",c.extractSection),
        ("Extract &amp;Names",c.extractSectionNames),
        ("&amp;Extract",c.extract),
        ("-",None,None),
        ("Convert All B&amp;lanks",c.convertAllBlanks),
        ("Convert All T&amp;abs",c.convertAllTabs),
        ("Convert &amp;Blanks",c.convertBlanks),
        ("Convert &amp;Tabs",c.convertTabs),
        ("Insert Body Time/&amp;Date",c.insertBodyTime),
        ("&amp;Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&amp;Indent",c.indentBody),
        ("&amp;Unindent",c.dedentBody),
        ("&amp;Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u</t>
<t tx="ekr.20031218072017.3755">def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &amp;Headline",c.editHeadline),
        ("&amp;End Edit Headline",f.endEditLabelCommand),
        ("&amp;Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&amp;Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]</t>
<t tx="ekr.20031218072017.3756">def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    # Bind to the Find tab.
    sc = c.searchCommands
    self.editMenuFindMenuTable = [
        ("&amp;Show Find Tab",  sc.openFindTab),
        ("&amp;Hide Find Tab",  sc.hideFindTab),
        ("-",None),
        ("Find &amp;Next",          sc.findTabFindNext),
        ("Find &amp;Previous",      sc.findTabFindPrev),
        ("&amp;Replace",            sc.findTabChange),
        ("Replace, &amp;Then Find", sc.findTabChangeThenFind),
    ]</t>
<t tx="ekr.20031218072017.3757">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20031218072017.3758">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()</t>
<t tx="ekr.20031218072017.3759">def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&amp;New",c.new),
        ("&amp;Open...",c.open),
    ]</t>
<t tx="ekr.20031218072017.3760">def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&amp;Close",c.close),
        ("&amp;Save",c.save),
        ("Save &amp;As",c.saveAs),
        ("Save To",c.saveTo), # &amp;Tangle
        ("Re&amp;vert To Saved",c.revert), # &amp;Read/Write
    ]</t>
<t tx="ekr.20031218072017.3761">def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&amp;Read Outline Only",c.readOutlineOnly),
        ("Read @file &amp;Nodes",c.readAtFileNodes),
        ("-",None),
        ("Write &amp;Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &amp;Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &amp;Outline Only",fc.writeOutlineOnly),
        ("&amp;Write @file Nodes",fc.writeAtFileNodes),
    ]</t>
<t tx="ekr.20031218072017.3762">def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &amp;All",c.tangleAll),
        ("Tangle &amp;Marked",c.tangleMarked),
        ("&amp;Tangle",c.tangle),
    ]</t>
<t tx="ekr.20031218072017.3763">def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &amp;All",c.untangleAll),
        ("Untangle &amp;Marked",c.untangleMarked),
        ("&amp;Untangle",c.untangle),
    ]</t>
<t tx="ekr.20031218072017.3764">def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&amp;file",c.importAtFile),
        ("Import To @&amp;root",c.importAtRoot),
        ("Import &amp;CWEB Files",c.importCWEBFiles),
        ("Import &amp;noweb Files",c.importNowebFiles),
        ("Import Flattened &amp;Outline",c.importFlattenedOutline),
    ]</t>
<t tx="ekr.20031218072017.3765">def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &amp;Headlines",c.exportHeadlines),
        ("Outline To &amp;CWEB",c.outlineToCWEB),
        ("Outline To &amp;Noweb",c.outlineToNoweb),
        ("&amp;Flatten Outline",c.flattenOutline),
        ("&amp;Remove Sentinels",c.removeSentinels),
        ("&amp;Weave",c.weave),
    ]</t>
<t tx="ekr.20031218072017.3766">def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&amp;xit",g.app.onQuit),
    ]</t>
<t tx="ekr.20031218072017.3767">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()</t>
<t tx="ekr.20031218072017.3768">def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&amp;ut Node",c.cutOutline),
        ("C&amp;opy Node",c.copyOutline),
        ("&amp;Paste Node",c.pasteOutline),
        ("Pas&amp;te Node As Clone",c.pasteOutlineRetainingClones),
        ("&amp;Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&amp;Insert Node",c.insertHeadline),
        ("&amp;Clone Node",c.clone),
        ("Sort Childre&amp;n",c.sortChildren), # Conflicted with Hoist.
        ("&amp;Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&amp;Hoist",c.hoist),
        ("D&amp;e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x</t>
<t tx="ekr.20031218072017.3769">def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&amp;Contract All",c.contractAllHeadlines),
        ("Contract &amp;Node",c.contractNode),
        ("Contract &amp;Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&amp;rev Level",c.expandPrevLevel),
        ("Expand N&amp;ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &amp;1",c.expandLevel1),
        ("Expand To Level &amp;2",c.expandLevel2),
        ("Expand To Level &amp;3",c.expandLevel3),
        ("Expand To Level &amp;4",c.expandLevel4),
        ("Expand To Level &amp;5",c.expandLevel5),
        ("Expand To Level &amp;6",c.expandLevel6),
        ("Expand To Level &amp;7",c.expandLevel7),
        ("Expand To Level &amp;8",c.expandLevel8),
        ("-",None),
        ("Expand &amp;All",c.expandAllHeadlines),
        ("Expand N&amp;ode",c.expandNode),
    ]</t>
<t tx="ekr.20031218072017.3770">def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &amp;Down",c.moveOutlineDown),
        ("Move &amp;Left",c.moveOutlineLeft),
        ("Move &amp;Right",c.moveOutlineRight),
        ("Move &amp;Up",c.moveOutlineUp),
        ("-",None),
        ("&amp;Promote",c.promote),
        ("&amp;Demote",c.demote),
    ]</t>
<t tx="ekr.20031218072017.3771">def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&amp;Mark",c.markHeadline),
        ("Mark &amp;Subheads",c.markSubheads),
        ("Mark Changed &amp;Items",c.markChangedHeadlines),
        ("Mark Changed &amp;Roots",c.markChangedRoots),
        ("Mark &amp;Clones",c.markClones),
        ("&amp;Unmark All",c.unmarkAll),
    ]</t>
<t tx="ekr.20031218072017.3772">def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]</t>
<t tx="ekr.20031218072017.3773">def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&amp;Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &amp;Active Pane",f.toggleActivePane),
        ("Toggle &amp;Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&amp;de",f.cascade),
        ("&amp;Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &amp;Compare Window",c.openCompareWindow),
        ("Open &amp;Python Window",c.openPythonWindow),
    ]</t>
<t tx="ekr.20031218072017.3774">def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&amp;About Leo...",c.about),
        ("Online &amp;Home Page",c.leoHome),
        ("Open Online &amp;Tutorial",c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &amp;Offline Tutorial",f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&amp;Docs.leo",c.leoDocumentation),
        ("Open Leo&amp;Plugins.leo",c.openLeoPlugins),
        ("Open Leo&amp;Settings.leo",c.openLeoSettings),
    ]</t>
<t tx="ekr.20031218072017.3785">def createMenusFromTables (self):
    
    c = self.c
    
    self.defineMenuTables()
    
    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()
    
    g.doHook("create-optional-menus",c=c)
    
    if self.useCmdMenu:
        self.createCmndsMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()</t>
<t tx="ekr.20031218072017.3786">def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&amp;Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    &lt;&lt; create the edit body submenu &gt;&gt;
    &lt;&lt; create the edit headline submenu &gt;&gt;
    &lt;&lt; create the find submenu &gt;&gt;
    
    self.createMenuEntries(editMenu,self.editMenuTop2Table)</t>
<t tx="ekr.20031218072017.3787">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)</t>
<t tx="ekr.20031218072017.3788">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)</t>
<t tx="ekr.20031218072017.3789">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)</t>
<t tx="ekr.20031218072017.3790">def createFileMenuFromTable (self):
    
    c = self.c
    fileMenu = self.createNewMenu("&amp;File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &amp;With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    &lt;&lt; create the recent files submenu &gt;&gt;
    self.add_separator(fileMenu)
    &lt;&lt; create the read/write submenu &gt;&gt;
    &lt;&lt; create the tangle submenu &gt;&gt;
    &lt;&lt; create the untangle submenu &gt;&gt;
    &lt;&lt; create the import submenu &gt;&gt;
    &lt;&lt; create the export submenu &gt;&gt;
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)</t>
<t tx="ekr.20031218072017.3791">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()</t>
<t tx="ekr.20031218072017.3792">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)</t>
<t tx="ekr.20031218072017.3793">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)</t>
<t tx="ekr.20031218072017.3794">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)</t>
<t tx="ekr.20031218072017.3795">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)</t>
<t tx="ekr.20031218072017.3796">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)</t>
<t tx="ekr.20031218072017.3797">def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&amp;Outline")
    
    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)
    
    &lt;&lt; create check submenu &gt;&gt;
    &lt;&lt; create expand/contract submenu &gt;&gt;
    &lt;&lt; create move submenu &gt;&gt;
    &lt;&lt; create mark submenu &gt;&gt;
    &lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="ekr.20031218072017.3798">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)</t>
<t tx="ekr.20031218072017.3799">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)</t>
<t tx="ekr.20031218072017.3800">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)</t>
<t tx="ekr.20031218072017.3801">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)</t>
<t tx="ekr.20031218072017.3802">def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&amp;Window")
    
    self.createMenuEntries(windowMenu,self.windowMenuTopTable)</t>
<t tx="ekr.20031218072017.3803">def createHelpMenuFromTable (self):

    if sys.platform == 'darwin':
        helpMenu = self.getMacHelpMenu()
        if not helpMenu: return
    else:
        helpMenu = self.createNewMenu("&amp;Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTopTable)
    
    if sys.platform=="win32":
        self.createMenuEntries(helpMenu,self.helpMenuTop2Table)
    
    self.createMenuEntries(helpMenu,self.helpMenuTop3Table)</t>
<t tx="ekr.20031218072017.3804">def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&amp;")
            label = label.replace("&amp;","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&amp;")
                index_label = index_label.replace("&amp;","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.3807">def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3941"></t>
<t tx="ekr.20031218072017.3942">def __repr__ (self):

    return "&lt;leoTkinterFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20031218072017.3944">def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas</t>
<t tx="ekr.20031218072017.3946">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        &lt;&lt; resize the Pmw panes &gt;&gt;
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20031218072017.3947">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="ekr.20031218072017.3949"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="ekr.20031218072017.3950"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20031218072017.3951">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="ekr.20031218072017.3952">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="ekr.20031218072017.3964"></t>
<t tx="ekr.20031218072017.3965">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()</t>
<t tx="ekr.20031218072017.4059"></t>
<t tx="ekr.20031218072017.4060"></t>
<t tx="ekr.20031218072017.4061"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4062">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4063"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20031218072017.4064"></t>
<t tx="ekr.20031218072017.4065">def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()</t>
<t tx="ekr.20031218072017.4066"></t>
<t tx="ekr.20031218072017.4067"></t>
<t tx="ekr.20031218072017.4068">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20031218072017.4069">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)

if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20031218072017.4070"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20031218072017.4071"></t>
<t tx="ekr.20031218072017.4072">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4073">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4074"></t>
<t tx="ekr.20031218072017.4075">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20031218072017.4076">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20031218072017.4077">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20031218072017.4078">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20031218072017.4079">def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False</t>
<t tx="ekr.20031218072017.4080">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20031218072017.4081"></t>
<t tx="ekr.20031218072017.4082">def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'</t>
<t tx="ekr.20031218072017.4083">def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass</t>
<t tx="ekr.20031218072017.4084"></t>
<t tx="ekr.20031218072017.4085">def getSelectionRange (self,t):
    
    try:
        # Warning: this can return None.
        return t.tag_ranges("sel")
    except Exception:
        return 0,0</t>
<t tx="ekr.20031218072017.4086">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20031218072017.4088">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20031218072017.4089">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, "&gt;", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20031218072017.4090"></t>
<t tx="ekr.20031218072017.4091">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4092">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4093">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4094">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4095">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4096">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20031218072017.4097"></t>
<t tx="ekr.20031218072017.4098">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20031218072017.4113">def new_menu(self,parent,tearoff=False):
    
    """Wrapper for the Tkinter new_menu menu method."""

    return Tk.Menu(parent,tearoff=tearoff)</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self,command,name,minibufferCommand):
    
    if minibufferCommand:
        
        # Create a dummy event as a signal to doCommand.
        event = g.Bunch(keysym='',char='',widget='')
        
        # The first parameter must be event, and it must default to None.
        def minibufferMenuCallback(event=event,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label,event)
    
        return minibufferMenuCallback
        
    else:
    
        # The first parameter must be event, and it must default to None.
        def legacyMenuCallback(event=None,self=self,command=command,label=name):
            __pychecker__ = '--no-argsused' # event not used, and must be present.
            
            c = self.c
            return c.doCommand(command,label)
    
        return legacyMenuCallback</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 beta 2, build %s, February 14, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.414 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040709081208"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)</t>
<t tx="ekr.20040711140738">def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &amp;Outline",c.checkOutline),
        ("&amp;Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &amp;All Python Code",c.checkAllPythonCode),
        ("&amp;Check Python &amp;Code",c.checkPythonCode),
        ("-",None),
        ("Pretty P&amp;rint All Python Code",c.prettyPrintAllPythonCode),
        ("&amp;Pretty Print Python Code",c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r</t>
<t tx="ekr.20040711140738.1">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)</t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041221071131">def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas</t>
<t tx="ekr.20041221071131.1">def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 0:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20041221073427">def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame</t>
<t tx="ekr.20041221073427.1">def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2</t>
<t tx="ekr.20041221075743">@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)</t>
<t tx="ekr.20041221122440">def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()</t>
<t tx="ekr.20041221123325">def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        &lt;&lt; create Pmw splitters and their components &gt;&gt;
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="ekr.20041221185246">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.</t>
<t tx="ekr.20041221195402"></t>
<t tx="ekr.20041223130032"># Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20050104084531">self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))</t>
<t tx="ekr.20050119210541"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050711091931">def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050916180203"></t>
<t tx="ekr.20050920085536.1"></t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None
    
    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and stroke == k.abortAllModesKey: # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20050921103230">def defineCmdsMenuTables (self):
    
    self.defineCmdsMenuTopTable()
    self.defineCmdsMenuAbbrevTable()
    self.defineCmdsMenuBuffersTable()
    self.defineCmdsMenuCenterTable()
    self.defineCmdsMenuChangeCaseTable()
    self.defineCmdsMenuIndentTable()
    self.defineCmdsMenuMacroTable()
    self.defineCmdsMenuRectanglesTable()
    self.defineCmdsMenuRegistersTable()
    self.defineCmdsMenuSortTable()
    self.defineCmdsMenuSpellCheckTable()
</t>
<t tx="ekr.20050921103736">def createCmndsMenuFromTable (self):
    
    cmdsMenu = self.createNewMenu('C&amp;mds')
    self.createMenuEntries(cmdsMenu,self.cmdsMenuTopTable)

    for name,table,sep in (
        ('Abbrev...',       self.cmdsMenuAbbrevTable,       False),
        ('Buffers...',      self.cmdsMenuBuffersTable,      False),
        ('Center...',       self.cmdsMenuCenterTable,       False),
        ('Change Case...',  self.cmdsMenuChangeCaseTable,   False),
        ('Indent...',       self.cmdsMenuIndentTable,       False),
        ('Macro...',        self.cmdsMenuMacroTable,        False),
        ('Rectangles...',   self.cmdsMenuRectanglesTable,   False),
        ('Registers...',    self.cmdsMenuRegistersTable,    False),
        ('Sort...',         self.cmdsMenuSortTable,         False),
        ('Spell Check...',  self.cmdsMenuSpellCheckTable,   False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20050923213858">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())</t>
<t tx="ekr.20051009044751">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
        f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)
        f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
        f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)</t>
<t tx="ekr.20051009044920"># Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()</t>
<t tx="ekr.20051009045208">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()</t>
<t tx="ekr.20051009045300"># Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)</t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051021091958">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20051025144611"></t>
<t tx="ekr.20051025144611.1">@nocolor</t>
<t tx="ekr.20051025144611.2">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="ekr.20051025144611.3">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="ekr.20051025144611.4">&lt;&lt; docstring &gt;&gt;
&lt;&lt;imports&gt;&gt;
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;

#These two global determine if the autocompleter and calltip systems are used.  Default is on.
useauto = 1
usecall = 1

&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others</t>
<t tx="ekr.20051025144611.5">'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''</t>
<t tx="ekr.20051025144611.6">## import leoTkinterFrame 

import sets 
import threading
import weakref</t>
<t tx="ekr.20051025144611.7">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.</t>
<t tx="ekr.20051025144611.8">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="ekr.20051025144611.10">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information

context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode</t>
<t tx="ekr.20051025144611.11">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.</t>
<t tx="ekr.20051025144611.12">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20051025144611.13">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
</t>
<t tx="ekr.20051025144611.14"># This section defines patterns for calltips.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats ['python'] = re.compile(r'def\s+%s' % end)

pats ['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
        space, space, end))

pats ['perl'] = re.compile(r'sub\s+%s' % end)

pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (space,end))

pats ['c'] = re.compile(r'\w+%s%s' % (space,end))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits + string.letters + r

ripout = string.punctuation + string.whitespace + '\n'
ripout = ripout.replace('_','')

okchars = {}
for z in string.ascii_letters:
    okchars [z] = z
okchars ['_'] = '_'</t>
<t tx="ekr.20051025144611.15">def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20051025144611.16">watchitems = ('.',')')
txt_template = '%s%s%s'

def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.
    Certain chars activate the text scanning code.'''
    global lang
    if not (event.char.isspace() or event.char in watchitems):
        return
        
@
This if statement ensures that attributes set in another node are put in the
database.Of course the user has to type a whitespace to make sure it happens.
We try to be selective so that we dont burn through the scanText def for  every
whitespace char entered.This will help when the nodes become big.
@c
    bCtrl = event.widget
    if event.char.isspace():
        # Do nothing if the previous char was a whitespace
        if bCtrl.get('insert -1c').isspace(): return
        if bCtrl.get('insert -1c wordstart -1c') != '.': return
    c = bCtrl.commander
    lang = c.frame.body.getColorizer().language
    txt = txt_template % (
        bCtrl.get("1.0",'insert'),
        event.char, bCtrl.get('insert',"end"))
        # Add the newest char; its not in the bCtrl yet
    scanText(txt)</t>
<t tx="ekr.20051025144611.17">def scanText (txt):

    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)</t>
<t tx="ekr.20051025144611.18">def scanForAutoCompleter (txt):
    
    '''This function scans text for the autocompleter database.'''

    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b )
            # we are using the experimental DictSet class here.
            # usage removed the above statements
            # notice we have cut it down to one line of code here!</t>
<t tx="ekr.20051025144611.19">def scanForCallTip (txt):

    '''this function scans text for calltip info'''

    # pat2 = pats['python']
    # if lang:
        # if pats.has_key(lang):
            # pat2 = pats[lang]

    pat2 = pats.get(lang or 'python')
    g2 = pat2.findall(txt) or []

    for z in g2:
        if isinstance(z,tuple):
            z = z [0]
        pieces2 = z.split('(')
        pieces2 [0] = pieces2 [0].split() [ -1]
        a, b = pieces2 [0], pieces2 [1]
        calltips [lang][a].add(z)</t>
<t tx="ekr.20051025144611.20">def makeAutocompletionList (a,b,glist):
    
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 

</t>
<t tx="ekr.20051025144611.21">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20051025144611.22">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20051025144611.23">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
</t>
<t tx="ekr.20051025144611.24">#These functions determine if the config and language files have been read or not.
# No need to read it more than once.

def hasReadConfig():
    return configfilesread

def setReadConfig():
    global configfilesread
    configfilesread = True</t>
<t tx="ekr.20051025144611.25">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20051025144611.26">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="ekr.20051025144611.27">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20051025144611.28">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20051025144611.29">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20051025144611.30">def unbind (context):

    '''This method turns everything off and removes the calltip and autobox from the canvas.'''

    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map(context.unbind,(
            "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;", "&lt;Alt_R&gt;"))
        context.unbind_all('&lt;Button&gt;')
        context.update_idletasks()</t>
<t tx="ekr.20051025144611.31">def moveSelItem (event, context ):

    '''Move the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1  ## Can't be correct.
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:
        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="ekr.20051025144611.32">def processKeyStroke (event,context,body):

    '''Take action based on the state of context (a Tk.Canvas) and the event'''
    
    autobox = context.autobox

    if not context.on or event.keysym in ("??","Shift_L","Shift_R"):
        return None
    elif testForUnbind(event,context):
        unbind(context)
        return None
    elif context.which == 1:
        return None # It is calltip time.
        
    index = body.index('insert-1c wordstart')
    pat = body.get(index,'insert') + event.char
    pat = pat.lstrip('.')
    ww = list(autobox.get(0,'end'))
    aList = reducer(ww,pat)
    if not aList: return None
    # Select which item to select based on what the user has typed.
    i = ww.index(aList[0])
    # Set the current selection to match what the user has typed.
    autobox.select_clear(0,'end') 
    autobox.select_set(i)
    autobox.see(i)
    return 'break'</t>
<t tx="ekr.20051025144611.33">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="ekr.20051025144611.34">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20051025144611.35">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="ekr.20051025144611.36">def add_bindings( context, body ):
    
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''

    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )</t>
<t tx="ekr.20051025144611.37">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20051025144611.38">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20051025144611.39">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20051025144611.40">def newCreateControl (self,frame,parentFrame):
    '''A decoration of the createControl def.
    We set up the ancestory of the control so we can draw
    widgets over the Text editor without disturbing the text.'''

@
Creating the background:
- We now use a placer: simpler to use and more efficient.
- We have to decorate the Tk.Text widget with a constructor that creates an
  intermediate Frame for the Text to be placed instead of packed.
  Had no idea that the placer could do this so nicely.
  With a couple changes in 3 places, we are using the placer !
@c
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init (self,master,*args,**kwords):

        context = Tk.Frame(master)
            #This is what we need to put in before the text to make place work.
        orig_init(self,context,*args,**kwords)

    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame,parentFrame) #orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init

    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack(expand=1,fill='both',after=frame.bodyBar) #We have to add it to the environment, since we pass on it in the __init__
    body.place(relwidth=1.0,relheight=1.0)
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets(context)
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler (event,context=context,body=body):
        processKeyStroke(event,context,body)
    def addItemHandler (event,context=context,body=body,colorizer=frame.body):
        add_item(event,context,body,colorizer.getColorizer())

    for z in (watcher,processKeyStrokeHandler,addItemHandler):
        context.bind("&lt;Key&gt;",z,'+')

    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr(context,'autobox'):
        ignore.append(context.autobox.component('listbox'))
        ignore.append(context.autobox.component('vertscrollbar'))
    def do_unbind (event):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind(context)

    context.do_unbind = do_unbind

    # This part protects this plugin from others that use Alt-Up, Alt-Down.
    # The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt (event):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ('&lt;Alt-Up&gt;','&lt;Alt-Down&gt;'): context.block_alt.bind(z,block_alt)

    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append(context.bindtags()[0])
    ctags.append(context.block_alt.bindtags()[0])
    ctags.extend(body.bindtags())
    body.bindtags(tuple(ctags))

    return body</t>
<t tx="ekr.20051025144611.41">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []

    if useauto:
        context.autobox = Pmw.ScrolledListBox(
            context ,hscrollmode='none',
            listbox_selectbackground='#FFE7C6',
            listbox_selectforeground='blue',
            listbox_background='white',
            listbox_foreground='blue',
            vertscrollbar_background='#FFE7C6',
            vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):
        #This def makes removing the autobox or calltip label easy.
        # No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()

    context.clean_editor = clean_editor</t>
<t tx="ekr.20051025144611.42">def onOpenWindow ():

    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="ekr.20051025170832"></t>
<t tx="ekr.20051025170832.1"></t>
<t tx="ekr.20051026083544">def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051112075511">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3424153
By: rogererens

When reversing the search direction, it would be better to place the cursor
'on the other side' of the current hit, and then proceed to find the next occurrence
of &lt;pattern&gt;. At the current state of affairs, searching in the reverse direction
first finds the current occurrence _again_, just placing the cursor on the other
side of the higlighted selection.

This suggestion is based on the way searching in Vim works.</t>
<t tx="ekr.20051121070552"></t>
<t tx="ekr.20051121092320">def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)</t>
<t tx="ekr.20051126122638">- Use typing completion to select desired word.
- No auto-scan: use database instead.
- Scan button does manual scan.
- Use import or inspect instead of text scan.
- @strings autocompleter-info
list of names for which classes are known: c,frame,g,k,p,t,tree,v etc.
  (Autocompleter may already do this)
</t>
<t tx="ekr.20051126122952.1">def autoComplete (self,event):

    c = self.c ; k = self.k ; gui = g.app.gui
    self.widget = w = event and event.widget 
    self.prefix = gui.getSelectedText(w) or ''
    self.text = gui.getAllText(w)

    c.frame.log.clearTab('Completion') # Creates the tab if necessary.
    self.membersList = c.commandsDict.keys() ## Testing only.
    k.setState('auto-completer',1,handler=self.stateHandler)
    self.computeCompletionList()</t>
<t tx="ekr.20051126123149">def computeCompletionList (self):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    if s:
        self.tabList,common_prefix = g.itemsMatchingPrefixInList(s,self.membersList)
        c.frame.log.clearTab('Completion') # Creates the tab if necessary.
        if self.tabList:
            self.tabListIndex = -1 # The next item will be item 0.
            self.setSelection(common_prefix)
        for name in self.tabList:
            g.es('%s' % (name),tabName='Completion')</t>
<t tx="ekr.20051126123249">class autoCompleterCommandsClass (baseEditCommandsClass):
    
    '''Similar to typing completion in the minibuffer,
    but the presently selected completion is shown in the widget itself.'''

    @others</t>
<t tx="ekr.20051126123249.1">def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.bodyWantsFocus()</t>
<t tx="ekr.20051126123759"></t>
<t tx="ekr.20051126123759.1">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.c = c
    self.k = c.k
    self.membersList = None
    self.prefix = None
    self.tabList = []
    self.tabListIndex = -1
    self.text = None # For Escape.
    self.widget = None</t>
<t tx="ekr.20051126123759.2">def getPublicCommands (self):

    k = self.k

    return {
        'auto-complete':    self.autoComplete,
    }</t>
<t tx="ekr.20051126124705">def stateHandler (self,event):
    
    c = self.c ; k = self.k ; gui = g.app.gui ; w = self.widget
    keysym = event and event.keysym
    ch = event and event.char or ''
    # g.trace(repr(ch),repr(keysym))
    if keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.finish()
    elif keysym == 'Escape':
        c.frame.log.deleteTab('Completion')
        k.clearState()
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif ch in string.printable:
        self.extendSelection(ch)
        s = gui.getSelectedText(w)
        if s.startswith(self.prefix):
            self.prefix = self.prefix + ch
            # g.trace('prefix',self.prefix)
        self.computeCompletionList()</t>
<t tx="ekr.20051126125950">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""</t>
<t tx="ekr.20051126131103">def doBackSpace (self):

    '''Cut back to previous prefix.'''

    self.prefix = self.prefix[:-1]
    self.setSelection(self.prefix)
    self.computeCompletionList()</t>
<t tx="ekr.20051126171929">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20051127065601">def extendSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
    else:
        i = j = gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127070018">def setSelection (self,s):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    if gui.hasSelection(w):
        i,j = gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = gui.getInsertPoint(w)
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    gui.setSelectionRange(w,i,j)</t>
<t tx="ekr.20051127105102">def finish (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    c.widgetWantsFocus(w)
    
    i,j = gui.getTextSelection(w)
    if i != j:
        gui.setTextSelection(w,j,j)</t>
<t tx="ekr.20051127105431">def abort (self):
    
    c = self.c ; w = self.widget ; gui = g.app.gui
    
    c.widgetWantsFocus(w)

    w.delete('1.0','end')
    w.insert('1.0',self.text)
    gui.setTextSelection(w,'1.0','1.0')</t>
<t tx="ekr.20051202095626">Use docstrings as the help message.</t>
<t tx="ekr.20051202102337">@nocolor</t>
<t tx="ekr.20051202102337.1">auto-complete command is merely a prototype.</t>
<t tx="ekr.20051202102337.2">ok:

list-buffers

Not ready yet:

append-to-buffer
copy-to-buffer
insert-to-buffer
kill-buffer
prepend-to-buffer
rename-buffer       probably should change headline too
switch-to-buffer    use typing completion to get node name (headline)</t>
<t tx="ekr.20051202102337.3">advertised-undo
keyboard-quit
iconify-frame
save-buffers-kill-leo
shell-command
shell-command-on-region
suspend</t>
<t tx="ekr.20051202102337.4">back-sentence
back-to-indentation
backward-char
backward-delete-char
backward-kill-paragraph
backward-paragraph
backward-word
beginning-of-buffer
beginning-of-line
capitalize-word
center-line
center-region
count-region
cycle-focus
dabbrev-completion
dabbrev-expands
delete-char
delete-indentation
delete-spaces
downcase-region
downcase-word
end-of-buffer
end-of-line
escape
eval-expression
exchange-point-mark
fill-paragraph
fill-region
fill-region-as-paragraph
flush-lines
focus-to-body
focus-to-log
focus-to-minibuffer
focus-to-tree
forward-char
forward-paragraph
forward-sentence
forward-word
goto-char
goto-line
how-many
# Use indentBody in leoCommands.py
#indent-region
indent-relative
indent-rigidly
indent-to-comment-column
insert-newline
insert-parentheses
keep-lines
kill-paragraph
line-number
move-past-close
newline-and-indent
next-line
previous-line
remove-blank-lines
replace-regex
replace-string
reverse-region
scroll-down
scroll-up
select-paragraph
# Exists, but can not be executed via the minibuffer.
# self-insert-command
set-comment-column
set-fill-column
set-fill-prefix
set-mark-command
show-colors
show-fonts
# save-buffer
sort-columns
sort-fields
sort-lines
split-line
tabify
transpose-chars
transpose-lines
transpose-words
untabify
upcase-region
upcase-word
view-lossage
what-line</t>
<t tx="ekr.20051202102337.6">delete-file
diff
insert-file
make-directory
remove-directory
save-file</t>
<t tx="ekr.20051202102752.1">digit-argument
help
hide-mini-buffer
negative-argument
number-command
number-command-0
number-command-1
number-command-2
number-command-3
number-command-4
number-command-5
number-command-6
number-command-7
number-command-8
number-command-9
print-bindings
print-commands
repeat-complex-command
show-mini-buffer
toggle-mini-buffer
universal-argument</t>
<t tx="ekr.20051202102752.2">backward-kill-sentence
backward-kill-word
kill-line
kill-word
kill-sentence
kill-region
kill-region-save
yank
yank-pop
zap-to-character</t>
<t tx="ekr.20051202102752.3">call-last-keyboard-macro
end-kbd-macro
name-last-kbd-macro
load-file
insert-keyboard-macro 
start-kbd-macro</t>
<t tx="ekr.20051202102752.4">query-replace
query-replace-regex</t>
<t tx="ekr.20051202102752.5">clear-rectangle
close-rectangle
delete-rectangle
kill-rectangle
open-rectangle
string-rectangle
yank-rectangle</t>
<t tx="ekr.20051202102752.6">append-to-register
copy-rectangle-to-register
copy-to-register
increment-register
insert-register
jump-to-register
number-to-register not used: used copy-to-register insead.
point-to-register
prepend-to-register
view-register

To do:

point-to-register should write an 'expanded point' so inter-node jumps are possible.</t>
<t tx="ekr.20051202102752.7">hide-find-tab
open-find-tab
find-tab-find
find-tab-find-prev
find-tab-change
find-tab-change-then-find

isearch-forward
isearch-backward
isearch-forward-regexp
isearch-backward-regexp

re-search-forward
re-search-backward

search-forward
search-backward
word-search-forward
word-search-backward</t>
<t tx="ekr.20051202102752.8">ok:

hide-spell-tab
open-spell-tab
spell-find
spell-change
spell-change-then-find
spell-ignore</t>
<t tx="ekr.20051205093049">@nocolor

Working throught the IronPython tutorial just now I saw how useful the dir function could be, especially dir(object)

I'm thinking that Leo might use dir(object) to discover members for the auto-complete command.  It's not clear if or how this can be made to work, but it might be slick.</t>
<t tx="ekr.20051220144507">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20060104083551">http://sourceforge.net/forum/message.php?msg_id=3488030

move-region-up

Swap the selection with the line above it. If we are at the top of a node, the
node identified by threadBack() is selected and the text is moved to the bottom
of the node.

move-region-down

Swap the selection with the line below it. If we are at the bottom of the node,
the node identified by threadNext() is selected and the text is moved to the top
of the node.

In all cases the moved text remains selected, even when the text moves to another node.</t>
<t tx="ekr.20060108120501">This is the easy way to do script finds!</t>
<t tx="ekr.20060109183500.1">execute-named-script executes script in leo/scripts.</t>
<t tx="ekr.20060111152145">- Organize scripts menu from subfolders of leo/scripts folder.

- Create minibuffer commands for each script?</t>
<t tx="ekr.20060113090042"></t>
<t tx="ekr.20060115195302">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20060116073938"></t>
<t tx="ekr.20060116074450">- create-tab
- clear-tab
- delete-tab
- hide-tab
- show-tab, show-log

These might get the tab name from the minibuffer...</t>
<t tx="ekr.20060116074839.2"></t>
<t tx="ekr.20060116083043"># http://sourceforge.net/forum/message.php?msg_id=3237845</t>
<t tx="ekr.20060116083043.1"></t>
<t tx="ekr.20060116084526.1">http://sourceforge.net/forum/message.php?msg_id=3488030

add-space-to-lines      Adds a space is added to start of all selected lines.

add-tab-to-line         Adds 4 spaces to start of all selected lines.

remove-space-from lines Removes a space from start of all selected lines.

remove-tab-from lines   Removes a space from start of all selected lines.</t>
<t tx="ekr.20060116085217">@nocolor

The following commands already work in the body pane.

scroll-down
scroll-down-extend-selection  
scroll-up
scroll-up-extend-selection

Note: arrow keys scroll the outline as needed, so there *is* a way to scroll the outline without the UniversalScrolling plugin.</t>
<t tx="ekr.20060116085649"></t>
<t tx="ekr.20060116090428"></t>
<t tx="ekr.20060116173818"></t>
<t tx="ekr.20060117074259"></t>
<t tx="ekr.20060117074259.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3526056
By: nobody

Hi Edward. I've been using the linux and windows version but would like to try
leo on the mac. The install instructions seem a bit out of date. I take it any
additional downloading of TclTkAqua is unneccessary?

I have python2.4 in addition to the stock python 2.3.5 that comes with osx 10.4.
Launching leo like so:  "python2.4 leo.py", as I do on linux, seems to run just
fine.

I don't know if this was fixed on osx or in leo in general, but moving the mouse
to each of the panes and scrolling with the wheel works just great now. Thanks.

Plugin manager: the plugin text font is really tiny, and the window opens to
a default width such that the 'Installed Plugins' button reads 'talled Plugi'.
Resizing the window does stretch the buttons horizontally.

Ok -- here's maybe a big issue. I open a new leo file (File-&gt;New) and type in:

for i in range(3):

I hit return after the colon, but a newline is not entered.

Stephen
</t>
<t tx="ekr.20060117094955">def defineCmdsMenuTopTable (self):
    
    self.cmdsMenuTopTable = [
        ('Repeat Last Complex Command','repeat-complex-command'),
        ('Execute Named Command','full-command'),
        ("-",None),
    ]
</t>
<t tx="ekr.20060117094955.1">def defineCmdsMenuAbbrevTable (self):
    
    c = self.c
    
    self.cmdsMenuAbbrevTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117095212">def defineCmdsMenuBuffersTable (self):

    self.cmdsMenuBuffersTable = [
        ('Append To Buffer',             'append-to-buffer'),
        ('Kill Buffer',                  'kill-buffer'),
        ('List Buffers',                 'list-buffers'),
        ('List Buffers Alphbetically',   'list-buffers-alphabetically'),
        ('Prepend To Buffer',            'prepend-to-buffer'),
        ('Rename Buffer',                'rename-buffer'),
        ('Switch To Buffer',             'switch-to-buffer'),
    ]</t>
<t tx="ekr.20060117095212.1">def defineCmdsMenuRegistersTable (self):

    c = self.c

    self.cmdsMenuRegistersTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117095212.2">def defineCmdsMenuRectanglesTable (self):

    c = self.c

    self.cmdsMenuRectanglesTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117095212.3">def defineCmdsMenuSortTable (self):

    c = self.c

    self.cmdsMenuSortTable = [
        ('Sort Columns',    'sort-columns'),
        ('Sort Fields',     'sort-fields'),
        ('Sort Lines',      'sort-lines'),
    ]</t>
<t tx="ekr.20060117095212.4">def defineCmdsMenuChangeCaseTable (self):

    c = self.c

    self.cmdsMenuChangeCaseTable = [
        ('Capitalize Word', 'capitalize-word'),
        ('Downcase Region', 'downcase-region'),
        ('Downcase Word',   'downcase-word'),
        ('Upcase Region',   'upcase-region'), # Crashes.
        ('Upcase Word',     'upcase-word'),
    ]
    </t>
<t tx="ekr.20060117095212.5">def defineCmdsMenuCenterTable (self):

    c = self.c

    self.cmdsMenuCenterTable = [
        ('Center Line',     'center-line'),
        ('Center Region',   'center-region'),
    ]</t>
<t tx="ekr.20060117095212.6">def defineCmdsMenuIndentTable (self):

    c = self.c

    self.cmdsMenuIndentTable = [
        ('Indent Region',   'indent-region'),
        ('Indent Relative', 'indent-relative'),
        ('Indent Rigidly',  'indent-rigidly'),
        ('Unindent Region', 'unindent-region'),
    ]</t>
<t tx="ekr.20060117095212.7">def defineCmdsMenuSpellCheckTable (self):

    c = self.c

    self.cmdsMenuSpellCheckTable = [
        ('Check Spelling',      'open-spell-tab'),
        ('Change',              'spell-change'),
        ('Change, Then Find',   'spell-change-then-find'),
        ('Find',                'spell-find'),
        ('Ignore',              'spell-ignore'),
    ]</t>
<t tx="ekr.20060117112444">@nocolor

- Call menu.defineMenuTables from menu.createMenusFromTables.
  This ensures the keyHandler class has been created.

- Added support for using minibuffer command names instead of command in menu
tables. This is a signal that the command is a new-style minibuffer command
rather than a legacy command. This required minor changes in createMenu entries
and defineMenuCallback.</t>
<t tx="ekr.20060117114315">def defineCmdsMenuMacroTable (self):

    c = self.c

    self.cmdsMenuMacroTable = [
        ("-",None),
    ]</t>
<t tx="ekr.20060117114903"></t>
<t tx="ekr.20060117115212"></t>
<t tx="ekr.20060117123143">        'back-to-indentation':                  self.backToIndentation,
        'back-char':                            self.backCharacter,
        'back-char-extend-selection':           self.backCharacterExtendSelection,
        'back-paragraph':                       self.backwardParagraph,
        'back-paragraph-extend-selection':      self.backwardParagraphExtendSelection,
        'back-sentence':                        self.backSentence,
        'back-sentence-extend-selection':       self.backSentenceExtendSelection,
        'back-word':                            self.backwardWord,
        'back-word-extend-selection':           self.backwardWordExtendSelection,
        'backward-delete-char':                 self.backwardDeleteCharacter,
        'backward-kill-paragraph':              self.backwardKillParagraph,
        'beginning-of-buffer':                  self.beginningOfBuffer,
        'beginning-of-buffer-extend-selection': self.beginningOfBufferExtendSelection,
        'beginning-of-line':                    self.beginningOfLine,
        'beginning-of-line-extend-selection':   self.beginningOfLineExtendSelection,
       
        'clear-extend-mode':                    self.clearExtendMode,
        'count-region':                         self.countRegion,
        'cycle-focus':                          self.cycleFocus,
        'dabbrev-completion':                   self.dynamicExpansion2,
        'dabbrev-expands':                      self.dynamicExpansion,
        'delete-char':                          self.deleteNextChar,
        'delete-indentation':                   self.deleteIndentation,
        'delete-spaces':                        self.deleteSpaces,
        'downcase-region':                      self.downCaseRegion,
        'downcase-word':                        self.downCaseWord,
        'end-of-buffer':                        self.endOfBuffer,
        'end-of-buffer-extend-selection':       self.endOfBufferExtendSelection,
        'end-of-line':                          self.endOfLine,
        'end-of-line-extend-selection':         self.endOfLineExtendSelection,
        'escape':                               self.watchEscape,
        'eval-expression':                      self.evalExpression,
        'exchange-point-mark':                  self.exchangePointMark,
        'fill-paragraph':                       self.fillParagraph,
        'fill-region':                          self.fillRegion,
        'fill-region-as-paragraph':             self.fillRegionAsParagraph,
        'flush-lines':                          self.flushLines,
        'focus-to-body':                        self.focusToBody,
        'focus-to-log':                         self.focusToLog,
        'focus-to-minibuffer':                  self.focusToMinibuffer,
        'focus-to-tree':                        self.focusToTree,
        'forward-char':                         self.forwardCharacter,
        'forward-char-extend-selection':        self.forwardCharacterExtendSelection,
        'forward-paragraph':                    self.forwardParagraph,
        'forward-paragraph-extend-selection':   self.forwardParagraphExtendSelection,
        'forward-sentence':                     self.forwardSentence,
        'forward-sentence-extend-selection':    self.forwardSentenceExtendSelection,
        'forward-word':                         self.forwardWord,
        'forward-word-extend-selection':        self.forwardWordExtendSelection,
        'goto-char':                            self.gotoCharacter,
        'goto-line':                            self.gotoLine,
        'how-many':                             self.howMany,
        # Use indentBody in leoCommands.py
        #'indent-region':                       self.indentRegion,
        'indent-relative':                      self.indentRelative,
        'indent-rigidly':                       self.tabIndentRegion,
        'indent-to-comment-column':             self.indentToCommentColumn,
        'insert-newline':                       self.insertNewline,
        'insert-parentheses':                   self.insertParentheses,
        'keep-lines':                           self.keepLines,
        'kill-paragraph':                       self.killParagraph,
        'line-number':                          self.lineNumber,
        'move-past-close':                      self.movePastClose,
        'move-past-close-extend-selection':     self.movePastCloseExtendSelection,
        'newline-and-indent':                   self.insertNewLineAndTab,
        'next-line':                            self.nextLine,
        'next-line-extend-selection':           self.nextLineExtendSelection,
        'previous-line':                        self.prevLine,
        'previous-line-extend-selection':       self.prevLineExtendSelection,
        'remove-blank-lines':                   self.removeBlankLines,
        'replace-regex':                        self.activateReplaceRegex,
        'replace-string':                       self.replaceString,
        'reverse-region':                       self.reverseRegion,
        'scroll-down':                          self.scrollDown,
        'scroll-down-extend-selection':         self.scrollDownExtendSelection,
        'scroll-up':                            self.scrollUp,
        'scroll-up-extend-selection':           self.scrollUpExtendSelection,
        'select-paragraph':                     self.selectParagraph,
        # Exists, but can not be executed via the minibuffer.
        # 'self-insert-command':                self.selfInsertCommand,
        'set-comment-column':                   self.setCommentColumn,
        'set-extend-mode':                      self.setExtendMode,
        'set-fill-column':                      self.setFillColumn,
        'set-fill-prefix':                      self.setFillPrefix,
        'set-mark-command':                     self.setRegion,
        'show-colors':                          self.showColors,
        'show-fonts':                           self.showFonts,
        # 'save-buffer':                        self.saveFile,
        'split-line':                           self.insertNewLineIndent,
        'tabify':                               self.tabify,
        'toggle-extend-mode':                   self.toggleExtendMode,
        'transpose-chars':                      self.transposeCharacters,
        'transpose-lines':                      self.transposeLines,
        'transpose-words':                      self.transposeWords,
        'untabify':                             self.untabify,
      
</t>
<t tx="ekr.20060122183544">@nocolor

- Handle backspace for isearch: keep a stack of previous matches.
- Allow cross-node isearches.
</t>
<t tx="ekr.20060122184114">- Entering outline mode should call c.endEditing.
- Entering edit mode shouldn't call c.endEditing!
</t>
<t tx="ekr.20060122184800"></t>
<t tx="ekr.20060122185244.2"># unindent-region should work in all panes.</t>
<t tx="ekr.20060122185507"></t>
<t tx="ekr.20060122194643"></t>
<t tx="ekr.20060123091352"></t>
<t tx="ekr.20060123095316">Useful, e.g., after a find.</t>
<t tx="ekr.20060125113540">Maybe the entire table should be specified this way.</t>
<t tx="ekr.20060202141338.4"></t>
<t tx="ekr.20060202231708.1">This will allow @menu nodes in leoSettings.leo</t>
<t tx="ekr.20060202235215.1"></t>
<t tx="ekr.20060202235215.3"></t>
<t tx="ekr.20060203112912.1"></t>
<t tx="ekr.20060203165231"></t>
<t tx="ekr.20060206103922"></t>
<t tx="ekr.20060206104205"></t>
<t tx="ekr.20060206104841"></t>
<t tx="ekr.20060206114203">show/hide buttons, etc.
</t>
<t tx="ekr.20060206131908.1">@nocolor

This will indicate the start of searches.
It would be shown in the Find tab.</t>
<t tx="ekr.20060207085518">c.insertHeadlineTime uses the edit widget.  It shouldn't.</t>
<t tx="ekr.20060209105218.2"></t>
<t tx="ekr.20060209201859.1">Having to define dummy methods is getting odious.</t>
<t tx="ekr.20060210140415"></t>
<t tx="ekr.20060210140415.1"></t>
<t tx="ekr.20060211093935"></t>
<t tx="ekr.20060211100150"></t>
<t tx="ekr.20060211144330.1">def getMacHelpMenu (self):
    
    return None ###
    
    try:
        helpMenu = Tk.Menu('top.help')
        return helpMenu
        
    except Exception:
        g.trace('Can not get MacOS Help menu')
        g.es_exception()
        return None</t>
<t tx="ekr.20060211184834">Any command that alters text should call begin/endCommand.</t>
<t tx="ekr.20060212125650">def createBalloon (tab,sv):

    'Create a balloon for a widget.' ''

    balloon = Pmw.Balloon(tab,initwait=100)
    balloon.bind(tab,'')
    hull = balloon.component('hull')
    def blockExpose (event):
        if sv.get() == '':
             hull.withdraw()
    hull.bind('&lt;Expose&gt;',blockExpose,'+')
    balloon._label.configure(textvariable=sv)</t>
<t tx="ekr.20060213094300"></t>
<t tx="ekr.20060213144352">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3573148
By: yarkot

With the "latest" CVS snapshot. Do this:

[] Open LeoDocs.leo from the latest workspace;
[] Expand node "What's new in Leo 4.4" (I'll refer to this as the "parent");
[] Dbl-click parent (VIM opens text; text is single line: "@nocolor");
[] Add a second "@nocolor" line; write and save from VIM;
[] Leo view does not show line;
[] re-open w/ vim - vim shows new line;

[] Save;  add more text;  shows w/ vim, not in Leo; Apparently doesn't get save.
You can add a line in Leo, "This is a test", modify it in vim - "This was a
test", save vim, save Leo - close leo, re-open leo - the vim changes never got
saved.

Ok  - that's one.

Here's the second (same file, node, fresh session):

[] Open parent w/ vim (dbl-clk); opens ok;
[] open child "New commands not in legacy Leo" w/ vim; opens ok.
[] FAILS:  try to open first child: "Minibuffer-oriented find commands" - vim
doesn't open, status line flashes node name (once for each click it looks like),
and console window shows this:

open_in_vim: {'p': &lt;pos 20987888 lvl: 1 [0] New commands not in legacy Leo&gt;,
'c'
: Commander 25144936: u'C:\\Workspace\\Leo\\leo\\doc\\LeoDocs.leo', 'event':
&lt;Tk
inter.Event instance at 0x0132BE90&gt;, 'v': &lt;pos 20987888 lvl: 1 [0] New commands
not in legacy Leo&gt;}</t>
<t tx="ekr.20060213145539">@nocolor

1.  Both the vim and xemacs plugins require that open_with plugin be enabled.
    I changed the docstrings for each.

2.  The open_with plugin now explicitly calls g.enableIdleTimeHook.
    That is, the idle time hook is no longer enabled by default.
   
These were easy fixes to make.  A similar fix should be done for files opened from the Open With menu, but it's too late to do that for b2.</t>
<t tx="ekr.20060213151411"></t>
<t tx="ekr.20060213151918"></t>
<t tx="ekr.20060213160417">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3573470
By: nobody

Thank you for fast respond. I made some next testing and here are results.

OS - WindowsXP
&gt;&gt; locale.getdefaultlocale()
('cs_CZ', 'cp1250')

I'm trying write letters 'e&gt;' in mini-buffer:

e = LATIN SMALL LETTER E
 = LATIN SMALL LETTER E WITH ACUTE
&gt; = LATIN SMALL LETTER E WITH CARON
 = LATIN SMALL LETTER E WITH DIAERESIS

Letters '&gt;' and '' are directly on the keyboard,
letter '' I have to insert as multi key.

&gt;&gt; @bool trace_masterKeyHandler = True 
&gt;&gt; In leoSettings.leo. You should see the message: 
&gt;&gt; 'ignoring unbound special key' 

No - I got message:

-----------------------------------------------
strokeFromEvent: state 4 keysym f result 'Ctrl+f'
masterKeyHandlerHelper: 'Ctrl+f' state None
masterKeyHandlerHelper: all found Ctrl+f = search-with-present-options
strokeFromEvent: state 0 keysym e result 'e'
masterKeyHandlerHelper: 'e' state getArg
strokeFromEvent: ****************************** unknown keysym 'eacute'
strokeFromEvent: state 0 keysym eacute result '\xc3\xa9'
masterKeyHandlerHelper: '\xc3\xa9' state getArg
strokeFromEvent: ****************************** unknown keysym 'igrave'
strokeFromEvent: state 0 keysym igrave result '\xc4\x9b'
masterKeyHandlerHelper: '\xc4\x9b' state getArg
strokeFromEvent: ****************************** unknown keysym 'Multi_key'
strokeFromEvent: state 0 keysym Multi_key result ''
masterKeyHandlerHelper: '' state getArg
strokeFromEvent: state 0 keysym e result 'e'
masterKeyHandlerHelper: 'e' state getArg
-----------------------------------------------

When I insert same letters in body panel, message is identical, but text in
panel is inserted correctly.

(Sorry for my english, I'm not native speaker).

Milan Melena
</t>
<t tx="ekr.20060213164147">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3545403
By: e

more str() to remove...

with some non ascii headline,
a traceback after an executeScript
calls goto linenumber

 \leo-4-4-\src\leoCommands.py, line 1822, in goToScriptLineNumber
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
 \leo-4-4-\src\leoCommands.py", line 1466, in goToLineNumber
    if p.matchHeadline(vnodeName):
 \leo-4-4-\src\leoNodes.py, line 1631, in matchHeadline
    def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
 \leo-4-4-\src\leoNodes.py, line 665, in matchHeadline
    return s == h[0:len(s)]
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc2 in position 1: ordinal
not in range(128)

a + b = c
</t>
<t tx="ekr.20060214072931">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3575014
By: ktenney

&gt; it seems my Leo file must have a @button Unit Test  

Good point. I'll add a run-unit-test command soon.

&gt; the @test output goes to the console.

It goes to sys.stderr, iirc.  Perhaps run-unit-test should support this setting:

@bool unit_test_output_to_log_pane = True</t>
<t tx="ekr.20060214110318">- Manual update only.</t>
<t tx="ekr.20060214110318.1"></t>
<t tx="ekr.20060214140221"></t>
<t tx="ekr.20060214140930"></t>
<t tx="ekr.20060214140930.1">extract                             = Shift-Ctrl-D
extract-names                       = Shift-Ctrl-N
extract-section                     = Shift-Ctrl-S  # Shift-Ctrl-E: end-of-line-extend-selection

write-at-file-nodes                 = Shift-Ctrl-W # Was enter-file-mode.
write-dirty-at-file-nodes           = Shift+Ctrl+Q

# Removed definitions of find and file modes.  I never used them.</t>
</tnodes>
</leo_file>
