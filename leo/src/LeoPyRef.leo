<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="8385" clone_windows="0"/>
<globals body_outline_ratio="0.518959913326">
	<global_window_position top="11" left="391" height="923" width="797"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20040711135244.11,ekr.20040711135244.11,ekr.20031218072017.2052,ekr.20031218072017.2619,ekr.20031218072017.2052,ekr.20031218072017.2052,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20050831131028"><vh>opml</vh>
<v t="ekr.20050831131452"><vh>Original post</vh></v>
<v t="ekr.20050831131452.1"><vh>opml attributes v elements</vh></v>
<v t="ekr.20050912063133"><vh>@url http://sourceforge.net/forum/message.php?msg_id=3273977</vh></v>
<v t="ekr.20050912065811"><vh>@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)</vh></v>
<v t="ekr.20050915062404"><vh>My post</vh></v>
</v>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20051006122237"><vh>(Recent)</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20051009120608"><vh>(ctors &amp; finishCreate)</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20050920094212"><vh>f.createMiniBufferWidget</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
<v t="ekr.20050920084036.188"><vh>leoCommands.getPublicCommands (sets inversCommandDict &amp; leoCallbackDict)</vh>
<v t="ekr.20050920084036.189"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051006131811"><vh>(uArgs)</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20050920085536.73"><vh>universalDispatcher &amp; helpers</vh>
<v t="ekr.20051006083627.1"><vh>&lt;&lt; about repeat counts &gt;&gt;</vh></v>
<v t="ekr.20050920085536.75"><vh>executeNTimes</vh></v>
<v t="ekr.20050920085536.76"><vh>doControlU</vh></v>
</v>
</v>
<v t="ekr.20051010062551.1"><vh>(key dicts)</vh>
<v t="ekr.20050922104731"><vh>finishCreateEditCommanders (leoEditCommands module)</vh></v>
<v t="ekr.20050920084036.188"><vh>leoCommands.getPublicCommands (sets inversCommandDict &amp; leoCallbackDict)</vh>
<v t="ekr.20050920084036.189"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051012091323"><vh>(Outline goto's)</vh>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20031218072017.2898"><vh>Expand &amp; Contract...</vh>
<v t="ekr.20031218072017.2899"><vh>Commands</vh>
<v t="ekr.20031218072017.2900"><vh>contractAllHeadlines</vh></v>
<v t="ekr.20031218072017.2901"><vh>contractNode</vh></v>
<v t="ekr.20040930064232"><vh>contractNodeOrGoToParent</vh></v>
<v t="ekr.20031218072017.2902"><vh>contractParent</vh></v>
<v t="ekr.20031218072017.2903"><vh>expandAllHeadlines</vh></v>
<v t="ekr.20031218072017.2904"><vh>expandAllSubheads</vh></v>
<v t="ekr.20031218072017.2905"><vh>expandLevel1..9</vh></v>
<v t="ekr.20031218072017.2906"><vh>expandNextLevel</vh></v>
<v t="ekr.20031218072017.2907"><vh>expandNode</vh></v>
<v t="ekr.20040930064232.1"><vh>expandNodeAnd/OrGoToFirstChild</vh></v>
<v t="ekr.20031218072017.2908"><vh>expandPrevLevel</vh></v>
</v>
<v t="ekr.20031218072017.2909"><vh>Utilities</vh>
<v t="ekr.20031218072017.2910"><vh>contractSubtree</vh></v>
<v t="ekr.20031218072017.2911"><vh>expandSubtree</vh></v>
<v t="ekr.20031218072017.2912"><vh>expandToLevel (rewritten in 4.4)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2913"><vh>Goto</vh>
<v t="ekr.20031218072017.1628"><vh>goNextVisitedNode</vh></v>
<v t="ekr.20031218072017.1627"><vh>goPrevVisitedNode</vh></v>
<v t="ekr.20031218072017.2914"><vh>goToFirstNode</vh></v>
<v t="ekr.20051012092453"><vh>goToFirstSibling (New in 4.4)</vh></v>
<v t="ekr.20031218072017.2915"><vh>goToLastNode (Bug fix in 4.4)</vh></v>
<v t="ekr.20051012092847.1"><vh>goToLastSibling (New in 4.4)</vh></v>
<v t="ekr.20050711153537"><vh>goToLastVisibleNode</vh></v>
<v t="ekr.20031218072017.2916"><vh>goToNextClone</vh></v>
<v t="ekr.20031218072017.2917"><vh>goToNextDirtyHeadline</vh></v>
<v t="ekr.20031218072017.2918"><vh>goToNextMarkedHeadline</vh></v>
<v t="ekr.20031218072017.2919"><vh>goToNextSibling</vh></v>
<v t="ekr.20031218072017.2920"><vh>goToParent</vh></v>
<v t="ekr.20031218072017.2921"><vh>goToPrevSibling</vh></v>
<v t="ekr.20031218072017.2994"><vh>selectThreadNext</vh></v>
<v t="ekr.20031218072017.2993"><vh>selectThreadBack</vh></v>
<v t="ekr.20031218072017.2995"><vh>selectVisBack</vh></v>
<v t="ekr.20031218072017.2996"><vh>selectVisNext</vh></v>
</v>
</v>
<v t="ekr.20051013085834"><vh>(Added new emacs find commands &amp; ekr abbreviations)</vh>
<v t="ekr.20031218072017.2887"><vh>Find submenu (frame methods)</vh>
<v t="ekr.20051013084200"><vh>dismissFindPanel</vh></v>
<v t="ekr.20031218072017.2888"><vh>showFindPanel</vh></v>
<v t="ekr.20031218072017.2889"><vh>findNext</vh></v>
<v t="ekr.20031218072017.2890"><vh>findPrevious</vh></v>
<v t="ekr.20031218072017.2891"><vh>replace</vh></v>
<v t="ekr.20031218072017.2892"><vh>replaceThenFind</vh></v>
<v t="ekr.20051013083241"><vh>replaceAll</vh></v>
</v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3753"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20050711091931"><vh>defineEditMenuEditCursorTable</vh></v>
<v t="ekr.20031218072017.3754"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20031218072017.3755"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3759"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20031218072017.3760"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20031218072017.3761"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20031218072017.3762"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20031218072017.3763"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20031218072017.3764"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20031218072017.3765"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20031218072017.3766"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20050921103230"><vh>defineEditorMenuTables</vh></v>
<v t="ekr.20031218072017.3773"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20031218072017.3774"><vh>defineHelpMenuTables</vh></v>
</v>
</v>
<v t="ekr.20051014155115"><vh>(Added f.show/hideMinibuffer)</vh>
<v t="ekr.20051014170754.1"><vh>getShortcutForCommand/Name</vh></v>
<v t="ekr.20050920084036.173"><vh>getPublicCommands (for keyHandler)</vh></v>
<v t="ekr.20051014155551"><vh>k.show/hide/toggleMinibuffer</vh></v>
<v t="ekr.20051014154752"><vh>Minibuffer methods</vh></v>
<v t="ekr.20050920094212"><vh>f.createMiniBufferWidget</vh></v>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
</v>
<v t="ekr.20051014161914"><vh>(Don't put unknown control characters into the mini-buffer)</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20050920085536.62"><vh>getArg</vh>
<v t="ekr.20050928092516"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
</v>
<v t="ekr.20051014180059"><vh>(Help command)</vh>
<v t="ekr.20051014170754"><vh>k.help</vh></v>
<v t="ekr.20031218072017.3197"><vh>Whitespace...</vh>
<v t="ekr.20051014175117"><vh>g.adjustTripleString (same as removeExtraLws)</vh></v>
<v t="ekr.20031218072017.3198"><vh>computeLeadingWhitespace</vh></v>
<v t="ekr.20031218072017.3199"><vh>computeWidth</vh></v>
<v t="ekr.20031218072017.3200"><vh>get_leading_ws</vh></v>
<v t="ekr.20031218072017.3201"><vh>optimizeLeadingWhitespace</vh></v>
<v t="ekr.20040723093558"><vh>regularizeTrailingNewlines</vh></v>
<v t="ekr.20031218072017.3202"><vh>removeLeadingWhitespace</vh></v>
<v t="ekr.20050211120242.2"><vh>g.removeExtraLws &amp; tests</vh>
<v t="ekr.20050211120837"><vh>test_g_removeExtraLws</vh></v>
</v>
<v t="ekr.20031218072017.3203"><vh>removeTrailingWs</vh></v>
<v t="ekr.20031218072017.3204"><vh>skip_leading_ws</vh></v>
<v t="ekr.20031218072017.3205"><vh>skip_leading_ws_with_indent</vh></v>
<v t="ekr.20040723093558.1"><vh>stripBlankLines</vh></v>
</v>
</v>
<v t="ekr.20051015123432"><vh>(Methods with pychecker problems)</vh>
<v t="ekr.20051015113252"><vh>Pychecker report</vh></v>
<v t="ekr.20041126060136"><vh>print_list &amp; listToString</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
</v>
</v>
<v t="ekr.20051016115757"><vh>4.4a1 projects</vh>
<v t="ekr.20050929075341"><vh>Added option for selected body text</vh>
<v t="ekr.20050929075920"><vh>Request</vh></v>
<v t="ekr.20031218072017.3998"><vh>tkBody.createControl</vh></v>
<v t="ekr.20041217135735.1"><vh>tkBody.setColorFromConfig</vh></v>
</v>
<v t="ekr.20050928112629"><vh>Fixed bug in Leo's read logic</vh>
<v t="ekr.20050929082939"><vh>Report</vh></v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2 &amp; 4.4)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20041023110111"><vh>&lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1561"><vh>getTnode (changed for 4.4)</vh>
<v t="ekr.20031218072017.1564"><vh>&lt;&lt; handle unknown attributes &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050929084510"><vh>Fixed problem with auto-indent</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20031218072017.1330"><vh>onBodyKey</vh>
<v t="ekr.20040105223536"><vh>handleStatusLineKey</vh>
<v t="ekr.20040105223536.1"><vh>&lt;&lt; trace the key event &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1321"><vh>idle_body_key &amp; helpers</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20050526080309"><vh>&lt;&lt; handle special characters &gt;&gt;</vh>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>doAutoIndent (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>convertBlanksToTabs</vh>
<v t="ekr.20050526081024"><vh>&lt;&lt; convert tab no matter where it is &gt;&gt;</vh></v>
<v t="ekr.20050526081024.1"><vh>&lt;&lt; convert only leading tabs &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.838"><vh>tkBody.createBindings</vh></v>
</v>
<v t="ekr.20051006195420"><vh>Added background/foreground selection confic options</vh>
<v t="ekr.20051006195420.1"><vh>Report</vh></v>
<v t="ekr.20041217135735.1"><vh>tkBody.setColorFromConfig</vh></v>
</v>
<v t="ekr.20050920084720.1"><vh>Moved emacs commands and new keyHandler to Leo's core</vh>
<v t="ekr.20051003064825"><vh>Big picture</vh></v>
<v t="ekr.20051008204635"><vh>Docs</vh>
<v t="ekr.20050930083044"><vh>@url 'http://www.sas.upenn.edu/computing/help/Unix/emacs.html'   (Basic Emacs commands)</vh></v>
<v t="ekr.20051004093536"><vh>@url 'http://www.ling.ed.ac.uk/facilities/help/emacs/emacs_14.html' (Registers)</vh></v>
<v t="ekr.20051005094144"><vh>@url 'http://www.delorie.com/gnu/docs/emacs/emacs_487.html' (Macros)</vh></v>
</v>
<v t="ekr.20050921100955"><vh>Not used</vh>
<v t="ekr.20050723064110"><vh>class generalizedEditCommands (Do not delete)</vh>
<v t="ekr.20050723064110.1"><vh>ctor</vh></v>
<v t="ekr.20050723064110.3"><vh>Options...</vh>
<v t="ekr.20050723064110.4"><vh>setDefaultOptions</vh></v>
<v t="ekr.20050723064110.5"><vh>getOption</vh></v>
</v>
<v t="ekr.20050723064110.6"><vh>Word stuff...</vh>
<v t="ekr.20050723064110.7"><vh>findWordStart</vh></v>
<v t="ekr.20050723064110.8"><vh>insideWord</vh></v>
<v t="ekr.20050723064110.9"><vh>skipWord</vh></v>
<v t="ekr.20050723064110.10"><vh>startsWord</vh></v>
<v t="ekr.20050723064110.11"><vh>setDefaultWordChars</vh></v>
</v>
<v t="ekr.20050723064110.12"><vh>Cursor movement</vh>
<v t="ekr.20050723064110.13"><vh>moveBackwardChar</vh></v>
<v t="ekr.20050723064110.14"><vh>moveBackwardWord (Finish)</vh></v>
<v t="ekr.20050723064110.15"><vh>moveForwardChar</vh></v>
<v t="ekr.20050723064110.16"><vh>moveForwardWord</vh></v>
<v t="ekr.20050723064110.17"><vh>selectWord</vh></v>
<v t="ekr.20050723064110.18"><vh>selectForwordWord</vh></v>
</v>
</v>
<v t="ekr.20051012124209"><vh>From leoEditCommands...</vh>
<v t="ekr.20050920084036.129"><vh>zapTo</vh></v>
<v t="ekr.20050927102645"><vh>From bufferCommandsClass</vh>
<v t="ekr.20050920084036.46"><vh>setBufferListGetter</vh></v>
<v t="ekr.20050920084036.47"><vh>setBufferSetter</vh></v>
<v t="ekr.20050920084036.48"><vh>getBufferDict</vh></v>
<v t="ekr.20050920084036.49"><vh>setBufferData</vh></v>
<v t="ekr.20050920084036.50"><vh>setBufferGoto</vh></v>
<v t="ekr.20050920084036.51"><vh>setBufferDelete</vh></v>
<v t="ekr.20050920084036.52"><vh>setBufferRename</vh></v>
</v>
<v t="ekr.20050920085536.43"><vh>findItemsWithPrefix (Not used)</vh></v>
<v t="ekr.20050920084036.73"><vh>startGoto (No longer used)</vh></v>
<v t="ekr.20050920084036.143"><vh>Goto (no longer used)</vh></v>
<v t="ekr.20050930091642"><vh>walkKB</vh></v>
<v t="ekr.20050930095323"><vh>killSentenceHelper</vh></v>
<v t="ekr.20050920085536.69"><vh>tailEnd...</vh>
<v t="ekr.20050920114619.1"><vh>utTailEnd</vh></v>
<v t="ekr.20050920085536.70"><vh>_tailEnd</vh></v>
<v t="ekr.20050920085536.71"><vh>setTailEnd</vh></v>
</v>
<v t="ekr.20050920084036.44"><vh>setInBufferMode</vh></v>
<v t="ekr.20050920084036.256"><vh>executeRegister (not used)</vh></v>
</v>
<v t="ekr.20051012141518"><vh>From bufferCommandsClass</vh>
<v t="ekr.20050927101829.2"><vh>buildBufferList (not used)</vh></v>
<v t="ekr.20050920084036.41"><vh>bufferList (to be deleted)</vh></v>
<v t="ekr.20051012133615"><vh>switchToBuffer (not used)</vh></v>
</v>
<v t="ekr.20050920084036.251"><vh>_ToReg (not used)</vh></v>
<v t="ekr.20050920085536.64"><vh>k.manufactureKeyPress</vh></v>
<v t="ekr.20050929170812"><vh>leoEditCommands.manufactureKeyPress</vh></v>
</v>
<v t="ekr.20050921094025.254"><vh>All xemacs commands</vh>
<v t="ekr.20050921094025.255"><vh>B: Buffer-menu</vh></v>
<v t="ekr.20050921094025.256"><vh>C, E, F, H</vh></v>
<v t="ekr.20050921094025.257"><vh>I: info</vh></v>
<v t="ekr.20050921094025.258"><vh>L, M, R, T, V: LaTeX,TeX</vh></v>
<v t="ekr.20050921094025.259"><vh>a add- align- append- apropos- auto-</vh></v>
<v t="ekr.20050921094025.260"><vh>b backward- bbdb- beginning- bookmark- br- browse- buffer- build- byte-</vh></v>
<v t="ekr.20050921094025.261"><vh>c c- calc-, call- capitalize- center- checkdoc- command- completion- copy- count- customize- cvs-</vh></v>
<v t="ekr.20050921094025.262"><vh>d dabbrev- define- delete- describe- dictionary dired- display- downcase-</vh></v>
<v t="ekr.20050921094025.263"><vh>e ediff- edir edit- emerge- end- exchange- eshell eval- exit- expand-</vh></v>
<v t="ekr.20050921094025.264"><vh>f fill- find- format- forward-</vh></v>
<v t="ekr.20050921094025.265"><vh>g global- goto- grep-</vh></v>
<v t="ekr.20050921094025.266"><vh>h help- hide- html- hyper-</vh></v>
<v t="ekr.20050921094025.267"><vh>i ibuffer- id-select- igrep- indent- info- insert- isearch- ispell- iswitchb- itimer-</vh></v>
<v t="ekr.20050921094025.268"><vh>j jde-</vh></v>
<v t="ekr.20050921094025.269"><vh>k kill- kimport-</vh></v>
<v t="ekr.20050921094025.270"><vh>l lisp- list- load-</vh></v>
<v t="ekr.20050921094025.271"><vh>m macroexpand- mail- make- mark- minibuffer- mouse- move-</vh></v>
<v t="ekr.20050921094025.272"><vh>n narrow- newline- next-</vh></v>
<v t="ekr.20050921094025.273"><vh>o open- other- outl- outline- overwrite</vh></v>
<v t="ekr.20050921094025.274"><vh>p package- paren- pcomplete- pending- pop- popup- pp- prepend- prettyexapnd- previous- profile- ps- pydoc pymacs- python-</vh></v>
<v t="ekr.20050921094025.275"><vh>q query-</vh></v>
<v t="ekr.20050921094025.276"><vh>r re- read- recentf- recover- recursive- rename- repeat- replace- reverse- run-</vh></v>
<v t="ekr.20050921094025.277"><vh>s save- scroll- search- set- shell- sort- speedbar spell- strokes- suspend- switch- symbol-</vh></v>
<v t="ekr.20050921094025.278"><vh>t tab tags- toggle- toolbar- turn-off turn-on</vh></v>
<v t="ekr.20050921094025.279"><vh>u universal- upcase- url-</vh></v>
<v t="ekr.20050921094025.280"><vh>v view- vm-</vh></v>
<v t="ekr.20050921094025.281"><vh>w win32- winring- word- write-</vh></v>
<v t="ekr.20050921094025.282"><vh>x xwem-</vh></v>
<v t="ekr.20050921094025.283"><vh>y yank-</vh></v>
<v t="ekr.20050921094025.284"><vh>z zap-</vh></v>
</v>
<v t="ekr.20050921094025.6"><vh>What I did</vh>
<v t="ekr.20051004132320"><vh>Early days</vh>
<v t="ekr.20050921094025.7"><vh>Rewrote buildBufferList</vh></v>
<v t="ekr.20050921094025.8"><vh>Removed Emacs_instances class var</vh></v>
<v t="ekr.20050921094025.9"><vh>Added c ivar to Emacs class</vh></v>
<v t="ekr.20050921094025.10"><vh>Removed labels class var</vh></v>
<v t="ekr.20050921094025.11"><vh>Added baseCommands class</vh></v>
<v t="ekr.20050921094025.12"><vh>The big collapse (of complexity)</vh></v>
<v t="ekr.20050921094025.13"><vh>Improvements to commands</vh></v>
<v t="ekr.20050921094025.14"><vh>Removed all globals</vh></v>
<v t="ekr.20050921094025.15"><vh>Fixed bug: newline was not setting body pane dirty</vh></v>
<v t="ekr.20050921101706"><vh>Replaced 'M-x' prompt by 'full-command'</vh></v>
<v t="ekr.20050921105623"><vh>Added useMiniBuffer and useEditorMenu @settings</vh></v>
<v t="ekr.20050921105623.1"><vh>Deleted coreEmacs plugin</vh></v>
<v t="ekr.20050922080526"><vh>Fixed outline selection bug</vh></v>
<v t="ekr.20050923143034"><vh>c.commandsDict now describes all commands</vh></v>
<v t="ekr.20050923141539"><vh>Rewrote altX code</vh></v>
<v t="ekr.20050923233827"><vh>Eliminated all helper classes and simplified the code.</vh></v>
</v>
<v t="ekr.20051014170101"><vh>Before changeover</vh>
<v t="ekr.20050924073836.1"><vh>Simplifications 1</vh></v>
<v t="ekr.20051001180444"><vh>Simplifications 2</vh></v>
<v t="ekr.20051002161714"><vh>Simplfications 3</vh></v>
<v t="ekr.20051003140625"><vh>Improvements</vh></v>
<v t="ekr.20051004085713"><vh>Improvement 2</vh></v>
<v t="ekr.20051007093659"><vh>Final integration</vh></v>
<v t="ekr.20051008065518"><vh>Final integration 2</vh></v>
<v t="ekr.20051009042953"><vh>Changeover</vh></v>
<v t="ekr.20051009130341"><vh>Bugs fixed</vh></v>
<v t="ekr.20051011091759"><vh>Added big kludge to solve infamous control-v problems</vh></v>
</v>
<v t="ekr.20051011124540"><vh>After changeover</vh></v>
<v t="ekr.20051014170101.1"><vh>Before a1</vh></v>
</v>
</v>
<v t="ekr.20051012084345"><vh>Bugs fixed</vh>
<v t="ekr.20051012075322"><vh>openWithFileName now reads @settings by default</vh>
<v t="ekr.20051010152921"><vh>Report</vh></v>
<v t="ekr.20031218072017.1934"><vh>run &amp; allies</vh>
<v t="ekr.20041219072112"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20041219072416.1"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20040411081633"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1936"><vh>isValidPython</vh></v>
<v t="ekr.20041124083125"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20031218072017.1624"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20031218072017.1938"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20031218072017.1939"><vh>getBatchScript</vh></v>
<v t="ekr.20041130093254"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20031218072017.1624"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20041117093246"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20041117085625"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20041120064303"><vh>g.app.config.readSettingsFiles</vh></v>
<v t="ekr.20041117083857.1"><vh>g.app.config.readSettings</vh></v>
<v t="ekr.20051013161232"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20031218072017.2052" a="M"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20051012075322"><vh>openWithFileName now reads @settings by default</vh>
<v t="ekr.20051010152921"><vh>Report</vh></v>
<v t="ekr.20031218072017.1934"><vh>run &amp; allies</vh>
<v t="ekr.20041219072112"><vh>&lt;&lt; import leoGlobals and leoApp &gt;&gt;</vh></v>
<v t="ekr.20041219072416.1"><vh>&lt;&lt; import leoNodes and leoConfig &gt;&gt;</vh></v>
<v t="ekr.20040411081633"><vh>&lt;&lt; start psycho &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1936"><vh>isValidPython</vh></v>
<v t="ekr.20041124083125"><vh>completeFileName (leo.py)</vh></v>
<v t="ekr.20031218072017.1624"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20031218072017.1938"><vh>createNullGuiWithScript (leo.py)</vh></v>
<v t="ekr.20031218072017.1939"><vh>getBatchScript</vh></v>
<v t="ekr.20041130093254"><vh>reportDirectories</vh></v>
</v>
<v t="ekr.20031218072017.1624"><vh>createFrame (leo.py)</vh></v>
<v t="ekr.20041117093246"><vh>Scanning @settings (g.app.config)</vh>
<v t="ekr.20041117085625"><vh>g.app.config.openSettingsFile</vh></v>
<v t="ekr.20041120064303"><vh>g.app.config.readSettingsFiles</vh></v>
<v t="ekr.20041117083857.1"><vh>g.app.config.readSettings</vh></v>
<v t="ekr.20051013161232"><vh>g.app.config.updateSettings</vh></v>
</v>
<v t="ekr.20031218072017.2052" a="M"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20051012205437"><vh>(Replaced all calls to manufactureKeyPress)</vh>
<v t="ekr.20050929115226.1"><vh>forward/backCharacter</vh></v>
<v t="ekr.20050929163210"><vh>next/prevLine</vh></v>
<v t="ekr.20050929163010"><vh>backwardDeleteCharacter</vh></v>
</v>
<v t="ekr.20051013103838"><vh>(Escape does not end label editing)</vh>
<v t="ekr.20050120092028.1"><vh>set_focus (tkFrame)</vh></v>
<v t="ekr.20040803072955.135"><vh>setNormalLabelState</vh></v>
<v t="ekr.20040803072955.126"><vh>endEditLabel</vh></v>
<v t="ekr.20031218072017.3982"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20031218072017.3981"><vh>abortEditLabelCommand</vh></v>
</v>
<v t="ekr.20051012101104"><vh>Don't override menu defaults if there is no setting for the command in the @shortcuts node</vh>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051013155435"><vh>Minor crashes during development</vh>
<v t="ekr.20051012082219"><vh>Crash in backwardParagraph</vh>
<v t="ekr.20050920084036.102"><vh>backwardParagraph</vh></v>
</v>
<v t="ekr.20051012101954"><vh>Crash in Open Compare Window</vh></v>
<v t="ekr.20051010130212"><vh>Crash in unit test</vh>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20051014034200"><vh>(Fixed problems when special keys are not defined</vh>
<v t="ekr.20051014104337"><vh>Notes</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20031218072017.2098"><vh>canonicalizeShortcut</vh>
<v t="ekr.20031218072017.2102"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2099"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20031218072017.2100"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2101"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2103"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051015063053"><vh>(Problems enabling minibuffer)</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20051011105014"><vh>exists (g.app.config)</vh></v>
<v t="ekr.20041118084146"><vh>Setters (g.app.config)</vh>
<v t="ekr.20041118084146.1"><vh>set (g.app.config)</vh></v>
<v t="ekr.20041118084241"><vh>setString</vh></v>
<v t="ekr.20041228042224"><vh>setIvarsFromSettings (g.app.config)</vh></v>
<v t="ekr.20041201080436"><vh>appendToRecentFiles (g.app.config)</vh></v>
</v>
<v t="ekr.20041117083141"><vh>get &amp; allies (g.app.config)</vh>
<v t="ekr.20041121143823"><vh>getValFromDict</vh></v>
<v t="ekr.20051015093141"><vh>typesMatch</vh></v>
</v>
<v t="ekr.20041118195812"><vh>Setters... (c.configSettings)</vh>
<v t="ekr.20041118195812.3"><vh>setRecentFiles (c.configSettings)</vh></v>
<v t="ekr.20041118195812.2"><vh>set &amp; setString</vh></v>
</v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
</v>
<v t="ekr.20051015163627"><vh>(last-minute problem with ctrl-g)</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh></v>
<v t="ekr.20051014170754"><vh>k.help</vh></v>
</v>
</v>
</v>
<v t="ekr.20051016115757.1"><vh>4.4a2 projects</vh>
<v t="ekr.20051021070335"><vh>(Created open-find-tab command)</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
</v>
<v t="ekr.20051015112436"><vh>(Fixed bugs in k.registerCommand, k.printBindings</vh>
<v t="ekr.20051016171402"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
<v t="ekr.20051015110547"><vh>registerCommand</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh></v>
</v>
<v t="ekr.20051021074728.1"><vh>(Improved shortcuts parser)</vh>
<v t="ekr.20041117062717.14"><vh>getShortcut (config)</vh></v>
<v t="ekr.20051021212323"><vh>What I did</vh></v>
<v t="ekr.20041120112043"><vh>parseShortcutLine (g.app.config)</vh></v>
<v t="ekr.20041120105609"><vh>doShortcuts</vh></v>
<v t="ekr.20041120094940.9"><vh>set (parseBaseClass)</vh></v>
<v t="ekr.20041227071423"><vh>setShortcut (ParserBaseClass)</vh></v>
</v>
<v t="ekr.20051016113907"><vh>(Moved TabbedLog code into Leo's core)</vh>
<v t="ekr.20051016113907.1"><vh>How to use the new code</vh></v>
<v t="ekr.20031218072017.4039"><vh>class leoTkinterLog</vh>
<v t="ekr.20051016095907"><vh>tkLog Birth</vh>
<v t="ekr.20031218072017.4040"><vh>tkLog.__init__</vh></v>
<v t="ekr.20031218072017.4042"><vh>tkLog.createControl</vh></v>
<v t="ekr.20051016103459"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20051019134106.1"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20051016095907.1"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20031218072017.4041"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20031218072017.4043"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20041222043017"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20041222043017.1"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20041217135735.2"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20031218072017.4046"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20051016095907.2"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20031218072017.4045"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20031218072017.4044"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20051016101927"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20031218072017.1473"><vh>put</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20051016101927.1"><vh>putnl</vh></v>
</v>
<v t="ekr.20051018061932"><vh>Tab (TkLog)</vh>
<v t="ekr.20051017212057"><vh>clearTab</vh></v>
<v t="ekr.20051024173701"><vh>createTab</vh>
<v t="ekr.20051020075416"><vh>&lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;</vh></v>
<v t="ekr.20051018072306"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20051018102027"><vh>deleteTab</vh></v>
<v t="ekr.20051018061932.1"><vh>ower/raiseTab</vh></v>
<v t="ekr.20051019170806"><vh>renameTab</vh></v>
<v t="ekr.20051016101724.1"><vh>selectTab</vh></v>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051019134106"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20051019134422"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20051019140004.1"><vh>newTabFromMenu</vh></v>
<v t="ekr.20051019165401"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20051019172811"><vh>getTabName</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051022061226"><vh>(Refactored createMenuEntries)</vh>
<v t="ekr.20031218072017.3781"><vh>Gui-independent menu routines</vh>
<v t="ekr.20051022053758"><vh> Top level</vh>
<v t="ekr.20031218072017.3784"><vh>createMenuItemsFromTable</vh></v>
<v t="ekr.20031218072017.3785"><vh>createMenusFromTables &amp; helpers</vh>
<v t="ekr.20031218072017.3790"><vh>createFileMenuFromTable</vh>
<v t="ekr.20031218072017.3791"><vh>&lt;&lt; create the recent files submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3792"><vh>&lt;&lt; create the read/write submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3793"><vh>&lt;&lt; create the tangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3794"><vh>&lt;&lt; create the untangle submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3795"><vh>&lt;&lt; create the import submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3796"><vh>&lt;&lt; create the export submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3786"><vh>createEditMenuFromTable</vh>
<v t="ekr.20031218072017.3787"><vh>&lt;&lt; create the edit body submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3788"><vh>&lt;&lt; create the edit headline submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3789"><vh>&lt;&lt; create the find submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3797"><vh>createOutlineMenuFromTable</vh>
<v t="ekr.20040711140738.1"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3798"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3799"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3800"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3801"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20050921103736"><vh>createEditorMenuFromTable</vh></v>
<v t="ekr.20031218072017.3802"><vh>createWindowMenuFromTable</vh></v>
<v t="ekr.20031218072017.3803"><vh>createHelpMenuFromTable</vh></v>
</v>
<v t="ekr.20031218072017.3804"><vh>createNewMenu (contains Tk code)</vh></v>
<v t="ekr.20031218072017.4116"><vh>createOpenWithMenuFromTable</vh></v>
<v t="ekr.20031218072017.2078"><vh>createRecentFilesMenuItems (leoMenu)</vh></v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3753"><vh>defineEditMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20050711091931"><vh>defineEditMenuEditCursorTable</vh></v>
<v t="ekr.20031218072017.3754"><vh>defineEditMenuEditBodyTable</vh></v>
<v t="ekr.20031218072017.3755"><vh>defineEditMenuEditHeadlineTable</vh></v>
<v t="ekr.20031218072017.3756"><vh>defineEditMenuFindMenuTable</vh></v>
<v t="ekr.20031218072017.3757"><vh>defineEditMenuTop2Table</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>defineFileMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3759"><vh>defineFileMenuTopTable</vh></v>
<v t="ekr.20031218072017.3760"><vh>defineFileMenuTop2Table</vh></v>
<v t="ekr.20031218072017.3761"><vh>defineFileMenuReadWriteMenuTable</vh></v>
<v t="ekr.20031218072017.3762"><vh>defineFileMenuTangleMenuTable</vh></v>
<v t="ekr.20031218072017.3763"><vh>defineFileMenuUntangleMenuTable</vh></v>
<v t="ekr.20031218072017.3764"><vh>defineFileMenuImportMenuTable</vh></v>
<v t="ekr.20031218072017.3765"><vh>defineFileMenuExportMenuTable</vh></v>
<v t="ekr.20031218072017.3766"><vh>defineFileMenuTop3MenuTable</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>defineOutlineMenuTables &amp; helpers</vh>
<v t="ekr.20031218072017.3768"><vh>defineOutlineMenuTopMenuTable</vh></v>
<v t="ekr.20040711140738"><vh>defineOutlineMenuCheckOutlineMenuTable</vh></v>
<v t="ekr.20031218072017.3769"><vh>defineOutlineMenuExpandContractMenuTable</vh></v>
<v t="ekr.20031218072017.3770"><vh>defineOutlineMenuMoveMenuTable</vh></v>
<v t="ekr.20031218072017.3771"><vh>defineOutlineMenuMarkMenuTable</vh></v>
<v t="ekr.20031218072017.3772"><vh>defineOutlineMenuGoToMenuTable</vh></v>
</v>
<v t="ekr.20050921103230"><vh>defineEditorMenuTables</vh></v>
<v t="ekr.20031218072017.3773"><vh>defineWindowMenuTables</vh></v>
<v t="ekr.20031218072017.3774"><vh>defineHelpMenuTables</vh></v>
</v>
<v t="ekr.20031218072017.3805"><vh>deleteMenu</vh></v>
<v t="ekr.20031218072017.3806"><vh>deleteMenuItem</vh></v>
</v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
<v t="ekr.20051022053758.1"><vh>Helpers</vh>
<v t="ekr.20031218072017.3783"><vh>canonicalizeMenuName &amp; cononicalizeTranslatedMenuName</vh></v>
<v t="ekr.20031218072017.2098"><vh>canonicalizeShortcut</vh>
<v t="ekr.20031218072017.2102"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2099"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20031218072017.2100"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2101"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2103"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20051022044950"><vh>computeOldStyleShortcutKey</vh></v>
<v t="ekr.20051022043608.1"><vh>createOpenWithMenuItemsFromTable</vh>
<v t="ekr.20051022043713.1"><vh>&lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.4117"><vh>defineMenuCallback</vh></v>
<v t="ekr.20031218072017.4118"><vh>defineOpenWithMenuCallback</vh></v>
<v t="ekr.20031218072017.3782"><vh>get/setRealMenuName &amp; setRealMenuNamesFromTable</vh></v>
<v t="ekr.20031218072017.3807"><vh>getMenu, setMenu, destroyMenu</vh></v>
</v>
</v>
</v>
<v t="ekr.20051021143159.1"><vh>(Removed all key bindings from createMenuEntries)</vh>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051022083459"><vh>(Simplified the inverseBindingsDict)</vh>
<v t="ekr.20051018070524"><vh>computeInverseBindingDict</vh></v>
<v t="ekr.20051017212452"><vh>computeCompletionList</vh></v>
<v t="ekr.20051012201831"><vh>printBindings</vh></v>
<v t="ekr.20051014061332"><vh>printCommands</vh></v>
</v>
<v t="ekr.20051020074023"><vh>Created show-fonts &amp; show-colors commands</vh></v>
<v t="ekr.20051017111039"><vh>Fixed minor bug in k.doTabCompletion</vh></v>
<v t="ekr.20051017053631"><vh>Improved the scripting plugin</vh></v>
<v t="ekr.20051016162459"><vh>k.registerShortcut now makes sure to set k.inverseCommandsDict</vh></v>
<v t="ekr.20051013103457"><vh>(Per-pane bindings)</vh>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.11"><vh>add_ekr_altx_commands</vh>
<v t="ekr.20050920085536.12"><vh>&lt;&lt; define dict d of abbreviations &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20051023182326"><vh>copyBindingsToWidget</vh></v>
<v t="ekr.20051007080058"><vh>makeAllBindings</vh></v>
<v t="ekr.20050923174229.1"><vh>makeHardBindings</vh></v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh></v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20051017184201"><vh>(Tabbed log pane)</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20051002152108.1"><vh>Shared helpers</vh>
<v t="ekr.20051017212452"><vh>computeCompletionList</vh></v>
<v t="ekr.20051018070524"><vh>computeInverseBindingDict</vh></v>
<v t="ekr.20050920085536.46"><vh>doBackSpace</vh></v>
<v t="ekr.20050920085536.44"><vh>doTabCompletion</vh></v>
<v t="ekr.20051012092847"><vh>forceFocusToBody</vh></v>
<v t="ekr.20051014170754.1"><vh>getShortcutForCommand/Name</vh></v>
<v t="ekr.20051010063452"><vh>ultimateFuncName</vh></v>
</v>
<v t="ekr.20051017204206"><vh>Notes</vh></v>
<v t="ekr.20031218072017.4039"><vh>class leoTkinterLog</vh>
<v t="ekr.20051016095907"><vh>tkLog Birth</vh>
<v t="ekr.20031218072017.4040"><vh>tkLog.__init__</vh></v>
<v t="ekr.20031218072017.4042"><vh>tkLog.createControl</vh></v>
<v t="ekr.20051016103459"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20051019134106.1"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20051016095907.1"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20031218072017.4041"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20031218072017.4043"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20041222043017"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20041222043017.1"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20041217135735.2"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20031218072017.4046"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20051016095907.2"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20031218072017.4045"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20031218072017.4044"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20051016101927"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20031218072017.1473"><vh>put</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20051016101927.1"><vh>putnl</vh></v>
</v>
<v t="ekr.20051018061932"><vh>Tab (TkLog)</vh>
<v t="ekr.20051017212057"><vh>clearTab</vh></v>
<v t="ekr.20051024173701"><vh>createTab</vh>
<v t="ekr.20051020075416"><vh>&lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;</vh></v>
<v t="ekr.20051018072306"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20051018102027"><vh>deleteTab</vh></v>
<v t="ekr.20051018061932.1"><vh>ower/raiseTab</vh></v>
<v t="ekr.20051019170806"><vh>renameTab</vh></v>
<v t="ekr.20051016101724.1"><vh>selectTab</vh></v>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051019134106"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20051019134422"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20051019140004.1"><vh>newTabFromMenu</vh></v>
<v t="ekr.20051019165401"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20051019172811"><vh>getTabName</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051022152427"><vh>(Focus commands, etc.)</vh>
<v t="ekr.20051022142249"><vh>focus (editCommandsClass)</vh>
<v t="ekr.20051022144825"><vh>focusToBody/Log/Tree/Minibuffer</vh></v>
<v t="ekr.20051022144825.1"><vh>cycleFocus</vh></v>
</v>
<v t="ekr.20051022132934"><vh>Click event handlers (tkTree)</vh>
<v t="ekr.20040803072955.20"><vh>tkTree.createPermanentBindings</vh></v>
<v t="ekr.20051016095907.2"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20031218072017.4045"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20031218072017.4044"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20031218072017.4003"><vh>Focus (tkBody)</vh></v>
<v t="ekr.20040803072955.108"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20040803072955.87"><vh>onHeadlineClick</vh></v>
<v t="ekr.20051022141020"><vh>onTreeClick</vh></v>
<v t="ekr.20040803072955.105"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20040803072955.106"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040803072955.125"><vh>Selecting &amp; editing... (tkTree)</vh>
<v t="ekr.20040803072955.126"><vh>endEditLabel</vh></v>
<v t="ekr.20040803072955.127"><vh>editLabel</vh></v>
<v t="ekr.20040803072955.128"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.134"><vh>tree.set...LabelState</vh>
<v t="ekr.20040803072955.135"><vh>setNormalLabelState</vh></v>
<v t="ekr.20040803072955.136"><vh>setDisabledLabelState</vh></v>
<v t="ekr.20040803072955.137"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20040803072955.138"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20040803072955.139"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20040803072955.140"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20040803072955.141"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20040803072955.142"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20040803072955.143"><vh>tree.expandAllAncestors</vh></v>
</v>
</v>
<v t="ekr.20051023130656"><vh>(Use a Tk.Text widget for the minibuffer)</vh>
<v t="ekr.20051023135812"><vh>What I did</vh></v>
<v t="ekr.20050920094212"><vh>f.createMiniBufferWidget</vh></v>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050924064254"><vh>Label...</vh>
<v t="ekr.20051023132350"><vh>getLabel</vh></v>
<v t="ekr.20051023132350.2"><vh>protectLabel</vh></v>
<v t="ekr.20050920085536.37"><vh>resetLabel</vh></v>
<v t="ekr.20051023132350.1"><vh>setLabel</vh></v>
<v t="ekr.20050920085536.36"><vh>setLabelBlue</vh></v>
<v t="ekr.20050920085536.35"><vh>setLabelGrey</vh></v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
</v>
</v>
<v t="ekr.20051024053428"><vh>(Special bindings for minibuffer)</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051008152134"><vh>makeSpecialBindings (also binds to 'Key')</vh></v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
<v t="ekr.20051011072903.1"><vh>OnCopyFromMenu</vh></v>
<v t="ekr.20051011072049.1"><vh>OnCutFromMenu</vh></v>
<v t="ekr.20051011072903.4"><vh>OnPasteFromMenu</vh></v>
</v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
</v>
<v t="ekr.20051023175530"><vh>Improved the minibuffer</vh></v>
<v t="ekr.20051024101355"><vh>(Copy bindings to headlines)</vh>
<v t="ekr.20040803072955.20"><vh>tkTree.createPermanentBindings</vh></v>
<v t="ekr.20040803072955.11"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20050618045715"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh></v>
</v>
<v t="ekr.20051024112703"><vh>(Problems with key bindings in headlines)</vh>
<v t="ekr.20031218072017.1761"><vh>c.insertHeadline</vh></v>
<v t="ekr.20051024152318"><vh>Focus</vh>
<v t="ekr.20050120092028"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20050120092028.1"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20051024152318.1"><vh>Bindings</vh>
<v t="ekr.20040803072955.20"><vh>tkTree.createPermanentBindings</vh></v>
<v t="ekr.20051023182326"><vh>copyBindingsToWidget</vh></v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh></v>
<v t="ekr.20040803072955.11"><vh>newText (leoTkinterTree)</vh>
<v t="ekr.20050618045715"><vh>&lt;&lt; patch by Maciej Kalisiak  to handle scroll-wheel events &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051024152318.2"><vh>Event handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20040803072955.91"><vh>idle_head_key</vh>
<v t="ekr.20040803072955.93"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20040803072955.95"><vh>&lt;&lt; update p &gt;&gt;</vh></v>
<v t="ekr.20040803072955.96"><vh>&lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;</vh></v>
<v t="ekr.20040803072955.97"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051024145643"><vh>Label state</vh>
<v t="ekr.20031218072017.3716"><vh>Getters/Setters (tree)</vh></v>
<v t="ekr.20040803072955.76"><vh>findEditWidget</vh></v>
<v t="ekr.20031218072017.2991"><vh>c.editVnode (calls tree.editLabel)</vh></v>
<v t="ekr.20040803072955.75"><vh>edit_text</vh></v>
<v t="ekr.20040803072955.135"><vh>setNormalLabelState</vh></v>
<v t="ekr.20040803072955.127"><vh>editLabel</vh></v>
<v t="ekr.20040803072955.126"><vh>endEditLabel</vh></v>
<v t="ekr.20040803072955.39"><vh>drawIcon</vh>
<v t="ekr.20040803072955.40"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20051017184201"><vh>(Tabbed log pane)</vh>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction</vh></v>
</v>
<v t="ekr.20051002152108.1"><vh>Shared helpers</vh>
<v t="ekr.20051017212452"><vh>computeCompletionList</vh></v>
<v t="ekr.20051018070524"><vh>computeInverseBindingDict</vh></v>
<v t="ekr.20050920085536.46"><vh>doBackSpace</vh></v>
<v t="ekr.20050920085536.44"><vh>doTabCompletion</vh></v>
<v t="ekr.20051012092847"><vh>forceFocusToBody</vh></v>
<v t="ekr.20051014170754.1"><vh>getShortcutForCommand/Name</vh></v>
<v t="ekr.20051010063452"><vh>ultimateFuncName</vh></v>
</v>
<v t="ekr.20051017204206"><vh>Notes</vh></v>
<v t="ekr.20031218072017.4039"><vh>class leoTkinterLog</vh>
<v t="ekr.20051016095907"><vh>tkLog Birth</vh>
<v t="ekr.20031218072017.4040"><vh>tkLog.__init__</vh></v>
<v t="ekr.20031218072017.4042"><vh>tkLog.createControl</vh></v>
<v t="ekr.20051016103459"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20051019134106.1"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20051016095907.1"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20031218072017.4041"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20031218072017.4043"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20041222043017"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20041222043017.1"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20041217135735.2"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20031218072017.4046"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20051016095907.2"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20031218072017.4045"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20031218072017.4044"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20051016101927"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20031218072017.1473"><vh>put</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20051016101927.1"><vh>putnl</vh></v>
</v>
<v t="ekr.20051018061932"><vh>Tab (TkLog)</vh>
<v t="ekr.20051017212057"><vh>clearTab</vh></v>
<v t="ekr.20051024173701"><vh>createTab</vh>
<v t="ekr.20051020075416"><vh>&lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;</vh></v>
<v t="ekr.20051018072306"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20051018102027"><vh>deleteTab</vh></v>
<v t="ekr.20051018061932.1"><vh>ower/raiseTab</vh></v>
<v t="ekr.20051019170806"><vh>renameTab</vh></v>
<v t="ekr.20051016101724.1"><vh>selectTab</vh></v>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051019134106"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20051019134422"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20051019140004.1"><vh>newTabFromMenu</vh></v>
<v t="ekr.20051019165401"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20051019172811"><vh>getTabName</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051011071542.1"><vh>(Cut/Copy/Paste bindings)</vh>
<v t="ekr.20031218072017.839"><vh>defineEditMenuTopTable</vh></v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1728"><vh>&lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
<v t="ekr.20051011072903.1"><vh>OnCopyFromMenu</vh></v>
<v t="ekr.20051011072049.1"><vh>OnCutFromMenu</vh></v>
<v t="ekr.20051011072903.4"><vh>OnPasteFromMenu</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050921094025"><vh>4.4 To do</vh>
<v t="ekr.20051023125705"><vh>Asap (cool)</vh>
<v t="ekr.20051023125705.1"><vh>Autocompleter</vh>
<v t="ekr.20051023125705.2"><vh>Configuration</vh>
<v t="ekr.20051023125705.3"><vh>autocompleter.ini</vh></v>
<v t="ekr.20051023125705.4"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20051023125705.5"><vh> autocompleter.py</vh>
<v t="ekr.20051023125705.6"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20051023125705.7"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051023125705.8"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20051023125705.9"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="ekr.20051023125705.10"><vh>&lt;&lt;load notes&gt;&gt;</vh></v>
<v t="ekr.20051023125705.11"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="ekr.20051023125705.12"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20051023125705.13"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="ekr.20051023125705.14"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20051023125705.15"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20051023125705.16"><vh>init</vh></v>
<v t="ekr.20051023125705.17"><vh>watcher</vh></v>
<v t="ekr.20051023125705.18"><vh>scanText</vh></v>
<v t="ekr.20051023125705.19"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20051023125705.20"><vh>scanForCallTip</vh></v>
<v t="ekr.20051023125705.21"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20051023125705.22"><vh>_getCleanString</vh></v>
<v t="ekr.20051023125705.23"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20051023125705.24"><vh>initialScan</vh></v>
<v t="ekr.20051023125705.25"><vh>has read config file meths</vh></v>
<v t="ekr.20051023125705.26"><vh>readConfigFile</vh></v>
<v t="ekr.20051023125705.27"><vh>createConfigFile</vh></v>
<v t="ekr.20051023125705.28"><vh>readLanguageFiles</vh></v>
<v t="ekr.20051023125705.29"><vh>readOutline</vh></v>
<v t="ekr.20051023125705.30"><vh>reducer</vh></v>
<v t="ekr.20051023125705.31"><vh>unbind</vh></v>
<v t="ekr.20051023125705.32"><vh>moveSelItem</vh></v>
<v t="ekr.20051023125705.33"><vh>processKeyStroke</vh></v>
<v t="ekr.20051023125705.34"><vh>testForUnbind</vh></v>
<v t="ekr.20051023125705.35"><vh>processAutoBox</vh></v>
<v t="ekr.20051023125705.36"><vh>add_item</vh></v>
<v t="ekr.20051023125705.37"><vh>add_bindings</vh></v>
<v t="ekr.20051023125705.38"><vh>configureAutoBox</vh></v>
<v t="ekr.20051023125705.39"><vh>calculatePlace</vh></v>
<v t="ekr.20051023125705.40"><vh>setLanguage</vh></v>
<v t="ekr.20051023125705.41"><vh>newCreateControl</vh></v>
<v t="ekr.20051023125705.42"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20051023125705.43"><vh>onOpenWindow</vh></v>
</v>
</v>
</v>
<v t="ekr.20051008131807"><vh>Unit tests</vh></v>
<v t="ekr.20051021210459"><vh>Docs</vh></v>
<v t="ekr.20051016162724"><vh>First</vh>
<v t="ekr.20051018104223"><vh>Improve minibuffer commands</vh>
<v t="ekr.20051012053017.4"><vh>Search improvements</vh></v>
<v t="ekr.20051014122218"><vh>kill/yank from the xemacs tutorial</vh></v>
<v t="ekr.20051017111216"><vh>Commands to fix</vh>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20050920084036.75"><vh>backToIndentation</vh></v>
<v t="ekr.20050920084036.78"><vh>indentRelative</vh></v>
<v t="ekr.20050920084036.149"><vh>back/forwardWord &amp; helper</vh></v>
<v t="ekr.20050920084036.107"><vh>indentRegion</vh></v>
<v t="ekr.20050920084036.219"><vh>findNextMatch</vh>
<v t="ekr.20051005155611"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20051005160923"><vh>&lt;&lt; handle plain search &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20051012054228"><vh>Vim mode (k.vimMode)</vh></v>
<v t="ekr.20050928144501"><vh>Expand commands to handle Leo environment</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
</v>
<v t="ekr.20051015223107.2"><vh>Bugs 3</vh>
<v t="ekr.20051014104337.1"><vh>Crash in undo</vh></v>
<v t="ekr.20051014152256"><vh>Fix long-standing bug in import code</vh>
<v t="ekr.20040930075711"><vh>Handle underindented lines</vh></v>
<v t="ekr.20040722132104"><vh>Write script to report underindented lines</vh></v>
</v>
<v t="ekr.20051017132446"><vh>Hang in MacOS scripting</vh></v>
</v>
<v t="ekr.20050925105522"><vh>Big</vh>
<v t="ekr.20050928144501.1"><vh>Mouseless Leo</vh>
<v t="ekr.20050707085637"><vh>Suggestions from an emacs user</vh></v>
<v t="ekr.20050712092501.1"><vh>xemacs variables</vh>
<v t="ekr.20050712092501.2"><vh>top, bottom, left, right, horizontal vertical, gutter</vh></v>
<v t="ekr.20050712092501.5"><vh>prev...</vh>
<v t="ekr.20050712092501.6"><vh>*</vh></v>
<v t="ekr.20050712092501.7"><vh>:</vh></v>
<v t="ekr.20050712092501.8"><vh>abbrev-</vh></v>
<v t="ekr.20050712092501.9"><vh>after-</vh></v>
<v t="ekr.20050712092501.10"><vh>auto-</vh></v>
<v t="ekr.20050712092501.11"><vh>backup-</vh></v>
<v t="ekr.20050712092501.12"><vh>bbdb</vh></v>
<v t="ekr.20050712092501.13"><vh>before-</vh></v>
<v t="ekr.20050712092501.14"><vh>browse-url-</vh></v>
<v t="ekr.20050712092501.15"><vh>buffer</vh></v>
<v t="ekr.20050712092501.16"><vh>buffers-</vh></v>
<v t="ekr.20050712092501.17"><vh>cl-</vh></v>
<v t="ekr.20050712092501.18"><vh>command-</vh></v>
<v t="ekr.20050712092501.19"><vh>comment-</vh></v>
<v t="ekr.20050712092501.20"><vh>compilation</vh></v>
<v t="ekr.20050712092501.21"><vh>completion</vh></v>
<v t="ekr.20050712092501.22"><vh>configure</vh></v>
<v t="ekr.20050712092501.23"><vh>dabbrev- and dabbrev--</vh></v>
<v t="ekr.20050712094115"><vh>debug-</vh></v>
<v t="ekr.20050712094115.1"><vh>default-</vh></v>
<v t="ekr.20050712094115.2"><vh>global</vh></v>
<v t="ekr.20050712094115.3"><vh>help</vh></v>
<v t="ekr.20050712092501.24"><vh>isearch-</vh></v>
</v>
<v t="ekr.20050712092501.25"><vh>lisp</vh></v>
<v t="ekr.20050712092501.26"><vh>list-</vh></v>
<v t="ekr.20050712094115.4"><vh>load-</vh></v>
<v t="ekr.20050712092501.27"><vh>mail</vh></v>
<v t="ekr.20050712094115.5"><vh>message-</vh></v>
<v t="ekr.20050712092501.28"><vh>minibuffer-</vh></v>
<v t="ekr.20050712092501.29"><vh>mode-</vh></v>
<v t="ekr.20050712092501.30"><vh>modeline-</vh></v>
<v t="ekr.20050712092501.31"><vh>mouse-</vh></v>
<v t="ekr.20050712092501.32"><vh>mswindows-</vh></v>
<v t="ekr.20050712092501.33"><vh>package- &amp; packages-</vh></v>
<v t="ekr.20050712094115.6"><vh>paths-</vh></v>
<v t="ekr.20050712092501.34"><vh>regexp- &amp; search-</vh></v>
<v t="ekr.20050712092501.35"><vh>toolbar-</vh></v>
<v t="ekr.20050712094115.7"><vh>xwem</vh></v>
</v>
</v>
<v t="ekr.20051014161015"><vh>Full input modes</vh></v>
</v>
<v t="ekr.20051012062458.1"><vh>Minor</vh>
<v t="ekr.20050713105353"><vh>Add configuration setting to set menu fonts</vh>
<v t="ekr.20050713105353.1"><vh>Email from Martin Moncrieffe &lt;mcm35@cam.ac.uk&gt;</vh></v>
</v>
<v t="ekr.20050512031131"><vh>Use global_log_window_position to specify outline/log ratio?</vh></v>
<v t="ekr.20050916180203"><vh>Make more commands undoable</vh></v>
<v t="ekr.20051016155819"><vh>treat plugins/options.py  differently?</vh></v>
</v>
<v t="ekr.20051023192433"><vh>Maybe...</vh></v>
<v t="ekr.20051017140811"><vh>Original temac bindings</vh></v>
<v t="ekr.20051017140811.1"><vh>@url http://vimdoc.sourceforge.net/htmldoc/usr_03.html (vim must do all these)</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2415"><vh> Scripts</vh>
<v t="ekr.20040327103735.2"><vh>Script Tools (leoGlobals.py)</vh>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20040321065415"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
<v t="ekr.20050503112513.7" a="M"><vh>g.executeFile</vh>
<v t="ekr.20050503112513.8"><vh>&lt;&lt; define subprocess_wrapper &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040502195524"><vh>@thin ../scripts/leoScripts.txt</vh></v>
<v t="EKR.20040502194930"><vh>@thin ../scripts/tangle_done.py</vh></v>
<v t="ekr.20031218072017.2537"><vh>@thin ../scripts/untangle_done.py</vh></v>
</v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1" a="M"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>signOnWithVersion</vh></v>
</v>
<v t="ekr.20050123202520"><vh> Startup...</vh>
<v t="ekr.20050123202520.1"><vh>@button Settings...</vh></v>
<v t="ekr.20041226080857"><vh>@button Spell</vh></v>
<v t="ekr.20050130152155"><vh>@button Plugins...</vh></v>
<v t="ekr.20051025070441"><vh>@button Beautify</vh></v>
<v t="ekr.20051013103117"><vh>@button save</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"
marks="ekr.20031218072017.2619,"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20031218072017.2817,ekr.20040629121554.1,ekr.20040629121554.2,ekr.20040711135244.11,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20051025071455,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"
marks="ekr.20031218072017.2052,ekr.20050503112513.7,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
<v t="ekr.20050710142719"
marks="ekr.20051025071455,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20051025065958" a="TV"><vh>(Recent)</vh>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20050120092028.1"><vh>set_focus (tkFrame)</vh></v>
<v t="ekr.20051023094009"><vh>Search classes</vh>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__</vh>
<v t="ekr.20051020120306.12"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>find.createBindings</vh></v>
<v t="ekr.20051020120306.13"><vh>find.createFrame</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.19"><vh>find.init</vh>
<v t="ekr.20051020120306.20"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020120306.21"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020120306.22"><vh>find.update_ivars</vh></v>
<v t="ekr.20051023183028"><vh>findButtonCallback</vh></v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.27"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020120306.28"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20051020120306.1"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020120306.2"><vh>__init__</vh>
<v t="ekr.20051020120306.3"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.4"><vh>bindHotKey</vh></v>
<v t="ekr.20051020120306.5"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051022211617"><vh>find tab...</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>commands...</vh></v>
</v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler &amp; helper</vh>
<v t="ekr.20051002120125"><vh>&lt;&lt; do a non-incremental search &gt;&gt;</vh></v>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
</v>
<v t="ekr.20050920084036.267"><vh>non-incremental search...</vh>
<v t="ekr.20050920084036.269"><vh>seachForward/Backward &amp; helper</vh>
<v t="ekr.20050920084036.268"><vh>plainSearchHelper</vh></v>
</v>
<v t="ekr.20051002111614"><vh>wordSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.272"><vh>wordSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.274"><vh>reSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.275"><vh>reSearchHelper</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051025071455"><vh>Spell classes</vh>
<v t="ekr.20051025071455.3"><vh>&lt;&lt; specify aspell directories &gt;&gt;</vh></v>
<v t="ekr.20051025071455.1"><vh>class spellCommandsClass</vh>
<v t="ekr.20051025080056"><vh>ctor</vh></v>
<v t="ekr.20051025080420"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051025080633"><vh>openSpellTab</vh></v>
<v t="ekr.20051025080420.1"><vh>commands...</vh></v>
</v>
<v t="ekr.20051025071455.6"><vh>class Aspell</vh>
<v t="ekr.20051025071455.7"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.8"><vh>__init__</vh></v>
<v t="ekr.20051025071455.9"><vh>getAspellDirectory (not used)</vh></v>
</v>
<v t="ekr.20051025071455.10"><vh>processWord</vh></v>
<v t="ekr.20051025071455.11"><vh>updateDictionary</vh></v>
</v>
<v t="ekr.20051025071455.18"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20051025071455.19"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.20"><vh>spellTab.__init__</vh></v>
<v t="ekr.20051025094004"><vh>init_aspell</vh></v>
<v t="ekr.20051025071455.22"><vh>createSpellTab</vh>
<v t="ekr.20051025071455.23"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20051025071455.24"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025071455.16"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20051025071455.29"><vh>Buttons</vh>
<v t="ekr.20051025071455.30"><vh>onAddButton</vh></v>
<v t="ekr.20051025071455.31"><vh>onIgnoreButton</vh></v>
<v t="ekr.20051025071455.32"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20051025071455.33"><vh>onFindButton</vh></v>
<v t="ekr.20051025071455.34"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20051025071455.36"><vh>Commands</vh>
<v t="ekr.20051025071455.37"><vh>add</vh></v>
<v t="ekr.20051025071455.38"><vh>change</vh></v>
<v t="ekr.20051025071455.39"><vh>checkSpelling</vh></v>
<v t="ekr.20051025071455.40"><vh>find</vh></v>
<v t="ekr.20051025071455.41"><vh>ignore</vh></v>
</v>
<v t="ekr.20051025071455.42"><vh>Helpers</vh>
<v t="ekr.20051025071455.43"><vh>bringToFront</vh></v>
<v t="ekr.20051025071455.44"><vh>fillbox</vh></v>
<v t="ekr.20051025071455.45"><vh>findNextMisspelledWord</vh>
<v t="ekr.20051025071455.46"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025071455.47"><vh>findNextWord</vh></v>
<v t="ekr.20051025071455.48"><vh>getSuggestion</vh></v>
<v t="ekr.20051025071455.49"><vh>onMap</vh></v>
<v t="ekr.20051025071455.50"><vh>onSelectListBox</vh></v>
<v t="ekr.20051025071455.51"><vh>update</vh></v>
<v t="ekr.20051025071455.52"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040423082910">if 0:
    # Doing this here messes up the display in the log pane.
    if type(s) == type(u""):
        s = g.toEncodedString(s,g.app.TkEncoding)
        
# g.trace(repr(self.logCtrl))

if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
    
self.forceLogUpdate(s)</t>
<t tx="EKR.20040423082910.1">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040604090913"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")
            newSel = c.frame.body.getTextSelection() # Fixes crasher in undo logic.</t>
<t tx="ekr.20031218072017.838">def createBindings (self,frame):
    
    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    c = self.c ; t = self.bodyCtrl
    
    # Event handlers...
    t.bind("&lt;Button-1&gt;", frame.OnBodyClick)
    t.bind("&lt;Button-3&gt;", frame.OnBodyRClick)
    t.bind("&lt;Double-Button-1&gt;", frame.OnBodyDoubleClick)
    
    if sys.platform.startswith('win'):
        # Support Linux middle-button paste easter egg.
        t.bind("&lt;Button-2&gt;", frame.OnPaste)</t>
<t tx="ekr.20031218072017.839">def defineEditMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=[f]' # We define 'f' just in case.

    c = self.c ; f = self.frame
    
    self.editMenuTopTable = [
        ("Can't Undo",c.undoer.undo), # &amp;U reserved for Undo
        ("Can't Redo",c.undoer.redo), # &amp;R reserved for Redo
        ("-",None),
        ("Cu&amp;t",f.OnCutFromMenu), 
        ("Cop&amp;y",f.OnCopyFromMenu),
        ("&amp;Paste",f.OnPasteFromMenu),
        ("&amp;Delete",c.delete),
        ("Select &amp;All",f.body.selectAllText),
        ("-",None),
    ]

    # Top-level shortcuts here:  a,d,p,t,u,y,z
    # Top-level shortcuts later: e,g,n,v</t>
<t tx="ekr.20031218072017.840"></t>
<t tx="ekr.20031218072017.1321">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""
    
    __pychecker__ = 'maxlines=500'

    c = self.c
    if not c: return "break"
    if not p: return "break"
    if not c.isCurrentPosition(p): return "break"
    # g.trace(repr(ch))

    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        &lt;&lt; handle special characters &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    # g.trace(repr(ch),undoType)
    if undoType:
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"</t>
<t tx="ekr.20031218072017.1322"># Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20031218072017.1323">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20031218072017.1324">def doAutoIndent (self,p,removeTrailing,tab_width,undoType):
    
    __pychecker__ = '--no-argsused' # 'undoType' unused, but must be present.
    
    c = self.c
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # g.trace(repr(s))
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False
            
    return removeTrailing</t>
<t tx="ekr.20031218072017.1325">def convertBlanksToTabs (self,tab_width):

    c = self.c
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1:
        &lt;&lt; convert tab no matter where it is &gt;&gt;
    else:
        &lt;&lt; convert only leading tabs &gt;&gt;</t>
<t tx="ekr.20031218072017.1326">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # g.trace('no real change')
    return "break"</t>
<t tx="ekr.20031218072017.1327">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20031218072017.1328">redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
        redraw_flag = True
    # Update icons.
    val = p.computeIcon()
    # During unit tests the node may not have been drawn,
    # So p.v.iconVal may not exist yet.
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20031218072017.1330">def onBodyKey (self,event,undoType='Typing'):
    
    '''Handle any key press event in the body pane.'''

    # New in Leo 4.4.  May be called with event = None
    c = self.c
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''

    # g.trace(repr(ch),repr(event.keysym))

    # This translation is needed on MacOS.
    if ch == '':
        d = {'Return':'\r', 'Tab':'\t', 'BackSpace':chr(8)}
        ch = d.get(event.keysym,'')

    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()
        
    # We must execute this even if len(ch) &gt; 0 to delete spurious trailing newlines.
    self.c.frame.body.colorizer.interrupt()
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,ch)</t>
<t tx="ekr.20031218072017.1473"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    # print 'tkLog.put',self.c.shortFileName(),s,

    if g.app.quitting:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;</t>
<t tx="ekr.20031218072017.1561">def getTnode (self):

    # we have already matched &lt;t.
    index = -1 ; attrDict = {}

    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/&gt;'): # A collapsed tnode.
        return

    # Attributes may appear in any order.
    while 1:
        if self.matchTag("tx="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            index = self.getDqString()
        elif self.matchTag("rtf=\"1\""): pass # ignored
        elif self.matchTag("rtf=\"0\""): pass # ignored
        elif self.matchTag("&gt;"):         break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("tnode")
            if attr: attrDict[attr] = val
            
    # index might be Tnnn, nnn, or gnx.
    theId,time,n = g.app.nodeIndices.scanGnx(index,0)
    if time == None: # A pre-4.1 file index.
        if index[0] == "T":
            index = index[1:]

    index = self.canonicalTnodeIndex(index)
    t = self.tnodesDict.get(index)
    &lt;&lt; handle unknown attributes &gt;&gt;
    if t:
        s = self.getEscapedString()
        t.setTnodeText(s,encoding=self.leo_file_encoding)
    else:
        g.es("no tnode with index: %s.  The text will be discarded" % str(index))
    self.getTag("&lt;/t&gt;")</t>
<t tx="ekr.20031218072017.1564">keys = attrDict.keys()
if keys:
    t.unknownAttributes = attrDict
    if 0: # For debugging.
        s = "unknown attributes for tnode"
        g.es_print(s, color = "blue")
        for key in keys:
            s = "%s = %s" % (key,attrDict.get(key))
            g.es_print(s)</t>
<t tx="ekr.20031218072017.1566">def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = '' ; tnodeList = None ; attrDict = {}

    # we have already matched &lt;v.
    
    # New in Leo 4.4: support collapsed tnodes.
    if self.matchTag('/&gt;'): # A collapsed vnode.
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        return v
    
    while 1:
        if self.matchTag("a=\""):
            &lt;&lt; Handle vnode attribute bits &gt;&gt;
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = index = self.getDqString()
            if self.usingClipboard:
                &lt;&lt; raise invalidPaste if the tnode is in self.forbiddenTnodes &gt;&gt;
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2, deprecated for 4.3?
            s = self.getDqString()
            theDict = self.getDescendentUnknownAttributes(s)
            if theDict:
                self.descendentUnknownAttributesDictList.append(theDict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2.
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag("&gt;"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUa("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("&lt;vh&gt;"):
        headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
        if v: # Bug fix: 4/18/05: The headline may change during paste as clone.
            v.initHeadString(headline,encoding=self.leo_file_encoding)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.
            
    &lt;&lt; Set the remembered status bits &gt;&gt;

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("&lt;v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    &lt;&lt; Append to current or top stack &gt;&gt;

    # End this vnode.
    self.getTag("&lt;/v&gt;")
    return v</t>
<t tx="ekr.20031218072017.1567"># The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()</t>
<t tx="ekr.20031218072017.1568">if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()</t>
<t tx="ekr.20031218072017.1624">def createFrame (fileName):
    
    """Create a LeoFrame during Leo's startup process."""
    
    import leoGlobals as g
    
    # g.trace(repr(fileName))

    # Try to create a frame for the file.
    if fileName:
        if g.os_path_exists(fileName):
            # We have already read settings from this file.
            ok, frame = g.openWithFileName(fileName,None,readSettings=False)
            if ok:
                return frame.c,frame

    # Create a _new_ frame &amp; indicate it is the startup window.
    c,frame = g.app.gui.newLeoCommanderAndFrame(fileName=fileName)
    frame.setInitialWindowGeometry()
    frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # 5/13/05
    frame.startupWindow = True
    # 3/2/05: Call the 'new' hook for compatibility with plugins.
    g.doHook("new",old_c=None,c=c,new_c=c)

    # Report the failure to open the file.
    if fileName:
        g.es("File not found: " + fileName)

    return c,frame
</t>
<t tx="ekr.20031218072017.1627">def goPrevVisitedNode(self):
    
    c = self

    while c.beadPointer &gt; 0:
        c.beadPointer -= 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            c.frame.tree.idle_scrollTo(v)
            return
</t>
<t tx="ekr.20031218072017.1628">def goNextVisitedNode(self):
    
    c = self

    while c.beadPointer + 1 &lt; len(c.beadList):
        c.beadPointer += 1
        v = c.beadList[c.beadPointer]
        if v.exists(c):
            c.beginUpdate()
            try:
                c.frame.tree.expandAllAncestors(v)
                c.selectVnode(v,updateBeadList=False)
            finally:
                c.endUpdate()
            c.frame.tree.idle_scrollTo(v)
            return</t>
<t tx="ekr.20031218072017.1723">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.keyHandler
    
    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        rawKey,menu_shortcut = self.canonicalizeShortcut(accel)
        menuCallback = self.defineMenuCallback(command,commandName)
        realLabel = self.getRealMenuName(label)
        &lt;&lt; set amp_index using rawKey and realLabel &gt;&gt;
        realLabel = realLabel.replace("&amp;","")
        self.add_command(menu,label=realLabel,
            accelerator= menu_shortcut or '',
            command=menuCallback,underline=amp_index)</t>
<t tx="ekr.20031218072017.1725"># First, get the old-style name.
commandName = self.computeOldStyleShortcutKey(label)
rawKey,bunch = c.config.getShortcut(commandName)
accel = bunch and bunch.val

# Second, get new-style name.
if not accel:
    &lt;&lt; compute emacs_name &gt;&gt;
        # Contains the not-so-horrible kludge.
    if emacs_name:
        commandName = emacs_name
        rawKey,bunch = c.config.getShortcut(emacs_name)
        accel = bunch and bunch.val
    elif not dynamicMenu:
        g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20031218072017.1728">if rawKey:
    amp_index = rawKey.find("&amp;")
else:
    amp_index = -1

if amp_index == -1:
    amp_index = realLabel.find("&amp;")</t>
<t tx="ekr.20031218072017.1761">def insertHeadline (self,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try: # In update...
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
        c.editPosition(p) # Do this after before the redraw first.
        c.selectPosition(p)
    finally:
        c.endUpdate()
        c.editPosition(p) # Do this again after the redraw so p.edit_text() will succeed.
    return p # for mod_labels plugin.</t>
<t tx="ekr.20031218072017.1934">def run(fileName=None,*args,**keywords):
    
    """Initialize and run Leo"""
    
    __pychecker__ = '--no-argsused' # keywords not used.
    
    if not isValidPython(): return
    &lt;&lt; import leoGlobals and leoApp &gt;&gt;
    g.computeStandardDirectories()
    script = getBatchScript() # Do early so we can compute verbose next.
    verbose = script is None
    g.app.setLeoID(verbose=verbose) # Force the user to set g.app.leoID.
    &lt;&lt; import leoNodes and leoConfig &gt;&gt;
    g.app.nodeIndices = leoNodes.nodeIndices(g.app.leoID)
    g.app.config = leoConfig.configClass()
    fileName = completeFileName(fileName)
    reportDirectories(verbose)
    # Read settings *after* setting g.app.config.
    # Read settings *before* opening plugins.
    g.app.config.readSettingsFiles(fileName,verbose)
    g.app.setEncoding()
    if script:
        createNullGuiWithScript(script)
        fileName = None
    # Load plugins. Plugins may create g.app.gui.
    g.doHook("start1")
    if g.app.killed: return # Support for g.app.forceShutdown.
    # Create the default gui if needed.
    if g.app.gui == None:
        g.app.createTkGui() # Creates global windows.
    # Initialize tracing and statistics.
    g.init_sherlock(args)
    g.clear_stats()
    &lt;&lt; start psycho &gt;&gt;
    # New in 4.3: clear g.app.initing _before_ creating the frame.
    g.app.initing = False # "idle" hooks may now call g.app.forceShutdown.
    # Create the main frame.  Show it and all queued messages.
    c,frame = createFrame(fileName)
    if not frame: return
    if g.app.disableSave:
        g.es("disabling save commands",color="red")
    g.app.writeWaitingLog()
    p = c.currentPosition()
    g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
    g.enableIdleTimeHook()
    frame.tree.redraw()
    frame.body.setFocus()
    g.app.gui.runMainLoop()</t>
<t tx="ekr.20031218072017.1936">def isValidPython():

    message = """\
Leo requires Python 2.2.1 or higher.
You may download Python from http://python.org/download/
"""
    try:
        # This will fail if True/False are not defined.
        import leoGlobals as g
    except ImportError:
        print "isValidPython: can not import leoGlobals"
        return 0
    except:
        print "isValidPytyhon: unexpected exception: import leoGlobals.py as g"
        import traceback ; traceback.print_exc()
        return 0
    try:
        ok = g.CheckVersion(sys.version, "2.2.1")
        if not ok:
            print message
            g.app.gui.runAskOkDialog(None,"Python version error",message=message,text="Exit")
        return ok
    except:
        print "isValidPython: unexpected exception: g.CheckVersion"
        import traceback ; traceback.print_exc()
        return 0</t>
<t tx="ekr.20031218072017.1938">def createNullGuiWithScript (script):
    
    import leoGlobals as g
    import leoGui
    
    g.app.batchMode = True
    g.app.gui = leoGui.nullGui("nullGui")
    if not g.app.root:
        g.app.root = g.app.gui.createRootWindow()
    g.app.gui.finishCreate()
    g.app.gui.setScript(script)
</t>
<t tx="ekr.20031218072017.1939">def getBatchScript ():
    
    import leoGlobals as g
    
    name = None ; i = 1 # Skip the dummy first arg.
    while i + 1 &lt; len(sys.argv):
        arg = sys.argv[i].strip().lower()
        if arg in ("--script","-script"):
            name = sys.argv[i+1].strip() ; break
        i += 1

    if not name:
        return None
    name = g.os_path_join(g.app.loadDir,name)
    try:
        f = None
        try:
            f = open(name,'r')
            script = f.read()
            # g.trace("script",script)
        except IOError:
            g.es("can not open script file: " + name, color="red")
            script = None
    finally:
        if f: f.close()
        return script</t>
<t tx="ekr.20031218072017.2052">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True,readSettings=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            app.setLog(frame.log,"openWithFileName")
            # g.trace('Already open',fileName)
            return True, frame
    try:
        # g.trace('Not open',fileName)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.gui.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
            app.setLog(frame.log,"openWithFileName")
            app.lockLog()
            frame.c.fileCommands.open(
                theFile,fileName,
                readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
            app.unlockLog()
            for frame in g.app.windowList:
                # The recent files list has been updated by menu.updateRecentFiles.
                frame.c.config.setRecentFiles(g.app.config.recentFiles)
        # Bug fix in 4.4.
        frame.openDirectory = g.os_path_dirname(fileName)
        if readSettings:
            g.app.config.updateSettings(c,localFlag=True)
        g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20031218072017.2078">def createRecentFilesMenuItems (self):
    
    c = self.c
    recentFilesMenu = self.getMenu("Recent Files...")
    
    # Delete all previous entries.
    self.delete_range(recentFilesMenu,0,len(c.recentFiles)+2)
    
    # Create the first two entries.
    table = (
        ("Clear Recent Files",None,c.clearRecentFiles),
        ("-",None,None))
    self.createMenuEntries(recentFilesMenu,table)
    
    # Create all the other entries.
    i = 3
    for name in c.recentFiles:
        def recentFilesCallback (event=None,c=c,name=name):
            __pychecker__ = '--no-argsused' # event not used, but must be present.
            c.openRecentFile(name)
        label = "%d %s" % (i-2,g.computeWindowTitle(name))
        self.add_command(recentFilesMenu,label=label,command=recentFilesCallback,underline=0)
        i += 1</t>
<t tx="ekr.20031218072017.2098">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20031218072017.2099">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20031218072017.2100"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20031218072017.2101"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="ekr.20031218072017.2102">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20031218072017.2103">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20031218072017.2176">def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    g.app.setLog(f.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    f.body.createBindings(f)</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode

For more documentation, see the node called "Overview of Leo's code" in LeoDocs.leo.</t>
<t tx="ekr.20031218072017.2415"></t>
<t tx="ekr.20031218072017.2418">def initScriptFind(findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
        
    __pychecker__ = '--no-argsused' # firstNode is not used.
    
    import leoTest
    import leoGlobals as g

    # Find the scripts.
    c = g.top() ; p = c.currentPosition()
    u = leoTest.testUtils()
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    c.frame.findPanel.init(c)
    c.showFindPanel()</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.2887"></t>
<t tx="ekr.20031218072017.2888">def showFindPanel(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.bringToFront()</t>
<t tx="ekr.20031218072017.2889">def findNext(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findNextCommand(c)
</t>
<t tx="ekr.20031218072017.2890">def findPrevious(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.findPreviousCommand(c)
</t>
<t tx="ekr.20031218072017.2891">def replace(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeCommand(c)
</t>
<t tx="ekr.20031218072017.2892">def replaceThenFind(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeThenFindCommand(c)
</t>
<t tx="ekr.20031218072017.2898"></t>
<t tx="ekr.20031218072017.2899"></t>
<t tx="ekr.20031218072017.2900">def contractAllHeadlines (self):

    c = self
    
    c.beginUpdate()
    try: # update...
        for p in c.allNodes_iter():
            p.contract()
        # Select the topmost ancestor of the presently selected node.
        p = c.currentPosition()
        while p and p.hasParent():
            p.moveToParent()
        c.selectVnode(p)
    finally:
        c.endUpdate()

    c.expansionLevel = 1 # Reset expansion level.</t>
<t tx="ekr.20031218072017.2901">def contractNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.contract()
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20031218072017.2902">def contractParent (self):
    
    c = self ; v = c.currentVnode()
    parent = v.parent()
    if not parent: return
    
    c.beginUpdate()
    try:
        c.selectVnode(parent)
        parent.contract()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20031218072017.2903">def expandAllHeadlines(self):

    c = self ; v = root = c.rootVnode()
    c.beginUpdate()
    try:
        while v:
            c.expandSubtree(v)
            v = v.next()
        c.selectVnode(root)
    finally:
        c.endUpdate()
    c.expansionLevel = 0 # Reset expansion level.</t>
<t tx="ekr.20031218072017.2904">def expandAllSubheads (self):

    c = self ; v = c.currentVnode()
    if not v: return

    child = v.firstChild()
    c.beginUpdate()
    try:
        c.expandSubtree(v)
        while child:
            c.expandSubtree(child)
            child = child.next()
        c.selectVnode(v)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20031218072017.2905">def expandLevel1 (self): self.expandToLevel(1)
def expandLevel2 (self): self.expandToLevel(2)
def expandLevel3 (self): self.expandToLevel(3)
def expandLevel4 (self): self.expandToLevel(4)
def expandLevel5 (self): self.expandToLevel(5)
def expandLevel6 (self): self.expandToLevel(6)
def expandLevel7 (self): self.expandToLevel(7)
def expandLevel8 (self): self.expandToLevel(8)
def expandLevel9 (self): self.expandToLevel(9)
</t>
<t tx="ekr.20031218072017.2906">def expandNextLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(c.expansionLevel + 1)
</t>
<t tx="ekr.20031218072017.2907">def expandNode (self):
    
    c = self ; v = c.currentVnode()
    
    c.beginUpdate()
    try:
        v.expand()
    finally:
        c.endUpdate()

</t>
<t tx="ekr.20031218072017.2908">def expandPrevLevel (self):

    c = self ; v = c.currentVnode()
    
    # 1/31/02: Expansion levels are now local to a particular tree.
    if c.expansionNode != v:
        c.expansionLevel = 1
        c.expansionNode = v
        
    self.expandToLevel(max(1,c.expansionLevel - 1))
</t>
<t tx="ekr.20031218072017.2909"></t>
<t tx="ekr.20031218072017.2910">def contractSubtree (self,p):

    for p in p.subtree_iter():
        p.contract()</t>
<t tx="ekr.20031218072017.2911">def expandSubtree (self,v):

    c = self
    last = v.lastNode()
    while v and v != last:
        v.expand()
        v = v.threadNext()
    c.redraw()</t>
<t tx="ekr.20031218072017.2912">def expandToLevel (self,level):

    c = self
    c.beginUpdate()
    try:
        current = c.currentPosition()
        n = current.level()
        for p in current.self_and_subtree_iter():
            if p.level() - n + 1 &lt; level:
                p.expand()
            else:
                p.contract()
        c.expansionLevel = level
        c.expansionNode = c.currentPosition()
    finally:
        c.endUpdate()</t>
<t tx="ekr.20031218072017.2913"></t>
<t tx="ekr.20031218072017.2914">def goToFirstNode(self):
    
    c = self
    p = c.rootPosition()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20031218072017.2915">def goToLastNode(self):
    
    c = self ; p = c.rootPosition()
    while p and p.hasThreadNext(): # Bug fix: 10/12/05: was p.hasNext.
        p.moveToThreadNext()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()

</t>
<t tx="ekr.20031218072017.2916">def goToNextClone(self):

    c = self ; current = c.currentVnode()
    if not current: return
    if not current.isCloned(): return

    v = current.threadNext()
    while v and v.t != current.t:
        v = v.threadNext()
        
    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and v != current and v.t != current.t:
            v = v.threadNext()

    if v:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectVnode(v)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20031218072017.2917">def goToNextDirtyHeadline (self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isDirty():
        v = v.threadNext()

    if not v:
        # Wrap around.
        v = c.rootVnode()
        while v and not v.isDirty():
            v = v.threadNext()

    if v:
        c.selectVnode(v)
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20031218072017.2918">def goToNextMarkedHeadline(self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.threadNext()
    while v and not v.isMarked():
        v = v.threadNext()

    if v:
        c.beginUpdate()
        try:
            c.endEditing()
            c.selectVnode(v)
        finally:
            c.endUpdate()
    else:
        g.es("done",color="blue")</t>
<t tx="ekr.20031218072017.2919">def goToNextSibling(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    next = v.next()
    if next:
        c.beginUpdate()
        try:
            c.selectVnode(next)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20031218072017.2920">def goToParent(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    p = v.parent()
    if p:
        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20031218072017.2921">def goToPrevSibling(self):
    
    c = self
    v = c.currentVnode()
    if not v: return
    back = v.back()
    if back:
        c.beginUpdate()
        try:
            c.selectVnode(back)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20031218072017.2991"># Selects v: sets the focus to p and edits p.

def editPosition(self,p):

    c = self

    if p:
        c.selectVnode(p)
        c.frame.tree.editLabel(p)</t>
<t tx="ekr.20031218072017.2993">def selectThreadBack(self):

    c = self ; current = c.currentVnode()
    if not current: return
    
    v = current.threadBack()
    if v:
        c.beginUpdate()
        try:
            c.selectVnode(v)
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20031218072017.2994">def selectThreadNext(self):

    c = self ; current = c.currentPosition()
    if not current: return

    p = current.threadNext()
    if p:
        c.beginUpdate()
        try:
            c.selectPosition(p)
        finally:
            c.endUpdate()
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20031218072017.2995"># This has an up arrow for a control key.

def selectVisBack(self):

    c = self ; current = c.currentVnode()
    if not current: return

    v = current.visBack()
    if v:
        c.beginUpdate()
        try:
            c.selectVnode(v)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20031218072017.2996">def selectVisNext(self):

    c = self ; current = c.currentVnode()
    if not current: return
    
    v = current.visNext()
    if v:
        c.beginUpdate()
        try:
            c.selectVnode(v)
        finally:
            c.endUpdate()
</t>
<t tx="ekr.20031218072017.3197"></t>
<t tx="ekr.20031218072017.3198"># Returns optimized whitespace corresponding to width with the indicated tab_width.

def computeLeadingWhitespace (width, tab_width):

    if width &lt;= 0:
        return ""
    if tab_width &gt; 1:
        tabs   = width / tab_width
        blanks = width % tab_width
        return ('\t' * tabs) + (' ' * blanks)
    else: # 7/3/02: negative tab width always gets converted to blanks.
        return (' ' * width)</t>
<t tx="ekr.20031218072017.3199"># Returns the width of s, assuming s starts a line, with indicated tab_width.

def computeWidth (s, tab_width):
        
    w = 0
    for ch in s:
        if ch == '\t':
            w += (abs(tab_width) - (w % abs(tab_width)))
        else:
            w += 1
    return w</t>
<t tx="ekr.20031218072017.3200">def get_leading_ws(s):
    
    """Returns the leading whitespace of 's'."""

    i = 0 ; n = len(s)
    while i &lt; n and s[i] in (' ','\t'):
        i += 1
    return s[0:i]
</t>
<t tx="ekr.20031218072017.3201"># Optimize leading whitespace in s with the given tab_width.

def optimizeLeadingWhitespace (line,tab_width):

    i, width = g.skip_leading_ws_with_indent(line,0,tab_width)
    s = g.computeLeadingWhitespace(width,tab_width) + line[i:]
    return s</t>
<t tx="ekr.20031218072017.3202"># Remove whitespace up to first_ws wide in s, given tab_width, the width of a tab.

def removeLeadingWhitespace (s,first_ws,tab_width):

    j = 0 ; ws = 0
    for ch in s:
        if ws &gt;= first_ws:
            break
        elif ch == ' ':
            j += 1 ; ws += 1
        elif ch == '\t':
            j += 1 ; ws += (abs(tab_width) - (ws % abs(tab_width)))
        else: break
    if j &gt; 0:
        s = s[j:]
    return s</t>
<t tx="ekr.20031218072017.3203"># Warning: string.rstrip also removes newlines!

def removeTrailingWs(s):

    j = len(s)-1
    while j &gt;= 0 and (s[j] == ' ' or s[j] == '\t'):
        j -= 1
    return s[:j+1]
</t>
<t tx="ekr.20031218072017.3204"># Skips leading up to width leading whitespace.

def skip_leading_ws(s,i,ws,tab_width):

    count = 0
    while count &lt; ws and i &lt; len(s):
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i</t>
<t tx="ekr.20031218072017.3205">def skip_leading_ws_with_indent(s,i,tab_width):

    """Skips leading whitespace and returns (i, indent), 
    
    - i points after the whitespace
    - indent is the width of the whitespace, assuming tab_width wide tabs."""

    count = 0 ; n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch == ' ':
            count += 1
            i += 1
        elif ch == '\t':
            count += (abs(tab_width) - (count % abs(tab_width)))
            i += 1
        else: break

    return i, count</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3716">def getEditTextDict(self,v):
    # New in 4.2: the default is an empty list.
    return self.edit_text_dict.get(v,[])

def editPosition(self):
    return self._editPosition

def setEditPosition(self,p):
    self._editPosition = p</t>
<t tx="ekr.20031218072017.3752">def defineMenuTables (self):
    
    c = self.c
    
    self.defineEditMenuTables()
    self.defineFileMenuTables()
    self.defineOutlineMenuTables()
    self.defineWindowMenuTables()

    if self.useCmdMenu:
        self.defineEditorMenuTables()

    self.defineHelpMenuTables()</t>
<t tx="ekr.20031218072017.3753">def defineEditMenuTables (self):

    self.defineEditMenuTopTable()
    self.defineEditMenuEditCursorTable()
    self.defineEditMenuEditBodyTable()
    self.defineEditMenuEditHeadlineTable()
    self.defineEditMenuFindMenuTable()
    self.defineEditMenuTop2Table()</t>
<t tx="ekr.20031218072017.3754">def defineEditMenuEditBodyTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuEditBodyTable = [
        ("Extract &amp;Section",c.extractSection),
        ("Extract &amp;Names",c.extractSectionNames),
        ("&amp;Extract",c.extract),
        ("-",None,None),
        ("Convert All B&amp;lanks",c.convertAllBlanks),
        ("Convert All T&amp;abs",c.convertAllTabs),
        ("Convert &amp;Blanks",c.convertBlanks),
        ("Convert &amp;Tabs",c.convertTabs),
        ("Insert Body Time/&amp;Date",c.insertBodyTime),
        ("&amp;Reformat Paragraph",c.reformatParagraph),
        ("-",None,None),
        ("&amp;Indent",c.indentBody),
        ("&amp;Unindent",c.dedentBody),
        ("&amp;Match Brackets",c.findMatchingBracket),
        ("Add Comments",c.addComments),
        ("Delete Comments",c.deleteComments),
    ]
    # Shortcuts a,b,d,e,i,l,m,n,r,s,t,u</t>
<t tx="ekr.20031218072017.3755">def defineEditMenuEditHeadlineTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame
    
    self.editMenuEditHeadlineTable = [
        ("Edit &amp;Headline",c.editHeadline),
        ("&amp;End Edit Headline",f.endEditLabelCommand),
        ("&amp;Abort Edit Headline",f.abortEditLabelCommand),
        ("Insert Headline Time/&amp;Date",f.insertHeadlineTime),
        ("Toggle Angle Brackets",c.toggleAngleBrackets),
    ]</t>
<t tx="ekr.20031218072017.3756">def defineEditMenuFindMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.editMenuFindMenuTable = [
        ("&amp;Find Panel",c.showFindPanel),
        ("-",None),
        ("Find &amp;Next",c.findNext),
        ("Find &amp;Previous",c.findPrevious),
        ("&amp;Replace",c.replace),
        ("Replace, &amp;Then Find",c.replaceThenFind),
    ]</t>
<t tx="ekr.20031218072017.3757">def defineEditMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'

    c = self.c ; f = self.frame

    try:        show = c.frame.body.getColorizer().showInvisibles
    except:     show = False
    label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
        
    self.editMenuTop2Table = [
        ("&amp;Go To Line Number",c.goToLineNumber),
        ("&amp;Execute Script",c.executeScript),
        (label,c.viewAllCharacters),
        ("Setti&amp;ngs",c.preferences),
    ]

    # Top-level shortcuts earlier: a,d,p,t,u,y,z
    # Top-level shortcuts here: e,g,n,v</t>
<t tx="ekr.20031218072017.3758">def defineFileMenuTables (self):

    self.defineFileMenuTopTable()
    self.defineFileMenuTop2Table()
    self.defineFileMenuReadWriteMenuTable()
    self.defineFileMenuTangleMenuTable()
    self.defineFileMenuUntangleMenuTable()
    self.defineFileMenuImportMenuTable()
    self.defineFileMenuExportMenuTable()
    self.defineFileMenuTop3MenuTable()</t>
<t tx="ekr.20031218072017.3759">def defineFileMenuTopTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTopTable = [
        ("&amp;New",c.new),
        ("&amp;Open...",c.open),
    ]</t>
<t tx="ekr.20031218072017.3760">def defineFileMenuTop2Table (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop2Table = [
        ("-",None),
        ("&amp;Close",c.close),
        ("&amp;Save",c.save),
        ("Save &amp;As",c.saveAs),
        ("Save To",c.saveTo), # &amp;Tangle
        ("Re&amp;vert To Saved",c.revert), # &amp;Read/Write
    ]</t>
<t tx="ekr.20031218072017.3761">def defineFileMenuReadWriteMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame ; fc = c.fileCommands

    self.fileMenuReadWriteMenuTable = [
        ("&amp;Read Outline Only",c.readOutlineOnly),
        ("Read @file &amp;Nodes",c.readAtFileNodes),
        ("-",None),
        ("Write &amp;Dirty @file Nodes",fc.writeDirtyAtFileNodes),
        ("Write &amp;Missing @file Nodes",fc.writeMissingAtFileNodes),
        ("Write &amp;Outline Only",fc.writeOutlineOnly),
        ("&amp;Write @file Nodes",fc.writeAtFileNodes),
    ]</t>
<t tx="ekr.20031218072017.3762">def defineFileMenuTangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTangleMenuTable = [
        ("Tangle &amp;All",c.tangleAll),
        ("Tangle &amp;Marked",c.tangleMarked),
        ("&amp;Tangle",c.tangle),
    ]</t>
<t tx="ekr.20031218072017.3763">def defineFileMenuUntangleMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuUntangleMenuTable = [
        ("Untangle &amp;All",c.untangleAll),
        ("Untangle &amp;Marked",c.untangleMarked),
        ("&amp;Untangle",c.untangle),
    ]</t>
<t tx="ekr.20031218072017.3764">def defineFileMenuImportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuImportMenuTable = [
        ("Import Derived File",c.importDerivedFile),
        ("Import To @&amp;file",c.importAtFile),
        ("Import To @&amp;root",c.importAtRoot),
        ("Import &amp;CWEB Files",c.importCWEBFiles),
        ("Import &amp;noweb Files",c.importNowebFiles),
        ("Import Flattened &amp;Outline",c.importFlattenedOutline),
    ]</t>
<t tx="ekr.20031218072017.3765">def defineFileMenuExportMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuExportMenuTable = [
        ("Export &amp;Headlines",c.exportHeadlines),
        ("Outline To &amp;CWEB",c.outlineToCWEB),
        ("Outline To &amp;Noweb",c.outlineToNoweb),
        ("&amp;Flatten Outline",c.flattenOutline),
        ("&amp;Remove Sentinels",c.removeSentinels),
        ("&amp;Weave",c.weave),
    ]</t>
<t tx="ekr.20031218072017.3766">def defineFileMenuTop3MenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.fileMenuTop3MenuTable = [
        ("E&amp;xit",g.app.onQuit),
    ]</t>
<t tx="ekr.20031218072017.3767">def defineOutlineMenuTables (self):

    self.defineOutlineMenuTopMenuTable()
    self.defineOutlineMenuCheckOutlineMenuTable()
    self.defineOutlineMenuExpandContractMenuTable()
    self.defineOutlineMenuMoveMenuTable()
    self.defineOutlineMenuMarkMenuTable()
    self.defineOutlineMenuGoToMenuTable()</t>
<t tx="ekr.20031218072017.3768">def defineOutlineMenuTopMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuTopMenuTable = [
        ("C&amp;ut Node",c.cutOutline),
        ("C&amp;opy Node",c.copyOutline),
        ("&amp;Paste Node",c.pasteOutline),
        ("Pas&amp;te Node As Clone",c.pasteOutlineRetainingClones),
        ("&amp;Delete Node",c.deleteOutline),
        ("-",None,None),
        ("&amp;Insert Node",c.insertHeadline),
        ("&amp;Clone Node",c.clone),
        ("Sort Childre&amp;n",c.sortChildren), # Conflicted with Hoist.
        ("&amp;Sort Siblings",c.sortSiblings),
        ("-",None),
        ("&amp;Hoist",c.hoist),
        ("D&amp;e-Hoist",f.c.dehoist),
        ("-",None),
    ]
    # Ampersand bindings:  a,c,d,e,h,i,n,o,p,t,s,
    # Bindings for entries that go to submenus: a,g,k,m,x</t>
<t tx="ekr.20031218072017.3769">def defineOutlineMenuExpandContractMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuExpandContractMenuTable = [
        ("&amp;Contract All",c.contractAllHeadlines),
        ("Contract &amp;Node",c.contractNode),
        ("Contract &amp;Parent",c.contractParent),
        ("Contract Or Go Left",c.contractNodeOrGoToParent),
        ("-",None),
        ("Expand P&amp;rev Level",c.expandPrevLevel),
        ("Expand N&amp;ext Level",c.expandNextLevel),
        ("Expand And Go Right",c.expandNodeAndGoToFirstChild),
        ("Expand Or Go Right",c.expandNodeOrGoToFirstChild),
        ("-",None),
        ("Expand To Level &amp;1",c.expandLevel1),
        ("Expand To Level &amp;2",c.expandLevel2),
        ("Expand To Level &amp;3",c.expandLevel3),
        ("Expand To Level &amp;4",c.expandLevel4),
        ("Expand To Level &amp;5",c.expandLevel5),
        ("Expand To Level &amp;6",c.expandLevel6),
        ("Expand To Level &amp;7",c.expandLevel7),
        ("Expand To Level &amp;8",c.expandLevel8),
        ("-",None),
        ("Expand &amp;All",c.expandAllHeadlines),
        ("Expand N&amp;ode",c.expandNode),
    ]</t>
<t tx="ekr.20031218072017.3770">def defineOutlineMenuMoveMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMoveMenuTable = [
        ("Move &amp;Down",c.moveOutlineDown),
        ("Move &amp;Left",c.moveOutlineLeft),
        ("Move &amp;Right",c.moveOutlineRight),
        ("Move &amp;Up",c.moveOutlineUp),
        ("-",None),
        ("&amp;Promote",c.promote),
        ("&amp;Demote",c.demote),
    ]</t>
<t tx="ekr.20031218072017.3771">def defineOutlineMenuMarkMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuMarkMenuTable = [
        ("&amp;Mark",c.markHeadline),
        ("Mark &amp;Subheads",c.markSubheads),
        ("Mark Changed &amp;Items",c.markChangedHeadlines),
        ("Mark Changed &amp;Roots",c.markChangedRoots),
        ("Mark &amp;Clones",c.markClones),
        ("&amp;Unmark All",c.unmarkAll),
    ]</t>
<t tx="ekr.20031218072017.3772">def defineOutlineMenuGoToMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuGoToMenuTable = [
        ("Go Prev Visited",c.goPrevVisitedNode), # Usually use buttons for this.
        ("Go Next Visited",c.goNextVisitedNode),
        ("Go To Prev Node",c.selectThreadBack),
        ("Go To Next Node",c.selectThreadNext),
        ("-",None),
        ("Go To Next Marked",c.goToNextMarkedHeadline),
        ("Go To Next Changed",c.goToNextDirtyHeadline),
        ("Go To Next Clone",c.goToNextClone),
        ("-",None),
        ("Go To First Node",c.goToFirstNode),
        ("Go To Prev Visible",c.selectVisBack),
        ("Go To Next Visible",c.selectVisNext),
        ("Go To Last Node",c.goToLastNode),
        ('Go To Last Visible',c.goToLastVisibleNode),
        ("-",None),
        ("Go To Parent",c.goToParent),
        ('Go To First Sibling',c.goToFirstSibling),
        ('Go To Last Sibling',c.goToLastSibling),
        ("Go To Prev Sibling",c.goToPrevSibling),
        ("Go To Next Sibling",c.goToNextSibling),
    ]</t>
<t tx="ekr.20031218072017.3773">def defineWindowMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.windowMenuTopTable = [
        ("&amp;Equal Sized Panes",f.equalSizedPanes),
        ("Toggle &amp;Active Pane",f.toggleActivePane),
        ("Toggle &amp;Split Direction",f.toggleSplitDirection),
        ("-",None),
        ("Resize To Screen",f.resizeToScreen),
        ("Casca&amp;de",f.cascade),
        ("&amp;Minimize All",f.minimizeAll),
        ("-",None),
        ("Open &amp;Compare Window",c.openCompareWindow),
        ("Open &amp;Python Window",c.openPythonWindow),
    ]</t>
<t tx="ekr.20031218072017.3774">def defineHelpMenuTables (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.helpMenuTopTable = [
        ("&amp;About Leo...",c.about),
        ("Online &amp;Home Page",c.leoHome),
        ("Open Online &amp;Tutorial",c.leoTutorial),
    ]

    self.helpMenuTop2Table = [
        ("Open &amp;Offline Tutorial",f.leoHelp),
    ]

    self.helpMenuTop3Table = [
        ("-",None,None),
        ("Open Leo&amp;Docs.leo",c.leoDocumentation),
        ("Open Leo&amp;Plugins.leo",c.openLeoPlugins),
        ("Open Leo&amp;Settings.leo",c.openLeoSettings),
    ]</t>
<t tx="ekr.20031218072017.3781"></t>
<t tx="ekr.20031218072017.3782"># Returns the translation of a menu name or an item name.

def getRealMenuName (self,menuName):

    cmn = self.canonicalizeTranslatedMenuName(menuName)
    return g.app.realMenuNameDict.get(cmn,menuName)
    
def setRealMenuName (self,untrans,trans):

    cmn = self.canonicalizeTranslatedMenuName(untrans)
    g.app.realMenuNameDict[cmn] = trans

def setRealMenuNamesFromTable (self,table):

    try:
        for untrans,trans in table:
            self.setRealMenuName(untrans,trans)
    except:
        g.es("exception in setRealMenuNamesFromTable")
        g.es_exception()</t>
<t tx="ekr.20031218072017.3783">def canonicalizeMenuName (self,name):
    
    name = name.lower() ; newname = ""
    chars = string.ascii_letters + string.digits
    for ch in name:
        # if ch not in (' ','\t','\n','\r','&amp;'):
        if ch in chars:
            newname = newname+ch
    return newname
    
def canonicalizeTranslatedMenuName (self,name):
    
    name = name.lower() ; newname = ""
    for ch in name:
        if ch not in (' ','\t','\n','\r','&amp;'):
        # if ch in string.ascii_letters:
            newname = newname+ch
    return newname
</t>
<t tx="ekr.20031218072017.3784">def createMenuItemsFromTable (self,menuName,table):
    
    try:
        menu = self.getMenu(menuName)
        if menu == None:
            print "menu does not exist: ",menuName
            g.es("menu does not exist: ",menuName)
            return
        self.createMenuEntries(menu,table)
    except:
        s = "exception creating items for %s menu" % menuName
        g.es_print(s)
        g.es_exception()
        
    g.app.menuWarningsGiven = True</t>
<t tx="ekr.20031218072017.3785">def createMenusFromTables (self):
    
    c = self.c
    
    self.createFileMenuFromTable()
    self.createEditMenuFromTable()
    self.createOutlineMenuFromTable()
    
    g.doHook("create-optional-menus",c=c)
    
    if self.useCmdMenu:
        self.createEditorMenuFromTable()

    self.createWindowMenuFromTable()
    self.createHelpMenuFromTable()</t>
<t tx="ekr.20031218072017.3786">def createEditMenuFromTable (self):

    editMenu = self.createNewMenu("&amp;Edit")
    self.createMenuEntries(editMenu,self.editMenuTopTable)

    &lt;&lt; create the edit body submenu &gt;&gt;
    &lt;&lt; create the edit headline submenu &gt;&gt;
    &lt;&lt; create the find submenu &gt;&gt;
    
    self.createMenuEntries(editMenu,self.editMenuTop2Table)</t>
<t tx="ekr.20031218072017.3787">editBodyMenu = self.createNewMenu("Edit &amp;Body...","Edit")

self.createMenuEntries(editBodyMenu,self.editMenuEditBodyTable)</t>
<t tx="ekr.20031218072017.3788">editHeadlineMenu = self.createNewMenu("Edit &amp;Headline...","Edit")

self.createMenuEntries(editHeadlineMenu,self.editMenuEditHeadlineTable)</t>
<t tx="ekr.20031218072017.3789">findMenu = self.createNewMenu("&amp;Find...","Edit")

self.createMenuEntries(findMenu,self.editMenuFindMenuTable)</t>
<t tx="ekr.20031218072017.3790">def createFileMenuFromTable (self):
    
    c = self.c
    fileMenu = self.createNewMenu("&amp;File")
    self.createMenuEntries(fileMenu,self.fileMenuTopTable)
    self.createNewMenu("Open &amp;With...","File")
    self.createMenuEntries(fileMenu,self.fileMenuTop2Table)
    &lt;&lt; create the recent files submenu &gt;&gt;
    self.add_separator(fileMenu)
    &lt;&lt; create the read/write submenu &gt;&gt;
    &lt;&lt; create the tangle submenu &gt;&gt;
    &lt;&lt; create the untangle submenu &gt;&gt;
    &lt;&lt; create the import submenu &gt;&gt;
    &lt;&lt; create the export submenu &gt;&gt;
    self.add_separator(fileMenu)
    self.createMenuEntries(fileMenu,self.fileMenuTop3MenuTable)</t>
<t tx="ekr.20031218072017.3791">self.createNewMenu("Recent &amp;Files...","File")
c.recentFiles = c.config.getRecentFiles()

if 0: # Not needed, and causes problems in wxWindows...
    self.createRecentFilesMenuItems()</t>
<t tx="ekr.20031218072017.3792">readWriteMenu = self.createNewMenu("&amp;Read/Write...","File")

self.createMenuEntries(readWriteMenu,self.fileMenuReadWriteMenuTable)</t>
<t tx="ekr.20031218072017.3793">tangleMenu = self.createNewMenu("&amp;Tangle...","File")

self.createMenuEntries(tangleMenu,self.fileMenuTangleMenuTable)</t>
<t tx="ekr.20031218072017.3794">untangleMenu = self.createNewMenu("&amp;Untangle...","File")

self.createMenuEntries(untangleMenu,self.fileMenuUntangleMenuTable)</t>
<t tx="ekr.20031218072017.3795">importMenu = self.createNewMenu("&amp;Import...","File")

self.createMenuEntries(importMenu,self.fileMenuImportMenuTable)</t>
<t tx="ekr.20031218072017.3796">exportMenu = self.createNewMenu("&amp;Export...","File")

self.createMenuEntries(exportMenu,self.fileMenuExportMenuTable)</t>
<t tx="ekr.20031218072017.3797">def createOutlineMenuFromTable (self):

    outlineMenu = self.createNewMenu("&amp;Outline")
    
    self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)
    
    &lt;&lt; create check submenu &gt;&gt;
    &lt;&lt; create expand/contract submenu &gt;&gt;
    &lt;&lt; create move submenu &gt;&gt;
    &lt;&lt; create mark submenu &gt;&gt;
    &lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="ekr.20031218072017.3798">expandMenu = self.createNewMenu("E&amp;xpand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)</t>
<t tx="ekr.20031218072017.3799">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)</t>
<t tx="ekr.20031218072017.3800">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)</t>
<t tx="ekr.20031218072017.3801">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)</t>
<t tx="ekr.20031218072017.3802">def createWindowMenuFromTable (self):

    windowMenu = self.createNewMenu("&amp;Window")
    
    self.createMenuEntries(windowMenu,self.windowMenuTopTable)</t>
<t tx="ekr.20031218072017.3803">def createHelpMenuFromTable (self):

    helpMenu = self.createNewMenu("&amp;Help")
    
    self.createMenuEntries(helpMenu,self.helpMenuTopTable)
    
    if sys.platform=="win32":
        self.createMenuEntries(helpMenu,self.helpMenuTop2Table)
    
    self.createMenuEntries(helpMenu,self.helpMenuTop3Table)</t>
<t tx="ekr.20031218072017.3804">def createNewMenu (self,menuName,parentName="top",before=None):

    try:
        parent = self.getMenu(parentName) # parent may be None.
        menu = self.getMenu(menuName)
        if menu:
            g.es("menu already exists: " + menuName,color="red")
        else:
            menu = self.new_menu(parent,tearoff=0)
            self.setMenu(menuName,menu)
            label = self.getRealMenuName(menuName)
            amp_index = label.find("&amp;")
            label = label.replace("&amp;","")
            if before: # Insert the menu before the "before" menu.
                index_label = self.getRealMenuName(before)
                amp_index = index_label.find("&amp;")
                index_label = index_label.replace("&amp;","")
                index = parent.index(index_label)
                self.insert_cascade(parent,index=index,label=label,menu=menu,underline=amp_index)
            else:
                self.add_cascade(parent,label=label,menu=menu,underline=amp_index)
            return menu
    except:
        g.es("exception creating " + menuName + " menu")
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.3805">def deleteMenu (self,menuName):

    try:
        menu = self.getMenu(menuName)
        if menu:
            self.destroy(menu)
            self.destroyMenu(menuName)
        else:
            g.es("can't delete menu: " + menuName)
    except:
        g.es("exception deleting " + menuName + " menu")
        g.es_exception()</t>
<t tx="ekr.20031218072017.3806">def deleteMenuItem (self,itemName,menuName="top"):
    
    """Delete itemName from the menu whose name is menuName."""

    try:
        menu = self.getMenu(menuName)
        if menu:
            realItemName = self.getRealMenuName(itemName)
            self.delete(menu,realItemName)
        else:
            g.es("menu not found: " + menuName)
    except:
        g.es("exception deleting " + itemName + " from " + menuName + " menu")
        g.es_exception()</t>
<t tx="ekr.20031218072017.3807">def getMenu (self,menuName):

    cmn = self.canonicalizeMenuName(menuName)
    return self.menus.get(cmn)
    
def setMenu (self,menuName,menu):
    
    cmn = self.canonicalizeMenuName(menuName)
    self.menus [cmn] = menu
    
def destroyMenu (self,menuName):
    
    cmn = self.canonicalizeMenuName(menuName)
    del self.menus[cmn]</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3981">def abortEditLabelCommand (self):
    
    frame = self ; c = frame.c ; v = c.currentVnode() ; tree = frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return

    if self.revertHeadline and v.edit_text() and v == tree.editPosition():
    
        v.edit_text().delete("1.0","end")
        v.edit_text().insert("end",self.revertHeadline)
        tree.idle_head_key(v) # Must be done immediately.
        tree.revertHeadline = None
        if 1: # New code in 4.4a1.
            tree.endEditLabel()
            tree.select(tree.editPosition())
        else: # Old code:
            tree.select(v)
            if v and len(v.t.vnodeList) &gt; 0:
                tree.force_redraw() # force a redraw of joined headlines.</t>
<t tx="ekr.20031218072017.3982">def endEditLabelCommand (self):

    frame = self ; c = frame.c ; tree = frame.tree
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
        return
        
    if 1: # New code in 4.4a1.
        tree.endEditLabel()
        tree.select(tree.editPosition())
    else:
        v = frame.tree.editPosition()
        # g.trace(v)
        if v and v.edit_text():
            tree.select(v)
        if v: # Bug fix 10/9/02: also redraw ancestor headlines.
            tree.force_redraw() # force a redraw of joined headlines.

    frame.bodyWantsFocus()</t>
<t tx="ekr.20031218072017.3998">def createControl (self,frame,parentFrame):
    
    c = self.c

    wrap = c.config.getBool('body_pane_wraps')
    wrap = g.choose(wrap,"word","none")
    
    # Setgrid=1 cause severe problems with the font panel.
    body = Tk.Text(parentFrame,name='body-pane',
        bd=2,bg="white",relief="flat",setgrid=0,wrap=wrap)
    
    bodyBar = Tk.Scrollbar(parentFrame,name='bodyBar')
    frame.bodyBar = self.bodyBar = bodyBar
    body['yscrollcommand'] = bodyBar.set
    bodyBar['command'] = body.yview
    bodyBar.pack(side="right", fill="y")
    
    # Always create the horizontal bar.
    frame.bodyXBar = self.bodyXBar = bodyXBar = Tk.Scrollbar(
        parentFrame,name='bodyXBar',orient="horizontal")
    body['xscrollcommand'] = bodyXBar.set
    bodyXBar['command'] = body.xview
    self.bodyXbar = frame.bodyXBar = bodyXBar
    
    if wrap == "none":
        # g.trace(parentFrame)
        bodyXBar.pack(side="bottom", fill="x")
        
    body.pack(expand=1,fill="both")

    self.wrapState = wrap

    if 0: # Causes the cursor not to blink.
        body.configure(insertofftime=0)
        
    return body</t>
<t tx="ekr.20031218072017.4003">def hasFocus (self):
    
    return self.bodyCtrl == self.frame.top.focus_displayof()
    
def setFocus (self):
    
    self.bodyCtrl.focus_set()</t>
<t tx="ekr.20031218072017.4039">class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others</t>
<t tx="ekr.20031218072017.4040">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.tabMenu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
</t>
<t tx="ekr.20031218072017.4041">def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)</t>
<t tx="ekr.20031218072017.4042">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl
</t>
<t tx="ekr.20031218072017.4043">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font</t>
<t tx="ekr.20031218072017.4044">def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl</t>
<t tx="ekr.20031218072017.4045">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20031218072017.4046">def setFontFromConfig (self):

    c = self.c ; logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant",  "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)
    
    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass
    
    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass</t>
<t tx="ekr.20031218072017.4116">@ Entries in the table passed to createOpenWithMenuFromTable are
tuples of the form (commandName,shortcut,data).

- command is one of "os.system", "os.startfile", "os.spawnl", "os.spawnv" or "exec".
- shortcut is a string describing a shortcut, just as for createMenuItemsFromTable.
- data is a tuple of the form (command,arg,ext).

Leo executes command(arg+path) where path is the full path to the temp file.
If ext is not None, the temp file has the given extension.
Otherwise, Leo computes an extension based on the @language directive in effect.
@c

def createOpenWithMenuFromTable (self,table):

    c = self.c
    g.app.openWithTable = table # Override any previous table.
    # Delete the previous entry.
    parent = self.getMenu("File")
    label = self.getRealMenuName("Open &amp;With...")
    amp_index = label.find("&amp;")
    label = label.replace("&amp;","")
    try:
        index = parent.index(label)
        parent.delete(index)
    except:
        try:
            index = parent.index("Open With...")
            parent.delete(index)
        except: return
    # Create the Open With menu.
    openWithMenu = self.createOpenWithMenu(parent,label,index,amp_index)
    self.setMenu("Open With...",openWithMenu)
    # Create the menu items in of the Open With menu.
    for entry in table:
        if len(entry) != 3: # 6/22/03
            g.es("createOpenWithMenuFromTable: invalid data",color="red")
            return
    self.createOpenWithMenuItemsFromTable(openWithMenu,table)
    for entry in table:
        name,shortcut,data = entry
        c.keyHandler.bindOpenWith (shortcut,name,data)
</t>
<t tx="ekr.20031218072017.4117">def defineMenuCallback(self,command,name):
    
    # The first parameter must be event, and it must default to None.
    def menuCallback(event=None,self=self,command=command,label=name):
        __pychecker__ = '--no-argsused' # event not used, and must be present.
        return self.c.doCommand(command,label)

    return menuCallback</t>
<t tx="ekr.20031218072017.4118">def defineOpenWithMenuCallback(self,data):
    
    # The first parameter must be event, and it must default to None.
    def openWithMenuCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event param must be present.
        return self.c.openWith(data=data)

    return openWithMenuCallback</t>
<t tx="ekr.20040105223536">def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)&gt;0:
        &lt;&lt; trace the key event &gt;&gt;

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status</t>
<t tx="ekr.20040105223536.1">try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state &lt; 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)</t>
<t tx="ekr.20040321065415">def findNodeInTree(p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    c = p.c
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(headline):
    
    c = g.top()
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(headline):
    
    c = g.top()
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20040326055828">if not setCurrent and len(self.currentVnodeStack) &gt; 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) &gt; 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)</t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040411081633">if g.app and g.app.use_psyco:
    try:
        import psyco
        if 0:
            theFile = r"c:\prog\test\psycoLog.txt"
            g.es("psyco now logging to",theFile,color="blue")
            psyco.log(theFile)
            psyco.profile()
        psyco.full()
        g.es("psyco now running",color="blue")
    except ImportError:
        pass
    except:
        print "unexpected exception importing psyco"
        g.es_exception()</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 alpha 1, build %s, October 15, 2005" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.310 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, %s" % (n1,n2,n3,tkLevel,sys.platform))
    g.enl()</t>
<t tx="ekr.20040711140738">def defineOutlineMenuCheckOutlineMenuTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    self.outlineMenuCheckOutlineMenuTable = [
        ("Check &amp;Outline",c.checkOutline),
        ("&amp;Dump Outline",c.dumpOutline),
        ("-",None),
        ("Check &amp;All Python Code",c.checkAllPythonCode),
        ("&amp;Check Python &amp;Code",c.checkPythonCode),
        ("-",None),
        ("Pretty P&amp;rint All Python Code",c.prettyPrintAllPythonCode),
        ("&amp;Pretty Print Python Code",c.prettyPrintPythonCode),
    ]
    # shortcuts used: a,c,d,o,p,r</t>
<t tx="ekr.20040711140738.1">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)</t>
<t tx="ekr.20040722132104"></t>
<t tx="ekr.20040723093558">@

The caller should call g.stripBlankLines before calling this routine if desired.

This routine does _not_ simply call rstrip(): that would delete all trailing whitespace-only lines, and in some cases that would change the meaning of program or data.

@c

def regularizeTrailingNewlines(s,kind):
    
    """Kind is 'asis', 'zero' or 'one'."""
    
    pass</t>
<t tx="ekr.20040723093558.1">def stripBlankLines(s):
    
    lines = g.splitLines(s)

    for i in xrange(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j &gt;= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))
            
    return ''.join(lines)
</t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20040803072955.11">def newText (self,p,x,y):
    
    canvas = self.canvas ; tag = "textBox"
    c = self.c ; d = self.freeText
    key = p.v ; assert key
    pList = d.get(key,[])
    
    # Return only Tk.Text widgets with an exact match with p.
    found = False
    for i in xrange(len(pList)):
        p2,t,theId = pList[i]
        if p2 == p:
            del pList[i]
            theId = t.leo_window_id
            assert(theId)
            assert(t.leo_position == p2)
            canvas.coords(theId,x,y)
            t.configure(font=self.font) # 12/17/04
            found = True ; break
            
    if not found:
        # Tags are not valid in Tk.Text widgets.
        # The name is valid, but apparently it must be unique.
        self.textNumber += 1
        t = Tk.Text(canvas,name='head-%d' % self.textNumber,
            state="normal",font=self.font,bd=0,relief="flat",height=1)
    
        if self.useBindtags:
            t.bindtags(self.textBindings)
        else:
            c.keyHandler.copyBindingsToWidget('all',t)
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)

        if 0: # As of 4.4 this does not appear necessary.
            t.bind("&lt;Control-t&gt;",self.onControlT)

        if 0: # Crashes on XP.
            &lt;&lt; patch by Maciej Kalisiak to handle scroll-wheel events &gt;&gt;
    
        theId = canvas.create_window(x,y,anchor="nw",window=t,tag=tag)
        t.leo_window_id = theId # Never changes.
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),self.textAddr(t),align=-20)

    # Common configuration.
    # We must call setText even if p matches: p's text may have changed!
    self.setText(t,p.headString())
    t.configure(width=self.headWidth(p))
    t.leo_position = p # Never changes.
    t.leo_generation = self.generation

    assert(theId == t.leo_window_id)
    assert(not self.ids.get(theId))
    self.ids[theId] = p
    
    # Entries are pairs (p,t,theId) indexed by v.
    key = p.v ; assert key
    pList = self.visibleText.get(key,[])
    pList.append((p,t,theId),)
    self.visibleText[key] = pList
    return t</t>
<t tx="ekr.20040803072955.20">def createPermanentBindings (self):
    
    c = self.c ; canvas = self.canvas
    
    canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','&lt;Button-1&gt;', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','&lt;Button-1&gt;',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','&lt;Button-1&gt;', self.onIconBoxClick)
    canvas.tag_bind('iconBox','&lt;Double-1&gt;', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','&lt;Button-3&gt;', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','&lt;B1-Motion&gt;',            self.onDrag)
    canvas.tag_bind('iconBox','&lt;Any-ButtonRelease-1&gt;',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = self.bindingWidget
        t.bind("&lt;Button-1&gt;", self.onHeadlineClick, '+')
        t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick, '+')
        t.bind("&lt;Key&gt;",      self.onHeadlineKey)
            # There must be only one general key handler.

        if 0: # This does not appear necessary in 4.4.
            t.bind("&lt;Control-t&gt;",self.onControlT)</t>
<t tx="ekr.20040803072955.39">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20040803072955.40">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20040803072955.75">def edit_text (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)</t>
<t tx="ekr.20040803072955.76"># Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c
    
    if c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.visibleText.get(p.v,[])
        for p2,t2,id2 in pairs:
            assert t2.leo_window_id == id2
            assert t2.leo_position == p2
            if p.equal(p2):
                # g.trace('found',t2)
                return t2
        
    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20040803072955.87">def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    # g.trace(p.headString())
    
    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.88">def onHeadlineKey (self,event):
    
    """Handle a key event in a headline."""
    
    w = event.widget ; ch = event.char
    
    # g.trace(repr(ch))

    try:
        p = w.leo_position
    except AttributeError:
        g.trace('error *****')
        return "continue"

    return self.c.frame.bodyCtrl.after_idle(self.idle_head_key,p,ch)</t>
<t tx="ekr.20040803072955.91">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c ; u = c.undoer
    
    # g.trace(p.headString(),'isCurrent',p.isCurrentPosition())

    if not p or not p.isCurrentPosition():
        return "break"

    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    head = g.toUnicode(p.headString() or u'',"utf-8")
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        undoData = u.beforeChangeNodeContents(p)
        &lt;&lt; update p &gt;&gt;
        u.afterChangeNodeContents(p,'Change Headline',undoData,dirtyVnodeList=dirtyVnodeList)
    if done or changed:
        &lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
    return "break"</t>
<t tx="ekr.20040803072955.93">self.setText(edit_text,head)
edit_text.mark_set("insert",index)</t>
<t tx="ekr.20040803072955.94">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    limit = 1000
    if len(s) &gt; limit:
        g.es("Truncating headline to %d characters" % (limit),color="blue")
        s = s[:limit]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20040803072955.95">c.beginUpdate()
try: # In update...
    # Update changed bit.
    if not c.changed: c.setChanged(True)
    # We must call p.setDirty even if p is dirty!
    dirtyVnodeList = p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s)
    edit_text.mark_set("insert",index)
finally:
    c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20040803072955.96"># Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))</t>
<t tx="ekr.20040803072955.97">if done:
    # g.trace("done")
    c.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20040803072955.105">def OnActivateHeadline (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(p.headString())

    try:
        c = self.c
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20040803072955.106">if p == c.currentPosition():
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus(later=False)
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        c.frame.bodyWantsFocus()

self.active = True</t>
<t tx="ekr.20040803072955.108">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        try:
            tree.endEditLabel()
            tree.dimEditLabel()
        except:
            g.es_event_exception("deactivate tree")
</t>
<t tx="ekr.20040803072955.125"></t>
<t tx="ekr.20040803072955.126">def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; frame = c.frame
    
    p = self.editPosition()
    
    # g.trace(p and p.headString())

    if p and p.edit_text():
        if 0: # New in recycled widgets scheme: this could cause a race condition.
            # This will be done in the redraw code becaused editPosition will be None.
            self.setUnselectedLabelState(p)

        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        frame.bodyWantsFocus()</t>
<t tx="ekr.20040803072955.127">def editLabel (self,p):
    
    """Start editing p.edit_text."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()
        self.frame.revertHeadline = None
        
    self.setEditPosition(p)
    
    # g.trace(p,p.edit_text())

    # Start editing
    if p and p.edit_text():
        self.setNormalLabelState(p)
        self.frame.revertHeadline = p.headString()
        self.setEditPosition(p)
        self.frame.headlineWantsFocus(p)</t>
<t tx="ekr.20040803072955.128"># Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    
    # g.trace(p.headString())

    if not p: return
    if not p.exists(c):
        g.trace(g.callerList(5),'does not exist',p)
        return

    # g.trace('len(body)',len(p.bodyString()),p.headString())

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    # g.printGc()</t>
<t tx="ekr.20040803072955.129"># Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        # g.trace("unselect:",old_p.headString())
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20040803072955.130">frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20040803072955.131">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20040803072955.132"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20040803072955.133">c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()</t>
<t tx="ekr.20040803072955.134"></t>
<t tx="ekr.20040803072955.135">def setNormalLabelState (self,p): # selected, editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 
    
    if p and p.edit_text():
        self.setEditHeadlineColors(p)
        p.edit_text().tag_remove("sel","1.0","end")
        p.edit_text().tag_add("sel","1.0","end")
        
        # self.frame.headlineWantsFocus(p,later=False)</t>
<t tx="ekr.20040803072955.136">def setDisabledLabelState (self,p): # selected, disabled

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return

    if p and p.edit_text():
        self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20040803072955.137">def setSelectedLabelState (self,p): # selected, not editing

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    # g.trace(p)
    self.setDisabledLabelState(p)

</t>
<t tx="ekr.20040803072955.138">def setUnselectedLabelState (self,p): # not selected.

    # Do nothing if a redraw is already sheduled.
    # This prevents race conditions.
    if self.redrawScheduled: return 

    if p and p.edit_text():
        # g.trace(p.headString())
        self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20040803072955.139">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.140">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.141">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.142"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setDisabledLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20040803072955.143">def expandAllAncestors (self,p):
    
    redraw_flag = False

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag</t>
<t tx="ekr.20040930064232">def contractNodeOrGoToParent(self):
    
    """Simulate the left Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
 
    if p.hasChildren() and p.isExpanded():
        c.contractNode()
    elif p.hasParent():
        c.goToParent()</t>
<t tx="ekr.20040930064232.1">def expandNodeAndGoToFirstChild(self):
    
    """If a node has children, expand it if needed and go to the first child."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren():
        return

    if not p.isExpanded():
        c.expandNode()
        
    c.beginUpdate()
    try:
        c.selectVnode(p.firstChild())
    finally:
        c.endUpdate()
        
def expandNodeOrGoToFirstChild(self):
    
    """Simulate the Right Arrow Key in folder of Windows Explorer."""

    c = self ; p = c.currentPosition()
    if not p.hasChildren(): return

    if not p.isExpanded():
        c.expandNode()
    else:
        c.beginUpdate()
        try:
            c.selectVnode(p.firstChild())
        finally:
            c.endUpdate()</t>
<t tx="ekr.20040930075711">@nocolor

Leo can't represent some files using nodes!

I call this the "underindented blank line" problem.

Example:

@color

class aClass:
    def spam(): pass
# comment line
    def eggs(): pass
    
@nocolor

Leo's import code can't handle this:
    
- If the import code puts the comment line in a node, the line won't be output with the proper indentation!!

- Having the comment line stop the scanning of aClass is even worse.

- This usually shows up with an unindented blank line instead of the comment line.</t>
<t tx="ekr.20041023110111"># Bug fix in 4.3 a1: make sure we have valid paste.
theId,time,n = g.app.nodeIndices.scanGnx(index,0)
if not time and index[0] == "T":
    index = index[1:]
    
index = self.canonicalTnodeIndex(index)
t = self.tnodesDict.get(index)

if t in self.forbiddenTnodes:
    # g.trace(t)
    raise invalidPaste</t>
<t tx="ekr.20041117062717.14">def getShortcut (self,c,shortcutName):
    
    '''Return rawKey,accel for shortcutName'''
    
    key = c.frame.menu.canonicalizeMenuName(shortcutName)
    key = key.replace('&amp;','') # Allow '&amp;' in names.

    bunch = self.get(c,key,"shortcut")
    if bunch and bunch.val:
        # g.trace(bunch.pane,key,repr(bunch.val))
        if bunch.val.lower() == 'none':
            return key,None
        else:
            return key,bunch
    else:
        return key,None</t>
<t tx="ekr.20041117083141">def get (self,c,setting,kind):
    
    """Get the setting and make sure its type matches the expected type."""
    
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            val,junk = self.getValFromDict(d,setting,kind)
            if val is not None:
                # g.trace(c.shortFileName(),setting,val)
                return val
                
    for d in self.localOptionsList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val

    for d in self.dictList:
        val,junk = self.getValFromDict(d,setting,kind)
        if val is not None:
            kind = d.get('_hash','&lt;no hash&gt;')
            # g.trace(kind,setting,val)
            return val

    return None</t>
<t tx="ekr.20041117083857.1"># Called to read all leoSettings.leo files.
# Also called when opening an .leo file to read @settings tree.

def readSettings (self,c):
    
    """Read settings from a file that may contain an @settings tree."""
    
    # g.trace(c.fileName())
    
    # Create a settings dict for c for set()
    if c and self.localOptionsDict.get(c.hash()) is None:
        self.localOptionsDict[c.hash()] = {}

    parser = settingsTreeParser(c)
    d = parser.traverse()

    return d</t>
<t tx="ekr.20041117085625">def openSettingsFile (self,path):
    
    try:
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(path,'rb')
    except IOError:
        g.es("can not open: " + path, color="blue")
        return None
        
    # Similar to g.openWithFileName except it uses a null gui.
    # Changing g.app.gui here is a major hack.
    oldGui = g.app.gui
    g.app.gui = leoGui.nullGui("nullGui")
    c,frame = g.app.gui.newLeoCommanderAndFrame(path,updateRecentFiles=False)
    frame.log.enable(False)
    g.app.setLog(frame.log,"openWithFileName")
    g.app.lockLog()
    ok = frame.c.fileCommands.open(
        theFile,path,readAtFileNodesFlag=False,silent=True) # closes theFile.
    g.app.unlockLog()
    frame.openDirectory = g.os_path_dirname(path)
    g.app.gui = oldGui
    return ok and c</t>
<t tx="ekr.20041117093246"></t>
<t tx="ekr.20041118084146"></t>
<t tx="ekr.20041118084146.1">def set (self,c,setting,kind,val):
    
    '''Set the setting.  Not called during initialization.'''

    found = False ;  key = self.munge(setting)
    if c:
        d = self.localOptionsDict.get(c.hash())
        if d: found = True

    if not found:
        theHash = c.hash()
        for d in self.localOptionsList:
            hash2 = d.get('_hash')
            if theHash == hash2:
                found = True ; break

    if not found:
        d = self.dictList [0]

    d[key] = g.Bunch(setting=setting,kind=kind,val=val,tag='setting')
    # g.trace(d.get(key).toString())

    if 0:
        dkind = d.get('_hash','&lt;no hash: %s&gt;' % c.hash())
        g.trace(dkind,setting,kind,val)</t>
<t tx="ekr.20041118084241">def setString (self,c,setting,val):
    
    self.set(c,setting,"string",val)</t>
<t tx="ekr.20041118195812"></t>
<t tx="ekr.20041118195812.2">def set (self,p,setting,val):
    
    __pychecker__ = '--no-argsused' # p not used.
    
    return g.app.config.setString(self.c,setting,val)
    
setString = set</t>
<t tx="ekr.20041118195812.3">def setRecentFiles (self,files):
    
    '''Update the recent files list.'''

    # Append the files to the global list.
    g.app.config.appendToRecentFiles(files)</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041120064303">def readSettingsFiles (self,fileName,verbose=True):
    
    seen = []
    
    # Init settings from leoSettings.leo files.
    for path,localFlag in (
        (self.globalConfigFile,False),
        (self.homeFile,False),
        (fileName,True),
    ):
        if path and path.lower() not in seen:
            seen.append(path.lower())
            if verbose:
                g.es_print('reading settings in %s' % path)
            c = self.openSettingsFile(path)
            if c:
                self.updateSettings(c,localFlag)
                g.app.destroyWindow(c.frame)
            self.readRecentFilesFile(path)

    self.inited = True
    self.setIvarsFromSettings(None)</t>
<t tx="ekr.20041120094940.9">def set (self,p,kind,name,val):
    
    """Init the setting for name to val."""
    
    __pychecker__ = '--no-argsused' # p used in subclasses, not here.
    
    c = self.c ; key = self.munge(name)
    # g.trace("settingsParser %10s %15s %s" %(kind,val,name))
    d = self.settingsDict
    bunch = d.get(key)
    if bunch:
        # g.trace(key,bunch.val,bunch.path)
        path = bunch.path
        if g.os_path_abspath(c.mFileName) != g.os_path_abspath(path):
            g.es("over-riding setting: %s from %s" % (name,path))

    # N.B.  We can't use c here: it may be destroyed!
    d[key] = g.Bunch(path=c.mFileName,kind=kind,val=val,tag='setting')
    
    # g.trace('parserBaseClass',g.shortFileName(c.mFileName),key,val)</t>
<t tx="ekr.20041120105609">def doShortcuts(self,p,kind,name,val):
    
    __pychecker__ = '--no-argsused' # kind,val not used.
    
    d = {} # To detect duplicates.
    s = p.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        line = line.strip()
        if line and not g.match(line,0,'#'):
            name,bunch = self.parseShortcutLine(line)
            # g.trace(name,bunch)
            if bunch is not None:
                if d.get(name):
                    g.es('ignoring duplicate @shortcuts entry: %s' % (
                        name), color='blue')
                else:
                    d [name] = bunch
                    self.set(p,"shortcut",name,bunch)
                    self.setShortcut(name,bunch)</t>
<t tx="ekr.20041120112043">def parseShortcutLine (self,s):
    
    '''Parse a shortcut line.  Valid forms:
        
    settingName = shortcut
    settingName ! paneName = shortcut'''
    
    name = val = None
    j = g.skip_ws(s,0)
    i = g.skip_id(s,j,'-') # New in 4.4: allow Emacs-style shortcut names.
    name = s[j:i]
    if not name: return None,None
        
    i = g.skip_ws(s,i)
    if g.match(s,i,'!'): # New in 4.4: allow pane-specific shortcuts.
        j = g.skip_ws(s,i+1)
        i = g.skip_id(s,j)
        pane = s[j:i]
        if not pane.strip(): pane = 'all'
    else: pane = 'all'

    i = g.skip_ws(s,i)
    if g.match(s,i,'='):
        i = g.skip_ws(s,i+1)
        val = s[i:]
           
    # New in 4.4: Allow comments after the shortcut.
    # Comments must be preceded by whitespace. 
    if val:
        i = val.find('#')
        if i &gt; 0 and val[i-1] in (' ','\t'):
            val = val[:i].strip()

    # g.trace(pane,name,val,s)
    return name,g.bunch(pane=pane,val=val)</t>
<t tx="ekr.20041121143823">def getValFromDict (self,d,setting,requestedType,warn=True):
    
    '''Look up the setting in d. If warn is True, warn if the requested type
    does not (loosely) match the actual type.
    returns (val,exists)'''

    bunch = d.get(self.munge(setting))
    if not bunch: return None,False

    # g.trace(setting,requestedType,bunch.toString())
    val = bunch.val
    if not self.typesMatch(bunch.kind,requestedType):
        # New in 4.4: make sure the types match.
        # A serious warning: one setting may have destroyed another!
        # Important: this is not a complete test of conflicting settings:
        # The warning is given only if the code tries to access the setting.
        if warn:
            s = (
                'Warning: ignoring %s:%s not %s\n' +
                'There may be conflicting settings!')
            g.es_print(s % (bunch.kind,setting,requestedType),color='red')
        return None, False
    elif val in (u'None',u'none','None','none','',None):
        return None, True # Exists, but is None
    else:
        # g.trace(setting,val)
        return val, True</t>
<t tx="ekr.20041124083125">def completeFileName (fileName):
    
    import leoGlobals as g
    
    if not fileName:
        return None
        
    # This does not depend on config settings.
    fileName = g.os_path_join(os.getcwd(),fileName)

    head,ext = g.os_path_splitext(fileName)
    if not ext:
        fileName = fileName + ".leo"

    return fileName</t>
<t tx="ekr.20041126060136">def print_list(aList,tag=None,sort=False,indent=''):
    
    if not aList:
        if tag: print '%s...{}' % tag
        else:   print '{}'
        return
    if sort:
        aList = aList[:] # Sort a copy! Pychecker incorrectly complains.
        aList.sort()
    if tag: print '%s...[' % tag
    else:   print '['
    for e in aList:
        print '%s%s' % (indent,repr(e).strip())
    print ']'

printList = print_list

def listToString(aList,tag=None,sort=False,indent=''):

    if not aList:
        if tag: return '%s...{}' % tag
        else:   return '{}'
    if sort:
        aList = aList[:] # Sort a copy! Pychecker incorrectly complains.
        aList.sort()
    lines = ["%s%s" % (indent,repr(e).strip()) for e in aList]
    s = '\n'.join(lines)
    if tag:
        return '[%s...\n%s\n]' % (tag,s)
    else:
        return '[%s]' % s</t>
<t tx="ekr.20041130093254">def reportDirectories(verbose):
    
    import leoGlobals as g
   
    if verbose:
        for kind,theDir in (
            ("global config",g.app.globalConfigDir),
            ("home",g.app.homeDir),
        ):
            g.es("%s dir: %s" % (kind,theDir),color="blue")</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041201080436">def appendToRecentFiles (self,files):
    
    files = [theFile.strip() for theFile in files]
    
    # g.trace(files)
    
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()
    
    for name in files:
        # Remove all variants of name.
        for name2 in self.recentFiles:
            if munge(name) == munge(name2):
                self.recentFiles.remove(name2)

        self.recentFiles.append(name)</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041217135735.1">def setColorFromConfig (self):
    
    c = self.c ; body = self.bodyCtrl
        
    bg = c.config.getColor("body_text_background_color") or 'white'
    try: body.configure(bg=bg)
    except:
        g.es("exception setting body text background color")
        g.es_exception()
    
    fg = c.config.getColor("body_text_foreground_color") or 'black'
    try: body.configure(fg=fg)
    except:
        g.es("exception setting body textforeground color")
        g.es_exception()

    bg = c.config.getColor("body_insertion_cursor_color")
    if bg:
        try: body.configure(insertbackground=bg)
        except:
            g.es("exception setting body pane cursor color")
            g.es_exception()
        
    sel_bg = c.config.getColor('body_text_selection_background_color') or 'Gray80'
    try: body.configure(selectbackground=sel_bg)
    except Exception:
        g.es("exception setting body pane text selection background color")
        g.es_exception()

    sel_fg = c.config.getColor('body_text_selection_foreground_color') or 'white'
    try: body.configure(selectforeground=sel_fg)
    except Exception:
        g.es("exception setting body pane text selection foreground color")
        g.es_exception()
  
    if sys.platform != "win32": # Maybe a Windows bug.
        fg = c.config.getColor("body_cursor_foreground_color")
        bg = c.config.getColor("body_cursor_background_color")
        if fg and bg:
            cursor="xterm" + " " + fg + " " + bg
            try: body.configure(cursor=cursor)
            except:
                import traceback ; traceback.print_exc()</t>
<t tx="ekr.20041217135735.2">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20041219072112"># Import leoGlobals, but do NOT set g.
try:
    import leoGlobals
except ImportError:
    print "Error importing leoGlobals.py"

# Create the application object.
try:
    import leoApp
    leoGlobals.app = leoApp.LeoApp()
except ImportError:
    print "Error importing leoApp.py"
    
# NOW we can set g.
g = leoGlobals
assert(g.app)</t>
<t tx="ekr.20041219072416.1">try:
    import leoNodes
except ImportError:
    print "Error importing leoNodes.py"
    import traceback ; traceback.print_exc()
try:
    import leoConfig
except ImportError:
    print "Error importing leoConfig.py"
    import traceback ; traceback.print_exc()</t>
<t tx="ekr.20041222043017">def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)</t>
<t tx="ekr.20041222043017.1">def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d</t>
<t tx="ekr.20041226080857">c.spellCommands.openSpellTab()</t>
<t tx="ekr.20041227071423">def setShortcut (self,name,bunch):
    
    c = self.c
    
    # None is a valid value for val.
    key = c.frame.menu.canonicalizeMenuName(name)
    rawKey = key.replace('&amp;','')
    self.set(c,rawKey,"shortcut",bunch)
    
    # g.trace(bunch.pane,rawKey,bunch.val)</t>
<t tx="ekr.20041228042224">def setIvarsFromSettings (self,c):

    '''Init g.app.config ivars or c's ivars from settings.
    
    - Called from readSettingsFiles with c = None to init g.app.config ivars.
    - Called from c.__init__ to init corresponding commmander ivars.'''
    
    # Ingore temporary commanders created by readSettingsFiles.
    if not self.inited: return

    # g.trace(c)
    d = self.ivarsDict
    for key in d:
        if key != '_hash':
            bunch = d.get(key)
            if bunch:
                ivar = bunch.ivar # The actual name of the ivar.
                kind = bunch.kind
                val = self.get(c,key,kind) # Don't use bunch.val!
                if c:
                    # g.trace("%20s %s = %s" % (g.shortFileName(c.mFileName),ivar,val))
                    setattr(c,ivar,val)
                else:
                    # g.trace("%20s %s = %s" % ('g.app.config',ivar,val))
                    setattr(self,ivar,val)</t>
<t tx="ekr.20050120092028">@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,later=True):
    if self.body and self.body.bodyCtrl:
        self.set_focus(self.body.bodyCtrl,later=later)
        
def headlineWantsFocus(self,p,later=True):
    w = p and p.edit_text()
    if w:
        self.set_focus(w,later=later)
    
def logWantsFocus(self,later=True):
    if self.log and self.log.logCtrl:
        self.set_focus(self.log.logCtrl,later=later)
        
def minibufferWantsFocus(self,later=True):
    if self.c.miniBufferWidget:
        self.set_focus(self.c.miniBufferWidget,later=later)
    
def treeWantsFocus(self,later=True):
    if self.tree and self.tree.canvas:
        self.set_focus(self.tree.canvas,later=later)
    
def widgetWantsFocus(self,widget,later=True):
    if widget:
        self.set_focus(widget,later=later)
</t>
<t tx="ekr.20050120092028.1">@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWnatFocus routines call this with later=True, to queue up a ONE-SHOT later call
to g.app.g.app.gui.set_focus.
@c

def set_focus(self,widget,later=False):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    # This is a *very* effective trace.
    # g.trace(widget._name,g.callerList(5))

    if widget and not g.app.unitTesting:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget)
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(g.callerList(4),c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                # New in 4.4: set the delay to 1 msec.: the smaller the better.
                self.outerFrame.after(1,setFocusCallback)
        else:
            # g.trace(g.callerList(4),c.shortFileName())
            g.app.gui.set_focus(c,widget)
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None
    else:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None</t>
<t tx="ekr.20050123202520"></t>
<t tx="ekr.20050123202520.1">if 1:
    # Open leoSettings.leo
    c.openLeoSettings()

else:
    # Open the settings dialog.
    import leoConfig
    leoConfig.settingsController(c,replaceBody=True)</t>
<t tx="ekr.20050130152155">import leoGlobals as g
c = g.top()
name = "leoPlugins.leo"

fileName = g.os_path_join(g.app.loadDir,"..","plugins",name)
ok,frame = g.openWithFileName(fileName,c)
if not ok:
    g.es("not found: %s" % name)</t>
<t tx="ekr.20050208133438">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False</t>
<t tx="ekr.20050211120242.2">def removeExtraLws (s,tab_width):
    
    '''Remove extra indentation from one or more lines.
    
    Warning: used by getScript.  This is *not* the same as g.adjustTripleString.'''
    
    lines = g.splitLines(s)

    # Find the first non-blank line and compute w, the width of its leading whitespace.
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s
    
    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)
    
    if 0:
        g.trace('lines...')
        for line in g.splitLines(result):
            print repr(line)

    return result</t>
<t tx="ekr.20050211120837">def test_g_removeExtraLws():
    
    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
C:\prog\leoCVS\leo\src\LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050503112513.7">def executeFile(filename, options= ''):

    if not os.access(filename, os.R_OK): return

    subprocess = g.importExtension('subprocess',None,verbose=False)

    cwd = os.getcwdu()
    fdir, fname = g.os_path_split(filename)
    
    if subprocess: # Only exists in Python 2.4.
        &lt;&lt; define subprocess_wrapper &gt;&gt;
        rc, so, se = subprocess_wrapper('%s %s %s'%(sys.executable, fname, options))
        if rc:
             print 'return code', rc
        print so, se
    else:
        if fdir: os.chdir(fdir)
        d = {'__name__': '__main__'}
        execfile(fname, d)  #, globals()
        os.system('%s %s' % (sys.executable, fname))
        if fdir: os.chdir(cwd)</t>
<t tx="ekr.20050503112513.8">def subprocess_wrapper(cmdlst):
    
    # g.trace(cmdlst, fdir)
    # g.trace(subprocess.list2cmdline([cmdlst]))

    p = subprocess.Popen(cmdlst, cwd=fdir,
        universal_newlines=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdo, stde = p.communicate()
    return p.wait(), stdo, stde</t>
<t tx="ekr.20050512031131">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3147054
By: niccl

In the CVS leo from 12 May, yet another minor but mildly irritating bug: the
split ratio between log and outline windows isn't restored on re-opening a .leo
file. The  split between body and the others is, however.</t>
<t tx="ekr.20050526080309">d = g.scanDirectives(c,p) # Support @tab_width directive properly.
tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)

if ch in ('\n','\r'):
    # Do nothing if we are in @nocolor mode or if we are executing a Change command.
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        removeTrailing = self.doAutoIndent(p,removeTrailing,tab_width,undoType)

elif ch == '\t' and tab_width &lt; 0:
    # Do nothing if we are executing a Change command.
    if undoType != "Change":
        self.convertBlanksToTabs(tab_width)

elif ch in (chr(8)) and tab_width &lt; 0:
    &lt;&lt; handle backspace with negative tab_width &gt;&gt;</t>
<t tx="ekr.20050526081024">w = g.computeWidth(prev,tab_width)
w2 = (abs(tab_width) - (w % abs(tab_width)))
# g.trace("prev w:",w,"prev chars:",prev)
c.frame.bodyCtrl.delete("insert -1c")
c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050526081024.1"># Get the characters preceeding the tab.
prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

# Do nothing if there are non-whitespace in prev:
all_ws = True
for ch in prev:
    if ch != ' ' and ch != '\t':
        all_ws = False
if all_ws:
    w = g.computeWidth(prev,tab_width)
    w2 = (abs(tab_width) - (w % abs(tab_width)))
    # g.trace("prev w:",w,"prev chars:",prev)
    c.frame.bodyCtrl.delete("insert -1c")
    c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20050618045715">def PropagateButton4(e):
    canvas.event_generate("&lt;Button-4&gt;")
    return "break"

def PropagateButton5(e):
    canvas.event_generate("&lt;Button-5&gt;")
    return "break"

def PropagateMouseWheel(e):
    canvas.event_generate("&lt;MouseWheel&gt;")
    return "break"

if self.useBindtags:
    instance_tag = t.bindtags()[0]
    t.bind_class(instance_tag, "&lt;Button-4&gt;", PropagateButton4)
    t.bind_class(instance_tag, "&lt;Button-5&gt;", PropagateButton5)
    t.bind_class(instance_tag, "&lt;MouseWheel&gt;",PropagateMouseWheel)
else:
    # UNTESTED CASE!!!
    t.bind("&lt;Button-4&gt;", PropagateButton4)
    t.bind("&lt;Button-5&gt;", PropagateButton5)
    t.bind("&lt;MouseWheel&gt;", PropagateMouseWheel)

</t>
<t tx="ekr.20050707085637">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3237845
By: eichin

First, I'd like to thank Mr. Ream for presenting at EuroPython; I've been an
emacs user 'forever' (anyone else remember CCA emacs?) and have seen enough
"this could change your world as much as emacs did" sorts of comments, finally
seeing it on-screen live finally kicked me into trying it myself.

My overall experience was mixed; some of this may be due to my laziness (I just
unpacked 4-3-1 on my mac and ran src/leo.py, which got me a window so I counted
it as working.)  I did the original version of this in leo to attempt to get
some experience with it...

I am an emacs user.  So of course, I will use emacs bindings first - and since
some of them work (c-f, c-b) I get in trouble because the others then don't
(c-p pops up a python shell, c-a does something dramatic.)  *definitely* needs
at least a simple "you're an emacs user, here is basic editing in emacs bindings,
the leo-specific stuff is pushed out of the way."  Note that this is not actually
odd for a mac user - most of the basic emacs bindings work in text entry boxes,
like the Safari textarea I'm typing this in now - I'm not asking for m-x, but
for c-f/c-b/c-n/c-p/c-a/c-e and maybe a few more, but those are key.

Pure keyboard usage is also key - one thing that worried me watching the demo
was that Mr. Ream kept switching back and forth, keyboard to mouse, and that's
bad - and when I say bad, I mean that Raskin's book had a good footnote pointing
to a clinical study showing that RSIs correllated with *mouse* usage, not keyboard
usage, in a mainstream computer user context.  Note that I don't really mean
emacs-level keyboard-only use - just that in a typical hour of leo usage, I
shouldn't need the mouse for anything I use twice.  Having unusual stuff only
menus is fine.  Not having keybindings that I could find for *next-node* and
*prev-node* is *not* fine.  Frankly, just logging everything *you* use in an
hour and adding bindings for it might be enough...

Similarly, think of simple use-cases/workflows and make them easier.  Can node-titles
actually be multiple lines?  If not, why not have hitting return in a node title
take me to the text window? (This is just one example I tried and was surprised
didn't work.)  More critically, I couldn't find any keystroke at all to take
me from editing nodes to editing text, but I may have been confused at that
point.

For another, mac-specific case: *don't steal system bindings*.  M-`
(command-backtick, in macspeak) should cycle windows (M-~ the other direction.)
Breaking this dooms you on the Mac; even if that's an important binding on other
platforms, you just *have* to make it different on the mac - or you will only
have cross platform occasional mac users and *never* have any users who are
primarily mac users.  I suppose I should submit that one as a direct bug report.

Minor nit - on startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.

Defaulting to python-mode: sure, maybe it's just coloring, but coming into it
expecting it to be primarily a text-in-outlines editor, that confused me a lot.
I don't actually have an answer here - you can't cheat the way emacs does and
use an extension or #! line to decide "this is python code", though you may
be able to use other tricks - but a first time user is probably going to start
with bits of text and *then* move on to code, and if there's a sane way to support
that, please consider it.

More mac nits: two HELP menus, one is empty; "open leo docs.leo" from the help
menu gives a window that doesn't fit on-screen on my mac (tiger 10.4.1 12" powerbook)
and this leaves the resize control off-screen, so I can't fix it either.

Also (not so mac specific, but more glaring on the mac than elsewhere) - no
context-menu on nodes or text, and I couldn't seem to drag nodes with the mouse
at all (one of the things the mouse *is* obviously useful for, especially if
I'm doing a bunch of rearrangement in one place and *not* going back and forth.)

Finally, one comment from the talk that bothered me for a while and didn't click
until later - "emacs doesn't really have an outline mode".  This is true, at
face value - outline mode in fact is just some regexp and hiding kludging, powerful
in it's own way but not "deep".  However, the operations felt familiar, and
it wasn't until I went home and checked mail that I caught it -- *GNUS* is actually
surprisingly close in function set to an outliner.  Not in any immediately useful
way, but it both clarifies why I think emacs could work this way *and* possibly
clarifies why gnus users are so engaged by the interface :-)  Though that does
mean gnus might be a reasonable source of suggestions for key bindings...

Again, thanks for the demo.  It at least inspired a lot of interest, if not
actually a new convert, but I'll be watching more closely, at least.

_Mark_</t>
<t tx="ekr.20050711091931">def defineEditMenuEditCursorTable (self):
    
    __pychecker__ = 'no-unusednames=c,f'
    
    c = self.c ; f = self.frame

    if 0: ### Not ready yet.
        # These should have Emacs names...
        self.editMenuEditCursorTable = [
            ('Delete Right',c.deleteRightChar), 
            ('Delete Left',c.deleteLeftChar), 
            # Moving the cursor.
            ('Start of Line',c.moveToStartOfLine), 
            ('End of Line',c.moveToEndOfLine), 
            ('Start of Node',c.moveToStartOfNode),
            ('End of Node',c.moveToEndOfNode), 
            ('-',None,None),
            # Extending the selection...
            ('Select Line',c.selectEntireLine),
            ('Extend To Start of Word',c.extendToStartOfWord),
            ('Extend To End of Word',c.extendToEndOfWord),
            ('Extend To Start Of Line',c.extendToStartOfLine), 
            ('Extend To End Of Line',c.extendToEndOfLine), 
            ('Extend To End of Node',c.extendToEndOfNode),
            # The mark...
        ]</t>
<t tx="ekr.20050711153537">def goToLastVisibleNode (self):
    
    c = self ; p = c.rootPosition()
    
    while p.hasNext():
        p.moveToNext()
        
    while p and p.isExpanded():
        p.moveToLastChild()

    if p:
        c.beginUpdate()
        try:
            c.frame.tree.expandAllAncestors(p)
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20050712092501.1">@killcolor

Buffer-menu-buffer-column
Buffer-menu-mode-map
Buffer-menu-popup-menu

Info-default-directory-list
Info-directory-list
Info-frame-plist

Installation-string
Mouse-track-gensym
X-default-timeout
__buffer-dedicated-frame
_history_

abbreviated-calendar-year
abbreviated-home-dir
abbrevs-changed

activate-menubar-hook
activate-popup-menu-hook
ad-default-compilation-action
ad-redefinition-action

adaptive-fill-function
adaptive-fill-mode
adaptive-fill-regexp

add-log-c-like-modes
add-log-lisp-like-modes
add-log-tex-like-modes

adjust-frame-function

all-christian-calendar-holidays
all-hebrew-calendar-holidays
all-islamic-calendar-holidays

allow-deletion-of-last-visible-frame
allow-remote-paths

american-calendar-display-form
american-date-diary-pattern
apache-file-patterns

appt-audible
appt-display-duration
appt-display-mode-line
appt-issue-message

atomic-extent-goto-char-p
autoload-file-name
backward-delete-function
backward-word-regexp
balloon-help-mode
bar-cursor

bdf-directory-list
bell-inhibit-time
bell-volume

binary-file-regexps
binary-process-input
binary-process-output

binhex-begin-line

blink-cursor-mode
blink-matching-delay
blink-matching-paren
blink-matching-paren-distance
blink-matching-paren-dont-ignore-comments
blink-matching-paren-on-screen
blink-paren-function

block-comment-end
block-comment-start
block-movement-size

bookmark-map

bq-at-flag
bq-at-marker
bq-backquote-marker
bq-backtick-marker
bq-comma-flag
bq-comma-marker
bq-dot-flag
bq-dot-marker

built-in-face-specifiers
built-in-glyph-specifiers
busy-pointer-glyph
c++-mode-syntax-table
c-mode-syntax-table

calc-autoload-directory
calc-gnuplot-name
calc-gnuplot-plot-command
calc-gnuplot-print-command
calc-info-filename

calendar-latitude
calendar-load-hook
calendar-location-name
calendar-longitude
calendar-offset
calendar-setup
calendar-time-display-form
calendar-week-start-day

call-count-profile-table
camldebug-command-name
case-fold-search
case-replace
cd-path
cdpath-previous
change-major-mode-hook
change-major-mode-with-file-name
character-set-property
christian-holidays

coding-keymap
coding-system-for-read
coding-system-for-write
colon-double-space
column-number-mode
column-number-start-at-one

complex-buffers-menu-p

continuation-glyph
continue-save-buffer-hooks-tail

control-arrow-glyph

create-console-hook
create-device-hook
create-frame-hook

ctl-arrow
ctl-x-4-map
ctl-x-5-map
ctl-x-map

current-display-table
current-load-list
current-menubar
current-minibuffer-contents
current-minibuffer-point
current-mouse-event
current-prefix-arg

cursor-in-echo-area

custom-background-mode
custom-define-hook
custom-face-attributes
custom-file
custom-file-base
custom-group-hash-table
custom-known-themes
custom-loaded-themes
custom-local-buffer
custom-print-functions

data-directory
data-directory-list


defining-kbd-macro
defun-prompt-regexp
degrees-to-radians

delete-auto-save-files
delete-console-hook
delete-device-hook
delete-dialog-box-hook
delete-exited-processes
delete-frame-hook
delete-key-deletes-forward
delete-old-versions

describe-function-show-arglist
deselect-frame-hook

dialog-frame-plist

diary-display-hook
diary-file
diary-hook
diary-include-string
diary-list-include-blanks
diary-nonmarking-symbol

diff-switches
dir

directory-abbrev-alist
directory-sep-char

dired-backup-if-overwrite
dired-chown-program
dired-compression-method
dired-compression-method-alist
dired-copy-preserve-time
dired-dwim-target
dired-find-file-compare-truenames
dired-find-subdir
dired-gnutar-program
dired-kept-versions
dired-listing-switches
dired-local-variables-file
dired-ls-program
dired-mail-reader
dired-no-confirm
dired-omit-files
dired-refresh-automatically
dired-unshar-program
dired-use-file-transformers
dired-use-ls-dired

disable-animated-pixmaps
disable-auto-save-when-buffer-shrinks
disabled-command-hook

display-buffer-function
display-time-day-and-date
display-warning-minimum-level
display-warning-suppressed-classes
display-warning-tick

divider-pointer-glyph
doc-directory
dont-record-current-mark

drag-divider-event-lag
drag-modeline-event-lag

dragdrop-autoload-tm-view
dragdrop-drop-at-point
dragdrop-drop-log
dragdrop-drop-log-buffer
dragdrop-drop-log-name
dragdrop-protocols

e

early-package-load-path
early-packages

easy-menu-all-popups
ecb-running-emacs-21
ecb-running-xemacs
echo-keystrokes

edebug-all-defs
edebug-all-forms

ediff-menu
ediff-merge-menu
ediff-misc-menu

edit-abbrevs-map
edit-tab-stops-buffer
edit-tab-stops-map

efs-auto-save
efs-auto-save-remotely
efs-path-root-regexp

eldoc-mode

emacs-beta-version
emacs-build-system
emacs-build-time
emacs-lisp-byte-compile-dir-interactive-p
emacs-lisp-mode-hook
emacs-lisp-mode-map
emacs-lisp-mode-menubar-menu
emacs-lisp-mode-popup-menu
emacs-lisp-mode-syntax-table
emacs-major-version
emacs-minor-version
emacs-patch-level
emacs-priority
emacs-program-name
emacs-program-version
emacs-roots
emacs-version

enable-local-eval
enable-local-variables
enable-multibyte-characters
enable-recursive-minibuffers

enter-window-hook
epatch-menu
erc-ctcp-query-DCC-hook
errors-deactivate-region
esc-map
eshell-directory-name
european-calendar-display-form
european-calendar-style
european-date-diary-pattern

eval-expr-error-message-delay
eval-expr-honor-debug-on-error
eval-expr-print-length
eval-expr-print-level
eval-expr-prompt
eval-interactive-verbose

exec-directory
exec-path
exec-suffix-list

executing-kbd-macro
executing-macro
experimental-dragdrop-drop-functions
face-frob-from-locale-first
facemenu-keymap
facemenu-menu
fast-lock-mode
features

file-coding-system
file-coding-system-alist
file-coding-system-for-read
file-name-coding-system
file-name-handler-alist
file-name-history
file-precious-flag

fill-column
fill-individual-varying-indent
fill-paragraph-function
fill-prefix

find-file-compare-truenames
find-file-existing-other-name
find-file-hooks
find-file-not-found-hooks
find-file-not-true-dirname-list
find-file-run-dired
find-file-use-truenames
find-file-visit-truename

first-change-hook
float-epsilon
float-negative-epsilon
float-output-format
flyspell-mode
flyspell-mode-line-string
flyspell-mode-map
focus-follows-mouse

folding-default-keys-function
folding-default-mouse-keys-function
folding-inside-mode-name
folding-mode
folding-mode-hook-no-regexp
folding-mode-marks-alist
folding-mode-string

font-lock-auto-fontify
font-lock-fontify-string-delimiters
font-lock-keywords
font-lock-maximum-decoration
font-lock-maximum-size
font-lock-mode
font-lock-mode-disable-list
font-lock-mode-enable-list
font-lock-mode-hook
font-lock-syntactic-keywords
font-lock-use-colors
font-lock-use-fonts
font-lock-use-maximal-decoration
font-menu-ignore-scaled-fonts
font-menu-this-frame-only-p

footnote-minor-mode-map
footnote-mode-line-string
footnote-mode-map
footnote-prefix

force-dialog-box-use
format-alist
fortran-tab-mode-default
forward-word-regexp

frame
frame-background-mode
frame-icon-glyph
frame-icon-title-format
frame-initial-frame
frame-initial-frame-plist
frame-initial-geometry-arguments
frame-title-format

function-history
function-key-map
fundamental-mode-abbrev-table
gc-cons-threshold
gc-message
gc-pointer-glyph
gdb-command-name
general-holidays
generated-modeline-string

get-frame-for-buffer-default-frame-name
get-frame-for-buffer-default-instance-limit
get-frame-for-buffer-default-to-current

gnats::mode-name

gnus-outlook-deuglify-unwrap-max
gnus-outlook-deuglify-unwrap-min
gnus-outlook-display-hook

gnuserv-frame
goal-column
grep-null-device
grep-regexp-alist
gui-button-shadow-thickness

hack-local-variables-hook
has-modeline-p
haskell-doc-mode
haskell-mode-hook

hebrew-diary-entry-symbol
hebrew-holidays
hebrew-holidays-1
hebrew-holidays-2
hebrew-holidays-3
hebrew-holidays-4

hide-ifdef-initially
hide-ifdef-lines
hide-ifdef-mode-map
hide-ifdef-read-only

hippie-expand-ignore-buffers
hippie-expand-max-buffers
hippie-expand-try-functions-list
hippie-expand-verbose

history
holidays-in-diary-buffer

hs-hide-comments-when-hiding-all
hs-special-modes-alist
hscroll-glyph
html-font-lock-keywords

hyper-apropos-apropos-buf
hyper-apropos-currently-showing
hyper-apropos-face-history
hyper-apropos-help-buf
hyper-apropos-help-history
hyper-apropos-help-map
hyper-apropos-junk-regexp
hyper-apropos-last-regexp
hyper-apropos-map
hyper-apropos-mode-hook
hyper-apropos-prettyprint-long-values
hyper-apropos-programming-apropos
hyper-apropos-regexp-history
hyper-apropos-show-brief-docs
hyper-apropos-shrink-window

hyperb:emacs19-p
hyperb:kotl-p
hyperb:microcruft-os-p
hyperb:mouse-buttons
hyperb:xemacs-p

hypropos-help-map
hypropos-map
hypropos-prettyprint-long-values
hypropos-programming-apropos
hypropos-show-brief-docs
hypropos-shrink-window

icon-name
iconification-data
idl-mode-syntax-table
ignored-local-variables
image-formats-alist
imenu-generic-expression
in-shifted-motion-command

indent-line-function
indent-region-function
indent-tabs-mode

inhibit-auto-save-session
inhibit-autoloads
inhibit-default-init
inhibit-early-packages
inhibit-file-name-handlers
inhibit-file-name-operation
inhibit-first-line-modes-regexps
inhibit-first-line-modes-suffixes
inhibit-help-echo
inhibit-input-event-recording
inhibit-quit
inhibit-read-only
inhibit-site-lisp
inhibit-site-modules
inhibit-startup-message
inhibit-warning-display

init-face-from-resources
init-file-debug
init-file-had-error
init-file-loaded
init-file-user
init-x-toolbar-list

initial-calendar-window-hook
initial-contents
initial-frame-alist
initial-frame-plist
initial-frame-unmapped-p
initial-major-mode
initial-minibuffer-history-position
initial-scratch-message
initial-toolbar-spec
initial-window-system

initialize-face-resources
insert-default-directory
insert-directory-program
insert-file-contents-access-hook
insert-file-contents-error-hook
insert-file-contents-post-hook
insert-file-contents-pre-hook
internal-doc-file-name
internal-error-checking
interpreter-mode-alist
interprogram-cut-function
interprogram-paste-function
invisible-text-glyph
invocation-directory
invocation-name
invocation-path

islamic-diary-entry-symbol
islamic-holidays
iso8859/1-case-table

ispell-dictionary-alist
ispell-dictionary-alist-1
ispell-dictionary-alist-2
ispell-dictionary-alist-3
ispell-dictionary-alist-4
ispell-dictionary-alist-5
ispell-dictionary-alist-6
ispell-html-skip-alists
ispell-local-dictionary-alist
ispell-menu-map
ispell-menu-map-needed
ispell-menu-xemacs
ispell-personal-dictionary
ispell-skip-region-alist
ispell-tex-skip-alists

itimer-edit-map
itimer-edit-start-marker
itimer-inside-driver
itimer-list
itimer-next-wakeup
itimer-process
itimer-short-interval
itimer-timer
itimer-timer-last-wakeup
itimer-version

java-mode-syntax-table
jde-version
jde-which-method-mode
kept-new-versions
kept-old-versions
key-translation-map
keyboard-coding-system
keyboard-translate-table
keyboard-type
keymap
keymap-tick

kill-buffer-hook
kill-buffer-query-functions
kill-emacs-hook
kill-emacs-query-functions
kill-hooks
kill-ring
kill-ring-max
kill-ring-yank-pointer
kill-whole-line

killed-rectangle
kimport:mode-alist
kimport:suffix-alist
last

last-abbrev
last-abbrev-location
last-abbrev-text
last-command
last-command-char
last-command-event
last-command-event-time
last-command-properties
last-error
last-exact-completion
last-help-echo-object
last-input-char
last-input-event
last-input-time
last-kbd-macro
last-package-load-path
last-packages
last-popup-menu-event
last-pressed-toolbar-button
last-undo-buffer

late-package-load-path
late-packages
lazy-lock-mode
lazy-shot-mode
least-negative-float
least-negative-normalized-float
least-positive-float
least-positive-normalized-float
leave-window-hook

ledit-go-to-lisp-string
ledit-go-to-liszt-string
ledit-save-files

lib-complete:cache
lib-complete:max-cache-size
line-move-ignore-invisible
line-number-mode

local-abbrev-table
local-holidays
local-write-file-hooks

log-message-filter-function
log-message-ignore-labels
log-message-ignore-regexps
log-message-max-size
log-warning-minimum-level
log-warning-suppressed-classes

lookup-syntax-properties
lost-selection-hooks
lpr-command
lpr-lp-system
lpr-switches
lpr-windows-system

major-mode
make-annotation-hook
make-backup-files
manual-program
map-frame-hook

mark-diary-entries-hook
mark-diary-entries-in-calendar
mark-holidays-in-calendar
mark-ring
mark-ring-max
mark-ring-unrecorded-commands

max-lisp-eval-depth
max-specpdl-size
mconfig

menu-accelerator-enabled
menu-accelerator-map
menu-accelerator-modifiers
menu-accelerator-prefix
menu-bar-bookmark-map
menu-no-selection-hook

menubar-configuration
menubar-pointer-glyph
menubar-show-keybindings

menubar-visible-p

meta-prefix-char
mh-lib
mh-libs
mh-progs

minimum-line-ascent
minimum-line-descent
minor-mode-alist
minor-mode-map-alist

modifier-keys-are-sticky
modifier-keys-sticky-time

module-directory
module-load-path

most-negative-fixnum
most-negative-float
most-positive-fixnum
most-positive-float
motion-keys-for-shifted-motion

mule-lisp-directory
native-sound-only-on-console
network-coding-system-alist
news-inews-program
news-path
next-line-add-newlines
next-screen-context-lines
nil
no-redraw-on-reenter
nongregorian-diary-listing-hook
nongregorian-diary-marking-hook
noninteractive
nontext-pointer-glyph
normal-auto-fill-function
nroff-electric-mode
nt-fake-unix-uid
null-device
number-of-diary-entries
obarray
objc-mode-syntax-table

occur-buffer
occur-mode-map
occur-nlines
occur-pos-list

oconfig
octal-escape-glyph
oframe
old-whitespace-incremental-mode-line-string
old-whitespace-mode-line-string
only-global-abbrevs
options-save-faces
oriental-holidays
other-holidays
other-window-scroll-buffer
outline-minor-mode
overlay-arrow-position
overlay-arrow-string

overriding-file-coding-system
overriding-local-map
overriding-terminal-local-map

overwrite-mode
overwrite-mode-binary
overwrite-mode-textual
owindow

page-delimiter

paragraph-ignore-fill-prefix
paragraph-separate
paragraph-start

paren-mode
parens-require-spaces
parse-sexp-ignore-comments
parse-sexp-lookup-properties
path-separator
pathname-coding-system

pending-delete-mode
pending-undo-list
permanent-buffers-mode
php-file-patterns
pi
pike-mode-syntax-table
pixel-horizontal-clip-threshold
pixel-vertical-clip-threshold
point-before-scroll

pop-up-frame-alist
pop-up-frame-function
pop-up-frame-plist
pop-up-frames
pop-up-windows

popup-menu-titles
post-command-hook
post-gc-hook
pre-abbrev-expand-hook
pre-command-hook
pre-display-buffer-function
pre-gc-hook
pre-idle-hook
predicate
prefix-arg
prefix-help-command
preloaded-file-list
primary-selection-extent

print-diary-entries-hook
print-escape-newlines
print-gensym
print-gensym-alist
print-length
print-level
print-message-label
print-readably
print-string-length

printer-current-device
printer-name
printer-page-footer
printer-page-header

process-coding-system-alist
process-connection-type
process-environment

progress-abort-glyph
progress-feedback-popup-period
progress-feedback-style
progress-feedback-use-echo-area
progress-gauge-instantiator
progress-glyph-height
progress-layout-glyph
progress-layout-instantiator
progress-stack
progress-text-instantiator

prompt
ps-multibyte-buffer
ps-page-dimensions-database
ps-paper-type
ps-print-color-p
purify-flag
put-buffer-names-in-file-menu
query-replace-help
query-replace-history
query-replace-interactive
query-replace-map
quit-flag
radians-to-degrees

read-command-history
read-expression-history
read-expression-map
read-file-name-map
read-file-name-must-match-map
read-shell-command-map

readp
redisplay-cache-adjustment
redisplay-end-trigger-functions

register-alist
remote-shell-program
remove-message-hook
replace-re-search-function
replace-search-function
require-final-newline
require-match
ret
retry-undefined-key-binding-unshifted
revert-buffer-function
revert-buffer-insert-file-contents-function
revert-buffer-internal-hook
revert-without-query

rmail-default-dont-reply-to-names
rmail-delete-after-output
rmail-dont-reply-to-names
rmail-file-name
rmail-ignored-headers
rmail-last-file
rmail-mail-new-frame
rmail-primary-inbox-list
rmail-retry-setup-hook
rmail-spool-directory

ruby-mode-hook
running-xemacs
same-window-buffer-names
same-window-regexps
save-abbrevs
save-options-file
save-options-init-file
save-some-buffers-query-display-buffer

scroll-conservatively
scroll-on-clipped-lines
scroll-step
scrollbar-height
scrollbar-on-left-p
scrollbar-on-top-p
scrollbar-pointer-glyph
scrollbar-width
scrollbars-visible-p

scsh-program-name

secondary-selection-extent
select-frame-hook
selected-text-type

selection-appender-alist
selection-buffer-killed-alist
selection-coercible-types
selection-coercion-alist
selection-converter-alist
selection-converter-in-alist
selection-converter-out-alist
selection-pointer-glyph
selection-sets-clipboard

selective-display
selective-display-ellipses

self-insert-face
self-insert-face-command
semanticdb-global-mode
send-mail-function
sendmail-program
sentence-end
sentence-end-double-space
sexp-diary-entry-symbol
shared-lisp-mode-map

shell-command-history
shell-command-switch
shell-dumb-shell-regexp
shell-file-name

shifted-motion-keys-select-region
signal-error-on-buffer-boundary

site-directory
site-load-package-file
site-load-packages
site-module-directory
site-start-file

skeleton-filter
solar-holidays
sound-alist

special-display-buffer-names
special-display-frame-alist
special-display-frame-plist
special-display-function
special-display-regexps

splash-frame-static-body
splash-frame-timeout

split-height-threshold
split-width-threshold
split-window-keep-point

stack-trace-on-error
stack-trace-on-signal
standard-indent
standard-input
standard-output
startup-message-timeout
startup-presentation-hack-keymap
status
strokes-mode
suppress-early-error-handler-backtrace
synchronize-minibuffers
synchronous-sounds
system-configuration
system-configuration-options
system-type
t

tab-stop-list
tab-width

table
tar-regexp

teach-extended-commands-p
teach-extended-commands-timeout

temp-buffer-max-height
temp-buffer-show-function
temp-buffer-show-hook
temp-buffer-shrink-to-fit

temporary-goal-column
term-file-prefix
term-setup-hook

terminal-coding-system
terminal-console
terminal-device
terminal-frame

texinfo-close-quote
texinfo-open-quote

text-cursor-visible-p
text-mode-abbrev-table
text-mode-hook
text-mode-map
text-mode-syntax-table
text-mode-variant
text-pointer-glyph

this-command
this-command-properties

three-step-help
today-invisible-calendar-hook
today-visible-calendar-hook
toggle-where-was-i

trace-buffer
track-eol

tramp-completion-file-name-regexp
tramp-completion-file-name-regexp-separate
tramp-completion-file-name-regexp-unified
tramp-file-name-regexp
tramp-file-name-regexp-separate
tramp-file-name-regexp-unified
tramp-unified-filenames

truncate-lines
truncate-partial-width-windows
truncation-glyph

tshell-prompt-pattern
tutorial-supported-languages
uncapitalized-title-word-regexp
uncapitalized-title-words
undo-high-threshold
undo-threshold
universal-argument-map
universal-argument-num-events
unmap-frame-hook
unread-command-event
unread-command-events
unshifted-motion-keys-deselect-region
use-dialog-box
use-hard-newlines
use-left-overflow
use-right-overflow

user-full-name
user-home-init-file-base-list
user-init-directory
user-init-directory-base
user-init-file
user-init-file-base
user-init-file-base-list
user-mail-address

v
values
variable-history
vc-annotate-mode-hook
vc-before-checkin-hook
vc-checkin-hook
vc-cvs-program
vc-log-template
vc-populate-vc-log-hook
version-control
version18p
version20p

view-calendar-holidays-initially
view-default-lines
view-diary-entries-initially
view-lossage-key-count
view-lossage-message-count
view-minor-mode
view-minor-mode-map
view-mode-map
view-search-arg
view-search-string
visible-bell
w3-configuration-directory
warning-count
warning-level-alist
warning-marker
widget-border-width

win32-pipe-read-delay
win32-quote-process-args
win32-start-process-share-console
win32-start-process-show-window

window
window-config-stack-max
window-min-height
window-min-width
window-pixel-scroll-increment
window-scroll-functions
window-setup-hook
window-size-change-functions
window-system

windowed-process-io
words-include-escapes

write-contents-hooks
write-file-data-hooks
write-file-hooks
write-region-annotate-functions
write-region-annotations-so-far
write-region-post-hook
write-region-pre-hook

x-busy-pointer-shape
x-gc-pointer-shape
x-library-search-path
x-mode-pointer-shape
x-nontext-pointer-shape
x-pointer-shape
x-selection-pointer-shape
x-toolbar-pointer-shape

xemacs-betaname
xemacs-codename
xemacs-logo
xemacs-praise-message
xemacs-praise-sound-file
xemacsp

xlib-version
xpm-color-symbols

xslt-process-additional-classpath
xslt-process-key-binding
xslt-process-mode
xslt-process-mode-line-string
xslt-process-mode-map

zenirc-command-queue
zenirc-last-command-queue-exec

zmacs-activate-region-hook
zmacs-deactivate-region-hook
zmacs-region-active-p
zmacs-region-extent
zmacs-region-rectangular-p
zmacs-region-stays
zmacs-regions
</t>
<t tx="ekr.20050712092501.2">bottom-gutter
bottom-gutter-border-width
bottom-gutter-height
bottom-gutter-visible-p

bottom-toolbar
bottom-toolbar-border-width
bottom-toolbar-height
bottom-toolbar-visible-p

gutter-buffers-tab
gutter-buffers-tab-enabled
gutter-buffers-tab-orientation
gutter-buffers-tab-visible-p
gutter-element-visibility-changed-hook

horizontal-scrollbar-visible-p

left-gutter
left-gutter-border-width
left-gutter-visible-p
left-gutter-width

left-margin
left-margin-width

left-toolbar
left-toolbar-border-width
left-toolbar-visible-p
left-toolbar-width

right-gutter
right-gutter-border-width
right-gutter-visible-p
right-gutter-width

right-margin-width

right-toolbar
right-toolbar-border-width
right-toolbar-visible-p
right-toolbar-width

top-gutter
top-gutter-border-width
top-gutter-height
top-gutter-visible-p

top-level

top-toolbar
top-toolbar-border-width
top-toolbar-height
top-toolbar-visible-p

vertical-divider-always-visible-p
vertical-divider-line-width
vertical-divider-map
vertical-divider-shadow-thickness
vertical-divider-spacing
vertical-scrollbar-visible-p</t>
<t tx="ekr.20050712092501.5"></t>
<t tx="ekr.20050712092501.6">*gensym-counter*
*random-state*</t>
<t tx="ekr.20050712092501.7">:
:accelerator
:activate-callback
:active
:active-opstring
:allow-multi-select
:allow-other-keys
:allow-pages
:allow-selection
:args
:author-version
:autoload-end
:autosize
:background
:background-pixmap
:bold
:border
:buttons
:callback
:callback-ex
:color
:color-symbols
:completion-string
:complex
:config
:cost
:count
:create-prompt-on-nonexistent
:dangerous
:data
:deletion
:description
:descriptor
:device
:dim
:duration
:enable
:end
:end1
:end2
:error
:extra-offset
:face
:face-reset-string
:face-set-string
:family
:file
:file-must-exist
:filter
:filter-list
:foreground
:format
:from-end
:full
:full-name
:get
:greedy
:group
:height
:help
:help-echo
:help-string
:horizontally-justify
:hotspot-x
:hotspot-y
:if
:if-not
:image
:immediate
:included
:initial-directory
:initial-filename
:initial-focus
:initial-value
:initialize
:inline
:interactive
:inverse-video
:italic
:items
:justify
:key
:key-sequence
:keys
:label
:link
:load
:margin-width
:mark
:mask-data
:mask-file
:match
:match-alternatives
:maybe
:menu-tag
:modal
:modifier-p
:must-match
:name
:nick
:no-network-button
:no-read-only-return
:opstring
:options
:orientation
:overwrite-prompt
:pageno
:parent
:password
:pitch
:pixel-height
:pixel-width
:port
:prefix
:printer-name
:printer-settings
:properties
:props
:question
:reader
:reference-buffer
:rehash-size
:rehash-threshold
:require
:resource-id
:resource-type
:selected
:selected-page-button
:server
:set
:set-after
:short-description
:size
:sound
:spec
:start
:start-time
:start1
:start2
:strikethru
:style
:suffix
:summarizer
:tag
:tags
:test
:test-not
:text
:title
:type
:underline
:user-data
:validate
:value
:variable-reset-string
:variable-set-string
:version
:vertically-justify
:volume
:weakness
:width
:window
:window-height
:window-width</t>
<t tx="ekr.20050712092501.8">abbrev-all-caps
abbrev-file-name
abbrev-mode
abbrev-start-location
abbrev-start-location-buffer
abbrev-table
abbrev-table-name-list</t>
<t tx="ekr.20050712092501.9">after-change-function
after-change-functions
after-delete-annotation-hook
after-find-file-from-revert-buffer
after-init-hook
after-insert-file-functions
after-load-alist
after-revert-hook
after-save-hook
after-set-visited-file-name-hooks</t>
<t tx="ekr.20050712092501.10">auto-fill-chars
auto-fill-function
auto-fill-inhibit-regexp
auto-gc-threshold
auto-lower-frame
auto-mode-alist
auto-raise-frame
auto-revert-mode
auto-save-default
auto-save-directory
auto-save-directory-fallback
auto-save-file-format
auto-save-hash-directory
auto-save-hash-p
auto-save-interval
auto-save-list-file-name
auto-save-list-file-prefix
auto-save-offer-delete
auto-save-reserved-chars
auto-save-timeout
auto-save-version
auto-save-visited-file-name
auto-show-inhibiting-commands
auto-show-mode
auto-show-shift-amount
auto-show-show-left-margin-threshold</t>
<t tx="ekr.20050712092501.11">backup-by-copying
backup-by-copying-when-linked
backup-by-copying-when-mismatch
backup-enable-predicate
backup-inhibited</t>
<t tx="ekr.20050712092501.12">bbdb-get-addresses-headers
bbdb-get-only-first-address-p
bbdb-sound-volume
bbdb-sounds-directory
bbdb-update-records-mode
bbdb/vm-set-auto-folder-alist-field</t>
<t tx="ekr.20050712092501.13">before-change-function
before-change-functions
before-delete-annotation-hook
before-init-deferred-warnings
before-init-hook
before-revert-hook</t>
<t tx="ekr.20050712092501.14">browse-url-browser-display
browse-url-browser-function
browse-url-galeon-program
browse-url-generic-program
browse-url-grail
browse-url-mozilla-program
browse-url-new-window-flag
browse-url-new-window-p
browse-url-save-file</t>
<t tx="ekr.20050712092501.15">buffer
buffer-auto-save-file-name
buffer-backed-up
buffer-file-coding-system
buffer-file-coding-system-for-read
buffer-file-format
buffer-file-name
buffer-file-number
buffer-file-numbers-unique
buffer-file-truename
buffer-history
buffer-invisibility-spec
buffer-list-changed-hook
buffer-offer-save
buffer-quit-function
buffer-read-only
buffer-saved-size
buffer-string
buffer-undo-list</t>
<t tx="ekr.20050712092501.16">buffers-menu-format-buffer-line-function
buffers-menu-grouping-function
buffers-menu-max-size
buffers-menu-omit-chars-list
buffers-menu-omit-function
buffers-menu-sort-function
buffers-menu-submenus-for-groups-p
buffers-menu-switch-to-buffer-function
buffers-tab-default-buffer-line-length
buffers-tab-face
buffers-tab-filter-functions
buffers-tab-format-buffer-line-function
buffers-tab-grouping-regexp
buffers-tab-max-buffer-line-length
buffers-tab-max-size
buffers-tab-omit-function
buffers-tab-selection-function
buffers-tab-sort-function
buffers-tab-switch-to-buffer-function</t>
<t tx="ekr.20050712092501.17">cl-builtin-clrhash
cl-builtin-gethash
cl-builtin-maphash
cl-builtin-remhash
cl-closure-vars
cl-compiling-file
cl-emacs-type
cl-hacked-flag
cl-macro-environment
cl-macroexpand-cmacs
cl-old-macroexpand
cl-optimize-safety
cl-optimize-speed
cl-proclaims-deferred
cl-struct-Print-context-tags</t>
<t tx="ekr.20050712092501.18">command-debug-status
command-history
command-line-args
command-line-args-left
command-line-default-directory
command-line-processed
command-loop-level
command-switch-alist</t>
<t tx="ekr.20050712092501.19">comment-column
comment-end
comment-indent-function
comment-indent-hook
comment-line-break-function
comment-multi-line
comment-start
comment-start-skip</t>
<t tx="ekr.20050712092501.20">compilation-buffer-name-function
compilation-finish-function
compilation-minor-mode
compilation-minor-mode-map
compilation-mode-hook
compilation-search-path
compilation-shell-minor-mode
compilation-shell-minor-mode-map
compilation-window-height</t>
<t tx="ekr.20050712092501.21">completion
completion-auto-help
completion-base-size
completion-default-help-string
completion-display-completion-list-function
completion-highlight-first-word-only
completion-ignore-case
completion-ignored-extensions
completion-list-mode-abbrev-table
completion-list-mode-map
completion-list-mode-syntax-table
completion-reference-buffer
completion-regexp-list
completion-setup-hook</t>
<t tx="ekr.20050712092501.22">configure-data-directory
configure-doc-directory
configure-exec-directory
configure-exec-prefix-directory
configure-info-directory
configure-info-path
configure-lisp-directory
configure-mail-lock-method
configure-module-directory
configure-mule-lisp-directory
configure-package-path
configure-prefix-directory
configure-site-directory
configure-site-module-directory</t>
<t tx="ekr.20050712092501.23">dabbrev--abbrev-char-regexp
dabbrev--check-other-buffers
dabbrev--eliminate-newlines
dabbrev--friend-buffer-list
dabbrev--last-abbrev-location
dabbrev--last-abbreviation
dabbrev--last-buffer
dabbrev--last-buffer-found
dabbrev--last-case-pattern
dabbrev--last-completion-buffer
dabbrev--last-direction
dabbrev--last-expansion
dabbrev--last-expansion-location
dabbrev--last-obarray
dabbrev--last-table
dabbrev-abbrev-char-regexp
dabbrev-abbrev-skip-leading-regexp
dabbrev-backward-only
dabbrev-case-distinction
dabbrev-case-fold-search
dabbrev-case-replace
dabbrev-check-all-buffers
dabbrev-check-other-buffers
dabbrev-friend-buffer-function
dabbrev-ignored-buffer-names
dabbrev-ignored-buffer-regexps
dabbrev-limit
dabbrev-search-these-buffers-only
dabbrev-select-buffers-function
dabbrev-upcase-means-case-search</t>
<t tx="ekr.20050712092501.24">isearch-adjusted
isearch-barrier
isearch-buffer
isearch-case-fold-search
isearch-cmds
isearch-extent
isearch-fixed-case
isearch-forward
isearch-hide-immediately
isearch-highlight
isearch-highlight-all-matches
isearch-highlight-extents
isearch-highlight-last-case-fold-search
isearch-highlight-last-regexp
isearch-highlight-last-string
isearch-invalid-regexp
isearch-just-started
isearch-message
isearch-mode
isearch-mode-end-hook
isearch-mode-hook
isearch-mode-map
isearch-new-forward
isearch-nonincremental
isearch-op-fun
isearch-opoint
isearch-other-end
isearch-recursive-edit
isearch-regexp
isearch-selected-frame
isearch-slow-terminal-mode
isearch-small-window
isearch-string
isearch-success
isearch-unhidden-extents
isearch-window-configuration
isearch-window-end
isearch-window-start
isearch-within-brackets
isearch-word
isearch-wrapped
isearch-yank-flag</t>
<t tx="ekr.20050712092501.25">lisp-body-indent
lisp-directory
lisp-imenu-generic-expression
lisp-indent-function
lisp-indent-offset
lisp-interaction-mode-map
lisp-interaction-mode-menubar-menu
lisp-interaction-mode-popup-menu
lisp-mode-abbrev-table
lisp-mode-map
lisp-mode-syntax-table</t>
<t tx="ekr.20050712092501.26">list-buffers-directory
list-buffers-header-line
list-buffers-identification
list-diary-entries-hook
list-directory-brief-switches
list-directory-verbose-switches
list-matching-lines-default-context-lines
list-matching-lines-whole-buffer
list-mode-extent
list-mode-extent-old-point
list-mode-hook
list-mode-map</t>
<t tx="ekr.20050712092501.27">mail-abbrev-mailrc-file
mail-alias-file
mail-aliases
mail-archive-file-name
mail-default-directory
mail-default-reply-to
mail-from-style
mail-header-separator
mail-host-address
mail-interactive
mail-lock-method
mail-lock-methods
mail-self-blind
mail-signature
mail-specify-envelope-from
mail-use-rfc822
mail-user-agent
mail-yank-ignored-headers
mail-yank-prefix</t>
<t tx="ekr.20050712092501.28">minibuffer-completion-confirm
minibuffer-completion-predicate
minibuffer-completion-table
minibuffer-confirm-incomplete
minibuffer-default
minibuffer-electric-file-name-behavior
minibuffer-exit-hook
minibuffer-frame-alist
minibuffer-frame-plist
minibuffer-help-form
minibuffer-history
minibuffer-history-minimum-string-length
minibuffer-history-position
minibuffer-history-search-history
minibuffer-history-sexp-flag
minibuffer-history-uniquify
minibuffer-history-variable
minibuffer-local-completion-map
minibuffer-local-isearch-map
minibuffer-local-map
minibuffer-local-must-match-map
minibuffer-max-depth
minibuffer-scroll-window
minibuffer-setup-hook
minibuffer-smart-completion-tracking-behavior</t>
<t tx="ekr.20050712092501.29">mode-compile-after-compile-hook
mode-compile-after-kill-hook
mode-compile-always-save-buffer-p
mode-compile-before-compile-hook
mode-compile-before-kill-hook
mode-compile-chosen-compiler
mode-compile-default-make-options
mode-compile-expert-p
mode-compile-ignore-makefile-backups
mode-compile-ignore-makerule-regexp
mode-compile-make-options
mode-compile-make-program
mode-compile-never-edit-command-p
mode-compile-other-frame-p
mode-compile-preferred-default-makerule
mode-compile-reading-time
mode-compile-save-all-p
mode-compile-version
mode-for-help
mode-line-buffer-identification
mode-line-format
mode-line-map
mode-line-menu
mode-line-modified
mode-line-process
mode-motion-extent
mode-motion-help-echo-string
mode-motion-hook
mode-name
mode-popup-menu
mode-specific-map</t>
<t tx="ekr.20050712092501.30">modeline-3d-p
modeline-buffer-id-extent
modeline-buffer-id-left-extent
modeline-buffer-id-left-map
modeline-buffer-id-right-extent
modeline-buffer-id-right-map
modeline-buffer-identification
modeline-click-swaps-buffers
modeline-format
modeline-map
modeline-menu
modeline-minor-mode-extent
modeline-minor-mode-map
modeline-modified
modeline-modified-extent
modeline-modified-map
modeline-mousable-minor-mode-extent
modeline-multibyte-status
modeline-narrowed-extent
modeline-narrowed-map
modeline-pointer-glyph
modeline-process
modeline-scrolling-method
modeline-shadow-thickness</t>
<t tx="ekr.20050712092501.31">mouse-avoidance-mode
mouse-avoidance-mode-line-string
mouse-enter-frame-hook
mouse-grabbed-buffer
mouse-highlight-priority
mouse-highlight-text
mouse-leave-frame-hook
mouse-motion-handler
mouse-track-activate-strokes
mouse-track-cleanup-hook
mouse-track-click-count
mouse-track-click-hook
mouse-track-down-hook
mouse-track-drag-hook
mouse-track-drag-up-hook
mouse-track-multi-click-time
mouse-track-rectangle-p
mouse-track-scroll-delay
mouse-track-timeout-id
mouse-track-up-hook
mouse-track-up-time
mouse-track-up-x
mouse-track-up-y
mouse-track-x-threshold
mouse-track-y-threshold
mouse-yank-at-point
mouse-yank-function</t>
<t tx="ekr.20050712092501.32">mswindows-alt-by-itself-activates-menu
mswindows-bitmap-file-path
mswindows-construct-process-command-line-alist
mswindows-downcase-file-names
mswindows-dynamic-frame-resize
mswindows-font-regexp
mswindows-get-true-file-attributes
mswindows-ls-round-file-size
mswindows-ls-sort-case-insensitive
mswindows-match-one-cmd-exe-token-regexp
mswindows-mouse-button-max-skew-x
mswindows-mouse-button-max-skew-y
mswindows-mouse-button-tolerance
mswindows-num-mouse-buttons
mswindows-post-win-initted
mswindows-pre-win-initted
mswindows-start-process-inherit-error-mode
mswindows-start-process-share-console
mswindows-system-shells
mswindows-use-system-frame-size-defaults
mswindows-win-initted</t>
<t tx="ekr.20050712092501.33">package-get-base
package-get-download-sites

packages-data-path-depth
packages-hardcoded-lisp
packages-hierarchy-depth
packages-load-path-depth
packages-no-package-hierarchy-regexp
packages-package-list
packages-special-base-regexp
packages-unbytecompiled-lisp
packages-useful-lisp</t>
<t tx="ekr.20050712092501.34">regexp-history
regexp-search-ring
regexp-search-ring-max
regexp-search-ring-yank-pointer

search-caps-disable-folding
search-dialog
search-dialog-direction
search-dialog-regexp
search-exit-option
search-highlight
search-invisible
search-nonincremental-instead
search-ring
search-ring-max
search-ring-update
search-ring-yank-pointer
search-slow-speed
search-slow-window-lines
search-whitespace-regexp</t>
<t tx="ekr.20050712092501.35">toolbar-active
toolbar-blank-press-function
toolbar-buttons-captioned-p
toolbar-captioned-p
toolbar-compile-icon
toolbar-copy-function
toolbar-copy-icon
toolbar-cut-function
toolbar-cut-icon
toolbar-debug-icon
toolbar-dired-function
toolbar-disk-icon
toolbar-file-icon
toolbar-folder-icon
toolbar-help-enabled
toolbar-icon-directory
toolbar-info-frame
toolbar-info-frame-plist
toolbar-info-icon
toolbar-info-use-separate-frame
toolbar-ispell-function
toolbar-last-win-icon
toolbar-mail-commands-alist
toolbar-mail-icon
toolbar-mail-reader
toolbar-map
toolbar-news-commands-alist
toolbar-news-frame
toolbar-news-frame-plist
toolbar-news-frame-properties
toolbar-news-icon
toolbar-news-reader
toolbar-news-use-separate-frame
toolbar-next-win-icon
toolbar-open-function
toolbar-paste-function
toolbar-paste-icon
toolbar-pointer-glyph
toolbar-print-function
toolbar-printer-icon
toolbar-replace-function
toolbar-replace-icon
toolbar-save-function
toolbar-spell-icon
toolbar-undo-function
toolbar-undo-icon
toolbar-vector-compile
toolbar-vector-copy
toolbar-vector-cut
toolbar-vector-debug
toolbar-vector-dired
toolbar-vector-info
toolbar-vector-mail
toolbar-vector-news
toolbar-vector-open
toolbar-vector-paste
toolbar-vector-print
toolbar-vector-replace
toolbar-vector-save
toolbar-vector-spell
toolbar-vector-undo
toolbar-visible-p</t>
<t tx="ekr.20050712094115">debug-ignored-errors
debug-mswindows-process-command-lines
debug-on-error
debug-on-next-call
debug-on-quit
debug-on-signal
debug-paths
debugger</t>
<t tx="ekr.20050712094115.1">default
default-abbrev-mode
default-buffer-file-coding-system
default-case-fold-search
default-ctl-arrow
default-custom-frame-properties
default-directory
default-directory-function
default-file-dialog-filter-alist
default-fill-column
default-frame-alist
default-frame-name
default-frame-plist
default-function-key-map
default-gutter
default-gutter-border-width
default-gutter-height
default-gutter-position
default-gutter-position-changed-hook
default-gutter-visible-p
default-gutter-width
default-justification
default-left-margin
default-major-mode
default-menubar
default-minibuffer-frame
default-mode-line-format
default-modeline-format
default-mouse-track-adjust
default-mouse-track-down-event
default-mouse-track-extent
default-mouse-track-max-anchor
default-mouse-track-min-anchor
default-mouse-track-normalize-point-function
default-mouse-track-previous-point
default-mouse-track-result
default-mouse-track-type
default-mouse-track-type-list
default-mouse-track-window
default-msprinter-frame-plist
default-mswindows-frame-plist
default-popup-menu
default-profiling-interval
default-tab-width
default-text-properties
default-toolbar
default-toolbar-border-width
default-toolbar-height
default-toolbar-position
default-toolbar-visible-p
default-toolbar-width
default-truncate-lines</t>
<t tx="ekr.20050712094115.2">global-abbrev-table
global-auto-revert-mode
global-map
global-mark-ring
global-mark-ring-max
global-mode-string
global-popup-menu
global-semantic-auto-parse-mode
global-semantic-show-dirty-mode
global-semantic-show-unmatched-syntax-mode
global-semantic-summary-mode
global-senator-minor-mode</t>
<t tx="ekr.20050712094115.3">help-buffer-list
help-buffer-prefix-string
help-char
help-echo-owns-message
help-form
help-map
help-max-help-buffers
help-mode-abbrev-table
help-mode-map
help-mode-syntax-table
help-selects-help-window
help-sticky-window
help-symbol-function-and-variable-context-menu
help-symbol-function-context-menu
help-symbol-regexp
help-symbol-variable-context-menu
help-window-config
</t>
<t tx="ekr.20050712094115.4">load-file-name
load-force-doc-strings
load-history
load-home-init-file
load-ignore-elc-files
load-in-progress
load-path
load-read-function
load-user-init-file-p
load-warn-when-source-newer
load-warn-when-source-only
</t>
<t tx="ekr.20050712094115.5">message-archive-header
message-archive-note
message-citation-line-function
message-cite-function
message-cross-post-default
message-cross-post-note
message-cross-post-note-function
message-followup-to-note
message-from-style
message-indent-citation-function
message-mark-insert-begin
message-mark-insert-end
message-send-mail-function
message-signature
message-signature-file
message-signature-insert-empty-line
message-signature-separator
message-stack
message-user-organization-file
message-yank-prefix</t>
<t tx="ekr.20050712094115.6">paths-core-load-path-depth
paths-default-info-directories

paths-el-original-directory-abbrev-alist
paths-el-original-manual-program
paths-el-original-mh-libs
paths-el-original-mh-progs
paths-el-original-news-inews-program
paths-el-original-remote-shell-program
paths-el-original-rmail-spool-directory
paths-el-original-sendmail-program

paths-lisp-filename-regexp
paths-mule-load-path-depth
paths-no-lisp-directory-regexp
paths-site-load-path-depth
paths-version-control-filename-regexp</t>
<t tx="ekr.20050712094115.7">xwem-after-init-hook
xwem-after-init-wins-hook
xwem-applications-alist
xwem-before-init-hook
xwem-before-init-wins-hook
xwem-cl-activate-hook
xwem-cl-change-hook
xwem-cl-create-hook
xwem-cl-deactivate-hook
xwem-cl-destroy-hook
xwem-cl-iconify-hook
xwem-cl-mark-ring
xwem-cl-refit-hook
xwem-cl-state-change-hook
xwem-cl-withdraw-hook
xwem-clgen-map
xwem-client-default-properties
xwem-client-deselect-hook
xwem-client-select-hook
xwem-config-read-hook
xwem-debug-routines
xwem-dedicated-frame-defalut-properties
xwem-default-focus-mode
xwem-default-parent-map
xwem-dir
xwem-embedded-frame-default-properties
xwem-frame-default-properties
xwem-global-map
xwem-help-key
xwem-icons-dir
xwem-icons-list
xwem-kbd-now-grabbing
xwem-kbd-quit-hook
xwem-keyboard-echo-keystrokes
xwem-keyboard-init-hook
xwem-load-hook
xwem-manage-default-properties
xwem-manage-expectances
xwem-manage-list
xwem-messages-ignore-labels
xwem-minibuffer-focusin-hook
xwem-minibuffer-focusout-hook
xwem-override-local-map
xwem-override-map
xwem-post-command-hook
xwem-pre-command-hook
xwem-prefix-arg
xwem-prefix-help-command
xwem-quit-command
xwem-quit-key
xwem-sound-alist
xwem-sound-list
xwem-started
xwem-tabber-click-cl
xwem-tabber-click-frame
xwem-universal-key
xwem-version
xwem-win-min-height
xwem-win-min-width
xwem-win-split-hook
xwem-worklog-load-hook
xwem-worklog-login-hook
xwem-worklog-logout-hook
xwem-worklog-task-pause-hook
xwem-worklog-task-resume-hook
xwem-worklog-task-start-hook
xwem-worklog-task-stop-hook
xwem-worklog-tasks-description</t>
<t tx="ekr.20050713105353"></t>
<t tx="ekr.20050713105353.1">@nocolor

I have looked into leo's code and managed to figure out how to change 
some fonts. Here's what I did to change the menu fonts for example.

Fonts for the menu can be set in Code-&gt;Gui Tkinter classes-&gt;@thin 
leoTkinterMenu.py-&gt;Tkinter menu bindings-&gt;Routines with Tk 
spellings-&gt;new_menu

so to use the system font (linux) I changed the return statement to:

return Tk.Menu(parent,tearoff=tearoff, font=("System",11))

I'll try using .leo_xresources file and see if that works as well.</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050723064110">class editCommands:

    @others</t>
<t tx="ekr.20050723064110.1">def __init__ (self,c):
    
    self.c = c

    self.mode = 'default'
    self.modeStack = []
    
    self.defaultWordChars1, self.defaultWordChars2 = self.setDefaultWordChars()
    self.wordChars1 = self.defaultWordChars1
    self.wordChars2 = self.defaultWordChars2

    self.setDefaultOptions()</t>
<t tx="ekr.20050723064110.3"></t>
<t tx="ekr.20050723064110.4">def setDefaultOptions(self):
    
    self.options = {
        'extendMovesForward':   True,  # True: moving forward may cross node boundaries.
        'extendMovesBack':      True,  # True: moving back may cross node boundaries.
        'extendFindsForward':   True,   # True: find forward may cross node boundaries.
        'extendFindsBack':      True,   # True: find back may cross node boundaries.
    }</t>
<t tx="ekr.20050723064110.5">def getOption (self,optionName):
    
    # This may change when modes get put in.
    return self.options.get(optionName)</t>
<t tx="ekr.20050723064110.6"></t>
<t tx="ekr.20050723064110.7">def findWordStart(self,s,i):
    
    while i &lt; len(s):
        if s[i] in self.wordChars1:
            return i
        else:
            i += 1
    return i</t>
<t tx="ekr.20050723064110.8">def insideWord (self,s,i):
    
    '''Return True if the char at s[i] is inside a word but does not start the word.'''
    
    return (
        0 &lt; i &lt; len(s) and
        s[i] in self.wordChars2 and
        s[i-1] in self.wordChars2
    )</t>
<t tx="ekr.20050723064110.9">def skipWord(self,s,i):
    
    while i &lt; len(s) and s[i] in self.wordChars2:
        i += 1
    return i</t>
<t tx="ekr.20050723064110.10">def startsWord (self,s,i):
    
    '''Return True if the char at s[i] is inside a word but does not start the word.'''
    
    return (
        i &lt; len(s) and 
        s[i] in self.wordChars1 and
        (i == 0 or s[i-1] not in self.wordChars1)
    )</t>
<t tx="ekr.20050723064110.11">def setDefaultWordChars (self):
    
    chars1 = '_' + string.letters
    chars2 = '_' + string.letters + string.digits
    return chars1, chars2</t>
<t tx="ekr.20050723064110.12"></t>
<t tx="ekr.20050723064110.13">def moveBackwardChar (self):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    i = b.getPythonInsertionPoint(s=s)
    i -= 1
    if i &gt;= 0:
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesBackward'): # Recursively look for words in previous nodes.
        p = c.currentPosition().moveToThreadBack()
        while p:
            s = p.bodyString()
            if len(s) &gt; 0:
                c.selectPosition(p)
                b.setPythonInsertionPoint(len(s)-1)
                return True
            else:
                p.moveToThreadBack()
        return False
    else:
        return False</t>
<t tx="ekr.20050723064110.14">def moveBackwardWord (self,i=None):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    if i is None: i = b.getPythonInsertionPoint(s=s)

    if self.startsWord(s,i) or self.insideWord(s,i):
        i = self.findWordStart(s,i)
    i = self.findWordStart(s,i) ###
    if self.startsWord(s,i): ###
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesBackward'): # Recursively look for words in previous nodes.
        p = c.currentPosition().moveToThreadBack()
        while p:
            c.selectPosition(p)
            if self.moveBackwardWord(0):
                return True
            p.moveToThreadBack()
        return False
    else:
        return False</t>
<t tx="ekr.20050723064110.15">def moveForwardChar (self):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    i = b.getPythonInsertionPoint(s=s)
    i += 1
    if i &lt; len(s):
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesForward'): # Recursively look for words in following nodes.
        p = c.currentPosition().moveToThreadNext()
        while p:
            if len(p.bodyString()) &gt; 0:
                c.selectPosition(p)
                b.setPythonInsertionPoint(0)
                return True
            else:
                p.moveToThreadNext()
        return False
    else:
        return False</t>
<t tx="ekr.20050723064110.16">def moveForwardWord (self,i=None):
    
    c = self.c ; b = c.frame.body ; s = b.getAllText()
    if i is None: i = b.getPythonInsertionPoint(s=s)

    if self.startsWord(s,i) or self.insideWord(s,i):
        i = self.skipWord(s,i)
    i = self.findWordStart(s,i)
    if self.startsWord(s,i):
        b.setPythonInsertionPoint(i)
        return True
    elif self.getOption('extendMovesForward'): # Recursively look for words in following nodes.
        p = c.currentPosition().moveToThreadNext()
        while p:
            c.selectPosition(p)
            if self.moveForwardWord(0):
                return True
            p.moveToThreadNext()
        return False
    else:
        return False</t>
<t tx="ekr.20050723064110.17"></t>
<t tx="ekr.20050723064110.18">def selectForwardWord (self):
    
    c = self ; b = c.frame.body ; s = b.getAllText()

    i = i1 = b.getPythonInsertionPoint()
    
    if i &lt; len(s) and g.is_c_id(s[i]):
        i = g.skip_c_id(s,i+1)
    
    while i &lt; len(s) and not g.is_c_id(s[i]):
        i += 1
        
    if i &lt; len(s) and g.is_c_id(s[i]):
        # b.setPythonTextSelection(i1,i)
        pass ### TODO</t>
<t tx="ekr.20050831131028"></t>
<t tx="ekr.20050831131452">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3280949
By: billp9619

&gt;&gt;Making Leo a friendly part of the opml world has the potential to be very
important to Leo. &lt;&lt;

This is probably point 5. and covers the implementation of opml features as
exposed in Leo.

Because Leo is highly scripted there may be many requests... currently out on
the OPML list... that are solveable....such as how to see their outlines as
HTML without passing thru the OPML web server /host. BTW...all this new opml
stuff is only a week or two in production. The first message on
http://groups.yahoo.com/group/opml-newbies/
is July 25.

&gt;&gt; The question of whether to duplicate body text in &lt;outline&gt; elements
is minor&lt;&lt;

Good. 

Really, the opml tools are pretty much raw text/xml  and I was thinking the
default fallback is ... all clone text is "duplicate". If you want clones then
you will take care to only edit them in Leo. But if opml users all know and
use clones routinely in other editors,  then this is good news for opml
as technology.

&gt;&gt;more complicated than it needs to be&lt;&lt;

Well, both Leo and opml have only a few elements and each primarilly uses one
which recusively nests to make up the outline portion. I suppose body nodes
could be included more directly in headlines ... allowing un-numbered headlines
basically, ... but I am not sure that the current way is inferior
or complicated.

 A simpler (forgiving?) format might make it easier to create with external
apps and encourage transforming other xml to Leo via XSLT. It would have to
just "work".

(One thing about Leo's bias towards elements to contain markup, versus attributes,
is that ...you can cheat a little on escaping &amp;quot; in vh or t nodes ?...which
makes code blocks smaller in the Leo xml.)

Your list above is pretty much how I see it as well.

regards,

bill p

</t>
<t tx="ekr.20050831131452.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3282460
By: billp9619

Looking at some discussion of outline formats there was a remark that because
opml places all text in attributes it is limited in not being able to contan
other elements. On xml-dev I also saw some advice about opml followed by the
comment that it is not a good format.

opml is crippled in this regard but  Leo only restricts itself as a choice in
order to  discern leo xml from content.(out of necessity we know).

Of course with xml you can mix vocabularies based on the use of namespaces.
By becoming namespace aware Leo could be adapted for non-escaped markup. The
purpose then is xml parsing of leo as a standard container of other xml. I do
not believe this is unthinkable  for some future capabilities... especially
if such nodes would contain exclusively xml from another namespace.

Just interesting that leo's format is more versatile than opml, 
but, ...by choice for its own purposes, ...
 is in this part "backward" compatible with opml. :)  

regards,

bill p
</t>
<t tx="ekr.20050912063133"></t>
<t tx="ekr.20050912065811"></t>
<t tx="ekr.20050915062404">@nocolor

Hi,

I am the author of Leo http://webpages.charter.net/edreamleo/front.html an outline editor supporting clones http://webpages.charter.net/edreamleo/intro.html#clones-views.

I am interested in having Leo be able to read and write opml files.  My understanding is that applications are free to use attributes of &lt;outline&gt; elements as they please, but I am wondering whether there are guidelines or existing conventions for representing clones.  Have any namespaces been defined for that purpose?

Thanks.

Edward
</t>
<t tx="ekr.20050916180203">@nocolor

Make Alt-arrow commands undoable.
    Example:  Alt-left Alt-right is not the same, in general, as Alt-left, Undo.
    
Make Expand/Contract undoable?
</t>
<t tx="ekr.20050920084036.41">def bufferList (self,event):
    
    k = self.k
    state = k.getState('bufferList')
    if state.startswith('start'):
        state = state[5:]
        k.setState('bufferList',state)
        k.setLabel('')
    if event.keysym=='Tab':
        stext = k.getLabel().strip()
        if self.bufferTracker.prefix and stext.startswith(self.bufferTracker.prefix):
            k.setLabel(self.bufferTracker.next())#get next in iteration
        else:
            prefix = k.getLabel()
            pmatches =[]
            for z in self.bufferDict.keys():
                if z.startswith(prefix):
                    pmatches.append(z)
            self.bufferTracker.setTabList(prefix,pmatches)
            k.setLabel(self.bufferTracker.next())#begin iteration on new lsit
    elif event.keysym=='Return':
       bMode = k.getState('bufferList')
       c.commandsDict[bMode](event,k.getLabel())
    else:
        self.update(event)</t>
<t tx="ekr.20050920084036.44">def setInBufferMode (self,event,which):
    
    k = self.k ; w = event.widget

    k.keyboardQuit(event)
    k.setState('bufferList','start%s' % which)
    k.setLabelBlue('Choose Buffer Name: ',protect=True)
    self.bufferDict = self.getBufferDict(event)

    return 'break'</t>
<t tx="ekr.20050920084036.46">def setBufferListGetter (self,buffer,method):

    #Sets a method that returns a buffer name and its text, and its insert position.
    self.bufferListGetters [buffer] = method</t>
<t tx="ekr.20050920084036.47">def setBufferSetter( self, buffer, method ):

    #Sets a method that takes a buffer name and the new contents.
    self.bufferSetters[ buffer ] = method</t>
<t tx="ekr.20050920084036.48">def getBufferDict (self,event):

    w = event.widget
    meth = self.bufferListGetters [w]
    return meth()</t>
<t tx="ekr.20050920084036.49">def setBufferData( self, event, name, data ):
    
    w = event.widget
    meth = self.bufferSetters[ w ]
    meth( name, data )</t>
<t tx="ekr.20050920084036.50">def setBufferGoto( self, w, method ):

    self.bufferGotos[ w ] = method</t>
<t tx="ekr.20050920084036.51">def setBufferDelete( self, w, method ):
    
    self.bufferDeletes[ w ] = method</t>
<t tx="ekr.20050920084036.52">def setBufferRename( self, buffer, method ):
    
    self.renameBuffers[ buffer ] = method</t>
<t tx="ekr.20050920084036.73">def startGoto (self,event,ch=False):

    k = self.k ; state = k.getState('goto')
    k.setState('goto',state+1,handler=self.Goto)
    k.setLabelBlue('')
    return 'break'</t>
<t tx="ekr.20050920084036.75">def backToIndentation (self,event):

    w = event.widget

    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)
    ### w.update_idletasks()</t>
<t tx="ekr.20050920084036.78">def indentRelative (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    l, c = i.split('.')
    c2 = int(c)
    l2 = int(l) -1
    if l2 &lt; 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) &lt;= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                ###w.update_idletasks()</t>
<t tx="ekr.20050920084036.102">def backwardParagraph (self,event):

    k = self.k ; w = event.widget ; i = w.index('insert')

    while 1:
        s = w.get('%s linestart' % i,'%s lineend' % i).strip()
        if s:
            i = w.index('%s - 1 lines' % i)
            if w.index('%s linestart' % i) == '1.0':
                i = w.search(r'\w','1.0',regexp=True,stopindex='end')
                break
        else:
            i = w.search(r'\w',i,backwards=True,regexp=True,stopindex='1.0')
            i = '%s +1c' % i
            break
    if i:
        w.mark_set('insert',i)
        w.see('insert')
</t>
<t tx="ekr.20050920084036.107">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20050920084036.129">def zapTo (self,event):

    k = self.k ; c = k.c ; w = event.widget
    s = string.ascii_letters+string.digits+string.punctuation

    if len(event.char) != 0 and event.char in s:
        k.setState('zap',0)
        i = w.search(event.char,'insert',stopindex='end')
        k.resetLabel()
        if i:
            t = w.get('insert','%s+1c' % i)
            c.killBufferCommands.addToKillBuffer(t)
            w.delete('insert','%s+1c' % i)

    return 'break'
</t>
<t tx="ekr.20050920084036.141">def removeBlankLines (self,event):
    
    w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) ; dindex = []
    if w.get('insert linestart','insert lineend').strip() == '':
        while str(i1) + '.0' != '1.0':
            i1 -= 1
            g.trace('loop1',i1)
            s = w.get('%s.0' % i1,'%s.0 lineend' % i1).strip()
            if not s:
                dindex.append('%s.0' % i1)
                dindex.append('%s.0 lineend' % i1)
            elif dindex:
                w.delete('%s-1c' % dindex[-2],dindex[1])
                w.event_generate('&lt;Key&gt;')
                w.update_idletasks() # Needed to continue the loop.
                break
            else:
                break
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) ; dindex = []
    while w.index('%s.0 lineend' % i1) != w.index('end'):
        i1 += 1
        g.trace('loop1',i1)
        s = w.get('%s.0' % i1,'%s.0 lineend' % i1).strip()
        if not s:
            dindex.append('%s.0' % i1)
            dindex.append('%s.0 lineend' % i1)
        elif dindex:
            w.delete('%s-1c' % dindex[0],dindex[-1])
            w.event_generate('&lt;Key&gt;')
            w.update_idletasks() # Needed to continue the loop.
            break
        else:
            break</t>
<t tx="ekr.20050920084036.143">def Goto (self,event):

    k = self.k ; w = event.widget
    if event.keysym == 'Return':
        i = k.getLabel()
        k.resetLabel()
        state = k.getState('goto')
        k.setState('goto',0)
        if i.isdigit():
            if state == 1:
                w.mark_set('insert','%s.0' % i)
            elif state == 2:
                w.mark_set('insert','1.0 +%sc' % i)
            w.event_generate('&lt;Key&gt;')
            w.update_idletasks()
            w.see('insert')
    else:
        k.updateLabel(event)

    return 'break'</t>
<t tx="ekr.20050920084036.149">def moveWordHelper (self,event,forward=True):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'

    w.mark_set('insert',nind)
    w.see('insert')
    c.frame.widgetWantsFocus(w)

def backwardWord (self,event):
    self.moveWordHelper(event,forward=False)

def forwardWord (self,event):
    self.moveWordHelper(event,forward=True)</t>
<t tx="ekr.20050920084036.173">def getPublicCommands (self):
    
    k = self.k
    
    return {
        'digit-argument':           k.digitArgument,
        'help':                     k.help,
        'hide-mini-buffer':         k.hideMinibuffer,
        'negative-argument':        k.negativeArgument,
        'number-command':           k.numberCommand,
        'number-command-0':         k.numberCommand0,
        'number-command-1':         k.numberCommand1,
        'number-command-2':         k.numberCommand2,
        'number-command-3':         k.numberCommand3,
        'number-command-4':         k.numberCommand4,
        'number-command-5':         k.numberCommand5,
        'number-command-6':         k.numberCommand6,
        'number-command-7':         k.numberCommand7,
        'number-command-8':         k.numberCommand8,
        'number-command-9':         k.numberCommand9,
        'print-bindings':           k.printBindings,
        'print-commands':           k.printCommands,
        'repeat-complex-command':   k.repeatComplexCommand,
        'show-mini-buffer':         k.showMinibuffer,
        'toggle-mini-buffer':       k.toggleMinibuffer,
        'universal-argument':       k.universalArgument,
    }</t>
<t tx="ekr.20050920084036.188">def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2</t>
<t tx="ekr.20050920084036.189">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    #'check-spelling':      None,                   # Create this command.
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    # Leo find panel stuff.  It's not clear what will happen to these.
    'dismiss-leo-find-panel':   c.dismissFindPanel,
    'leo-change':               c.replace,
    'leo-change-then-find':     c.replaceThenFind,
    'leo-change-all':           c.replaceAll,
    'leo-find':                 c.findNext,
    'leo-find-panel':           c.showFindPanel,
    'leo-find-previous':        c.findPrevious,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}</t>
<t tx="ekr.20050920084036.219">def findNextMatch (self,event):
    
    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k ; w = event.widget
    
    w.tag_delete('qR')

    if self.regexp:
        &lt;&lt; handle regexp &gt;&gt;
    else:
        &lt;&lt; handle plain search &gt;&gt;</t>
<t tx="ekr.20050920084036.251">def _ToReg (self,event,which):

    if not self._chckSel(event):
        return
    if self._checkIfRectangle(event):
        return

    if event.keysym in string.letters:
        event.keysym = event.keysym.lower()
        w = event.widget
        if not self.registers.has_key(event.keysym):
            self.registers [event.keysym] = ''
        txt = w.get('sel.first','sel.last')
        rtxt = self.registers [event.keysym]
        if self.which == 'p':
            txt = txt + rtxt
        else:
            txt = rtxt + txt
        self.registers [event.keysym] = txt</t>
<t tx="ekr.20050920084036.256">def executeRegister (self,event):
    
    k = self.k

    if self.method:
        self.method(event)

        if self.registerMode != 0:
            k.keyboardQuit(event)</t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    
    self.forward = True
    self.regexp = False

    # For replace-string and replace-regexp
    self._sString = ''
    self._rpString = ''</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':            self.hideFindTab,
        'open-find-tab':            self.openFindTab,
        'find-tab-find':            self.findTabFindNext,
        'find-tab-find-prev':       self.findTabFindPrev,
        'find-tab-change':          self.findTabChange,
        'find-tab-change-then-find':self.findTabChangeThenFind,

        'isearch-forward':          self.isearchForward,
        'isearch-backward':         self.isearchBackward,
        'isearch-forward-regexp':   self.isearchForwardRegexp,
        'isearch-backward-regexp':  self.isearchBackwardRegexp,
        
        're-search-forward':        self.reSearchForward,
        're-search-backward':       self.reSearchBackward,
        
        'search-forward':           self.searchForward,
        'search-backward':          self.searchBackward,
        'word-search-forward':      self.wordSearchForward,
        'word-search-backward':     self.wordSearchBackward,
    }</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,regexp):

    k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = event.widget
    s = k.getLabel(ignorePrompt=True)
    g.trace(forward,repr(s))
    if s:
        try:
            if forward:
                i = w.search(s,"insert + 1c",stopindex='end',regexp=regexp)
                if not i:
                    # Start again at the top of the buffer.
                    i = w.search(s,'1.0',stopindex='insert',regexp=regexp)
            else:
                i = w.search(s,'insert',backwards=True,stopindex='1.0',regexp=regexp)
                if not i:
                    # Start again at the bottom of the buffer.
                    i = w.search(s,'end',backwards=True,stopindex='insert',regexp=regexp)
            
        except: pass

        if i and not i.isspace():
            w.mark_set('insert',i)
            w.see('insert')</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    k = self.k ; w = event.widget ; keysym = event.keysym
    if keysym == 'Control_L': return
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        if 0: # Doesn't do anything at present.
            &lt;&lt; do a non-incremental search &gt;&gt;
        k.resetLabel()
        k.clearState()
        return

    if event.char == '\b':
        g.trace('backspace not handled yet')
        return
    
    if event.char:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        z = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if not z:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event):

    k = self.k ; w = event.widget

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d
    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20050920084036.267"></t>
<t tx="ekr.20050920084036.268">def plainSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget ; i = w.index('insert')

    try:
        if forward:
            s = w.search(pattern,i,stopindex='end')
            if s: s = w.index('%s +%sc' % (s,len(pattern)))
        else:
            s = w.search(pattern,i,stopindex='1.0',backwards=True)
    except Exception:
        return

    if s:
        w.mark_set('insert',s)</t>
<t tx="ekr.20050920084036.269">def searchBackward (self,event):

    k = self.k ; state = k.getState('search-backward')
    if state == 0:
        k.setLabelBlue('Search Backward: ',protect=True)
        k.getArg(event,'search-backward',1,self.searchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=False)

def searchForward (self,event):

    k = self.k ; state = k.getState('search-forward')
    if state == 0:
        k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,'search-forward',1,self.searchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.272">def wordSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget ; i = w.index('insert')
    words = pattern.split()
    sep = '[%s%s]+' % (string.punctuation,string.whitespace)
    pattern = sep.join(words)
    cpattern = re.compile(pattern)
    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        if not match: return
        end = match.end()
    else:
        txt = w.get('1.0','insert') #initially the reverse words formula for Python Cookbook was going to be used.
        a = re.split(pattern,txt) #that didnt quite work right.  This one apparently does.
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return
        
    s = g.choose(forward,'insert +%sc','insert -%sc')
    w.mark_set('insert',s % end)
    w.see('insert')
</t>
<t tx="ekr.20050920084036.274">def reSearchBackward (self,event):

    k = self.k ; state = k.getState('re-search-backward')
    if state == 0:
        k.setLabelBlue('Regexp Search backward:',protect=True)
        k.getArg(event,'re-search-backward',1,self.reSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=False)

def reSearchForward (self,event):

    k = self.k ; state = k.getState('re-search-forward')
    if state == 0:
        k.setLabelBlue('Regexp Search:',protect=True)
        k.getArg(event,'re-search-forward',1,self.reSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.275">def reSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget
    cpattern = re.compile(pattern)

    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        end = match.end()
    else:
        # The reverse words formula for Python Cookbook didn't quite work.
        txt = w.get('1.0','insert') 
        a = re.split(pattern,txt)
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return

    if end:
        s = g.choose(forward,'insert +%sc','insert -%sc')
        w.mark_set('insert',s % end)
        w.see('insert')</t>
<t tx="ekr.20050920084720.1"></t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = True
        # A Tk Label or Text widget.  Exists even if c.showMinibuffer is False.
        
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20050920085536.11">def add_ekr_altx_commands (self):

    &lt;&lt; define dict d of abbreviations &gt;&gt;

    k = self ; c = k.c
    k.abbreviationsDict = {}

    keys = d.keys()
    keys.sort()
    for key in keys:
        val = d.get(key)
        func = c.commandsDict.get(val)
        if func:
            # g.trace(('%-4s' % key),val)
            c.commandsDict [key] = func
            k.abbreviationsDict [key] = val
            </t>
<t tx="ekr.20050920085536.12">d = {
    'again':'repeat-complex-command',
    
    # Leo searches.
    # It's not possible to use Alt-x while the find-panel is frontmost.
    # On XP you can use Alt-F4 to dismiss or Alt-tab to switch panes, then dismiss.
    # (Or I could add a 'close' button with Alt-something hotkey :-)
    'fx':   'dismiss-leo-find-panel',
    'f':    'leo-find-panel',
    'ff':   'leo-find-button',  
    'fp':   'leo-find-previous',
    'fc':   'leo-find-change-button',
    'fcf':  'leo-find-change-then-find-button',

    'i':    'isearch-forward', 
    'ib':   'isearch-backward',      
    'ix':   'isearch-forward-regexp',
    'irx':  'isearch-backward-regexp',
    'ixr':  'isearch-backward-regexp',
    
    'r':    'replace-string',
    'rx':   'replace-regex',

    's':    'search-forward',
    'sb':   'search-backward',
    'sv':   'save-file',
    
    'sw':   'word-search-forward',    
    'sbw':  'word-search-backward',
    'swb':  'word-search-backward',
    
    #
    # 'a1'  'abbrev-on'
    # 'a0'  'abbrev-off'
 
    ## Don't put these in: they might conflict with other abbreviatsions.
    # 'fd':   'find-dialog',
    # 'od':   'options-dialog',
    
    # At present these would be Leo Find stuff.
    # 'fr':   'find-reverse',
    # 'fx':   'find-regex',
    # 'frx':  'find-regex-reverse',
    # 'fxr':  'find-regex-reverse',
    # 'fw':   'find-word',
    # 'sf':   'set-find-text',
    # 'sr':   'set-find-replace',
    # 'ss':   'script-search',
    # 'ssr':  'script-search-reverse',
    
    ## These could be shared...
    # 'tfh':  'toggle-find-search-headline',
    # 'tfb':  'toggle-find-search-body',
    # 'tfw':  'toggle-find-word',
    # 'tfn':  'toggle-find-node-only',
    # 'tfi':  'toggle-find-ignore-case',
    # 'tfmc': 'toggle-find-mark-changes',
    # 'tfmf': 'toggle-find-mark-finds',
}</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c
    
    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return

    try:
        &lt;&lt; bind callback to shortcut in pane &gt;&gt;

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            # g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20050920085536.35">def setLabelGrey (self,label=None):

    k = self
    k.widget.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)
        
setLabelGray = setLabelGrey</t>
<t tx="ekr.20050920085536.36">def setLabelBlue (self,label=None,protect=False):
    
    k = self

    k.widget.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)</t>
<t tx="ekr.20050920085536.37">def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''</t>
<t tx="ekr.20050920085536.38">def updateLabel (self,event,suppressControlChars=True):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; s = k.getLabel()
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    
    # g.trace(repr(s),ch,keysym,k.stroke)
    
    if ch == '\b': # Handle backspace.
        # Don't backspace over the prompt.
        if len(s) &lt;= k.mb_prefix:
            return 
        elif len(s) == 1: s = ''
        else: s = s [0:-1]
    elif suppressControlChars and ch not in string.printable:
        return
    elif ch and ch not in ('\n','\r'):
        s = s + ch # Add the character.
    
    k.setLabel(s)</t>
<t tx="ekr.20050920085536.41">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('altx')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    # g.trace('state',state,keysym)
    if state == 0:
        k.setState('altx',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc(fromMinibuffer=True)
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.frame.minibufferWantsFocus(later=True)
        # g.trace('new prefix',k.mb_tabListPrefix)
    if keysym != 'Return':
        c.frame.minibufferWantsFocus(later=True)
    return 'break'
</t>
<t tx="ekr.20050920085536.43">def findItemsWithPrefix (self,s,aList=None):

    '''This method returns a sorted list of matches.
    
    It returns the list of matches and the longest common prefix of all the matches.'''

    k = self ; c = k.c

    common_prefix = ''

    if s: pmatches = [a for a in aList if a.startswith(s)]
    else: pmatches = []
        
    if pmatches:
        s = pmatches[0] ; done = False
        for i in xrange(len(s)):
            prefix = s[:i]
            for z in pmatches:
                if not z.startswith(prefix):
                    done = True ; break
            if done:
                break
            else:
                common_prefix = prefix
        pmatches.sort()

    # g.trace(repr(s),len(pmatches))
    return pmatches,common_prefix</t>
<t tx="ekr.20050920085536.44"># Used by getArg and fullCommand.

def doTabCompletion (self,defaultTabList):
    
    '''Handle tab completion when the user hits a tab.'''
    
    k = self ; c = k.c ; s = k.getLabel().strip()
    
    if k.mb_tabList and s.startswith(k.mb_tabListPrefix):
        g.trace('cycle',repr(s))
        # Set the label to the next item on the tab list.
        k.mb_tabListIndex +=1
        if k.mb_tabListIndex &gt;= len(k.mb_tabList):
            k.mb_tabListIndex = 0
        k.setLabel(k.mb_prompt + k.mb_tabList [k.mb_tabListIndex])
    else:
        k.computeCompletionList(defaultTabList,backspace=False)</t>
<t tx="ekr.20050920085536.45">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    # These must be done *after* getting the command.
    k.clearState()
    k.resetLabel()

    if func:
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        # if command in k.x_hasNumeric: func(event,aX)
        func(event)
        k.endCommand(event,commandName)
    else:
        k.setLabel('Command does not exist: %s' % commandName)</t>
<t tx="ekr.20050920085536.46"># Used by getArg and fullCommand.

def doBackSpace (self,defaultCompletionList):

    '''Cut back to previous prefix and update prefix.'''

    k = self

    if len(k.mb_tabListPrefix) &gt; len(k.mb_prefix):

        k.mb_tabListPrefix = k.mb_tabListPrefix [:-1]
        k.setLabel(k.mb_tabListPrefix)

    k.computeCompletionList(defaultCompletionList,backspace=True)</t>
<t tx="ekr.20050920085536.62">def getArg (self,event,returnKind=None,returnState=None,handler=None,prefix=None,tabList=None):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    # g.trace('state',state,'keysym',keysym)
    if state == 0:
        k.arg = ''
        if tabList: k.argTabList = tabList[:]
        else:       k.argTabList = []
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        k.afterGetArgState = (returnKind,returnState,handler)
        k.setState('getArg',1,k.getArg)
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList)
    elif keysym == 'BackSpace':
        k.doBackSpace()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()

    return 'break'
</t>
<t tx="ekr.20050920085536.64">def manufactureKeyPress (self,event,keysym):
    
    '''Implement a command by passing a keypress to Tkinter.'''

    w = event.widget
    w.event_generate('&lt;Key&gt;',keysym=keysym)
    
    ### Synthesize commandName instead of keysym?
    self.endCommand(event,keysym,tag='manufactureKeyPress')
    
    return 'break'</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    k.stroke = stroke # Set this global for general use.
    k.func = func
    commandName = k.ultimateFuncName(func)
    special = event.keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '&lt;Key&gt;'
    
    # g.trace(stroke,k.inState(),k.getStateKind())

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=event.keysym))

    if inserted:
        # g.trace(stroke,event.keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = event.keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        # g.trace('executing func',commandName)
        forceFocus = func.__name__ != 'leoCallback'
        if forceFocus:
            k.forceFocusToBody()
        func(event)
        k.endCommand(event,commandName,forceFocus)
        return 'break'

    else:
        c.frame.body.onBodyKey(event)
        return None # Not 'break'</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,event.keysym)

if len(event.char) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,event.char)

if 0: # traces
    g.trace(event.keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920085536.69"></t>
<t tx="ekr.20050920085536.70">def _tailEnd (self,w):
    
    '''This returns the tailEnd function that has been configure for the w parameter.'''
    
    k = self
    func = k.tailEnds.get(w)
    if func:
        # g.trace(func)
        return func(w)
    else:
        return 'break'
</t>
<t tx="ekr.20050920085536.71">def setTailEnd (self,w,tailCall):

    '''This method sets a ending call that is specific for a particular Text widget.
       Some environments require that specific end calls be made after a keystroke
       or command is executed.'''

    k = self

    k.tailEnds [w] = tailCall
</t>
<t tx="ekr.20050920085536.73">def universalDispatcher (self,event):
    
    '''Handle accumulation of universal argument.'''
    
    &lt;&lt; about repeat counts &gt;&gt;

    k = self ; state = k.getState('u-arg')

    if state == 0:
        # The call should set the label.
        k.setState('u-arg',1,k.universalDispatcher)
        k.repeatCount = 1
    elif state == 1:
        stroke = k.stroke ; keysym = event.keysym
            # Stroke is &lt;Key&gt; for plain keys, &lt;Control-u&gt; (k.universalArgKey)
        # g.trace(state,stroke)
        if stroke == k.universalArgKey:
            k.repeatCount = k.repeatCount * 4
        elif stroke == '&lt;Key&gt;' and keysym in string.digits + '-':
            k.updateLabel(event)
        elif stroke == '&lt;Key&gt;' and keysym in (
            'Alt_L','Alt_R','Shift_L','Shift_R','Control_L','Control_R'):
             # g.trace('stroke',k.stroke,'keysym',keysym)
             k.updateLabel(event)
        else:
            # *Anything* other than C-u, '-' or a numeral is taken to be a command.
            # g.trace('stroke',k.stroke,'keysym',keysym)
            val = k.getLabel(ignorePrompt=True)
            try:                n = int(val) * k.repeatCount
            except ValueError:  n = 1
            # g.trace('val',repr(val),'n',n,'k.repeatCount',k.repeatCount)
            k.clearState()
            k.executeNTimes(event,n)
            k.clearState()
            k.setLabelGrey()
            if 0: # Not ready yet.
                # This takes us to macro state.
                # For example Control-u Control-x ( will execute the last macro and begin editing of it.
                if stroke == '&lt;Control-x&gt;':
                    k.setState('uC',2,k.universalDispatcher)
                    return k.doControlU(event,stroke)
    elif state == 2:
        k.doControlU(event,stroke)

    return 'break'</t>
<t tx="ekr.20050920085536.75">def executeNTimes (self,event,n):
    
    __pychecker__ = '--no-local' # z is used just for a repeat count.
    
    k = self ; stroke = k.stroke ; w = event.widget
    g.trace('stroke',stroke,'keycode',event.keycode,'n',n)

    if stroke == k.fullCommandKey:
        for z in xrange(n):
            k.fullCommand()
    else:
        stroke = stroke.lstrip('&lt;').rstrip('&gt;')
        b = k.bindingsDict.get(stroke)
        if b:
            g.trace('method',b.f)
            for z in xrange(n):
                if 1: # No need to do this: commands never alter events.
                    ev = Tk.Event()
                    ev.widget = event.widget
                    ev.keysym = event.keysym
                    ev.keycode = event.keycode
                    ev.char = event.char
                k.masterCommand(event,b.f,'&lt;%s&gt;' % stroke)
        else:
            for z in xrange(n):
                w.event_generate('&lt;Key&gt;',keycode=event.keycode,keysym=event.keysym)</t>
<t tx="ekr.20050920085536.76">def doControlU (self,event,stroke):
    
    k = self ; c = k.c

    k.setLabelBlue('Control-u %s' % stroke.lstrip('&lt;').rstrip('&gt;'))

    if event.keysym == 'parenleft': # Execute the macro.

        k.clearState()
        k.resetLabel()
        c.macroCommands.startKbdMacro(event)
        c.macroCommands.callLastKeyboardMacro(event)</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands')
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    # There is no miniBufferWidget created for leoSettings.leo files.
    if c.miniBufferWidget:
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        # c.printCommandsDict()
    else:
        c.commandsDict = {}

    c.keyHandler.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)</t>
<t tx="ekr.20050920094212">def createMiniBufferWidget (self):
    
    '''Create the minbuffer below the status line.'''
    
    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')
    
    if 1:
        label = Tk.Text(f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minnibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)
    
    frame.minibufferVisible = c.showMinibuffer

    return label</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)</t>
<t tx="ekr.20050920114619.1">def utTailEnd (self,event=None):

    '''A method that Emacs will call with its _tailEnd method'''
    
    k = self ; c = k.c ; w = c.frame.bodyCtrl

    # w.event_generate('&lt;Key&gt;')
    w.focus_force()
    w.update_idletasks()
    # c.frame.bodyWantsFocus(w,later=True,tag='utTailEnd')

    return 'break'</t>
<t tx="ekr.20050921094025">@nocolor

** Double pastes in headlines!

- Put the focus in the body pane when loading a file.

- Retire the Find dialog, rename the commands.

** There must be a way of forcing focus to one of the main panes.
  Maybe this can be done at idle time??

* Cleanup: review all calls to g.app.gui.set_focus.

- Make spelling/autocompleter tabs.

- Make sure there is some way of executing script find/changes.

Posting: Status report.
    - Much progress.  A few details remain.
    - minibuffer find commands are about to be rename.
    - g.trace in set_focus makes clear, for the first time, what is happening.
      (g.callerList is essential)
    - a2 coming Friday.  Spelling &amp; autocompleter in the meantime.
    - There are now higher-level mechanisms in place to specify bindings:
        - k.copyBindingsToWidget([panes],widget)
        - It might be good to generalize further:  ! all, minibuffer = whatever.
    - There must be a way of forcing focus to one of the main panes,
      esp. when the minibuffer is active.</t>
<t tx="ekr.20050921094025.6">@nocolor</t>
<t tx="ekr.20050921094025.7">There may be bugs here.  The old code had definite strange aspects to it.</t>
<t tx="ekr.20050921094025.8">createBindings now sets c.emacs, so modifyOnBodyKey just uses c.emacs.</t>
<t tx="ekr.20050921094025.9">This is an important addition:  it guarantees that the proper commander is always used.</t>
<t tx="ekr.20050921094025.10">This is not needed.  createBindings is called at most once per commander.</t>
<t tx="ekr.20050921094025.11">Subclasses of baseCommands class should implement getPublicCommands.

This returns a dict whose keys are emacs command names and whose values are bound methods.</t>
<t tx="ekr.20050921094025.12">The miniBufferClass is the one half of the great divide.  The commands classes are the other.

- The commnds classes do not understand the details of the miniBufferClass: it can be rearranged as needed.

(done) Replace:
    svar, label = self.getSvarLabel( event )
by:
    b = self.miniBuffer ; tbuffer = event.widget

(done) self.setSvar(event,svar) -&gt; b.update(event)
(done) svar -&gt;  b
(done) label.configure(background='lightblue') --&gt; b.setLabelBlue()
(done) self.miniBuffer -&gt; b
(done) Replaced all delegators by b.methods.
(done) Removed unused args from most methods.</t>
<t tx="ekr.20050921094025.13">- Improved feedback for interactive search.
    - The minibuffer now says isearch:
    - Added args to miniBuffer.set/get methods to protect/ignore initial prompt characters.

- Backspacing when tab completion cuts back to last 'really' typed character.
    - Further backspaces work as you would expect.</t>
<t tx="ekr.20050921094025.14">- positions and tnodes globals are now ivars of bufferCommands class.</t>
<t tx="ekr.20050921094025.15">The fix was to return return orig_OnBodyKey(self.c.frame.body,event) at end of masterCommand.</t>
<t tx="ekr.20050921094025.254">@killcolor
</t>
<t tx="ekr.20050921094025.255">Buffer-menu-1-window
Buffer-menu-2-window
Buffer-menu-backup-unmark
Buffer-menu-delete
Buffer-menu-delete-backwards
Buffer-menu-execute
Buffer-menu-igrep
Buffer-menu-mark
Buffer-menu-maybe-mouse-select
Buffer-menu-mouse-select
Buffer-menu-not-modified
Buffer-menu-other-window
Buffer-menu-popup-menu
Buffer-menu-quit
Buffer-menu-save
Buffer-menu-select
Buffer-menu-switch-other-window
Buffer-menu-this-window
Buffer-menu-toggle-read-only
Buffer-menu-unmark
Buffer-menu-visit-tags-table</t>
<t tx="ekr.20050921094025.256">Custom-buffer-done
Custom-goto-parent
Custom-make-dependencies
Custom-mode-menu
Custom-reset-current
Custom-reset-saved
Custom-reset-standard
Custom-save
Custom-set

Electric-command-history-redo-expression

Footnote-add-footnote

Helper-describe-bindings
Helper-help

</t>
<t tx="ekr.20050921094025.257">Info-elisp-ref
Info-emacs-command
Info-emacs-key
Info-goto-emacs-command-node
Info-goto-emacs-key-command-node
Info-goto-node
Info-query
Info-search
Info-speedbar-browser
Info-split
Info-tagify
Info-validate
Info-visit-file</t>
<t tx="ekr.20050921094025.258">LaTeX-install-toolbar
LaTeX-mode

Manual-nuke-nroff-bs

Rd-mode

TeX-auto-generate
TeX-auto-generate-global
TeX-insert-quote
TeX-mode
TeX-submit-bug-report

View-process-status</t>
<t tx="ekr.20050921094025.259">abbrev-mode
abbrev-prefix-mark

abort-recursive-edit
about-xemacs
activate-region
ada-make-filename-from-adaname
ada-mode

add-change-log-entry
add-change-log-entry-other-window
add-global-abbrev
add-log-convert
add-mode-abbrev
add-name-to-file

advertised-switch-to-completions
advertised-undo

align
align-current
align-entire
align-highlight-rule
align-newline-and-indent
align-regexp
align-unhighlight-rule

all-hail-emacs
all-hail-xemacs
ams-tex-mode
ansi-color-for-comint-mode-on
apache-mode

append-next-kill
append-to-buffer
append-to-file
append-to-register

apply-macro-to-region-lines
appt-add
appt-delete
apropos
apropos-command
apropos-documentation
apropos-value
apropos-zippy
arp
asm-mode
assign-last-kbd-macro-to-key

auto-compression-mode
auto-fill-mode
auto-insert
auto-revert-mode
auto-save-mode
auto-show-make-point-visible
auto-show-mode

autoconf-mode
awk-mode</t>
<t tx="ekr.20050921094025.260">back-to-indentation
background
backtrace

backward-block-of-lines
backward-char
backward-char-command
backward-delete-char
backward-delete-char-untabify
backward-kill-line
backward-kill-paragraph
backward-kill-sentence
backward-kill-sexp
backward-kill-word
backward-list
backward-or-forward-delete-char
backward-or-forward-kill-sentence
backward-or-forward-kill-sexp
backward-or-forward-kill-word
backward-other-window
backward-page
backward-paragraph
backward-sentence
backward-sexp
backward-to-indentation
backward-up-list
backward-word

balance-windows
balloon-help-minor-mode
balloon-help-mode
base64-decode-region
base64-encode-region
basic-save-buffer

bbdb
bbdb-add-or-remove-mail-alias
bbdb-apply-next-command-to-all-records
bbdb-changed
bbdb-company
bbdb-complete-name
bbdb-create
bbdb-create-ftp-site
bbdb-creation-newer
bbdb-creation-no-change
bbdb-creation-older
bbdb-delete-current-field-or-record
bbdb-delete-current-record
bbdb-dial
bbdb-display-all-records-completely
bbdb-display-record-completely
bbdb-edit-current-field
bbdb-finger
bbdb-fontify-buffer
bbdb-force-record-create
bbdb-ftp
bbdb-help
bbdb-info
bbdb-insert-new-field
bbdb-load-touchtones
bbdb-menu
bbdb-merge-file
bbdb-name
bbdb-net
bbdb-notes
bbdb-omit-record
bbdb-print
bbdb-record-edit-notes
bbdb-record-edit-property
bbdb-refile-record
bbdb-send-mail
bbdb-show-all-recipients
bbdb-snarf
bbdb-snarf-region
bbdb-submit-bug-report
bbdb-timestamp-newer
bbdb-timestamp-older
bbdb-toggle-all-records-display-layout
bbdb-toggle-records-display-layout
bbdb-transpose-fields
bbdb-whois
bbdb-www
bbdb-www-grab-homepage
bbdb-yank
bbdb/gnus-annotate-sender
bbdb/gnus-show-all-recipients
bbdb/gnus-show-records
bbdb/gnus-snarf-signature
bbdb/mh-annotate-sender
bbdb/mh-show-sender
bbdb/rmail-annotate-sender
bbdb/rmail-show-sender
bbdb/vm-annotate-sender
bbdb/vm-set-auto-folder-alist
bbdb/vm-show-all-recipients
bbdb/vm-show-records
bbdb/vm-show-sender

beginning-of-buffer
beginning-of-buffer-other-window
beginning-of-defun
beginning-of-defun-raw
beginning-of-line
beginning-of-line-text

bib-cite-minor-mode
bib-mode
bibtex-mode
binary-overwrite-mode
blackbox
blink-cursor-mode
blink-matching-open
blink-paren
bnf-mode

bookmark-bmenu-list
bookmark-delete
bookmark-insert
bookmark-insert-location
bookmark-jump
bookmark-load
bookmark-locate
bookmark-menu-delete
bookmark-menu-insert
bookmark-menu-jump
bookmark-menu-locate
bookmark-menu-rename
bookmark-relocate
bookmark-rename
bookmark-save
bookmark-set
bookmark-write

br-complete-symbol
br-env-browse
br-env-load
br-three-button-mouse
br-to-from-viewer
br-two-button-mouse

browse-url
browse-url-at-mouse
browse-url-at-point
browse-url-cci
browse-url-firefox
browse-url-galeon
browse-url-generic
browse-url-gnome-moz
browse-url-grail
browse-url-iximosaic
browse-url-kde
browse-url-lynx-emacs
browse-url-lynx-xterm
browse-url-mail
browse-url-mmm
browse-url-mosaic
browse-url-mozilla
browse-url-netscape
browse-url-of-buffer
browse-url-of-dired-file
browse-url-of-file
browse-url-of-region
browse-url-opera
browse-url-w3
browse-url-w3-gnudoit
browse-url-w3m
browse-url-w3m-gnudoit

bsh-script-help

buffer-disable-undo
buffer-enable-undo
buffer-flush-undo
buffer-menu
buffer-menu-other-window

build
build-report
build-version

bury-buffer

byte-compile-and-load-file
byte-compile-buffer
byte-compile-file
byte-force-recompile
byte-recompile-directory
byte-recompile-file</t>
<t tx="ekr.20050921094025.261">c++-browse
c++-mode

c-add-style
c-comment-edit
c-macro-expand
c-mode
c-set-offset
c-set-style

calc
calc-dispatch
calc-embedded
calc-embedded-activate
calc-grab-rectangle
calc-grab-region
calc-keypad
calc-tutorial

calendar
call-last-kbd-macro
call-tree
caml-mode
camldebug
cancel-debug-on-entry
canonically-space-region

capitalize-region
capitalize-region-as-title
capitalize-region-or-word
capitalize-word

cd
cde-start-drag
cde-start-drag-region

center-line
center-paragraph
center-region
center-to-window-line

change-log-merge
change-log-mode
change-log-redate

check-ispell-version

checkdoc
checkdoc-continue
checkdoc-current-buffer
checkdoc-defun
checkdoc-eval-current-buffer
checkdoc-eval-defun
checkdoc-interactive
checkdoc-ispell
checkdoc-ispell-comments
checkdoc-ispell-continue
checkdoc-ispell-current-buffer
checkdoc-ispell-defun
checkdoc-ispell-interactive
checkdoc-ispell-message-interactive
checkdoc-ispell-message-text
checkdoc-ispell-start
checkdoc-message-interactive
checkdoc-message-text
checkdoc-minor-mode
checkdoc-rogue-spaces
checkdoc-start

choose-completion

clear-profiling-info
clear-rectangle
clearcase-install
clearcase-integrate
clearcase-unintegrate

clos-browse
column-number-mode
comint-dynamic-complete
comint-mode
comint-run
command-apropos
command-history-mode
comment-region
compare-windows
compilation-minor-mode
compilation-mode
compilation-shell-minor-mode
compile
compile-defun
complete

completion-do-in-minibuffer
completion-list-mode
completion-list-mode-quit
completion-switch-to-minibuffer

compose-mail
compose-mail-other-frame
compose-mail-other-window

consing-since-gc
context-en-mode
context-nl-mode

conx
conx-buffer
conx-load
conx-region

copy-file
copy-from-above-command
copy-primary-selection
copy-rectangle-to-register
copy-region-as-kill
copy-to-buffer
copy-to-register

count-lines-buffer
count-lines-page
count-lines-region
count-matches
count-words-buffer
count-words-region

cperl-mode
cperl-perldoc
cperl-perldoc-at-point

css-mode

ctypes-all-buffers
ctypes-auto-parse-mode
ctypes-buffer
ctypes-define-type
ctypes-define-type-in-mode
ctypes-dir
ctypes-file
ctypes-read-file
ctypes-tags

customize
customize-apropos
customize-apropos-faces
customize-apropos-groups
customize-apropos-options
customize-browse
customize-changed-options
customize-customized
customize-face
customize-face-other-window
customize-group
customize-group-other-window
customize-option
customize-option-other-window
customize-other-window
customize-save-customized
customize-save-variable
customize-saved
customize-set-value
customize-set-variable
customize-variable
customize-variable-other-window

cvs-checkout
cvs-examine
cvs-log-mode
cvs-quickdir
cvs-status
cvs-status-mode
cvs-update</t>
<t tx="ekr.20050921094025.262">dabbrev-completion
dabbrev-expand

dbx

debug
debug-on-entry

decipher
decipher-mode
decrease-left-margin
decrease-right-margin

define-abbrevs
define-global-abbrev
define-mail-alias
define-mode-abbrev
defining-kbd-macro

delete-backward-char
delete-blank-lines
delete-char
delete-completion-window
delete-directory
delete-file
delete-frame
delete-horizontal-space
delete-indentation
delete-matching-lines
delete-non-matching-lines
delete-other-frames
delete-other-windows
delete-primary-selection
delete-rectangle
delete-region
delete-selection-mode
delete-window
delete-windows-on

deprecated-help-command

describe-beta
describe-bindings
describe-buffer-case-table
describe-class
describe-copying
describe-current-display-table
describe-distribution
describe-function
describe-function-arglist
describe-function-at-point
describe-generic
describe-installation
describe-key
describe-key-briefly
describe-last-error
describe-method
describe-mode
describe-no-warranty
describe-pointer
describe-prefix-bindings
describe-project
describe-stroke
describe-syntax
describe-variable
describe-variable-at-point

desktop-entry-mode
desktop-read

diary
diary-mail-entries

dictionary
dictionary-lookup-definition
dictionary-match-words
dictionary-mouse-popup-matching-words
dictionary-popup-matching-words
dictionary-search

diff
diff-backup
diff-minor-mode
diff-mode

digit-argument
directory-tree-thing

dired
dired-apropos
dired-backup-diff
dired-cleanup
dired-compress-subdir-files
dired-describe-mode
dired-diff
dired-do-background-shell-command
dired-do-compress
dired-do-copy-regexp
dired-do-grep
dired-do-hardlink-regexp
dired-do-igrep
dired-do-igrep-find
dired-do-print
dired-do-relsymlink-regexp
dired-do-rename-regexp
dired-do-shell-command
dired-do-symlink-regexp
dired-do-uucode
dired-downcase
dired-ediff
dired-emerge
dired-emerge-with-ancestor
dired-epatch
dired-flag-extension
dired-flag-files-regexp
dired-jump-back
dired-jump-back-other-frame
dired-jump-back-other-window
dired-mark-extension
dired-mark-files-compilation-buffer
dired-mark-files-from-other-dired-buffer
dired-mark-files-regexp
dired-mark-sexp
dired-other-frame
dired-other-window
dired-read-mail
dired-report-bug
dired-rmail
dired-summary
dired-upcase
dired-virtual
dired-vm

disable-command
disassemble

display-buffer
display-call-tree
display-column-mode
display-time

dissociated-press
dns-mode
dns-mode-soa-increment-serial
do-auto-save
docbook-grep
docbook-mode
docref-setup
doctor
down-list

downcase-region
downcase-region-or-word
downcase-word

drag-window-divider
dsssl-mode
dunnet</t>
<t tx="ekr.20050921094025.263">ebuffers
ebuffers3

ecb-activate
ecb-byte-compile
ecb-minor-mode
ecb-show-help
edebug-defun
edebug-eval-top-level-form

ediff
ediff-backup
ediff-buffers
ediff-buffers3
ediff-customize
ediff-directories
ediff-directories3
ediff-directory-revisions
ediff-documentation
ediff-files
ediff-files3
ediff-merge
ediff-merge-buffers
ediff-merge-buffers-with-ancestor
ediff-merge-directories
ediff-merge-directories-with-ancestor
ediff-merge-directory-revisions
ediff-merge-directory-revisions-with-ancestor
ediff-merge-files
ediff-merge-files-with-ancestor
ediff-merge-revisions
ediff-merge-revisions-with-ancestor
ediff-merge-with-ancestor
ediff-patch-buffer
ediff-patch-file
ediff-regions-linewise
ediff-regions-wordwise
ediff-revision
ediff-show-registry
ediff-toggle-multiframe
ediff-toggle-use-toolbar
ediff-version
ediff-windows-linewise
ediff-windows-wordwise
ediff3

edir-merge-revisions
edir-merge-revisions-with-ancestor
edir-revisions
edirs
edirs-merge
edirs-merge-with-ancestor
edirs3

edit-abbrevs
edit-abbrevs-mode
edit-abbrevs-redefine
edit-bookmarks
edit-faces
edit-itimers
edit-kbd-macro
edit-last-kbd-macro
edit-mime
edit-named-kbd-macro
edit-picture
edit-pr
edit-tab-stops
edit-tab-stops-note-changes
edit-toolbar

edt-emulation-on
edt-set-scroll-margins

efs-display-ftp-activity
efs-nslookup-host
efs-report-bug
efs-set-passwd
efs-set-user

eieio-class-tree
eieio-describe-class
eieio-describe-generic
eieio-describe-method

eif-browse
eiffel-mode
eldoc-mode

electric-buffer-list
electric-command-history
electric-nroff-mode

elp-instrument-function
elp-instrument-list
elp-instrument-package
elp-results

emacs-lisp-byte-compile
emacs-lisp-byte-compile-and-load
emacs-lisp-mode
emacs-version

emerge
emerge-buffers
emerge-buffers-with-ancestor
emerge-files
emerge-files-with-ancestor
emerge-merge-directories
emerge-revisions
emerge-revisions-with-ancestor

enable-command
enable-flow-control

encrypt-insert-file-contents

end-kbd-macro
end-of-buffer
end-of-buffer-other-window
end-of-defun
end-of-line

enlarge-window
enlarge-window-horizontally
enlarge-window-pixels

enriched-mode
epatch

epatch-buffer
erase-buffer

erc-add-dangerous-host
erc-add-fool
erc-add-keyword
erc-add-pal
erc-autojoin-mode
erc-button-mode
erc-chanlist
erc-cmd-LIST
erc-complete
erc-completion-mode
erc-delete-dangerous-host
erc-delete-fool
erc-delete-keyword
erc-delete-pal
erc-fill-mode
erc-log-mode
erc-nickserv-identify
erc-nickserv-identify-mode
erc-notify-mode
erc-ring-mode
erc-save-buffer-in-logs
erc-select
erc-server-select
erc-services-mode
erc-spelling-mode
erc-timestamp-mode
erc-track-mode
erc-track-when-inactive-mode
erc-truncate-buffer
erc-truncate-mode
erc-xdcc-add-file

eregistry
erevision
escreen-install

eshell
eshell-command
eshell-report-bug
eshell-test
eshell-toggle
eshell-toggle-cd

eudc-edit-hotlist
eudc-expand-inline
eudc-get-email
eudc-get-phone
eudc-insert-record-at-point-into-bbdb
eudc-load-eudc
eudc-query-form
eudc-set-server
eudc-try-bbdb-insert

eval-buffer
eval-current-buffer
eval-defun
eval-expr
eval-expr-install
eval-expression
eval-last-sexp
eval-print-last-sexp
eval-region

exchange-dot-and-mark
exchange-point-and-mark

executable-self-display
executable-set-magic

execute-extended-command

exit-minibuffer
exit-recursive-edit

expand-abbrev
expand-region-abbrevs</t>
<t tx="ekr.20050921094025.264">f90-mode

facemenu-make-larger
facemenu-make-much-larger
facemenu-make-much-smaller
facemenu-make-smaller
facemenu-remove-props
facemenu-remove-special
facemenu-set-background
facemenu-set-face
facemenu-set-face-from-menu
facemenu-set-foreground
facemenu-set-intangible
facemenu-set-invisible
facemenu-set-read-only
facemenu-set-size-default

fast-lock-mode

feedmail-queue-reminder
feedmail-run-the-queue
feedmail-run-the-queue-global-prompt
feedmail-run-the-queue-no-prompts

ffap
ffap-at-mouse
ffap-menu
ffap-next

fill-individual-paragraphs
fill-nonuniform-paragraphs
fill-paragraph
fill-paragraph-or-region
fill-region
fill-region-as-paragraph

find-alternate-file
find-alternate-file-other-window
find-file
find-file-at-point
find-file-other-frame
find-file-other-window
find-file-read-only
find-file-read-only-other-frame
find-file-read-only-other-window
find-function
find-function-at-point
find-function-on-key
find-function-other-frame
find-function-other-window
find-library
find-library-other-frame
find-library-other-window
find-tag
find-tag-at-point
find-tag-other-window
find-variable
find-variable-at-point
find-variable-other-frame
find-variable-other-window

finder-by-keyword
finder-commentary
finger
first-error
fixup-whitespace
flame

floating-toolbar
floating-toolbar-from-extent-or-popup-mode-menu
floating-toolbar-or-popup-mode-menu

flush-lines

flyspell-buffer
flyspell-mode
flyspell-prog-mode
flyspell-region
flyspell-version

folding-mode
folding-mode-add-find-file-hook

font-lock-fontify-buffer
font-lock-mode

footnote-mode

format-decode-buffer
format-decode-region
format-encode-buffer
format-encode-region
format-find-file
format-insert-file
format-write-file

forms-find-file
forms-find-file-other-window
forms-mode

fortran-mode

forward-block-of-lines
forward-char
forward-char-command
forward-line
forward-list
forward-page
forward-paragraph
forward-sentence
forward-sexp
forward-to-indentation
forward-word

frame-configuration-to-register
ftelnet
ftp
full-calc
full-calc-keypad
fume-mode
fume-setup-buffer
function-menu
fundamental-mode
fusion-mode</t>
<t tx="ekr.20050921094025.265">garbage-collect
gdb
gdb-with-core
gdbsrc
generate-file-autoloads
generic-page-setup
generic-print-buffer
getenv

global-auto-revert-mode
global-semantic-auto-parse-mode
global-semantic-show-dirty-mode
global-semantic-show-unmatched-syntax-mode
global-semantic-summary-mode
global-semanticdb-minor-mode
global-senator-minor-mode
global-set-key
global-set-stroke
global-unset-key

gnats:edit-pr
gnats:query-pr
gnats:summ-pr
gnats:view-pr

gnuserv-start
gomoku

google-query
google-query-region

goto-address
goto-address-at-mouse
goto-address-at-point
goto-char
goto-line

grep
grep-all-files-in-current-directory
grep-all-files-in-current-directory-and-below
grep-find

gtk-start-drag
gtk-start-drag-region</t>
<t tx="ekr.20050921094025.266">hanoi
haskell-doc-mode
haskell-doc-show-type
haskell-mode

help
help-for-help
help-mode
help-mode-bury
help-mode-quit
help-next-section
help-next-symbol
help-prev-section
help-prev-symbol
help-quit
help-with-tutorial

hexl-find-file
hexl-mode
hexlify-buffer

hide-copyleft-region
hide-ifdef-mode

highlight-headers-follow-url
highlight-headers-follow-url-kfm
highlight-headers-follow-url-mosaic
highlight-headers-follow-url-netscape

highline-customize
highline-local-mode
highline-mode
highline-mode-off
highline-mode-on
highline-off
highline-on
highline-view-mode
highline-view-off
highline-view-on

hippie-expand
hm--html-minor-mode
hm--html-mode
hmail:compose
holidays
how-many
hs-minor-mode

html-mode
html-quote-region
html-view-get-display
html-view-goto-url
html-view-start-mosaic
html-view-view-buffer
html-view-view-file
htmlize-buffer
htmlize-file
htmlize-many-files
htmlize-many-files-dired
htmlize-region

hyper-apropos
hyper-apropos-popup-menu
hyper-apropos-set-variable
hyper-describe-face
hyper-describe-function
hyper-describe-key
hyper-describe-key-briefly
hyper-describe-variable
hyper-set-variable
hyper-where-is

hyperb:customize
hyperb:find-file-urls-mode
hyperb:init-menubar
hyperbole

hypropos-popup-menu
hypropos-set-variable</t>
<t tx="ekr.20050921094025.267">ibuffer
ibuffer-add-saved-filters
ibuffer-add-to-tmp-hide
ibuffer-add-to-tmp-show
ibuffer-auto-mode
ibuffer-backward-filter-group
ibuffer-backwards-next-marked
ibuffer-bs-show
ibuffer-clear-filter-groups
ibuffer-copy-filename-as-kill
ibuffer-customize
ibuffer-decompose-filter
ibuffer-delete-saved-filter-groups
ibuffer-delete-saved-filters
ibuffer-diff-with-file
ibuffer-do-kill-lines
ibuffer-do-occur
ibuffer-exchange-filters
ibuffer-filter-disable
ibuffer-filters-to-filter-group
ibuffer-forward-next-marked
ibuffer-invert-sorting
ibuffer-jump-to-buffer
ibuffer-jump-to-filter-group
ibuffer-kill-filter-group
ibuffer-kill-line
ibuffer-list-buffers
ibuffer-mark-by-file-name-regexp
ibuffer-mark-by-mode
ibuffer-mark-by-mode-regexp
ibuffer-mark-by-name-regexp
ibuffer-mark-dired-buffers
ibuffer-mark-dissociated-buffers
ibuffer-mark-help-buffers
ibuffer-mark-modified-buffers
ibuffer-mark-old-buffers
ibuffer-mark-read-only-buffers
ibuffer-mark-special-buffers
ibuffer-mark-unsaved-buffers
ibuffer-negate-filter
ibuffer-or-filter
ibuffer-other-window
ibuffer-pop-filter
ibuffer-pop-filter-group
ibuffer-save-filter-groups
ibuffer-save-filters
ibuffer-set-filter-groups-by-mode
ibuffer-switch-to-saved-filter-groups
ibuffer-switch-to-saved-filters
ibuffer-toggle-sorting-mode
ibuffer-yank

icomplete-mode
icon-mode
iconify-emacs
iconify-frame

id-select-and-copy-thing
id-select-and-kill-thing
id-select-goto-matching-tag
id-select-install
id-select-thing
id-select-thing-with-mouse

idl-mode
idlwave-mode
idlwave-shell
ielm
ifconfig

ignore

igrep
igrep-find
igrep-insinuate
igrep-visited-files

ilisp-imenu-add-menubar-index
image-mode

imenu
imenu-add-menubar-index
imenu-add-to-menubar

increase-left-margin
increase-right-margin

increment-register

indent-according-to-mode
indent-code-rigidly
indent-for-comment
indent-for-tab-command
indent-new-comment-line
indent-region
indent-relative
indent-relative-maybe
indent-rigidly
indent-sexp
indent-to
indent-to-column

indented-text-mode
inferior-prolog-mode
inferior-tcl

info
info-browse
info-complete-file
info-complete-symbol
info-lookup-file
info-lookup-reset
info-lookup-symbol

insert-abbrevs
insert-buffer
insert-file
insert-kbd-macro
insert-key-binding
insert-parentheses
insert-register
insert-selection
insert-zippyism

install-where-was-i
inverse-add-global-abbrev
inverse-add-mode-abbrev
invert-face
ipconfig

isearch-*-char
isearch-abort
isearch-backward
isearch-backward-regexp
isearch-cancel
isearch-complete
isearch-complete-edit
isearch-delete-char
isearch-edit-string
isearch-exit
isearch-forward
isearch-forward-exit-minibuffer
isearch-forward-regexp
isearch-help-or-delete-char
isearch-mode-help
isearch-nonincremental-exit-minibuffer
isearch-printing-char
isearch-quote-char
isearch-repeat-backward
isearch-repeat-forward
isearch-return-char
isearch-reverse-exit-minibuffer
isearch-ring-advance
isearch-ring-advance-edit
isearch-ring-retreat
isearch-ring-retreat-edit
isearch-toggle-case-fold
isearch-toggle-regexp
isearch-whitespace-chars
isearch-yank-clipboard
isearch-yank-kill
isearch-yank-line
isearch-yank-selection
isearch-yank-sexp
isearch-yank-word
isearch-yank-x-clipboard
isearch-yank-x-selection
isearch-|-char

iso-accents-mode

ispell
ispell-buffer
ispell-change-dictionary
ispell-comments-and-strings
ispell-complete-word
ispell-complete-word-interior-frag
ispell-continue
ispell-kill-ispell
ispell-message
ispell-minor-mode
ispell-pdict-save
ispell-region
ispell-word

iswitchb-buffer
iswitchb-buffer-other-frame
iswitchb-buffer-other-window
iswitchb-default-keybindings
iswitchb-display-buffer

itimer-edit-delete-itimer
itimer-edit-help
itimer-edit-next-field
itimer-edit-previous-field
itimer-edit-quit
itimer-edit-set-field</t>
<t tx="ekr.20050921094025.268">japanese-latex-mode
japanese-plain-tex-mode

java-browse
java-mode

javascript-mode
javascript-shell

jde-ant-build
jde-ant-projecthelp
jde-ant-show-options
jde-bug-debug-app
jde-build
jde-checkstyle
jde-checkstyle-customize
jde-compile
jde-compile-jde
jde-create-new-project
jde-db-set-app-args
jde-db-set-args
jde-db-set-debugger
jde-ejb-entity-bean-buffer
jde-ejb-session-bean-buffer
jde-gen-buffer
jde-gen-class-buffer
jde-gen-console-buffer
jde-gen-interface-buffer
jde-gen-jfc-app-buffer
jde-gen-junit-test-class-buffer
jde-help-browse-jdk-doc
jde-import-organize
jde-java-font-lock-setup-keywords
jde-javadoc-autodoc-at-line
jde-javadoc-checkdoc
jde-javadoc-checkdoc-at-line
jde-javadoc-checker-fix
jde-javadoc-checker-next
jde-javadoc-checker-previous
jde-javadoc-checker-quit
jde-javadoc-customize
jde-javadoc-make
jde-jdb
jde-jdb-applet
jde-make
jde-make-show-options
jde-mode
jde-open-project-file
jde-package-update
jde-run
jde-run-applet
jde-run-set-app
jde-run-set-app-args
jde-run-set-applet-doc
jde-run-set-applet-viewer
jde-run-set-args
jde-save-project
jde-set-compile-options
jde-set-global-classpath
jde-show-help
jde-stat-loc-report
jde-stat-loc-report-directory
jde-stat-loc-report-project
jde-xref-customize
jde-xref-display-call-tree
jde-xref-first-caller
jde-xref-list-uncalled-functions
jde-xref-make-xref-db
jde-xref-next-caller
jde-xref-update

join-line
jump-to-register
just-one-space
justify-current-line</t>
<t tx="ekr.20050921094025.269">kbd-macro-query
keep-lines

keyboard-escape-quit
keyboard-quit

kfile:find
kfile:view

kill-all-abbrevs
kill-buffer
kill-buffer-and-window
kill-comment
kill-console-local-variable
kill-emacs
kill-entire-line
kill-line
kill-local-variable
kill-paragraph
kill-primary-selection
kill-rectangle
kill-region
kill-ring-save
kill-sentence
kill-sexp
kill-some-buffers
kill-this-buffer
kill-word

kimport:aug-post-outline
kimport:file
kimport:star-outline
kimport:text

klink:create
kotl-mode
kotl-mode:example
ksh-mode</t>
<t tx="ekr.20050921094025.270">latex-mode
lazy-lock-mode
lazy-shot-mode
ledit-mode
liece
life
line-number-mode
linuxdoc-sgml-mode

lisp-complete-symbol
lisp-fill-paragraph
lisp-indent-for-comment
lisp-indent-line
lisp-interaction-mode
lisp-mode
lisp-send-defun

list-abbrevs
list-bookmarks
list-buffers
list-colors-display
list-command-history
list-directory
list-faces-display
list-holidays
list-itimers
list-load-path-shadows
list-matches-in-buffers
list-matching-lines
list-mode
list-mode-item-keyboard-selected
list-mode-item-mouse-selected
list-packages
list-processes
list-strokes
list-tags
list-text-properties-at
list-yahrzeit-dates

literate-haskell-mode

load-default-sounds
load-file
load-library
load-sound-file
load-user-strokes

local-set-key
local-unset-key

locate-library
lock-buffer
lower-frame
lpr-buffer
lpr-region
lua-mode</t>
<t tx="ekr.20050921094025.271">m4-mode

macroexpand-all-sexp
macroexpand-sexp

mail
mail-mode
mail-other-frame
mail-other-window

make-command-summary
make-compatible
make-compatible-variable
make-directory
make-directory-path
make-face-bold
make-face-bold-italic
make-face-italic
make-face-larger
make-face-smaller
make-face-unbold
make-face-unitalic
make-file-part
make-frame
make-indirect-buffer
make-local-variable
make-obsolete
make-obsolete-variable
make-search-dialog
make-symbolic-link
make-variable-buffer-local
makefile-mode

manual-entry
map-query-replace-regexp
mark-beginning-of-buffer

mark-bob
mark-defun
mark-end-of-buffer
mark-end-of-line
mark-end-of-sentence
mark-eob
mark-page
mark-paragraph
mark-sexp
mark-whole-buffer
mark-word

maybe-unmigrate-user-init-file
mchat
mchat-other-frame

metamail-buffer
metamail-interpret-body
metamail-interpret-header
metamail-region

mew
mew-send
mh-letter-mode
mh-nmail
mh-rmail
mh-smail
mh-smail-other-window
mh-version
migrate-user-init-file
mime-decode-region
mime-encode-region
mime-insert-encoded-file
mime/editor-mode

minibuffer-complete
minibuffer-complete-and-exit
minibuffer-complete-word
minibuffer-completion-help
minibuffer-electric-separator
minibuffer-electric-tilde
minibuffer-keyboard-quit
minibuffer-smart-maybe-select-highlighted-completion
minibuffer-smart-select-highlighted-completion

mode-compile
mode-compile-kill
mode-compile-submit-bug-report

modeline-buffers-menu
modeline-menu
modeline-minor-mode-menu
modeline-toggle-read-only

modify-syntax-entry
modula-2-mode
morse-region

mouse-avoidance-mode
mouse-bury-buffer
mouse-choose-completion
mouse-consolidated-yank
mouse-del-char
mouse-delete-window
mouse-drag-modeline
mouse-eval-last-sexpr
mouse-eval-sexp
mouse-ignore
mouse-keep-one-window
mouse-kill-line
mouse-line-length
mouse-me
mouse-scroll
mouse-select
mouse-select-and-split
mouse-set-mark
mouse-set-point
mouse-track
mouse-track-adjust
mouse-track-adjust-default
mouse-track-default
mouse-track-delete-and-insert
mouse-track-do-rectangle
mouse-track-insert
mouse-unbury-buffer
mouse-window-to-region
mouse-yank

move-past-close-and-reindent
move-to-left-margin
move-to-tab-stop
move-to-window-line

mpuz
mswindows-paste-clipboard
mwheel-install</t>
<t tx="ekr.20050921094025.272">name-last-kbd-macro

narrow-stack-mode
narrow-to-defun
narrow-to-page
narrow-to-region
narrow-window-to-region

negative-argument
netstat
network-connection
network-connection-to-service
new-frame

newline
newline-and-indent

next-complete-history-element
next-error
next-file
next-history-element
next-line
next-list-mode-item
next-matching-history-element
next-multiframe-window

normal-mode
not-modified
nroff-mode
nslookup
nslookup-host
nuke-nroff-bs
nuke-selective-display
number-to-register</t>
<t tx="ekr.20050921094025.273">objc-browse
objc-mode

occur
occur-mode-goto-occurrence
occur-mode-mouse-goto

offix-start-drag
offix-start-drag-region

old-whitespace-incremental-mode
old-whitespace-mode

oo-browser

open-dribble-file
open-line
open-rectangle
open-termscript

other-frame
other-window

outl-mouse-minor-mode
outl-mouse-mode

outline-minor-mode
outline-mode

overstrike-region
overwrite-mode
own-selection</t>
<t tx="ekr.20050921094025.274">package-admin-add-binary-package
package-admin-add-single-file-package
package-get
package-get-all
package-get-custom
package-get-delete-package
package-get-package-provider
package-get-save-base
package-get-update-all
package-get-update-base
package-get-update-base-from-buffer

paragraph-indent-text-mode
paren-activate
paren-backward-sexp
paren-deactivate
paren-forward-sexp
paren-set-mode
paren-toggle-matching-paired-delimiter
paren-toggle-matching-quoted-paren
paren-toggle-open-paren-context

pascal-mode
patch-to-change-log

patcher-mail
patcher-mail-subproject
patcher-version

pcomplete
pcomplete-continue
pcomplete-expand
pcomplete-expand-and-complete
pcomplete-help
pcomplete-list
pcomplete-reverse

pdb

pending-delete
pending-delete-mode
pending-delete-off
pending-delete-on

perl-mode
perldb
permanent-buffers-mode

pgg-decrypt
pgg-decrypt-region
pgg-encrypt
pgg-encrypt-region
pgg-insert-key
pgg-sign
pgg-sign-region
pgg-snarf-keys
pgg-snarf-keys-region
pgg-verify
pgg-verify-region

phases-of-moon
php-mode
picture-mode
pike-mode
ping

plain-TeX-mode
plain-tex-mode

play-sound-file
point-to-register

pop-global-mark
pop-tag-mark
pop-window-configuration

popper-install

popup-buffer-menu
popup-menubar-menu
popup-mode-menu

posix-search-backward
posix-search-forward

postscript-mode

pp-eval-expression
pp-eval-last-sexp
pp-function
pp-plist
pp-variable

praise-be-unto-emacs
praise-be-unto-xemacs

prefer-coding-system
prefix-region

prepend-to-buffer
prepend-to-register

press-toolbar-button

prettyexpand-all-sexp
prettyexpand-sexp

previous-complete-history-element
previous-error
previous-history-element
previous-line
previous-list-mode-item
previous-matching-history-element
previous-multiframe-window

print-buffer
print-region

profile-command
profile-expression
profile-key-sequence
profile-results

prolog-mode

ps
ps-despool
ps-line-lengths
ps-nb-pages-buffer
ps-nb-pages-region
ps-print-buffer
ps-print-buffer-with-faces
ps-print-customize
ps-print-region
ps-print-region-with-faces
ps-spool-buffer
ps-spool-buffer-with-faces
ps-spool-region
ps-spool-region-with-faces

psychoanalyze-pinhead
pui-add-install-directory
pui-list-packages
push-window-configuration
pwd

py-shell
pydoc-apropos
pydoc-commands
pydoc-help
pydoc-keywords
pydoc-modules
pydoc-packages
pydoc-topics
pydoc-xrefs

pymacs-eval
pymacs-load

python-browse
python-mode</t>
<t tx="ekr.20050921094025.275">query-pr
query-replace
query-replace-regexp
quick-calc
quoted-insert</t>
<t tx="ekr.20050921094025.276">raise-frame

re-builder
re-search-backward
re-search-forward

read-abbrev-file
read-kbd-macro
read-library-name

recent-files-initialize
recent-files-visit-file

recenter

recentf-cancel-dialog
recentf-cleanup
recentf-dialog-mode
recentf-edit-list
recentf-mode
recentf-open-files
recentf-open-more-files
recentf-rebuild-virtual-pathes
recentf-save-list

recover-all-files
recover-file
recover-session
recover-session-finish

recursive-edit

reftex-citation
reftex-index-phrases-mode
reftex-mode

regexp-builder
register-to-point
reindent-then-newline-and-indent
release-and-activate-toolbar-button
release-toolbar-button
remote-compile
remove-directory

rename-buffer
rename-file
rename-uniquely

repeat-complex-command
repeat-matching-complex-command

replace-buffer-in-windows
replace-rectangle
replace-regexp
replace-string

report-emacs-bug
report-xemacs-bug

reposition-window
resize-minibuffer-mode
restore-initial-toolbar
resume-console
reverse-region
revert-buffer
rexx-mode
riece
rlogin

rmail
rmail-input
rmail-mode

rolo-add
rolo-display-matches
rolo-edit
rolo-fgrep
rolo-fgrep-logical
rolo-grep
rolo-kill
rolo-sort
rolo-toggle-datestamps
rolo-yank

rot13-other-window
rotate-yank-pointer
route

rpm
rpm-spec-mode

rsh

rtf-clip-buffer
rtf-clip-region
rtf-export
rtf-export-region
rtf-spool-buffer
rtf-spool-region

ruby-mode
rubydb

run-at-time
run-caml
run-ediff-from-cvs-buffer
run-prolog
run-ruby
run-scheme
run-scsh
run-sml
run-with-idle-timer
run-with-timer</t>
<t tx="ekr.20050921094025.277">s-region-bind
s-region-bind-cua

save-buffer
save-buffers-kill-emacs
save-some-buffers

savehist-load
savehist-save

scheme-mode
scribe-mode

scroll-down
scroll-down-command
scroll-down-one
scroll-left
scroll-other-window
scroll-other-window-down
scroll-right
scroll-up
scroll-up-command
scroll-up-one

sdb

search-backward
search-backward-regexp
search-forward
search-forward-regexp

self-insert-and-exit
self-insert-command

semantic-analyze-current-context
semantic-auto-parse-mode
semantic-bnf-mode
semantic-cb-speedbar-mode
semantic-chart-database-size
semantic-chart-nonterminal-complexity-token
semantic-chart-nonterminals-by-token
semantic-show-dirty-mode
semantic-show-unmatched-syntax-mode
semantic-summary-mode

senator-complete-symbol
senator-completion-menu-popup
senator-jump
senator-jump-regexp
senator-minor-mode
senator-next-token
senator-previous-token
senator-re-search-backward
senator-re-search-forward
senator-search-backward
senator-search-forward
senator-word-search-backward
senator-word-search-forward

send-pr
send-pr-mode
send-pr:send-pr
send-pr:send-pr-mode

set-buffer-file-coding-system
set-buffer-file-coding-system-for-read
set-buffer-process-coding-system
set-comment-column
set-default-buffer-file-coding-system
set-default-file-coding-system
set-face-background
set-face-background-pixmap
set-face-blinking-p
set-face-dim-p
set-face-display-table
set-face-doc-string
set-face-font
set-face-foreground
set-face-highlight-p
set-face-reverse-p
set-face-strikethru-p
set-face-underline-p
set-file-coding-system
set-file-coding-system-for-read
set-fill-column
set-fill-prefix
set-goal-column
set-justification
set-justification-center
set-justification-full
set-justification-left
set-justification-none
set-justification-right
set-keyboard-coding-system
set-left-margin
set-mark-command
set-pathname-coding-system
set-right-margin
set-selective-display
set-terminal-coding-system
set-variable
set-visited-file-name

setenv
setnu-mode
sgml-mode
sh-mode

shell
shell-command
shell-command-on-region
shell-script-mode

show-message-log

shrink-window
shrink-window-horizontally
shrink-window-if-larger-than-buffer
shrink-window-pixels

sieve-manage
sieve-mode
sieve-upload
sieve-upload-and-bury

signal-process
simula-mode

skeleton-pair-insert-maybe
skeleton-proxy
skeleton-proxy-new

smart-c++
smart-info
smart-info-assist
smart-java
smart-objc

smerge
sml-mode
smt-browse
snake
sokoban

sort-columns
sort-fields
sort-float-fields
sort-lines
sort-numeric-fields
sort-pages
sort-paragraphs
sort-regexp-fields
sort-regexp-fields-numerically

speedbar
speedbar-frame-mode
speedbar-get-focus

spell-buffer
spell-region
spell-string
spell-word

split-line
split-window
split-window-horizontally
split-window-vertically

spook

sql-db2
sql-help
sql-informix
sql-ingres
sql-interbase
sql-linter
sql-mode
sql-ms
sql-mysql
sql-oracle
sql-postgres
sql-product-interactive
sql-solid
sql-sqlite
sql-sybase

ssh
standard-display-european
start-itimer
start-kbd-macro
startup-presentation-hack
string-rectangle

strokes-compose-complex-stroke
strokes-decode-buffer
strokes-describe-stroke
strokes-do-complex-stroke
strokes-do-stroke
strokes-global-set-stroke
strokes-help
strokes-list-strokes
strokes-load-user-strokes
strokes-mode

style-format
summ-pr
sunrise-sunset

suspend-console
suspend-emacs
suspend-emacs-or-iconify-frame
suspend-or-iconify-emacs

switch-to-buffer
switch-to-buffer-other-frame
switch-to-buffer-other-window
switch-to-completions
switch-to-other-buffer

symbol-file
symbol-near-point</t>
<t tx="ekr.20050921094025.278">tab-to-tab-stop
tabify

tag-complete-symbol
tags-apropos
tags-loop-continue
tags-query-replace
tags-search

tcl-help-on-word
tcl-mode

tdbx
teco-command
telnet
term
terminal-emulator
tetris

tex-mode
texi2info
texinfo-format-buffer
texinfo-format-region
texinfo-mode
texmathp

text-mode
tgdb
time-stamp
time-stamp-toggle-active

tmpl-expand-templates-in-buffer
tmpl-expand-templates-in-region
tmpl-insert-template-file
tmpl-insert-template-file-from-fixed-dirs
tmpl-minor-mode

toggle-auto-compression
toggle-buffer-file-coding-system
toggle-debug-on-error
toggle-debug-on-quit
toggle-debug-on-signal
toggle-profiling
toggle-read-only
toggle-rot13-mode
toggle-text-mode-auto-fill
toggle-truncate-lines
toggle-viper-mode
toggle-where-was-i

toolbar-add-button-on-the-fly
toolbar-add-execute-macro-button
toolbar-add-kbd-macro
toolbar-compile
toolbar-copy
toolbar-cut
toolbar-debug
toolbar-dired
toolbar-external
toolbar-gnus
toolbar-info
toolbar-ispell
toolbar-ispell-internal
toolbar-mail
toolbar-news
toolbar-not-configured
toolbar-open
toolbar-paste
toolbar-print
toolbar-redo
toolbar-replace
toolbar-save
toolbar-search
toolbar-undo

top-level
tperldb
tpu-edt
tpu-edt-mode
tpu-edt-on
tpu-set-cursor-bound
tpu-set-cursor-free
tpu-set-scroll-margins

tpum-global-mode
tpum-minor-mode

trace-function
trace-function-background
traceroute

transpose-chars
transpose-line-down
transpose-line-up
transpose-lines
transpose-paragraphs
transpose-preceding-chars
transpose-sentences
transpose-sexps
transpose-words

tree-test-it-all
tsdb
tshell

turn-off-font-lock
turn-off-haskell-doc-mode
turn-off-pending-delete
turn-on-auto-fill
turn-on-eldoc-mode
turn-on-font-lock
turn-on-fume-mode
turn-on-haskell-doc-mode
turn-on-pending-delete
turn-on-permanent-buffers

txdb</t>
<t tx="ekr.20050921094025.279">uil-mode
undefined
underline-region
undo
unexpand-abbrev
unhide-copyleft-region

universal-argument
universal-argument-minus
universal-argument-more
universal-argument-other-key
universal-coding-system-argument

unix-sync
unload-feature
unlock-buffer
unmigrate-user-init-file
unmorse-region
unoverstrike-region
unpop-window-configuration
unrmail
untabify
ununderline-and-unoverstrike-region
ununderline-region
up-list

upcase-initials-region
upcase-region
upcase-region-or-word
upcase-word

update-autoloads-from-directory
update-autoloads-here
update-file-autoloads

url-gateway-nslookup-host
url-mail
url-setup-save-timer

use-hard-newlines
user-mail-address</t>
<t tx="ekr.20050921094025.280">vc-annotate
vc-cancel-version
vc-create-snapshot
vc-diff
vc-directory
vc-insert-headers
vc-load-vc-hooks
vc-merge
vc-next-action
vc-print-log
vc-register
vc-rename-file
vc-resolve-conflicts
vc-retrieve-snapshot
vc-revert-buffer
vc-update-change-log
vc-version-diff
vc-version-other-window

verilog-customize
verilog-mode
verilog-version

version
vertical-mode
vhdl-mode

view-buffer
view-buffer-other-window
view-emacs-news
view-file
view-file-other-window
view-lossage
view-major-mode
view-minor-mode
view-mode
view-pr
view-register
view-sample-init-el

viper-mode
visit-tags-table

vm
vm-compose-mail
vm-folders-summarize
vm-mail
vm-mail-other-frame
vm-mail-other-window
vm-mode
vm-other-frame
vm-other-window
vm-submit-bug-report
vm-visit-folder
vm-visit-folder-other-frame
vm-visit-folder-other-window
vm-visit-imap-folder
vm-visit-imap-folder-other-frame
vm-visit-imap-folder-other-window
vm-visit-pop-folder
vm-visit-pop-folder-other-frame
vm-visit-pop-folder-other-window
vm-visit-virtual-folder
vm-visit-virtual-folder-other-frame
vm-visit-virtual-folder-other-window

vrml-mode</t>
<t tx="ekr.20050921094025.281">w3
w3-display-stylesheet
w3-fetch
w3-fetch-other-frame
w3-find-file
w3-follow-link
w3-follow-url-at-point
w3-follow-url-at-point-other-frame
w3-hotindex-add-key
w3-hotindex-query
w3-hotindex-rm-key
w3-hotlist-add-document
w3-hotlist-add-document-at-point
w3-hotlist-append
w3-hotlist-apropos
w3-hotlist-delete
w3-hotlist-refresh
w3-hotlist-rename-entry
w3-maybe-follow-link
w3-maybe-follow-link-mouse
w3-next-document
w3-open-local
w3-prev-document
w3-preview-this-buffer
w3-print-this-url
w3-print-url-under-point
w3-read-html-bookmarks
w3-region
w3-show-dvi
w3-table-speak-current-table-column
w3-use-hotlist
w3-version

wconfig-add-by-name
wconfig-delete-by-name
wconfig-delete-pop
wconfig-restore-by-name
wconfig-ring-save
wconfig-yank-pop

webjump

what-coding-system
what-cursor-position
what-domain
what-line
what-page

where-is

whitespace-buffer
whitespace-cleanup
whitespace-cleanup-region
whitespace-global-mode
whitespace-region
whitespace-toggle-ateol-check
whitespace-toggle-indent-check
whitespace-toggle-leading-check
whitespace-toggle-spacetab-check
whitespace-toggle-trailing-check
whitespace-visual-incremental-mode
whitespace-visual-mode
whitespace-write-file-hook

whois
whois-reverse-lookup
widen

widget-backward
widget-beginning-of-line
widget-browse
widget-browse-at
widget-browse-other-window
widget-button-click
widget-button-press
widget-button1-click
widget-complete
widget-end-of-line
widget-field-activate
widget-file-complete
widget-forward
widget-kill-line
widget-minor-mode
widget-transpose-chars

win32-get-current-locale-id
win32-get-default-locale-id
win32-get-locale-info
win32-get-valid-locale-ids
win32-long-file-name
win32-set-current-locale
win32-set-process-priority
win32-short-file-name

window-configuration-to-register
winmgr-mode

winring-delete-configuration
winring-duplicate-configuration
winring-jump-to-configuration
winring-new-configuration
winring-next-configuration
winring-prev-configuration
winring-rename-configuration

word-search-backward
word-search-forward

wordstar-mode

write-abbrev-file
write-file
write-region
write-region-internal

wrolo-popup-menu</t>
<t tx="ekr.20050921094025.282">x-symbol-decode
x-symbol-decode-recode
x-symbol-encode
x-symbol-encode-recode
x-symbol-fontify
x-symbol-grid
x-symbol-image-editor
x-symbol-image-parse-buffer
x-symbol-init-language-interactive
x-symbol-initialize
x-symbol-key-autoload
x-symbol-map-autoload
x-symbol-mode
x-symbol-modify-key
x-symbol-package-bug
x-symbol-package-info
x-symbol-package-reply-to-report
x-symbol-package-web
x-symbol-rotate-key
x-symbol-unalias

xdb

xemacs-local-faq
xemacs-splash-buffer
xemacs-www-faq
xemacs-www-page

xetla
xetla-add-log-entry
xetla-apply-changeset
xetla-archives
xetla-bookmarks
xetla-browse
xetla-changelog
xetla-changes
xetla-changes-against
xetla-changes-last-revision
xetla-commit
xetla-conflicts-finish
xetla-delta
xetla-ediff-add-log-entry
xetla-edit-log
xetla-file-diff
xetla-file-ediff
xetla-file-ediff-revisions
xetla-file-view-original
xetla-get-changeset
xetla-help
xetla-id-tagging-method
xetla-inventory
xetla-inventory-file-mode
xetla-log-edit-mode
xetla-logs
xetla-make-archive
xetla-missing
xetla-my-id
xetla-my-revision-library
xetla-prepare-patch-submission
xetla-revisions
xetla-rm
xetla-start-project
xetla-submit-bug-report
xetla-tag-insert
xetla-tag-regenerate
xetla-tree-lint
xetla-tree-version
xetla-version
xetla-view-conflicts

xmine
xmine-mode
xml-mode
xpm-mode
xrdb-mode
xsl-grep
xsl-mode
xslt-process-mode
xt-check-xlib

xwem-attach-client
xwem-backward-application
xwem-balance-windows
xwem-battery
xwem-battery-popup-menu
xwem-battery-status
xwem-cl-pop-to-client
xwem-cl-set-title
xwem-cl-switch-other-frame
xwem-cl-switch-other-win
xwem-cl-switch-to-other
xwem-cl-switch-to-other-in-other-win
xwem-cl-transpose
xwem-clgen-toggle-other-on-split
xwem-clgen-turn-off-other-on-split
xwem-clgen-turn-on-other-on-split
xwem-client-demanage-others
xwem-client-exchange-selected-and-mark
xwem-client-iconify
xwem-client-idestroy
xwem-client-imove
xwem-client-info
xwem-client-iresize
xwem-client-kill
xwem-client-query-kill
xwem-client-run-copy
xwem-client-run-copy-other-frame
xwem-client-run-copy-other-win
xwem-client-set-mark
xwem-client-unset-mark
xwem-clswi-next
xwem-clswi-next-other-window
xwem-clswi-prev
xwem-clswi-prev-other-window
xwem-copy-cutbuffer
xwem-copy-region-as-cutbuffer
xwem-describe-prefix-bindings
xwem-desktop-load
xwem-desktop-load-onetime
xwem-desktop-save
xwem-desktop-save-onetime
xwem-edit-client-properties
xwem-edmacro-edit-kbd-macro
xwem-eval-expression
xwem-execute-extended-command
xwem-fini
xwem-focus-click-on
xwem-forward-application
xwem-frame-destroy
xwem-frame-fit-screen
xwem-frame-goto-next
xwem-frame-goto-next-hor
xwem-frame-goto-next-vert
xwem-frame-goto-prev
xwem-frame-goto-prev-hor
xwem-frame-goto-prev-vert
xwem-frame-hide
xwem-frame-imove
xwem-frame-iresize
xwem-frame-lower
xwem-frame-next
xwem-frame-on-delim-menu
xwem-frame-on-delim-resize
xwem-frame-previous
xwem-frame-raise
xwem-frame-sbs-hor-split
xwem-frame-sbs-vert-split
xwem-frame-set-name
xwem-frame-showroot
xwem-frame-split-sbs
xwem-frame-switch
xwem-frame-switch-nth
xwem-frame-switch-nth-linkage
xwem-frame-transparency
xwem-frame-transpose
xwem-framei-dockapp-popup-alt-menu
xwem-framei-dockapp-popup-menu
xwem-fullscreen-mode
xwem-help
xwem-help-clients
xwem-help-cutbuffers
xwem-help-describe-bindings
xwem-help-describe-key
xwem-help-describe-key1
xwem-help-for-help
xwem-help-frames
xwem-help-mode
xwem-help-where-is
xwem-help-wins
xwem-ignore-command
xwem-kbd-quit
xwem-kbd-quote-command
xwem-keyboard-quit
xwem-keymacro-begin
xwem-keymacro-end
xwem-keymacro-exit-recursive-edit
xwem-keymacro-recursive-edit
xwem-keymacro-undefined
xwem-keytt-minor-mode
xwem-kill-cl-and-window
xwem-launch-dock-down
xwem-launch-dock-launch
xwem-launch-dock-menu
xwem-launch-lupe
xwem-launch-lupe-other-frame
xwem-launch-lupe-other-win
xwem-launch-program
xwem-launch-program-other-frame
xwem-launch-program-other-win
xwem-launch-xlock
xwem-launch-xterm
xwem-launch-xterm-other-frame
xwem-launch-xterm-other-win
xwem-launcher-toggle-frame-type
xwem-launcher-toggle-split-type
xwem-launcher-turn-on-embedded-frame-type
xwem-launcher-turn-on-horizontal-split-type
xwem-launcher-turn-on-normal-frame-type
xwem-launcher-turn-on-vertical-split-type
xwem-make-frame
xwem-mini-calc
xwem-minib-resize-mode
xwem-minibuffer-activate
xwem-misc-make-screenshot
xwem-misc-pause
xwem-misc-profiling-results
xwem-misc-start-profiling
xwem-modeline-disable
xwem-modeline-enable
xwem-open-file
xwem-other-window
xwem-pager
xwem-pager-move-down
xwem-pager-move-left
xwem-pager-move-right
xwem-pager-move-up
xwem-paste-cutbuffer
xwem-popup-auto-menu
xwem-popup-clients-menu
xwem-recover-do-recover
xwem-recover-toggle
xwem-recover-turn-off
xwem-recover-turn-on
xwem-register-client
xwem-register-frame-config
xwem-register-jump
xwem-register-win-config
xwem-report-bug
xwem-rooter-lower
xwem-rooter-raise
xwem-run-program
xwem-self-insert-or-undefined
xwem-shell-command
xwem-show-message-log
xwem-sm-global-mode
xwem-sm-mode
xwem-strokes-begin
xwem-strokes-cmplx-begin
xwem-strokes-define
xwem-strokes-ibutton1
xwem-strokes-ibutton1up
xwem-strokes-ibutton3
xwem-strokes-idescribe
xwem-strokes-list
xwem-strokes-nocmd
xwem-strokes-unset-last-stroke
xwem-switch-client
xwem-switch-other-client
xwem-switch-to-fullscreen-cl
xwem-tabber-popup-cl-menu
xwem-tabber-switch-cl
xwem-theme-set
xwem-time
xwem-toggle-fullscreen
xwem-transpose-frames
xwem-turn-off-keytt
xwem-turn-off-vline
xwem-turn-on-keytt
xwem-turn-on-vline
xwem-undefined-command
xwem-universal-argument
xwem-universal-command
xwem-universal-digit
xwem-universal-minus
xwem-universal-more
xwem-vline-minor-mode
xwem-weather-popup-menu
xwem-weather-popup-remove
xwem-weather-show-details
xwem-weather-update
xwem-window-delete
xwem-window-delete-others
xwem-window-enlarge-horizontally
xwem-window-enlarge-vertically
xwem-window-split-horizontally
xwem-window-split-vertically
xwem-winmove-down
xwem-winmove-left
xwem-winmove-right
xwem-winmove-up
xwem-worklog-login
xwem-worklog-logout</t>
<t tx="ekr.20050921094025.283">yank
yank-clipboard-selection
yank-pop
yank-rectangle
yow
</t>
<t tx="ekr.20050921094025.284">zap-to-char
zap-up-to-char
zenirc</t>
<t tx="ekr.20050921100955"></t>
<t tx="ekr.20050921101706"></t>
<t tx="ekr.20050921103230">def defineEditorMenuTables (self):
    
    def dummyCommand():
        pass
    
    self.emacsMenuCommandsMenuTable = [
        ('Cmnd Command 1',dummyCommand),
    ]
    
    self.emacsMenuToolsMenuTable = [
        ('Tools Command 1',dummyCommand),
    ]

    self.emacsMenuOptionsMenuTable = [
        ('Options Command 1',dummyCommand),
    ]

    self.emacsMenuBuffersMenuTable = [
        ('Buffers Command 1',dummyCommand),
    ]</t>
<t tx="ekr.20050921103736">def createEditorMenuFromTable (self):

    cmdsMenu = self.createNewMenu('C&amp;mds')

    for name,table,sep in (
        #('View...',   self.emacsMenuViewMenuTable,    True),
        ('Commands...',self.emacsMenuCommandsMenuTable,True),
        ('Tools...',   self.emacsMenuToolsMenuTable,   True),
        ('Options...', self.emacsMenuOptionsMenuTable, True),
        ('Buffers...', self.emacsMenuBuffersMenuTable, False),
    ):
        menu = self.createNewMenu(name,'Cmds')
        self.createMenuEntries(menu,table)
        if sep: self.add_separator(cmdsMenu)</t>
<t tx="ekr.20050921105623"></t>
<t tx="ekr.20050921105623.1">No longer needed.</t>
<t tx="ekr.20050922080526">Thie problem was in the code at the end of keyHandler.finishCreate.

The watchDelete hack was interfering with some kind of event.

It was an ugly hack anyway ;-)</t>
<t tx="ekr.20050922104731">def finishCreateEditCommanders (c):
    
    '''Finish creating edit classes in the commander.
    
    Return the commands dictionary for all the classes.'''
    
    global classesList
    
    d = {}

    for name, theClass in classesList:
        theInstance = getattr(c,name)
        theInstance.finishCreate()
        theInstance.init()
        d2 = theInstance.getPublicCommands()
        if d2:
            d.update(d2)
            if 0:
                keys = d2.keys()
                keys.sort()
                print '----- %s' % name
                for key in keys: print
                
    return d</t>
<t tx="ekr.20050923141539">- Eliminated iterator class.  (I now understand the code :-)
- Automatically call b.clearState() and b.keyboardQuit() before dispatching commands.
- Tab completion returns a non-trivial common prefix if it exists.  Further tabs cycle through possibilities.</t>
<t tx="ekr.20050923143034">- Keys are full Emacs command names, values are methods.</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.stateKind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.1">def makeHardBindings (self):
    
    '''Define the bindings used in quick-command mode.'''
    
    k = self ; c = k.c
    
    self.negArgFunctions = {
        '&lt;Alt-c&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-u&gt;': c.editCommands.changePreviousWord,
        '&lt;Alt-l&gt;': c.editCommands.changePreviousWord,
    }
    
    # No longer used.  Very weird.
    self.keystrokeFunctionDict = {
        '&lt;Control-s&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Control-r&gt;':      (2, c.searchCommands.startIncremental),
        '&lt;Alt-g&gt;':          (1, c.editCommands.gotoLine),
        '&lt;Alt-z&gt;':          (1, c.killBufferCommands.zapToCharacter),
        '&lt;Alt-percent&gt;':    (1, c.queryReplaceCommands.queryReplace),
        '&lt;Control-Alt-w&gt;':  (1, lambda event: 'break'),
    }

    self.abbreviationFuncDict = {
        'a':    c.abbrevCommands.addAbbreviation,
        'a i':  c.abbrevCommands.addInverseAbbreviation,
    }
    
    self.rCommandDict = {
        'space':    c.registerCommands.pointToRegister,
        'a':        c.registerCommands.appendToRegister,
        'i':        c.registerCommands.insertRegister,
        'j':        c.registerCommands.jumpToRegister,
        'n':        c.registerCommands.numberToRegister,
        'p':        c.registerCommands.prependToRegister,
        'r':        c.rectangleCommands.enterRectangleState,
        's':        c.registerCommands.copyToRegister,
        'v':        c.registerCommands.viewRegister,
        'plus':     c.registerCommands.incrementRegister,
    }
    
    self.variety_commands = {
        # Keys are Tk keysyms.
        'period':       c.editCommands.setFillPrefix,
        'parenleft':    c.macroCommands.startKbdMacro,
        'parenright':   c.macroCommands.endKbdMacro,
        'semicolon':    c.editCommands.setCommentColumn,
        'Tab':          c.editCommands.tabIndentRegion,
        'u':            c.undoer.undo,
        'equal':        c.editCommands.lineNumber,
        'h':            c.frame.body.selectAllText,
        'f':            c.editCommands.setFillColumn,
        'b':            c.bufferCommands.switchToBuffer,
        'k':            c.bufferCommands.killBuffer,
    }
    
    self.xcommands = {
        '&lt;Control-t&gt;':  c.editCommands.transposeLines,
        '&lt;Control-u&gt;':  c.editCommands.upCaseRegion,
        '&lt;Control-l&gt;':  c.editCommands.downCaseRegion,
        '&lt;Control-o&gt;':  c.editCommands.removeBlankLines,
        '&lt;Control-i&gt;':  c.editFileCommands.insertFile,
        '&lt;Control-s&gt;':  c.editFileCommands.saveFile,
        '&lt;Control-x&gt;':  c.editCommands.exchangePointMark,
        '&lt;Control-c&gt;':  c.controlCommands.shutdown,
        '&lt;Control-b&gt;':  c.bufferCommands.listBuffers,
        '&lt;Control-Shift-at&gt;': lambda event: event.widget.selection_clear(),
        '&lt;Delete&gt;':     c.killBufferCommands.backwardKillSentence,
    }</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName,forceFocus)
    
    return func</t>
<t tx="ekr.20050923213858"># Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)
    
# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []

# For getArg...
self.afterGetArgState = None
self.argTabList = []

if 0: # These are now set in makeSpecialBindings.
    self.abortAllModesKey = 'Control-g'
    self.fullCommandKey = 'Alt-x'
    self.universalArgKey = 'Control-u'</t>
<t tx="ekr.20050923233827">- Eliminated self.tbuffer

- Removed all subclssses from keyHandlerClass.
    - Replaced all references to keyHandler, miniBuffer, kstrokeManager, etc.
    - All methods are now methods of the keyHandler class.

- k denotes the keyHandler class everywhere.
    - All commands classes define k ivar that refers to keyHandler.

- Replaced tbuffer by w everywhere.

The effect of these changes:
    - There is never any confusion about how to access a keyHandler method: just use k.whatever.
    - The init logic is simple and clean.
    - The client code is visually much shorter and easier to understand.
    - The keyHandler class is now simpler, though larger.
    - There is no need for redirector methods.</t>
<t tx="ekr.20050924064254">@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20050924073836.1">- setEvent is only used in one commands class, so it was moved there.

- setLabelBlue and setLabelGrey now can set the label text as well as color.
  This is a nice simplification of the client code.

- Changed k.get, k.set and k.update to k.getLabel, k.setLable and k.updateLabel.
  This is an important clarification.

- Used simplified state-handling scheme, under control of k.newState ivar.
    - I now see that state-handling is actually fully encapsulated in the commands classes.
    - In particular, masterCommand knows essentially nothing of states.
    - Removed getStateCommands dicts.

- Simplified keyboardQuit by defining leoEditCommands.initAllEditCommanders at the module level.
    - This call theInstance.init() for all commands classes.
      The default in the base class does nothing.</t>
<t tx="ekr.20050925105522">* Complete Editor menu.

- (1-2 days) Complete generalization of code.
    - Allow state-oriented shortcuts (C-x C-x, for example)
    - Create new kinds of commands dispatchers: vim, tree, etc.
        - Single-key mode == vim mode??

- (1-2 hours) Tab completion for file commands.

- (1-2 days) Emacs-style help: appropos, etc.
    - printLongCommandName (like Emacs Ctrl-H Ctrl-K) command prints long name of any keystroke command.

* @link-unl/url/etc.</t>
<t tx="ekr.20050927101829.2">def buildBufferList (self):

    '''Build a buffer list from an outline.'''
    
    self.positions =  {}
    self.tnodes = {}

    for p in c.allNodes_iter():
    
        t = p.v.t ; h = t.headString()
        
        theList = self.positions.get(h,[])
        theList.append(p.copy())
        self.positions [h] = theList
        
        self.tnodes [h] = t.bodyString()</t>
<t tx="ekr.20050927102645"></t>
<t tx="ekr.20050928092516"># Clear the list, any other character besides tab indicates that a new prefix is in effect.
k.mb_tabList = []

if prefix:
    k.mb_tabListPrefix = prefix
    k.mb_prefix = prefix
    k.mb_prompt = prefix
else:
    k.mb_tabListPrefix = k.mb_prefix = k.getLabel()
    k.mb_prompt = ''</t>
<t tx="ekr.20050928112629"></t>
<t tx="ekr.20050928144501">* Traditional Emacs commands must be generalized to handle the more complex
envirnoment Leo offers. For example, search commands must be told whether to
limit the search a single node, or a node or and its descendents, or the entire
outline.

    - Expand 'point' so it indicates node as well as text location.
    - Allow Leo options (e.g. search options) in Emacs commands.
    - (Maybe) a default-search-command.
    - Implement set-variable command that sets a (Python) variable using an emacs-style variable name.
    
* At present, there are two versions of some operations, the traditional Leo way and the Emacs way.  Some simplification is needed.

* Many more commands are needed to support 'mouseless-Leo'.
    - The user must be able to set Emacs and Leo options from the keyboard.
    - The user must be able to drive all dialogs from the keyboard,
      **or to get the same effect without using a dialog at all**.

- Expand names for some Leo commands  new -&gt; new-outline, etc.

- Emacs search commands are limited to a single node.

- There should be a method for the 'check-spelling' command. (use button code)

- cycle-active-pane and cycle-active-widget (in a single pane) commands.

- create-tab, clear-tab commands, etc.
    These might get the tab name from the minibuffer...</t>
<t tx="ekr.20050928144501.1">Control all Leo commands &amp; widgets using only key commands.

- emacs commands for buttons, dialogs, etc.
    - dismiss-top-dialog command.
    - Scroll outline pane up/down

- emacs commands to change focus, etc.
    - focus-in-body/tree/log/dialog.

- emacs commands for menus.
    - activate-xxx-menu commands.  (alternative to XP Alt-f, Alt-E, etc.)



</t>
<t tx="ekr.20050929075341"></t>
<t tx="ekr.20050929075920">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3355954
By: nobody

Well, I came to the conclusion that there is no setting for body selection colors.
Please consider adding such settings in the future.

I changed it the source (Code--&gt;Gui Tkinter classes--&gt;@thin
leoTkinterFrame.py--&gt;class leoTkinterBody--&gt; Birth &amp; death--&gt;tkBody.createControl).
CadetBlue3 is more cheerful than Gray80, and syntax coloring still looks good.
</t>
<t tx="ekr.20050929082939">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3351985
By: leouserz

I have ran into my first case of actual brittleness in regular leos read code.

If I output via dom a tnode that has no text it does it like so:
&lt;t/&gt;

leo yacks on the fact that it was expecting:
&lt;t&gt;&lt;/t&gt;</t>
<t tx="ekr.20050929084510">@

idle_body_key was being called twice for every keystroke.
Why this worked at all is still a bit of a mystery.
The fix was to eliminate the binding to &lt;Key&gt; in tkBody.createBindings.

To do: remove the cut/copy/paste bindings in tkBody.createBindings.</t>
<t tx="ekr.20050929115226.1">def backCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s - 1c' % i)
    except Exception:
        pass #  w might not be a text widget.
    
def forwardCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s + 1c' % i)
    except Exception:
        pass #  w might not be a text widget.
</t>
<t tx="ekr.20050929163010">def backwardDeleteCharacter (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.delete('%s-1c' % (i), '%s' % (i))
    except Exception:
        pass #  w might not be a text widget.</t>
<t tx="ekr.20050929163210">def nextLine (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s + 1l' % i) # 1Line
    except Exception:
        pass #  w might not be a text widget.

def prevLine (self,event):

    try:
        w = event.widget
        i = w.index('insert')
        w.mark_set('insert','%s - 1l' % i) # 1Line
    except Exception:
        pass #  w might not be a text widget.</t>
<t tx="ekr.20050929170812">def manufactureKeyPress (self,event,keysym):
    
    return self.k.manufactureKeyPress(event,keysym)</t>
<t tx="ekr.20050930083044">@killcolor

Invoking:
    emacs file1 file2 file3 .... 

Help
    CTRL-h enters the Help facility.
    Help Tutorial  (CTRL-h t)
    Help Apropos   (CTRL-h a) find a command given its functionality,
    Help Character (CTRL-h c) describes a given character's effect,
    Help Function ( CTRL-h f) describes a given Lisp function specified by name.

Reading, writing files
    C-x C-f Find file (to read into buffer) 
    C-x C-s Save current buffer (ie. file in the buffer) 

Moving the cursor
    C-f forward character 
    C-b backward character 
    C-n next line 
    C-p previous line 
    C-e move cursor to end of line 
    C-a move cursor to beginning of line 
    Esc-&lt; move cursor to top of document 
    Esc-&gt; move cursor to bottom of document 
    Esc-f forward word 
    Esc-b backward word 
    Esc-a backward sentence 
    Esc-e forward sentence 
    Esc-] forward paragraph 
    Esc-[ backward paragraph 
    C-v forward page 
    Esc-v backward page 
    Esc-x goto-linen 
    Esc-x goto-char 
    C-l recenter and redraw page 

Repeating Commands
    ESC-5 C-f       move forward 5 chars 
    C-u (the universal argument command)
        Just like Esc-n, but does not need an argument -&gt; in which case the default of 4 is used. eg: 
    C-u C-u -&gt; repeat 16 times 

Deleting Stuff (Killing)
    C-d delete char 
    E-d kill word 
    C-k kill line (but not newline after it) 
    C-u C-k delete 4 lines (not 2 lines! - newlines go too!) 
    E-4 C-k same 

Yanking back things from the Kill ring
    C-y yank 
    C-w kill region 
    E-w copy region into kill ring 
    C-@ or C-SPC set-mark 
    
Paragraph Reformatting
    E-q fill-paragraph 
    E-g fill-region

Searching and replacing
    C-s isearch-forward 
    C-r isearch-backward 
    Esc exit a successful search 
    C-g quit 
    C-s Esc non incremental search forward 
    C-r Esc backward " 
    E-x  replace-string RET bad RET good RET 
    E-% query replace 

By default, searches are case insensitive. You can change this by setting the
variable: case-fold-search --&gt; set it to: nil (Use Esc-x set-variable) 
    E-x re-search-forward simple 
    E-x re-search-backward 
    E-x isearch-forward-regexp incremental 
    E-x isearch-backward-regexp 
    E-x query-replace-regexp 
    E-x replace-regexp 
    replace unconditionally 

Undo
    E-x revert-buffer restore file from disk 
    C-s u undo

Transpose
    C-t transpose characters 
    E-t transpose words 
    C-x C-t transpose lines 

Buffer Manipulation
    C-x b move to other buffer 
    C-x s save some buffers 
    E-x kill-buffer kill buffer 
    E-x kill-some-buffers kill some buffers 
    E-x rename-buffer rename buffer 
    C-x C-q toggle read only status of buffer 
    C-x C-b list buffers 

Window Manipulation
    C-x 2 split current window into 2 horizontals 
    C-x 5 vertically 
    C-x o move to other window 
    E-C v scroll next window 
    Attach '4' to C-x to have the operation go to the other window, eg: C-x 4 f find-file-other window 
    C-x 4 b change buffer other window 
    E-x compare-windows (must have 2 buffers in split windows) 

Spelling Checker
    E-$ (spell check the word the cursor is on)
    E-x spell-string
    E-x spell-buffer
    E-x spell-region

Shell commands in Emacs
    E-! run UNIX command 
    E-| run command on marked region (shell-command-on-region) 
    C-u E-! run UNIX command, but in the current window! 
    E-x shell invoke shell buffer 

Fix echo'ing and ^M ing at the end of lines: 
    stty -echo nl 

Dired: Directory Editor commands
    E-x dired or emacs  
    SPC move 
    n next 
    p prev 
    v view (via recursive edit) 
    C-c (or q) to return to directory list 
    d mark for deletion 
    e edit file 
    f edit file 
    x DELETE those marked 
    c copy file 
    r rename file 
    M change file permissions 

Text Formatting
    E-x fill-paragraph
    E-x fill-individual-paragraphs
    E-x edit-tab-stops
    E-x untabify (converts tabs to spaces)
    E-x tabify
    E-x mark-whole-buffer
    C-x h variable: indent-tabs-mode
    (if set to nil, Emacs always uses spaces to make tabs)
    C-x fill-prefix: this string automatically gets inserted at begin of each line
    C-x . set-fill-prefix
    E-x indented-text-mode

Centering Text
    E-s center-line
    E-x center-paragraph
    C-l form feed - used for pagination

Macros
    C-x ( start macro definition
    C-x ) end macro definition
    C-x e call-last-kbd-macro

Customizing Emacs
    (define-key keymap "keystroke" 'command-name)
    (global-set-key "keystroke" 'command-name)
    (local-set-key "keystroke" 'command-name)
    (global-unset-key "\C-s") 
    Example:
        (define-key global-map "\C-xl" 'goto-line)
            (global-set-key "\C-xl" 'goto-line) 
    Maps: global-map, ctl-x-map, esc-map 

Indentation
    E-C-\ indent-region 
    E-m back-to-indentation 
    E-^ delete-indentation join this line to previous 
    E-; indent-for-comment 

C-Mode
    E-C-a beginning-of-defun 
    E-C-e end-of-defun 
    E-C-h mark-c-function 

Variables Default 
    c-indent-level 2 
    c-auto-new-line nil 
    c-continued-statement-offset 2 
    c-argdecl-indent 5 
    c-brace-offset 0 
    c-continued-brace-offset 0 
    c-brace-imaginary-offset 0 
    c-label-offset -2 

ETAGS
    etags *.[ch] creates a TAGS file E-.
    find-tag C-x 4 find-tag-other-window E-,
    tags-loop-continue (find next tag)
    E-x tags-search prompts for an RE and finds it.
    find next by E-,
    E-x tags-query-replace
    C-u E-x tags-query-replace (only replace for full words) E-x list-tags 

Lisp Mode
    3: emacs-lisp-mode, lisp-mode, lisp-interaction-mode 
    S-expression: any syntactically correct LISP expression: atom or parenthesized list. 
    E C-a beginning-of-defun 
    E C-e end-of-defun 
    E C-h mark-defun 

Lisp Interaction Mode
    E-x lisp-interaction-mode
    LINEFEED C-j is bound to eval-print-last-sexp

Compiling Programs withing Emacs
    E-x compile
    default: make -k (controlled by compile-command variable)
    C-c ` next-error
    C-u C-x ` start at first error again
    E-x grep</t>
<t tx="ekr.20050930091642">def walkKB( self, event, frm, which ):# kb = self.iterateKillBuffer() ):

    k = self.k ; w = event.widget
    i = w.index( 'insert' )
    t , t1 = i.split( '.' )
    clip_text = self.getClipboard( w )    
    if self.killbuffer or clip_text:
        if which == 'c':
            self.reset = True
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
        else:
            if clip_text:
                txt = clip_text
            else:
                txt = self.kbiterator.next()
            t1 = str( int( t1 ) + len( txt ) )
            r = w.tag_ranges( 'kb' )
            if r and r[ 0 ] == i:
                w.delete( r[ 0 ], r[ -1 ] )
            w.tag_delete( 'kb' )
            w.insert( frm, txt, ('kb') )
            w.mark_set( 'insert', i )
    return k._tailEnd( w )</t>
<t tx="ekr.20050930095323">def killSentenceHelper (self,event,back):
    w = event.widget
    i = w.search('.','insert',stopindex='end')
    if back:
        i = w.search('.','insert',backwards=True,stopindex='1.0')
        if not i: return 'break'
        i2 = w.search('.',i,backwards=True,stopindex='1.0') or '1.0'
        return self.kill(event,i2,'%s + 1c' % i)
    else:
        i  = w.search('.','insert',stopindex='end')
        i2 = w.search('.','insert',backwards=True,stopindex='1.0')
    if i:
        i2 = g.choose(i2=='','1.0',i2+'+1c ')
        self.kill(event,i2,'%s + 1c' % i)

    return 'break'</t>
<t tx="ekr.20051001050607">def endCommand (self,event,commandName,forceFocus=True):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c ; w = event.widget
    if g.app.quitting: return
    
    # The command may have closed the window, so this may fail.
    try:
        p = c.currentPosition()
    except AttributeError:
        return
        
    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    # g.trace(commandName)

    # Call onBodyWillChange only if there is a proper command name.
    if commandName:
        c.frame.body.onBodyWillChange(p,undoType=commandName,oldSel=None,oldYview=None)
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # leoEditCommands.initAllEditCommanders *does* exist.
    
            # g.trace('commandName:',commandName,'caller:',g.callerList())
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            
            # # if forceFocus: # This is dubious.
                # # w.focus_force()
            try:
                bodyCtrl = c.frame.body.bodyCtrl
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
                bodyCtrl.update_idletasks()
            except Exception:
                pass

    w.update_idletasks()</t>
<t tx="ekr.20051001180444">10/1/05

Important simplifications:

- Dispatchers call endCommand (via handleEndCommand)
  when a command returns and there is no state.
- "User" commands need only clear the state and set (or clear) the label:
  everything else is automatic.
- endCommand calls bodyWillChange.  This is the correct way to ensure that changes 'stick'.
- Dispatchers will return 'break' or None as appropriate:
  User code will not have to worry about this.
- keyboardQuit still exists, but it merely clears the state and the label.
  As before, commands may set the label to inform the user of what has happened.</t>
<t tx="ekr.20051002111614">def wordSearchBackward (self,event):

    k = self.k ; state = k.getState('word-search-backward')
    if state == 0:
        k.setLabelBlue('Word Search Backward: ',protect=True)
        k.getArg(event,'word-search-backward',1,self.wordSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=False)

def wordSearchForward (self,event):

    k = self.k ; state = k.getState('word-search-forward')
    if state == 0:
        k.setLabelBlue('Word Search: ',protect=True)
        k.getArg(event,'word-search-forward',1,self.wordSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20051002120125">s = k.getLabel(ignorePrompt=True)

if s:
    if self.forward:
        if self.regexp: self.reSearchForward(event)
        else:           self.searchForward(event)
    else:
        if self.regexp: self.reSearchBackward(event)
        else:           self.searchBackward(event)</t>
<t tx="ekr.20051002152108.1"></t>
<t tx="ekr.20051002161714">- Removed tailEnd and return 'break's.  They are no longer needed.

- Replaced stopControlX by keyboardQuit.

- Rewrote state handling for search commands.

- Call endCommand after every keystroke.

- Set k.commandName to include args in keep-lines, shell-command, etc.

- Removed k.doUndo.</t>
<t tx="ekr.20051003064825">- The primary goal is to allow Emacs and Vim users to retain their 'finger habits' while using Leo.

    - It is *not* necessary to implement all Emacs commands: just those that are used frequently.
    - It *is* necessary to extend commands like isearch so they can deal with multiple body texts.

- The secondary goal is 'mouseless leo': being able to drive all parts of Leo without using the mouse.

    - The user must be able to drive all dialogs from the keyboard,
      **or to get the same effect without using a dialog at all**.</t>
<t tx="ekr.20051003140625">- Extended k.commandName for undoable commands that use extension arguments.
  There aren't that many such commands, surprisingly.</t>
<t tx="ekr.20051004085713">- Split abbrevDispatch into addAbbreviation and inversAddAbbriviation.
- Removed coresponding lambda's.
- Change the hard binding for &lt;Control-g&gt; to k.abbortAllModesKey.
- Renamed the top-level dispatches to fullCommand and quickCommand.
** Massive improvements to rectangle and register commands.
    - new rCommands dispatcher.
    - Use new states in rCommands and most rectangle and register commands.
    - This simplifies and localizes the code.
    - The new code gives much better feedback.
    - Allow arbitrary location-types in registers:  e.g. 'end'</t>
<t tx="ekr.20051004093536"></t>
<t tx="ekr.20051004132320"></t>
<t tx="ekr.20051005094144"></t>
<t tx="ekr.20051005155611">try:
    regex = re.compile(self.qQ)
except:
    self.quitSearch(event,'Illegal regular expression')
    return False

txt = w.get('insert','end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    w.mark_set('insert','insert +%sc' % start)
    ### w.update_idletasks()
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    txt = w.get('insert','insert +%sc' % length)
    return True
else:
    self.quitSearch(event)
    return False</t>
<t tx="ekr.20051005160923">i = w.search(self.qQ,'insert',stopindex='end')
if i:
    w.mark_set('insert',i)
    ###w.update_idletasks()
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False</t>
<t tx="ekr.20051006083627.1">@nocolor

@  Any Emacs command can be given a numeric argument. Some commands interpret the
argument as a repetition count. For example, giving an argument of ten to the
key C-f (the command forward-char, move forward one character) moves forward ten
characters. With these commands, no argument is equivalent to an argument of
one. Negative arguments are allowed. Often they tell a command to move or act
backwards.

If your keyboard has a META key, the easiest way to specify a numeric argument
is to type digits and/or a minus sign while holding down the the META key. For
example,

M-5 C-n

moves down five lines. The characters Meta-1, Meta-2, and so on, as well as
Meta--, do this because they are keys bound to commands (digit-argument and
negative-argument) that are defined to contribute to an argument for the next
command.

Another way of specifying an argument is to use the C-u (universal-argument)
command followed by the digits of the argument. With C-u, you can type the
argument digits without holding down shift keys. To type a negative argument,
start with a minus sign. Just a minus sign normally means -1. C-u works on all
terminals.

C-u followed by a character which is neither a digit nor a minus sign has the
special meaning of "multiply by four". It multiplies the argument for the next
command by four. C-u twice multiplies it by sixteen. Thus, C-u C-u C-f moves
forward sixteen characters. This is a good way to move forward "fast", since it
moves about 1/5 of a line in the usual size screen. Other useful combinations
are C-u C-n, C-u C-u C-n (move down a good fraction of a screen), C-u C-u C-o
(make "a lot" of blank lines), and C-u C-k (kill four lines).

Some commands care only about whether there is an argument and not about its
value. For example, the command M-q (fill-paragraph) with no argument fills
text; with an argument, it justifies the text as well. (See section Filling
Text, for more information on M-q.) Just C-u is a handy way of providing an
argument for such commands.

Some commands use the value of the argument as a repeat count, but do something
peculiar when there is no argument. For example, the command C-k (kill-line)
with argument n kills n lines, including their terminating newlines. But C-k
with no argument is special: it kills the text up to the next newline, or, if
point is right at the end of the line, it kills the newline itself. Thus, two
C-k commands with no arguments can kill a non-blank line, just like C-k with an
argument of one. (See section Deletion and Killing, for more information on
C-k.)

A few commands treat a plain C-u differently from an ordinary argument. A few
others may treat an argument of just a minus sign differently from an argument
of -1. These unusual cases will be described when they come up; they are always
to make the individual command more convenient to use.</t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)

</t>
<t tx="ekr.20051006122237"></t>
<t tx="ekr.20051006125633"></t>
<t tx="ekr.20051006125633.1">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20051006131811"></t>
<t tx="ekr.20051006195420"></t>
<t tx="ekr.20051006195420.1">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3361442
By: nobody

Thanks, now I know where those settings live. For completeness, and in case
somebody doesn't like low contrast of white on gray, I suggest to also add foreground
color setting. Imitating what you did I added the following:

two new settings under @settings--&gt;Colors--&gt;@page Body pane colors
in leoSettings.leo:

 @color body_text_selection_background_color = Gray80   (or CadetBlue2 etc.)
 @color body_text_selection_foreground_color = white    (or black)

added to tkBody.setColorFromConfig:

....sel_bg = c.config.getColor('body_text_selection_background_color')
or 'Gray80'
....try: body.configure(selectbackground=sel_bg)
....except Exception:
........g.es("exception setting body pane text selection background color")
........g.es_exception()
....
....sel_fg = c.config.getColor('body_text_selection_foreground_color')
or 'white'
....try: body.configure(selectforeground=sel_fg)
....except Exception:
........g.es("exception setting body pane text selection foreground color")
........g.es_exception()

Works with Leo 4.3.3, build  1.282 , Python 2.3.5, Tk 8.4.3, win32
</t>
<t tx="ekr.20051007080058">def makeAllBindings (self):
    
    k = self ; c = k.c
    
    k.bindingsDict = {}
    k.makeHardBindings()
    k.makeSpecialBindings()
    k.makeBindingsFromCommandsDict()
    k.add_ekr_altx_commands()
    k.checkBindings()</t>
<t tx="ekr.20051007093659">@nocolor

- menu.createMenuEntries calls c.keyHandler.bindShortcutFromMenu.
    menu.createMenuEntries makes **no** bindings itself in this case.

- Created k.makeAllBindings to localize bindings.

- bindShortcutFromMenu and setBufferStrokes use two levels of callbacks.
    The keyCallback is bound to the key: it calls k.masterCommand.
    It refers to a refers to a second callback that dispatches the actual command.

- bindKey now tests for duplicates and recovers from bad key bindings (user error).

- Removed test to keystrokeFunctionDict in masterCommand.
    The regular key binding mechanism should be enough!</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008065518">- k.finishCreate calls k.createInverseCommandsDict first.

- The values in k.inverseCommandsDict are f.__name__, rather than f.

- leoCommands.getPublicCommands now adds underlying f.__name__ to k.inverseCommandsDict rather than leoCallback.

- createInverseCommandsDict ignores 'leoCallback' when adding entries.

- Used k.inverseCommandsDict in &lt;&lt; set accel to the shortcut for name &gt;&gt; to get shortcuts using emacs-style names.

    This allows either old-style menu shortcuts or emacs command names.

- Allow '-' in shortcut names in parseShortcutLine.

- Allow trailing comments in shortcut names in parseShortcutLine.

* cb_dict is now vestigial and will soon be removed.
    However, &lt;Alt-X&gt; is not bound properly at present.

Binding is mostly complete:  the traces from createMenuEntries show missing command names in leoSettings.leo.

- Removed last traces of cbDict ivar.  Use. by k.bindingsDict as need.</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20051008131807">@nocolor

** New utils for unit testing
    - The idea is to avoid subclassing TestCase,
      and to avoid the kind of helper code that is in leoTest.leo.
    - data = g.saveSubtree()
    - g.restoreSubtree(data)

- g.simulateKeystrokes (keystrokes,p=None)
    - keystrokes is a list of bindings to be 'executed' as if typed.
        - This is an easy way of simulating user interaction.

- unit calls k.simulateKeystrokes and then makes assertions about
    - state
    - Contents of label.
    - ivars
    - Contents of body text.
    - what widget has focus.
    - what the point, mark and selection are.
    - etc.

@color</t>
<t tx="ekr.20051008134059">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunch = c.config.getShortcut(commandName)
        accel = bunch and bunch.val
        if accel:
            bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(accel)
            k.bindShortcut(bunch.pane,bind_shortcut,command,commandName)
        
        if 0:
            if bunch: g.trace('%s %s %s' % (commandName,bunch.pane,bunch.val))
            else:     g.trace(commandName)</t>
<t tx="ekr.20051008135051.1">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c ;
    
    bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)
    
    # g.trace(bind_shortcut,name,data)

    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)

    def keyCallback (event,func=openWithCallback,stroke=bind_shortcut):
        return k.masterCommand(event,func,stroke)
            
    return k.bindKey('all',bind_shortcut,keyCallback,'open-with')</t>
<t tx="ekr.20051008152134">def makeSpecialBindings (self):
    
    '''Make the bindings and set ivars for sepcial keystrokes.'''
    
    k = self ; c = k.c ; f = c.frame
    
    # These defaults may be overridden.
    for pane,stroke,ivar,commandName,func in (
        ('all', 'Alt-x',  'fullCommandKey',  'full-command',  k.fullCommand),
        ('all', 'Ctrl-g', 'abortAllModesKey','keyboard-quit', k.keyboardQuit),
        ('all', 'Ctrl-u', 'universalArgKey', 'universal-argument', k.universalArgument),
        ('all', 'Ctrl-c', 'quickCommandKey', 'quick-command', k.quickCommand),
        # These bindings for inside the minibuffer are strange beasts.
        # They are sent directly to k.fullcommand with a special callback.
        ('mini', 'Alt-x',  None,'full-command',  k.fullCommand),
        ('mini', 'Ctrl-g', None,'keyboard-quit', k.keyboardQuit),
        ('mini', 'Ctrl-c', 'mb_copyKey', 'copy-text', f.copyText),
        ('mini', 'Ctrl-v', 'mb_pasteKey','paste-text',f.pasteText),
        ('mini', 'Ctrl-x', 'mb_cutKey',  'cut-text',  f.cutText),
    ):
        # Get the user shortcut *before* creating the callbacks.
        junk, bunch = c.config.getShortcut(commandName)
        accel = (bunch and bunch.val) or stroke
        shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
        # g.trace(stroke,accel,shortcut,func.__name__)
        if pane == 'mini' and func != k.keyboardQuit:
            # Call a strange callback that bypasses k.masterCommand.
            def minibufferKeyCallback(event,func=func,shortcut=shortcut):
                k.fullCommand(event,specialStroke=shortcut,specialFunc=func)

            k.bindKey(pane,shortcut,minibufferKeyCallback,commandName)
        else:
            # Create two-levels of callbacks.
            def specialCallback (event,func=func):
                return func(event)

            def keyCallback (event,func=specialCallback,stroke=shortcut):
                return k.masterCommand(event,func,stroke)

            k.bindKey(pane,shortcut,keyCallback,commandName)

        if ivar:
            setattr(k,ivar,shortcut)
        
    # Add a binding for &lt;Key&gt; events, so all key events go through masterCommand.
    def allKeysCallback (event):
        return k.masterCommand(event,func=None,stroke='&lt;Key&gt;')

    k.bindKey('all','&lt;Key&gt;',allKeysCallback,'master-command')</t>
<t tx="ekr.20051008204635"></t>
<t tx="ekr.20051009042953">@nocolor

- replaced x.useMiniBuffer by c.useMiniBuffer.
- Replace useEditorMenu by useCmdMenu, etc.
- Call createMenuBar in c.finishCreate.
- Removed all dummy methods from nullMenu class.
    - The methods of the base class will do fine, provided that an overrided oops method does nothing!
** Always define c.keyHandler, even if c.useMiniBuffer is False.
    - Changes to c.finishCreate and keyHandler.ctor.
- Removed all warnings:
    - Added dynamicMenu arg to createMenuEntries to suppress a warning when a menu is created from a plugin.
    - Revise &lt;&lt; set accel to the shortcut for name &gt;&gt; in createMenuEntries tests c.useMiniBuffer.
    - Use c.frame.selectAllText instead of c.editCommands.selectAll.
- Fixed bug in makeSpecialBindings so that Control-g works.</t>
<t tx="ekr.20051009044751">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
    f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)
    
    f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
    f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
</t>
<t tx="ekr.20051009044920"># Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()</t>
<t tx="ekr.20051009045208">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()</t>
<t tx="ekr.20051009045300"># Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()

    c.beginUpdate()
    try:
        c.selectVnode(p)
        c.redraw()
        c.frame.getFocus()
        c.editPosition(p)
    finally:
        c.endUpdate(False)</t>
<t tx="ekr.20051009120608"></t>
<t tx="ekr.20051009130341">- Make all bindings to c.frame.top (not w) in bindKey.
  This make bindings available everywhere.</t>
<t tx="ekr.20051010062551.1">@

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.
    
inverseBindingsDict (computed by computeInverseBindingDict)
    keys are emacs command names, values are shortcuts.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are g.bunch(func,name,warningGiven)
</t>
<t tx="ekr.20051010063452">def ultimateFuncName (self,func):
    
    '''Return func.__name__ unless it is 'leoCallback.
    In that case, return the name in k.leoCallbackDict.get(func).'''
    
    k = self
    
    if not func:
        return '&lt;no function&gt;'
        
    if func.__name__ != 'leoCallback':
        return func.__name__
        
    # Get the function wrapped by this particular leoCallback function.
    calledFunc = k.leoCallbackDict.get(func)
    if calledFunc:
        return 'leoCallback -&gt; %s' % calledFunc.__name__ 
    else:
        return '&lt;no leoCallback name&gt;'</t>
<t tx="ekr.20051010130212">Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoGlobals.py", line 2349, in doHook
    return f(tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 88, in doPlugins
    return doHandlersForTag(tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 69, in doHandlersForTag
    val = callTagHandler(bunch,tag,keywords)

  File "c:\prog\leoCVS\leo\src\leoPlugins.py", line 47, in callTagHandler
    result = handler(tag,keywords)

  File "C:\prog\leoCVS\leo\plugins\rst2.py", line 248, in onFileOpen
    transform_rst2_text_in_subtree(c)

  File "C:\prog\leoCVS\leo\plugins\rst2.py", line 239, in transform_rst2_text_in_subtree
    c.frame.menu.createMenuEntries(editMenu, newEntries)

  File "C:\prog\leoCVS\leo\src\leoMenu.py", line 1022, in createMenuEntries
    emacs_name = k.inverseCommandsDict.get(command.__name__)

AttributeError: 'callOnFileOpen' object has no attribute '__name__'</t>
<t tx="ekr.20051010152921">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3376527
By: vpe

My first complaint is the same as in this earlier post:
http://sourceforge.net/forum/message.php?msg_id=3331283
If leo file has @settings in it, these settings are not applied when I open
the file from another outline, that is from File-&gt;Recent Files or File-&gt;Open
or Help-&gt;Leo Docs etc. They are applied when I open the file directly by double
clicking.

Also, when leo files are opened from another outline, the log window has no
messages about leoID, global config dir, home dir, reading settings, # plugins
loaded.

Possible reason:

I have leo files associated with "path\pythonw.exe" "path\leo.py" "%1". Each
time I open a leo file directly, a new pythonw.exe process is started. But,
when I open files from an outline, no new pythonw.exe is started. This does
not make much sense to me. It's not an MDI editor. It's also safer to have separate
processes--if one outline crashes, others will survive.

Leo 4.3.3, build  1.282 , Python 2.4.2, Tk 8.4.7, win2k</t>
<t tx="ekr.20051011071542.1"></t>
<t tx="ekr.20051011072049.1">def OnCutFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    #g.trace()
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        # Necessary
        w.event_generate(g.virtual_event_name("Cut"))
        f.tree.onHeadChanged(c.currentPosition())</t>
<t tx="ekr.20051011072049.2">def cutText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    
    # g.trace(w,w._name) # _name and widgetName are tkinter additions to Tk.

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        # Old: Do **not** call w.event_generate.
        # New: Do call w.event_generate.
        w.event_generate(g.virtual_event_name("Cut"))
        if not fromMinibuffer:
            f.tree.onHeadChanged(c.currentPosition())</t>
<t tx="ekr.20051011072903.1">def OnCopyFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    #g.trace()
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Copy"))
    else:
        # Necessary when not using shortcut keys.
        w.event_generate(g.virtual_event_name("Copy"))</t>
<t tx="ekr.20051011072903.2">def copyText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    
    # g.trace(w,w._name) # _name and widgetName are tkinter additions to Tk.

    # These two branches used to be different, an might be so again.
    if isBody:
        w.event_generate(g.virtual_event_name("Copy"))
    elif fromMinibuffer:
        pass
    else:
        # Old: Do **not** call w.event_generate.
        # New: Do call w.event_generate.
        w.event_generate(g.virtual_event_name("Copy"))</t>
<t tx="ekr.20051011072903.4">def OnPasteFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    #g.trace()
    
    f = self ; c = f.c ; w = f.getFocus()
    w = self.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Paste"))
    else:
        w.event_generate(g.virtual_event_name("Paste"))
        f.tree.onHeadChanged(c.currentPosition())</t>
<t tx="ekr.20051011072903.5">def pasteText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    
    # g.trace(w,w._name) # _name and widgetName are tkinter additions to Tk.

    if isBody:
        w.event_generate(g.virtual_event_name("Paste"))
    elif fromMinibuffer:
        pass
    else:
        # Do **not** call w.event_generate for headlines.
        f.tree.onHeadChanged(c.currentPosition())</t>
<t tx="ekr.20051011091759">Added big kludge to menu.createMenuEntries so that f.OnCut/Copy/PasteFromMenu get called
**only** when explicitly selected from the menu (rather than from a shortcut).
This allows the code in cut/copy/paste-text to be different as needed.

Users can override the shortcut by assigning shortcuts to cut/copy/paste-text commands.
The shortcut will appear in the menu, but does **not** get bound to c.frame.menu.

This is an essential step in solving the infamous Control-V problem.
The code appears to work properly on XP.  Not tested other places.

This is the last best hope to solve this problem: the code interacts as little as possible with Tk.</t>
<t tx="ekr.20051011103654">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20051011105014">def exists (self,c,setting,kind):
    
    '''Return true if a setting of the given kind exists, even if it is None.'''

    if c:
        d = self.localOptionsDict.get(c.hash())
        if d:
            junk,found = self.getValFromDict(d,setting,kind)
            if found: return True
                
    for d in self.localOptionsList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    for d in self.dictList:
        junk,found = self.getValFromDict(d,setting,kind)
        if found: return True

    # g.trace('does not exist',setting,kind)
    return False</t>
<t tx="ekr.20051011124540">- Fixed duplicate Pastes in headlines.
    - Works when paste-text command is not defined.
    - Removed weird virtual bindings in tkBody.createBindings.

- Control-H now works properly.
    - Added forceFocuse arg to k.endCommand.
      This is always False for Leo commands.
      
- At present the processing for @shortcuts does not allow multiple shortcuts for a single command.
  The **last** setting prevails.  The value should be a list, and each item on the list should create a binding.
  
- Fixed crash in unit test for rst2 plugin.
    The call to createMenuEntries had callOnFileOpen() instead of callOnFileOpen.

- k.checkBindings checks that commands have an @shortcuts entry.
    - The entry may be None, of course.
    - Created g.app.config.exists as a helper function.
    ** The major @shortcuts nodes now pass this test.

- created `@button align to col` in leoSettings.leo.
- open-with shortcuts now work.
- Made sure old-style settings still work.

- Changed name Editor menu to Cmds menu.
- Used previously unused init param to createMenuEntries to suppress warnings.
- Disabled many plugin tests. These tests are flakey: they don't work the same if repeated.
- Fixed all pychecker errors.
- Fixed bugs in nextLine, prevLine.  Can't call manufactureKeyPress: the keys may have been rebound!</t>
<t tx="ekr.20051012053017.4">** Important: search headline option.
    
[iqr] incremental,query,regex
[fb] forward,back
[w] word
[c] case-sensitive
[hat] headline,all,body
[osn] outline,subtree,node

*Set defaults for all the above using commands.
set-word-search-on/off
set-search-case-on/off
set-regexp-search-on/off
set-wrap-search-on/off
set-search-scope-to-outline/subtree/node

** Search mode: Control keys could change these options *after* starting the search command.

- Script-search commands
script-search  (can we abort the search somehow?)
set-find-script
set-change-script

Apply incremental search commands to headlines.  This might be fast, but is it useful if nodes aren't visible?</t>
<t tx="ekr.20051012054228">- k.vimMode controls whether full-command keeps mini-buffer open after a command complete.

- k.fullCommand sets k.sets k.vimMode = c.config.getBool('vim-mode') on entry.

- Commands (like vim-insert-mode) clear k.vimMode to return to the body pane.

- control-g does not alter k.vimMode.

- Shift-control-g clears k.vimMode.
</t>
<t tx="ekr.20051012062458.1">- the cycle-focus command should cycle through all log tabs.

- Something cool that can be bound to alt-tab.

- Strip quotes from color, font settings.

-  Allow multiple selectors:  ! all,find =

- Specify &amp; for most menu items.

</t>
<t tx="ekr.20051012075322"></t>
<t tx="ekr.20051012082219">TclError Exception in Tk callback
  Function: &lt;function keyCallback at 0x017923B0&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x026A9E18&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "c:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 792, in keyCallback
    return k.masterCommand(event,func,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1050, in masterCommand
    func(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 789, in menuFuncCallback
    return command(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 1979, in backwardParagraph
    w.mark_set('insert',i) ; w.see('insert')
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2932, in mark_set
    self.tk.call(self._w, 'mark', 'set', markName, index)
TclError: bad text index " +1c"

================================================
  Event contents:
    char: {
    delta: 219
    height: ??
    keycode: 219
    keysym: braceleft
    keysym_num: 123
    num: ??
    serial: 4627
    state: 131073
    time: 11194296
    type: 2
    widget: .19812560.24607680.24608040.24608160.body
    width: ??
    x: 656
    x_root: 873
    y: 37
    y_root: 487

TclError Exception in Tk callback
  Function: &lt;function keyCallback at 0x017923B0&gt; (type: &lt;type 'function'&gt;)
  Args: (&lt;Tkinter.Event instance at 0x026B2648&gt;,)
  Event type: KeyPress (type num: 2)
Traceback (innermost last):
  File "c:\prog\leoCVS\leo\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__
    return apply(self.func, args)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 792, in keyCallback
    return k.masterCommand(event,func,stroke)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 1050, in masterCommand
    func(event)
  File "C:\prog\leoCVS\leo\src\leoKeys.py", line 789, in menuFuncCallback
    return command(event)
  File "C:\prog\leoCVS\leo\src\leoEditCommands.py", line 1979, in backwardParagraph
    w.mark_set('insert',i) ; w.see('insert')
  File "c:\python24\lib\lib-tk\Tkinter.py", line 2932, in mark_set
    self.tk.call(self._w, 'mark', 'set', markName, index)
TclError: bad text index " +1c"

================================================
  Event contents:
    char: {
    delta: 219
    height: ??
    keycode: 219
    keysym: braceleft
    keysym_num: 123
    num: ??
    serial: 4627
    state: 131073
    time: 11194296
    type: 2
    widget: .19812560.24607680.24608040.24608160.body
    width: ??
    x: 656
    x_root: 873
    y: 37
    y_root: 487

</t>
<t tx="ekr.20051012084345"></t>
<t tx="ekr.20051012091323"></t>
<t tx="ekr.20051012092453">def goToFirstSibling(self):
    
    c = self ; p = c.currentPosition()
    
    if p.hasBack():
        while p.hasBack():
            p.moveToBack()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20051012092847">def forceFocusToBody (self):
    
    k = self ; c = k.c
    
    # Later=False does not always work.
    c.frame.bodyWantsFocus(later=True)</t>
<t tx="ekr.20051012092847.1">def goToLastSibling(self):
    
    c = self ; p = c.currentPosition()
    
    if p.hasNext():
        while p.hasNext():
            p.moveToNext()

        c.beginUpdate()
        try:
            c.selectVnode(p)
        finally:
            c.endUpdate()</t>
<t tx="ekr.20051012101104"></t>
<t tx="ekr.20051012101954">exception executing command
Traceback (most recent call last):

  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 236, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 4856, in openCompareWindow
    frame.comparePanel = g.app.gui.createComparePanel(c)

  File "c:\prog\leoCVS\leo\src\leoTkinterGui.py", line 254, in createComparePanel
    return leoTkinterComparePanel.leoTkinterComparePanel(c)

  File "c:\prog\leoCVS\leo\src\leoTkinterComparePanel.py", line 41, in __init__
    self.useOutputFileVar = Tk.IntVar()

  File "c:\python24\lib\lib-tk\Tkinter.py", line 244, in __init__
    Variable.__init__(self, master)

  File "c:\python24\lib\lib-tk\Tkinter.py", line 179, in __init__
    self._tk = master.tk

AttributeError: 'NoneType' object has no attribute 'tk'

Exception exceptions.AttributeError: "IntVar instance has no attribute '_tk'" in &lt;bound method IntVar.__del__ of &lt;Tkinte
r.IntVar instance at 0x0171B800&gt;&gt; ignored
</t>
<t tx="ekr.20051012124209"></t>
<t tx="ekr.20051012133615">def switchToBuffer (self,event,name):

    method = self.bufferGotos [event.widget]
    self.keyboardQuit(event)
    method(name)
    return 'break'
</t>
<t tx="ekr.20051012141518"></t>
<t tx="ekr.20051012201831">def printBindings (self,event):

    '''Print all the bindings presently in effect.'''

    k = self ; c = k.c
    keys = k.bindingsDict.keys() ; keys.sort()

    c.frame.log.clearTab('Command')
    for key in keys:
        b = k.bindingsDict.get(key)
        g.es(key,b.commandName or b.name,tabName='Command')</t>
<t tx="ekr.20051012205437"># Such calls will fail if keys have been rebound.</t>
<t tx="ekr.20051013083241">def replaceAll(self):

    c = self
    
    if not c.frame.findPanel:
        c.frame.findPanel = g.app.gui.createFindPanel(c)

    c.frame.findPanel.changeAllCommand(c)
</t>
<t tx="ekr.20051013084200">def dismissFindPanel (self):
    
    c = self
    
    if c.frame.findPanel:
        c.frame.findPanel.dismiss()</t>
<t tx="ekr.20051013085834"></t>
<t tx="ekr.20051013103117">c.save()</t>
<t tx="ekr.20051013103457"></t>
<t tx="ekr.20051013103838">@
Control-c while editing headline caused problems.
end/abort-edit-headline did not work.</t>
<t tx="ekr.20051013155435"></t>
<t tx="ekr.20051013161232">def updateSettings (self,c,localFlag):

    d = self.readSettings(c)
    
    if d:
        d['_hash'] = theHash = c.hash()
        if localFlag:
            self.localOptionsDict[theHash] = d
        else:
            self.localOptionsList.insert(0,d)
            
    if 0: # Good trace.
        if localFlag:
            g.trace(c.fileName())
            g.printDict(d)</t>
<t tx="ekr.20051014034200"></t>
<t tx="ekr.20051014061332">def printCommands (self,event):

    '''Print all the known commands and their bindings, if any.'''

    k = self ; c = k.c
    
    c.frame.log.clearTab('Command')
    
    inverseBindingDict = k.computeInverseBindingDict()
    commandNames = c.commandsDict.keys() ; commandNames.sort()

    for commandName in commandNames:
        shortcut = inverseBindingDict.get(commandName,'')
        g.es('%s %s' % (commandName,shortcut),tabName='Command')</t>
<t tx="ekr.20051014104337">@ The hard-to-find bug was in makeSpecialBindings.

- Changed tag to tag=tag.  The bug was causing tag to be bound to the openWith arg!</t>
<t tx="ekr.20051014104337.1">exception executing command
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 213, in doCommand
    command()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 1571, in undo
    u.undoHelper()

  File "C:\prog\leoCVS\leo\src\leoUndo.py", line 1720, in undoMove
    u.p.moveToNthChildOf(u.oldParent,u.oldN)

  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 2764, in moveToNthChildOf
    p.unlink()

  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3307, in unlink
    assert(parent.v in p.v.directParents())

AssertionError</t>
<t tx="ekr.20051014122218">&lt;Delete&gt;     delete the character just before the cursor
C-d   	     delete the next character after the cursor

M-&lt;Delete&gt;   kill the word immediately before the cursor
M-d	     kill the next word after the cursor

C-k	     kill from the cursor position to end of line
M-k	     kill to the end of the current sentence

** (I changed this: I should change it back)
Note that a single C-k kills the contents of the line, and a second
C-k kills the line itself...

C-k treats a numeric argument specially: it kills that many lines AND
their contents.  This is not mere repetition.  C-u 2 C-k kills two
lines and their newlines; typing C-k twice would not do that.

The set-mark-command command sets the mark to the point.
Bound to Alt-@, Ctrl--, Ctrl-space</t>
<t tx="ekr.20051014152256">Improve import code so it handles stufff like this from Ipyton/iplib

### This should *not* terminate the function!

    self.LOGHEAD = Itpl(
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = $self.rc.opts
#log# args = $self.rc.args
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
""")

- Handle blanks better in imports:
    - Add tab_width keyword arg to import command.
    - Convert tabs to blanks if tab width &lt; 0.
- Ignore position of blank lines wrt sentinels.
- Ignore (optionally?) underindented blank lines.
- Use pyclbr to parse Python imports?</t>
<t tx="ekr.20051014154752">def showMinibuffer (self):
    
    frame = self
    
    if not frame.minibufferVisible:
        frame.minibufferFrame.pack(side='bottom',fill='x')
        frame.minibufferVisible = True
        
def hideMinibuffer (self):
    
    frame = self
    if frame.minibufferVisible:
        frame.minibufferFrame.pack_forget()
        frame.minibufferVisible = False</t>
<t tx="ekr.20051014155115"></t>
<t tx="ekr.20051014155551">def hideMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.hideMinibuffer()
    
    g.es('Minibuffer hidden',color='red')

    for commandName in ('show-mini-buffer','toggle-mini-buffer'):
        shortcut = k.getShortcutForCommandName(commandName)
        if shortcut:
            g.es('%s is bound to: %s' % (commandName,shortcut))
    
    
def showMinibuffer (self,event):
    
    k = self ; c = k.c
    
    c.frame.showMinibuffer()
    
def toggleMinibuffer (self,event):
    
    k = self ; c = k.c
    
    if c.frame.minibufferVisible:
        k.hideMinibuffer(event)
    else:
        k.showMinibuffer(event)</t>
<t tx="ekr.20051014161015"></t>
<t tx="ekr.20051014161914"></t>
<t tx="ekr.20051014170101"></t>
<t tx="ekr.20051014170101.1">- Changed k.updateLabel so unknown control keysare not put into minibuffer.
- Added hide/show/toggle-mini-buffer commands.
- Added contract-and-go-right command
- Fixed long-standing bug in goto-last-node.
- Added goto-first-sibling and goto-last-sibling commands.
- Created help command.
- Changed c.useMiniBuffer to c.showMinibuffer
- Fixed existing bug in config logic: (munged) shortcuts could conflict with other settings!</t>
<t tx="ekr.20051014170754">def help (self,event):
    
    k = self ; c = k.c
    commands = (
        k.fullCommand,
        k.quickCommand,
        k.universalArgument,
        k.keyboardQuit,
        # negative-argument
        # repeat-complex-command
    )
    shortcuts = [
        k.getShortcutForCommand(command)
        for command in commands]

    # A bug in Leo: triple quotes puts indentation before each line.
    s = '''
The mini-buffer is intended to be like the Emacs buffer:

%s: Just like Emacs Alt-x: starts minibuffer. The prompt is 'full-command' Type a
full command name, then hit &lt;Return&gt; to execute the command. Tab completion
works, but not for file names.

%s: Like Emacs Control-C: (Ctrl-C conflicts with XP cut). starts minibuffer.
The prompt is 'quick-command'. This mode is not completed, but stuff like
`Ctrl-C r` and `Ctrl r r` do work.

%s: Like Emacs Ctrl-u: (Ctrl-u conflicts with move-outline-up). Add a repeat
count for later command. Ctrl-u 999 a adds 999 a's, but many features remain
unfinished.

%s: Just like Emacs Ctrl-g: Closes the mini-buffer.
'''

    s = g.adjustTripleString(s,c.tab_width)
        # Remove indentation from indentation of this function.
    s = s % (shortcuts[0],shortcuts[1],shortcuts[2],shortcuts[3])
    g.es_print(s)</t>
<t tx="ekr.20051014170754.1">def getShortcutForCommandName (self,commandName):
    
    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            b = k.bindingsDict.get(key)
            if b.name == command.__name__:
                return key
    
    return ''
    
def getShortcutForCommand (self,command):
    
    k = self ; c = k.c
    
    if command:
        for key in k.bindingsDict:
            b = k.bindingsDict.get(key)
            if b.name == command.__name__:
                return key
    
    return ''</t>
<t tx="ekr.20051014175117">def adjustTripleString (s,tab_width):
    
    '''Remove leading indentation from a triple-quoted string.
    
    This works around the fact that Leo nodes can't represent underindented strings.
    '''
    
    # Compute the minimum leading whitespace of all non-blank lines.
    lines = g.splitLines(s)
    w = -1
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w2 = g.computeWidth(lws,tab_width)
            if w &lt; 0: w = w2
            else:     w = min(w,w2)
            # g.trace('w',w)
    if w &lt;= 0: return s

    # Remove the leading whitespace.
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]
    result = ''.join(result)

    return result</t>
<t tx="ekr.20051014180059"></t>
<t tx="ekr.20051015063053"># These arose because @bool useMinibuffer conflicted with @shortcut use-mini-buffer(!!)
# Added new checks in g.app.config.getValFromDict.</t>
<t tx="ekr.20051015093141">def typesMatch (self,type1,type2):
    
    '''
    Return True if type1, the actual type, matches type2, the requeseted type.
    
    The following equivalences are allowed:

    - None matches anything.
    - An actual type of string or strings matches anything.
    - Shortcut matches shortcuts.
    '''

    shortcuts = ('shortcut','shortcuts')
    
    return (
        type1 == None or type2 == None or
        type1.startswith('string') or
        (type1 in shortcuts and type2 in shortcuts) or
        type1 == type2
    )
</t>
<t tx="ekr.20051015110547">def registerCommand (self,commandName,shortcut,func,pane='all',verbose=True):
    
    '''Make the function available as a minibuffer command,
    and optionally attempt to bind a shortcut.
    
    You can wrap any method in a callback function, so the
    restriction to functions is not significant.'''
    
    k = self ; c = k.c
    
    f = c.commandsDict.get(commandName)
    if f:
        g.es_trace('Redefining %s' % (commandName), color='red')
        
    c.commandsDict [commandName] = func
    k.inverseCommandsDict [func.__name__] = commandName
    
    if shortcut:
        # Retain the original spelling of the shortcut for the message.
        shortcut, junk = c.frame.menu.canonicalizeShortcut(shortcut)
        ok = k.bindShortcut (pane,shortcut,func,commandName)
            
    if verbose:
        if shortcut and ok:
            g.es_print('Registered %s bound to %s' % (
                commandName,shortcut),color='blue')
        else:
            g.es_print('Registered %s' % (commandName), color='blue')</t>
<t tx="ekr.20051015112436"></t>
<t tx="ekr.20051015113252"># None of the following are correct.

C:\prog\leoCVS\leo\src\leoGlobals.py:1417: Setting aList to itself has no effect

C:\prog\leoCVS\leo\src\leoGlobals.py:1433: Setting aList to itself has no effect

C:\prog\leoCVS\leo\src\leoKeys.py:803: Redefining attribute (keyCallback) original line (792)

C:\prog\leoCVS\leo\src\leoKeys.py:1315: No module attribute (initAllEditCommanders) found</t>
<t tx="ekr.20051015123432"># None of the following warnings are correct.</t>
<t tx="ekr.20051015163627">@ What I did:
    
- Bind shortcuts in makeSpecialBindings *before* defining callbacks.

- Removed duplicate entry for universal-argument in @shortcuts node.
  (very confusing).
  
- Chose default for universal-argument in makeSpecialBindings that does
  not conflict with move-outline-up or untangle.
</t>
<t tx="ekr.20051015223107.2"></t>
<t tx="ekr.20051016095907"></t>
<t tx="ekr.20051016095907.1"></t>
<t tx="ekr.20051016095907.2"></t>
<t tx="ekr.20051016101724.1">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    c.frame.widgetWantsFocus(self.logCtrl)
    self.tabFrame = self.frameDict.get(tabName)
    return tabFrame</t>
<t tx="ekr.20051016101927">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...</t>
<t tx="ekr.20051016101927.1">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20051016103459">def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log</t>
<t tx="ekr.20051016113907">@

I removed the TabbedLog plugin from cvs, and changed the UASearch and URLloader
plugins so they create create tabbed logs using c.frame.log.selectTab rather
than TabbedLog.getPane. No other official plugins use TabbedLog. 
</t>
<t tx="ekr.20051016113907.1">@nocolor

c.frame.log.selectTab(tabName) selects the tab in the log pane, creating it if
necessary.

The g.es, g.enl, g.ecnl, g.ecnls write to the log tab specified by the optional
tabName argument. The default for tabName is 'Log', so existing code works as
before.

Minor notes:

1. The following are official status ivars.  They can be read by client code,
but they should never be changed outside of the leoTkinterLog class:

c.frame.log.tabName: the name of the active tab.
c.frame.log.logCtrl: the Tk.Text widget for the active tab.
c.frame.log.tabFrame: the Tk.Frame containing the active tab.

These ivars may not exist in nullLog's.

2. The put and putnl methods of the tkinterLog class also take an optional
tabName argument which defaults to 'Log'.</t>
<t tx="ekr.20051016115757"></t>
<t tx="ekr.20051016115757.1"></t>
<t tx="ekr.20051016155819">Any plugin could be considered an options file such as Emacs loads on startup.
Indeed, any plugin can specify options and change any part of Leo's operation.
Still, I am wondering whether Leo might treat one plugin, say options.py, just a
bit differently from other options, say by loading it first (or last) or
possibly looking somewhere besides the leo/plugins folder, or maybe having it
always be enabled.</t>
<t tx="ekr.20051016162459"># k.finishCreate sets k.inverseCommandsDict, but k.registerShortcut can be called after that.</t>
<t tx="ekr.20051016162724">Urgent:

- Improve emacs-search commands

- Improve handling of the mark.  The selection should be visible.

- Improve kill/yank.

Later:

- Review the posting about making positions permanent, or recording vnode
indicies. It's probably time to do this.

- Must bind *all* keysrokes in all panes to masterControl so that minibuffer works properly.</t>
<t tx="ekr.20051016171402">@nocolor

print-bindings was printing the function name, not the command name. Fixing this
was hairy: it involved adding the commandName argument to k.bindShortcut and
k.bindKey. The work is worthwhile: it is now much clearer what is being bound.
The most complicated change was to menu.createMenuEntries, as usual...</t>
<t tx="ekr.20051017053631">@nocolor

The scripting plugin now has support for the following kinds of headlines:

@button name @key=shortcut

This binds the shortcut to the script in the script button.  The button's name is 'name', but you can see the full headline in the status line when you move the mouse over the button.  This is a clean and simple way of discovering the shortcut.

@command name

This creates a new minibuffer command whose name is 'name'.

@command name @key=shortcut

This creates a new minibuffer command and binds shortcut to it.

The scripting plugin no longer contains the 'bindLate' code-level option.  The scripts for all @button or @command nodes are computed 'dynamically', that is, when the button is pushed or the command is executed from the minibuffer.  This is the most useful way, and the most intuitive.

Previously, scripts for @button nodes were never dynamic, while scripts in @button nodes created by the 'Script button' button were dynamic only if bindLate was True.  You could call this a bug: it was unhelpful, annoying and confusing.
</t>
<t tx="ekr.20051017111039">@nocolor

Set the tab-list index to-1 if we first print a common prefix.  That way item returned next will be item 0.</t>
<t tx="ekr.20051017111216">- Removed update_idletasks and event_generate from minibuffer commands...

It is unlikely that any of the following commands work:

    removeBlankLines,backToIndentation,indentRelative,
    moveWordHelper,findNextMatch.

- If possibly, eliminate update_idletasks and w.event_generate('&lt;Key&gt;') in the following:
    removeBlankLines,backToIndentation,indentRelative,
    moveWordHelper,findNextMatch.

- baseEditCommandsClass helpers:
    These would be similar to g.app.gui methods, but maybe simpler to use.
    head,sel,tail = getSelectedLines()
    hasSelection, setSelection, etc.</t>
<t tx="ekr.20051017132446">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3384016
By: slott56

Executing [any] script throws me into a loop with a lot of "exception execution
script" messages.  There's a copy of Python left running in the background,
it appears, which is hung up.

Here's the full header...

Leo 4.3 final, build  1.262 , May 23, 2005
Python 2.3.5, Tk 8.4.7, darwin

Mac OS 10.4.2
</t>
<t tx="ekr.20051017140811">Buffer Keyboard Commands:
----------------------------------------

&lt;Control-p&gt;: move up one line
&lt;Control-n&gt;: move down one line
&lt;Control-f&gt;: move forward one char
&lt;Conftol-b&gt;: move backward one char
&lt;Control-o&gt;: insert newline
&lt;Control-Alt-o&gt; : insert newline and indent
&lt;Control-j&gt;: insert newline and tab
&lt;Alt-&lt;&gt; : move to start of Buffer
&lt;Alt- &gt; &gt;: move to end of Buffer
&lt;Control a&gt;: move to start of line
&lt;Control e&gt; :move to end of line
&lt;Alt-Up&gt;: move to start of line
&lt;Alt-Down&gt;: move to end of line
&lt;Alt b&gt;: move one word backward
&lt;Alt f&gt; : move one word forward
&lt;Control - Right Arrow&gt;: move one word forward
&lt;Control - Left Arrow&gt;: move one word backwards
&lt;Alt-m&gt; : move to beginning of indentation
&lt;Alt-g&gt; : goto line number
&lt;Control-v&gt;: scroll forward one screen
&lt;Alt-v&gt;: scroll up one screen
&lt;Alt-a&gt;: move back one sentence
&lt;Alt-e&gt;: move forward one sentence
&lt;Alt-}&gt;: move forward one paragraph
&lt;Alt-{&gt;: move backwards one paragraph
&lt;Alt-:&gt; evaluate a Python expression in the minibuffer and insert the value in the current buffer
Esc Esc : evaluate a Python expression in the minibuffer and insert the value in the current buffer
&lt;Control-x . &gt;: set fill prefix
&lt;Alt-q&gt;: fill paragraph
&lt;Alt-h&gt;: select current or next paragraph
&lt;Control-x Control-@&gt;: pop global mark
&lt;Control-u&gt;: universal command, repeats the next command n times.
&lt;Alt -n &gt; : n is a number.  Processes the next command n times.
&lt;Control-x (&gt;: start definition of kbd macro
&lt;Control-x ) &gt; : stop definition of kbd macro
&lt;Control-x e : execute last macro defined
&lt;Control-u Control-x ( &gt;: execute last macro and edit
&lt;Control-x Esc Esc &gt;: execute last complex command( last Alt-x command
&lt;Control-x Control-c &gt;: save buffers kill Emacs
&lt;Control-x u &gt; : advertised undo.   This function utilizes the environments.
        If the buffer is not configure explicitly, there is no operation.
&lt;Control-_&gt;: advertised undo.  See above
&lt;Control-z&gt;: iconfify frame
----------------------------------------

&lt;Delete&gt; : delete previous character
&lt;Control d&gt;: delete next character
&lt;Control k&gt; : delete from cursor to end of line. Text goes to kill buffer
&lt;Alt d&gt;: delete word. Word goes to kill buffer
&lt;Alt Delete&gt;: delete previous word. Word goes to kill buffer
&lt;Alt k &gt;: delete current sentence. Sentence goes to kill buffer
&lt;Control x Delete&gt;: delete previous sentence. Sentence goes to kill buffer
&lt;Control y &gt;: yank last deleted text segment from
 kill buffer and inserts it.
&lt;Alt y &gt;: cycle and yank through kill buffer.

&lt;Alt z &gt;: zap to typed letter. Text goes to kill buffer
&lt;Alt-^ &gt;: join this line to the previous one
&lt;Alt-\ &gt;: delete surrounding spaces
&lt;Alt-s&gt; &gt;: center line in current fill column
&lt;Control-Alt-w&gt;: next kill is appended to kill buffer
----------------------------------------

&lt;Alt c&gt;: Capitalize the word the cursor is under.
&lt;Alt u&gt;: Uppercase the characters in the word.
&lt;Alt l&gt;: Lowercase the characters in the word.
----------------------------------------

&lt;Alt t&gt;: Mark word for word swapping.  Marking a second
 word will swap this word with the first
&lt;Control-t&gt;: Swap characters
&lt;Ctrl-@&gt;: Begin marking region.
&lt;Ctrl-W&gt;: Kill marked region
&lt;Alt-W&gt;: Copy marked region
&lt;Ctrl-x Ctrl-u&gt;: uppercase a marked region
&lt;Ctrl-x Ctrl-l&gt;: lowercase a marked region
&lt;Ctrl-x h&gt;: mark entire buffer
&lt;Alt-Ctrl-backslash&gt;: indent region to indentation of line 1 of the region.
&lt;Ctrl-x tab&gt; : indent region by 1 tab
&lt;Control-x Control-x&gt; : swap point and mark
&lt;Control-x semicolon&gt;: set comment column
&lt;Alt-semicolon&gt;: indent to comment column
----------------------------------------

M-! cmd -- Run the shell command line cmd and display the output
M-| cmd -- Run the shell command line cmd with region contents as input
----------------------------------------

&lt;Control-x a e&gt;: Expand the abbrev before point (expand-abbrev). This is effective even when Abbrev mode is not enabled
&lt;Control-x a g&gt;: Define an abbreviation for previous word
&lt;Control-x a i g&gt;: Define a word as abbreviation for word before point, or in point
----------------------------------------

&lt;Control s&gt;: forward search, using pattern in Mini buffer.

&lt;Control r&gt;: backward search, using pattern in Mini buffer.

&lt;Control s Enter&gt;: search forward for a word, nonincremental

&lt;Control r Enter&gt;: search backward for a word, nonincremental

&lt;Control s Enter Control w&gt;: Search for words, ignoring details of punctuation
&lt;Control r Enter Control w&gt;: Search backward for words, ignoring details of punctuation
&lt;Control-Alt s&gt;: forward regular expression search, using pattern in Mini buffer

&lt;Control-Alt r&gt;: backward regular expression search, using pattern in Mini buffer

&lt;Alt-%&gt;: begin query search/replace. n skips to next match. y changes current match.  
        q or Return exits. ! to replace all remaining matches with no more questions
&lt;Control Alt %&gt; begin regex search replace, like Alt-%
&lt;Alt-=&gt;: count lines and characters in regions
&lt;Alt-( &gt;: insert parentheses()
&lt;Alt-) &gt;:  move past close
&lt;Control-x Control-t&gt;: transpose lines.
&lt;Control-x Control-o&gt;: delete blank lines
&lt;Control-x r s&gt;: save region to register
&lt;Control-x r i&gt;: insert to buffer from register
&lt;Control-x r +&gt;: increment register
&lt;Control-x r n&gt;: insert number 0 to register
&lt;Control-x r space &gt; : point insert point to register
&lt;Control-x r j &gt; : jump to register
&lt;Control-x x&gt;: save region to register
&lt;Control-x r r&gt; : save rectangle to register
&lt;Control-x r o&gt;: open up rectangle
&lt;Control-x r c&gt; : clear rectangle
&lt;Control-x r d&gt; : delete rectangle
&lt;Control-x r t&gt; : replace rectangle with string
&lt;Control-x r k&gt; : kill rectangle
&lt;Control-x r y&gt; : yank rectangle
&lt;Control-g&gt; : keyboard quit

&lt;Control-x = &gt; : position of cursor
&lt;Control-x . &gt; : set fill prefix
&lt;Control-x f &gt; : set the fill column
&lt;Control-x Control-b &gt; : display the buffer list
&lt;Control-x b &gt; : switch to buffer
&lt;Control-x k &gt; : kill the specified buffer
----------------------------------------

&lt;Alt - - Alt-l &gt;: lowercase previous word
&lt;Alt - - Alt-u&gt;: uppercase previous word
&lt;Alt - - Alt-c&gt;: capitalise previous word
----------------------------------------

&lt;Alt-/ &gt;: dynamic expansion
&lt;Control-Alt-/&gt;: dynamic expansion.  Expands to common prefix in buffer
----------------------------------------

Alt-x commands:

(Pressing Tab will result in auto completion of the options if an appropriate match is found</t>
<t tx="ekr.20051017140811.1"></t>
<t tx="ekr.20051017184201"></t>
<t tx="ekr.20051017204206">@nocolor

We can't use nb.selectpage('Log') after writing the tab completion list,
but we want to restore the default page to 'Log'.

There are at least two approaches:

1. Create a method, say, setDefaultTab(), that causes *future* writes to go to the 'Log' tab but does *not* change the presently selected tab.

2. Add tabName='Log' as a keyword argument to g.es, g.enl, etc. and tkLog.put/putnl.

This is more explicit and easier to program, and does the same thing.  This is what I have done.  So by default, g.es does what it always has done, but it is easy to switch to other panes.</t>
<t tx="ekr.20051017212057">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t.delete('1.0','end')</t>
<t tx="ekr.20051017212452"># Important: this code must not change mb_tabListPrefix.  Only doBackSpace should do that.

def computeCompletionList (self,defaultTabList,backspace):
    
    k = self ; c = k.c ; s = k.getLabel() 
    command = s [len(k.mb_prompt):]
        # s always includes prefix, so command is well defined.

    k.mb_tabList,common_prefix = g.itemsMatchingPrefixInList(command,defaultTabList)

    c.frame.log.clearTab('Completion')

    if k.mb_tabList:
        k.mb_tabListIndex = -1 # The next item will be item 0.

        if not backspace:
            k.setLabel(k.mb_prompt + common_prefix)
            
        inverseBindingDict = k.computeInverseBindingDict()
        for commandName in k.mb_tabList:
            shortcut = inverseBindingDict.get(commandName,'')
            g.es('%s %s' % (commandName,shortcut),tabName='Completion')

    k.forceFocusToBody()</t>
<t tx="ekr.20051018061932"></t>
<t tx="ekr.20051018061932.1">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    
def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
        logCtrl = self.textDict.get(tabName)
        self.c.frame.widgetWantsFocus(logCtrl)</t>
<t tx="ekr.20051018070524">def computeInverseBindingDict (self):

    k = self

    d = {} # keys are minibuffer command names, values are shortcuts.

    for shortcut in k.bindingsDict.keys():
        b = k.bindingsDict.get(shortcut)
        d [b.commandName] = shortcut # was b.name

    return d</t>
<t tx="ekr.20051018072306">textWidget = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: textWidget.configure(bg=bg)
except Exception: pass # Could be a user error.

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = textWidget

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]
self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags

# Make the bindings.
textWidget.bind("&lt;Button-1&gt;",self.onActivateLog)
textWidget.tag_config('black',foreground='black')</t>
<t tx="ekr.20051018102027">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        return

    if tabName == 'Find':
        self.selectTab('Log')
        return
    
    if tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')</t>
<t tx="ekr.20051018104223"></t>
<t tx="ekr.20051019134106"></t>
<t tx="ekr.20051019134106.1">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)

        menu.add_command(label='Delete This Tab',command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu</t>
<t tx="ekr.20051019134422">def onRightClick (self,event,menu):

    menu.post(event.x_root,event.y_root)
    
def onClick (self,event,tabName):
    
    self.selectTab(tabName)</t>
<t tx="ekr.20051019140004.1">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    parentFrame = self.frameDict.get(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (oldName,newName):
        self.selectTab(newName)

    self.getTabName(parentFrame,'',selectTabCallback)</t>
<t tx="ekr.20051019165401">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        parentFrame = self.frameDict.get(tabName)
        self.getTabName(parentFrame,tabName,self.renameTab)</t>
<t tx="ekr.20051019170806">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20051019172811">def getTabName (self,parentFrame,tabName,exitCallback):

    f = Tk.Frame(parentFrame)
    f.pack(side='bottom',fill='x',expand=1)

    Tk.Label(f,text='Tab name').pack(side='left')

    e = Tk.Entry(f,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(tabName,s)
    
    if 0:
        b = Tk.Button(row,text="Close",command=getNameCallback)
        b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20051020074023"></t>
<t tx="ekr.20051020075416">menu = self.makeTabMenu(tabName)
tab = self.nb.tab(tabName)

def tabMenuRightClickCallback(event):
    self.onRightClick(event,menu)
    
def tabMenuClickCallback(event):
    self.onClick(event,tabName)

tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)
        
    self.findTabHandler.bringToFront()</t>
<t tx="ekr.20051020120306.1">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020120306.2">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020120306.3">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020120306.4">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20051020120306.5"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind.leoFind):

    """A class that implements Leo's tkinter find tab."""

    @others</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020120306.12">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two columns of buttons &gt;&gt;
    
    for w in buttons:
        w.bindHotKey(ftxt)
        w.bindHotKey(ctxt)</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.frame = Tk.Frame(self.top,background=bg)
self.outerFrame = outer = Tk.Frame(self.frame,background=bg)

self.top.pack   (side='top',expand=0,fill='x',pady=5)
    # Don't expand, so the frame goes to the top.

self.frame.pack (side="top",expand=1,fill='x')
outer.pack      (side='top',expand=1,fill='x',padx=2,pady=2,)</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

# Use bigger boxes for scripts.
self.find_ctrl = ftxt = Tk.Text(
    fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
self.change_ctrl = ctxt = Tk.Text(
    cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") 
ftxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&amp;Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &amp;Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ("&amp;Mark Finds",           self.dict["mark_finds"]),
    ("Mark &amp;Changes",         self.dict["mark_changes"]),
    ('Show Context',          self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051020120306.19">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020120306.20">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020120306.21">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20051020120306.22">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.frame.widgetWantsFocus(t,later=False)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.frame.widgetWantsFocus(t,later=True)</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.</t>
<t tx="ekr.20051020120306.28">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl	
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051021070335"></t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051021074728.1"></t>
<t tx="ekr.20051021091958">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20051021143159.1">@ This is an important simplification.

One not-so-horrible kludge remains. The cut/copy/paste commands in the menu
tables are not the same as the methods actually bound to cut/copy/paste-text
minibuffer commands, so we must do a bit of extra translation to discover
whether the user has overridden their bindings.

Important: this affect only the **appearance** of the menu, **not** any bindings!</t>
<t tx="ekr.20051021210459">- Document new settings.
- Document how to create and manage tabs in the log pane.
- Document how to script the log pane.

- Document @command and @button @key.
- Posting: how to program tabs in the log pane.
- Posting: Not possible to use @command inside a derived file.

- Add an entry in the FAQ that g.trace is usually more useful than pdb.</t>
<t tx="ekr.20051021212323">@nocolor

- Allow per-pane bindings in parseShortcutLine.

    goto-next-visible ! outline =  DnArrow
    next-line         ! body = DnArrow

- Warn and ignore duplicate shortcuts in doShortcuts.</t>
<t tx="ekr.20051022043608.1">def createOpenWithMenuItemsFromTable (self,menu,table):
    
    '''Create an entry in the Open with Menu from the table.
    
    Each entry should be a sequence with 2 or 3 elements.'''

    if g.app.unitTesting: return

    for data in table:
        &lt;&lt; get label, accelerator &amp; command or continue &gt;&gt;
        realLabel = self.getRealMenuName(label)
        underline=realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        callback = self.defineOpenWithMenuCallback(openWithData)
    
        self.add_command(menu,label=realLabel,
            accelerator=accelerator or '',
            command=callback,underline=underline)
</t>
<t tx="ekr.20051022043713.1">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        label,openWithData = data ; accelerator = None
    else:
        label,accelerator,openWithData = data
        junk,accelerator = self.canonicalizeShortcut(accelerator)
else:
    g.trace('bad data in Open With table: %s' % repr(data))
    continue # Ignore bad data</t>
<t tx="ekr.20051022044950">def computeOldStyleShortcutKey (self,s):
    
    '''Compute the old-style shortcut key for @shortcuts entries.'''
    
    chars = string.ascii_letters + string.digits
    
    result = [ch for ch in s.strip().lower() if ch in chars]
            
    return ''.join(result)</t>
<t tx="ekr.20051022053758"></t>
<t tx="ekr.20051022053758.1"></t>
<t tx="ekr.20051022061226">@nocolor

- Split openWith logic from createMenuEntries into createOpenWithMenuItemsFromTable.
- Removed openWith keyword arg from createMenuEntries and k.bindShortcut.
- Removed dontBind arg from openWith.
- Removed key bindings from popup menu table.

At last createMenuEntries does one thing.
createMenuEntries will never be a simple method, but it is reasonable now.

@color</t>
<t tx="ekr.20051022083459">@ Keys are now minibuffer command names, not function.__name__.

The confusing 'name' entry is now longer needed in k.bindingsDict. This
simplifies the calls to k.bindKey.

As a result, the print-commands and print-bindings commands no longer need a
helper function.</t>
<t tx="ekr.20051022094136">body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

# Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.

allPanes = [body,log,tree,menu,minibuffer]

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or 'all').lower(),[])

if shortcut == '&lt;Key&gt;':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20051022132934"></t>
<t tx="ekr.20051022141020">def onTreeClick (self,event=None):
    
    self.frame.treeWantsFocus()
    
    return 'break'
</t>
<t tx="ekr.20051022142249"></t>
<t tx="ekr.20051022144825">def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.body.bodyCtrl,later=True)

def focusToLog (self,event):
    self.c.frame.logWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.log.logCtrl,later=True)
    
def focusToMinibuffer (self,event):
    self.c.frame.minibufferWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.log.logCtrl,later=True)

def focusToTree (self,event):
    self.c.frame.treeWantsFocus(later=True)
    # frame = self.c.frame
    # return frame.set_focus(frame.tree.canvas,later=True)</t>
<t tx="ekr.20051022144825.1">def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i &gt;= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane,later=True)</t>
<t tx="ekr.20051022152427"></t>
<t tx="ekr.20051022162730">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.keyHandler

    textWidget = self.textDict.get(tabName)

    if k and textWidget:

        k.copyBindingsToWidget(['all','log','text'],textWidget)</t>
<t tx="ekr.20051022211617"></t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, we must also force the Find tab to be visible.

def findTabChange (self,event=None):

    if self.findTabHandler:
        self.openFindTab()
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.openFindTab()
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.openFindTab()
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.openFindTab()
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        seelf.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051023125705">- Spelling tab

- Autocompleter (list of names for which classes are known:
    c,frame,g,k,p,t,tree,v etc.

- Open .leo file in new process: alternative to test.leo!</t>
<t tx="ekr.20051023125705.1"></t>
<t tx="ekr.20051023125705.2">@nocolor</t>
<t tx="ekr.20051023125705.3">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="ekr.20051023125705.4">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="ekr.20051023125705.5">&lt;&lt; docstring &gt;&gt;

@language python 
@tabwidth-4

&lt;&lt;imports&gt;&gt;
__version__ = ".73"
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;load notes&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;
useauto = 1 #These two global determine if the autocompleter and calltip systems are used.  Default is on.
usecall = 1
&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others</t>
<t tx="ekr.20051023125705.6">'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''</t>
<t tx="ekr.20051023125705.7">import leoGlobals as g 
import leoPlugins 
import leoTkinterFrame 

import leoColor 
import ConfigParser 
import os
import os.path  

import re 
import sets 
import string 
import threading
import weakref

Tk  = g.importExtension('Tkinter',pluginName=__name__,verbose=True)
Pmw = g.importExtension("Pmw",    pluginName=__name__,verbose=True)</t>
<t tx="ekr.20051023125705.8">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.</t>
<t tx="ekr.20051023125705.9">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="ekr.20051023125705.10">@ 

switching to the placer appears to have gotten rid of this dependency

--no longer true---
Autocompleter needs to be loaded before Chapters/chapters or the autobox and the calltip label do
not appear in the correct place.
--no longer true---


@c 
</t>
<t tx="ekr.20051023125705.11">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the
new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information


context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode


</t>
<t tx="ekr.20051023125705.12">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.

</t>
<t tx="ekr.20051023125705.13">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20051023125705.14">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
   
</t>
<t tx="ekr.20051023125705.15">#This section defines patterns for calltip recognition.  The autocompleter does not use regexes.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats['python'] = re.compile(r'def\s+%s' % end)

pats['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % ( space, space, end ) )
    
pats['perl'] = re.compile(r'sub\s+%s' % end)

pats['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' %( space, end ))

pats['c'] = re.compile(r'\w+%s%s' % ( space ,end ))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits+string.letters+r 

ripout = string.punctuation+string.whitespace+'\n'
ripout = ripout.replace('_','')

okchars ={}
for z in string.ascii_letters:
    okchars[z] = z 
okchars['_'] = '_'</t>
<t tx="ekr.20051023125705.16">def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20051023125705.17">watchitems = ( '.',')' )
txt_template = '%s%s%s'
def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.  Certain chars activate the text scanning
       code.'''
    global lang 
    if event.char.isspace() or event.char in watchitems:
        bCtrl = event.widget
        #This if statement ensures that attributes set in another node
        #are put in the database.  Of course the user has to type a whitespace
        # to make sure it happens.  We try to be selective so that we dont burn
        # through the scanText def for every whitespace char entered.  This will
        # help when the nodes become big.
        if event.char.isspace():
            if bCtrl.get( 'insert -1c' ).isspace(): return #We dont want to do anything if the previous char was a whitespace
            if bCtrl.get( 'insert -1c wordstart -1c') != '.': return
            
        c = bCtrl.commander
        lang = c.frame.body.getColorizer().language 
        txt = txt_template %( bCtrl.get( "1.0", 'insert' ), 
                             event.char, 
                             bCtrl.get( 'insert', "end" ) ) #We have to add the newest char, its not in the bCtrl yet

        scanText(txt)
    
</t>
<t tx="ekr.20051023125705.18">def scanText (txt):
    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)
</t>
<t tx="ekr.20051023125705.19">def scanForAutoCompleter (txt):
    '''This function scans text for the autocompleter database.'''
    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b ) # we are using the experimental DictSet class here, usage removed the above statements
            #notice we have cut it down to one line of code here!</t>
<t tx="ekr.20051023125705.20">def scanForCallTip (txt):
    '''this function scans text for calltip info'''
    pat2 = pats['python']
    if lang!=None:
        if pats.has_key(lang):
            pat2 = pats[lang]
    g2 = pat2.findall(txt)
    if g2:
        for z in g2:
            if isinstance(z,tuple):
                z = z[0]
            pieces2 = z.split('(')
            pieces2[0] = pieces2[0].split()[-1]
            a, b = pieces2[0], pieces2[1]
            calltips[ lang ][ a ].add( z ) #we are using the experimental DictSet here, usage removed all of the commented code. notice we have cut all this down to one line of code!
            #if calltips.has_key(lang):
            #    if calltips[lang].has_key(a):
            #        calltips[lang][a].add(z)
            #    else:
            #        calltips[lang][a] = sets.Set([z]) 
            #else:
            #    calltips[lang] ={}
            #    calltips[lang][a] = sets.Set([z])        </t>
<t tx="ekr.20051023125705.21">def makeAutocompletionList (a,b,glist):
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 
</t>
<t tx="ekr.20051023125705.22">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20051023125705.23">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20051023125705.24">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
</t>
<t tx="ekr.20051023125705.25">#These functions determine if the config and language files have been read or not.  No need to read it more than once.
def hasReadConfig():
    return configfilesread
    

def setReadConfig():
    global configfilesread
    configfilesread = True
</t>
<t tx="ekr.20051023125705.26">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20051023125705.27">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="ekr.20051023125705.28">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20051023125705.29">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20051023125705.30">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20051023125705.31">def unbind ( context ):
    '''This method turns everything off and removes the calltip and autobox from the canvas.'''
    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map( context.unbind, ( "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;" , "&lt;Alt_R&gt;" ) )
        context.unbind_all( '&lt;Button&gt;' )
        context.update_idletasks()</t>
<t tx="ekr.20051023125705.32">def moveSelItem (event, context ):
    '''This def moves the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:

        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="ekr.20051023125705.33">def processKeyStroke (event,context ,body):
    '''c in this def is not a commander but a Tk Canvas.  This def determine what action to take dependent upon
       the state of the canvas and what information is in the Event'''
    #if not c.on:return None #nothing on, might as well return
    if not context.on or event.keysym in ( "??", "Shift_L","Shift_R" ):
        return None 
    #if event.keysym=='Escape':
    #    #turn everything off
    #    unbind( c )
    #    return None 
    #if c.which and event.keysym in('parenright','Control_L','Control_R'):
    #    unbind( c )
    #    c.on = False 
    elif testForUnbind( event, context ): #all of the commented out code is being tested in the new testForUnbind def or moved above.
        unbind( context )
        return None
    #elif event.keysym in("Shift_L","Shift_R"):
    #    #so the user can use capital letters.
    #    return None 
    #elif not c.which and event.char in ripout:
    #    unbind( c )
    elif context.which==1:
        #no need to add text if its calltip time.
        return None 
    ind = body.index('insert-1c wordstart')
    pat = body.get(ind,'insert')+event.char 
    pat = pat.lstrip('.')

    autobox = context.autobox
    ww = list( autobox.get( 0, 'end' ) )
    lis = reducer(ww,pat)
    if len(lis)==0:return None #in this section we are selecting which item to select based on what the user has typed.
    i = ww.index(lis[0])

    autobox.select_clear( 0, 'end' ) #This section sets the current selection to match what the user has typed
    autobox.select_set( i )
    autobox.see( i )
    return 'break'</t>
<t tx="ekr.20051023125705.34">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="ekr.20051023125705.35">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20051023125705.36">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="ekr.20051023125705.37">def add_bindings( context, body ):
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''
    
    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )

</t>
<t tx="ekr.20051023125705.38">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20051023125705.39">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20051023125705.40">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20051023125705.41">def newCreateControl (self,frame,parentFrame):
    '''This def is a decoration of the createControl def.  We set up the ancestory of the control so we can draw
       Widgets over the Text editor without disturbing the text.'''
    #creating background
    #We have moved to using the placer, this is simpler to use and more efficient.  We have to decorate the Tk.Text
    #widget with a constructor that creates an intermediate Frame for the Text to be placed instead of packed.  Had no
    #idea that the placer could do this so nicely.  With a couple changes in 3 places, we are using the placer!
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init( self, master, *args, **kwords ):
        
        context = Tk.Frame( master ) #This is what we need to put in before the text to make place work.
        orig_init( self, context, *args, **kwords )
    
    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame, parentFrame )#orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init
    
    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack( expand = 1, fill = 'both', after = frame.bodyBar )  #We have to add it to the environment, since we pass on it in the __init__   
    body.place( relwidth = 1.0, relheight = 1.0 )
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets( context )
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler( event, context= context, body = body ): 
        processKeyStroke( event, context, body )
    def addItemHandler( event, context = context, body = body, colorizer = frame.body ): 
        add_item( event, context, body, colorizer.getColorizer() )
                
    for z in ( watcher, processKeyStrokeHandler, addItemHandler ):
        context.bind( "&lt;Key&gt;", z, '+' )
    
    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr( context, 'autobox' ):
        ignore.append(  context.autobox.component( 'listbox' ) )
        ignore.append( context.autobox.component( 'vertscrollbar' ) )
    def do_unbind( event ):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''            
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind( context )

    context.do_unbind = do_unbind
    
    #This part protects this plugin from others that use Alt-Up, Alt-Down, an example being temacs.py
    #The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt( event ):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ( '&lt;Alt-Up&gt;', '&lt;Alt-Down&gt;' ): context.block_alt.bind( z, block_alt ) 
    
    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append( context.bindtags()[ 0 ] )
    ctags.append( context.block_alt.bindtags()[ 0 ] )
    ctags.extend( body.bindtags() ) 
    body.bindtags( tuple( ctags ))
    
    return body  







</t>
<t tx="ekr.20051023125705.42">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []
    
    if useauto:
        context.autobox = Pmw.ScrolledListBox( context ,hscrollmode='none',
                                         listbox_selectbackground='#FFE7C6',
                                         listbox_selectforeground='blue',
                                         listbox_background='white',
                                         listbox_foreground='blue',
                                         vertscrollbar_background='#FFE7C6',
                                         vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',
                         foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):#This def makes removing the autobox or calltip label easy.  No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()
    context.clean_editor = clean_editor

</t>
<t tx="ekr.20051023125705.43">def onOpenWindow ():
    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="ekr.20051023130656"></t>
<t tx="ekr.20051023132350">def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        if s.endswith('\n') or s.endswith('\r'): s = s[:-1]
        # g.trace(repr(s))
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

</t>
<t tx="ekr.20051023132350.1">def setLabel (self,s,protect=False):

    k = self ; w = self.widget

    # g.trace(repr(s))

    if self.useTextWidget:
        if w:
            k.c.frame.minibufferWantsFocus(later=False)
            w.update_idletasks()
            w.delete('1.0','end') ; w.insert('1.0',s)
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s</t>
<t tx="ekr.20051023132350.2">def protectLabel (self):
    
    k = self ; w = self.widget

    if self.useTextWidget:
        if w:
            w.update_idletasks()
            k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()


</t>
<t tx="ekr.20051023135812">@nocolor

- Made the minibuffer a Tk.Text widget rather than a Tk.Label.
- Put the focus in the minibuffer when it is active.
- Created a 'text' pane specification for common editing bindings.
  To do:  copy these text bindings whenever a Text widget is created.</t>
<t tx="ekr.20051023175530">@nocolor

- Support 'text' and 'mini' pane selectors.
    - 'mini' is used only in k.makeSpecialBindings to bind ctrl-g inside the minibuffer.

- Every very Tk.Text widget is given a 'name' when it is created.
    - w._name is the name created by the 'name' option.

- minibufferWantsFocus *does* work.
    - The 'raw' ctrl keys were confusing k.fullCommand.
      k.masterCommand now doesn't pass those keys along.

- Eliminated the weird call to bodyWantsFocus in k.masterCommand.</t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            junk, bunch = c.config.getShortcut(commandName)
            accel = bunch and bunch.val
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            if shortcut:
                # g.trace(shortcut,commandName)
                w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)</t>
<t tx="ekr.20051023182326">def copyBindingsToWidget (self,paneOrPanes,widget):
    
    '''Copy all bindings for the given panes to widget.
    
    paneOrPanes may be a single pane name or a list of pane names.'''

    k = self ; d = k.bindingsDict
    keys = d.keys() ; keys.sort()
    
    panes = list(paneOrPanes)
    
    for shortcut in keys:
        bunch = d.get(shortcut)
        if bunch.pane in panes:
            func = bunch.func
            commandName = bunch.commandName
            # g.trace('find tab',shortcut,commandName)
            
            # This callback executes the command in the given widget.
            def textBindingsRedirectionCallback(event,
                func=func,widget=widget,commandName=commandName):
                event.widget = widget
                # g.trace(commandName,widget)
                func(event)

            widget.bind(shortcut,textBindingsRedirectionCallback)</t>
<t tx="ekr.20051023183028">def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'</t>
<t tx="ekr.20051023192433">- Convert Emacs-Style Names to Menu Style Names when creating undo name.

- Examine scheme for duplicate shortcuts.
        - At present, a single command can be bound only once.
        - It's not a horrible restriction...
    
- The colerer is calling c.config too much?</t>
<t tx="ekr.20051024053428"></t>
<t tx="ekr.20051024101355">@nocolor

- Removed the Ctrl-T hack.  It does not appear to be needed.

- Created Ctrl-Shift-V shortcut for show-invisibles.

- (done) Created c.frame.headlineWantsFocus

- (done) Fixed problems with multiple calls to newHeadline.

- (done) copyBindingsToWidget can take either a single pane name or a list of pane names.

- (done) Copy both 'all' bindings and 'tree' bindings to headline.

- (done) Create separate names for all log panes.

- (done) Create names for find/change Text widgets.

@color</t>
<t tx="ekr.20051024102724"># New in 4.4a2.

def setBindings (self):
    
    '''Copy all bindings to headlines.'''
    
    if self.useBindtags:
        # This _must_ be a Text widget attached to the canvas!
        self.bindingWidget = t = Tk.Text(self.canvas)
        self.c.keyHandler.copyBindingsToWidget(['all','tree'],t)

        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()
        # g.trace('tkTree,t.bind())
    else:
        self.bindingWidget = None
   
    self.createPermanentBindings()</t>
<t tx="ekr.20051024112703"></t>
<t tx="ekr.20051024145643"></t>
<t tx="ekr.20051024152318"></t>
<t tx="ekr.20051024152318.1"></t>
<t tx="ekr.20051024152318.2"></t>
<t tx="ekr.20051024173701">def createTab (self,tabName):
    
    c = self.c ; k = c.keyHandler
    tabFrame = self.nb.add(tabName)
    &lt;&lt; bind a tab-specific pop-up menu to the tab &gt;&gt;
    &lt;&lt; Create the tab's text widget &gt;&gt;
    self.setTabBindings(tabName)</t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.change()
    
def changeThenFindCommand(self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.changeThenFind()</t>
<t tx="ekr.20051025065958"></t>
<t tx="ekr.20051025070441">c.prettyPrintPythonNode()</t>
<t tx="ekr.20051025071455">@ To do:
- open the minibuffer to get suggestions.
- Per-pane key bindings. (arrows, etc.)
- Accumulate status messages.
@c

&lt;&lt; specify aspell directories &gt;&gt;

@others</t>
<t tx="ekr.20051025071455.1">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others</t>
<t tx="ekr.20051025071455.3">if sys.platform == 'darwin':
    aspell_dir = '/sw/lib'
        # The top-level directory.
    aspell_bin_dir = '/sw/lib/bin'
        # NOT TESTED YET.
else:
    aspell_dir = r'c:\Aspell'
        # The top-level directory.
    aspell_bin_dir = r'c:\Aspell\bin'
        # The directory continaing apell.pyd and aspell-15.dll</t>
<t tx="ekr.20051025071455.6">class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others

</t>
<t tx="ekr.20051025071455.7"></t>
<t tx="ekr.20051025071455.8">def __init__(self,c,local_dictionary_file,local_language_code):
    
    """Ctor for the Aspell class."""
    
    self.c = c
    
    # Specify the path to the top-level Aspell directory.
    if sys.platform == 'darwin':
        aspell = g.importFromPath ("aspell",aspell_dir,pluginName=__name__,verbose=True)
    else:
        aspell = g.importFromPath(
            "aspell",aspell_bin_dir,pluginName=__name__,verbose=True)
            
    self.aspell = aspell

    self.sc = aspell.spell_checker(prefix=aspell_dir,lang=local_language_code)
    # g.trace(self.sc)
    
    self.aspell_exe_loc = (c.config.getString('aspell_bin_dir') or aspell_bin_dir)
    # g.trace(self.aspell_exe_loc)

    self.local_language_code = local_language_code
    self.local_dictionary_file = local_dictionary_file
    self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file)[0]
    # g.trace(self.local_dictionary)</t>
<t tx="ekr.20051025071455.9">def getAspellDirectory(self):

    """Get the directory containing aspell.exe from the .ini file"""

    try:
        fileName = os.path.join(g.app.loadDir,"..","plugins",ini_file_name)
        config = ConfigParser.ConfigParser()
        config.read(fileName)
        return config.get("main", "aspell_dir")
    except:
        g.es_exception()
        return None</t>
<t tx="ekr.20051025071455.10">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; original count offset: miss, miss, ... 
    None: 
    # original offset 
    simplifyed to not create the string then make a list from it    
    """

    if self.sc.check(word):
        return None
    else:
        return self.sc.suggest(word)</t>
<t tx="ekr.20051025071455.11">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_exe_loc, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es("Unable to update local aspell dictionary: %s" % err)
        print err
        add_dicts = ""
        return False</t>
<t tx="ekr.20051025071455.16">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % local_dictionary)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d</t>
<t tx="ekr.20051025071455.18">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others</t>
<t tx="ekr.20051025071455.19"></t>
<t tx="ekr.20051025071455.20">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    self.c = c ; log = c.frame.log ; tabName = 'Spell'
    
    leoFind.leoFind.__init__(self,c) # Call the base ctor.
    
    self.c = c
    # self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.v = None
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)</t>
<t tx="ekr.20051025071455.22">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    # Create the outer frame.
    outer = Tk.Frame(parentFrame,bd=2,bg=bg)
    outer.pack(expand=1,fill='both',padx=2,pady=2)
    
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20051025071455.23">f = outer

f2 = Tk.Frame(f,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(f,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=10,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')</t>
<t tx="ekr.20051025071455.24"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="ekr.20051025071455.29"></t>
<t tx="ekr.20051025071455.30">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()
    #self.closePipes()

</t>
<t tx="ekr.20051025071455.31">def onIgnoreButton(self):
    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()
    #self.closePipes()</t>
<t tx="ekr.20051025071455.32">def onChangeButton(self):
    """Handle a click in the Change button in the Check Spelling dialog."""

    self.change()
    #self.closePipes()
    self.updateButtons()
    
# Event needed for double-click event.
def onChangeThenFindButton(self,event=None): 
    """Handle a click in the "Change, Find" button in the Check Spelling dialog."""

    if self.change():
        self.find()
    #self.closePipes()
    self.updateButtons()</t>
<t tx="ekr.20051025071455.33">def onFindButton(self):
    """Handle a click in the Find button in the Check Spelling dialog."""

    self.find()
    self.updateButtons()
    self.c.frame.bodyWantsFocus()
    #self.closePipes()</t>
<t tx="ekr.20051025071455.34">def onHideButton(self):
    
    """Handle a click in the Hide button in the Check Spelling dialog."""

    #self.closePipes()
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []</t>
<t tx="ekr.20051025071455.36"></t>
<t tx="ekr.20051025071455.37">def add(self):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.38">def change(self):
    """Make the selected change to the text"""

    c = self.c ; v = self.v ; body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            newSel = g.app.gui.getTextSelection(t)

            # update node, undo status, dirty flag, changed mark &amp; recolor
            c.beginUpdate()
            c.frame.body.onBodyChanged(v,"Change",oldSel=oldSel,newSel=newSel)
            c.endUpdate(True)
            t.focus_set()
            return True

    # The focus must never leave the body pane.
    t.focus_set()
    return False</t>
<t tx="ekr.20051025071455.39">def checkSpelling(self,event=None):

    """Open the Check Spelling dialog."""

    self.bringToFront()
    self.update(show=True,fill=False)</t>
<t tx="ekr.20051025071455.40">def find(self):
    """Find the next unknown word."""
    
    # Reload the work pane from the present node.
    s = self.body.bodyCtrl.get("1.0", "end").rstrip()
    self.workCtrl.delete("1.0", "end")
    self.workCtrl.insert("end", s)
    
    # Reset the insertion point of the work widget.
    ins = self.body.bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert", ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'
    
    if alts:
        self.fillbox(alts, word)
        self.body.bodyCtrl.focus_set()
                    
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(self.body.bodyCtrl, start, end)
        #fix selection getting hidden in not visable section of body
        self.body.bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])</t>
<t tx="ekr.20051025071455.41">def ignore(self):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.42"></t>
<t tx="ekr.20051025071455.43">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')</t>
<t tx="ekr.20051025071455.44">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1) 

</t>
<t tx="ekr.20051025071455.45">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    aspell = self.aspell ; alts = None ; word = None
    c = self.c ; p = self.v ; t = self.workCtrl
    try:
        #aspell.openPipes()
        try:
            while 1:
                p, word = self.findNextWord(p) 
                if not p or not word:
                    alts = None
                    break
                &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
                alts = aspell.processWord(word)
                if alts:
                    self.v = p
                    c.beginUpdate()
                    c.frame.tree.expandAllAncestors(p)
                    c.selectPosition(p)
                    c.endUpdate()
                    break
        except:
            g.es_exception()
    finally:
        #aspell.closePipes()
        return alts, word</t>
<t tx="ekr.20051025071455.46">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    
    # print "Ignored", word
    continue
    
# print "Didn't ignore '%s'" % word</t>
<t tx="ekr.20051025071455.47"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as .  I don't know what the solution is.
    word_start = string.letters
    word_end   = string.letters + string.digits
    word_chars = string.letters + string.digits + "`" + "'" + "_"
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and line[i] not in word_start:
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")</t>
<t tx="ekr.20051025071455.48">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None</t>
<t tx="ekr.20051025071455.49">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)</t>
<t tx="ekr.20051025071455.50">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    self.updateButtons()
    self.body.bodyCtrl.focus_set()
</t>
<t tx="ekr.20051025071455.51">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    # print "update(show=%d,fill=%d)" % (show,fill)
    
    # Always assume that the user has changed text.
    if not self.c: return

    c = self.c
    self.v = c.currentVnode()
    self.body = c.frame.body
    if fill:
        self.fillbox([])
    self.updateButtons()
    if show:
        self.bringToFront()
        # Don't interfere with Edit Headline commands.
        self.body.bodyCtrl.focus_set()

</t>
<t tx="ekr.20051025071455.52">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')</t>
<t tx="ekr.20051025080056">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.</t>
<t tx="ekr.20051025080420">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }</t>
<t tx="ekr.20051025080420.1"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.findCommand()
    else:
        self.openSpellTab()

def change(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.changeCommand()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFindCommand()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.frame.bodyWantsFocus()

def ignore (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.ignoreCommand()
    else:
        self.openSpellTab()</t>
<t tx="ekr.20051025080633">def openSpellTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()</t>
<t tx="ekr.20051025094004">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = Aspell(c,dictionaryFileName,self.local_language_code)
    if not self.aspell.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True</t>
</tnodes>
</leo_file>
