<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="9077" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="48" left="451" height="870" width="793"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2" a="V"><vh>To do</vh>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601" descendentTnodeUnknownAttributes="7d71005814000000656b722e32303036303230313135303534372e3871017d710255092f3e0d0a3c742074787103551a7a6f7263616e6461212e32303035303932353136303131382e31710473732e"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20060203112912.1"><vh>Initing</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3941"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20031218072017.1801"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20031218072017.1802"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3942"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20041221122440"><vh>f.component &amp; components</vh></v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20051121092320"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20041221071131"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20041221071131.1"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050119210541"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041221123325"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20041223130032"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20041221195402"><vh>Pmw...</vh>
<v t="ekr.20041221073427"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20031218072017.3946"><vh>resizePanesToRatio</vh>
<v t="ekr.20050104084531"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221075743"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20041221185246"><vh>Tk...</vh>
<v t="ekr.20041221073427.1"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20031218072017.3947"><vh>bindBar</vh></v>
<v t="ekr.20031218072017.3949"><vh>divideAnySplitter</vh></v>
<v t="ekr.20031218072017.3950"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20031218072017.3951"><vh>onDrag...</vh></v>
<v t="ekr.20031218072017.3952"><vh>placeSplitter</vh></v>
<v t="ekr.20031218072017.998"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3964"><vh>Destroying the frame</vh>
<v t="ekr.20031218072017.1975"><vh>destroyAllObjects</vh>
<v t="ekr.20031218072017.1976"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3965"><vh>destroyAllPanels</vh></v>
<v t="ekr.20031218072017.1974"><vh>destroySelf (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
</v>
<v t="ekr.20060208080524"><vh>4.4b2 projects</vh>
<v t="ekr.20060210180603"><vh>Fixed multiple pastes into find tab</vh>
<v t="ekr.20051023181449"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh></v>
</v>
<v t="ekr.20060206131908"><vh>catch exceptions in pasteText</vh></v>
<v t="ekr.20060206113925"><vh>Made sure yield works with Python 2.2</vh></v>
<v t="ekr.20060211132742"><vh>Fixed the alt key on Linux</vh>
<v t="ekr.20060126163152.2"><vh>k.strokeFromEvent</vh></v>
</v>
<v t="ekr.20060206113925.1"><vh>Fixed problem with body_gmt_time setting</vh>
<v t="ekr.20060211135013"><vh>Report</vh></v>
<v t="ekr.20031218072017.1832"><vh>getTime &amp; test</vh></v>
</v>
<v t="ekr.20060116082302.1"><vh>Use os.getenv('User") if it exists to get initial cvs name</vh>
<v t="ekr.20060211140947"><vh>Report</vh></v>
<v t="ekr.20031218072017.1978"><vh>app.setLeoID</vh>
<v t="ekr.20031218072017.1979"><vh>&lt;&lt; return if we can set leoID from sys.leoID&gt;&gt;</vh></v>
<v t="ekr.20031218072017.1980"><vh>&lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;</vh></v>
<v t="ekr.20060211140947.1"><vh>&lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1981"><vh>&lt;&lt; put up a dialog requiring a valid id &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1982"><vh>&lt;&lt; attempt to create leoID.txt &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060121101642"><vh>Made sure save updates the open directory</vh>
<v t="ekr.20031218072017.2820"><vh>top level</vh>
<v t="ekr.20031218072017.1623"><vh>new</vh></v>
<v t="ekr.20031218072017.2821"><vh>open</vh>
<v t="ekr.20031218072017.2822"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2823"><vh>openWith and allies</vh>
<v t="ekr.20031218072017.2824"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2825"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20031218072017.2826"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2827"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20031218072017.2828"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2829"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2830"><vh>createOpenWithTempFile</vh>
<v t="ekr.20031218072017.2831"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2832"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20031218072017.2833"><vh>close</vh></v>
<v t="ekr.20031218072017.2834"><vh>save</vh></v>
<v t="ekr.20031218072017.2835"><vh>saveAs</vh></v>
<v t="ekr.20031218072017.2836"><vh>saveTo</vh></v>
<v t="ekr.20031218072017.2837"><vh>revert</vh></v>
</v>
<v t="ekr.20031218072017.2052"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20060114055611"><vh>Fix sort-lines problems</vh>
<v t="ekr.20060211175131"><vh>What I did</vh></v>
<v t="ekr.20050920084036.118"><vh>sortLines</vh></v>
<v t="ekr.20051214132256"><vh>begin/endCommand</vh>
<v t="ekr.20051214133130"><vh>beginCommand  &amp; beginCommandWithEvent</vh>
<v t="ekr.20051215102349"><vh>beingCommandHelper</vh></v>
</v>
<v t="ekr.20051214133130.1"><vh>endCommand</vh></v>
</v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
<v t="ekr.20060207140352"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20031218072017.2949"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20031218072017.2950"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20031218072017.2951"><vh>c.bringToFront</vh></v>
<v t="ekr.20060205103842"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060210103358"><vh>c.invalidateFocus</vh></v>
<v t="ekr.20060207140352"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20031218072017.2953"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20051216171520"><vh>c.recolor_now</vh></v>
<v t="ekr.20031218072017.2954"><vh>c.redraw_now</vh></v>
<v t="ekr.20060208143543"><vh>c.restoreFocus</vh></v>
<v t="ekr.20060207142332"><vh>c.traceFocus</vh></v>
<v t="ekr.20060205111103"><vh>c.widget_name</vh></v>
<v t="ekr.20050120092028"><vh>c.xWantsFocus</vh></v>
<v t="ekr.20060210102201"><vh>c.xWantsFocusNow</vh></v>
</v>
</v>
<v t="ekr.20060211112120.1"><vh>Call updateAllMenus only if c.exists</vh></v>
<v t="ekr.20060211193044"><vh>Fixed problem with view plugin</vh></v>
<v t="ekr.20060211194440"><vh>Installed cleo patch</vh></v>
<v t="ekr.20060212055701"><vh>Remember previous open directory</vh>
<v t="ekr.20060212055701.1"><vh>Request</vh></v>
<v t="ekr.20031218072017.2052"><vh>g.openWithFileName</vh></v>
<v t="ekr.20031218072017.2820"><vh>top level</vh>
<v t="ekr.20031218072017.1623"><vh>new</vh></v>
<v t="ekr.20031218072017.2821"><vh>open</vh>
<v t="ekr.20031218072017.2822"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2823"><vh>openWith and allies</vh>
<v t="ekr.20031218072017.2824"><vh>&lt;&lt; set ext based on the present language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2825"><vh>&lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;</vh>
<v t="ekr.20031218072017.2826"><vh>&lt;&lt;set dict and path if a temp file already refers to p.v.t &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2827"><vh>&lt;&lt; create or recreate temp file as needed &gt;&gt;</vh>
<v t="ekr.20031218072017.2828"><vh>&lt;&lt; Raise dialog about conflict and set result &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2829"><vh>&lt;&lt; execute a command to open path in external editor &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2830"><vh>createOpenWithTempFile</vh>
<v t="ekr.20031218072017.2831"><vh>&lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2832"><vh>c.openWithTempFilePath</vh></v>
</v>
<v t="ekr.20031218072017.2833"><vh>close</vh></v>
<v t="ekr.20031218072017.2834"><vh>save</vh></v>
<v t="ekr.20031218072017.2835"><vh>saveAs</vh></v>
<v t="ekr.20031218072017.2836"><vh>saveTo</vh></v>
<v t="ekr.20031218072017.2837"><vh>revert</vh></v>
</v>
<v t="ekr.20031218072017.4057"><vh>app.gui.Tkinter file dialogs</vh>
<v t="ekr.20060212061804"><vh>runOpenFileDialog</vh></v>
<v t="ekr.20060212061804.1"><vh>runSaveFileDialog</vh></v>
</v>
</v>
<v t="ekr.20060212101331"><vh>Improved gc tracing</vh>
<v t="ekr.20040803072955.16"><vh>__init__ (tkTree)</vh>
<v t="ekr.20040803072955.17"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20040803072955.18"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040803072955.19"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20060127163325.1"><vh>enable/disableGcTrace</vh></v>
<v t="ekr.20040803072955.58"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20040803072955.59"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20031218072017.1588"><vh>Garbage Collection</vh>
<v t="ekr.20060127162818"><vh>enable_gc_debug</vh></v>
<v t="ekr.20031218072017.1589"><vh>clearAllIvars</vh></v>
<v t="ekr.20060205043324"><vh>Called from commands</vh>
<v t="ekr.20031218072017.1590"><vh>collectGarbage</vh></v>
<v t="ekr.20060205043324.1"><vh>printGcSummary</vh></v>
<v t="ekr.20060202161935"><vh>printGcAll</vh></v>
<v t="ekr.20060127164729.1"><vh>printGcObjects</vh>
<v t="ekr.20040703065638"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
<v t="ekr.20040703054646"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
</v>
<v t="ekr.20060127165509"><vh>printGcVerbose</vh></v>
</v>
<v t="ekr.20060205043324.2"><vh>Called from unit tests</vh>
<v t="ekr.20031218072017.1592"><vh>printGc</vh>
<v t="ekr.20031218072017.1593"><vh>printGcRefs</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20060213090947"><vh>Typing non-ascii keys in the minibuffer</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh></v>
<v t="ekr.20060126163152.2"><vh>k.strokeFromEvent</vh></v>
</v>
<v t="ekr.20060213143106"><vh>Fixed recent bug in Import Derived Files command</vh>
<v t="ekr.20031218072017.1809"><vh>importDerivedFile</vh></v>
<v t="ekr.20031218072017.1810"><vh>importDerivedFiles</vh>
<v t="ekr.20040930135204"><vh>&lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;</vh></v>
<v t="ekr.20051208100903.1"><vh>forceGnxOnPosition</vh></v>
</v>
</v>
<v t="ekr.20060213154136"><vh>Fixed bug: paste outline lost headline editing</vh>
<v t="ekr.20031218072017.1551"><vh>pasteOutline</vh>
<v t="ekr.20050418084539"><vh>&lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;</vh></v>
<v t="ekr.20050418084539.2"><vh>&lt;&lt; put only needed info in copiedBunchList &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060214082933"><vh>Fixed crasher cutText</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20051022142249,"><vh>@thin leoEditCommands.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.998">def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20031218072017.1551"># To cut and paste between apps, just copy into an empty body first, then copy to Leo's clipboard.

def pasteOutline(self,event=None,reassignIndices=True):

    c = self ; u = c.undoer ; current = c.currentPosition()
    s = g.app.gui.getTextFromClipboard()
    pasteAsClone = not reassignIndices
    undoType = g.choose(reassignIndices,'Paste Node','Paste As Clone')
    
    c.endEditing()

    if not s or not c.canPasteOutline(s):
        return # This should never happen.

    isLeo = g.match(s,0,g.app.prolog_prefix_string)
    tnodeInfoDict = {}
    if pasteAsClone:
        &lt;&lt; remember all data for undo/redo Paste As Clone &gt;&gt;

    if isLeo:
        pasted = c.fileCommands.getLeoOutline(s,reassignIndices)
    else:
        pasted = c.importCommands.convertMoreStringToOutlineAfter(s,current)
    if not pasted: return

    c.beginUpdate()
    try:
        copiedBunchList = []
        if pasteAsClone:
            &lt;&lt; put only needed info in copiedBunchList &gt;&gt;
        undoData = u.beforeInsertNode(current,
        pasteAsClone=pasteAsClone,copiedBunchList=copiedBunchList)
        c.endEditing()
        c.validateOutline()
        c.selectPosition(pasted)
        pasted.setDirty()
        c.setChanged(True)
        # paste as first child if back is expanded.
        back = pasted.back()
        if back and back.isExpanded():
            pasted.moveToNthChildOf(back,0)
        u.afterInsertNode(pasted,undoType,undoData)
    finally:
        c.endUpdate(scroll=True)
        c.recolor()</t>
<t tx="ekr.20031218072017.1588"># debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
</t>
<t tx="ekr.20031218072017.1589">def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
</t>
<t tx="ekr.20031218072017.1590">def collectGarbage():

    try:
        if not g.app.trace_gc_inited and g.app.trace_gc_verbose:
            g.enable_gc_debug()

        if g.app.trace_gc_verbose or g.app.trace_gc_calls:
            g.es_print('Collecting garbage')

        gc.collect()
    except:
        pass
        
    # Only init once, regardless of what happens.
    g.app.trace_gc_inited = True</t>
<t tx="ekr.20031218072017.1592">def printGc(message=None):
    
    if not g.app.trace_gc: return None
    
    if not message:
        message = g.callerName(n=2)
        
    printGcObjects(message)
    printGcRefs(message)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(message)
        
    
</t>
<t tx="ekr.20031218072017.1593">def printGcRefs (message=''):

    refs = gc.get_referrers(app.windowList[0])
    g.es_print('-' * 30,message)

    if g.app.trace_gc_verbose:
        g.es_print("refs of", app.windowList[0])
        for ref in refs:
            g.es_print(type(ref))
    else:
        g.es_print("%d referers" % len(refs))</t>
<t tx="ekr.20031218072017.1623">def new (self,event=None):

    c,frame = g.app.newLeoCommanderAndFrame(fileName=None)
    
    # Needed for plugins.
    g.doHook("new",old_c=self,c=c,new_c=c)
    # Use the config params to set the size and location of the window.
    c.beginUpdate()
    try:
        frame.setInitialWindowGeometry()
        frame.deiconify()
        frame.lift()
        frame.resizePanesToRatio(frame.ratio,frame.secondary_ratio) # Resize the _new_ frame.
        t = leoNodes.tnode()
        v = leoNodes.vnode(c,t)
        p = leoNodes.position(c,v,[])
        v.initHeadString("NewHeadline")
        v.moveToRoot()
        c.editPosition(p)
    finally:
        c.endUpdate()
        frame.body.setFocus()
    return c # For unit test.</t>
<t tx="ekr.20031218072017.1801">def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    &lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</t>
<t tx="ekr.20031218072017.1802"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None</t>
<t tx="ekr.20031218072017.1809">def importDerivedFile (self,event=None):
    
    """Create a new outline from a 4.0 derived file."""
    
    c = self ; p = c.currentPosition()
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]
    
    names = g.app.gui.runOpenFileDialog(
        title="Import Derived File",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importDerivedFiles(parent=p,paths=names)</t>
<t tx="ekr.20031218072017.1810">def importDerivedFiles (self,parent=None,paths=None):
    # Not a command.  It must *not* have an event arg.
    
    c = self.c ; u = c.undoer ; command = 'Import'
    at = c.atFileCommands ; current = c.currentPosition()
    self.tab_width = self.getTabWidth()
    if not paths: return
    c.beginUpdate()
    try:
        u.beforeChangeGroup(current,command)
        for fileName in paths:
            &lt;&lt; set isThin if fileName is a thin derived file &gt;&gt;
            undoData = u.beforeInsertNode(parent)
            p = parent.insertAfter()
            if isThin:
                at.forceGnxOnPosition(p)
                p.initHeadString("@thin " + fileName)
                at.read(p,thinFile=True)
            else:
                p.initHeadString("Imported @file " + fileName)
                at.read(p,importFileName=fileName)
            p.contract()
            u.afterInsertNode(p,command,undoData)
        current.expand()
        c.selectPosition(current)
        c.setChanged(True)
        u.afterChangeGroup(p,command)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20031218072017.1832">def getTime (self,body=True):

    c = self
    default_format =  "%m/%d/%Y %H:%M:%S" # E.g., 1/30/2003 8:31:55
    
    # Try to get the format string from leoConfig.txt.
    if body:
        format = c.config.getString("body_time_format_string")
        gmt    = c.config.getBool("body_gmt_time")
    else:
        format = c.config.getString("headline_time_format_string")
        gmt    = c.config.getBool("headline_gmt_time")

    if format == None:
        format = default_format

    try:
        import time
        if gmt:
            s = time.strftime(format,time.gmtime())
        else:
            s = time.strftime(format,time.localtime())
    except (ImportError, NameError):
        g.es("time.strftime not available on this platform",color="blue")
        return ""
    except:
        g.es_exception() # Probably a bad format string in leoSettings.leo.
        s = time.strftime(default_format,time.gmtime())
    return s
</t>
<t tx="ekr.20031218072017.1974">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20031218072017.1975">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)</t>
<t tx="ekr.20031218072017.1976"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="ekr.20031218072017.1978">def setLeoID (self,verbose=True):

    tag = ".leoID.txt"
    homeDir = g.app.homeDir
    globalConfigDir = g.app.globalConfigDir
    loadDir = g.app.loadDir
    
    verbose = not g.app.unitTesting
    &lt;&lt; return if we can set leoID from sys.leoID &gt;&gt;
    &lt;&lt; return if we can set leoID from "leoID.txt" &gt;&gt;
    &lt;&lt; return if we can set leoID from os.getenv('USER') &gt;&gt;
    &lt;&lt; put up a dialog requiring a valid id &gt;&gt;
    &lt;&lt; attempt to create leoID.txt &gt;&gt;</t>
<t tx="ekr.20031218072017.1979"># This would be set by in Python's sitecustomize.py file.

# 7/2/04: Use hasattr &amp; getattr to suppress pychecker warning.
# We also have to use a "non-constant" attribute to suppress another warning!

nonConstantAttr = "leoID"

if hasattr(sys,nonConstantAttr):
    g.app.leoID = getattr(sys,nonConstantAttr)
    if verbose: g.es_print("leoID = " + g.app.leoID, color='red')
    return
else:
    g.app.leoID = None</t>
<t tx="ekr.20031218072017.1980">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'r')
            s = f.readline()
            f.close()
            if s and len(s) &gt; 0:
                g.app.leoID = s
                if verbose:
                    g.es_print("leoID = %s (in %s)" % (g.app.leoID,theDir), color="red")
                return
            elif verbose:
                g.es_print("empty %s (in %s)" % (tag,theDir), color = "red")
        except IOError:
            g.app.leoID = None
            # g.es("%s not found in %s" % (tag,theDir),color="red")
        except Exception:
            g.app.leoID = None
            g.es_print('Unexpected exception in app.setLeoID',color='red')
            g.es_exception()</t>
<t tx="ekr.20031218072017.1981"># New in 4.1: get an id for gnx's.  Plugins may set g.app.leoID.

# Create an emergency gui and a Tk root window.
g.app.createTkGui("startup")

# Bug fix: 2/6/05: put result in g.app.leoID.
g.app.leoID = g.app.gui.runAskLeoIDDialog()

# g.trace(g.app.leoID)
g.es_print("leoID = %s" % (repr(g.app.leoID)),color="blue")</t>
<t tx="ekr.20031218072017.1982">for theDir in (homeDir,globalConfigDir,loadDir):
    # N.B. We would use the _working_ directory if theDir is None!
    if theDir:
        cant = "can not create %s in %s" % (tag,theDir)
        try:
            fn = g.os_path_join(theDir,tag)
            f = open(fn,'w')
            f.write(g.app.leoID)
            f.close()
            if g.os_path_exists(fn):
                s = "%s created in %s" % (tag,theDir)
                g.es_print(s, color="red")
                return
            else:
                g.es(cant,color='red')
        except IOError:
            g.es(cant,color='red')</t>
<t tx="ekr.20031218072017.2052">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_abspath(g.os_path_dirname(fileName))
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20031218072017.2176">def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    # f.enableTclTraces()</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.2820"></t>
<t tx="ekr.20031218072017.2821">def open (self,event=None):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title = "Open",
        filetypes = [("Leo files","*.leo"), ("All files","*")],
        defaultextension = ".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok:
            g.app.globalOpenDir = frame.openDirectory
            # g.es('current directory: %s' %  g.app.globalOpenDir)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)
    else:
        c.bodyWantsFocus()</t>
<t tx="ekr.20031218072017.2822">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow and # The window was open on startup
    not c.changed and not c.frame.saved and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened</t>
<t tx="ekr.20031218072017.2823">def openWith(self,event=None,data=None):

    """This routine handles the items in the Open With... menu.

    These items can only be created by createOpenWithMenuFromTable().
    Typically this would be done from the "open2" hook.
    
    New in 4.3: The "os.spawnv" now works. You may specify arguments to spawnv
    using a list, e.g.:
        
    openWith("os.spawnv", ["c:/prog.exe","--parm1","frog","--switch2"], None)
    """
    
    c = self ; p = c.currentPosition()
    n = data and len(data) or 0
    if n != 3:
        g.trace('bad data, length must be 3, got %d' % n)
        return
    try:
        openType,arg,ext=data
        if not g.doHook("openwith1",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext):
            &lt;&lt; set ext based on the present language &gt;&gt;
            &lt;&lt; create or reopen temp file, testing for conflicting changes &gt;&gt;
            &lt;&lt; execute a command to open path in external editor &gt;&gt;
        g.doHook("openwith2",c=c,p=p,v=p.v,openType=openType,arg=arg,ext=ext)
    except Exception:
        g.es("unexpected exception in c.openWith")
        g.es_exception()

    return "break"
</t>
<t tx="ekr.20031218072017.2824">if not ext:
    theDict = g.scanDirectives(c)
    language = theDict.get("language")
    ext = g.app.language_extension_dict.get(language)
    # print language,ext
    if ext == None:
        ext = "txt"
    
if ext[0] != ".":
    ext = "."+ext
    
# print "ext",ext</t>
<t tx="ekr.20031218072017.2825">theDict = None ; path = None
&lt;&lt; set dict and path if a temp file already refers to p.v.t &gt;&gt;
if path:
    &lt;&lt; create or recreate temp file as needed &gt;&gt;
else:
    path = c.createOpenWithTempFile(p,ext)

if not path:
    return # An error has occured.</t>
<t tx="ekr.20031218072017.2826">searchPath = c.openWithTempFilePath(p,ext)

if g.os_path_exists(searchPath):
    for theDict in g.app.openWithFiles:
        if p.v == theDict.get('v') and searchPath == theDict.get("path"):
            path = searchPath
            break
</t>
<t tx="ekr.20031218072017.2827">@ We test for changes in both p and the temp file:

- If only p's body text has changed, we recreate the temp file.
- If only the temp file has changed, do nothing here.
- If both have changed we must prompt the user to see which code to use.
@c

encoding = theDict.get("encoding")
old_body = theDict.get("body")
new_body = p.bodyString()
new_body = g.toEncodedString(new_body,encoding,reportErrors=True)

old_time = theDict.get("time")
try:
    new_time = g.os_path_getmtime(path)
except:
    new_time = None
    
body_changed = old_body != new_body
temp_changed = old_time != new_time

if body_changed and temp_changed:
    &lt;&lt; Raise dialog about conflict and set result &gt;&gt;
    if result == "cancel": return
    rewrite = result == "outline"
else:
    rewrite = body_changed
        
if rewrite:
    path = c.createOpenWithTempFile(p,ext)
else:
    g.es("reopening: " + g.shortFileName(path),color="blue")</t>
<t tx="ekr.20031218072017.2828">message = (
    "Conflicting changes in outline and temp file\n\n" +
    "Do you want to use the code in the outline or the temp file?\n\n")

result = g.app.gui.runAskYesNoCancelDialog(c,
    "Conflict!", message,
    yesMessage = "Outline",
    noMessage = "File",
    defaultButton = "Cancel")</t>
<t tx="ekr.20031218072017.2829">try:
    if arg == None: arg = ""
    shortPath = path # g.shortFileName(path)
    if openType == "os.system":
        if 1:
            # This works, _provided_ that arg does not contain blanks.  Sheesh.
            command = 'os.system(%s)' % (arg+shortPath)
            os.system(arg+shortPath)
        else:
            # XP does not like this format!
            command = 'os.system("%s" "%s")' % (arg,shortPath)
            os.system('"%s" "%s"' % (arg,shortPath))
    elif openType == "os.startfile":
        command = "os.startfile(%s)" % (arg+shortPath)
        os.startfile(arg+path)
    elif openType == "exec":
        command = "exec(%s)" % (arg+shortPath)
        exec arg+path in {}
    elif openType == "os.spawnl":
        filename = g.os_path_basename(arg)
        command = "os.spawnl(%s,%s,%s)" % (arg,filename,path)
        apply(os.spawnl,(os.P_NOWAIT,arg,filename,path))
    elif openType == "os.spawnv":
        filename = os.path.basename(arg[0]) 
        vtuple = arg[1:]
        vtuple.insert(0, filename)
            # add the name of the program as the first argument.
            # Change suggested by Jim Sizelove.
        vtuple.append(path)
        command = "os.spawnv(%s,%s)" % (arg[0],repr(vtuple))
        apply(os.spawnv,(os.P_NOWAIT,arg[0],vtuple))
    # This clause by Jim Sizelove.
    elif openType == "subprocess.Popen":
        if isinstance(arg, basestring):
            vtuple = arg + " " + path
        elif isinstance(arg, (list, tuple)):
            vtuple = arg[:]
            vtuple.append(path)
        command = "subprocess.Popen(%s)" % repr(vtuple)
        if subprocess:
            subprocess.Popen(vtuple)
        else:
            g.grace('Can not import subprocess.  Skipping: "%s"' % command)
    else:
        command="bad command:"+str(openType)
        g.trace(command)
except Exception:
    g.es("exception executing: "+command)
    g.es_exception()</t>
<t tx="ekr.20031218072017.2830">def createOpenWithTempFile (self,p,ext):
    
    c = self
    path = c.openWithTempFilePath(p,ext)
    try:
        if g.os_path_exists(path):
            g.es("recreating:  " + g.shortFileName(path),color="red")
        else:
            g.es("creating:  " + g.shortFileName(path),color="blue")
        theFile = open(path,"w")
        # Convert s to whatever encoding is in effect.
        s = p.bodyString()
        theDict = g.scanDirectives(c,p=p)
        encoding = theDict.get("encoding",None)
        if encoding == None:
            encoding = c.config.default_derived_file_encoding
        s = g.toEncodedString(s,encoding,reportErrors=True) 
        theFile.write(s)
        theFile.flush()
        theFile.close()
        try:    time = g.os_path_getmtime(path)
        except: time = None
        # g.es("time: " + str(time))
        # New in 4.3: theDict now contains both 'p' and 'v' entries, of the expected type.
        theDict = {
            "body":s, "c":c, "encoding":encoding,
            "f":theFile, "path":path, "time":time,
            "p":p, "v":p.v }
        &lt;&lt; remove previous entry from app.openWithFiles if it exists &gt;&gt;
        g.app.openWithFiles.append(theDict)
        return path
    except:
        if theFile:
            theFile.close()
        theFile = None
        g.es("exception creating temp file",color="red")
        g.es_exception()
        return None</t>
<t tx="ekr.20031218072017.2831">for d in g.app.openWithFiles[:]:
    p2 = d.get("p")
    if p.v.t == p2.v.t:
        # print "removing previous entry in g.app.openWithFiles for",p.headString()
        g.app.openWithFiles.remove(d)</t>
<t tx="ekr.20031218072017.2832">def openWithTempFilePath (self,p,ext):
    
    """Return the path to the temp file corresponding to p and ext."""
    
    if 0: # new code: similar to code in mod_tempfname.py plugin.
        try:
            # At least in Windows, user name may contain special characters
            # which would require escaping quotes.
            leoTempDir = g.sanitize_filename(getpass.getuser()) + "_" + "Leo"
        except:
            leoTempDir = "LeoTemp"
            g.es("Could not retrieve your user name.")
            g.es("Temporary files will be stored in: %s" % leoTempDir)
        
        td = os.path.join(g.os_path_abspath(tempfile.gettempdir()),leoTempDir)
        if not os.path.exists(td):
            os.mkdir(td)
        
        name = g.sanitize_filename(v.headString()) + '_' + str(id(v.t))  + ext
        path = os.path.join(td,name)
        return path
    else: # Original code.
        name = "LeoTemp_%s_%s%s" % (
            str(id(p.v.t)),
            g.sanitize_filename(p.headString()),
            ext)
    
        name = g.toUnicode(name,g.app.tkEncoding)
    
        if 1:
            td = g.os_path_abspath(tempfile.gettempdir())
        else:
            td = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','temp'))
    
        path = g.os_path_join(td,name)
    
        return path</t>
<t tx="ekr.20031218072017.2833">def close (self,event=None):
    
    """Handle the File-Close command."""

    g.app.closeLeoWindow(self.frame)</t>
<t tx="ekr.20031218072017.2834">def save (self,event=None):

    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return
    
    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""
        c.mFileName = ""

    if c.mFileName != "":
        # Calls c.setChanged(False) if no error.
        c.fileCommands.save(c.mFileName)
    else:
        fileName = g.app.gui.runSaveFileDialog(
            initialfile = c.mFileName,
            title="Save",
            filetypes=[("Leo files", "*.leo")],
            defaultextension=".leo")
        if fileName:
            # Don't change mFileName until the dialog has suceeded.
            c.mFileName = g.ensure_extension(fileName, ".leo")
            c.frame.title = c.mFileName
            c.frame.setTitle(g.computeWindowTitle(c.mFileName))
            c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
            c.fileCommands.save(c.mFileName)
            c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20031218072017.2835">def saveAs (self,event=None):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save As",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        # 7/2/02: don't change mFileName until the dialog has suceeded.
        c.mFileName = g.ensure_extension(fileName, ".leo")
        c.frame.title = c.mFileName
        c.frame.setTitle(g.computeWindowTitle(c.mFileName))
        c.frame.openDirectory = g.os_path_dirname(c.mFileName) # Bug fix in 4.4b2.
        # Calls c.setChanged(False) if no error.
        c.fileCommands.saveAs(c.mFileName)
        c.updateRecentFiles(c.mFileName)</t>
<t tx="ekr.20031218072017.2836">def saveTo (self,event=None):
    
    c = self
    
    if g.app.disableSave:
        g.es("Save commands disabled",color="purple")
        return

    # Make sure we never pass None to the ctor.
    if not c.mFileName:
        c.frame.title = ""

    # set local fileName, _not_ c.mFileName
    fileName = g.app.gui.runSaveFileDialog(
        initialfile = c.mFileName,
        title="Save To",
        filetypes=[("Leo files", "*.leo")],
        defaultextension=".leo")

    if fileName:
        fileName = g.ensure_extension(fileName, ".leo")
        c.fileCommands.saveTo(fileName)
        c.updateRecentFiles(fileName)</t>
<t tx="ekr.20031218072017.2837">def revert (self,event=None):
    
    c = self

    # Make sure the user wants to Revert.
    if not c.mFileName:
        return
        
    reply = g.app.gui.runAskYesNoDialog(c,"Revert",
        "Revert to previous version of " + c.mFileName + "?")

    if reply=="no":
        return

    # Kludge: rename this frame so openWithFileName won't think it is open.
    fileName = c.mFileName ; c.mFileName = ""

    # Create a new frame before deleting this frame.
    ok, frame = g.openWithFileName(fileName,c)
    if ok:
        frame.deiconify()
        g.app.destroyWindow(c.frame)
    else:
        c.mFileName = fileName
</t>
<t tx="ekr.20031218072017.2949"></t>
<t tx="ekr.20031218072017.2950">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20031218072017.2951">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20031218072017.2953">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20031218072017.2954">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3941"></t>
<t tx="ekr.20031218072017.3942">def __repr__ (self):

    return "&lt;leoTkinterFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20031218072017.3944">def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas</t>
<t tx="ekr.20031218072017.3946">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        &lt;&lt; resize the Pmw panes &gt;&gt;
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20031218072017.3947">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="ekr.20031218072017.3949"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="ekr.20031218072017.3950"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20031218072017.3951">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="ekr.20031218072017.3952">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="ekr.20031218072017.3964"></t>
<t tx="ekr.20031218072017.3965">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()</t>
<t tx="ekr.20031218072017.4057"># We no longer specify default extensions so that we can open and save files without extensions.</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 beta 2, build %s, February 14, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.413 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040703054646">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    t = type(obj)
    if t == 'instance':
        try: t = obj.__class__
        except: pass
    typesDict[t] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.es_print("%+6d =%7d %s" % (delta2,n2,key))
    
lastTypesDict = typesDict
typesDict = {}</t>
<t tx="ekr.20040703065638">import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            g.es_print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.es_print("args", args)
            if varargs: g.es_print("varargs",varargs)
            if varkw: g.es_print("varkw",varkw)
            if defaults:
                g.es_print("defaults...")
                for s in defaults: g.es_print(s)

lastFunctionsDict = funcDict
funcDict = {}</t>
<t tx="ekr.20040709081208"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)</t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20040803072955.16">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    # Configuration and debugging settings.
    self.expanded_click_area    = c.config.getBool('expanded_click_area')
    self.gc_before_redraw       = c.config.getBool('gc_before_redraw')
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')

    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')
    self.trace_select           = c.config.getBool('trace_select')
    self.trace_stats            = c.config.getBool('show_tree_stats')
 
    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []</t>
<t tx="ekr.20040803072955.17">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20040803072955.18"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20040803072955.19"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20040803072955.58"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.gc_before_redraw:
            g.collectGarbage()
        if g.app.trace_gc_verbose:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            g.trace(self.redrawCount,g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20040803072955.59">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20040930135204">fileName = g.os_path_normpath(fileName)

try:
    theFile = open(fileName,'rb')
    isThin = at.scanHeaderForThin(theFile,fileName)
    theFile.close()
except IOError:
    isThin = False</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041221071131">def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas</t>
<t tx="ekr.20041221071131.1">def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 0:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20041221073427">def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame</t>
<t tx="ekr.20041221073427.1">def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2</t>
<t tx="ekr.20041221075743">@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)</t>
<t tx="ekr.20041221122440">def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()</t>
<t tx="ekr.20041221123325">def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        &lt;&lt; create Pmw splitters and their components &gt;&gt;
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="ekr.20041221185246">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.</t>
<t tx="ekr.20041221195402"></t>
<t tx="ekr.20041223130032"># Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20050104084531">self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))</t>
<t tx="ekr.20050119210541"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)</t>
<t tx="ekr.20050120092028">def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)</t>
<t tx="ekr.20050418084539">@

We don't know yet which nodes will be affected by the paste, so we remember
everything. This is expensive, but foolproof.

The alternative is to try to remember the 'before' values of tnodes in the
fileCommands read logic. Several experiments failed, and the code is very ugly.
In short, it seems wise to do things the foolproof way.

@c

for p in c.allNodes_iter():
    t = p.v.t
    if t not in tnodeInfoDict.keys():
        tnodeInfoDict[t] = g.Bunch(
            t=t,head=p.headString(),body=p.bodyString())</t>
<t tx="ekr.20050418084539.2"># Create a dict containing only copied tnodes.
copiedTnodeDict = {}
for p in pasted.self_and_subtree_iter():
    if p.v.t not in copiedTnodeDict:
        copiedTnodeDict[p.v.t] = p.v.t
        
# g.trace(copiedTnodeDict.keys())

for t in tnodeInfoDict.keys():
    bunch = tnodeInfoDict.get(t)
    if copiedTnodeDict.get(t):
        copiedBunchList.append(bunch)

# g.trace('copiedBunchList',copiedBunchList)</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050920084036.118">def sortLines (self,event,which=None):

    c = self.c ; k = c.k ; w = event.widget
    g.trace(c.widget_name(w))
    if not self._chckSel(event): return
    self.beginCommand()
    i = w.index('sel.first')
    i2 = w.index('sel.last')
    is1 = i.split('.')
    is2 = i2.split('.')
    txt = w.get('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    ins = w.index('insert')
    txt = txt.split('\n')
    w.delete('%s.0' % is1[0],'%s.0 lineend' % is2[0])
    txt.sort()
    if which:
        txt.reverse()
    inum = int(is1[0])
    for z in txt:
        w.insert('%s.0' % inum,'%s\n' % z)
        inum = inum + 1
    w.mark_set('insert',ins)
    self.endCommand(changed=True,setLabel=False)</t>
<t tx="ekr.20050920085536.1"></t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20050920085536.41">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif ch not in string.printable:
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20050920085536.45">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20050923213858">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())</t>
<t tx="ekr.20051009044751">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
        f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)
        f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
        f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)</t>
<t tx="ekr.20051009044920"># Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()</t>
<t tx="ekr.20051009045208">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()</t>
<t tx="ekr.20051009045300"># Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)</t>
<t tx="ekr.20051011072903.5">def pasteText (self,event=None):

    '''Paste the clipboard into a widget.'''

    f = self ; c = f.c ; w = event and event.widget
    if not w or not g.app.gui.isTextWidget(w): return

    wname = c.widget_name(w)
    oldSel = g.app.gui.getTextSelection(w)
    oldText = w.get('1.0','end')
    i,j = g.app.gui.getTextSelection(w)
    s = s1 = g.app.gui.getTextFromClipboard()
    # g.trace(wname,s,i,j)
    
    singleLine = wname.startswith('head') or wname.startswith('minibuffer')
    
    if singleLine:
        # Strip trailing newlines so the truncation doesn't cause confusion.
        while s and s [ -1] in ('\n','\r'):
            s = s [: -1]

    try:
        # Update the widget.
        if i != j:
            w.delete(i,j)
        w.insert(i,s)
    
        if wname.startswith('body'):
            c.frame.body.onBodyChanged('Paste',oldSel=oldSel,oldText=oldText)
        elif singleLine:
            s = w.get('1.0','end')
            while s and s [ -1] in ('\n','\r'):
                s = s [: -1]
            if wname.startswith('head'):
                # The headline is not officially changed yet.
                # p.initHeadString(s)
                w.configure(width=f.tree.headWidth(s=s))
        else: pass
    except Exception:
        pass # Tk sometimes throws weird exceptions here.
        
    return 'break' # Essential

OnPasteFromMenu = pasteText</t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    self.findButtonCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051121092320">def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)</t>
<t tx="ekr.20051208100903.1">def forceGnxOnPosition (self,p):

    self._forcedGnxPositionList.append(p.v)</t>
<t tx="ekr.20051214132256"></t>
<t tx="ekr.20051214133130">def beginCommand (self,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''

    return self.beginCommandHelper(ch='',undoType=undoType,w=self.w)

def beginCommandWithEvent (self,event,undoType='Typing'):
    
    '''Do the common processing at the start of each command.'''
    
    return self.beginCommandHelper(ch=event.char,undoType=undoType,w=event.widget)</t>
<t tx="ekr.20051214133130.1">def endCommand(self,label=None,changed=True,setLabel=True):
    
    '''Do the common processing at the end of each command.'''
    
    c = self.c ; b = self.undoData ; k = self.k

    if b:
        name = b.name
        if name.startswith('body'):
            if changed:
                c.frame.body.onBodyChanged(undoType=b.undoType,
                    oldSel=b.oldSel,oldText=b.oldText,oldYview=None)
        elif name.startswith('head'):
            g.trace('Should not happen: endCommand does not support undo in headlines')
        else: pass
        
    self.undoData = None # Bug fix: 1/6/06 (after a5 released).

    k.clearState()
    
    # Warning: basic editing commands **must not** set the label.
    if setLabel:
        if label:
            k.setLabelGrey(label)
        else:
            k.resetLabel()</t>
<t tx="ekr.20051215102349">def beginCommandHelper (self,ch,undoType,w):

    c = self.c ; p = c.currentPosition()
    name = c.widget_name(w)
    
    # Don't do this in headlines!
    if name.startswith('body'):
        oldSel =  g.app.gui.getTextSelection(w)
        oldText = p.bodyString()
        self.undoData = g.Bunch(
            ch=ch,name=name,oldSel=oldSel,oldText=oldText,w=w,undoType=undoType)
        
    return w</t>
<t tx="ekr.20051216171520">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20060114055611"></t>
<t tx="ekr.20060115195302">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20060116082302.1"></t>
<t tx="ekr.20060121101642">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3534349
By: edcdave

Saving the Leo file is not sufficient - I have to exit the document and open
it again before the rst destination directory is set correctly.

The fix was to set c.frame.openDirectory in save and 

@color
</t>
<t tx="ekr.20060126163152.2"># The keys to k.bindingsDict must be consistent with what this method returns.
# See 'about internal bindings' for details.
 
def strokeFromEvent (self,event):
    
    c = self.c ; k = c.k
    if event is None: return ''
    state = event.state or 0
    keysym = event.keysym or ''
    ch = event.char
    result = []
    shift = (state &amp; 1) == 1 # Not used for alpha chars.
    caps  = (state &amp; 2) == 2 # Not used at all.
    ctrl  = (state &amp; 4) == 4
    # Linux uses, 8 and 0x80, XP uses 0x20000.
    alt   = (state &amp; 0x20000) == 0x20000 or (state &amp; 8) == 8 or (state &amp; 0x80) == 0x80
    plain = len(keysym) == 1 # E.g., for ctrl-v the keysym is 'v' but ch is empty.
    
    # g.trace('ch',repr(ch),'keysym',repr(keysym),'state: %x' % state)
    
    # The big aha: we can ignore the shift state.
    if plain:
        if shift and ch.isalpha() and ch.islower():
            g.trace('oops: inconsistent shift state. shift: %s, ch: %s' % (shift,ch))
        ch = keysym
        shift = False
    else:
        ch2 = k.tkBindNamesInverseDict.get(keysym)
        if ch2:
            ch = ch2
            if len(ch) == 1: shift = False
        else:
            # Just use the unknown keysym.
            g.trace('*'*30,'unknown keysym',repr(keysym))
    
    if alt: result.append('Alt+')
    if ctrl: result.append('Ctrl+')
    if shift: result.append('Shift+')
    result.append(ch)
    result = ''.join(result)
    # g.trace('state',state,'keysym',keysym,'result',repr(result))
    return result</t>
<t tx="ekr.20060127162818">def enable_gc_debug(event=None):
    
    if g.app.trace_gc_inited:
        return
    
    if gc:
        if g.app.trace_gc_verbose:
            gc.set_debug(
                gc.DEBUG_STATS | # prints statistics.
                gc.DEBUG_LEAK | # Same as all below.
                gc.DEBUG_COLLECTABLE |
                gc.DEBUG_UNCOLLECTABLE |
                gc.DEBUG_INSTANCES |
                gc.DEBUG_OBJECTS |
                gc.DEBUG_SAVEALL
            )
            g.es('enabled verbose gc stats',color='blue')
        else:
            gc.set_debug(gc.DEBUG_STATS)
            g.es('enabled brief gc stats',color='blue')
    else:
        g.es('Can not import gc module',color='blue')</t>
<t tx="ekr.20060127163325.1">def disableGcTrace (self,event=None):
    
    g.app.trace_gc = False
    
def enableGcTrace (self,event=None):
    
    g.app.trace_gc = True
    g.app.trace_gc_inited = False
    g.enable_gc_debug()</t>
<t tx="ekr.20060127164729.1">def printGcObjects(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        lastObjectCount = n2

        g.es_print('-' * 30)
        g.es_print("garbage: %d, objects: %d, delta: %d %s" % (n,n2,delta,message))
        
        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

    except:
        traceback.print_exc()</t>
<t tx="ekr.20060127165509"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(message=''):
    
    if not message:
        message = g.callerName(n=2)

    global lastObjectsDict
    objects = gc.get_objects()
    
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            seqs += 1
        else:
            g.es_print(o)
        i += 1
    g.es_print('-' * 40)
    g.es_print('dicts: %d, sequences: %d' % (dicts,seqs))
    g.es_print("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))</t>
<t tx="ekr.20060202161935">def printGcAll (message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    d = {} ; objects = gc.get_objects()
    g.es_print('-' * 30)
    g.es_print('%d objects' % len(objects),message)

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            g.es_print('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            g.es_print('%40s %7d' % (t,d.get(t)))
</t>
<t tx="ekr.20060203112912.1"></t>
<t tx="ekr.20060205043324"></t>
<t tx="ekr.20060205043324.1">def printGcSummary (message='',trace=False):
    
    if not message:
        message = g.callerName(n=2)

    g.enable_gc_debug()

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = 'garbage: %d, objects: %d, %s' % (n,n2,message)
        if trace:
            print s
        else:
            g.es_print(s)
    except:
        traceback.print_exc()</t>
<t tx="ekr.20060205043324.2"></t>
<t tx="ekr.20060205103842">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def get_requested_focus (self):
    
    c = self
    return c.requestedFocusWidget or c.hasFocusWidget or g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20060205111103">def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)</t>
<t tx="ekr.20060205221734">def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # if trace: g.trace(repr(stroke),'mini binding',b.commandName)
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060206113925">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3549737
By: nobody

\src\leoEditCommands.py:340: 
Warning: 'yield' will become a reserved keyword 

for python2.2 leoEditCommands.py needs
from __future__ import generators

Also changed the following plugins:

at_produce.py
fastGotoNode.py
rst3.py
zodb.py</t>
<t tx="ekr.20060206113925.1"></t>
<t tx="ekr.20060206131908"># Paste-text crashed when pasting into minibuffer
</t>
<t tx="ekr.20060207140352">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_masterFocusHandler')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if trace: g.trace(
        'requested',c.widget_name(c.requestedFocusWidget),
        'present',c.widget_name(c.hasFocusWidget),
        g.callers())
    
    if c.hasFocusWidget and (
        not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget):
        # if trace: g.trace('no change.',c.widget_name(w))
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        # This is not an error: it can arise because of a call to k.invalidateFocus.
        # g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler</t>
<t tx="ekr.20060207142332">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers(8))</t>
<t tx="ekr.20060208080524"></t>
<t tx="ekr.20060208143543">def restoreFocus (self):
    
    '''Ensure that the focus eventually gets restored.'''
    
    c =self
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')

    if c.requestedFocusWidget:
        c.hasFocusWidget = None # Force an update
    elif c.hasFocusWidget:
        c.requestedFocusWidget = c.hasFocusWidget
        c.hasFocusWidget = None # Force an update
    else:
        # Should not happen, except during unit testing.
        # c.masterFocusHandler sets c.hasFocusWidget,
        # so if it is not set here it is because this method cleared it.
        if not g.app.unitTesting: g.trace('oops: no requested or present widget.')
        c.bodyWantsFocusNow()
    
    if c.inCommand:
        if trace: g.trace('expecting later call to c.masterFocusHandler')
        pass # A call to c.masterFocusHandler will surely happen.
    else:
        c.masterFocusHandler() # Do it now.</t>
<t tx="ekr.20060210102201">def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
</t>
<t tx="ekr.20060210103358">def invalidateFocus (self):
    
    '''Indicate that the focus is in an invalid location, or is unknown.'''
    
    c = self
    c.requestedFocusWidget = None
    c.hasFocusWidget = None
    # g.trace(g.callers())
    
</t>
<t tx="ekr.20060210180603"># The callback must return what k.masterKeyHandler returns (i.e., 'break')</t>
<t tx="ekr.20060211112120.1">There was a problem during unit tests.  It may have other implications.</t>
<t tx="ekr.20060211132742"># http://sourceforge.net/forum/message.php?msg_id=3571104</t>
<t tx="ekr.20060211135013">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3549737

The fix was to call getBool rather than getString.</t>
<t tx="ekr.20060211140947">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3237845

On startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.</t>
<t tx="ekr.20060211140947.1">try:
    theId = os.getenv('USER')
    if theId:
        if verbose: g.es_print("using os.getenv('USER'): %s " % (repr(theId)),color='red')
        g.app.leoID = theId
        return
        
except Exception:
    pass</t>
<t tx="ekr.20060211175131">@nocolor

The problem: event.widget is the minibuffer.  It must be the body text.

- k.fullCommand saves the initial event and passes it on to callAltXFunction.

- There was a bug in c.masterFocusHandler.  The correct test for 'no change' is:

    if c.hasFocusWidget and c.requestedFocusWidget == c.hasFocusWidget:

** Important: the 'extra' calls to set_focus are correct. The minibuffer messes
with the tab pane, and so we *must* be careful to yank the focus back to the
body.</t>
<t tx="ekr.20060211193044">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3538274

It's not clear that there were serious problems with the plugin, but I improved the code and error messages.  All features work for me.

Several plugins use the icon-double-click hook.  The reported problems could have been due to plugin conflicts.
</t>
<t tx="ekr.20060211194440">http://sourceforge.net/forum/message.php?msg_id=3517080

Patch for CLeo to allow check-marks:
-----------------------------------------------------
Line 412 in def draw_arrow:
replace 
............canvas.create_line(v.iconx-10,v.icony+7,v.iconx+5,v.icony+7,fill
= 'Gray50',width=1)

with
............#@........&lt;&lt; Blank Check &gt;&gt;
............#@+node:rjries.20060113114142:&lt;&lt; Blank Check &gt;&gt;
............#@&lt;&lt; Point Setter &gt;&gt;
............#@+node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
............# Define the 3 points of a check mark to allow quick adjustment
............XpointA = v.iconx  -15+3
............YpointA = v.icony  +8-2
............XpointB = v.iconx  -7
............YpointB = v.icony  +13
............XpointC = v.iconx  +5
............YpointC = v.icony  -2
............#@nonl
............#@-node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
............#@nl
............# "white-out" the check mark
............canvas.create_line(XpointA, YpointA, XpointB, YpointB,
fill=colour,width=2)
............canvas.create_line(XpointB, YpointB, XpointC, YpointC,
fill=colour,width=2)
............#@nonl
............#@-node:rjries.20060113114142:&lt;&lt; Blank Check &gt;&gt;
............#@nl
............# restore line 
............canvas.create_line(v.iconx-12,v.icony+7,v.iconx+6,v.icony+7,fill
= 'Gray50',width=1)

-----------------------------------------------------
Line 421-422 in def draw_tick (**not draw_arrow):
replace 
........canvas.create_line(v.iconx+13-5,v.icony+8,v.iconx+13,v.icony+13,fill=colour,width=2)
........canvas.create_line(v.iconx+13,v.icony+13,v.iconx+13+12,v.icony-2,fill=colour,width=2)

with

........#@....&lt;&lt; Point Setter &gt;&gt;
........#@+node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
........# Define the 3 points of a check mark to allow quick adjustment
........XpointA = v.iconx  -15+3
........YpointA = v.icony  +8-2
........XpointB = v.iconx  -7
........YpointB = v.icony  +13
........XpointC = v.iconx  +5
........YpointC = v.icony  -2
........#@nonl
........#@-node:rjries.20060113114350:&lt;&lt; Point Setter &gt;&gt;
........#@nl
........# draw the check-mark
........canvas.create_line(XpointA, YpointA, XpointB, YpointB,
fill=colour,width=2)
........canvas.create_line(XpointB, YpointB, XpointC, YpointC,
fill=colour,width=2)

-----------------------------------------------------
Line 598 in def priority_menu
replace
............# (self.donePriority,'Done'),
with
............(self.donePriority,'Done'),
</t>
<t tx="ekr.20060212055701"></t>
<t tx="ekr.20060212055701.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3571431
By: ktenney

To reiterate a request:

When doing File-&gt;Open the default directory should the directory which
was navigated to for previous 'Open'

What I did:

- Defined g.app.globalOpenDir # The directory last used to open a file.</t>
<t tx="ekr.20060212061804">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir = g.app.globalOpenDir or g.os_path_abspath(os.getcwd())
    
    if multiple:
        # askopenfilenames requires Python 2.3 and Tk 8.4.
        if (
            g.CheckVersion(sys.version,"2.3") and
            g.CheckVersion(self.root.getvar("tk_patchLevel"),"8.4")
        ):
            files = tkFileDialog.askopenfilenames(
                title=title,filetypes=filetypes,initialdir=initialdir)
            # g.trace(files)
            return list(files)
        else:
            # Get one file and return it as a list.
            theFile = tkFileDialog.askopenfilename(
                title=title,filetypes=filetypes,initialdir=initialdir)
            return [theFile]
    else:
        # Return a single file name as a string.
        return tkFileDialog.askopenfilename(
            title=title,filetypes=filetypes,initialdir=initialdir)</t>
<t tx="ekr.20060212061804.1">def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""
    
    __pychecker__ = '--no-argsused' # defaultextension not used.
    
    initialdir=g.app.globalOpenDir or g.os_path_abspath(os.getcwd()),

    return tkFileDialog.asksaveasfilename(
        initialdir=initialdir,initialfile=initialfile,
        title=title,filetypes=filetypes)</t>
<t tx="ekr.20060212101331"></t>
<t tx="ekr.20060213090947"></t>
<t tx="ekr.20060213143106"></t>
<t tx="ekr.20060213154136"></t>
<t tx="ekr.20060214082933">@nocolor

Traceback (most recent call last):
  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 265, in doCommand
    val = command(event)
  File "C:\prog\leoCVS\leo\src\leoTkinterFrame.py", line 1959, in cutText
    w.configure(width=f.tree.headWidth(s=s))
UnboundLocalError: local variable 's' referenced before assignment
</t>
</tnodes>
</leo_file>
