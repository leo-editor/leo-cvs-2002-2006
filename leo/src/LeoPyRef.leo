<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="9109" clone_windows="0"/>
<globals body_outline_ratio="0.442906574394">
	<global_window_position top="10" left="423" height="867" width="751"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601" descendentTnodeUnknownAttributes="7d71005814000000656b722e32303036303230313135303534372e3871017d710255092f3e0d0a3c742074787103551a7a6f7263616e6461212e32303035303932353136303131382e31710473732e"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20060203112912.1"><vh>Initing</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3941"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20031218072017.1801"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20031218072017.1802"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3942"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20041221122440"><vh>f.component &amp; components</vh></v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20051121092320"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20041221071131"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20041221071131.1"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050119210541"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041221123325"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20041223130032"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20041221195402"><vh>Pmw...</vh>
<v t="ekr.20041221073427"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20031218072017.3946"><vh>resizePanesToRatio</vh>
<v t="ekr.20050104084531"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221075743"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20041221185246"><vh>Tk...</vh>
<v t="ekr.20041221073427.1"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20031218072017.3947"><vh>bindBar</vh></v>
<v t="ekr.20031218072017.3949"><vh>divideAnySplitter</vh></v>
<v t="ekr.20031218072017.3950"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20031218072017.3951"><vh>onDrag...</vh></v>
<v t="ekr.20031218072017.3952"><vh>placeSplitter</vh></v>
<v t="ekr.20031218072017.998"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3964"><vh>Destroying the frame</vh>
<v t="ekr.20031218072017.1975"><vh>destroyAllObjects</vh>
<v t="ekr.20031218072017.1976"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3965"><vh>destroyAllPanels</vh></v>
<v t="ekr.20031218072017.1974"><vh>destroySelf (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
</v>
<v t="ekr.20060214140930"><vh>4.4 x1 projects</vh>
<v t="ekr.20060214140930.1"><vh>Restored some legacy bindings</vh></v>
<v t="ekr.20060213164147"><vh>Fixed crasher in Go To Line command</vh>
<v t="ekr.20060215090312"><vh>Report</vh></v>
<v t="ekr.20031218072017.3353"><vh>matchHeadline</vh></v>
</v>
<v t="ekr.20060215092723"><vh>Fixed menu problem on Linux</vh>
<v t="ekr.20060215092723.1"><vh>Report</vh></v>
<v t="ekr.20060211100905.1"><vh>tkMenu.activateMenu</vh></v>
</v>
<v t="ekr.20060213151411"><vh>Fixed (maybe) problems with unicode characters &amp; caps lock</vh>
<v t="ekr.20060215092723.2"><vh>To do &amp; what I did</vh></v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
<v t="ekr.20060214172823"><vh>canonicalizeShortcut (4.3.3)</vh>
<v t="ekr.20060214172823.1"><vh>&lt;&lt; set the last field, preserving case &gt;&gt;</vh></v>
<v t="ekr.20060214172823.2"><vh>&lt;&lt; canonicalize the last field &gt;&gt;</vh>
<v t="ekr.20060214172823.3"><vh>&lt;&lt; define dict of Tk bind names &gt;&gt;</vh></v>
<v t="ekr.20060214172823.4"><vh>&lt;&lt; define dict of special names &gt;&gt;</vh></v>
</v>
<v t="ekr.20060214172823.5"><vh>&lt;&lt; synthesize the shortcuts from the information &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060216110502"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
<v t="ekr.20060128092340"><vh>Shortcuts (keyHandler)</vh>
<v t="ekr.20060120071949"><vh>isPlainKey</vh></v>
<v t="ekr.20060128081317"><vh>shortcutFromSetting</vh>
<v t="ekr.20060201065809"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060215104239"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060128103640.1"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060128103640.2"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060128103640.4"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20060126163152.2"><vh>k.strokeFromEvent</vh></v>
<v t="ekr.20060131075440"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060201083154"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20050920085536.62"><vh>getArg</vh>
<v t="ekr.20050928092516"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
<v t="ekr.20051125080855"><vh>selfInsertCommand</vh>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
</v>
<v t="ekr.20050920085536.41"><vh>fullCommand (alt-x) &amp; helper</vh>
<v t="ekr.20050920085536.45"><vh>callAltXFunction</vh></v>
</v>
</v>
</v>
<v t="ekr.20060216071129"><vh>4.4 a6 projects</vh>
<v t="ekr.20060216120335"><vh>What I did</vh></v>
<v t="ekr.20060216093552"><vh>Added support for trace_minibuffer setting</vh>
<v t="ekr.20050924064254"><vh>Label...</vh>
<v t="ekr.20060125175103"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20051023132350"><vh>getLabel</vh></v>
<v t="ekr.20051023132350.2"><vh>protectLabel</vh></v>
<v t="ekr.20050920085536.37"><vh>resetLabel</vh></v>
<v t="ekr.20051023132350.1"><vh>setLabel</vh></v>
<v t="ekr.20060206064635"><vh>extendLabel</vh></v>
<v t="ekr.20050920085536.36"><vh>setLabelBlue</vh></v>
<v t="ekr.20050920085536.35"><vh>setLabelGrey</vh></v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
<v t="ekr.20060210141604.1"><vh>getEditableTextRange</vh></v>
</v>
</v>
<v t="ekr.20060216071953"><vh>Bind to strokes, not commands</vh>
<v t="ekr.20060216070014"><vh>Key report 1</vh></v>
<v t="ekr.20060216065048"><vh>Key report  2 (and bug report)</vh></v>
<v t="ekr.20060215150236"><vh>Handle num-lock key properly</vh></v>
<v t="ekr.20060216070841"><vh>Calls to bind: no change</vh>
<v t="ekr.20060203114017"><vh>f.setMinibufferBindings</vh></v>
<v t="ekr.20031218072017.838"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh>
<v t="ekr.20060131173440"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
<v t="ekr.20060131173440.2"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051025071455.22"><vh>createSpellTab</vh>
<v t="ekr.20051113090322"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051025071455.23"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20051025071455.24"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025120920"><vh>createBindings (spellTab)</vh></v>
</v>
<v t="ekr.20051006125633"><vh>Binding (keyHandler)</vh>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20060114115648"><vh>&lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;</vh></v>
<v t="ekr.20060114110141"><vh>&lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;</vh></v>
</v>
<v t="ekr.20060130093055"><vh>bindKeyToDict</vh></v>
<v t="ekr.20051008135051.1"><vh>bindOpenWith</vh></v>
<v t="ekr.20051011103654"><vh>checkBindings</vh></v>
<v t="ekr.20060216074643"><vh>k.completeAllBindings</vh>
<v t="ekr.20060221141535"><vh>completeAllBindingsForWidget</vh></v>
</v>
<v t="ekr.20051007080058"><vh>k.makeAllBindings</vh></v>
<v t="ekr.20060104154937"><vh>addModeCommands</vh></v>
<v t="ekr.20051008152134"><vh>initSpecialIvars</vh></v>
<v t="ekr.20051008134059"><vh>makeBindingsFromCommandsDict</vh></v>
</v>
<v t="ekr.20060128092340"><vh>Shortcuts (keyHandler)</vh>
<v t="ekr.20060120071949"><vh>isPlainKey</vh></v>
<v t="ekr.20060128081317"><vh>shortcutFromSetting</vh>
<v t="ekr.20060201065809"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060215104239"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060128103640.1"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060128103640.2"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060128103640.4"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
<v t="ekr.20060126163152.2"><vh>k.strokeFromEvent</vh></v>
<v t="ekr.20060131075440"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060201083154"><vh>k.prettyPrintKey</vh></v>
</v>
<v t="ekr.20050920084036.113"><vh>replaceString</vh></v>
<v t="ekr.20050920085536.62"><vh>getArg</vh>
<v t="ekr.20050928092516"><vh>&lt;&lt; init altX vars &gt;&gt;</vh></v>
</v>
<v t="ekr.20060128090219"><vh>masterMenuHandler</vh></v>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20031218072017.1723"><vh>createMenuEntries</vh>
<v t="ekr.20051021091958"><vh>&lt;&lt; get label &amp; command or continue &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1725"><vh>&lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;</vh>
<v t="ekr.20051021100806.1"><vh>&lt;&lt; compute emacs_name &gt;&gt;</vh></v>
</v>
<v t="ekr.20060216110502"><vh>&lt;&lt; clear accelerator if it is a plain key &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060216115304"><vh>Fixed crasher in k.masterCommand</vh>
<v t="ekr.20060216115304.1"><vh>Report</vh></v>
<v t="ekr.20050920085536.65"><vh>masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
</v>
<v t="ekr.20060216115304.2"><vh>g.safeStringCompare &amp; test</vh></v>
</v>
<v t="ekr.20060215055823"><vh>Arrow keys no longer destroy UNL line</vh>
<v t="ekr.20060216134253"><vh>Report</vh></v>
<v t="ekr.20050924064254"><vh>Label...</vh>
<v t="ekr.20060125175103"><vh>k.minibufferWantsFocus/Now</vh></v>
<v t="ekr.20051023132350"><vh>getLabel</vh></v>
<v t="ekr.20051023132350.2"><vh>protectLabel</vh></v>
<v t="ekr.20050920085536.37"><vh>resetLabel</vh></v>
<v t="ekr.20051023132350.1"><vh>setLabel</vh></v>
<v t="ekr.20060206064635"><vh>extendLabel</vh></v>
<v t="ekr.20050920085536.36"><vh>setLabelBlue</vh></v>
<v t="ekr.20050920085536.35"><vh>setLabelGrey</vh></v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
<v t="ekr.20060210141604.1"><vh>getEditableTextRange</vh></v>
</v>
<v t="ekr.20041223104933"><vh>class statusLineClass</vh>
<v t="ekr.20031218072017.3961"><vh> ctor</vh></v>
<v t="ekr.20031218072017.3962"><vh>clear</vh></v>
<v t="EKR.20040424153344"><vh>enable, disable &amp; isEnabled</vh></v>
<v t="ekr.20041026132435"><vh>get</vh></v>
<v t="ekr.20041223114744"><vh>getFrame</vh></v>
<v t="ekr.20050120093555"><vh>onActivate</vh></v>
<v t="ekr.20041223111916"><vh>pack &amp; show</vh></v>
<v t="ekr.20031218072017.3963"><vh>put (leoTkinterFrame:statusLineClass)</vh></v>
<v t="ekr.20041223111916.1"><vh>unpack &amp; hide</vh></v>
<v t="ekr.20031218072017.1733"><vh>update</vh></v>
</v>
<v t="ekr.20040803072955.126"><vh>tree.endEditLabel</vh></v>
</v>
</v>
<v t="ekr.20060218075614"><vh>4.4 a7 projects</vh>
<v t="ekr.20060221073409"><vh>Bugs</vh>
<v t="ekr.20060218071531"><vh>Fixed binding bug</vh>
<v t="ekr.20060218075614.1"><vh>R</vh></v>
<v t="ekr.20060216074643"><vh>k.completeAllBindings</vh>
<v t="ekr.20060221141535"><vh>completeAllBindingsForWidget</vh></v>
</v>
<v t="ekr.20060131075440"><vh>k.tkbindingFromStroke</vh></v>
<v t="ekr.20060128081317"><vh>shortcutFromSetting</vh>
<v t="ekr.20060201065809"><vh>&lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;</vh></v>
<v t="ekr.20060215104239"><vh>&lt;&lt; swap cmd and ctrl keys &gt;&gt;</vh></v>
<v t="ekr.20060128103640.1"><vh>&lt;&lt; convert minus signs to plus signs &gt;&gt;</vh></v>
<v t="ekr.20060128103640.2"><vh>&lt;&lt; compute the last field &gt;&gt;</vh></v>
<v t="ekr.20060128103640.4"><vh>&lt;&lt; compute shortcut &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060221073238"><vh>Fixed bug in open-find-dialog</vh></v>
</v>
<v t="ekr.20051126122638"><vh>Finish autocompletion</vh>
<v t="ekr.20060216135646"><vh>To do</vh></v>
<v t="ekr.20060222083704"><vh>What I did</vh></v>
<v t="ekr.20060219183519"><vh>Ref code</vh>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
<v t="ekr.20050920084036.173"><vh>getPublicCommands (keyHandler)</vh></v>
<v t="ekr.20060221112937"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20060223124014"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20060223124014.2"><vh>completeSelf</vh></v>
<v t="ekr.20060223124014.3"><vh>completeFromObject</vh></v>
</v>
</v>
<v t="ekr.20051126123249"><vh>class autoCompleterClass</vh>
<v t="ekr.20051126123759.1"><vh> ctor (autocompleter)</vh>
<v t="ekr.20060223085549"><vh>defineClassesDict</vh></v>
<v t="ekr.20060219171914"><vh>defineObjectDict</vh></v>
</v>
<v t="ekr.20060219103046"><vh>Top level</vh>
<v t="ekr.20051126122952.1"><vh>autoComplete</vh></v>
<v t="ekr.20060219103822"><vh>autoCompleteForce</vh></v>
<v t="ekr.20060219170612"><vh>enable/disableAutocompleter/Calltips</vh></v>
<v t="ekr.20060219103046.1"><vh>showCalltips</vh></v>
<v t="ekr.20060219170043"><vh>showCalltipsForce</vh></v>
<v t="ekr.20051126124705"><vh>autoCompleterStateHandler</vh></v>
</v>
<v t="ekr.20060216160332.2"><vh>Helpers</vh>
<v t="ekr.20051127105431"><vh>abort &amp; exit</vh></v>
<v t="ekr.20060219180034"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20060221131304"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20060220110302"><vh>calltip</vh></v>
<v t="ekr.20060220085402"><vh>chain</vh></v>
<v t="ekr.20051126123149"><vh>computeCompletionList</vh></v>
<v t="ekr.20051126131103"><vh>doBackSpace</vh></v>
<v t="ekr.20051126123249.1"><vh>doTabCompletion</vh></v>
<v t="ekr.20051127065601"><vh>extendSelection</vh></v>
<v t="ekr.20060221104137"><vh>findAnchor</vh></v>
<v t="ekr.20051127105102"><vh>finish</vh></v>
<v t="ekr.20060223081914"><vh>getAttr and hasAttr</vh></v>
<v t="ekr.20060219111416"><vh>getLeadinWord</vh></v>
<v t="ekr.20060219174642"><vh>getMembersList</vh></v>
<v t="ekr.20060220055415"><vh>getModulesList (not used)</vh></v>
<v t="ekr.20060220132026"><vh>info</vh>
<v t="ekr.20060220132919"><vh>prettyPrintDoc</vh></v>
</v>
<v t="ekr.20060220104902"><vh>insertNormalChar</vh></v>
<v t="ekr.20060222092243"><vh>push, pop, clear, stackNames</vh></v>
<v t="ekr.20060221112937"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20060223124014"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20060223124014.2"><vh>completeSelf</vh></v>
<v t="ekr.20060223124014.3"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20051127070018"><vh>setSelection</vh></v>
<v t="ekr.20060220062710"><vh>start</vh></v>
</v>
<v t="ekr.20060216160332.1"><vh>Scanning</vh>
<v t="ekr.20060217132329"><vh>initialScan</vh></v>
<v t="ekr.20060216155558.1"><vh>scan</vh></v>
<v t="ekr.20060216163305"><vh>definePatterns</vh></v>
<v t="ekr.20060216161220"><vh>scanOutline</vh></v>
<v t="ekr.20060216161234"><vh>scanForCallTip</vh></v>
<v t="ekr.20060216161247"><vh>scanForAutoCompleter</vh>
<v t="ekr.20051025144611.20"><vh>makeAutocompletionList</vh>
<v t="ekr.20060216161258"><vh>reverseFindWhitespace</vh></v>
<v t="ekr.20060216161253"><vh>getCleanString</vh></v>
</v>
</v>
</v>
<v t="ekr.20060223114802"><vh>Proxy classes and objects</vh>
<v t="ekr.20060223114802.1"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20060223093358"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20060223093117"><vh>class forgivingParserClass</vh>
<v t="ekr.20060223093117.1"><vh>ctor (forgivingParserClass)</vh></v>
<v t="ekr.20060223093117.2"><vh>parse</vh></v>
<v t="ekr.20060223093117.3"><vh>forgivingParser</vh></v>
<v t="ekr.20060223093117.4"><vh>computeErrorNode</vh></v>
<v t="ekr.20060223093117.5"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20060222082041"><vh>class classScannerClass</vh>
<v t="ekr.20060222082041.1"><vh>ctor</vh></v>
<v t="ekr.20060223120755"><vh>parse</vh></v>
<v t="ekr.20060222082041.2"><vh>findParentClass</vh></v>
<v t="ekr.20060222082041.3"><vh>findClass &amp; helpers</vh>
<v t="ekr.20060222082041.4"><vh>endsDoc</vh></v>
<v t="ekr.20060222082041.5"><vh>startsClass</vh></v>
<v t="ekr.20060222082041.6"><vh>startsDoc</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20060116073938"><vh>To do 4.4 a7</vh>
<v t="ekr.20060220153557"><vh>Make sure focus doesn't get ripped from find/change text areas</vh></v>
<v t="ekr.20060219172026"><vh>Dialogs must get grab focus and keystrokes</vh></v>
<v t="ekr.20060220155313"><vh>update-leo-settings-file</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20031218072017.3093"
marks="ekr.20031218072017.2052,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20051022142249,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
</v>
<v t="ekr.20051126122638" a="V"><vh>Finish autocompletion</vh>
<v t="ekr.20060216135646"><vh>To do</vh></v>
<v t="ekr.20060222083704"><vh>What I did</vh></v>
<v t="ekr.20060219183519"><vh>Ref code</vh>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
<v t="ekr.20050920084036.173"><vh>getPublicCommands (keyHandler)</vh></v>
<v t="ekr.20060221112937"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20060223124014"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20060223124014.2"><vh>completeSelf</vh></v>
<v t="ekr.20060223124014.3"><vh>completeFromObject</vh></v>
</v>
</v>
<v t="ekr.20051126123249"><vh>class autoCompleterClass</vh>
<v t="ekr.20051126123759.1"><vh> ctor (autocompleter)</vh>
<v t="ekr.20060223085549"><vh>defineClassesDict</vh></v>
<v t="ekr.20060219171914"><vh>defineObjectDict</vh></v>
</v>
<v t="ekr.20060219103046"><vh>Top level</vh>
<v t="ekr.20051126122952.1"><vh>autoComplete</vh></v>
<v t="ekr.20060219103822"><vh>autoCompleteForce</vh></v>
<v t="ekr.20060219170612"><vh>enable/disableAutocompleter/Calltips</vh></v>
<v t="ekr.20060219103046.1"><vh>showCalltips</vh></v>
<v t="ekr.20060219170043"><vh>showCalltipsForce</vh></v>
<v t="ekr.20051126124705"><vh>autoCompleterStateHandler</vh></v>
</v>
<v t="ekr.20060216160332.2"><vh>Helpers</vh>
<v t="ekr.20051127105431"><vh>abort &amp; exit</vh></v>
<v t="ekr.20060219180034"><vh>append/begin/popTabName</vh></v>
<v t="ekr.20060221131304"><vh>appendToKnownObjects</vh></v>
<v t="ekr.20060220110302"><vh>calltip</vh></v>
<v t="ekr.20060220085402"><vh>chain</vh></v>
<v t="ekr.20051126123149"><vh>computeCompletionList</vh></v>
<v t="ekr.20051126131103"><vh>doBackSpace</vh></v>
<v t="ekr.20051126123249.1"><vh>doTabCompletion</vh></v>
<v t="ekr.20051127065601"><vh>extendSelection</vh></v>
<v t="ekr.20060221104137"><vh>findAnchor</vh></v>
<v t="ekr.20051127105102"><vh>finish</vh></v>
<v t="ekr.20060223081914"><vh>getAttr and hasAttr</vh></v>
<v t="ekr.20060219111416"><vh>getLeadinWord</vh></v>
<v t="ekr.20060219174642"><vh>getMembersList</vh></v>
<v t="ekr.20060220055415"><vh>getModulesList (not used)</vh></v>
<v t="ekr.20060220132026"><vh>info</vh>
<v t="ekr.20060220132919"><vh>prettyPrintDoc</vh></v>
</v>
<v t="ekr.20060220104902"><vh>insertNormalChar</vh></v>
<v t="ekr.20060222092243"><vh>push, pop, clear, stackNames</vh></v>
<v t="ekr.20060221112937"><vh>setObjectAndMembersList &amp; helpers</vh>
<v t="ekr.20060223124014"><vh>getObjectFromAttribute</vh></v>
<v t="ekr.20060223124014.2"><vh>completeSelf</vh></v>
<v t="ekr.20060223124014.3"><vh>completeFromObject</vh></v>
</v>
<v t="ekr.20051127070018"><vh>setSelection</vh></v>
<v t="ekr.20060220062710"><vh>start</vh></v>
</v>
<v t="ekr.20060216160332.1"><vh>Scanning</vh>
<v t="ekr.20060217132329"><vh>initialScan</vh></v>
<v t="ekr.20060216155558.1"><vh>scan</vh></v>
<v t="ekr.20060216163305"><vh>definePatterns</vh></v>
<v t="ekr.20060216161220"><vh>scanOutline</vh></v>
<v t="ekr.20060216161234"><vh>scanForCallTip</vh></v>
<v t="ekr.20060216161247"><vh>scanForAutoCompleter</vh>
<v t="ekr.20051025144611.20"><vh>makeAutocompletionList</vh>
<v t="ekr.20060216161258"><vh>reverseFindWhitespace</vh></v>
<v t="ekr.20060216161253"><vh>getCleanString</vh></v>
</v>
</v>
</v>
<v t="ekr.20060223114802"><vh>Proxy classes and objects</vh>
<v t="ekr.20060223114802.1"><vh>createProxyObjectFromClass</vh></v>
<v t="ekr.20060223093358"><vh>createClassObjectFromString</vh></v>
</v>
<v t="ekr.20060223093117"><vh>class forgivingParserClass</vh>
<v t="ekr.20060223093117.1"><vh>ctor (forgivingParserClass)</vh></v>
<v t="ekr.20060223093117.2"><vh>parse</vh></v>
<v t="ekr.20060223093117.3"><vh>forgivingParser</vh></v>
<v t="ekr.20060223093117.4"><vh>computeErrorNode</vh></v>
<v t="ekr.20060223093117.5"><vh>newPutBody</vh></v>
</v>
<v t="ekr.20060222082041"><vh>class classScannerClass</vh>
<v t="ekr.20060222082041.1"><vh>ctor</vh></v>
<v t="ekr.20060223120755"><vh>parse</vh></v>
<v t="ekr.20060222082041.2"><vh>findParentClass</vh></v>
<v t="ekr.20060222082041.3"><vh>findClass &amp; helpers</vh>
<v t="ekr.20060222082041.4"><vh>endsDoc</vh></v>
<v t="ekr.20060222082041.5"><vh>startsClass</vh></v>
<v t="ekr.20060222082041.6"><vh>startsDoc</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040424153344">def disable (self,background=None):
    
    c = self.c ; t = self.textWidget
    if t:
        if not background:
            background = self.statusFrame.cget("background")
        t.configure(state="disabled",background=background)
    self.enabled = False
    c.bodyWantsFocus()
    
def enable (self,background="white"):
    
    # g.trace()
    c = self.c ; t = self.textWidget
    if t:
        t.configure(state="normal",background=background)
        c.widgetWantsFocus(t)
    self.enabled = True
        
def isEnabled(self):
    return self.enabled</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.838">def createBindings (self):

    '''(tkBody) Create gui-dependent bindings.
    These are *not* made in nullBody instances.'''
    
    frame = self.frame ; c = self.c ; k = c.k ; t = self.bodyCtrl
    
    t.bind('&lt;Key&gt;', k.masterKeyHandler)

    for kind,func,handler in (
        ('&lt;Button-1&gt;',  frame.OnBodyClick,          k.masterClickHandler),
        ('&lt;Button-3&gt;',  frame.OnBodyRClick,         k.masterClick3Handler),
        ('&lt;Double-1&gt;',  frame.OnBodyDoubleClick,    k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',  None,                       k.masterDoubleClick3Handler),
    ):
        def bodyClickCallback(event,handler=handler,func=func):
            return handler(event,func)

        t.bind(kind,bodyClickCallback)
            
    if sys.platform.startswith('win'):
        # Support Linux middle-button paste easter egg.
        t.bind("&lt;Button-2&gt;",frame.OnPaste)</t>
<t tx="ekr.20031218072017.998">def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20031218072017.1723">def createMenuEntries (self,menu,table,dynamicMenu=False):
        
    '''Create a menu entry from the table.
    New in 4.4: this method shows the shortcut in the menu,
    but this method **never** binds any shortcuts.'''
    
    c = self.c ; f = c.frame ; k = c.k
    if g.app.unitTesting: return
    for data in table:
        &lt;&lt; get label &amp; command or continue &gt;&gt;
        &lt;&lt; compute commandName &amp; accel from label &amp; command &gt;&gt;
        accelerator = stroke = k.shortcutFromSetting(accel) or ''
        accelerator = accelerator and k.prettyPrintKey(accelerator).lstrip('&lt;').rstrip('&gt;')
        def masterMenuCallback (k=k,stroke=stroke,command=command,commandName=commandName):
            return k.masterMenuHandler(stroke,command,commandName)
        realLabel = self.getRealMenuName(label)
        amp_index = realLabel.find("&amp;")
        realLabel = realLabel.replace("&amp;","")
        if sys.platform == 'darwin':
            &lt;&lt; clear accelerator if it is a plain key &gt;&gt;
        self.add_command(menu,label=realLabel,
            accelerator=accelerator,
            command=masterMenuCallback,
            underline=amp_index)</t>
<t tx="ekr.20031218072017.1725"># New in 4.4b2: command can be a minibuffer-command name (a string)
minibufferCommand = type(command) == type('')
accel = None
if minibufferCommand:
    commandName = command 
    command = c.commandsDict.get(commandName)
    if command:
        rawKey,bunchList = c.config.getShortcut(commandName)
        # Pick the first entry that is not a mode.
        for bunch in bunchList:
            if not bunch.pane.endswith('-mode'):
                # g.trace('1',bunch)
                accel = bunch and bunch.val ; break
    else:
        g.trace('No inverse for %s' % commandName)
        continue # There is no way to make this menu entry.
else:
    # First, get the old-style name.
    commandName = self.computeOldStyleShortcutKey(label)
    rawKey,bunchList = c.config.getShortcut(commandName)
    for bunch in bunchList:
        if not bunch.pane.endswith('-mode'):
            # g.trace('2',bunch)
            accel = bunch and bunch.val ; break
    # Second, get new-style name.
    if not accel:
        &lt;&lt; compute emacs_name &gt;&gt;
            # Contains the not-so-horrible kludge.
        if emacs_name:
            commandName = emacs_name
            rawKey,bunchList = c.config.getShortcut(emacs_name)
            # Pick the first entry that is not a mode.
            for bunch in bunchList:
                if not bunch.pane.endswith('-mode'):
                    accel = bunch.val ; break
                    # g.trace('2',bunch)
        elif not dynamicMenu:
            g.trace('No inverse for %s' % commandName)</t>
<t tx="ekr.20031218072017.1733">def update (self):
    
    c = self.c ; w = self.bodyCtrl ; lab = self.labelWidget
    if g.app.killed or not self.isVisible:
        return

    index = w.index("insert")
    row,col = g.app.gui.getindex(w,index)

    if col &gt; 0:
        s = w.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth (s,c.tab_width)

    if 1: # row != self.lastRow or col != self.lastCol:
        s = "line %d, col %d " % (row,col)
        # Important: this does not change the focus because labels never get focus.
        lab.configure(text=s)
        self.lastRow = row
        self.lastCol = col</t>
<t tx="ekr.20031218072017.1801">def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    self.trace_status_line = None # Set in finishCreate.
    &lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</t>
<t tx="ekr.20031218072017.1802"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None</t>
<t tx="ekr.20031218072017.1974">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20031218072017.1975">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)</t>
<t tx="ekr.20031218072017.1976"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="ekr.20031218072017.2176">def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    self.trace_status_line = c.config.getBool('trace_status_line')
    # f.enableTclTraces()</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.3353">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""
    
    v = self
    
    h = g.toUnicode(v.headString(),'utf-8')
    h = h.lower().replace(' ','').replace('\t','')

    pattern = g.toUnicode(pattern,'utf-8')
    pattern = pattern.lower().replace(' ','').replace('\t','')
    
    return h.startswith(pattern)</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3941"></t>
<t tx="ekr.20031218072017.3942">def __repr__ (self):

    return "&lt;leoTkinterFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20031218072017.3944">def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas</t>
<t tx="ekr.20031218072017.3946">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        &lt;&lt; resize the Pmw panes &gt;&gt;
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20031218072017.3947">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="ekr.20031218072017.3949"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="ekr.20031218072017.3950"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20031218072017.3951">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="ekr.20031218072017.3952">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="ekr.20031218072017.3961">def __init__ (self,c,parentFrame):
    
    self.c = c
    self.bodyCtrl = c.frame.bodyCtrl
    self.colorTags = [] # list of color names used as tags.
    self.enabled = False
    self.isVisible = False
    self.lastRow = self.lastCol = 0
    self.log = c.frame.log
    #if 'black' not in self.log.colorTags:
    #    self.log.colorTags.append("black")
    self.parentFrame = parentFrame
    self.statusFrame = Tk.Frame(parentFrame,bd=2)
    text = "line 0, col 0"
    width = len(text) + 4
    self.labelWidget = Tk.Label(self.statusFrame,text=text,width=width,anchor="w")
    self.labelWidget.pack(side="left",padx=1)
    
    bg = self.statusFrame.cget("background")
    self.textWidget = Tk.Text(self.statusFrame,
        height=1,state="disabled",bg=bg,relief="groove",name='status-line')
    self.textWidget.pack(side="left",expand=1,fill="x")
    self.textWidget.bind("&lt;Button-1&gt;", self.onActivate)</t>
<t tx="ekr.20031218072017.3962">def clear (self):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(g.callers())
    
    t.configure(state="normal")
    t.delete("1.0","end")
    t.configure(state="disabled")</t>
<t tx="ekr.20031218072017.3963">def put(self,s,color=None):
    
    t = self.textWidget
    if not t: return
    
    trace = self.c.frame.trace_status_line and not g.app.unitTesting
    if trace: g.trace(s,g.callers())
    
    t.configure(state="normal")
        
    if color and color not in self.colorTags:
        self.colorTags.append(color)
        t.tag_config(color,foreground=color)

    if color:
        t.insert("end",s)
        t.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
        t.tag_config("black",foreground="black")
        t.tag_add("black","end")
    else:
        t.insert("end",s)
    
    t.configure(state="disabled")
    t.update_idletasks()</t>
<t tx="ekr.20031218072017.3964"></t>
<t tx="ekr.20031218072017.3965">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 a6, build %s, February 17, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.416 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040709081208"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)</t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20040803072955.126">def endEditLabel (self):
    
    '''End editing of a headline and update p.headString().'''

    c = self.c ; k = c.k ; p = c.currentPosition()

    self.setEditPosition(None) # That is, self._editPosition = None
    
    if k:
        k.setDefaultUnboundKeyAction()
        # k.showStateAndMode() # Destroys UNL info.
    
    # Important: this will redraw if necessary.
    self.onHeadChanged(p)</t>
<t tx="ekr.20041026132435">def get (self):
    
    t = self.textWidget
    if t:
        return t.get("1.0","end")
    else:
        return ""</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041221071131">def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas</t>
<t tx="ekr.20041221071131.1">def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 0:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20041221073427">def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame</t>
<t tx="ekr.20041221073427.1">def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2</t>
<t tx="ekr.20041221075743">@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)</t>
<t tx="ekr.20041221122440">def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()</t>
<t tx="ekr.20041221123325">def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        &lt;&lt; create Pmw splitters and their components &gt;&gt;
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="ekr.20041221185246">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.</t>
<t tx="ekr.20041221195402"></t>
<t tx="ekr.20041223104933">class statusLineClass:
    
    '''A class representing the status line.'''
    
    @others</t>
<t tx="ekr.20041223111916">def pack (self):
    
    if not self.isVisible:
        self.isVisible = True
        self.statusFrame.pack(fill="x",pady=1)
        
show = pack</t>
<t tx="ekr.20041223111916.1">def unpack (self):
    
    if self.isVisible:
        self.isVisible = False
        self.statusFrame.pack_forget()

hide = unpack</t>
<t tx="ekr.20041223114744">def getFrame (self):
    
    return self.statusFrame</t>
<t tx="ekr.20041223130032"># Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20050104084531">self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))</t>
<t tx="ekr.20050119210541"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)</t>
<t tx="ekr.20050120093555">def onActivate (self,event=None):
    
    # Don't change background as the result of simple mouse clicks.
    background = self.statusFrame.cget("background")
    self.enable(background=background)</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050920084036.113">def replaceString (self,event):

    k = self.k ; tag = 'replace-string' ; state = k.getState(tag)
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')
    if state == 0:
        self.setupArgs(forward=None,regexp=None,word=None)
        prefix = '%s: ' % prompt
        self.stateZeroHelper(event,tag,prefix,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        self.addChangeStringToLabel()
        k.getArg(event,'replace-string',2,self.replaceString,completion=False,prefix=s)
    elif state == 2:
        self.lastStateHelper()
        self.generalChangeHelper(self._sString,k.arg)</t>
<t tx="ekr.20050920084036.173">def getPublicCommands (self):
    
    k = self.k
    
    return {
        'auto-complete':            k.autoCompleter.autoComplete,
        'auto-complete-force':      k.autoCompleter.autoCompleteForce,
        'digit-argument':           k.digitArgument,
        'disable-auto-completer-command':   k.autoCompleter.disableAutocompleter,
        'disable-calltips-command':         k.autoCompleter.disableCalltips,
        'enable-auto-completer-command':    k.autoCompleter.enableAutocompleter,
        'enable-calltips-command':          k.autoCompleter.enableCalltips,
        'exit-named-mode':          k.exitNamedMode,
        'full-command':             k.fullCommand, # For menu.
        'hide-mini-buffer':         k.hideMinibuffer,
        'mode-help':                k.modeHelp,
        'negative-argument':        k.negativeArgument,
        'number-command':           k.numberCommand,
        'number-command-0':         k.numberCommand0,
        'number-command-1':         k.numberCommand1,
        'number-command-2':         k.numberCommand2,
        'number-command-3':         k.numberCommand3,
        'number-command-4':         k.numberCommand4,
        'number-command-5':         k.numberCommand5,
        'number-command-6':         k.numberCommand6,
        'number-command-7':         k.numberCommand7,
        'number-command-8':         k.numberCommand8,
        'number-command-9':         k.numberCommand9,
        'print-bindings':           k.printBindings,
        'print-commands':           k.printCommands,
        'repeat-complex-command':   k.repeatComplexCommand,
        # 'scan-for-autocompleter':   k.autoCompleter.scan,
        'set-ignore-state':         k.setIgnoreState,
        'set-insert-state':         k.setInsertState,
        'set-overwrite-state':      k.setOverwriteState,
        'show-calltips':            k.autoCompleter.showCalltips,
        'show-calltips-force':      k.autoCompleter.showCalltipsForce,
        'show-mini-buffer':         k.showMinibuffer,
        'toggle-mini-buffer':       k.toggleMinibuffer,
        'universal-argument':       k.universalArgument,
    }</t>
<t tx="ekr.20050920085536.1"></t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    
    self.enable_autocompleter           = c.config.getBool('enable_autocompleter')
    self.enable_calltips                = c.config.getBool('enable_calltips')
    self.ignore_caps_lock               = c.config.getBool('ignore_caps_lock')
    self.ignore_unbound_non_ascii_keys  = c.config.getBool('ignore_unbound_non_ascii_keys')
    self.swap_mac_keys                  = c.config.getBool('swap_mac_keys')
    self.trace_key_event                = c.config.getBool('trace_key_event')
    self.trace_minibuffer               = c.config.getBool('trace_minibuffer')
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;
    
    self.autoCompleter = autoCompleterClass(self)</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c

    # g.trace(pane,shortcut,commandName)
    if not shortcut:
        # g.trace('No shortcut for %s' % commandName)
        return False
    if pane.endswith('-mode'):
        g.trace('oops: ignoring mode binding',shortcut,commandName,g.callers())
        return False
    bunchList = k.bindingsDict.get(shortcut,[])
    &lt;&lt; give warning and return if there is a serious redefinition &gt;&gt;
    &lt;&lt; trace bindings if enabled in leoSettings.leo &gt;&gt;
    try:
        k.bindKeyToDict(pane,shortcut,callback,commandName)
        bunchList.append(
            g.bunch(pane=pane,func=callback,commandName=commandName))
        shortcut = shortcut.strip().lstrip('&lt;').rstrip('&gt;')
        # if shortcut.startswith('&lt;Shift'): g.trace('ooops',shortcut,g.callers())
        k.bindingsDict [shortcut] = bunchList
        return True
    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            g.es_exception()
            g.app.menuWarningsGiven = True
        return False
        
bindShortcut = bindKey # For compatibility</t>
<t tx="ekr.20050920085536.35">def setLabelGrey (self,label=None):

    k = self ; w = self.widget
    if not w: return
    
    w.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)

setLabelGray = setLabelGrey</t>
<t tx="ekr.20050920085536.36">def setLabelBlue (self,label=None,protect=False):
    
    k = self ; w = k.widget
    if not w: return
    
    w.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)</t>
<t tx="ekr.20050920085536.37">def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''</t>
<t tx="ekr.20050920085536.38">def updateLabel (self,event):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; c = k.c ; w = self.widget
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    trace = self.trace_minibuffer and not g.app.unitTesting

    if trace: g.trace('ch',ch,'keysym',keysym,'k.stroke',k.stroke)
    
    if ch and ch not in ('\n','\r'):
        if self.useTextWidget:
            c.widgetWantsFocusNow(w)
            i,j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            i = w.index('insert')
            w.insert(i,ch)
            # g.trace(k.mb_prefix)       
        else:
            # Just add the character.
            k.setLabel(k.getLabel() + ch)
</t>
<t tx="ekr.20050920085536.41">def fullCommand (self,event,specialStroke=None,specialFunc=None):
    
    '''Handle 'full-command' (alt-x) mode.'''

    k = self ; c = k.c ; state = k.getState('full-command')
    keysym = (event and event.keysym) or ''
    ch = (event and event.char) or ''
    trace = c.config.getBool('trace_modes')
    if trace: g.trace('state',state,keysym)
    if state == 0:
        k.mb_event = event # Save the full event for later.
        k.setState('full-command',1,handler=k.fullCommand) 
        k.setLabelBlue('%s' % (k.altX_prompt),protect=True)
        # Init mb_ ivars. This prevents problems with an initial backspace.
        k.mb_prompt = k.mb_tabListPrefix = k.mb_prefix = k.altX_prompt
        k.mb_tabList = [] ; k.mb_tabListIndex = -1
        c.minibufferWantsFocus()
    elif keysym == 'Return':
        c.frame.log.deleteTab('Completion')
        k.callAltXFunction(k.mb_event)
    elif keysym == 'Tab':
        k.doTabCompletion(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif keysym == 'BackSpace':
        k.doBackSpace(c.commandsDict.keys())
        c.minibufferWantsFocus()
    elif k.ignore_unbound_non_ascii_keys and len(ch) &gt; 1:
        # g.trace('non-ascii')
        if specialStroke:
            g.trace(specialStroke)
            specialFunc()
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
        c.minibufferWantsFocus()
        # g.trace('new prefix',k.mb_tabListPrefix)

    return 'break'</t>
<t tx="ekr.20050920085536.45">def callAltXFunction (self,event):
    
    k = self ; c = k.c ; s = k.getLabel()
    k.mb_tabList = []
    commandName = s[len(k.mb_prefix):].strip()
    func = c.commandsDict.get(commandName)

    if func:
        # These must be done *after* getting the command.
        k.clearState()
        k.resetLabel()
        if commandName != 'repeat-complex-command':
            k.mb_history.insert(0,commandName)
        c.widgetWantsFocusNow(event.widget) # Important, so cut-text works, e.g.
        func(event)
        k.endCommand(event,commandName)
    else:
        if 1: # Useful.
            k.doTabCompletion(c.commandsDict.keys())
        else: # Annoying.
            k.keyboardQuit(event)
            k.setLabel('Command does not exist: %s' % commandName)
            c.bodyWantsFocus()</t>
<t tx="ekr.20050920085536.62">def getArg (self,event,
    returnKind=None,returnState=None,handler=None,
    prefix=None,tabList=None,completion=True):
    
    '''Accumulate an argument until the user hits return (or control-g).
    Enter the given return state when done.
    The prefix is does not form the arg.  The prefix defaults to the k.getLabel().
    '''

    k = self ; c = k.c ; state = k.getState('getArg')
    keysym = (event and event.keysym) or ''
    trace = c.config.getBool('trace_modes') and not g.app.unitTesting
    if trace: g.trace(
        'state',state,'keysym',keysym,
        'completion', state==0 and completion or state!=0 and k.arg_completion)
    if state == 0:
        k.arg = '' ; k.arg_completion = completion
        if tabList: k.argTabList = tabList[:]
        else:       k.argTabList = []
        &lt;&lt; init altX vars &gt;&gt;
        # Set the states.
        bodyCtrl = c.frame.body.bodyCtrl
        c.widgetWantsFocus(bodyCtrl)
        k.afterGetArgState=returnKind,returnState,handler
        k.setState('getArg',1,k.getArg)
        k.afterArgWidget = event and event.widget or c.frame.body.bodyCtrl
        if k.useTextWidget: c.minibufferWantsFocus()
    elif keysym == 'Return':
        k.arg = k.getLabel(ignorePrompt=True)
        kind,n,handler = k.afterGetArgState
        if kind: k.setState(kind,n,handler)
        c.frame.log.deleteTab('Completion')
        if trace: g.trace('kind',kind,'n',n,'handler',handler and handler.__name__)
        if handler: handler(event)
    elif keysym == 'Tab':
        k.doTabCompletion(k.argTabList,k.arg_completion)
    elif keysym == 'BackSpace':
        k.doBackSpace(k.argTabList,k.arg_completion)
        c.minibufferWantsFocus()
    else:
        # Clear the list, any other character besides tab indicates that a new prefix is in effect.
        k.mb_tabList = []
        k.updateLabel(event)
        k.mb_tabListPrefix = k.getLabel()
    return 'break'</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke,commandName=None):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    c.setLog()
    trace = c.config.getBool('trace_masterCommand')
  
    c.startRedrawCount = c.frame.tree.redrawCount
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym or ''
    ch = event and event.char or ''
    w = event and event.widget
    state = event and hasattr(event,'state') and event.state or 0
    k.func = func
    k.funcReturn = None # For unit testing.
    commandName = commandName or func and func.__name__ or '&lt;no function&gt;'
    special = keysym in (
        'Caps_Lock','Num_Lock','Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func is not None

    if trace and interesting:
        g.trace(
            # 'stroke: ',stroke,'state:','%x' % state,'ch:',repr(ch),'keysym:',repr(keysym),
            'w:',w and c.widget_name(w),'func:',func and func.__name__
        )

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=keysym))

    if inserted:
        # g.trace(stroke,keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if k.abortAllModesKey and g.safeStringCompare(stroke,k.abortAllModesKey): # 'Control-g'
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'
        
    if special: # Don't pass these on.
        return 'break' 

    if 0: # *** This is now handled by k.masterKeyHandler.
        if k.inState():
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-func': return 'break'
            g.trace('Executing key outside of mode')

    if k.regx.iter:
        try:
            k.regXKey = keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        if trace: g.trace('command',commandName)
        if commandName.startswith('specialCallback'):
            # The callback function will call c.doCommand
            val = func(event)
            # k.simulateCommand uses k.funcReturn.
            k.funcReturn = k.funcReturn or val # For unit tests.
        else:
            # Call c.doCommand directly
            c.doCommand(func,commandName,event=event)
        k.endCommand(event,commandName)
        return 'break'
    elif k.inState():
        return 'break' # New in 4.4b2: ignore unbound keys in a state.
    else:
        val = k.handleDefaultChar(event)
        return val</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.
k.keysymHistory.insert(0,keysym)

if len(ch) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,ch)

if 0: # traces
    g.trace(keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.state.kind)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20050923213858">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_event = None
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}</t>
<t tx="ekr.20050924064254">@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.

trace = self.trace_minibuffer and not g.app.unitTesting</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20050928092516"># Clear the list, any other character besides tab indicates that a new prefix is in effect.
k.mb_tabList = []

if prefix:
    k.mb_tabListPrefix = prefix
    k.mb_prefix = prefix
    k.mb_prompt = prefix
else:
    k.mb_tabListPrefix = k.mb_prefix = k.getLabel()
    k.mb_prompt = ''</t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20051006125633"></t>
<t tx="ekr.20051007080058">def makeAllBindings (self):
    
    k = self ; c = k.c

    k.bindingsDict = {}
    
    k.addModeCommands() 
    k.makeBindingsFromCommandsDict()
    k.initSpecialIvars()
    c.frame.body.createBindings()
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    c.frame.setMinibufferBindings()
    k.completeAllBindings()
    k.checkBindings()</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())</t>
<t tx="ekr.20051008134059">def makeBindingsFromCommandsDict (self):
    
    '''Add bindings for all entries in c.commandDict.'''

    k = self ; c = k.c
    keys = c.commandsDict.keys() ; keys.sort()

    for commandName in keys:
        command = c.commandsDict.get(commandName)
        key, bunchList = c.config.getShortcut(commandName)
        for bunch in bunchList:
            accel = bunch.val ; pane = bunch.pane
            if accel and not pane.endswith('-mode'):
                shortcut = k.shortcutFromSetting(accel)
                k.bindKey(pane,shortcut,command,commandName)</t>
<t tx="ekr.20051008135051.1">def bindOpenWith (self,shortcut,name,data):
    
    '''Make a binding for the Open With command.'''
    
    k = self ; c = k.c
    
    # The first parameter must be event, and it must default to None.
    def openWithCallback(event=None,self=self,data=data):
        __pychecker__ = '--no-argsused' # event must be present.
        return self.c.openWith(data=data)
    
    return k.bindKey('all',shortcut,openWithCallback,'open-with')</t>
<t tx="ekr.20051008152134">def initSpecialIvars (self):
    
    '''Set ivars for special keystrokes from previously-existing bindings.'''

    k = self ; c = k.c ; trace = c.config.getBool('trace_bindings')
    
    for ivar,commandName in (
        ('fullCommandKey',  'full-command'),
        ('abortAllModesKey','keyboard-quit'),
        ('universalArgKey', 'universal-argument'),
    ):
        junk, bunchList = c.config.getShortcut(commandName)
        bunchList = bunchList or [] ; found = False
        for pane in ('text','all'):
            for bunch in bunchList:
                if bunch.pane == pane:
                    stroke = k.strokeFromSetting(bunch.val)
                    if trace: g.trace(commandName,stroke)
                    setattr(k,ivar,stroke) ; found = True ;break
        if not found:
            g.trace('no setting for %s' % commandName)</t>
<t tx="ekr.20051009044751">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
        f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)
        f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
        f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)</t>
<t tx="ekr.20051009044920"># Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()</t>
<t tx="ekr.20051009045208">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()</t>
<t tx="ekr.20051009045300"># Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)</t>
<t tx="ekr.20051011103654">def checkBindings (self):
    
    '''Print warnings if commands do not have any @shortcut entry.
    The entry may be `None`, of course.'''
    
    k = self ; c = k.c
    
    names = c.commandsDict.keys() ; names.sort()
    
    for name in names:
        abbrev = k.abbreviationsDict.get(name)
        key = c.frame.menu.canonicalizeMenuName(abbrev or name)
        key = key.replace('&amp;','')
        if not g.app.config.exists(c,key,'shortcut'):
            if abbrev:
                 g.trace('No shortcut for abbrev %s -&gt; %s = %s' % (
                    name,abbrev,key))
            else:
                g.trace('No shortcut for %s = %s' % (name,key))</t>
<t tx="ekr.20051021091958">ok = (
    type(data) in (type(()), type([])) and
    len(data) in (2,3)
)
    
if ok:
    if len(data) == 2:
        # New in 4.4b2: command can be a minibuffer-command name (a string)
        label,command = data
    else:
        # New in 4.4: we ignore shortcuts bound in menu tables.
        label,junk,command = data
else:
    g.trace('bad data in menu table: %s' % repr(data))
    continue # Ignore bad data
     
if ok and label in (None,'-'):
    self.add_separator(menu)
    continue # That's all.</t>
<t tx="ekr.20051021100806.1">@ One not-so-horrible kludge remains.

The cut/copy/paste commands in the menu tables are not the same as the methods
actually bound to cut/copy/paste-text minibuffer commands, so we must do a bit
of extra translation to discover whether the user has overridden their
bindings.
@c

if command in (f.OnCutFromMenu,f.OnCopyFromMenu,f.OnPasteFromMenu):
    emacs_name = '%s-text' % commandName
else:
    try: # User errors in the table can cause this.
        emacs_name = k.inverseCommandsDict.get(command.__name__)
    except Exception:
        emacs_name = None</t>
<t tx="ekr.20051022162730">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    w = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        w.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        return self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        return self.onClick(event,tabName)
    
    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)
    
    k.completeAllBindingsForWidget(w)</t>
<t tx="ekr.20051023132350">def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    if not w: return ''
    trace = self.trace_minibuffer and not g.app.unitTesting
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        while s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        
    else:
        s = k.svar and k.svar.get()
        
    if trace: g.trace(repr(s))

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

</t>
<t tx="ekr.20051023132350.1">def setLabel (self,s,protect=False):

    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting

    if trace: g.trace(repr(s),g.callers())

    if self.useTextWidget:
        w.delete('1.0','end')
        w.insert('1.0',s)
        c.masterFocusHandler() # Restore to the previously requested focus.
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s</t>
<t tx="ekr.20051023132350.2">def protectLabel (self):
    
    k = self ; w = self.widget
    if not w: return

    if self.useTextWidget:
        w.update_idletasks()
        k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()</t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        return k.masterKeyHandler(event)
        
    def findButtonBindingCallback(event=None,self=self):
        self.findButton()
        return 'break'

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    findButtonBindingCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)</t>
<t tx="ekr.20051024102724">def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    &lt;&lt; make bindings for a common binding widget &gt;&gt;

    self.canvas.bind('&lt;Key&gt;',k.masterKeyHandler)
    self.canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    &lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</t>
<t tx="ekr.20051025071455.22">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    # Pack last so buttons don't get squished.
    self.outerScrolledFrame.pack(expand=1,fill='both',padx=2,pady=2)
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20051025071455.23">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=6,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')</t>
<t tx="ekr.20051025071455.24"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="ekr.20051025120920">def createBindings (self):
    
    c = self.c ; k = c.k
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:

        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunchList = c.config.getShortcut(commandName)
            for bunch in bunchList:
                accel = bunch.val
                shortcut = k.shortcutFromSetting(accel)
                if shortcut:
                    # g.trace(shortcut,commandName)
                    w.bind(shortcut,func)
           </t>
<t tx="ekr.20051025144611.20">def makeAutocompletionList (self,a,b,glist):
    
    '''We have seen a.b, where a and b are arbitrary strings.
    Append (a1.b1) to glist.
    To compute a1, scan backwards in a until finding whitespace.
    To compute b1, scan forwards in b until finding a char not in okchars.
    '''
    
    if 1: # Do everything inline.  It's a few percent faster.

        # Compute reverseFindWhitespace inline.
        i = len(a) -1
        while i &gt;= 0:
            if a[i].isspace() or a [i] == '.':
                a1 = a [i+1:] ; break
            i -= 1
        else:
            a1 = a
            
        # Compute getCleanString inline.
        i = 0
        for ch in b:
            if ch not in self.okchars:
                b1 = b[:i] ; break
            i += 1
        else:
            b1 = b

        if b1:
            glist.append((a1,b1),)
            
        return b # Not needed unless we are using reduce.
    else:
        a1 = self.reverseFindWhitespace(a)
        if a1:
            b1 = self.getCleanString(b)
            if b1:
                glist.append((a1,b1))
        return b </t>
<t tx="ekr.20051026083544">def handleDefaultChar(self,event):
    
    k = self ; c = k.c
    w = event and event.widget
    name = c.widget_name(w)

    if name.startswith('body'):
        action = k.unboundKeyAction
        if action in ('insert','overwrite'):
            c.editCommands.selfInsertCommand(event,action=action)
        else:
            pass ; g.trace('ignoring key')
        return 'break'
    elif name.startswith('head'):
        c.frame.tree.onHeadlineKey(event)
        return 'break'
    else:
        # Let tkinter handle the event.
        # ch = event and event.char ; g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20051026092433">def updateTab (self,p,w):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20051026171121">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if c.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20051026171121.1"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c ; d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if c.frame.body.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051113090322">self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(
        relief='flat',background=bg)</t>
<t tx="ekr.20051121092320">def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)</t>
<t tx="ekr.20051125080855">def selfInsertCommand(self,event,action='insert'):
    
    '''Insert a character in the body pane.
    
    This is the default binding for all keys in the body pane.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    w = event and event.widget
    name = c.widget_name(w)
    oldSel =  name.startswith('body') and g.app.gui.getTextSelection(w)
    oldText = name.startswith('body') and p.bodyString()
    removeTrailing = None # A signal to compute it later.
    undoType = 'Typing'
    trace = c.config.getBool('trace_masterCommand')
    
    if trace: g.trace(name)
    
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
        
    if ch == '\t':
        removeTrailing = self.updateTab(p,w)
    elif ch == '\b':
        # This is correct: we only come here if there no bindngs for this key. 
        self.backwardDeleteCharacter(event)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j:                  w.delete(i,j)
        elif action == 'overwrite': w.delete(i,'%s+1c' % i)
        w.insert(i,ch)                     
    else:
        return 'break' # New in 4.4a5: this method *always* returns 'break'

    # Update the text and handle undo.
    newText = w.get('1.0','end')
    w.see(w.index('insert'))
    if newText != oldText:
        c.frame.body.onBodyChanged(undoType=undoType,
            oldSel=oldSel,oldText=oldText,oldYview=None,removeTrailing=removeTrailing)
            
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return 'break'</t>
<t tx="ekr.20051126122638"></t>
<t tx="ekr.20051126122952.1">def autoComplete (self,event=None,force=False):
    
    '''An event handler called from k.masterKeyHanderlerHelper.'''

    c = self.c ; k = self.k
    w = event and event.widget or c.get_focus()

    # First, handle the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)

    self.language = g.scanForAtLanguage(c,c.currentPosition())
    if w and self.language == 'python' and (k.enable_autocompleter or force):
        self.start(event=event,w=w)

    return 'break'</t>
<t tx="ekr.20051126123149">def computeCompletionList (self,verbose=False):
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    c.widgetWantsFocus(w)
    s = gui.getSelectedText(w)
    self.tabList,common_prefix = g.itemsMatchingPrefixInList(
        s,self.membersList,matchEmptyPrefix=True)
    if not common_prefix:
        if verbose or len(self.tabList) &lt; 25:
            self.tabList,common_prefix = g.itemsMatchingPrefixInList(
                s,self.membersList,matchEmptyPrefix=True)
        else: # Show the possible starting letters.
            d = {}
            for z in self.tabList:
                ch = z and z[0] or ''
                if ch:
                    n = d.get(ch,0)
                    d[ch] = n + 1
            aList = [ch+'...%d' % (d.get(ch)) for ch in d.keys()] ; aList.sort()
            self.tabList = aList
       
    c.frame.log.clearTab(self.tabName) # Creates the tab if necessary.
    if self.tabList:
        self.tabListIndex = -1 # The next item will be item 0.
        self.setSelection(common_prefix)
    for name in self.tabList:
        g.es('%s' % (name),tabName=self.tabName)</t>
<t tx="ekr.20051126123249">class autoCompleterClass:
    
    '''A class that inserts autocompleted and calltip text in text widgets.
    This class shows alternatives in the tabbed log pane.
    
    The keyHandler class contains hooks to support these characters:
    invoke-autocompleter-character (default binding is '.')
    invoke-calltips-character (default binding is '(')
    '''

    @others</t>
<t tx="ekr.20051126123249.1">def doTabCompletion (self):
    
    '''Handle tab completion when the user hits a tab.'''
    
    c = self.c ; gui = g.app.gui ; w = self.widget
    s = gui.getSelectedText(w)

    if s.startswith(self.prefix) and self.tabList:
        # g.trace('cycle','prefix',repr(self.prefix),len(self.tabList),repr(s))
        # Set the label to the next item on the tab list.
        self.tabListIndex +=1
        if self.tabListIndex &gt;= len(self.tabList):
           self.tabListIndex = 0
        self.setSelection(self.tabList[self.tabListIndex])
    else:
        self.computeCompletionList()

    c.widgetWantsFocusNow(w)</t>
<t tx="ekr.20051126123759.1">def __init__ (self,k):
    
    self.c = c = k.c
    self.k = k
    self.allClassesDict = {} # Will be completed after more classes exist.
    self.attrDictDict = {}  # Keys are languages (strings); values are anonymous attrDicts.
        # attrDicts: keys are strings; values are list of strings (attributes).
    self.calltips = {} # Keys are language, values are dicts: keys are ids, values are signatures.
    self.classScanner = self.classScannerClass(c)
    self.forgivingParser = self.forgivingParserClass(c)
    self.knownObjects = {}
    self.language = None
    self.membersList = None
    self.objectDict = {} # Created on first use of the autocompleter.
    self.selection = None # The selection range on entry to autocompleter or calltips.
    self.selectedText = None # The selected text on entry to autocompleter or calltips.
    self.selfObjectsDict = {} # Keys are classNames, values are real proxy objects.
    self.selfTnodesDict = {} # Keys are tnodes, values are real proxy objects.
    self.prefix = None
    self.prevObjects = []
    self.tabList = []
    self.tabListIndex = -1
    self.tabName = None # The name of the main completion tab.
    self.object = None # The previously found object, for . chaining.
    self.trace = c.config.getBool('trace_autocompleter')
    self.verbose = False # True: print all members.
    self.watchwords = {} # Keys are ids, values are lists of ids that can follow a id dot.
    self.widget = None # The widget that should get focus after autocomplete is done.

</t>
<t tx="ekr.20051126124705">def autoCompleterStateHandler (self,event):
    
    c = self.c ; k = self.k ; w = self.widget
    tag = 'auto-complete' ; state = k.getState(tag)
    keysym = event and event.keysym
    ch = event and event.char or ''
    trace = self.trace and not g.app.unitTesting
    if trace: g.trace(repr(ch),repr(keysym),state)

    if state == 0:
        c.frame.log.clearTab(self.tabName)
        self.computeCompletionList()
        k.setState(tag,1,handler=self.autoCompleterStateHandler) 
    elif keysym in ('space','Return'):
        self.finish()
    elif keysym == 'Escape':
        self.abort()
    elif keysym == 'Tab':
        self.doTabCompletion()
    elif keysym == 'BackSpace':
        self.doBackSpace()
    elif keysym == 'period':
        self.chain()
    elif keysym == 'question':
        self.info()
    elif keysym == 'exclam':
        # Toggle between verbose and brief listing.
        self.verbose = not self.verbose
        if type(self.object) == types.DictType:
            self.membersList = self.object.keys()
        elif type(self.object) in (types.ListType,types.TupleType):
            self.membersList = self.object
        self.computeCompletionList(verbose=self.verbose)
    elif ch and ch in string.printable:
        self.insertNormalChar(ch,keysym)
    else:
        if trace: g.trace('ignore',repr(ch))
        return 'do-standard-keys'</t>
<t tx="ekr.20051126131103">def doBackSpace (self):

    '''Cut back to previous prefix.'''
    
    if self.prefix:
        self.prefix = self.prefix[:-1]
        self.setSelection(self.prefix)
        self.computeCompletionList()
    elif self.prevObjects:
        obj = self.pop()
        # g.trace(self.object,obj)
        w = self.widget
        i,j = g.app.gui.getTextSelection(w)
        ch = w.get(i+'-1c')
        if ch == '.':
            self.object = obj
            w.delete(i+'-1c')
            i = w.index(i+'-1c wordstart')
            j = w.index(i+' wordend')
            word = w.get(i,j)
            g.app.gui.setSelectionRange(w,i,j,insert=j)
            self.prefix = word
            self.popTabName()
            self.membersList = self.getMembersList(obj)
            self.computeCompletionList()
        else:
            self.abort() # should not happen.
    else:
        self.abort()</t>
<t tx="ekr.20051127065601">def extendSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
    else:
        i = j = g.app.gui.getInsertPoint(w)
    
    w.insert(j,s)
    j = w.index('%s + 1c' % (j))
    g.app.gui.setSelectionRange(w,i,j,insert=j)</t>
<t tx="ekr.20051127070018">def setSelection (self,s):
    
    c = self.c ; w = self.widget
    c.widgetWantsFocusNow(w)
    
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
        w.delete(i,j)
    else:
        i = g.app.gui.getInsertPoint(w)
        
    # Don't go past the ':' that separates the completion from the type.
    n = s.find(':')
    if n &gt; -1: s = s[:n]
    
    w.insert(i,s)
    j = w.index('%s + %dc' % (i,len(s)))
    g.app.gui.setSelectionRange(w,i,j,insert=j)</t>
<t tx="ekr.20051127105102">def finish (self):
    
    c = self.c ; k = self.k ; w = self.widget ; gui = g.app.gui
    
    k.keyboardQuit(event=None)
    
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
        
    c.frame.body.onBodyChanged('Typing')
        
    self.clear()
    self.object = None</t>
<t tx="ekr.20051127105431">def abort (self):
    
    k = self.k
    k.keyboardQuit(event=None)
    self.exit(restore=True)

def exit (self,restore=False): # Called from keyboard-quit.
    
    c = self.c ; w = self.widget
    for name in (self.tabName,'Modules','Info'):
        c.frame.log.deleteTab(name)
    c.widgetWantsFocusNow(w)
    i,j = g.app.gui.getTextSelection(w)
    if restore:
        w.delete(i,j)
        w.insert(i,self.selectedText)
    g.app.gui.setTextSelection(w,j,j,insert=j)
    
    self.clear()
    self.object = None</t>
<t tx="ekr.20060104154937">def addModeCommands (self):
    
    '''Add commands created by @mode settings to c.commandsDict and k.inverseCommandsDict.'''

    k = self ; c = k.c
    d = g.app.config.modeCommandsDict
    
    # Create the callback functions and update c.commandsDict and k.inverseCommandsDict.
    for key in d.keys():

        def enterModeCallback (event=None,name=key):
            k.enterNamedMode(event,name)

        c.commandsDict[key] = f = enterModeCallback
        k.inverseCommandsDict [f.__name__] = key
        # g.trace('leoCommands %24s = %s' % (f.__name__,key))</t>
<t tx="ekr.20060114110141">if c.config.getBool('trace_bindings'):
    theFilter = c.config.getString('trace_bindings_filter') or ''
    # g.trace(repr(theFilter))
    if not theFilter or shortcut.find(theFilter) != -1:
        pane_filter = c.config.getString('trace_bindings_pane_filter')
        if not pane_filter or pane_filter.lower() == pane:
            g.trace(pane,shortcut,commandName)</t>
<t tx="ekr.20060114115648">for bunch in bunchList:
    if ( bunch and
        # (not bunch.pane.endswith('-mode') and not pane.endswith('-mode')) and
        bunch.pane != 'mini' and # Minibuffer bindings are completely separate.
        (bunch.pane == pane or pane == 'all' or bunch.pane == 'all') and
        commandName != bunch.commandName
    ):
        g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
            k.prettyPrintKey(shortcut),
            bunch.commandName,commandName,pane),
            color='blue')
        return</t>
<t tx="ekr.20060115195302">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20060116073938"></t>
<t tx="ekr.20060120071949">def isPlainKey (self,shortcut):
    
    '''Return true if the shortcut refers to a plain key.'''
    
    shortcut = shortcut or ''
    shortcut1 = shortcut[:]

    shift = 'Shift-'
    shortcut = shortcut or ''
    if shortcut.startswith('&lt;'):   shortcut = shortcut[1:]
    if shortcut.endswith('&gt;'):     shortcut = shortcut[:-1]
    if shortcut.startswith(shift): shortcut = shortcut[len(shift):]

    return len(shortcut) == 1</t>
<t tx="ekr.20060125175103">def minibufferWantsFocus(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocus(c.miniBufferWidget)
    else:
        c.bodyWantsFocus()

def minibufferWantsFocusNow(self):
    
    c = self.c
    if self.useTextWidget:
        c.widgetWantsFocusNow(c.miniBufferWidget)
    else:
        c.bodyWantsFocusNow()</t>
<t tx="ekr.20060126163152.2"># The keys to k.bindingsDict must be consistent with what this method returns.
# See 'about internal bindings' for details.
 
def strokeFromEvent (self,event):
    
    k = self
    if event is None: return ''
    trace = k.trace_key_event and not g.app.unitTesting
    state = event.state or 0
    keysym = event.keysym or ''
    ch = event.char
    result = []
    shift = (state &amp; 1) == 1 # Not used for alpha chars.
    caps  = (state &amp; 2) == 2
    ctrl  = (state &amp; 4) == 4
    # Linux uses, 8 and 0x80, XP uses 0x20000.
    if sys.platform=='darwin':
        alt = (state&amp;0x10) == 0x10
        #num = False
    elif sys.platform.startswith('win'):
        alt = (state &amp; 0x20000) == 0x20000
        #num = (state &amp; 8) == 8
    else:
        #num = False # ???
        alt = (state &amp; 8) == 8 or (state &amp; 0x80) == 0x80
    plain = len(keysym) == 1 # E.g., for ctrl-v the keysym is 'v' but ch is empty.
    
    if trace: g.trace('ch',repr(ch),'keysym',repr(keysym),'state: %x' % state)
    
    # Undo the effect of the caps-lock key.
    if caps:
        if alt or ctrl or k.ignore_caps_lock:
            if shift:
                ch = ch.upper() ; keysym = keysym.upper()
                event.char=event.char.upper()
                event.keysym=event.keysym.upper()
            else:
                ch = ch.lower() ; keysym = keysym.lower()
                event.char=event.char.lower()
                event.keysym=event.keysym.lower()
    
    # The big aha: we can ignore the shift state.
    if plain:
        if shift and ch.isalpha() and ch.islower():
            g.trace('oops: inconsistent shift state. shift: %s, ch: %s' % (shift,ch))
        ch = keysym
        shift = False
    else:
        ch2 = k.tkBindNamesInverseDict.get(keysym)
        if ch2:
            ch = ch2
            if len(ch) == 1: shift = False
        else:
            # Just use the unknown keysym.
            pass # There are lots of keysyms that Leo may not know about.
            # g.trace('*'*30,'unknown keysym',repr(keysym))
    
    if alt: result.append('Alt+')
    if ctrl: result.append('Ctrl+')
    if shift: result.append('Shift+')
    result.append(ch)
    result = ''.join(result)
    # g.trace('state',state,'keysym',keysym,'result',repr(result))
    return result</t>
<t tx="ekr.20060127183752">master_key_count = 0

def masterKeyHandler (self,event,stroke=None):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event,stroke)
    if val and c and c.exists: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val</t>
<t tx="ekr.20060128081317">def shortcutFromSetting (self,setting):
    
    k = self

    if not setting:
        return None

    s = setting.strip()
    &lt;&lt; define cmd, ctrl, alt, shift &gt;&gt;
    if k.swap_mac_keys and sys.platform == "darwin":
        &lt;&lt; swap cmd and ctrl keys &gt;&gt;
    &lt;&lt; convert minus signs to plus signs &gt;&gt;
    &lt;&lt; compute the last field &gt;&gt;
    &lt;&lt; compute shortcut &gt;&gt;
    return shortcut
    
canonicalizeShortcut = shortcutFromSetting # For compatibility.
strokeFromSetting    = shortcutFromSetting</t>
<t tx="ekr.20060128090219">def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    # g.trace(c.widget_name(w))
    
    if stroke: # New in 4.4a6:
        return k.masterKeyHandler(event,stroke=stroke)
    else:
        return k.masterCommand(event,func,stroke,commandName)</t>
<t tx="ekr.20060128092340"></t>
<t tx="ekr.20060128103640.1"># Replace all minus signs by plus signs, except a trailing minus:
if s.endswith('-'):
    s = s[:-1].replace('-','+') + '-'
else:
    s = s.replace('-','+')</t>
<t tx="ekr.20060128103640.2">if s.endswith('+'):
    last = '+'
else:
    fields = s.split('+') # Don't lower this field.
    last = fields and fields[-1]
    if not last:
        if not g.app.menuWarningsGiven:
            print "bad shortcut specifier:", s
        return None

if len(last) == 1:
    last2 = k.tkBindNamesDict.get(last) # Fix new bug introduced in 4.4b2.
    if last2:
        last = last2 ; shift = False # Ignore the shift state for these special chars.
    else:
        if shift:
            last = last.upper()
            shift = False
        else:
            last = last.lower()
else:
    # Translate from a made-up (or lowercase) name to 'official' Tk binding name.
    # This is a *one-way* translation, done only here.
    d = self.settingsNameDict
    last = d.get(last.lower(),last)</t>
<t tx="ekr.20060128103640.4">table = (
    (alt, 'Alt+'),
    (ctrl,'Ctrl+'),
    (cmd, 'Command+'),
    (shift,'Shift+'),
    (True,last),
)
    
shortcut = ''.join([val for flag,val in table if flag])</t>
<t tx="ekr.20060130093055">def bindKeyToDict (self,pane,stroke,func,commandName):
    
    k = self
    d =  k.masterBindingsDict.get(pane,{})
    
    stroke = stroke.lstrip('&lt;').rstrip('&gt;')
    
    if 0:
        g.trace('%-4s %-18s %-40s %s' % (
            pane,repr(stroke),commandName,func and func.__name__)) # ,len(d.keys()))

    if d.get(stroke):
        g.es('ignoring duplicate definition of %s to %s in %s' % (
            stroke,commandName,pane), color='blue')
    else:
        d [stroke] = g.Bunch(commandName=commandName,func=func,pane=pane,stroke=stroke)
        k.masterBindingsDict [pane] = d</t>
<t tx="ekr.20060131075440">def tkbindingFromStroke (self,stroke):
    
    '''Convert a stroke (key to k.bindingsDict) to an actual Tk binding.'''
    
    stroke = stroke.lstrip('&lt;').rstrip('&gt;')
    
    for a,b in (
        ('Alt+','Alt-'),
        ('Ctrl+','Control-'),
        ('Shift+','Shift-'),
        ('Command+','Command-'),
    ):
        stroke = stroke.replace(a,b)
        
    return '&lt;%s&gt;' % stroke</t>
<t tx="ekr.20060131173440">self.bindingWidget = t = Tk.Text(self.canvas,name='bindingWidget')

t.bind('&lt;Key&gt;',k.masterKeyHandler)

table = (
    ('&lt;Button-1&gt;',       k.masterClickHandler,          tree.onHeadlineClick),
    ('&lt;Button-3&gt;',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('&lt;Double-Button-1&gt;',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('&lt;Double-Button-3&gt;',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    t.bind(a,treeBindingCallback)
    
self.textBindings = t.bindtags()</t>
<t tx="ekr.20060131173440.2">where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '&lt;Button-1&gt;',self.onClickBoxClick),
    ('iconBox','&lt;Button-1&gt;',self.onIconBoxClick),
    ('iconBox','&lt;Double-1&gt;',self.onIconBoxDoubleClick),
    ('iconBox','&lt;Button-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;Double-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;B1-Motion&gt;',self.onDrag),
    ('iconBox','&lt;Any-ButtonRelease-1&gt;',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)</t>
<t tx="ekr.20060201065809">s2 = s.lower()

cmd   = s2.find("cmd") &gt;= 0     or s2.find("command") &gt;= 0
ctrl  = s2.find("control") &gt;= 0 or s2.find("ctrl") &gt;= 0
alt   = s2.find("alt") &gt;= 0
shift = s2.find("shift") &gt;= 0   or s2.find("shft") &gt;= 0</t>
<t tx="ekr.20060201083154">def prettyPrintKey (self,stroke):
    
    s = stroke and stroke.strip().lstrip('&lt;').rstrip('&gt;')
    if not s: return ''

    shift = s.find("shift") &gt;= 0 or s.find("shft") &gt;= 0
    
    # Replace all minus signs by plus signs, except a trailing minus:
    if s.endswith('-'): s = s[:-1].replace('-','+') + '-'
    else:               s = s.replace('-','+')
    fields = s.split('+')
    last = fields and fields[-1]

    if last and len(last) == 1:
        prev = s[:-1]
        if last.isalpha():
            if last.isupper():
                if not shift:
                    s = prev + 'Shift+' + last
            elif last.islower():
                if not prev:
                    s = 'Key+' + last.upper()
                else:
                    s = prev + last.upper()

    return '&lt;%s&gt;' % s</t>
<t tx="ekr.20060203112912.1"></t>
<t tx="ekr.20060203114017">def setMinibufferBindings (self):
    
    '''Create bindings for the minibuffer..'''
    
    f = self ; c = f.c ; k = c.k ; t = f.miniBufferWidget
    
    if not c.useTextMinibuffer: return
    
    for kind,callback in (
        ('&lt;Key&gt;',           k.masterKeyHandler),
        ('&lt;Button-1&gt;',      k.masterClickHandler),
        ('&lt;Button-3&gt;',      k.masterClick3Handler),
        ('&lt;Double-1&gt;',      k.masterDoubleClickHandler),
        ('&lt;Double-3&gt;',      k.masterDoubleClick3Handler),
    ):
        t.bind(kind,callback)

    if 0:
        if sys.platform.startswith('win'):
            # Support Linux middle-button paste easter egg.
            t.bind("&lt;Button-2&gt;",frame.OnPaste)</t>
<t tx="ekr.20060205221734">def masterKeyHandlerHelper (self,event,stroke):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in (
        'Caps_Lock', 'Num_Lock', 'Control_L', 'Alt_L',
        'Shift_L', 'Control_R', 'Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    if 0:
        if stroke is None:
            if trace: g.trace('no stroke: using strokeFromEvent')
            stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings, but *not* in auto-complete state.
        if not state.startswith('auto-'):
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                if trace: g.trace(repr(stroke),'mini binding',b.commandName)
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state in ('full-command','auto-complete'):
            # Do the default state action.
            if trace: g.trace('calling state function')
            val = k.callStateFunction(event) # Calls end-command.
            if val != 'do-standard-keys':
                return 'break'
            g.trace('do-standard-keys',w_name,stroke)
        # Third, pass keys to the general mode handler.
        else:
            d =  k.masterBindingsDict.get(state)
            if d:
                # A typical state
                b = d.get(stroke)
                # g.trace(d.keys())
                if b:
                    if trace: g.trace('calling generalModeHandler')
                    k.generalModeHandler (event,
                        commandName=b.commandName,func=b.func,
                        modeName=state,nextMode=b.nextMode)
                    return 'break'
                else:
                    if trace: g.trace('calling modeHelp')
                    k.modeHelp(event)
                    return 'break'
            else:
                g.trace('No state dictionary for %s' % state)
                return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text','log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if k.ignore_unbound_non_ascii_keys and len(event.char) &gt; 1:
        # (stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1)):
        if trace: g.trace('ignoring unbound non-ascii key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060206064635">def extendLabel(self,s,select=False,protect=False):
    
    k = self ; c = k.c ; w = self.widget
    if not w: return
    trace = self.trace_minibuffer and not g.app.unitTesting
    
    if trace: g.trace(repr(s))
    if not s: return

    if self.useTextWidget:
        c.widgetWantsFocusNow(w)
        w.insert('end',s)
        if select:
            i,j = k.getEditableTextRange()
            g.app.gui.setTextSelection(w,i,j,insert=j)
        if protect:
            k.protectLabel()
</t>
<t tx="ekr.20060210141604.1">def getEditableTextRange (self):
    
    k = self ; w = self.widget ; n = 0
    # trace = self.trace_minibuffer and not g.app.unitTesting
    
    s = w.get('1.0','end')
    while s.endswith('\n') or s.endswith('\r'):
        s = s[:-1] ; n += 1
        
    i = w.index('1.%d' % len(k.mb_prefix))
    j = w.index('end -%dc' % n)
    
    # if trace: g.trace(i,j)
    return i,j
</t>
<t tx="ekr.20060211100905.1">def activateMenu (self,menuName):
    
    c = self.c ;  top = c.frame.top
    topx,topy = top.winfo_rootx(),top.winfo_rooty()
    menu = c.frame.menu.getMenu(menuName)

    if menu:
        d = self.computeMenuPositions()
        x = d.get(menuName)
        if x is None:
             x = 0 ; g.trace('oops, no menu offset: %s' % menuName)
        
        menu.tk_popup(topx+d.get(menuName,0),topy) # Fix by caugm.  Thanks!
    else:
        g.trace('oops, no menu: %s' % menuName)</t>
<t tx="ekr.20060213151411"></t>
<t tx="ekr.20060213164147"></t>
<t tx="ekr.20060214140930"></t>
<t tx="ekr.20060214140930.1">extract                             = Shift-Ctrl-D
extract-names                       = Shift-Ctrl-N
extract-section                     = Shift-Ctrl-S  # Shift-Ctrl-E: end-of-line-extend-selection

write-at-file-nodes                 = Shift-Ctrl-W # Was enter-file-mode.
write-dirty-at-file-nodes           = Shift+Ctrl+Q

# Removed definitions of find and file modes.  I never used them.</t>
<t tx="ekr.20060214172823">@ This code "canonicalizes" both the shortcuts that appear in menus and the arguments to bind, mostly ignoring case and the order in which special keys are specified in leoConfig.txt.

For example, Ctrl+Shift+a is the same as Shift+Control+A.  Either may appear in leoConfig.txt.  Each generates Shift+Ctrl-A in the menu and Control+A as the argument to bind.

Returns (bind_shortcut, menu_shortcut)
@c

def canonicalizeShortcut (self,shortcut):
    
    if shortcut == None or len(shortcut) == 0:
        return None,None
    s = shortcut.strip().lower()
    
    has_cmd   = s.find("cmd") &gt;= 0     or s.find("command") &gt;= 0 # 11/18/03
    has_ctrl  = s.find("control") &gt;= 0 or s.find("ctrl") &gt;= 0
    has_alt   = s.find("alt") &gt;= 0
    has_shift = s.find("shift") &gt;= 0   or s.find("shft") &gt;= 0
    if sys.platform == "darwin":
        if has_ctrl and not has_cmd:
            has_cmd = True ; has_ctrl = False
        if has_alt and not has_ctrl: # 9/14/04
            has_ctrl = True ; has_alt = False
    &lt;&lt; set the last field, preserving case &gt;&gt;
    &lt;&lt; canonicalize the last field &gt;&gt;
    &lt;&lt; synthesize the shortcuts from the information &gt;&gt;
    # print shortcut,bind_shortcut,menu_shortcut
    return bind_shortcut,menu_shortcut</t>
<t tx="ekr.20060214172823.1">s2 = shortcut
s2 = string.strip(s2)

# Replace all minus signs by plus signs, except a trailing minus:
if len(s2) &gt; 0 and s2[-1] == "-":
    s2 = string.replace(s2,"-","+")
    s2 = s2[:-1] + "-"
else:
    s2 = string.replace(s2,"-","+")

fields = string.split(s2,"+")
if fields == None or len(fields) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None

last = fields[-1]
if last == None or len(last) == 0:
    if not g.app.menuWarningsGiven:
        print "bad shortcut specifier:", s
    return None,None</t>
<t tx="ekr.20060214172823.2">bind_last = menu_last = last
if len(last) == 1:
    ch = last[0]
    if ch in string.ascii_letters:
        menu_last = string.upper(last)
        if has_shift:
            bind_last = string.upper(last)
        else:
            bind_last = string.lower(last)
    elif ch in string.digits:
        bind_last = "Key-" + ch # 1-5 refer to mouse buttons, not keys.
    else:
        &lt;&lt; define dict of Tk bind names &gt;&gt;
        if ch in theDict.keys():
            bind_last = theDict[ch]
elif len(last) &gt; 0:
    &lt;&lt; define dict of special names &gt;&gt;
    last2 = string.lower(last)
    if last2 in theDict.keys():
        bind_last,menu_last = theDict[last2]</t>
<t tx="ekr.20060214172823.3"># These are defined at http://tcl.activestate.com/man/tcl8.4/TkCmd/keysyms.htm.
theDict = {
    "!" : "exclam",
    '"' : "quotedbl",
    "#" : "numbersign",
    "$" : "dollar",
    "%" : "percent",
    "&amp;" : "ampersand",
    "'" : "quoteright",
    "(" : "parenleft",
    ")" : "parenright",
    "*" : "asterisk",
    "+" : "plus",
    "," : "comma",
    "-" : "minus",
    "." : "period",
    "/" : "slash",
    ":" : "colon",
    ";" : "semicolon",
    "&lt;" : "less",
    "=" : "equal",
    "&gt;" : "greater",
    "?" : "question",
    "@" : "at",
    "[" : "bracketleft",
    "\\": "backslash",
    "]" : "bracketright",
    "^" : "asciicircum",
    "_" : "underscore",
    "`" : "quoteleft",
    "{" : "braceleft",
    "|" : "bar",
    "}" : "braceright",
    "~" : "asciitilde" }</t>
<t tx="ekr.20060214172823.4"># These keys are simply made-up names.  The menu_bind values are known to Tk.
# Case is not significant in the keys.

theDict = {
    "bksp"    : ("BackSpace","BkSp"),
    "esc"     : ("Escape","Esc"),
    # Arrow keys...
    "dnarrow" : ("Down", "DnArrow"),
    "ltarrow" : ("Left", "LtArrow"),
    "rtarrow" : ("Right","RtArrow"),
    "uparrow" : ("Up",   "UpArrow"),
    # Page up/down keys...
    "pageup"  : ("Prior","PgUp"),
    "pagedn"  : ("Next", "PgDn")
}

@  The following are not translated, so what appears in the menu is the same as what is passed to Tk.  Case is significant.

Note: the Tk documentation states that not all of these may be available on all platforms.

F1,F2,F3,F4,F5,F6,F7,F8,F9,F10,
BackSpace, Break, Clear, Delete, Escape, Linefeed, Return, Tab,
Down, Left, Right, Up,
Begin, End, Home, Next, Prior,
Num_Lock, Pause, Scroll_Lock, Sys_Req,
KP_Add, KP_Decimal, KP_Divide, KP_Enter, KP_Equal,
KP_Multiply, KP_Separator,KP_Space, KP_Subtract, KP_Tab,
KP_F1,KP_F2,KP_F3,KP_F4,
KP_0,KP_1,KP_2,KP_3,KP_4,KP_5,KP_6,KP_7,KP_8,KP_9
</t>
<t tx="ekr.20060214172823.5">bind_head = menu_head = ""

if has_shift:
    menu_head = "Shift+"
    if len(last) &gt; 1 or (len(last)==1 and last[0] not in string.ascii_letters):
        bind_head = "Shift-"
if has_alt:
    bind_head = bind_head + "Alt-"
    menu_head = menu_head + "Alt+"

if has_ctrl:
    bind_head = bind_head + "Control-"
    menu_head = menu_head + "Ctrl+"
    
if has_cmd: # 11/18/03
    bind_head = bind_head + "Command-"
    menu_head = menu_head + "Command+"
    
bind_shortcut = "&lt;" + bind_head + bind_last + "&gt;"
menu_shortcut = menu_head + menu_last</t>
<t tx="ekr.20060215055823"></t>
<t tx="ekr.20060215090312">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3545403
By: e

more str() to remove...

with some non ascii headline,
a traceback after an executeScript
calls goto linenumber

 \leo-4-4-\src\leoCommands.py, line 1822, in goToScriptLineNumber
    c.goToLineNumber(root=root,lines=lines,n=n,scriptFind=True)
 \leo-4-4-\src\leoCommands.py", line 1466, in goToLineNumber
    if p.matchHeadline(vnodeName):
 \leo-4-4-\src\leoNodes.py, line 1631, in matchHeadline
    def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
 \leo-4-4-\src\leoNodes.py, line 665, in matchHeadline
    return s == h[0:len(s)]
UnicodeDecodeError: 'ascii' codec can't decode byte 0xc2 in position 1: ordinal
not in range(128)

aÂ² + bÂ² = cÂ²
</t>
<t tx="ekr.20060215092723"></t>
<t tx="ekr.20060215092723.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3577681
By: caugm

I added this line on leoTkinterMenu.py and now the activate-x-menu commands
works on Linux, at least for me ;-)

--- src/leoTkinterMenu.py       2006-02-15 12:06:28.000000000 -0200
+++ src2/leoTkinterMenu.py      2006-02-15 12:06:24.000000000 -0200
@@ -41,6 +41,7 @@
             if x is None:
                  x = 0 ; g.trace('oops, no menu offset: %s' % menuName)
             menu.post(topx+d.get(menuName,0),topy)
+            menu.focus()
         else:
             g.trace('oops, no menu: %s' % menuName)
     #@nonl


</t>
<t tx="ekr.20060215092723.2">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3573470

Still to do:

? What are the state masks for Num_Lock on Linux and darwin?

What I did:

- Added support for trace_key_event setting.
- Added support for ignore_caps_lock setting.
- Added Caps_Lock and Num_Lock to k.tkNamesList and in the list of
  special keys in k.masterCommand and k.masterKeyHandlerHelper.
- Added support for k.ignore_unbound_non_ascii_keys logic in masterKeyHandlerHelper.
- Disabled unknown keysym trace in k.strokeFromEvent.
- Enabled the international keyboard on XP as an aid to testing.
- Added support for swap_mac_keys setting in k.shortcutFromSetting.
- Added support for non-ascii characters in the minibuffer.</t>
<t tx="ekr.20060215104239">if ctrl and not cmd:
    cmd = True ; ctrl = False
if alt and not ctrl:
    ctrl = True ; alt = False</t>
<t tx="ekr.20060215150236">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3576790
By: yarkot

On WinXT PC -

If NUM-LOCK key is enabled, main keyboard mappings all "scrogged";  need to
unlock NUM-LOCK for keys to work.
</t>
<t tx="ekr.20060216065048">@killcolor

http://sourceforge.net/forum/message.php?msg_id=3579430
By: dcbbcd

I hope you can still read this after SourceForge
messed up my indentation.

Cursor in the body pane

1. Pressing the modifier keys without any other key

   1.1 Left Alt
       Pressing left Alt without any other key gives no report
   
   1.2 Right Alt
       Pressing right Alt without any other key reports:
   
       strokeFromEvent: ch '' keysym 'ISO_Level3_Shift' state: 0
       masterKeyHandlerHelper: '' state None
       masterKeyHandlerHelper: '' no func
   
   1.3. Shift, Ctrl and Caps Lock
        Pressing any of the Shift, Ctrl and Caps Lock keys without 
        any other key gives no report
   
2. Pressing the modifier keys with the letter a

   2.1 Left Alt
   
       strokeFromEvent: ch 'a' keysym 'a' state: 8
       masterKeyHandlerHelper: 'Alt+a' state None
       masterKeyHandlerHelper: all found Alt+a = sort-siblings
       
   2.2 Right Alt
   
       This is very interesting! The following exception occurs, but the
       correct character is inserted in the body pane.
   
       Error: 1
       UnicodeDecodeError Exception in Tk callback
         Function: &lt;bound method keyHandlerClass.masterKeyHandler
of &lt;leoKeys.keyHandlerClass instance at 0xb77e278c&gt;&gt; (type: &lt;type
'instancemethod'&gt;)
         Args: (&lt;Tkinter.Event instance at 0xb78afa0c&gt;,)
         Event type: KeyPress (type num: 2)
       Traceback (innermost last):
         File "/home/dennis/Desktop/leo-4-4-x1/extensions/Pmw/Pmw_1_2/lib/PmwBas
e.py", line 1752, in __call__
           return apply(self.func, args)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1396, in
masterKeyHandler
           val = self.masterKeyHandlerHelper(event)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1423, in
masterKeyHandlerHelper
           if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
4: ordinal not in range(128)

       ================================================
         Event contents:
           char: Ã¦
           delta: 38
           height: ??
           keycode: 38
           keysym: ??
           keysym_num: 0
           num: ??
           send_event: False
           serial: 38133
           state: 128
           time: 2652121
           type: 2
           widget: .-1214814356.-1214814004.-1214354900.-1214354996.body-pane
           width: ??
           x: 128
           x_root: 833
           y: 92
           y_root: 410

   2.3 Shift
   
       strokeFromEvent: ch 'A' keysym 'A' state: 1
       masterKeyHandlerHelper: 'A' state None
       masterKeyHandlerHelper: 'A' no func
       
   2.4 Ctrl
   
       strokeFromEvent: ch '\x01' keysym 'a' state: 4
       masterKeyHandlerHelper: 'Ctrl+a' state None
       masterKeyHandlerHelper: text found Ctrl+a = beginning-of-line
       
   2.5 Caps Lock
       
       If Caps Lock is turned on pressing "a" results in 
       
       strokeFromEvent: ch 'A' keysym 'A' state: 2
       masterKeyHandlerHelper: 'a' state None
       masterKeyHandlerHelper: 'a' no func
       
       and the lowercase "a" is inserted!!!
       
3. Various combinations

   3.1 Shift-(Left)Ctrl a
   
       strokeFromEvent: ch '\x01' keysym 'A' state: 5
       masterKeyHandlerHelper: 'Ctrl+A' state None
       masterKeyHandlerHelper: text found Ctrl+A =
beginning-of-line-extend-selection
       
   3.2 Shift-(Right)Ctrl a    
   
       This relates to "2.2 Right Alt". The exception occurs, but the correct
       character is inserted.
   
       Error: 4
       UnicodeDecodeError Exception in Tk callback
         Function: &lt;bound method keyHandlerClass.masterKeyHandler
of &lt;leoKeys.keyHandlerClass instance at 0xb77e278c&gt;&gt; (type: &lt;type
'instancemethod'&gt;)
         Args: (&lt;Tkinter.Event instance at 0xb77893cc&gt;,)
         Event type: KeyPress (type num: 2)
       Traceback (innermost last):
         File "/home/dennis/Desktop/leo-4-4-x1/extensions/Pmw/Pmw_1_2/lib/PmwBas
e.py", line 1752, in __call__
           return apply(self.func, args)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1396, in
masterKeyHandler
           val = self.masterKeyHandlerHelper(event)
         File "/home/dennis/Desktop/leo-4-4-x1/src/leoKeys.py", line 1423, in
masterKeyHandlerHelper
           if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
10: ordinal not in range(128)
       
       ================================================
         Event contents:
           char: Ã?
           delta: 38
           height: ??
           keycode: 38
           keysym: ??
           keysym_num: 0
           num: ??
           send_event: False
           serial: 76290
           state: 129
           time: 3254177
           type: 2
           widget: .-1214814356.-1214814004.-1214354900.-1214354996.body-pane
           width: ??
           x: 170
           x_root: 875
           y: 118
           y_root: 436

   3.3 (Left)Alt-Shift a
   
       strokeFromEvent: ch 'A' keysym 'A' state: 9
       masterKeyHandlerHelper: 'Alt+A' state None
       masterKeyHandlerHelper: text found Alt+A = select-all
       
       If I start this combination with pressing Shift first and then Alt
       and the the letter "a" the following is reported before the above:
       
       strokeFromEvent: ch '' keysym 'Meta_L' state: 1
       masterKeyHandlerHelper: 'Shift+' state None
       masterKeyHandlerHelper: 'Shift+' no func
       
   3.4 Shift-(Right)Alt
   
       strokeFromEvent: ch '' keysym 'ISO_Level3_Shift' state: 1
       masterKeyHandlerHelper: 'Shift+' state None
       masterKeyHandlerHelper: 'Shift+' no func
       
   3.5 (Right)Alt-Shift
   
       strokeFromEvent: ch '' keysym '??' state: 80
       masterKeyHandlerHelper: 'Alt+' state None
       masterKeyHandlerHelper: 'Alt+' no func
</t>
<t tx="ekr.20060216070014">@killcolor

Read and respond to this message at: 
https://sourceforge.net/forum/message.php?msg_id=3578917
By: davidmcnab

&gt; Then type control-a and alt-a, Shift-a, CapsLock-A and CapsLock-Shift-A and
tell me what the trace reports.

Ctrl-A:

ch '\x01' keysym 'a' state: 4
masterKeyHandlerHelper: 'Ctrl+a' state None
masterKeyHandlerHelper: text found Ctrl+a = beginning-of-line

Alt-A:

strokeFromEvent: ch 'a' keysym 'a' state: 8
masterKeyHandlerHelper: 'Alt+a' state None
masterKeyHandlerHelper: all found Alt+a = sort-siblings

Shift-A:

trokeFromEvent: ch 'A' keysym 'A' state: 1
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-A:

trokeFromEvent: ch '' keysym 'Caps_Lock' state: 0
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'A' keysym 'A' state: 2
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-Shift-A:

strokeFromEvent: ch '' keysym 'Caps_Lock' state: 0
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'a' keysym 'A' state: 3
strokeFromEvent: oops: inconsistent shift state. shift: True, ch: a
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

&gt; Ditto for all the above with numlock down. 

Numlock down:

trokeFromEvent: ch '' keysym 'Num_Lock' state: 0
strokeFromEvent: ****************************** unknown keysym 'Num_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func

Ctrl-A:

strokeFromEvent: ch '\x01' keysym 'a' state: 14
masterKeyHandlerHelper: 'Ctrl+a' state None
masterKeyHandlerHelper: text found Ctrl+a = beginning-of-line

Alt-A:

strokeFromEvent: ch 'a' keysym 'a' state: 18
masterKeyHandlerHelper: 'Alt+a' state None
masterKeyHandlerHelper: all found Alt+a = sort-siblings

Shift-A:

strokeFromEvent: ch 'A' keysym 'A' state: 11
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-A:

strokeFromEvent: ch '' keysym 'Caps_Lock' state: 10
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'A' keysym 'A' state: 12
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

Caplocks-Shift-A:

strokeFromEvent: ch '' keysym 'Caps_Lock' state: 10
strokeFromEvent: ****************************** unknown keysym 'Caps_Lock'
masterKeyHandlerHelper: '' state None
masterKeyHandlerHelper: '' no func
strokeFromEvent: ch 'a' keysym 'A' state: 13
strokeFromEvent: oops: inconsistent shift state. shift: True, ch: a
masterKeyHandlerHelper: 'A' state None
masterKeyHandlerHelper: 'A' no func

And finally:

a:

strokeFromEvent: ch 'a' keysym 'a' state: 0
masterKeyHandlerHelper: 'a' state None
masterKeyHandlerHelper: 'a' no func

u (typed by itself):

strokeFromEvent: ch 'u' keysym 'u' state: 0
masterKeyHandlerHelper: 'u' state None
masterKeyHandlerHelper: 'u' no func

ui (typed quickly):

trokeFromEvent: ch 'u' keysym 'u' state: 0
masterKeyHandlerHelper: 'u' state None
masterKeyHandlerHelper: 'u' no func
strokeFromEvent: ch 'i' keysym 'i' state: 80
masterKeyHandlerHelper: 'Alt+i' state None
masterKeyHandlerHelper: ignoring unbound special key

Hope this helps
David

</t>
<t tx="ekr.20060216070841"></t>
<t tx="ekr.20060216071129"></t>
<t tx="ekr.20060216071953"></t>
<t tx="ekr.20060216074643">def completeAllBindings (self):
    
    '''New in 4.4b3: make an actual binding in *all* the standard places.
    
    The event will go to k.masterKeyHandler as always, so nothing really changes.
    except that k.masterKeyHandler will know the proper stroke.'''
    
    k = self ; c = k.c ; f = c.frame
    bodyCtrl = f.body and hasattr(f.body,'bodyCtrl') and f.body.bodyCtrl or None
    canvas   = f.tree and hasattr(f.tree,'canvas')   and f.tree.canvas   or None
    bindingWidget = f.tree and hasattr(f.tree,'bindingWidget') and f.tree.bindingWidget or None
    if not bodyCtrl or not canvas: return
    
    for w in (c.miniBufferWidget,bodyCtrl,canvas,bindingWidget):
        self.completeAllBindingsForWidget(w)
        
        
        # for stroke in  k.bindingsDict.keys():
        # 
            # def bindKeyCallback (event,k=k,stroke=stroke):
                # return k.masterKeyHandler(event,stroke=stroke)
            # bindStroke = k.tkbindingFromStroke(stroke)
            # try:
                # # g.trace(bindStroke,c.widget_name(w))
                # w.bind(bindStroke,bindKeyCallback)
            # except Exception:
                # g.es_print('exception binding %s to %s' % (
                    # bindStroke,c.widget_name(w)),color='blue')</t>
<t tx="ekr.20060216093552"></t>
<t tx="ekr.20060216110502">for z in ('Alt','Ctrl','Command'):
    if accelerator.find(z) != -1:
        break # Found.
else:
    accelerator = ''</t>
<t tx="ekr.20060216115304"> if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
4: ordinal not in range(128)
</t>
<t tx="ekr.20060216115304.1">if k.abortAllModesKey and stroke == k.abortAllModesKey:
       UnicodeDecodeError: 'ascii' codec can't decode byte 0xc3 in position
4: ordinal not in range(128)
</t>
<t tx="ekr.20060216115304.2">def safeStringCompare (s1,s2):

    s1 = g.toUnicode(s1,'utf-8')
    s2 = g.toUnicode(s2,'utf-8')
    return s1 == s2
    
def test_g_safeStringCompare ():
    
    assert g.safeStringCompare('a','á') is False
    assert g.safeStringCompare('','á') is False
    assert g.safeStringCompare('',u'á') is False
    assert g.safeStringCompare('a','a') is True
    assert g.safeStringCompare('á','á') is True
    assert g.safeStringCompare(u'á',u'á') is True</t>
<t tx="ekr.20060216120335">@nocolor

- Created k.completeAllBindings, called last in k.makeAllBindings. This binds
all keystrokes in k.bindingsDict to k.masterKeyHandler with an optional stroke
argument. This allows k.masterKeyhandler to dispense with the problematic call
to k.strokeFromEvent. This is all that is really required. 

- Added code to menu.createMenuEntries that clears the accelerator on MacOS for
any key that isn't a control, alt or command key. This solves the recurring
problems with the Return key. The only effect is that the menu won't mention a
binding that is actually in effect, but apparently that cannot be helped.

- Added g.safeCompareStrings, which may, or may not, fix the crasher when
comparing k.abortAllModesKey to the incoming keystroke in k.masterKeyHandler.
It's a bit tricky to test.

- The ignore_caps_lock is no longer functional. Sigh. This depends on knowing
the Caps_Lock bit in key events. I may put this back later, but I can't delay a6
even a minute for this.</t>
<t tx="ekr.20060216134253">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3577022

You can click nodes and get the UNL to display, but when arrowing around the
tree, UNL area flashes the unl and then clears it immediately.</t>
<t tx="ekr.20060216135646">@nocolor

- Allow 'self' as an anchor.

- leading . shows all classes.

- Info for builtins like reduce, getattr, etc. (Maybe a separate command).

Maybe:

- .#  leoNodes.# removes leoNodes but makes it the present object.
      (useful for specifing self, and other classes)

- Scan present body text if all else fails.</t>
<t tx="ekr.20060216155558.1">def scan (self,event=None,verbose=True,thread=True):
    
    c = self.c
    if not c or not c.exists or c.frame.isNullFrame: return
    if g.app.unitTesting: return
    
    # g.trace('autocompleter')
    
    if 0: ## thread:
        # Use a thread to do the initial scan so as not to interfere with the user.            
        def scan ():
            #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
            # During unit testing c gets destroyed before the scan finishes.
            if not g.app.unitTesting:
                self.scanOutline(verbose=True)
    
        t = threading.Thread(target=scan)
        t.setDaemon(True)
        t.start()
    else:
        self.scanOutline(verbose=verbose)</t>
<t tx="ekr.20060216160332.1"># Not used at present, but soon.</t>
<t tx="ekr.20060216160332.2"></t>
<t tx="ekr.20060216161220">def scanOutline (self,verbose=True):

    '''Traverse an outline and build the autocommander database.'''
    
    if verbose: g.es_print('Scanning for auto-completer...')

    c = self.c ; k = self.k ; count = 0
    for p in c.rootPosition().allNodes_iter():
        if verbose:
            count += 1 ;
            if (count % 200) == 0: g.es('.',newline=False)
        language = g.scanForAtLanguage(c,p)
        # g.trace('language',language,p.headString())
        s = p.bodyString()
        if k.enable_autocompleter:
            self.scanForAutoCompleter(s)
        if k.enable_calltips:
            self.scanForCallTip(s,language)

    if 0:
        g.trace('watchwords...\n\n')
        keys = self.watchwords.keys() ; keys.sort()
        for key in keys:
            aList = self.watchwords.get(key)
            g.trace('%s:\n\n' % (key), g.listToString(aList))
    if 0:
        g.trace('calltips...\n\n')
        keys = self.calltips.keys() ; keys.sort()
        for key in keys:
            d = self.calltips.get(key)
            if d:
                g.trace('%s:\n\n' % (key), g.dictToString(d))
        
    if verbose:        
        g.es_print('\nauto-completer scan complete',color='blue')</t>
<t tx="ekr.20060216161234">def scanForCallTip (self,s,language):

    '''this function scans text for calltip info'''

    d = self.calltips.get(language,{})
    pat = self.pats.get(language or 'python')
    
    # Set results to a list of all the function/method defintions in s.
    results = pat and pat.findall(s) or []

    for z in results:
        if isinstance(z,tuple): z = z [0]
        pieces2 = z.split('(')
        # g.trace(pieces2)
        pieces2 [0] = pieces2 [0].split() [-1]
        a, b = pieces2 [0], pieces2 [1]
        aList = d.get(a,[])
        if str(z) not in aList:
            aList.append(str(z))
            d [a] = aList
    
    self.calltips [language] = d</t>
<t tx="ekr.20060216161247">def scanForAutoCompleter (self,s):

    '''This function scans text for the autocompleter database.'''

    aList = [] ; t1 = s.split('.')
    
    if 1: # Slightly faster.
        t1 = s.split('.') ; 
        i = 0 ; n = len(t1)-1
        while i &lt; n:
            self.makeAutocompletionList(t1[i],t1[i+1],aList)
            i += 1
    else:
        reduce(lambda a,b: self.makeAutocompletionList(a,b,aList),t1)

    if aList:
        for a, b in aList:
            z = self.watchwords.get(a,[])
            if str(b) not in z:
                z.append(str(b))
                self.watchwords [a] = z</t>
<t tx="ekr.20060216161253">def getCleanString (self,s):
    
    '''Return the prefix of s containing only chars in okchars.'''
    
    i = 0
    for ch in s:
        if ch not in self.okchars:
            return s[:i]
        i += 1

    return s</t>
<t tx="ekr.20060216161258">def reverseFindWhitespace (self,s):

    '''Return the longest tail of s containing no whitespace or period.'''

    i = len(s) -1
    while i &gt;= 0:
        if s[i].isspace() or s [i] == '.': return s [i+1:]
        i -= 1

    return s</t>
<t tx="ekr.20060216163305">def definePatterns (self):
    
    self.space = r'[ \t\r\f\v ]+' # one or more whitespace characters.
    self.end = r'\w+\s*\([^)]*\)' # word (\w) ws ( any ) (can cross lines)

    # Define re patterns for various languages.
    # These patterns match method/function definitions.
    self.pats = {}
    self.pats ['python'] = re.compile(r'def\s+%s' % self.end)  # def ws word ( any ) # Can cross line boundaries.
    self.pats ['java'] = re.compile(
        r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
            self.space,self.space,self.end))
    self.pats ['perl'] = re.compile(r'sub\s+%s' % self.end)
    self.pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (self.space,self.end))
    self.pats ['c'] = re.compile(r'\w+%s%s' % (self.space,self.end))
    
    # Define self.okchars for getCleaString.
    okchars = {}
    for z in string.ascii_letters:
        okchars [z] = z
    okchars ['_'] = '_'
    self.okchars = okchars 
    
    if 0: # not used
        self.r  = string.punctuation.replace('(','').replace('.','') # punctuation except ( and .
        self.pt = string.digits + string.letters + self.r
        ripout = string.punctuation + string.whitespace + '\n'
        self.ripout = ripout.replace('_','') # punctuation except underscore.</t>
<t tx="ekr.20060217132329"># Don't call this finishCreate: the startup logic would call it too soon.

def initialScan (self):
    
    g.trace(g.callers())
    
    self.scan(thread=True)</t>
<t tx="ekr.20060218071531"># http://sourceforge.net/forum/message.php?msg_id=3583335
</t>
<t tx="ekr.20060218075614"></t>
<t tx="ekr.20060218075614.1"></t>
<t tx="ekr.20060219103046"></t>
<t tx="ekr.20060219103046.1">def showCalltips (self,event=None,force=False):
    
    k = self.k
    
    w = event and event.widget or c.get_focus()
    
    # First, insert the invocation character as usual.
    k.masterCommand(event,func=None,stroke=None,commandName=None)
    
    # Insert the calltip if possible.
    if k.enable_calltips or force:
        # g.trace('calltips not ready yet')
        self.widget = w
        self.prefix = ''
        self.selection = g.app.gui.getTextSelection(w)
        self.selectedText = g.app.gui.getSelectedText(w)
        self.getLeadinWord(w)
        self.tabName = 'Calltips'
        
    return 'break'</t>
<t tx="ekr.20060219103822">def autoCompleteForce (self,event=None):
    
    return self.autoComplete(event,force=True)</t>
<t tx="ekr.20060219111416">def getLeadinWord (self,w):
    
    self.verbose = False # User must explicitly ask for verbose.
    start = g.app.gui.getInsertPoint(w)
    start = w.index(start+'-1c')
    i,word = self.findAnchor(w)
    self.setObjectAndMembersList(word)
    if not self.object:
        # g.trace('unknown',word)
        return False
    self.beginTabName(word)

    while w.compare(i,'&lt;',start):
        if w.get(i) != '.':
            g.trace('oops: %s' % (repr(w.get(i))))
            return False
        i = w.index(i+'+1c')
        j = w.index(i+' wordend')
        word = w.get(i,j)
        self.setObjectAndMembersList(word)
        if not self.object:
            g.trace('unknown',word)
            return False
        self.appendTabName(word)
        i = j
            
    self.leadinWord = word
    # g.trace(self.leadinWord)
    return True</t>
<t tx="ekr.20060219170043">def showCalltipsForce (self,event=None):
    
    return self.showCalltips(event,force=True)</t>
<t tx="ekr.20060219170612">def disableAutocompleter (self,event=None):
    self.k.enable_autocompleter = False
    
def disableCalltips (self,event=None):
    self.k.enable_calltips = False
    
def enableAutocompleter (self,event=None):
    self.k.enable_autocompleter = True
    
def enableCalltips (self,event=None):
    self.k.enable_calltips = True</t>
<t tx="ekr.20060219171914">def defineObjectDict (self):
    
    c = self.c ; k = c.k ; p = c.currentPosition()

    table = [
        # Python globals...
        (['aList','bList'],     'python','list'),
        (['aString'],           'object','aString'),    # An actual string object.
        (['c','old_c','new_c'], 'object',c),            # 'leoCommands','Commands'),
        (['d','d1','d2'],       'python','dict'),
        (['f'],                 'object',c.frame), # 'leoTkinterFrame','leoTkinterFrame'),
        (['g'],                 'object',g),       # 'leoGlobals',None),
        (['p','p1','p2'],       'object',p),       # 'leoNodes','position'),         
        (['s','s1','s2','ch'],  'object','aString'),
        (['string'],            'object',string),     # Python's string module.
        (['t','t1','t2'],       'object',p.v.t),   # 'leoNodes','tnode'),  
        (['v','v1','v2'],       'object',p.v),     # 'leoNodes','vnode'),
        (['w','widget'],        'Tkinter','Text'),
    ]
    
    if 0: # Not useful at this point.
        for key in __builtins__.keys():
            obj = __builtins__.get(key)
            if obj in (True,False,None): continue
            data = [key],'object',obj
            table.append(data)
    
    d = {'dict':{},'int':1,'list':[],'string':''}

    for idList,kind,nameOrObject in table:
        if kind == 'object':
            # Works, but hard to generalize for settings.
            obj = nameOrObject
        elif kind == 'python':
            className = nameOrObject
            o = d.get(className)
            obj = o is not None and o.__class__
        else:
            module = g.importModule (kind,verbose=True)
            if not module:
                g.trace('Can not import ',nameOrObject)
                continue
            self.appendToKnownObjects(module)
            if nameOrObject:
                className = nameOrObject
                obj = hasattr(module,className) and getattr(module,className) or None
                if not obj:
                    g.trace('%s module has no class %s' % (kind,nameOrObject))
                else:
                    self.appendToKnownObjects(getattr(module,className))
            else:
                obj = module
        if not obj:
            g.trace('bad object',obj)
            continue
        for z in idList:
            self.objectDict[z]=obj
            # g.trace(obj)</t>
<t tx="ekr.20060219172026"></t>
<t tx="ekr.20060219174642">def getMembersList (self,obj):
    
    '''Return a list of possible autocompletions for self.leadinWord.'''

    if obj:
        aList = inspect.getmembers(obj)
        members = ['%s:%s' % (a,g.prettyPrintType(b))
            for a,b in aList if not a.startswith('__')]
        members.sort()
        return members
    else:
        return []</t>
<t tx="ekr.20060219180034">def appendTabName (self,word):
    
    self.setTabName(self.tabName + word + '.')

def beginTabName (self,word):

    self.setTabName('AutoComplete ' + word + '.')
    
def popTabName (self):
    
    s = self.tabName
    i = s.rfind('.',0,-1)
    if i &gt; -1:
        self.setTabName(s[0:i])
    
# Underscores are not valid in Pmw tab names!
def setTabName (self,s):

    c = self.c
    if self.tabName:
        c.frame.log.deleteTab(self.tabName)
    self.tabName = s.replace('_','') or ''
    c.frame.log.clearTab(self.tabName)</t>
<t tx="ekr.20060219183519"></t>
<t tx="ekr.20060220055415">def getModulesList (self):
    
    '''Return a list all (loaded) Python modules.'''
    
    aList = sys.modules.keys()
    aList.sort()
    return aList</t>
<t tx="ekr.20060220062710">def start (self,event=None,w=None):
    
    if w: self.widget = w
    else: w = self.widget
    
    # We wait until now to define these dicts so that more classes and objects will exist.
    if not self.objectDict:
        self.defineClassesDict()
        self.defineObjectDict()

    self.prefix = ''
    self.selection = g.app.gui.getTextSelection(w)
    self.selectedText = g.app.gui.getSelectedText(w)
    if self.getLeadinWord(w):
        self.autoCompleterStateHandler(event)</t>
<t tx="ekr.20060220085402">def chain (self):
    
    c = self.c ; w = self.widget
    word = g.app.gui.getSelectedText(w)
    old_obj = self.object
    if word and old_obj and self.hasAttr(old_obj,word):
        self.push(old_obj)
        self.object = obj = self.getAttr(old_obj,word)
        self.appendToKnownObjects(obj)
        self.leadinWord = word
        self.membersList = self.getMembersList(obj)
        self.appendTabName(word)
        self.extendSelection('.')
        i = g.app.gui.getInsertPoint(w)
        g.app.gui.setTextSelection(w,i,i,insert=i)
        # g.trace('chaining to',word,self.object)
        # Similar to start logic.
        self.prefix = ''
        self.selection = g.app.gui.getTextSelection(w)
        self.selectedText = g.app.gui.getSelectedText(w)
        if self.membersList:
            self.autoCompleterStateHandler(event=None)
            return
    self.extendSelection('.')
    self.finish()</t>
<t tx="ekr.20060220104902">def insertNormalChar (self,ch,keysym):
    
    k = self.k ; w = self.widget
    trace = self.trace and not g.app.unitTesting

    if ch in (string.letters + string.digits + '_' ):
        # Look ahead to see if the character completes any item.
        s = g.app.gui.getSelectedText(w) + ch
        tabList,common_prefix = g.itemsMatchingPrefixInList(
            s,self.membersList,matchEmptyPrefix=True)
        if tabList:
            # Add the character.
            self.tabList = tabList
            self.extendSelection(ch)
            s = g.app.gui.getSelectedText(w)
            if s.startswith(self.prefix):
                self.prefix = self.prefix + ch
            self.computeCompletionList()
    else:
        word = g.app.gui.getSelectedText(w)
        # g.trace(word)
        if keysym == 'parenleft':
            # Similar to chain logic.
            obj = self.object
            # g.trace(obj,word,self.hasAttr(obj,word))
            if self.hasAttr(obj,word):
                obj = self.getAttr(obj,word)
                self.push(self.object)
                self.object = obj
                self.leadinWord = word
                self.membersList = self.getMembersList(obj)
                if k.enable_calltips:
                    # This calls self.finish if the '(' is valid.
                    self.calltip(obj)
                    return
        self.extendSelection(ch)
        self.finish()</t>
<t tx="ekr.20060220110302">def calltip (self,obj=None):
    
    c = self.c ; w = self.widget
    removeCloseParen = True # Should be a user arg.
    
    isStringMethod = self.prevObjects and type(self.prevObjects[-1]) == types.StringType

    # g.trace(self.prevObjects)

    if isStringMethod:
        # A hack. String functions are builtins, and getargspec doesn't handle them.
        # Get the corresponding string function instead, and remove the s arg later.
        obj = getattr(string,obj.__name__)
    
    try:
        s1,s2,s3,s4 = inspect.getargspec(obj)
    except:
        g.es('inspect failed:',repr(obj))
        self.extendSelection('(')
        self.finish()
        return # Not a function.  Just '('.

    s = args = inspect.formatargspec(s1,s2,s3,s4)

    # Remove 'self' from s, but not from args.
    if g.match(s,1,'self,'):
        s = s[0] + s[6:].strip()
    elif g.match_word(s,1,'self'):
        s = s[0] + s[5:].strip()

    if isStringMethod:
        # Remove 's' from s *and* args.
        if g.match(s,1,'s,'):
            s = s[0] + s[3:]
            args = args[0] + args[3:]
        elif g.match_word(s,1,'s'):
            s = s[0] + s[2:]
            args = args[0] + args[2:]
            
    remove = removeCloseParen and len(s) &gt; 2
    if remove: s = s.rstrip(')')
    
    # Insert the text and remember what to select.
    if g.app.gui.hasSelection(w):
        i,j = g.app.gui.getSelectionRange(w)
    else:
        i = j = g.app.gui.getInsertPoint(w)
    w.insert(j,s)
    
    if remove:
        j1 = w.index('%s + 1c' % j)
        j2 = w.index('%s + %sc' % (j,len(s)))
    else:
        j1 = j2 = w.index('%s + 2c' % j)

    # End autocompletion mode, restoring the selection.
    self.finish()
    c.widgetWantsFocusNow(w)
    g.app.gui.setSelectionRange(w,j1,j2,insert=j2)
    
    # Put the status line last.
    c.frame.clearStatusLine()
    name = hasattr(obj,'__name__') and obj.__name__ or repr(obj)
    c.frame.putStatusLine('%s %s' % (name,args))</t>
<t tx="ekr.20060220132026">def info (self):
    
    c = self.c ; obj = self.object ; w = self.widget

    word = g.app.gui.getSelectedText(w)
     
    if not self.hasAttr(obj,word): return
    
    obj = self.getAttr(obj,word)
    doc = inspect.getdoc(obj)
    if not doc: return

    c.frame.log.clearTab('Info',wrap='word')
    g.es(doc,tabName='Info')</t>
<t tx="ekr.20060220132919">def prettyPrintDoc (self,s):
    
    c = self.c
    
    lines = [s.strip() for s in g.splitLines(s)]
    return ''.join(s)</t>
<t tx="ekr.20060220153557"></t>
<t tx="ekr.20060220155313"></t>
<t tx="ekr.20060221073238">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3586962
By: bwmulder

the open-find-dialog is broken. 
 
Error: 4 
TypeError Exception in Tk callback 
Function: &lt;function findButtonCallback at 0x04E219F0&gt; (type: &lt;type 'function'&gt;) 
Args: () 
Traceback (innermost last): 
File "C:\Python24\lib\site-packages\Pmw\Pmw_1_2\lib\PmwBase.py", line 1747, in __call__ 
return apply(self.func, args) 
TypeError: findButtonCallback() takes at least 1 argument (0 given) 
</t>
<t tx="ekr.20060221073409"></t>
<t tx="ekr.20060221104137">def findAnchor (self,w):
    
    i = g.app.gui.getInsertPoint(w)
    
    while w.get(i + '-1c') == '.' and w.compare(i,'&gt;','1.0'):
        i = w.index(i + '-2c wordstart')

    j = w.index(i+' wordend')
    word = w.get(i,j)
    
    # g.trace(i,j,repr(word),w.get(j))
    return j,word</t>
<t tx="ekr.20060221112937">def setObjectAndMembersList (self,word):
    
    c = self.c

    if word in ( "'",'"'):
        word = 'aString' # This is in the objectsDict.
        self.clear()
        self.push(self.object)
        self.object = 'aString'
        self.membersList = self.getMembersList(self.object)
    elif self.prevObjects:
        self.getObjectFromAttribute(word)
    elif word == 'self':
        self.completeSelf()
    else:
        obj = self.objectDict.get(word) or sys.modules.get(word)
        self.completeFromObject(obj)

    # g.trace(word,self.object,len(self.membersList))</t>
<t tx="ekr.20060221131304">def appendToKnownObjects (self,obj):
    
    if type(obj) in (types.InstanceType,types.ModuleType,types):
        if hasattr(obj,'__name__'):
            self.knownObjects[obj.__name__] = obj
            # g.trace('adding',obj.__name__)</t>
<t tx="ekr.20060221141535">def completeAllBindingsForWidget (self,w):
    
    k = self ; c = k.c
    
    for stroke in  k.bindingsDict.keys():
    
        def bindKeyCallback (event,k=k,stroke=stroke):
            return k.masterKeyHandler(event,stroke=stroke)
        bindStroke = k.tkbindingFromStroke(stroke)

        try:
            # g.trace(bindStroke,c.widget_name(w))
            w.bind(bindStroke,bindKeyCallback)
        except Exception:
            g.es_print('exception binding %s to %s' % (
                bindStroke,c.widget_name(w)),color='blue')</t>
<t tx="ekr.20060222082041">class classScannerClass:
    
    '''A class to find class definitions in a node or its parents.'''
    
    @others</t>
<t tx="ekr.20060222082041.1">def __init__ (self,c):
    
    self.c = c
    
    # Ignore @root for now:
    # self.start_in_doc = c.config.getBool('at_root_bodies_start_in_doc_mode')

    self.start_in_doc = False</t>
<t tx="ekr.20060222082041.2">def findParentClass (self,p):
    
    for p in p.self_and_parents_iter():
        className = self.findClass(p)
        if className:
            return p,className
    
    return None,None</t>
<t tx="ekr.20060222082041.3">def findClass (self,p):

    lines = g.splitLines(p.bodyString())
    inDoc = self.start_in_doc
    # g.trace(p.headString())
    for s in lines:
        if inDoc:
            if self.endsDoc(s):
                inDoc = False
        else:
            if self.startsDoc(s):
                inDoc = True
            else:
                # Not a perfect scan: a triple-string could start with 'class',
                # but perfection is not important.
                className = self.startsClass(s)
                if className: return className
    else:
        return None</t>
<t tx="ekr.20060222082041.4">def endsDoc (self,s):
    
    return s.startswith('@c')</t>
<t tx="ekr.20060222082041.5">def startsClass (self,s):
    
    if s.startswith('class'):
        i = 5
        i = g.skip_ws(s,i)
        j = g.skip_id(s,i)
        word = s[i:j]
        # g.trace(word)
        return word
    else:
        return None</t>
<t tx="ekr.20060222082041.6">def startsDoc (self,s):

    for s2 in ('@doc','@ ','@\n', '@r', '@\t'):
        if s.startswith(s2):
            return True
    else:
        return False</t>
<t tx="ekr.20060222083704">- Handle backspace across '.'
- . prints dict.keys and contents of lists.
- ! now toggles between brief and full listings.
- Make sure typing completion sticks.
- Start at the anchor (back chaining).
- Print number of matches for ... entries
- Print types in Autocomplete tab.
- Support ''.whatever()
- x? gives docstring.
- Dot chaining: remember previous object.
- Add f, frame, log, body to dicts.
- Define objectDict on first use so all objects are completely created.
- .! opens a list of Python modules.
- Recompute list if another . seen.
- Try python modules if leadinWord not found.
- Only enable for known languages. (Right now: python)
- Create database using inspect.
- Create enable-auto-completer-command and disable-auto-completer-command commands.
- Escape should retain present insert point and selection.
- Use space accept char, return as escape.</t>
<t tx="ekr.20060222092243">def push (self,obj):
    
    if obj is not None:
        self.prevObjects.append(obj)
        # g.trace(self.stackNames())
        
def pop (self):
    
    obj = self.prevObjects.pop()
    # g.trace(obj)
    return obj
    
def clear (self):
    
    self.prevObjects = []
    # g.trace(g.callers())
    
def stackNames (self):
    
    aList = []
    for z in self.prevObjects:
        if hasattr(z,'__name__'):
            aList.append(z.__name__)
        elif hasattr(z,'__class__'):
            aList.append(z.__class__.__name__)
        else:
            aList.append(str(z))
    return aList</t>
<t tx="ekr.20060223081914"># The values of self.attrDictDic are anonymous attrDict's.
# attrDicts: keys are strings, values are lists of strings.

def getAttr (self,obj,attr):
    
    '''Simulate getattr function, regardless of langauge.'''
    
    if self.language == 'python':
        return getattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList and attr

def hasAttr (self,obj,attr):
    
    '''Simulate hasattr function, regardless of langauge.'''

    if self.language == 'python':
        return hasattr(obj,attr)
    else:
        d = self.attrDictDict.get(self.language)
        aList = d.get(obj,[])
        return attr in aList</t>
<t tx="ekr.20060223085549">def defineClassesDict (self):
    
    # gc does not necessarily exist everywhere.
    try:
        import gc
    except ImportError:
        return {}

    d = {}
    for z in gc.get_objects():
        if type(z) == types.InstanceType:
            d[z.__class__.__name__] = z

    # g.printList(d.keys(),tag='Classes',sort=True)
    
    return d</t>
<t tx="ekr.20060223093117">class forgivingParserClass:
    
    '''A class to create a valid class instances from
    a class definition that may contain syntax errors.'''
    
    @others</t>
<t tx="ekr.20060223093117.1">def __init__ (self,c):
    
    self.c = c
    self.excludedTnodesList = []
    self.old_putBody = None # Set in parse for communication with newPutBody.</t>
<t tx="ekr.20060223093117.2">def parse (self,p):
    
    '''The top-level parser method.
    
    It patches c.atFileCommands.putBody, calls the forgiving parser and finally
    restores c.atFileCommands.putBody.'''
    
    c = self.c
    
    # Create an ivar for communication with newPutBody.
    self.old_putBody = c.atFileCommands.putBody
    
    # Override atFile.putBody.
    c.atFileCommands.putBody = self.newPutBody
    
    try:
        s = None
        s = self.forgivingParser(p)
    finally:
        c.atFileCommands.putBody = self.old_putBody
        return s</t>
<t tx="ekr.20060223093117.3">def forgivingParser (self,p):

    c = self.c ; root = p.copy()
    self.excludedTnodesList = []
    s = g.getScript(c,root,useSelectedText=False)
    while s:
        try:
            val = compiler.parse(s+'\n')
            break
        except (parser.ParserError,SyntaxError):
            fileName, n = g.getLastTracebackFileAndLineNumber()
            p = self.computeErrorNode(c,root,n,lines=g.splitLines(s))
            if not p or p == root:
                g.es_print('Syntax error in class node: can not continue')
                s = None ; break
            else:
                # g.es_print('Syntax error: deleting %s' % p.headString())
                self.excludedTnodesList.append(p.v.t)
                s = g.getScript(c,root,useSelectedText=False)
    return s or ''</t>
<t tx="ekr.20060223093117.4">def computeErrorNode (self,c,root,n,lines):

    '''The from c.goToLineNumber that applies to scripts.
    Unlike c.gotoLineNumberOpen, this function returns a position.'''

    if n == 1 or n &gt;= len(lines):
        return root

    vnodeName, junk, junk, junk, junk = c.convertLineToVnodeNameIndexLine(
        lines, n, root, scriptFind = True)

    if vnodeName:
        for p in root.self_and_subtree_iter():
            if p.matchHeadline(vnodeName):
                return p

    return None</t>
<t tx="ekr.20060223093117.5">def newPutBody (self,p,oneNodeOnly=False,fromString=''):

    if p.v.t in self.excludedTnodesList:
        pass
        # g.trace('ignoring',p.headString())
    else:
        self.old_putBody(p,oneNodeOnly,fromString)</t>
<t tx="ekr.20060223093358">def computeClassObjectFromString (self,className,s):

    try:
        # Add the the class definition to the present environment.
        exec s

        # Get the newly created object from the locals dict.
        theClass = locals().get(className)
        return theClass

    except Exception:
        if 1: # Could be a weird kind of user error.
            g.es_print('unexpected exception in computeProxyObject')
            g.es_exception()
        return None</t>
<t tx="ekr.20060223114802"></t>
<t tx="ekr.20060223114802.1">@ Warning:
This code passes None to the ctor as the value of all required args.
This may generate arbitrary exceptions and may be too dangerous.
A safer way would be to create a dummy ctor, but then we don't get any ivars.
@c

def createProxyObjectFromClass (self,className,theClass):
    
    '''Create a real instance object by instantiating theClass.
    
    This will create all ivars unless the ctor throws an exception.'''

    # g.trace(type(theClass))

    # Set args to the list of required arguments.
    args = inspect.getargs(theClass.__init__.im_func.func_code)
    args = args[0] ; n = len(args)-1
    args = [None for z in xrange(n)]
    try:
        obj = theClass(*args)
    except Exception:
        g.es_print('Warning: exception creating proxy for %s' % (className),color='red')
        def dummyCtor (self,*args,**keys):
            pass
        theClass.__init__ = dummyCtor
        obj = testClass()
    
    # Verify that it has all the proper attributes.
    # g.trace(g.listToString(dir(obj)))
    return obj</t>
<t tx="ekr.20060223120755">def parse (self):
    
    c = self.c ; p = c.currentPosition()
    parser = c.k.autoCompleter.forgivingParser
    
    p,className = self.findParentClass(p)
    if p and className:
        s = parser.parse(p)
        return className,s
    else:
        return None,None</t>
<t tx="ekr.20060223124014">def backup (self,word):
    
    prevObj = self.prevObjects and self.prevObjects[-1]

    if prevObj and self.hasAttr(prevObj,word):
        self.object = self.getAttr(prevObj,word)
        self.appendToKnownObjects(self.object)
        self.membersList = self.getMembersList(self.object)
    else:
        # No special support for 'self' here.
        # Don't clear the stack here!
        self.membersList = []
        self.object = None</t>
<t tx="ekr.20060223124014.2">def completeSelf (self):
    
    c = self.c ; p = c.currentPosition()

    obj = self.selfTnodesDict.get(p.v.t) # **Much** quicker than scanning.

    if not obj:
        className, s = self.classScanner.parse()
        if className and s:
            obj = self.selfObjectsDict.get(className)
            if not obj:
                theClass = self.computeClassObjectFromString(className,s)
                if theClass:
                    obj = self.createProxyObjectFromClass(className,theClass)
                    if obj:
                        self.selfObjectsDict [className] = obj
                        self.selfTnodesDict [p.v.t] = obj
    if obj:
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        # No further action possible or desirable.
        self.object = None
        self.clear()
        self.membersList = []</t>
<t tx="ekr.20060223124014.3">def completeFromObject (self,obj):

    if obj:
        self.appendToKnownObjects(obj)
        self.push(self.object)
        self.object = obj
        self.membersList = self.getMembersList(obj=obj)
    else:
        self.object = None
        self.clear()
        self.membersList = []</t>
</tnodes>
</leo_file>
