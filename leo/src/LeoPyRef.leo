<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="6990" clone_windows="0"/>
<globals body_outline_ratio="0.396226415094">
	<global_window_position top="10" left="464" height="901" width="776"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="EKR.20040519090151"><vh>Diary</vh>
<v t="ekr.20031218072017"><vh>@thin ../doc/leoDiary.txt</vh></v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20040701152235.15,ekr.20040701152235.16,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20031218072017.828,ekr.20031218072017.734,ekr.20040831092540,ekr.20031218072017.1863,"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2415"><vh> Scripts</vh>
<v t="ekr.20040327103735.2"><vh>Script Tools (leoGlobals.py)</vh>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20040321065415"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
</v>
<v t="EKR.20040502195524"><vh>@thin ../scripts/leoScripts.txt</vh></v>
<v t="EKR.20040502194930"><vh>@thin ../scripts/tangle_done.py</vh></v>
<v t="ekr.20031218072017.2537"><vh>@thin ../scripts/untangle_done.py</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,ekr.20031218072017.2865,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20031218072017.3001"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"
marks="ekr.20031218072017.1863,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20031218072017.3626"><vh>@thin leoColorPanel.py</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3652"><vh>@thin leoFontPanel.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3812"><vh>@thin leoPrefs.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3822"><vh>@thin leoTkinterColorPanels.py</vh></v>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3909"><vh>@thin leoTkinterFontPanel.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20031218072017.4122"><vh>@thin leoTkinterPrefs.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
<v t="ekr.20041006103243" a="TV"><vh>Talk</vh>
<v t="ekr.20041012112045"><vh>Bring Knuth book, business cards, python.leo, plugins.leo, cweb.leo, pythonGC.leo</vh></v>
<v t="ekr.20041012114739"><vh>Questions for audience</vh></v>
<v t="ekr.20041006104224"><vh>Intro</vh>
<v t="ekr.20041008104656"><vh>Summary</vh></v>
<v t="ekr.20041012111712"><vh>History</vh></v>
<v t="ekr.20041006110923"><vh>Will cover the highlights: please ask questions</vh></v>
</v>
<v t="ekr.20041006105206"><vh>Overview</vh>
<v t="ekr.20041006103243.2"><vh>1. Leo organizes everything as an outline</vh>
<v t="ekr.20041006103243.3"><vh>Outlines may contains huge amounts of data</vh></v>
<v t="ekr.20041006103243.4"><vh>Leo's nodes contain headlines and body text</vh></v>
<v t="ekr.20041007083344"><vh>Outlines create new objects and relationships between them</vh>
<v t="ekr.20041006104908.3"><vh>Similar to power of complex numbers</vh></v>
</v>
</v>
<v t="ekr.20041006103243.6"><vh>2. Outlines create derived files</vh>
<v t="ekr.20041006105206.2"><vh>Leo embeds structure within "flat" derived files</vh></v>
<v t="ekr.20041006110548"><vh>Structure is contained within OPTIONAL sentinel comments</vh></v>
</v>
<v t="ekr.20041006105206.1"><vh>3. Leo lets you organize projects as YOU want</vh></v>
<v t="ekr.20041006103243.45"><vh>4. Leo has a real memory</vh></v>
<v t="ekr.20041006111429"><vh>Leo is a superb scripting environment</vh>
<v t="ekr.20041006103243.46"><vh>Leo's Execute Script command understands directives and sections</vh></v>
<v t="ekr.20041006103243.47"><vh>Leo's @directives are valid in scripts</vh></v>
<v t="ekr.20041006103243.48"><vh>Leo's sections are vaiid in scripts</vh>
<v t="ekr.20041006103243.49"><vh>getFontSettings</vh></v>
<v t="ekr.20041006104908"><vh>&lt;&lt; print font of body pane &gt;&gt;</vh></v>
<v t="ekr.20041006104908.1"><vh>&lt;&lt; print font of log pane &gt;&gt;</vh></v>
<v t="ekr.20041006104908.2"><vh>&lt;&lt; print font of tree pane &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041006111429.1"><vh>Leo is a highly dynamic environment</vh></v>
</v>
<v t="ekr.20041006104224.3"><vh>Practice:  Look and feel</vh>
<v t="ekr.20041006103243.21"><vh>Outlines + noweb organize programs</vh>
<v t="ekr.20041006105452"><vh>Example 1: outlines organize methods</vh>
<v t="ekr.20031218072017.889"><vh>class position</vh>
<v t="ekr.20031218072017.890"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040228094013"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20040117170612"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__</vh></v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040310153624"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20040325142015"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="ekr.20040306212636"><vh>Getters</vh>
<v t="ekr.20040306210951"><vh> vnode proxies</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20040306212151"><vh>p.Extra Attributes</vh></v>
<v t="ekr.20040306220230"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20040306214401"><vh>p.Status bits</vh></v>
<v t="ekr.20040306220230.1"><vh>p.edit_text</vh></v>
<v t="ekr.20040323160302"><vh>p.directParents</vh></v>
<v t="ekr.20040326064330"><vh>p.childIndex</vh></v>
</v>
<v t="ekr.20040306214240.2"><vh>children</vh>
<v t="ekr.20040306214240.3"><vh>p.hasChildren</vh></v>
<v t="ekr.20040306212636.1"><vh>p.numberOfChildren</vh></v>
</v>
<v t="ekr.20040307104131.3"><vh>p.exists</vh></v>
<v t="ekr.20040306215548"><vh>p.findRoot</vh></v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20040227212621"><vh>p.hasX</vh>
<v t="ekr.20040227224946"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20040307104131.1"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040803111240"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20040803140033.4"><vh>isCurrentPosition</vh></v>
<v t="ekr.20040803140033.5"><vh>isRootPosition</vh></v>
</v>
<v t="ekr.20040306215056"><vh>p.isCloned</vh></v>
<v t="ekr.20040307104131.2"><vh>p.isRoot</vh></v>
<v t="ekr.20040117162509.16"><vh>p.isVisible</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20040305222924"><vh>Setters</vh>
<v t="ekr.20040306220634"><vh>vnode proxies</vh>
<v t="ekr.20040306220634.9"><vh> Status bits</vh></v>
<v t="ekr.20040306220634.8"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20040306220634.29"><vh>p.setSelection</vh></v>
<v t="ekr.20040306220634.31"><vh>p.trimTrailingLines</vh></v>
<v t="ekr.20040315034158"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20040315031401"><vh>Head &amp; body text (position)</vh>
<v t="ekr.20040315032503"><vh>p.appendStringToBody</vh></v>
<v t="ekr.20040305223522"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20040305222924.1"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20040305223225"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="ekr.20040315031445"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20040312015908"><vh>Visited bits</vh>
<v t="ekr.20040312015705"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="ekr.20040315023430"><vh>File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>moreBody</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.12"><vh>p.sortChildren</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040228094013.1"><vh>p.utils...</vh>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20040409203454"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20041006105452.1"><vh>The @others directive refers to all unnamed descendents</vh></v>
</v>
<v t="ekr.20041006105452.2"><vh>Example 2: sections clarify complex code</vh>
<v t="ekr.20041006103243.22"><vh>tree.select</vh>
<v t="ekr.20041006103243.23"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20041006103243.24"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20041006103243.25"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20041006103243.26"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20041006103243.27"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20041006105452.3"><vh>sections must be defined in a descendent node</vh></v>
<v t="ekr.20041006105452.4"><vh>sections work like macros</vh></v>
</v>
</v>
<v t="ekr.20041006105206.4"><vh>Outlines + noweb organize data</vh>
<v t="ekr.20041006103243.28"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="ekr.20041006103243.29"><vh>actionscript keywords</vh></v>
<v t="ekr.20041006103243.30"><vh>c# keywords</vh></v>
<v t="ekr.20041006103243.31"><vh>c/c++ keywords</vh></v>
<v t="ekr.20041006103243.32"><vh>css keywords</vh></v>
<v t="ekr.20041006103243.33"><vh>elisp keywords</vh></v>
<v t="ekr.20041006103243.34"><vh>html keywords</vh></v>
<v t="ekr.20041006103243.35"><vh>java keywords</vh></v>
<v t="ekr.20041006103243.36"><vh>latex keywords</vh></v>
<v t="ekr.20041006103243.37"><vh>pascal keywords</vh></v>
<v t="ekr.20041006103243.38"><vh>perl keywords</vh></v>
<v t="ekr.20041006103243.39"><vh>php keywords</vh></v>
<v t="ekr.20041006103243.40"><vh>python keywords</vh></v>
<v t="ekr.20041006103243.41"><vh>rapidq keywords</vh></v>
<v t="ekr.20041006103243.42"><vh>rebol keywords</vh></v>
<v t="ekr.20041006103243.43"><vh>shell keywords</vh></v>
<v t="ekr.20041006103243.44"><vh>tcl/tk keywords</vh></v>
</v>
</v>
<v t="ekr.20041012111712.1"><vh>Basic patterns &amp; anti-patterns</vh>
<v t="ekr.20041012111712.2"><vh>These rules have not changed since the very first hour</vh></v>
<v t="ekr.20041012111712.3"><vh>Use @others to refer to functions &amp; methods (order independent)</vh></v>
<v t="ekr.20041012111712.4"><vh>Use sections references to refer to code snippets (order dependent)</vh></v>
<v t="ekr.20041012111712.5"><vh>Don't use sections to define functions</vh></v>
<v t="ekr.20041012111712.6"><vh>Don't use @others for to refer to to code snippets</vh></v>
<v t="ekr.20041006103243.524"><vh>Don't use clones to share code</vh></v>
</v>
<v t="ekr.20041006103243.8"><vh>Clones allow multiple views of data within a SINGLE outline</vh>
<v t="ekr.20041012112259"><vh>Knuth calls these views "slices"</vh></v>
<v t="ekr.20041006111057"><vh>Example:  use clones to create task view</vh>
<v t="ekr.20040901061935"><vh>(Added option to disable left click logic in outline pane)</vh>
<v t="ekr.20040906081644"><vh>Notes: expanded_click_area</vh></v>
<v t="ekr.20040803072955.16"><vh>__init__</vh>
<v t="ekr.20040803072955.17"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20040803072955.18"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040803072955.19"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.20"><vh>createPermanentBindings</vh></v>
<v t="ekr.20040803072955.7"><vh>newBox</vh></v>
<v t="ekr.20040803072955.37"><vh>drawClickBox</vh>
<v t="ekr.20040803072955.38"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20041006111429"><vh>Leo is a superb scripting environment</vh>
<v t="ekr.20041006103243.46"><vh>Leo's Execute Script command understands directives and sections</vh></v>
<v t="ekr.20041006103243.47"><vh>Leo's @directives are valid in scripts</vh></v>
<v t="ekr.20041006103243.48"><vh>Leo's sections are vaiid in scripts</vh>
<v t="ekr.20041006103243.49"><vh>getFontSettings</vh></v>
<v t="ekr.20041006104908"><vh>&lt;&lt; print font of body pane &gt;&gt;</vh></v>
<v t="ekr.20041006104908.1"><vh>&lt;&lt; print font of log pane &gt;&gt;</vh></v>
<v t="ekr.20041006104908.2"><vh>&lt;&lt; print font of tree pane &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041006111429.1"><vh>Leo is a highly dynamic environment</vh></v>
</v>
<v t="ekr.20041006104224.6"><vh>Theory:  Why Leo is important</vh>
<v t="ekr.20041006103243.51"><vh>Outlines create a framework for metadata as well as data</vh>
<v t="ekr.20041006104908.3"><vh>Similar to power of complex numbers</vh></v>
</v>
<v t="ekr.20041006103243.52"><vh>Structure is  co-equal with program and data</vh>
<v t="ekr.20041006103243.54"><vh>Programs are outlines &amp; vice versa</vh>
<v t="ekr.20031218072017.889"><vh>class position</vh>
<v t="ekr.20031218072017.890"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040228094013"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20040117170612"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__</vh></v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040310153624"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20040325142015"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="ekr.20040306212636"><vh>Getters</vh>
<v t="ekr.20040306210951"><vh> vnode proxies</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20040306212151"><vh>p.Extra Attributes</vh></v>
<v t="ekr.20040306220230"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20040306214401"><vh>p.Status bits</vh></v>
<v t="ekr.20040306220230.1"><vh>p.edit_text</vh></v>
<v t="ekr.20040323160302"><vh>p.directParents</vh></v>
<v t="ekr.20040326064330"><vh>p.childIndex</vh></v>
</v>
<v t="ekr.20040306214240.2"><vh>children</vh>
<v t="ekr.20040306214240.3"><vh>p.hasChildren</vh></v>
<v t="ekr.20040306212636.1"><vh>p.numberOfChildren</vh></v>
</v>
<v t="ekr.20040307104131.3"><vh>p.exists</vh></v>
<v t="ekr.20040306215548"><vh>p.findRoot</vh></v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20040227212621"><vh>p.hasX</vh>
<v t="ekr.20040227224946"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20040307104131.1"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040803111240"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20040803140033.4"><vh>isCurrentPosition</vh></v>
<v t="ekr.20040803140033.5"><vh>isRootPosition</vh></v>
</v>
<v t="ekr.20040306215056"><vh>p.isCloned</vh></v>
<v t="ekr.20040307104131.2"><vh>p.isRoot</vh></v>
<v t="ekr.20040117162509.16"><vh>p.isVisible</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20040305222924"><vh>Setters</vh>
<v t="ekr.20040306220634"><vh>vnode proxies</vh>
<v t="ekr.20040306220634.9"><vh> Status bits</vh></v>
<v t="ekr.20040306220634.8"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20040306220634.29"><vh>p.setSelection</vh></v>
<v t="ekr.20040306220634.31"><vh>p.trimTrailingLines</vh></v>
<v t="ekr.20040315034158"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20040315031401"><vh>Head &amp; body text (position)</vh>
<v t="ekr.20040315032503"><vh>p.appendStringToBody</vh></v>
<v t="ekr.20040305223522"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20040305222924.1"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20040305223225"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="ekr.20040315031445"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20040312015908"><vh>Visited bits</vh>
<v t="ekr.20040312015705"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="ekr.20040315023430"><vh>File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>moreBody</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.12"><vh>p.sortChildren</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040228094013.1"><vh>p.utils...</vh>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20040409203454"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
</v>
</v>
<v t="ekr.20041006103243.179"><vh>Data are outlines &amp; vice versa</vh>
<v t="ekr.20041012095746"><vh>Unit testing...</vh>
<v t="ekr.20041012095746.2"><vh>Unit Tests</vh>
<v t="ekr.20041012095746.3"><vh>Perfect Import tests</vh>
<v t="ekr.20041012095746.4"><vh>@test inserting a line: no trailing newline</vh>
<v t="ekr.20041012095746.5"><vh>-input</vh></v>
<v t="ekr.20041012095746.6"><vh>-input-after</vh></v>
<v t="ekr.20041012095746.7"><vh>-output-sent</vh></v>
<v t="ekr.20041012095746.8"><vh>-output-after-sent</vh></v>
<v t="ekr.20041012095746.9"><vh>-i_lines</vh></v>
<v t="ekr.20041012095746.10"><vh>-j_lines</vh></v>
<v t="ekr.20041012095746.11"><vh>-result</vh></v>
</v>
<v t="ekr.20041012095746.12"><vh>@test replace one line</vh>
<v t="ekr.20041012095746.13"><vh>-input</vh></v>
<v t="ekr.20041012095746.14"><vh>-input-after</vh></v>
<v t="ekr.20041012095746.15"><vh>-output-sent</vh></v>
<v t="ekr.20041012095746.16"><vh>-output-after-sent</vh></v>
<v t="ekr.20041012095746.17"><vh>-i_lines</vh></v>
<v t="ekr.20041012095746.18"><vh>-j_lines</vh></v>
<v t="ekr.20041012095746.19"><vh>-result</vh></v>
</v>
<v t="ekr.20041012095746.20"><vh>@test replace multiple lines</vh>
<v t="ekr.20041012095746.21"><vh>-input</vh></v>
<v t="ekr.20041012095746.22"><vh>-input-after</vh></v>
<v t="ekr.20041012095746.23"><vh>-output-sent</vh></v>
<v t="ekr.20041012095746.24"><vh>-output-after-sent</vh></v>
<v t="ekr.20041012095746.25"><vh>-i_lines</vh></v>
<v t="ekr.20041012095746.26"><vh>-j_lines</vh></v>
<v t="ekr.20041012095746.27"><vh>-result</vh></v>
</v>
<v t="ekr.20041012095746.28"><vh>@test replace across sentinel blocks: Succeeds ONLY when ignoring sentinels</vh>
<v t="ekr.20041012095746.29"><vh>-input</vh>
<v t="ekr.20041012095746.30"><vh>Node 1</vh></v>
<v t="ekr.20041012095746.31"><vh>Node 2</vh></v>
</v>
<v t="ekr.20041012095746.32"><vh>-input-after</vh>
<v t="ekr.20041012095746.33"><vh>Node 1</vh></v>
<v t="ekr.20041012095746.34"><vh>Node 2</vh></v>
</v>
<v t="ekr.20041012095746.35"><vh>-output-sent</vh></v>
<v t="ekr.20041012095746.36"><vh>-i_lines</vh></v>
<v t="ekr.20041012095746.37"><vh>-j_lines</vh></v>
<v t="ekr.20041012095746.38"><vh>-output-after-sent</vh></v>
<v t="ekr.20041012095746.39"><vh>-result</vh></v>
</v>
</v>
<v t="ekr.20041012095746.40"><vh>Import/Export tests</vh>
<v t="ekr.20041012095746.41"><vh>@suite Import tests</vh></v>
<v t="ekr.20041012095746.42"><vh>@suite Export tests</vh></v>
<v t="ekr.20041012095746.43"><vh>importTests</vh>
<v t="ekr.20041012095746.44"><vh>tempNode</vh></v>
<v t="ekr.20041012095746.45"><vh>importAtRoot</vh>
<v t="ekr.20041012095746.46"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.47"><vh>importDerivedFile</vh>
<v t="ekr.20041012095746.48"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.49"><vh>importNowebFiles</vh>
<v t="ekr.20041012095746.50"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.51"><vh>importFlattenedOutline</vh>
<v t="ekr.20041012095746.52"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.53"><vh>importCWEBFiles</vh>
<v t="ekr.20041012095746.54"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.55"><vh>removeSentinels</vh>
<v t="ekr.20041012095746.56"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.57"><vh>importAtFile</vh>
<v t="ekr.20041012095746.58"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20041012095746.59"><vh>exportTests</vh>
<v t="ekr.20041012095746.60"><vh>tempNode</vh></v>
<v t="ekr.20041012095746.61"><vh>exportHeadlines</vh>
<v t="ekr.20041012095746.62"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.63"><vh>flattenOutline</vh>
<v t="ekr.20041012095746.64"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.65"><vh>weave</vh>
<v t="ekr.20041012095746.66"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.67"><vh>outlineToNoweb</vh>
<v t="ekr.20041012095746.68"><vh>dialog</vh></v>
</v>
<v t="ekr.20041012095746.69"><vh>outlineToCWEB</vh>
<v t="ekr.20041012095746.70"><vh>dialog</vh></v>
</v>
</v>
</v>
<v t="ekr.20041012095746.71"><vh>Test Leo files...</vh>
<v t="ekr.20041012095746.72"><vh>@test minimalLeoFile.leo</vh></v>
<v t="ekr.20041012095746.73"><vh>@test minimalLeoFile2.leo</vh></v>
<v t="ekr.20041012095746.74"><vh>@test minimalLeoFile3.leo</vh></v>
<v t="ekr.20041012095746.75"><vh>@test test.leo</vh></v>
<v t="ekr.20041012095746.76"><vh>@test leoDist.leo</vh></v>
<v t="ekr.20041012095746.77"><vh>@test LeoPy.leo</vh></v>
<v t="ekr.20041012095746.78"><vh>@test leoPlugins.leo</vh></v>
<v t="ekr.20041012095746.79"><vh>@test LeoDocs.leo</vh></v>
<v t="ekr.20041012095746.80"><vh>@test line endings of Linux scripts</vh></v>
</v>
<v t="ekr.20041012095746.81"><vh>Non-file tests</vh>
<v t="ekr.20041012095746.82"><vh>@suite Edit body tests</vh>
<v t="ekr.20041012095746.83"><vh>editBodyTests</vh>
<v t="ekr.20041012095746.84"><vh>tempNode</vh></v>
<v t="ekr.20041012095746.85"><vh>extractSection</vh>
<v t="ekr.20041012095746.86"><vh>before</vh></v>
<v t="ekr.20041012095746.87"><vh>after</vh>
<v t="ekr.20041012095746.88"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20041012095746.89"><vh>selection</vh></v>
</v>
<v t="ekr.20041012095746.90"><vh>indentBody</vh>
<v t="ekr.20041012095746.91"><vh>before</vh></v>
<v t="ekr.20041012095746.92"><vh>after</vh></v>
<v t="ekr.20041012095746.93"><vh>selection</vh></v>
</v>
<v t="ekr.20041012095746.94"><vh>dedentBody</vh>
<v t="ekr.20041012095746.95"><vh>before</vh></v>
<v t="ekr.20041012095746.96"><vh>after</vh></v>
<v t="ekr.20041012095746.97"><vh>selection</vh></v>
</v>
</v>
</v>
<v t="ekr.20041012095746.98"><vh>@suite Reformat Paragraph Tests</vh>
<v t="ekr.20041012095746.99"><vh>What I did</vh></v>
<v t="ekr.20041012095746.100"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20041012095746.101"><vh>tempNode</vh></v>
<v t="ekr.20041012095746.102"><vh>testNoTrailingNewline</vh>
<v t="ekr.20041012095746.103"><vh>before</vh></v>
<v t="ekr.20041012095746.104"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.105"><vh>testTrailingNewline</vh>
<v t="ekr.20041012095746.106"><vh>before</vh></v>
<v t="ekr.20041012095746.107"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.108"><vh>testMixedLineLengths</vh>
<v t="ekr.20041012095746.109"><vh>before</vh></v>
<v t="ekr.20041012095746.110"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.111"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20041012095746.112"><vh>before</vh></v>
<v t="ekr.20041012095746.113"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.114"><vh>testNoChangeRequired</vh>
<v t="ekr.20041012095746.115"><vh>before</vh></v>
<v t="ekr.20041012095746.116"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.117"><vh>testHonorLeadingWS</vh>
<v t="ekr.20041012095746.118"><vh>before</vh></v>
<v t="ekr.20041012095746.119"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.120"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20041012095746.121"><vh>before</vh></v>
<v t="ekr.20041012095746.122"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.123"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20041012095746.124"><vh>before</vh></v>
<v t="ekr.20041012095746.125"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.126"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20041012095746.127"><vh>before</vh></v>
<v t="ekr.20041012095746.128"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.129"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20041012095746.130"><vh>before</vh></v>
<v t="ekr.20041012095746.131"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.132"><vh>testMultiParagraph</vh>
<v t="ekr.20041012095746.133"><vh>before</vh></v>
<v t="ekr.20041012095746.134"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.135"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20041012095746.136"><vh>before</vh></v>
<v t="ekr.20041012095746.137"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.138"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20041012095746.139"><vh>before</vh></v>
<v t="ekr.20041012095746.140"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.141"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20041012095746.142"><vh>before</vh></v>
<v t="ekr.20041012095746.143"><vh>after</vh></v>
</v>
</v>
</v>
<v t="ekr.20041012095746.144"><vh>@test c iters</vh>
<v t="ekr.20041012095746.145"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="ekr.20041012095746.146"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20041012095746.147"><vh>@test changing headline marks descendent @thin nodes dirty</vh>
<v t="ekr.20041012095746.148"><vh>bogus</vh></v>
</v>
<v t="ekr.20041012095746.149"><vh>@test CheckOutline</vh></v>
<v t="ekr.20041012095746.150"><vh>@test p.setBodyStringOrPane</vh>
<v t="ekr.20041012095746.151"><vh>child</vh></v>
</v>
<v t="ekr.20041012095746.152"><vh>@test Pretty Print command</vh>
<v t="ekr.20041012095746.153"><vh>tempNode</vh></v>
<v t="ekr.20041012095746.154"><vh>before</vh></v>
<v t="ekr.20041012095746.155"><vh>after</vh></v>
</v>
<v t="ekr.20041012095746.156"><vh>@test bogus tnodeList doesn't corrupt @thin nodes</vh></v>
<v t="ekr.20041012095746.157"><vh>@test g.cantImport returns None</vh></v>
<v t="ekr.20041012095746.158"><vh>atFileTests...</vh>
<v t="ekr.20041012095746.159"><vh>@test @file no newline</vh>
<v t="ekr.20041012095746.160"><vh>@@file</vh></v>
<v t="ekr.20041012095746.161"><vh>Output</vh></v>
</v>
<v t="ekr.20041012095746.162"><vh>@test @file one newline</vh>
<v t="ekr.20041012095746.163"><vh>@@file</vh></v>
<v t="ekr.20041012095746.164"><vh>Output</vh></v>
</v>
<v t="ekr.20041012095746.165"><vh>@test @file two newlines</vh>
<v t="ekr.20041012095746.166"><vh>@@file</vh></v>
<v t="ekr.20041012095746.167"><vh>Output</vh></v>
</v>
<v t="ekr.20041012095746.168"><vh>@test @thin</vh>
<v t="ekr.20041012095746.169"><vh>@@thin</vh></v>
<v t="ekr.20041012095746.170"><vh>Output</vh></v>
</v>
</v>
<v t="ekr.20041012095746.171"><vh>Colorizer tests...</vh>
<v t="ekr.20041012095746.172"><vh>@test @comment after @language plain</vh>
<v t="ekr.20041012095746.173"><vh>Test</vh></v>
</v>
<v t="ekr.20041012095746.174"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20041012095746.175"><vh>Actionscript</vh></v>
</v>
<v t="ekr.20041012095746.176"><vh>@test colorizer C</vh>
<v t="ekr.20041012095746.177"><vh>C</vh></v>
</v>
<v t="ekr.20041012095746.178"><vh>@test colorizer C#</vh>
<v t="ekr.20041012095746.179"><vh>C#</vh></v>
</v>
<v t="ekr.20041012095746.180"><vh>@test colorizer css</vh>
<v t="ekr.20041012095746.181"><vh>css</vh></v>
</v>
<v t="ekr.20041012095746.182"><vh>@test colorizer CWEB</vh>
<v t="ekr.20041012095746.183"><vh>CWEB</vh>
<v t="ekr.20041012095746.184"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041012095746.185"><vh>@test colorizer elisp</vh>
<v t="ekr.20041012095746.186"><vh>elisp</vh></v>
</v>
<v t="ekr.20041012095746.187"><vh>@test colorizer HTML string bug</vh>
<v t="ekr.20041012095746.188"><vh>String bug in html</vh></v>
</v>
<v t="ekr.20041012095746.189"><vh>@test colorizer HTML1</vh>
<v t="ekr.20041012095746.190"><vh>HTML1</vh></v>
</v>
<v t="ekr.20041012095746.191"><vh>@test colorizer HTML2</vh>
<v t="ekr.20041012095746.192"><vh>HTML2</vh></v>
</v>
<v t="ekr.20041012095746.193"><vh>@test colorizer LaTex</vh>
<v t="ekr.20041012095746.194"><vh>LaTex</vh></v>
</v>
<v t="ekr.20041012095746.195"><vh>@test colorizer mixed</vh>
<v t="ekr.20041012095746.196"><vh>Mixed</vh></v>
</v>
<v t="ekr.20041012095746.197"><vh>@test colorizer PHP</vh>
<v t="ekr.20041012095746.198"><vh>PHP</vh></v>
</v>
<v t="ekr.20041012095746.199"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="ekr.20041012095746.200"><vh>python.xml</vh>
<v t="ekr.20041012095746.201"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="ekr.20041012095746.202"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="ekr.20041012095746.203"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="ekr.20041012095746.204"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="ekr.20041012095746.205"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="ekr.20041012095746.206"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="ekr.20041012095746.207"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="ekr.20041012095746.208"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="ekr.20041012095746.209"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20041012095746.210"><vh>@test colorizer Python1</vh>
<v t="ekr.20041012095746.211"><vh>Python1</vh></v>
</v>
<v t="ekr.20041012095746.212"><vh>@test colorizer Python2</vh>
<v t="ekr.20041012095746.213"><vh>Python2</vh></v>
</v>
<v t="ekr.20041012095746.214"><vh>@test colorizer rapidq</vh>
<v t="ekr.20041012095746.215"><vh>rapidq</vh></v>
</v>
<v t="ekr.20041012095746.216"><vh>@test colorizer Rebol</vh>
<v t="ekr.20041012095746.217"><vh>Rebol</vh></v>
</v>
<v t="ekr.20041012095746.218"><vh>@test colorizer shell</vh>
<v t="ekr.20041012095746.219"><vh>shell</vh></v>
</v>
<v t="ekr.20041012095746.220"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="ekr.20041012095746.221"><vh>tex.xml</vh>
<v t="ekr.20041012095746.222"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="ekr.20041012095746.223"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041012095746.224"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20041012095746.225"><vh>wikiTest1</vh></v>
</v>
<v t="ekr.20041012095746.226"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20041012095746.227"><vh>wikiTest2</vh></v>
</v>
<v t="ekr.20041012095746.228"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20041012095746.229"><vh>wikiTest3</vh></v>
</v>
</v>
<v t="ekr.20041012095746.230"><vh>Mini tests...</vh>
<v t="ekr.20041012095746.231"><vh>@test p.t == p.v.t</vh></v>
<v t="ekr.20041012095746.232"><vh>@test python keywords</vh></v>
<v t="ekr.20041012095746.233"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20041012095746.234"><vh>File Conversion</vh>
<v t="ekr.20041012095746.235"><vh>moreHead</vh></v>
<v t="ekr.20041012095746.236"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20041012095746.237"><vh>inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20041012095746.238"><vh>parent</vh>
<v t="ekr.20041012095746.239"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
<v t="ekr.20041012095746.238"><vh>parent</vh>
<v t="ekr.20041012095746.239"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
</v>
<v t="ekr.20041012095746.240"><vh>@test consistency of p.v.t.vnodeList &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20041012095746.241"><vh>@test that cloned nodes actually share subtrees</vh></v>
<v t="ekr.20041012095746.242"><vh>@test batch mode</vh>
<v t="ekr.20041012095746.243"><vh>removeFile</vh></v>
</v>
</v>
<v t="ekr.20041012095746.244"><vh>Position tests...</vh>
<v t="ekr.20041012095746.245"><vh>@test p.iters and v.iters</vh>
<v t="ekr.20041012095746.246"><vh>child1</vh>
<v t="ekr.20041012095746.247"><vh>a</vh>
<v t="ekr.20041012095746.248"><vh>b</vh></v>
</v>
<v t="ekr.20041012095746.249"><vh>c</vh></v>
<v t="ekr.20041012095746.247"><vh>a</vh>
<v t="ekr.20041012095746.248"><vh>b</vh></v>
</v>
<v t="ekr.20041012095746.250"><vh>d</vh>
<v t="ekr.20041012095746.251"><vh>e</vh></v>
</v>
</v>
<v t="ekr.20041012095746.252"><vh>child2</vh></v>
<v t="ekr.20041012095746.253"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="ekr.20041012095746.254"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="ekr.20041012095746.255"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20041012095746.256"><vh>@test p.comparisons</vh></v>
<v t="ekr.20041012095746.257"><vh>@test that clones share subtrees</vh></v>
<v t="ekr.20041012095746.258"><vh>@test consistency of c.allNodes_iter() and p.ThreadNext()</vh></v>
<v t="ekr.20041012095746.259"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20041012095746.260"><vh>@test consistency of level</vh></v>
<v t="ekr.20041012095746.261"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20041012095746.262"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20041012095746.263"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20041012095746.264"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20041012095746.265"><vh>@test consistency of tnodeListAndParents</vh></v>
<v t="ekr.20041012095746.266"><vh>@test hasNextBack</vh></v>
<v t="ekr.20041012095746.267"><vh>@test hasParentChild</vh></v>
<v t="ekr.20041012095746.268"><vh>@test hasThreadNextBack</vh></v>
<v t="ekr.20041012095746.269"><vh>@test vnode list</vh></v>
<v t="ekr.20041012095746.270"><vh>@test isAncestorOf</vh></v>
</v>
<v t="ekr.20041012095746.271"><vh>Syntax Checks...</vh>
<v t="ekr.20041012095746.272"><vh>@test checkPythonCode (bad syntax)</vh>
<v t="ekr.20041012095746.273"><vh>Check Syntax data (bad)</vh></v>
</v>
<v t="ekr.20041012095746.274"><vh>@test checkPythonCode (bad tabnanny)</vh>
<v t="ekr.20041012095746.275"><vh>TabNanny data (bad)</vh></v>
</v>
<v t="ekr.20041012095746.276"><vh>disabled @test checkAllPythonCode</vh></v>
</v>
</v>
<v t="ekr.20041012095746.277"><vh>@suite run all doctests in leo*.py</vh></v>
<v t="ekr.20041012095746.278"><vh>Plugins tests</vh>
<v t="ekr.20041012095746.279"><vh>@suite test syntax of all plugins correctly</vh>
<v t="ekr.20041012095746.280"><vh>class parseFileTestCase</vh>
<v t="ekr.20041012095746.281"><vh>__init__</vh></v>
<v t="ekr.20041012095746.282"><vh>runTest</vh></v>
<v t="ekr.20041012095746.283"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20041012095746.284"><vh>(dangerous) @suite run unitTest method of plugins</vh>
<v t="ekr.20041012095746.285"><vh>class runPluginTestCase</vh>
<v t="ekr.20041012095746.286"><vh>__init__</vh></v>
<v t="ekr.20041012095746.287"><vh>runTest</vh></v>
<v t="ekr.20041012095746.288"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20041012095746.289"><vh>@test plugins/nodenavigator.py</vh></v>
</v>
<v t="ekr.20041012095746.290"><vh>Unfinished tests...</vh>
<v t="ekr.20041012095746.291"><vh>Outline tests (Sometimes fails)</vh>
<v t="ekr.20041012095746.292"><vh>test of p.copyTreeAfter and p.copyTreeFromSelfTo</vh>
<v t="ekr.20041012095746.293"><vh>root1</vh>
<v t="ekr.20041012095746.294"><vh>a</vh>
<v t="ekr.20041012095746.295"><vh>c</vh>
<v t="ekr.20041012095746.296"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20041012095746.297"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20041012095746.298"><vh>Manual test of testUtils.replaceOutline</vh>
<v t="ekr.20041012095746.299"><vh>outline1</vh>
<v t="ekr.20041012095746.300"><vh>a</vh></v>
</v>
<v t="ekr.20041012095746.301"><vh>outline2</vh>
<v t="ekr.20041012095746.302"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20041012095746.303"><vh>testUtils.replaceOutline</vh></v>
<v t="ekr.20041012095746.304"><vh>@@ suite Outline/Undo tests</vh>
<v t="ekr.20041012095746.305"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20041012095746.306"><vh>class outlineTestCase</vh>
<v t="ekr.20041012095746.307"><vh>__init__</vh></v>
<v t="ekr.20041012095746.308"><vh>outlineCommand</vh></v>
<v t="ekr.20041012095746.309"><vh>runTest</vh></v>
<v t="ekr.20041012095746.310"><vh>setUp</vh></v>
<v t="ekr.20041012095746.311"><vh>tearDown</vh></v>
<v t="ekr.20041012095746.312"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20041012095746.313"><vh>outlineTests</vh>
<v t="ekr.20041012095746.314"><vh>moveOutlineDown</vh>
<v t="ekr.20041012095746.315"><vh>before</vh>
<v t="ekr.20041012095746.316"><vh>a</vh></v>
<v t="ekr.20041012095746.317"><vh>move</vh></v>
<v t="ekr.20041012095746.318"><vh>b</vh></v>
</v>
<v t="ekr.20041012095746.319"><vh>after</vh>
<v t="ekr.20041012095746.320"><vh>a</vh></v>
<v t="ekr.20041012095746.321"><vh>b</vh></v>
<v t="ekr.20041012095746.322"><vh>move</vh></v>
</v>
<v t="ekr.20041012095746.323"><vh>ref</vh>
<v t="ekr.20041012095746.324"><vh>a</vh></v>
<v t="ekr.20041012095746.325"><vh>move</vh></v>
<v t="ekr.20041012095746.326"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20041012095746.327"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20041012095746.328"><vh>moveOutlineRight</vh></v>
<v t="ekr.20041012095746.329"><vh>moveOutlineUp</vh></v>
</v>
</v>
<v t="ekr.20041012095746.330"><vh>Find Command tests...(Not finished)</vh>
<v t="ekr.20041012095746.331"><vh>@suite Find sommands tests</vh>
<v t="ekr.20041012095746.332"><vh>class findCommandTestCase</vh>
<v t="ekr.20041012095746.333"><vh>setUp</vh></v>
<v t="ekr.20041012095746.334"><vh>testFindCommand</vh></v>
<v t="ekr.20041012095746.335"><vh>testFindWordCommand</vh></v>
<v t="ekr.20041012095746.336"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20041012095746.337"><vh>findTests</vh></v>
</v>
</v>
</v>
<v t="ekr.20041012095746.338"><vh>Do @test</vh></v>
<v t="ekr.20041012095746.339"><vh>@button unit test</vh></v>
</v>
</v>
</v>
<v t="ekr.20041006110307"><vh>Structure is an official part of the language</vh>
<v t="ekr.20041006110307.1"><vh>Nodes inherit directives from ancestor nodes</vh></v>
<v t="ekr.20041006110307.2"><vh>Sections must be defined in descendent nodes</vh></v>
</v>
</v>
<v t="ekr.20041007061255"><vh>How Leo uses Python</vh>
<v t="ekr.20041007061834"><vh>1. Clarity of design</vh></v>
<v t="ekr.20041007061834.1"><vh>2. Speed of development</vh></v>
<v t="ekr.20041007061834.2"><vh>3. Safety</vh></v>
<v t="ekr.20041007061834.3"><vh>4. Specifics</vh>
<v t="ekr.20041007061255.1"><vh>Loading plugins</vh>
<v t="ekr.20031218072017.3440"><vh>loadHandlers</vh>
<v t="ekr.20031218072017.3441"><vh>&lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2278"><vh>g,importFromPath</vh></v>
</v>
<v t="ekr.20041007061255.2"><vh>Overriding methods and classes</vh>
<v t="ekr.20031218072017.3126"><vh>g,funcToMethod</vh></v>
</v>
<v t="ekr.20041007061255.3"><vh>Scripting</vh>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines near the error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041007061834.4"><vh>Modules, modules, modules</vh></v>
</v>
</v>
<v t="ekr.20041006103243.519"><vh>Patterns: The World According to Leo</vh>
<v t="ekr.20041006110732"><vh>You can't do this in Emacs</vh></v>
<v t="ekr.20041012111712.1"><vh>Basic patterns &amp; anti-patterns</vh>
<v t="ekr.20041012111712.2"><vh>These rules have not changed since the very first hour</vh></v>
<v t="ekr.20041012111712.3"><vh>Use @others to refer to functions &amp; methods (order independent)</vh></v>
<v t="ekr.20041012111712.4"><vh>Use sections references to refer to code snippets (order dependent)</vh></v>
<v t="ekr.20041012111712.5"><vh>Don't use sections to define functions</vh></v>
<v t="ekr.20041012111712.6"><vh>Don't use @others for to refer to to code snippets</vh></v>
<v t="ekr.20041006103243.524"><vh>Don't use clones to share code</vh></v>
</v>
<v t="ekr.20041006103243.521"><vh>Use headlines to hold metadata</vh></v>
<v t="ekr.20041006103243.522"><vh>Clone patterns</vh>
<v t="ekr.20041006103243.523"><vh>Organize coding tasks with clones and task headlines</vh></v>
<v t="ekr.20041006103243.524"><vh>Don't use clones to share code</vh></v>
</v>
<v t="ekr.20041012111951"><vh>Other patterns...</vh>
<v t="ekr.20041006103243.525"><vh>Organizing patterns</vh>
<v t="ekr.20041006103243.526"><vh>Organize files with headlines</vh></v>
<v t="ekr.20041006103243.527"><vh>Organize classes with headlines</vh></v>
<v t="ekr.20041006103243.528"><vh>Organize methods with headlines</vh></v>
<v t="ekr.20041006103243.529"><vh>Organize project notes with headlines</vh></v>
<v t="ekr.20041006103243.530"><vh>Organize tasks with headlines</vh></v>
</v>
<v t="ekr.20041006103243.531"><vh>Coding patterns 8</vh>
<v t="ekr.20041006103243.532"><vh>Use @others to avoid naming sections</vh></v>
<v t="ekr.20041006103243.533"><vh>Use sections to clarify code</vh></v>
<v t="ekr.20041006103243.534"><vh>Use sections to highlight if statements</vh></v>
<v t="ekr.20041006103243.535"><vh>Use sections to highlight while statements</vh></v>
<v t="ekr.20041006103243.536"><vh>Use sections to make methods fit on a page</vh></v>
<v t="ekr.20041006103243.524"><vh>Don't use clones to share code</vh></v>
<v t="ekr.20041006103243.537"><vh>Use sections to show patterns in code: </vh></v>
<v t="ekr.20041006103243.538"><vh>Use nested @others to put multiple classes in a file</vh></v>
</v>
<v t="ekr.20041006103243.539"><vh>Refactoring pattenrs</vh>
<v t="ekr.20041006103243.540"><vh>Nodes are methods:  moving methods</vh></v>
<v t="ekr.20041006103243.541"><vh>Use clones to abstract code for timeit</vh></v>
</v>
<v t="ekr.20041006103243.542"><vh>Pattens of good style</vh></v>
<v t="ekr.20041006103243.543"><vh>Patterns of bad style</vh></v>
<v t="ekr.20041006103243.544"><vh>Project management patterns</vh></v>
<v t="ekr.20041006103243.545"><vh>Plugins patterns 3</vh>
<v t="ekr.20041006103243.546"><vh>Use plugins to override Leo's internals</vh></v>
<v t="ekr.20041006103243.547"><vh>Use plugins to add funtionality</vh></v>
<v t="ekr.20041006103243.548"><vh>Use g.app.scriptData to communicate with scripts</vh></v>
</v>
<v t="ekr.20041006103243.549"><vh>Script patterns 2</vh>
<v t="ekr.20041006103243.550"><vh>import leoGlobals as g to access Leo's utility funtions</vh></v>
<v t="ekr.20041006103243.551"><vh>Use the script button to bring data to scripts (or is it scripts to data?)</vh></v>
</v>
<v t="ekr.20041006103243.552"><vh>Find/Change patterns 1</vh>
<v t="ekr.20041006103243.553"><vh>Use sciprt find/replace for complex interactive searches</vh></v>
</v>
<v t="ekr.20041006103243.554"><vh>Unit test patters  11</vh>
<v t="ekr.20041006103243.555"><vh>Use g.app.unitTestDict to communicate with unit tests</vh></v>
<v t="ekr.20041006103243.551"><vh>Use the script button to bring data to scripts (or is it scripts to data?)</vh></v>
<v t="ekr.20041006103243.521"><vh>Use headlines to hold metadata</vh></v>
<v t="ekr.20041006103243.556"><vh>Use scripts instead of unit test classes</vh></v>
<v t="ekr.20041006103243.557"><vh>@test</vh></v>
<v t="ekr.20041006103243.558"><vh>@suite</vh></v>
<v t="ekr.20041006103243.559"><vh>@suite run all doctests</vh></v>
<v t="ekr.20041006103243.560"><vh>Use try:finally instead of tearDown</vh></v>
<v t="ekr.20041006103243.561"><vh>Use children to hold test data</vh></v>
<v t="ekr.20041006103243.562"><vh>Use children to hold intermediate results</vh></v>
<v t="ekr.20041006103243.563"><vh>Use functions/methods for common setup code</vh></v>
</v>
</v>
</v>
<v t="ekr.20041007081237.1"><vh>Leo and Literate Programming</vh>
<v t="ekr.20041007081237.2"><vh>Why I like Literate Programming</vh>
<v t="ekr.20041007081237.3"><vh>1. LP creates a new design dimension</vh>
<v t="ekr.20031218072017.889"><vh>class position</vh>
<v t="ekr.20031218072017.890"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040228094013"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20040117170612"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__</vh></v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040310153624"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20040325142015"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="ekr.20040306212636"><vh>Getters</vh>
<v t="ekr.20040306210951"><vh> vnode proxies</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20040306212151"><vh>p.Extra Attributes</vh></v>
<v t="ekr.20040306220230"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20040306214401"><vh>p.Status bits</vh></v>
<v t="ekr.20040306220230.1"><vh>p.edit_text</vh></v>
<v t="ekr.20040323160302"><vh>p.directParents</vh></v>
<v t="ekr.20040326064330"><vh>p.childIndex</vh></v>
</v>
<v t="ekr.20040306214240.2"><vh>children</vh>
<v t="ekr.20040306214240.3"><vh>p.hasChildren</vh></v>
<v t="ekr.20040306212636.1"><vh>p.numberOfChildren</vh></v>
</v>
<v t="ekr.20040307104131.3"><vh>p.exists</vh></v>
<v t="ekr.20040306215548"><vh>p.findRoot</vh></v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20040227212621"><vh>p.hasX</vh>
<v t="ekr.20040227224946"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20040307104131.1"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040803111240"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20040803140033.4"><vh>isCurrentPosition</vh></v>
<v t="ekr.20040803140033.5"><vh>isRootPosition</vh></v>
</v>
<v t="ekr.20040306215056"><vh>p.isCloned</vh></v>
<v t="ekr.20040307104131.2"><vh>p.isRoot</vh></v>
<v t="ekr.20040117162509.16"><vh>p.isVisible</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20040305222924"><vh>Setters</vh>
<v t="ekr.20040306220634"><vh>vnode proxies</vh>
<v t="ekr.20040306220634.9"><vh> Status bits</vh></v>
<v t="ekr.20040306220634.8"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20040306220634.29"><vh>p.setSelection</vh></v>
<v t="ekr.20040306220634.31"><vh>p.trimTrailingLines</vh></v>
<v t="ekr.20040315034158"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20040315031401"><vh>Head &amp; body text (position)</vh>
<v t="ekr.20040315032503"><vh>p.appendStringToBody</vh></v>
<v t="ekr.20040305223522"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20040305222924.1"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20040305223225"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="ekr.20040315031445"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20040312015908"><vh>Visited bits</vh>
<v t="ekr.20040312015705"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="ekr.20040315023430"><vh>File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>moreBody</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.12"><vh>p.sortChildren</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040228094013.1"><vh>p.utils...</vh>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20040409203454"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20041006103243.22"><vh>tree.select</vh>
<v t="ekr.20041006103243.23"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20041006103243.24"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20041006103243.25"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20041006103243.26"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20041006103243.27"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041007081237.11"><vh>LP clarifies the shape of functions</vh>
<v t="ekr.20041006103243.22"><vh>tree.select</vh>
<v t="ekr.20041006103243.23"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20041006103243.24"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20041006103243.25"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20041006103243.26"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20041006103243.27"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041007081237.8"><vh>Sections create a place for extensive comments</vh>
<v t="ekr.20031218072017.2618"><vh>app.setEncoding</vh></v>
</v>
<v t="ekr.20041007083215.1"><vh>Others reasons</vh>
<v t="ekr.20041007081237.4"><vh>Design and coding happen at the highest possible level</vh></v>
<v t="ekr.20041007081237.5"><vh>The visual weight of code is separate from its actual length</vh></v>
<v t="ekr.20041007081237.6"><vh>Sections show relations between snippets of code</vh></v>
<v t="ekr.20041007081237.7"><vh>Complex section names invite improvements</vh></v>
<v t="ekr.20041007081237.9"><vh>Section names eliminate mundane comments</vh></v>
<v t="ekr.20041007081237.10"><vh>Sections create comments automatically</vh></v>
<v t="ekr.20041007081237.12"><vh>I spend less time formatting code</vh></v>
</v>
</v>
<v t="ekr.20041007081237.13"><vh>(skip) How Leo Improves Literate Programming</vh>
<v t="ekr.20041007081237.14"><vh>Outlines add context</vh></v>
<v t="ekr.20041007081237.15"><vh>Outlines provide scope for commands</vh></v>
<v t="ekr.20041007081237.16"><vh>Clones create different views and focus attention</vh></v>
<v t="ekr.20041007081237.17"><vh>Outlines increase flexibility</vh></v>
<v t="ekr.20041007081237.18"><vh>Outlines express hierarchy directly</vh></v>
<v t="ekr.20041007081237.19"><vh>Outlines create new design dimensions</vh></v>
<v t="ekr.20041007081237.20"><vh>Leo improves tangling and adds untangling</vh></v>
</v>
<v t="ekr.20041007081237.21"><vh>How Leo Changes the Notion of Literate Programming</vh>
<v t="ekr.20041007083215.2"><vh>Fewer comments needed</vh></v>
<v t="ekr.20041007083215.3"><vh>Printed listings rarely needed</vh></v>
<v t="ekr.20041007083215.4"><vh>Outlines are much clearer than narrative</vh></v>
<v t="ekr.20041007083215.6"><vh>LP is a misnomer</vh></v>
</v>
<v t="ekr.20041006104224.2"><vh>Story: ski trip</vh></v>
</v>
<v t="ekr.20041006104908.4"><vh>Future directions</vh>
<v t="ekr.20041006110013"><vh>Better cvs support</vh></v>
<v t="ekr.20041006110013.1"><vh>More configurations options</vh></v>
<v t="ekr.20041006104224.5"><vh>?</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151"></t>
<t tx="EKR.20040519090151.2">@ The present code is almost useless if there is a crash in Leo's core (instead of the script itself).</t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040529103843">def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="EKR.20040529103945">def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="EKR.20040612215018">if g.os_path_exists(fileName):
    f = file(fileName)
    lines = f.readlines()
    f.close()
else:
    lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    try:
        s = "%s line %d: %s" % (fileName,n,lines[n-1])
        print s, ; g.es(s,newline=False)
    except IndexError:
        s = "%s line %d" % (fileName,n)
        print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i &lt; j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1</t>
<t tx="EKR.20040627100424">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()</t>
<t tx="ekr.20031218072017.889"># Warning: this code implies substantial changes to code that uses them, both core and scripts.

class position (object):
    
    """A class representing a position in a traversal of a tree containing shared tnodes."""

    &lt;&lt; about the position class &gt;&gt;
    
    @others
</t>
<t tx="ekr.20031218072017.890">@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible, p.hasThreadNext and p.vThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.</t>
<t tx="ekr.20031218072017.892">def __init__ (self,v,stack,trace=True):

    """Create a new position."""
    
    if v: self.c = v.c
    else: self.c = g.top()
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.

    g.app.positions += 1
    
    if g.app.tracePositions and trace:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.
</t>
<t tx="ekr.20031218072017.893">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal</t>
<t tx="ekr.20031218072017.915"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext</t>
<t tx="ekr.20031218072017.928">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()</t>
<t tx="ekr.20031218072017.930">def moveToBack (self):
    
    """Move self to its previous sibling."""
    
    p = self

    p.v = p.v and p.v._back
    
    return p</t>
<t tx="ekr.20031218072017.931">def moveToFirstChild (self):

    """Move a position to it's first child's position."""
    
    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
        
    return p

</t>
<t tx="ekr.20031218072017.932">def moveToLastChild (self):
    
    """Move a position to it's last child's position."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
</t>
<t tx="ekr.20031218072017.933">def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p</t>
<t tx="ekr.20031218072017.934">def moveToNext (self):
    
    """Move a position to its next sibling."""
    
    p = self
    
    p.v = p.v and p.v._next
    
    return p</t>
<t tx="ekr.20031218072017.935">def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20031218072017.936">def moveToNthChild (self,n):
    
    p = self
    
    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p</t>
<t tx="ekr.20031218072017.937">def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p # 10/30/04

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p</t>
<t tx="ekr.20031218072017.938">def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p</t>
<t tx="ekr.20031218072017.939">def moveToThreadNext (self):
    
    """Move a position to the next a position in threading order."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.
                
    return p</t>
<t tx="ekr.20031218072017.940">def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p</t>
<t tx="ekr.20031218072017.941">def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p</t>
<t tx="ekr.20031218072017.2140">def executeScript(self,p=None,script=None):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p)
    &lt;&lt; redirect output &gt;&gt;
    # g.trace(script)
    if script:
        script = script.strip()
    if script:
        # 9/14/04: Temporarily add the open directory to sys.path.
        sys.path.insert(0,c.frame.openDirectory)
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            &lt;&lt; unredirect output &gt;&gt;
            if not script1:
                g.es("end of script",color="purple")
        except:
            &lt;&lt; unredirect output &gt;&gt;
            g.es("exception executing script")
            fileName,n = g.es_exception(full=False,c=c)
            g.trace(fileName)
            if n is not None:
                &lt;&lt; dump the lines near the error &gt;&gt;
                if p and not script1 and not fileName:
                    c.goToScriptLineNumber(p,script,n)
            c.frame.tree.redrawAfterException()
        del sys.path[0]
    elif not error:
        &lt;&lt; unredirect output &gt;&gt;
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() </t>
<t tx="ekr.20031218072017.2143">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr</t>
<t tx="ekr.20031218072017.2278">@ Warning:
g.importFromPath uses imp.load_module, and that is equivalent to reload!
Calling this function to reload Leo files will crash Leo!
@c

def importFromPath (name,path,verbose=False):
    
    import imp

    try:
        theFile = None ; data = None ; result = None
        try:
            fn = g.shortFileName(name)
            mod_name,ext = g.os_path_splitext(fn)
            path = g.os_path_normpath(path)
            if g.CheckVersion(sys.version,"2.3"):
                path = g.toEncodedString(path,app.tkEncoding)
            else:
                path = str(path) # May throw exception.
            try:
                data = imp.find_module(mod_name,[path]) # This can open the file.
            except ImportError:
                if verbose:
                    s = "Can not import %s from %s" % (mod_name,path)
                    print s ; g.es(s,color="blue")
            if data:
                theFile,pathname,description = data
                try:
                    result = imp.load_module(mod_name,theFile,pathname,description)
                except ImportError:
                    g.es_exception()
        except:
            g.es_exception()

    # Put no return statements before here!
    finally: 
        if theFile: theFile.close()

    return result</t>
<t tx="ekr.20031218072017.2406"> @language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
lst: a list (Do _not_ use list, it is a Python global!)
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode

For more documentation, see the node called "Overview of Leo's code" in LeoDocs.leo.</t>
<t tx="ekr.20031218072017.2415"></t>
<t tx="ekr.20031218072017.2418">def initScriptFind(findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
    
    import leoTest
    import leoGlobals as g
    
    # Find the scripts.
    c = g.top() ; p = c.currentPosition()
    u = leoTest.testUtils()
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    g.app.findFrame.init(c)
    c.findPanel()</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2618">@ According to Martin v. Löwis, getdefaultlocale() is broken, and cannot be fixed. The workaround is to copy the g.getpreferredencoding() function from locale.py in Python 2.3a2.  This function is now in leoGlobals.py.
@c

def setEncoding (self):
    
    """Set g.app.tkEncoding."""

    for (encoding,src) in (
        (self.config.tkEncoding,"config"),
        #(locale.getdefaultlocale()[1],"locale"),
        (g.getpreferredencoding(),"locale"),
        (sys.getdefaultencoding(),"sys"),
        ("utf-8","default")):
    
        if g.isValidEncoding (encoding): # 3/22/03
            self.tkEncoding = encoding
            # g.trace(self.tkEncoding,src)
            break
        elif encoding and len(encoding) &gt; 0:
            g.trace("ignoring invalid ",src," encoding: ",encoding)
            
    color = g.choose(self.tkEncoding=="ascii","red","blue")</t>
<t tx="ekr.20031218072017.3126">@ The following is taken from page 188 of the Python Cookbook.

The following method allows you to add a function as a method of any class.  That is, it converts the function to a method of the class.  The method just added is available instantly to all existing instances of the class, and to all instances created in the future.

The function's first argument should be self.

The newly created method has the same name as the function unless the optional name argument is supplied, in which case that name is used as the method name.
@c

def funcToMethod(f,theClass,name=None):

    setattr(theClass,name or f.__name__,f)
    # g.trace(name)</t>
<t tx="ekr.20031218072017.3388">def clearAllVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()</t>
<t tx="ekr.20031218072017.3440">def loadHandlers(loadAllFlag=False):

    """Load all enabled plugins from the plugins directory"""
    import glob

    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    manager_path = g.os_path_join(plugins_path,"pluginsManager.txt")
    
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(theFile) for theFile in files]

    if loadAllFlag:
        files.sort()
        enabled_files = files
    else:
        &lt;&lt; set enabled_files from pluginsManager.txt &gt;&gt;
        enabled_files = [g.os_path_abspath(theFile) for theFile in enabled_files]
    
    # Load plugins in the order they appear in the enabled_files list.
    g.app.loadedPlugins = []
    if files and enabled_files:
        for theFile in enabled_files:
            if theFile in files:
                theFile = g.toUnicode(theFile,g.app.tkEncoding)
                g.importFromPath(theFile,plugins_path)
    if g.app.loadedPlugins and not loadAllFlag:
        g.es("%d plugins loaded" % (len(g.app.loadedPlugins)), color="blue")
        if 0:
            for name in g.app.loadedPlugins:
                print name</t>
<t tx="ekr.20031218072017.3441">if not g.os_path_exists(manager_path):
    return

enabled_files = []
try:
    theFile = open(manager_path)
    lines = theFile.readlines()
    for s in lines:
        s = s.strip()
        if s and not g.match(s,0,"#"):
            enabled_files.append(g.os_path_join(plugins_path,s))
    theFile.close()
except IOError:
    g.es("Can not open: " + manager_path)
    # Don't import leoTest initially.  It causes problems.
    import leoTest ; leoTest.fail()
    return</t>
<t tx="ekr.20031218072017.3625"></t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.4146">def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p</t>
<t tx="ekr.20040117162509.16">def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True</t>
<t tx="ekr.20040117170612">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        elif attr=="__del__":
            # This works around a Python 2.2 wierdness.
            return AttributeError # Silently ignore this.
        else:
            # Only called when normal lookup fails.
            print "unknown position attribute:",attr
            # import traceback ; traceback.print_stack()
            raise AttributeError</t>
<t tx="ekr.20040117171654"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    if g.app.tracePositions:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.v,self.stack,trace=False)</t>
<t tx="ekr.20040117173448">@
The test "if p" is the _only_ correct way to test whether a position p is valid.
In particular, tests like "if p is None" or "if p is not None" will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None</t>
<t tx="ekr.20040227212621">def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    return self.v and self.v._next
    
def hasParent(self):
    return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack</t>
<t tx="ekr.20040227214711">def simpleLevel(self):
    
    p = self ; level = 0
    for parent in p.parents_iter():
        level += 1
    return level

def level(self,verbose=False):
    
    # if g.app.debug: simpleLevel = self.simpleLevel()
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==simpleLevel)
            break
    return level</t>
<t tx="ekr.20040227224946">def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

hasVisNext = hasThreadNext</t>
<t tx="ekr.20040228060340"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n &gt;= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n</t>
<t tx="ekr.20040228060340.1">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

</t>
<t tx="ekr.20040228094013"></t>
<t tx="ekr.20040228094013.1"></t>
<t tx="ekr.20040301205720">def __str__ (self):
    
    p = self
    
    if p.v:
        return "&lt;pos %d lvl: %d [%d] %s&gt;" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d        [%d] None&gt;" % (id(p),len(p.stack))
        
__repr__ = __str__</t>
<t tx="ekr.20040303163330"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed</t>
<t tx="ekr.20040303175026"></t>
<t tx="ekr.20040303175026.2">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c

    assert(newPosition != p)
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
    c.selectVnode(newPosition)
    
    return newPosition

</t>
<t tx="ekr.20040303175026.3">def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2</t>
<t tx="ekr.20040303175026.4">def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.
    
    Returns the newly created position."""
    
    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")
    
    return p.insertAsNthChild(n,t)</t>
<t tx="ekr.20040303175026.5">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")
    
    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2</t>
<t tx="ekr.20040303175026.6">def moveToRoot (self,oldRoot=None):

    """Moves a position to the root position."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p</t>
<t tx="ekr.20040303175026.8">def clone (self,back):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    
    # g.trace(p,back)

    p2 = back.copy()
    p2.v = vnode(c,back.v.t)
    p2.linkAfter(back)

    return p2</t>
<t tx="ekr.20040303175026.9"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="ekr.20040303175026.10">def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self ; c = p.c # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)
    
    # Moving a node after another node can create a new root node.
    if not a.hasParent() and not a.hasBack():
        c.setRootPosition(a)

    return p</t>
<t tx="ekr.20040303175026.11">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        c.setRootPosition(parent)

    return p
</t>
<t tx="ekr.20040303175026.12">def sortChildren (self):
    
    p = self

    # Create a list of (headline,position) tuples
    pairs = []
    for child in p.children_iter():
        pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

    # Sort the list on the headlines.
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        child.moveToNthChildOf(p,index)
        index += 1</t>
<t tx="ekr.20040303175026.13"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
    
    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()
    
    # g.trace(p,parent,pv)
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result</t>
<t tx="ekr.20040303175026.14">if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))</t>
<t tx="ekr.20040303175026.15">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="ekr.20040303175026.16">if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )</t>
<t tx="ekr.20040303214038">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    changed = False
    
    # Calculate all nodes that are joined to v or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
    
    c.beginUpdate()
    if 1: # update...
        count = 0 # for debugging.
        for v in nodes:
            if not v.t.isDirty() and v.isAnyAtFileNode():
                # g.trace(v)
                changed = True
                v.t.setDirty() # Do not call v.setDirty here!
                count += 1
        # g.trace(count,changed)
    c.endUpdate(changed)
    return changed</t>
<t tx="ekr.20040305162628"></t>
<t tx="ekr.20040305162628.1">@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others</t>
<t tx="ekr.20040305171133">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)</t>
<t tx="ekr.20040305171133.1">def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20040305171133.3">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305172211.1">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)</t>
<t tx="ekr.20040305172211.2">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
</t>
<t tx="ekr.20040305172211.3">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305172855">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20040305172855.1">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self</t>
<t tx="ekr.20040305172855.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20040305173343">class siblings_iter_class:

    """Returns a list of siblings of a position."""

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)</t>
<t tx="ekr.20040305173343.1">def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

</t>
<t tx="ekr.20040305173343.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305173559">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20040305173559.1">def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20040305173559.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration</t>
<t tx="ekr.20040305222924"></t>
<t tx="ekr.20040305222924.1">def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
</t>
<t tx="ekr.20040305223225">def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()</t>
<t tx="ekr.20040305223522">def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="ekr.20040306060312">def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = p.numberOfChildren()
    p.linkAsNthChild(parent,n)

    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        p.c.setRootPosition(parent)
        
    return p
</t>
<t tx="ekr.20040306210951"></t>
<t tx="ekr.20040306211032">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="ekr.20040306212151">def extraAttributes (self):
    
    return self.v.extraAttributes()

def setExtraAttributes (self,data):

    return self.v.setExtraAttributes(data)</t>
<t tx="ekr.20040306212636"></t>
<t tx="ekr.20040306212636.1">def numberOfChildren (self):
    
    return self.v.numberOfChildren()
</t>
<t tx="ekr.20040306214240.2"></t>
<t tx="ekr.20040306214240.3">def hasChildren(self):
    
    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild</t>
<t tx="ekr.20040306214401">def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()</t>
<t tx="ekr.20040306215056">def isCloned (self):
    
    return len(self.v.t.vnodeList) &gt; 1</t>
<t tx="ekr.20040306215548">def findRoot (self):
    
    return self.c.frame.rootPosition()</t>
<t tx="ekr.20040306220230">def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
</t>
<t tx="ekr.20040306220230.1">def edit_text (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_text(p)</t>
<t tx="ekr.20040306220634"></t>
<t tx="ekr.20040306220634.8">def computeIcon (self):
    
    return self.v.computeIcon()
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="ekr.20040306220634.9"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    g.doHook("clear-mark",c=self.c,p=self)
    return self.v.clearMarked()

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus()
    
def setMarked (self):
    g.doHook("set-mark",c=self.c,p=self)
    return self.v.setMarked()

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()</t>
<t tx="ekr.20040306220634.17"># Compatibility routine for scripts.

def clearVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.clearVisited()
</t>
<t tx="ekr.20040306220634.29">def setSelection (self,start,length):

    return self.v.setSelection(start,length)</t>
<t tx="ekr.20040306220634.31">def trimTrailingLines (self):

    return self.v.trimTrailingLines()</t>
<t tx="ekr.20040307104131.1">def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False</t>
<t tx="ekr.20040307104131.2">def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()</t>
<t tx="ekr.20040307104131.3">def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()
    
    # This code must be fast.
    root = c.rootPosition()
    while p:
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False</t>
<t tx="ekr.20040310062332"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.</t>
<t tx="ekr.20040310062332.1">def invalidOutline (self, message):
    
    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))</t>
<t tx="ekr.20040310062332.2">def linkAfter (self,after):

    """Link self after v."""
    
    p = self
    # g.trace(p,after)
    
    p.stack = after.stack[:] # 3/12/04
    p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
    
    p.v._back = after.v
    p.v._next = after.v._next
    
    after.v._next = p.v
    
    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")</t>
<t tx="ekr.20040310062332.3">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n)
    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")</t>
<t tx="ekr.20040310062332.4">def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""
    
    # g.trace(self,oldRoot)

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode # Bug fix: 3/12/04
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v # Bug fix: 3/12/04

    p.c.setRootPosition(p)
    
    if 0:
        p.dump(label="root")
</t>
<t tx="ekr.20040310062332.5">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""

    p = self ; v = p.v ; parent = p.parent()
    
    # Note:  p.parent() is not necessarily the same as v._parent.
    
    if parent:
        assert(p.v and p.v._parent in p.v.directParents())
        assert(parent.v in p.v.directParents())

    # g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if parent and parent.v.t._firstChild == v:
        parent.v.t._firstChild = v._next

    # Do _not_ delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
</t>
<t tx="ekr.20040310153624">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]</t>
<t tx="ekr.20040311113514">def clearDirty (self):

    p = self
    p.v.clearDirty()</t>
<t tx="ekr.20040312015705"># Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()</t>
<t tx="ekr.20040312015908"></t>
<t tx="ekr.20040315023430">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315023430.1">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="ekr.20040315023430.2">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040315023430.3">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)</t>
<t tx="ekr.20040315031401"></t>
<t tx="ekr.20040315031445">def scriptSetBodyString (self,s,encoding="utf-8"):
    
    """Update the body string for the receiver.
    
    Should be called only from scripts: does NOT update body text."""

    self.v.t.bodyString = g.toUnicode(s,encoding)</t>
<t tx="ekr.20040315032503">def appendStringToBody (self,s,encoding="utf-8"):
    
    p = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    p.setBodyStringOrPane(body + s,encoding)</t>
<t tx="ekr.20040315034158">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.v.setTnodeText(s,encoding)</t>
<t tx="ekr.20040318125934">def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes</t>
<t tx="ekr.20040321065415">def findNodeInTree(p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    c = p.c
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(headline):
    
    c = g.top()
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(headline):
    
    c = g.top()
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20040323160302">def directParents (self):
    
    return self.v.directParents()
</t>
<t tx="ekr.20040325142015">def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    
    &gt;&gt;&gt; c = g.top() ; p = c.currentPosition() ; root = c.rootPosition()
    &gt;&gt;&gt; n = g.app.positions
    &gt;&gt;&gt; assert p.equal(p.copy()) is True
    &gt;&gt;&gt; assert p.equal(root) is False
    &gt;&gt;&gt; assert g.app.positions == n + 1
    &gt;&gt;&gt; 
    """

    p1 = self
    
    # if g.app.trace: "equal",p1.v,p2.v

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())
        
isEqual = equal
</t>
<t tx="ekr.20040326064330">def childIndex(self):
    
    p = self ; v = p.v
    
    # This is time-critical code!
    
    # 3/25/04: Much faster code:
    if not v or not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back

    return n</t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040409203454">def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        
    for p in root.children_iter():
        p.restoreLinksInTree()</t>
<t tx="ekr.20040409203454.1">def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20040410170806">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        assert(p.v not in p.v.t.vnodeList)
        # g.trace("deleted",p.v,p.vnodeListIds())
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()</t>
<t tx="ekr.20040410170806.1">def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.2 final, build %s, September 20, 2004" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.163 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = g.app.config.getWindowPref("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, %s" % (n1,n2,n3,tkLevel,sys.platform))
    g.enl()</t>
<t tx="ekr.20040702104823">def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False</t>
<t tx="ekr.20040803072955.7">def newBox (self,p,x,y,image):
    
    canvas = self.canvas ; tag = "plusBox" # 9/5/04: was plugBox.

    if self.freeBoxes:
        theId = self.freeBoxes.pop(0)
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),align=-20)

    assert(theId not in self.visibleBoxes)
    self.visibleBoxes.append(theId)

    assert(not self.ids.get(theId))
    assert(p)
    self.ids[theId] = p

    return theId</t>
<t tx="ekr.20040803072955.16">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.redrawing = False # Used only to disable traces.
    self.trace = False
    self.verbose = False
    self.useBindtags = True
    self.generation = 0
    self.dragging = False
    self.prevPositions = 0
    self.expanded_click_area = g.app.config.getBoolWindowPref("expanded_click_area")
    
    self.createPermanentBindings()
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are unchanging positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {} # Keys are vnodes, values are Tk.Text widgets
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = {} # Keys are vnodes, values are Tk.Text widgets
    self.freeUserIcons = []</t>
<t tx="ekr.20040803072955.17">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20040803072955.18"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.disableRedraw = False # True: reschedule a redraw for later.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)</t>
<t tx="ekr.20040803072955.19"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20040803072955.20">def createPermanentBindings (self):
    
    canvas = self.canvas

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','&lt;Button-1&gt;', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','&lt;Button-1&gt;',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','&lt;Button-1&gt;', self.onIconBoxClick)
    canvas.tag_bind('iconBox','&lt;Double-1&gt;', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','&lt;Button-3&gt;', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','&lt;B1-Motion&gt;',            self.onDrag)
    canvas.tag_bind('iconBox','&lt;Any-ButtonRelease-1&gt;',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = Tk.Text(canvas) # This _must_ be a Text widget attached to the canvas!
        if 1: # Either way works properly.
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)
        else:
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick, '+')
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick, '+')
            t.bind("&lt;Key&gt;",      self.onHeadlineKey, '+')
        t.bind("&lt;Control-t&gt;",self.onControlT)
    
        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()</t>
<t tx="ekr.20040803072955.37">def drawClickBox (self,p,y):

    canvas = self.canvas ; h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        theId = self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20040803072955.38">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040803111240"></t>
<t tx="ekr.20040803140033.4">def isCurrentPosition (self):
    
    p = self ; c = p.c
    
    return c.isCurrentPosition(p)
    
</t>
<t tx="ekr.20040803140033.5">def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)</t>
<t tx="ekr.20040901061935"></t>
<t tx="ekr.20040906081644">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2706676
By: nobody

Ive downloaded 4.2B3 and really really dont want to use the left click select/expand
anywhere Tree functionality( Ive never had a problem selecting the node I want
:) ).  I looked in the config file and didnt see an option for turning it off.
So do I need to hack the leo code to do this?

Option name: expanded_click_area</t>
<t tx="ekr.20041006103243">@ignore</t>
<t tx="ekr.20041006103243.2">@killcolor

- 

- .
   </t>
<t tx="ekr.20041006103243.3"></t>
<t tx="ekr.20041006103243.4"></t>
<t tx="ekr.20041006103243.6"></t>
<t tx="ekr.20041006103243.8"></t>
<t tx="ekr.20041006103243.21">@color</t>
<t tx="ekr.20041006103243.22"># Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return
    
    if self.trace and self.verbose: g.trace(p.headString())

    if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_v=p,old_v=old_p)
    
    # g.printGc()</t>
<t tx="ekr.20041006103243.23"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    if self.trace and self.verbose:
        g.trace("unselect:",old_p.headString())
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
</t>
<t tx="ekr.20041006103243.24">frame.setWrap(p)

# 6/14/04: Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")</t>
<t tx="ekr.20041006103243.25">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20041006103243.26"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20041006103243.27">self.c.setCurrentPosition(p)
if p != old_p:
    self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)</t>
<t tx="ekr.20041006103243.28">@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords</t>
<t tx="ekr.20041006103243.29">actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]</t>
<t tx="ekr.20041006103243.30">csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]</t>
<t tx="ekr.20041006103243.31">c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]</t>
<t tx="ekr.20041006103243.32">css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]</t>
<t tx="ekr.20041006103243.33"># EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]</t>
<t tx="ekr.20041006103243.34"># No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "&lt;%","%&gt;" ]</t>
<t tx="ekr.20041006103243.35">java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]</t>
<t tx="ekr.20041006103243.36">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
    "\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
    "\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
    "\\cot", "\\coth",	"csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
    "\\linethickness", "\\linewidth",	"\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow",	"longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi",	"\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow",	"\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone",	"\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]</t>
<t tx="ekr.20041006103243.37">pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]</t>
<t tx="ekr.20041006103243.38">perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 &amp; FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 &amp; f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]</t>
<t tx="ekr.20041006103243.39">php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "&lt;?php", "?&gt;"
</t>
<t tx="ekr.20041006103243.40">python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]</t>
<t tx="ekr.20041006103243.41">rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]</t>
<t tx="ekr.20041006103243.42">rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]</t>
<t tx="ekr.20041006103243.43">shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]</t>
<t tx="ekr.20041006103243.44">tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]</t>
<t tx="ekr.20041006103243.45">@killcolor

Leo remembers where you were.
</t>
<t tx="ekr.20041006103243.46"></t>
<t tx="ekr.20041006103243.47">@color # &lt;---  A Leo directive

import leoGlobals as g

g.es("Thanks for inviting me to Chicago!",color="red")
</t>
<t tx="ekr.20041006103243.48">import leoGlobals as g
import tkFont

@others  # &lt;---- a Leo directive.

c = g.top()

if 1:
    &lt;&lt; print font of body pane &gt;&gt;  # &lt;---- a section reference.

if 1:
    &lt;&lt; print font of log pane &gt;&gt;
    
if 1:
    &lt;&lt; print font of tree pane &gt;&gt;</t>
<t tx="ekr.20041006103243.49">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="ekr.20041006103243.51">Body text contains data; headlines contains meta-data.</t>
<t tx="ekr.20041006103243.52">The old world:  Applications are programs (algorithms) + data.

The Leo world:  Applications are data, outlines (structure) and algorithms.

- Programs _are_ outlines.
- Data _are_ outlines.
- Outlines _are_ programs.
- Outlines _are data.

This has specific, concrete, practical implications, e.g., in unit testing.</t>
<t tx="ekr.20041006103243.54">@color</t>
<t tx="ekr.20041006103243.179">@color</t>
<t tx="ekr.20041006103243.519"></t>
<t tx="ekr.20041006103243.521"></t>
<t tx="ekr.20041006103243.522"></t>
<t tx="ekr.20041006103243.523"></t>
<t tx="ekr.20041006103243.524"></t>
<t tx="ekr.20041006103243.525"></t>
<t tx="ekr.20041006103243.526"></t>
<t tx="ekr.20041006103243.527"></t>
<t tx="ekr.20041006103243.528"></t>
<t tx="ekr.20041006103243.529"></t>
<t tx="ekr.20041006103243.530"></t>
<t tx="ekr.20041006103243.531"></t>
<t tx="ekr.20041006103243.532"></t>
<t tx="ekr.20041006103243.533"></t>
<t tx="ekr.20041006103243.534"></t>
<t tx="ekr.20041006103243.535"></t>
<t tx="ekr.20041006103243.536"></t>
<t tx="ekr.20041006103243.537">Use section names like the following:
    
&lt;&lt; about this module &gt;&gt;
&lt;&lt; imports for this module &gt;&gt;
</t>
<t tx="ekr.20041006103243.538"></t>
<t tx="ekr.20041006103243.539"></t>
<t tx="ekr.20041006103243.540">@killcolor

Im curious as to your opinions as to what Refactorings are made easy by Leo. I use nodes as containers for methods. Yesterday I moved a node out of one class into another, hence moved a method into another class. This was easy. Thats it. So following the pattern of 'node is method' a refactoring was made simple.

Do other Leo users have refactorings that are made easy by usage patterns, such as the 'node is method' pattern? Id love to hear about them. If there is some twist I can apply to my Outline that makes code manipulation easier, its worth its weight in gold!( well a refactoring cant weigh anything, but you get my drift...)</t>
<t tx="ekr.20041006103243.541">@killcolor

RE: Refactoring Patterns in Leo  
2004-08-26 20:44
I stumbled on something I plan to use more the other day. take a few lines of code
maybe in a time critical section you would rather not make a function or method.
make that a named section node.
clone the node outside the outline
inside a function as if you were going to
extract it as a seperate function.
feed it those things it needs
return those things it will change.
add some doctesting.
run timeit on the node.
with doctests in place you can easily
try a few other formulations.
all w/o disturbing the previous source.
idealy this will be something w/o allot of
depandance on globals or much setup.
makeup your own example and try it out.

e </t>
<t tx="ekr.20041006103243.542"></t>
<t tx="ekr.20041006103243.543"></t>
<t tx="ekr.20041006103243.544"></t>
<t tx="ekr.20041006103243.545"></t>
<t tx="ekr.20041006103243.546"></t>
<t tx="ekr.20041006103243.547"></t>
<t tx="ekr.20041006103243.548"></t>
<t tx="ekr.20041006103243.549"></t>
<t tx="ekr.20041006103243.550"></t>
<t tx="ekr.20041006103243.551"></t>
<t tx="ekr.20041006103243.552"></t>
<t tx="ekr.20041006103243.553"></t>
<t tx="ekr.20041006103243.554"></t>
<t tx="ekr.20041006103243.555"></t>
<t tx="ekr.20041006103243.556"></t>
<t tx="ekr.20041006103243.557"></t>
<t tx="ekr.20041006103243.558"></t>
<t tx="ekr.20041006103243.559"></t>
<t tx="ekr.20041006103243.560"></t>
<t tx="ekr.20041006103243.561"></t>
<t tx="ekr.20041006103243.562"></t>
<t tx="ekr.20041006103243.563"></t>
<t tx="ekr.20041006104224">@killcolor</t>
<t tx="ekr.20041006104224.2"></t>
<t tx="ekr.20041006104224.3">@nocolor

Leo makes so-called literate programming practical.</t>
<t tx="ekr.20041006104224.5"></t>
<t tx="ekr.20041006104224.6">@nocolor</t>
<t tx="ekr.20041006104908">fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
g.es("body:",fn,name,size,slant,weight)</t>
<t tx="ekr.20041006104908.1">fn = c.frame.log.getFontConfig()
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
g.es("log:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="ekr.20041006104908.2">font = c.frame.tree.getFont()
name,size,slant,weight = getFontSettings(font)
g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="ekr.20041006104908.3">- Complex numbers create something new to mathematics.  R x R is not just more R!

- Leo's nodes (Headlines x Body) creates something new that is much more than just text.</t>
<t tx="ekr.20041006104908.4"></t>
<t tx="ekr.20041006105206"></t>
<t tx="ekr.20041006105206.1"></t>
<t tx="ekr.20041006105206.2"></t>
<t tx="ekr.20041006105206.4">@color</t>
<t tx="ekr.20041006105452"></t>
<t tx="ekr.20041006105452.1"></t>
<t tx="ekr.20041006105452.2"></t>
<t tx="ekr.20041006105452.3"></t>
<t tx="ekr.20041006105452.4"></t>
<t tx="ekr.20041006110013"></t>
<t tx="ekr.20041006110013.1"></t>
<t tx="ekr.20041006110307"></t>
<t tx="ekr.20041006110307.1"></t>
<t tx="ekr.20041006110307.2"></t>
<t tx="ekr.20041006110548"></t>
<t tx="ekr.20041006110732"></t>
<t tx="ekr.20041006110923"></t>
<t tx="ekr.20041006111057">@color</t>
<t tx="ekr.20041006111429">@color</t>
<t tx="ekr.20041006111429.1">@killcolor

Leo scans for @script, @button and @plugin nodes when opening windows.</t>
<t tx="ekr.20041007061255"></t>
<t tx="ekr.20041007061255.1"></t>
<t tx="ekr.20041007061255.2"></t>
<t tx="ekr.20041007061255.3"></t>
<t tx="ekr.20041007061834"></t>
<t tx="ekr.20041007061834.1"></t>
<t tx="ekr.20041007061834.2"></t>
<t tx="ekr.20041007061834.3"></t>
<t tx="ekr.20041007061834.4">- unittest, etc., etc.</t>
<t tx="ekr.20041007081237.1">@nocolor

This chapter discusses Leo's relationship with traditional literate programming.

@color</t>
<t tx="ekr.20041007081237.2">@nocolor

The following sections discuss the main benefits of traditional literate programming. It's worth noting that none of these benefits derives from being able to produce printed output.

@color</t>
<t tx="ekr.20041007081237.3">@nocolor

Sections add a new dimension to the design and coding process. Choices about what sections do, what they are named, what order they appear in, are choices in a design space different from "normal" programming. This an abstract concept, to be sure. However, the following concrete discussions are really manifestation of working in this new design space.

@color</t>
<t tx="ekr.20041007081237.4">@nocolor

The names of sections are constrained only by one's design skill, not by any rules of language. You say what you mean, and that becomes both the design and the code. You never have to simulate a concept because concepts become section names.</t>
<t tx="ekr.20041007081237.5">@nocolor

The visual weight of a web section is simply the length and complexity of the section's name, regardless of how complex the actual definition of the section is. The results of this separation are spectacular. No longer is one reluctant to do extensive error handling (or any other kind of minutia) for fear that it would obscure the essence of the program. Donald Knuth stresses this aspect of literate programming and I fully agree.</t>
<t tx="ekr.20041007081237.6">@nocolor

Sections can show and enforce relationships between apparently unrelated pieces of code. Comments, macros or functions are other ways to indicate such relationships, but often sections are ideal. Indeed, a natural progression is to create sections as a matter of course. I typically convert a section to a function only when it becomes apparent that a function's greater generality outweighs the inconvenience of having to declare and define the function.</t>
<t tx="ekr.20041007081237.7">@nocolor

A section name is complex when it implies unwholesome dependencies between the caller (user) of the section and the section itself. Such section names tend to be conspicuous, so that the programmer is lead to revise both the section name and its purpose. Many times my attention has been drawn to a poorly conceived section because I didn't like what its name implied. I have always been able to revise the code to improve the design, either by splitting a section into parts or be simplifying its relation to colleagues.</t>
<t tx="ekr.20041007081237.8">@nocolor

One of the most surprising thing about literate programming is how severely traditional programming tends to limit comments. In a conventional program the formatting of code must indicate structure, and comments obscure that formatting. Sections in literate programming provide a place for lengthy comments that do not clutter up the code at the place the section is referenced.

@color</t>
<t tx="ekr.20041007081237.9">@nocolor

The section name often says it all. The reference to the section says everything that the user needs to know, and the section name at the point of definition also eliminates the need for many comments.

@color</t>
<t tx="ekr.20041007081237.10">@nocolor

A typical root starts out with something like.

@color

	&lt;&lt; includes for class x &gt;&gt;
	&lt;&lt; private data for class x &gt;&gt;
	&lt;&lt; private prototypes for class x &gt;&gt;
	&lt;&lt; functions of class x &gt;&gt;

@nocolor
In the derived file there is a comment that looks like this:
@color

	/// &lt;&lt; includes for class x &gt;&gt;

@nocolor
It would be silly to write this comment by hand, though often programmers do just that in order to have a place holder for a mark in the source file. With literate programming the situation is different: the comment indicates that the code came from a particular section; that is, the comment servers a real purpose.

@color
</t>
<t tx="ekr.20041007081237.11">@nocolor

These last several paragraphs have discussed comments in detail because the net effect of "putting comments where they belong" is that comments don't clutter the code. Section references hide irrelevant detail, so larger-scale patterns within functions (or declarations) become more apparent. Often just recasting code into web format has created Ahas about my own code, with no special attention to recoding or redesign! Recasting a function as a web raises the real and apparent level of abstraction.

@color</t>
<t tx="ekr.20041007081237.12">@nocolor

Formatting no longer has to indicate overall design; sections do that. I am less obsessive about formatting code; it simply doesn't matter much whether different sections are formatted consistently because the format of one section has no effect on the look of other sections. Also, I don't worry about most line breaks within documentation parts, or about adding comment delimiters.</t>
<t tx="ekr.20041007081237.13">@nocolor

Outlines add something brand new to traditional literate programming, namely an explicit mechanism for expressing structure at any level of detail, from largest overall view to smallest detail. The following sections elaborate on this theme.</t>
<t tx="ekr.20041007081237.14">@nocolor

By far the biggest drawback of conventional literate programming is that there are so many sections; it becomes difficult to understand the relationships, if any, between sections. Using an outline to express a literate programming instantly solves this problem. The programmer is always aware of how sections are related.</t>
<t tx="ekr.20041007081237.15">@nocolor

Outlines provide a convenient way of expressing the intended scope of commands.  For example, the Tangle command operates only on the presently selected tree. The Extract Section command creates a new section as the last child of the present node.</t>
<t tx="ekr.20041007081237.16">@nocolor

Clones transform a tree into a directed graph without loops. This is a very powerful data structure. Nothing would be gained by cloning an arbitrary directed graph: in general, the clone would simply become the entire tree. Cloning a tree, however, is very effective.

A set of clones becomes essentially a different view of the outline. The set is itself part of the outline, so the outline itself contains an elegant mechanism for representing arbitrarily many views of the same data. It is because of the power of clones that I described MORE in the dedication as possibly the most elegant computer program ever written.

It is easy to create different (and useful) view of a literate outline. For example, I often make clones of all relevant sections of my outline while debugging or adding new features. The clones carry along relevant suboutlines, so essential context is retained, but gathering all the clones together automatically concentrates attention on the problem at hand.</t>
<t tx="ekr.20041007081237.17">@nocolor

The meaning of a well written literate outline is independent on the order in which sections appear, so outlines may be reorganized at will. In addition, headlines without body text do not affect derived files in any way; such headlines can be inserted freely at any time. In fact, such "nonfunctional" headlines often convey the most information about the structure and design of a large system. Decoupling structure from content in this way is precisely what is needed for flexibility: one can reorganize at will without worrying about changing the meaning of the code.</t>
<t tx="ekr.20041007081237.18">@nocolor

Hierarchy is often implicit in programming: for example, the grouping of functions into files, or the organization of a single file as a set of functions, etc. An outline directly expresses hierarchy. For example, Leo's tangle or Find and Change commands may be restricted to a particular suboutline. That's a direct expression of an hierarchical constraint or property: I only want to deal with this part of the outline. With outlines, I can do so effortlessly.

Traditional literate programming often simulates the hierarchy using "bridge" comments. Those comments are far weaker than explicit structure. Experience with the Print command clearly shows that a clear literate outline can easily become unintelligible when printed, no matter how "beautiful" the typeset printout is.

My experience shows that organizational crutches such as printed listings, tables of contents and indices are much less clear than the corresponding outline. You could say the entire outline is a table of contents!</t>
<t tx="ekr.20041007081237.19">@nocolor

There are many ways to express a program as a literate outline. Again, the choices made when doing so are choices in another design space. Such choices are important, and add clarity to the entire program, but can only be expressed when the hierarchy is expressed explicitly.</t>
<t tx="ekr.20041007081237.20">@nocolor

Tangling and untangling are the fundamental operations of literate programming. Any editor that supports literate programming should provide these operations directly. Moreover, Leo automatically untangles @file trees when reading .leo files and tangles @file trees when writing .leo files.  Eliminating the need for explicit tangling and untangling is a huge improvement.</t>
<t tx="ekr.20041007081237.21">@nocolor</t>
<t tx="ekr.20041007083215.1"></t>
<t tx="ekr.20041007083215.2">- Bridge or transition phrases are almost always unnecessary in a literate outline.

- One never needs to say something like, "having just finished with topic x, we turn now to topic y." Literate outlines tend to be far less chatty than flat literate programs.</t>
<t tx="ekr.20041007083215.3">- No printed listing can be as clear as Leo's outline view.

- Context lines are required to keep one's bearings in listings.

- Without context lines a literate program must rely on extensive bridge comments.</t>
<t tx="ekr.20041007083215.4">- Simple, standard, yet flexible outline organizations provide a more natural way to organize large programs than narrative organizations.

- Narrative style creates severe maintenance problems. The narrative is soon forgotten, and when that happens it becomes difficult to find anything.</t>
<t tx="ekr.20041007083215.6">- Chunks or sections, the atoms of literate programming, have little to do with literature.

- Outlines eliminate the need for narrative. One can use chunks or sections to write narrative prose, but Leo demonstrates that one is under no obligation to do so.
</t>
<t tx="ekr.20041007083344">- New objects for programmers.

- New objects for scripts.

- A framework for distinguishing metadata from data.</t>
<t tx="ekr.20041008104656">Leo lets you create and retain relationships between code, data and structure.

No other tool can even represent such relationships.  You can't do this in Emacs!

This fundamental capability takes the places of dozens of features in traditional tools.</t>
<t tx="ekr.20041012095746"></t>
<t tx="ekr.20041012095746.2"></t>
<t tx="ekr.20041012095746.3"># See the node called "About the Perfect Import tests" in leoTests.py for how to set up these tests.
</t>
<t tx="ekr.20041012095746.4"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20041012095746.5">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.6">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.7">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.5:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20041012095746.5:-input
#@-leo
</t>
<t tx="ekr.20041012095746.8">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.6:-input-after
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20041012095746.6:-input-after
#@-leo
</t>
<t tx="ekr.20041012095746.9">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.10">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.11">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.5:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20041012095746.5:-input
#@-leo
</t>
<t tx="ekr.20041012095746.12"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20041012095746.13">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.14">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.15">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.13:-input
Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20041012095746.13:-input
#@-leo
</t>
<t tx="ekr.20041012095746.16">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.14:-input-after
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20041012095746.14:-input-after
#@-leo
</t>
<t tx="ekr.20041012095746.17">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.18">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20041012095746.19">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.13:-input
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20041012095746.13:-input
#@-leo
</t>
<t tx="ekr.20041012095746.20"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20041012095746.21">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20041012095746.22">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20041012095746.23">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.21:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20041012095746.21:-input
#@-leo
</t>
<t tx="ekr.20041012095746.24">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.22:-input-after
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20041012095746.22:-input-after
#@-leo
</t>
<t tx="ekr.20041012095746.25">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20041012095746.26">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20041012095746.27">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.21:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20041012095746.21:-input
#@-leo
</t>
<t tx="ekr.20041012095746.28"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

ignoreSentinelsInCompare = True # Fails when False

assert leoTest.runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=ignoreSentinelsInCompare)</t>
<t tx="ekr.20041012095746.29">root line 1
root line 2</t>
<t tx="ekr.20041012095746.30">node 1: line 1
node 1: line 2
</t>
<t tx="ekr.20041012095746.31">node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20041012095746.32">root line 1
root line 2</t>
<t tx="ekr.20041012095746.33">node 1: line 1
These lines should be totally different
</t>
<t tx="ekr.20041012095746.34">and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20041012095746.35">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.29:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20041012095746.29:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20041012095746.30:Node 1
node 1: line 1
node 1: line 2
#@-node:ekr.20041012095746.30:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20041012095746.31:Node 2
node 2: line 1
node 2: line 2
#@-node:ekr.20041012095746.31:Node 2
#@-leo
</t>
<t tx="ekr.20041012095746.36">root line 1
root line 2
node 1: line 1
node 1: line 2
node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20041012095746.37">root line 1
root line 2
node 1: line 1
These lines should be totally different
and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20041012095746.38">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.32:-input-after
root line 1
root line 2
#@nonl
#@-node:ekr.20041012095746.32:-input-after
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20041012095746.33:Node 1
node 1: line 1
These lines should be totally different
#@-node:ekr.20041012095746.33:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20041012095746.34:Node 2
and should span node boundaries
node 2: line 2
#@-node:ekr.20041012095746.34:Node 2
#@-leo
</t>
<t tx="ekr.20041012095746.39">#@+leo-ver=4-thin
#@+node:ekr.20041012095746.29:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20041012095746.29:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20041012095746.30:Node 1
node 1: line 1
These lines should be totally different
and should span node boundaries
#@-node:ekr.20041012095746.30:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20041012095746.31:Node 2
node 2: line 2
#@-node:ekr.20041012095746.31:Node 2
#@-leo
</t>
<t tx="ekr.20041012095746.40">@language python
@tabwidth -4</t>
<t tx="ekr.20041012095746.41"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("importTests",doImport=True)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.42"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g

import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("exportTests",doImport=False)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.43">@language plain</t>
<t tx="ekr.20041012095746.44"></t>
<t tx="ekr.20041012095746.45"></t>
<t tx="ekr.20041012095746.46">openFileDialog
test\\unittest\\perfectImport\\formatter.py</t>
<t tx="ekr.20041012095746.47"></t>
<t tx="ekr.20041012095746.48">openFileDialog
src\\leo.py</t>
<t tx="ekr.20041012095746.49"></t>
<t tx="ekr.20041012095746.50">openFileDialog
test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20041012095746.51"></t>
<t tx="ekr.20041012095746.52">openFileDialog
test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20041012095746.53"></t>
<t tx="ekr.20041012095746.54">openFileDialog
test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20041012095746.55"></t>
<t tx="ekr.20041012095746.56">openFileDialog
test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20041012095746.57"></t>
<t tx="ekr.20041012095746.58">openFileDialog
test\\unittest\\perfectImport\\formatter.py</t>
<t tx="ekr.20041012095746.59">@language plain</t>
<t tx="ekr.20041012095746.60"></t>
<t tx="ekr.20041012095746.61"></t>
<t tx="ekr.20041012095746.62">saveFileDialog
test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20041012095746.63"></t>
<t tx="ekr.20041012095746.64">saveFileDialog
test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20041012095746.65"></t>
<t tx="ekr.20041012095746.66">saveFileDialog
test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20041012095746.67"></t>
<t tx="ekr.20041012095746.68">saveFileDialog
test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20041012095746.69"></t>
<t tx="ekr.20041012095746.70">saveFileDialog
test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20041012095746.71">@language python
@tabwidth -4</t>
<t tx="ekr.20041012095746.72">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20041012095746.73">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile2.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20041012095746.74">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile3.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20041012095746.75">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20041012095746.76">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","dist","leoDist.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20041012095746.77">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","src","LeoPy.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20041012095746.78">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","plugins","leoPlugins.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20041012095746.79">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20041012095746.80"># Apparently these file are fine when they are written.
# The problem comes later in the distribution process.

import leoGlobals as g

def checkLinuxLineEndings(filename):
    
    s = open(filename,"rb").read()
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
    assert cr == 0, "Bad Linux line ending in %s: cr: %d, nl: %d" % (cr,nl,filename)

for file in ("install","uninstall"):
    checkLinuxLineEndings(g.os_path_join(g.app.loadDir,"..",file))</t>
<t tx="ekr.20041012095746.81"></t>
<t tx="ekr.20041012095746.82"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeEditBodySuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.83">@language plain

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.</t>
<t tx="ekr.20041012095746.84"></t>
<t tx="ekr.20041012095746.85"></t>
<t tx="ekr.20041012095746.86">before
&lt;&lt; section &gt;&gt;
sec line 1
    sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20041012095746.87">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20041012095746.88">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20041012095746.89">2.0
5.0 lineend -1c</t>
<t tx="ekr.20041012095746.90"></t>
<t tx="ekr.20041012095746.91">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20041012095746.92">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20041012095746.93">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20041012095746.94"></t>
<t tx="ekr.20041012095746.95">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20041012095746.96">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20041012095746.97">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20041012095746.98"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeReformatParagraphSuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.99">@language plain

Changed made by EKR on 7/8/04.

- Created @suite node to call makeReformatParagraphSuite

- Used makeSuite(reformatParagraphTestCase,'test') in makeReformatParagraphSuite instead of list of tests.

- modified setUp to handle these new conventions.
    - Search for reformatParagraphsTests anywhere in the tree
    - Created tempNode inside reformatParagraphsTests tree.</t>
<t tx="ekr.20041012095746.100">@language plain

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth and language formatting directives
</t>
<t tx="ekr.20041012095746.101"></t>
<t tx="ekr.20041012095746.102">@language plain
@pagewidth 40
@tabwidth 8

Wrap a long line, no trailing newline.</t>
<t tx="ekr.20041012095746.103">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20041012095746.104">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20041012095746.105">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20041012095746.106">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20041012095746.107">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20041012095746.108">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20041012095746.109">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20041012095746.110">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20041012095746.111">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20041012095746.112">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20041012095746.113">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20041012095746.114">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20041012095746.115">This line is under 40 chars.</t>
<t tx="ekr.20041012095746.116">This line is under 40 chars.</t>
<t tx="ekr.20041012095746.117">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20041012095746.118">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20041012095746.119">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20041012095746.120">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20041012095746.121">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20041012095746.122">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20041012095746.123">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20041012095746.124">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20041012095746.125">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20041012095746.126">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20041012095746.127">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20041012095746.128">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20041012095746.129">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20041012095746.130">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20041012095746.131">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20041012095746.132">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Multiple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20041012095746.133">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20041012095746.134">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20041012095746.135">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20041012095746.136">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20041012095746.137">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20041012095746.138">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20041012095746.139">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20041012095746.140">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20041012095746.141">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20041012095746.142">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20041012095746.143">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20041012095746.144">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
    print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

if 0: # all nodes
    for v in c.all_vnodes_iter(): print v
    for t in c.all_tnodes_iter(): print t
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print v
    for t in c.all_unique_tnodes_iter(): print t</t>
<t tx="ekr.20041012095746.145">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"</t>
<t tx="ekr.20041012095746.146">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20041012095746.147"># Make sure that changing this headline marks descendant @thin nodes dirty.

import leoGlobals as g

c = g.top() ; p = c.currentPosition()

h = p.headString()

c.beginUpdate()
try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.headString() == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    p.setHeadString("changed")
    assert child.isDirty(), "setting descendant @thin nodes dirty failed."
finally:
    p.setHeadString(h)
    child.setHeadString("bogus")
    p.clearDirty()
    child.clearDirty()
c.endUpdate()
</t>
<t tx="ekr.20041012095746.148">test</t>
<t tx="ekr.20041012095746.149">import leoGlobals as g

c = g.top()
errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.
assert errors == 0, "Check Outline reported %d errors" % errors</t>
<t tx="ekr.20041012095746.150"># Tests that p.setBodyStringOrPane works immediately.

import leoGlobals as g

c = g.top() ; p = c.currentPosition()

h = p.headString()

try:
    child = p.firstChild()
    before = child.bodyString()
    after = "after"
    child.setBodyStringOrPane("after")
    c.selectPosition(child)
    t = c.frame.body.bodyCtrl
    s = t.get("1.0","end")
    assert s.rstrip() == after.rstrip(), \
        "setBodyStringOrPane failed: %s, %s" % (repr(s),repr(after))
finally:
    child.setBodyStringOrPane(before)
    c.selectPosition(p)</t>
<t tx="ekr.20041012095746.151">after</t>
<t tx="ekr.20041012095746.152">@language python 

import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

dump = False 
all = False 

if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = u.findNodeInTree(p,"tempNode")
    before = u.findNodeInTree(p,"before")
    after = u.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.bodyString())
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.bodyString() == after.bodyString()</t>
<t tx="ekr.20041012095746.153">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c 

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "Ä á Û"
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others </t>
<t tx="ekr.20041012095746.154">@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "Ä á Û"
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others</t>
<t tx="ekr.20041012095746.155">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c 

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "Ä á Û"
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others </t>
<t tx="ekr.20041012095746.156">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; u = leoTest.testUtils()

name = "@thin ../src/leoTest.py"

p = u.findNodeAnywhere(c,name)

assert p, "Can't find %s" % name

p.v.t.tnodeList = ["bogus tnodeList"]

if 0: # This causes p to be written, thereby clearing the tnodeList.
    p.setDirty()
    
if 0: # This actually saves this file, so it is a bit dangerous.
    g.app.unitTesting = True
    g.app.unitTestDict = {}
    c.save()
    ok = g.app.unitTestDict.get("warning")
    assert ok, "putVnode failed to give warning"
    g.app.unitTesting = False</t>
<t tx="ekr.20041012095746.157">import leoGlobals as g
assert(g.cantImport("xyzzy") is None)</t>
<t tx="ekr.20041012095746.158">@language plain
@color</t>
<t tx="ekr.20041012095746.159">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041012095746.160">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20041012095746.161">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@nonl
#@-node:@@file
#@-leo
last line 1: no newline</t>
<t tx="ekr.20041012095746.162">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041012095746.163">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20041012095746.164">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20041012095746.165">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041012095746.166">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20041012095746.167">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20041012095746.168">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041012095746.169">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20041012095746.170">#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:@@thin
Line 1

#@@last
#@nonl
#@-node:ekr.20040707141957.13:@@thin
#@-leo
last line 1: no newline</t>
<t tx="ekr.20041012095746.171"></t>
<t tx="ekr.20041012095746.172">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.173">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
continues */

More plain text.</t>
<t tx="ekr.20041012095746.174">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.175">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20041012095746.176">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.177">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20041012095746.178">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.179">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20041012095746.180">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.181">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20041012095746.182">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.183">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section references are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20041012095746.184">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20041012095746.185">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.186">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20041012095746.187">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.188">@language html

b = "cd"
d
</t>
<t tx="ekr.20041012095746.189">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.190">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20041012095746.191">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.192">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20041012095746.193">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.194">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20041012095746.195">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.196">@ignore
@ doc
@c
@language c
    @others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20041012095746.197">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.198">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20041012095746.199">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.200">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20041012095746.201">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="ekr.20041012095746.202">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="ekr.20041012095746.203">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="ekr.20041012095746.204">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="ekr.20041012095746.205">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="ekr.20041012095746.206">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="ekr.20041012095746.207">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="ekr.20041012095746.208">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20041012095746.209">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20041012095746.210">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.211">@language python

"""python
string""" ; following = a

'this\
is'''</t>
<t tx="ekr.20041012095746.212">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.213">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
    
def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20041012095746.214">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.215">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20041012095746.216">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.217">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20041012095746.218">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.219"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20041012095746.220">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.221">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20041012095746.222">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="ekr.20041012095746.223">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="ekr.20041012095746.224">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.225"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

import leoGlobals as g ; print g.app().loadDir</t>
<t tx="ekr.20041012095746.226">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.227"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

import leoGlobals as g ; print g.app().loadDir
</t>
<t tx="ekr.20041012095746.228">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041012095746.229"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass</t>
<t tx="ekr.20041012095746.230"></t>
<t tx="ekr.20041012095746.231">import leoGlobals as g
c = g.top()
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
    assert(p.t == p.v.t)</t>
<t tx="ekr.20041012095746.232">import leoGlobals as g
c = g.top()

c.frame.body.colorizer.python_keywords.append("as")</t>
<t tx="ekr.20041012095746.233">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

p = p.firstChild()
assert(p.headString()=="File Conversion")
p.convertTreeToString()</t>
<t tx="ekr.20041012095746.234">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20041012095746.235">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20041012095746.236">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.bodyString() ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20041012095746.237"># The actual test is in a child node.</t>
<t tx="ekr.20041012095746.238"></t>
<t tx="ekr.20041012095746.239">import leoGlobals as g
c = g.top()

try:
    for p in c.allNodes_iter():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            if p.v._parent: parents1 = p.v._parent.t.vnodeList
            else:           parents1 = []
            parents2 = p.v.directParents()
        
        assert len(parents1) == len(parents2), "length mismatch: %s, %s" % (p,p.v._parent)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print "parents1"
    for parent in parents1: print parent
    print "parents2"
    for parent in parents2: print parent
    raise</t>
<t tx="ekr.20041012095746.240">import leoGlobals as g
c = g.top()
try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert len(parents) == len(vparents), "length mismatch: %s,%s" % (p,child)
                for parent in parents:
                    assert parent in vparents, "not in vparents: %s,%s" % (p,child)
                for parent in vparents:
                    assert parent in parents, "not in parents: %s,%s" % (p,child)
except AssertionError:
    print "parents..."
    for parent in parents: print parent
    print "vparents..."
    for parent in vparents: print parent
    raise # for unittest.</t>
<t tx="ekr.20041012095746.241">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20041012095746.242">import leoGlobals as g
import os
import sys

verbose = False

python_interp = sys.executable
test_path = g.os_path_join(g.app.loadDir,"..","test","unittest")
src_path  = g.os_path_join(g.app.loadDir,"..","src")

leo_file   = g.os_path_join(src_path,"leo.py")
batch_file = g.os_path_join(test_path,"batchTest.py")
test_file  = g.os_path_join(test_path,"createdFile.txt")

# Execute this command: python leo.py -script test\unittest\batchTest.py

command = r"%s %s -script %s" % (python_interp,leo_file,batch_file)

@others

removeFile(test_file,verbose)
os.system(command)

try:
    g.redirectStdout()
    removeFile(test_file,verbose)
    os.system(command)
finally:
    g.restoreStdout()
    
assert(g.os_path_exists(test_file))</t>
<t tx="ekr.20041012095746.243">def removeFile(path,verbose):

    if os.path.exists(test_file):
        if verbose:
            print "@test batch mode: deleting",test_file
        os.remove(test_file)
    else:
        if verbose:
            print "@test batch mode: not found:",test_file
</t>
<t tx="ekr.20041012095746.244"></t>
<t tx="ekr.20041012095746.245">import leoNodes
import leoGlobals as g

c = g.top()
current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print v
    for v in vList2: print v

if 0:
    print len(allList),len(vList1),len(vList2)

&lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="ekr.20041012095746.246"></t>
<t tx="ekr.20041012095746.247"></t>
<t tx="ekr.20041012095746.248"></t>
<t tx="ekr.20041012095746.249"></t>
<t tx="ekr.20041012095746.250"></t>
<t tx="ekr.20041012095746.251"></t>
<t tx="ekr.20041012095746.252"></t>
<t tx="ekr.20041012095746.253">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    # print "consistency tests pass"

except AssertionError:
    print tag
    print "list1"
    for v in list1: print v
    print "list2"
    for v in list2: print v
    raise</t>
<t tx="ekr.20041012095746.254">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20041012095746.255">if 0:
    for v in current.vnodes_iter(): print v
    for v in current.unique_vnodes_iter(): print v

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print v
    for t in root.tnodes_iter(): print t

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print v
    for t in child.tnodes_iter(): print t</t>
<t tx="ekr.20041012095746.256">import leoGlobals as g
c = g.top()
p = c.currentPosition()
    
assert(p == p.copy())
assert(p != p.threadNext())</t>
<t tx="ekr.20041012095746.257">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20041012095746.258">import leoGlobals as g
c = g.top()

for copy in (True,False):
    p2 = c.rootPosition()
    for p in c.allNodes_iter(copy=copy):
        assert p==p2, "%s != %s" % (p,p2)
        p2.moveToThreadNext()
        
    assert not p2, repr(p2)
</t>
<t tx="ekr.20041012095746.259">import leoGlobals as g
c = g.top()

for copy in (True,False):
    for p in c.allNodes_iter(copy=copy):
        
        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToNext()

    assert not p2, repr(p2)</t>
<t tx="ekr.20041012095746.260">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)
        
    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())</t>
<t tx="ekr.20041012095746.261">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)</t>
<t tx="ekr.20041012095746.262">import leoGlobals as g
c = g.top()

for copy in (True,False):

    for p in c.allNodes_iter():
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToParent()

        assert not p2, repr(p2)</t>
<t tx="ekr.20041012095746.263"># Test consistency of p.parent, p.next, p.back and p.firstChild.

import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))
        
    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())
        
    if p.hasBack():
        assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20041012095746.264">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20041012095746.265">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned():
        parents = p.v.t.vnodeList
        for child in p.children_iter():
            vparents = child.v.directParents()
            assert(len(parents) == len(vparents))
            for parent in parents:
                assert(parent in vparents)
            for parent in vparents:
                assert(parent in parents)</t>
<t tx="ekr.20041012095746.266">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))
            
    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))</t>
<t tx="ekr.20041012095746.267">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))
            
    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))</t>
<t tx="ekr.20041012095746.268">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))
            
    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20041012095746.269">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    vnodeList = p.v.t.vnodeList

    for v in vnodeList:

        assert(v.t == p.v.t)
        if p.v.isCloned():
            assert(v.isCloned())
            assert(len(vnodeList) &gt; 1)
        else:
            assert(not v.isCloned())
            assert(len(vnodeList) == 1)</t>
<t tx="ekr.20041012095746.270">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    child = p.firstChild()
    while child:
        for parent in p.self_and_parents_iter():
            assert parent.isAncestorOf(child)
        child.moveToNext()

    next = p.next()
    assert not p.isAncestorOf(next)</t>
<t tx="ekr.20041012095746.271"></t>
<t tx="ekr.20041012095746.272">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import unittest

c = g.top()

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False,suppressErrors=True)

assert result=="error", "checkPythonCode returns: %s" % result
</t>
<t tx="ekr.20041012095746.273">import string

string.join(a,b] # A syntax error</t>
<t tx="ekr.20041012095746.274">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import unittest

c = g.top()

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False,suppressErrors=True)

assert result=="error", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20041012095746.275">@tabwidth 4

# Tabnanny _only_ checks errors involving tabs.
# It does _not_ check other indentation errors.
# It does _not_ check syntax.

if 1: # Essential, so we don't create a syntax error.
    a = 5
	b = 6 #Contains tab.
    c = 3</t>
<t tx="ekr.20041012095746.276">import leoGlobals as g

c = g.top()

result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20041012095746.277">import leoGlobals as g
import unittest
import leoTest
reload(leoTest)
import sys

c = g.top()

# DocTestSuite exists in Python 2.3 and above.

if g.CheckVersion(sys.version, "2.3"):

    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    
    suite = leoTest.createUnitTestsFromDoctests(modules)
                                
    if suite:
        g.app.scriptDict['suite'] = suite
        
else:
    # Create an empty suite to suppress a warning.
    g.app.scriptDict['suite'] = unittest.TestSuite()
    print
    print "Can't create unit tests from doctests"
    print "doctest.DocTestSuite requires Python 2.3 or above."
    print</t>
<t tx="ekr.20041012095746.278"></t>
<t tx="ekr.20041012095746.279"># N.B.  We don't import the files: multiple imports might cause problems.
import leoGlobals as g
import unittest
import leoTest
reload(leoTest)

c = g.top()

@others

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():

    f = file(path)
    assert f, "File not found: %s" % path
    s = f.read() ; f.close()
    test = parseFileTestCase(c,path,checkCompile=True,checkTabs=True)
    suite.addTest(test)

if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.280">class parseFileTestCase (unittest.TestCase):

    @others</t>
<t tx="ekr.20041012095746.281">def __init__ (self,c,path,checkCompile,checkTabs):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.checkCompile = checkCompile
    self.checkTabs = checkTabs
    assert self.checkCompile or self.checkTabs, "not checking anything"</t>
<t tx="ekr.20041012095746.282">def runTest(self):
    
    c = self.c ; path = self.path

    s = file(path).read()

    if self.checkCompile:
        leoTest.checkFileSyntax(path,s)

    if self.checkTabs:
        leoTest.checkFileTabs(path,s)</t>
<t tx="ekr.20041012095746.283">def shortDescription (self):
    
    fn = str(g.shortFileName(self.path))
    
    if self.checkCompile and self.checkTabs:
        return "Test syntax and tabbing of %s plugin" % fn
    elif self.checkCompile:
        return "Test syntax of %s plugin" % fn
    else:
        return "Test tabbing of %s plugin" % fn</t>
<t tx="ekr.20041012095746.284"># WARNING: Importing files this way tends to crash test.leo.

import leoGlobals as g
import unittest
import leoTest
reload(leoTest)

c = g.top()
verbose = False

@others

suite = unittest.makeSuite(unittest.TestCase)

g.app.unitTesting = True # Disable additional installation.

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():
    dir,fileName = g.os_path_split(path)
    try:
        module = g.importFromPath(fileName,dir)
    except:
        s = "Can not import %s" % path
        print s ; g.es(s)
        module = None
    
    # Run any unit tests in the module itself.
    if module and hasattr(module,"unitTest"):
        if verbose:
            print "Creating unit test for plugins/%s..." % fileName
        test = runPluginTestCase(c,path,module,verbose=verbose)
        suite.addTest(test)

    g.app.unitTesting = True # Disable additional installation.

if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.285">class runPluginTestCase (unittest.TestCase):

    @others</t>
<t tx="ekr.20041012095746.286">def __init__ (self,c,path,module,verbose=False):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.module = module</t>
<t tx="ekr.20041012095746.287">def runTest(self):
    
    fn = g.shortFileName(self.path)
    
    self.module.unitTest(verbose=verbose)</t>
<t tx="ekr.20041012095746.288">def shortDescription (self):
    
    fn = str(g.shortFileName(self.path))
    
    return "Run unitTest function in %s plugin if it exists" % fn</t>
<t tx="ekr.20041012095746.289">import leoGlobals as g
import leoTest
reload(leoTest)

leoTest.testPlugin("nodenavigator.py",verbose=False)</t>
<t tx="ekr.20041012095746.290"></t>
<t tx="ekr.20041012095746.291"></t>
<t tx="ekr.20041012095746.292">import leoGlobals as g
import leoNodes

c = g.top();  p = c.currentPosition()
root1 = p.firstChild()

root2 = root1.copyTreeAfter()
root2.initHeadString("root2")
c.checkOutline()
c.redraw()
root2.doDelete(root1)
c.checkOutline()
c.redraw()</t>
<t tx="ekr.20041012095746.293"></t>
<t tx="ekr.20041012095746.294"></t>
<t tx="ekr.20041012095746.295"></t>
<t tx="ekr.20041012095746.296"></t>
<t tx="ekr.20041012095746.297"></t>
<t tx="ekr.20041012095746.298">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.headString()=="outline1")
assert(outline2.headString()=="outline2")

u.replaceOutline(c,outline1,outline2)
c.redraw()
c.checkOutline()</t>
<t tx="ekr.20041012095746.299"></t>
<t tx="ekr.20041012095746.300"></t>
<t tx="ekr.20041012095746.301"></t>
<t tx="ekr.20041012095746.302"></t>
<t tx="ekr.20041012095746.303">def replaceOutline (self,c,outline1,outline2):
    
    """Replace outline1 by a copy of outline 2,
    
    retaining the headline of outline1."""

    u = self
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete(copy)</t>
<t tx="ekr.20041012095746.304"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = makeOutlineSuite("outlineTests")

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.305">def makeOutlineSuite(parentHeadline):
    
    """Create an outline test for every descendant of testParentHeadline.."""
    
    c = g.top() ; v = c.currentVnode()
    u = leoTest.testUtils()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    parent = u.findNodeAnywhere(c,parentHeadline)
    
    for child in parent.children_iter(copy=True):
        before = u.findNodeInTree(child,"before")
        after  = u.findNodeInTree(child,"after")
        ref    = u.findNodeInTree(child,"ref")
        if before and after and ref:
            test = outlineTestCase(c,child,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20041012095746.306">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20041012095746.307">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.u = leoTest.testUtils()

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref</t>
<t tx="ekr.20041012095746.308">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert move, "no move node"
    
    c.selectVnode(move)
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()

    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))</t>
<t tx="ekr.20041012095746.309">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20041012095746.310">def setUp(self,*args,**keys):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert self.u.compareOutlines(self.before,self.ref,compareHeadlines=False),\
        "compare failed"
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20041012095746.311">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()</t>
<t tx="ekr.20041012095746.312">def shortDescription (self):
    
    return self.parent.headString()</t>
<t tx="ekr.20041012095746.313"></t>
<t tx="ekr.20041012095746.314"></t>
<t tx="ekr.20041012095746.315"></t>
<t tx="ekr.20041012095746.316"></t>
<t tx="ekr.20041012095746.317"></t>
<t tx="ekr.20041012095746.318"></t>
<t tx="ekr.20041012095746.319"></t>
<t tx="ekr.20041012095746.320"></t>
<t tx="ekr.20041012095746.321"></t>
<t tx="ekr.20041012095746.322"></t>
<t tx="ekr.20041012095746.323"></t>
<t tx="ekr.20041012095746.324"></t>
<t tx="ekr.20041012095746.325"></t>
<t tx="ekr.20041012095746.326"></t>
<t tx="ekr.20041012095746.327"></t>
<t tx="ekr.20041012095746.328"></t>
<t tx="ekr.20041012095746.329"></t>
<t tx="ekr.20041012095746.330"></t>
<t tx="ekr.20041012095746.331"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = unittest.makeSuite(findCommandTestCase,'test')

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20041012095746.332">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20041012095746.333">def setUp(self,*args,**keys):
    
    self.u = u = leoTest.testUtils()
    self.c = c = g.top()
    self.find_p = u.findNodeAnywhere(c,"findTests")
    
    assert(self.find_p)
</t>
<t tx="ekr.20041012095746.334">def testFindCommand (self):
    
    pass</t>
<t tx="ekr.20041012095746.335">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20041012095746.336">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20041012095746.337">aaa</t>
<t tx="ekr.20041012095746.338"># You can run all tests by selecting the Unit Test headline.

import leoTest
reload(leoTest)

leoTest.doTests(all=False)</t>
<t tx="ekr.20041012095746.339"># You can run all tests by selecting the Unit Test headline.

import leoTest
reload(leoTest)

leoTest.doTests(all=False)</t>
<t tx="ekr.20041012111712">- Webs are outlines in disguise.

- Using MORE as a prototype:  very lucky.</t>
<t tx="ekr.20041012111712.1"></t>
<t tx="ekr.20041012111712.2"></t>
<t tx="ekr.20041012111712.3"></t>
<t tx="ekr.20041012111712.4"></t>
<t tx="ekr.20041012111712.5"></t>
<t tx="ekr.20041012111712.6"></t>
<t tx="ekr.20041012111951"></t>
<t tx="ekr.20041012112045"></t>
<t tx="ekr.20041012112259"></t>
<t tx="ekr.20041012114739">- How many have heard of Literate Programming?

- How many use it?

- How many write complex programs?</t>
</tnodes>
</leo_file>
