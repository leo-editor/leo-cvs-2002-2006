<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="5213" clone_windows="0"/>
<globals body_outline_ratio="0.473917869034">
	<global_window_position top="12" left="402" height="901" width="840"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="EKR.20040519090151"><vh>Diary</vh>
<v t="ekr.20031218072017"><vh>@thin ../doc/leoDiary.txt</vh></v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20031218072017.2865,ekr.20031218072017.2114,ekr.20031218072017.1863,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="ekr.20040706080316"><vh>Projects: 4.2 b3</vh>
<v t="ekr.20040705194708"><vh>(Cleaned up recognition of @file nodes)</vh>
<v t="ekr.20031218072017.3152"><vh>g.scanAtFileOptions (used in 3.x read code)</vh>
<v t="ekr.20031218072017.3153"><vh>&lt;&lt; scan another @file option &gt;&gt;</vh></v>
</v>
<v t="ekr.20040705195048"><vh>skip_id</vh></v>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20031218072017.3346"><vh>v.Comparisons</vh>
<v t="ekr.20040705201018"><vh>findAtFileName (new in 4.2 b3)</vh></v>
<v t="ekr.20031218072017.3350"><vh>anyAtFileNodeName</vh></v>
<v t="ekr.20031218072017.3348"><vh>at...FileNodeName</vh></v>
<v t="EKR.20040430152000"><vh>isAtAllNode</vh></v>
<v t="ekr.20040326031436"><vh>isAnyAtFileNode good</vh></v>
<v t="ekr.20040325073709"><vh>isAt...FileNode</vh></v>
<v t="ekr.20031218072017.3351"><vh>isAtIgnoreNode</vh></v>
<v t="ekr.20031218072017.3352"><vh>isAtOthersNode</vh></v>
<v t="ekr.20031218072017.3353"><vh>matchHeadline</vh></v>
</v>
</v>
<v t="ekr.20040705071418"><vh>(Made sure the user is given a chance to save read-only files)</vh>
<v t="ekr.20040706111156"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2609"><vh>app.closeLeoWindow</vh></v>
<v t="ekr.20031218072017.3692"><vh>promptForSave</vh>
<v t="ekr.20031218072017.3693"><vh>&lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1720"><vh>save</vh></v>
<v t="ekr.20031218072017.3046"><vh>write_Leo_file</vh>
<v t="ekr.20040324080359"><vh>&lt;&lt; write all @file nodes &gt;&gt;</vh></v>
<v t="ekr.20040324080359.1"><vh>&lt;&lt; return if the .leo file is read-only &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3047"><vh>&lt;&lt; create backup file &gt;&gt;</vh></v>
<v t="ekr.20040324080359.2"><vh>&lt;&lt; create the output file &gt;&gt;</vh>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
<v t="ekr.20040324080819"><vh>&lt;&lt; update leoConfig.txt &gt;&gt;</vh></v>
<v t="ekr.20040324080819.1"><vh>&lt;&lt; put the .leo file &gt;&gt;</vh></v>
<v t="ekr.20040324080819.2"><vh>&lt;&lt; report the exception &gt;&gt;</vh></v>
<v t="ekr.20040324080819.3"><vh>&lt;&lt; close the output file &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3049"><vh>&lt;&lt; erase filename and rename backupName to fileName &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3048"><vh>&lt;&lt; delete backup file &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040709085421"><vh>(Added p.copyTreeAfter, copyTreeTo)</vh>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
</v>
<v t="ekr.20040707144444"><vh>(Improved unit testing)</vh>
<v t="ekr.20040707150139"><vh>What I did</vh></v>
<v t="EKR.20040614071102.1"><vh>g.getScript</vh></v>
<v t="ekr.20031218072017.2140"><vh>c.executeScript</vh>
<v t="ekr.20031218072017.2143"><vh>&lt;&lt; redirect output &gt;&gt;</vh></v>
<v t="EKR.20040612215018"><vh>&lt;&lt; dump the lines of script near the error &gt;&gt;</vh></v>
<v t="EKR.20040627100424"><vh>&lt;&lt; unredirect output &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh>
<v t="ekr.20040314062338"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040313150633"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040323155951"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040314035615"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040314035615.1"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040314035615.2"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040323155951.1"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040323161837"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162707"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040314043623"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040731053740"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040314043900"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040314044652"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040709065122"><vh>(Added 3 .css files to cvs and distribution)</vh></v>
<v t="ekr.20040709075150"><vh>(Fixed double-click-drag) Now reverted</vh>
<v t="ekr.20040709075150.1"><vh>Patch</vh></v>
<v t="ekr.20040709094545"><vh>In app.gui.Tkinter.utils</vh>
<v t="ekr.20031218072017.4089"><vh>setTextSelection</vh></v>
</v>
<v t="ekr.20031218072017.3978"><vh>OnBodyDoubleClick (Events)</vh></v>
<v t="ekr.20031218072017.838"><vh>tkBody.createBindings</vh></v>
<v t="ekr.20031218072017.3977"><vh>OnBodyClick, OnBodyRClick (Events)</vh></v>
<v t="ekr.20031218072017.3975"><vh>OnActivateBody</vh></v>
</v>
<v t="ekr.20040709080432"><vh>(Scroll the tree pane on Shift left/right click)</vh>
<v t="ekr.20040709151825"><vh>Changed find_closest to find_overlapping</vh></v>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas</vh>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040709144318.1"><vh>(Underline tree nodes when entered)</vh></v>
<v t="ekr.20040709064521"><vh>(Allowed multiple files in import dialogs)</vh>
<v t="ekr.20040709101338"><vh>Report</vh></v>
<v t="ekr.20031218072017.3097"><vh>CheckVersion (Dave Hein)</vh></v>
<v t="ekr.20031218072017.4057"><vh>app.gui.Tkinter file dialogs</vh></v>
<v t="ekr.20040709104835"><vh>Changed import commands to accept lists of paths</vh>
<v t="ekr.20031218072017.2849"><vh>Import&amp;Export submenu</vh>
<v t="ekr.20031218072017.2850"><vh>exportHeadlines</vh></v>
<v t="ekr.20031218072017.2851"><vh>flattenOutline</vh></v>
<v t="ekr.20031218072017.2852"><vh>importAtRoot</vh></v>
<v t="ekr.20031218072017.2853"><vh>importAtFile</vh></v>
<v t="ekr.20031218072017.2854"><vh>importCWEBFiles</vh></v>
<v t="ekr.20031218072017.2855"><vh>importFlattenedOutline</vh></v>
<v t="ekr.20031218072017.2856"><vh>importNowebFiles</vh></v>
<v t="ekr.20031218072017.2857"><vh>outlineToCWEB</vh></v>
<v t="ekr.20031218072017.2858"><vh>outlineToNoweb</vh></v>
<v t="ekr.20031218072017.2859"><vh>removeSentinels</vh></v>
<v t="ekr.20031218072017.2860"><vh>weave</vh></v>
</v>
</v>
<v t="ekr.20040709104835.1"><vh>Changed import helpers to accept lists of paths</vh>
<v t="ekr.20031218072017.3300"><vh>removeSentinelsCommand</vh>
<v t="ekr.20031218072017.3301"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3302"><vh>&lt;&lt; set delims from the header line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1149"><vh>&lt;&lt; Write s into newFileName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3226"><vh>importWebCommand</vh></v>
<v t="ekr.20031218072017.3212"><vh>importFilesCommand</vh>
<v t="ekr.20031218072017.3213"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1810"><vh>importDerivedFiles</vh></v>
<v t="ekr.20031218072017.3210"><vh>createOutline</vh>
<v t="ekr.20031218072017.3211"><vh>&lt;&lt; Read file into s &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040711135244"><vh>(Improved g.importFromPath)</vh>
<v t="ekr.20031218072017.2278"><vh>g,importFromPath</vh></v>
</v>
<v t="ekr.20040712112449"><vh>(Removed scriptfile support)</vh>
<v t="EKR.20040614071102.1"><vh>g.getScript</vh></v>
</v>
<v t="ekr.20040712135130"><vh>(Fixed major bug in write logic)</vh>
<v t="ekr.20040712135130.1"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040715094645"><vh>(Fix open bug)</vh>
<v t="ekr.20040715100724"><vh>Report</vh></v>
<v t="ekr.20031218072017.4057"><vh>app.gui.Tkinter file dialogs</vh></v>
<v t="ekr.20031218072017.2821"><vh>open</vh>
<v t="ekr.20031218072017.2822"><vh>&lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040712082657"><vh>(Removed headline check logic in atFile read logic)</vh>
<v t="ekr.20040715171241"><vh>Report</vh></v>
<v t="ekr.20031218072017.2007"><vh>findChild 4.x (@file only)</vh>
<v t="ekr.20040716061450"><vh>&lt;&lt; Check the headlines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040718163531"><vh>(Fix pretty-printing bug)</vh>
<v t="ekr.20040718163531.1"><vh>Report</vh></v>
</v>
<v t="ekr.20040711135244.2"><vh>(Finished all commands in the Outline Check submenu)</vh>
<v t="ekr.20040713094547"><vh>To do</vh></v>
<v t="ekr.20040712045017"><vh>Notes</vh></v>
<v t="ekr.20040713085052"><vh>undo...</vh>
<v t="EKR.20040526090701.1"><vh>redoChangeAll</vh></v>
<v t="EKR.20040526090701.5"><vh>undoChangeAll</vh></v>
<v t="ekr.20031218072017.1493"><vh>undoRedoText</vh>
<v t="ekr.20031218072017.1494"><vh>&lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1495"><vh>&lt;&lt; Compute the result using v's body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1496"><vh>&lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1497"><vh>&lt;&lt; print mismatch trace &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040713081916"><vh>selection stuff</vh>
<v t="ekr.20040305223522"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20031218072017.4024"><vh>setTextSelection (tkinterBody)</vh></v>
<v t="ekr.20031218072017.4037"><vh>setSelectionAreas (tkinterBody)</vh></v>
</v>
<v t="ekr.20040712144354"><vh>in leoGlobals...</vh>
<v t="EKR.20040614071102.1"><vh>g.getScript</vh></v>
<v t="ekr.20031218072017.1260"><vh>get_directives_dict &amp; globalDirectiveList</vh>
<v t="ekr.20031218072017.1261"><vh>&lt;&lt; set dict for @ directives &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1262"><vh>&lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1391"><vh>scanDirectives (utils)</vh>
<v t="ekr.20031218072017.1392"><vh>&lt;&lt; Set local vars &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1393"><vh>&lt;&lt; Test for @comment and @language &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1394"><vh>&lt;&lt; Test for @encoding &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1395"><vh>&lt;&lt; Test for @lineending &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1396"><vh>&lt;&lt; Test for @pagewidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1397"><vh>&lt;&lt; Test for @path &gt;&gt;</vh>
<v t="ekr.20031218072017.1398"><vh>&lt;&lt; compute relative path from s[k:] &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1399"><vh>&lt;&lt; Test for @tabwidth &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1400"><vh>&lt;&lt; Test for @wrap and @nowrap &gt;&gt;</vh></v>
</v>
<v t="ekr.20040712084911.1"><vh>scanForAtLanguage</vh></v>
<v t="ekr.20040715155607"><vh>scanForAtIgnore</vh></v>
<v t="ekr.20031218072017.3112"><vh>es_exception</vh>
<v t="ekr.20040731211839"><vh>&lt;&lt; look for lines containing a specific message &gt;&gt;</vh>
<v t="EKR.20040612223431"><vh>&lt;&lt; compute n from the line &gt;&gt;</vh></v>
</v>
<v t="ekr.20040731204831"><vh>getLastTracebackLineNumber</vh></v>
</v>
</v>
<v t="ekr.20040712100041"><vh>Write stuff...</vh>
<v t="ekr.20031218072017.2128"><vh>putBody (4.x)</vh>
<v t="EKR.20040429084140"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2129"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2111"><vh>Writing (4.x)</vh>
<v t="ekr.20031218072017.2112"><vh>Top level</vh>
<v t="ekr.20031218072017.2113"><vh>new_df.closeWriteFile</vh></v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="EKR.20040506075328"><vh>new_df.writeOpenFile</vh>
<v t="EKR.20040506075328.1"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2118"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20031218072017.2119"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2122"><vh>new_df.norefWrite</vh>
<v t="ekr.20031218072017.2123"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20031218072017.2124"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2125"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2126"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2127"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2128"><vh>putBody (4.x)</vh>
<v t="EKR.20040429084140"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2129"><vh>&lt;&lt; handle line at s[i]  &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2130"><vh>code lines... (4.x)</vh>
<v t="EKR.20040430081109.1"><vh>@all</vh>
<v t="EKR.20040430080943.1"><vh>putAtAllLine</vh></v>
<v t="EKR.20040430104717"><vh>putatAllBody</vh>
<v t="EKR.20040430104717.1"><vh>&lt;&lt; Make sure all lines end in a newline &gt;&gt;</vh></v>
</v>
<v t="EKR.20040430080943.2"><vh>putAtAllChild</vh></v>
</v>
<v t="EKR.20040430081109.2"><vh>@others</vh>
<v t="ekr.20031218072017.2131"><vh>inAtOthers</vh></v>
<v t="ekr.20031218072017.2132"><vh>putAtOthersChild</vh></v>
<v t="ekr.20031218072017.2133"><vh>putAtOthersLine</vh></v>
</v>
<v t="ekr.20031218072017.2134"><vh>putCodeLine</vh></v>
<v t="ekr.20031218072017.2106"><vh>putRefLine &amp; allies</vh>
<v t="EKR.20040430081109"><vh>putRefLine</vh></v>
<v t="ekr.20031218072017.2107"><vh>putRefAt</vh></v>
<v t="ekr.20031218072017.2108"><vh>putAfterLastRef</vh></v>
<v t="ekr.20031218072017.2109"><vh>putAfterMiddleef</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1745"><vh>doc lines... (write)</vh>
<v t="ekr.20031218072017.1746"><vh>putBlankDocLine</vh></v>
<v t="ekr.20031218072017.1747"><vh>putStartDocLine</vh></v>
<v t="ekr.20031218072017.1748"><vh>putDocLine</vh>
<v t="ekr.20031218072017.1749"><vh>&lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1750"><vh>putEndDocLine</vh></v>
<v t="ekr.20031218072017.1751"><vh>putPending</vh></v>
</v>
<v t="ekr.20031218072017.2135"><vh>Writing Utils...</vh>
<v t="ekr.20031218072017.2136"><vh>directiveKind (4.x)</vh></v>
<v t="ekr.20031218072017.2137"><vh>hasSectionName</vh></v>
<v t="ekr.20031218072017.2138"><vh>os and allies</vh>
<v t="EKR.20040620094529"><vh>oblank, oblanks &amp; otabs</vh></v>
<v t="EKR.20040620094529.1"><vh>onl &amp; onl_sent</vh></v>
<v t="EKR.20040620094529.2"><vh>os</vh></v>
</v>
<v t="ekr.20031218072017.1921"><vh>putDirective  (handles @delims,@comment,@language) 4.x</vh>
<v t="ekr.20031218072017.1922"><vh>&lt;&lt; handle @delims &gt;&gt;</vh></v>
<v t="EKR.20040625103148"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625103148.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2132"><vh>putAtOthersChild</vh></v>
</v>
<v t="ekr.20040711141625"><vh>Menu stuff...</vh>
<v t="ekr.20031218072017.3797"><vh>&lt;&lt; create the outline menu &gt;&gt;</vh>
<v t="ekr.20040711140738.1"><vh>&lt;&lt; create check submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3798"><vh>&lt;&lt; create expand/contract submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3799"><vh>&lt;&lt; create move submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3800"><vh>&lt;&lt; create mark submenu &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3801"><vh>&lt;&lt; create goto submenu &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3752"><vh>defineMenuTables</vh>
<v t="ekr.20031218072017.3753"><vh>&lt;&lt; define edit menu tables &gt;&gt;</vh>
<v t="ekr.20031218072017.839"><vh>&lt;&lt; define editMenuTopTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3754"><vh>&lt;&lt; define editMenuEditBodyTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3755"><vh>&lt;&lt; define editMenuEditHeadlineTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3756"><vh>&lt;&lt; define editMenuFindMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3757"><vh>&lt;&lt; define editMenuTop2Table &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3758"><vh>&lt;&lt; define file menu tables &gt;&gt;</vh>
<v t="ekr.20031218072017.3759"><vh>&lt;&lt; define fileMenuTopTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3760"><vh>&lt;&lt; define fileMenuTop2Table &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3761"><vh>&lt;&lt; define fileMenuReadWriteMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3762"><vh>&lt;&lt; define fileMenuTangleMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3763"><vh>&lt;&lt; define fileMenuUntangleMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3764"><vh>&lt;&lt; define fileMenuImportMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3765"><vh>&lt;&lt; define fileMenuExportMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3766"><vh>&lt;&lt; define fileMenuTop3MenuTable &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3767"><vh>&lt;&lt; define outline menu tables &gt;&gt;</vh>
<v t="ekr.20031218072017.3768"><vh>&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;</vh></v>
<v t="ekr.20040711140738"><vh>&lt;&lt; define outlineMenuCheckOutlineMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3769"><vh>&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3770"><vh>&lt;&lt; define outlineMenuMoveMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3771"><vh>&lt;&lt; define outlineMenuMarkMenuTable &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3772"><vh>&lt;&lt; define outlineMenuGoToMenuTable &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3773"><vh>&lt;&lt; define window menu tables &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3774"><vh>&lt;&lt; define help menu tables &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040711135959.2"><vh>Check Outline submenu...</vh>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh>
<v t="ekr.20040314062338"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040313150633"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040323155951"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040314035615"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040314035615.1"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040314035615.2"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040323155951.1"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040323161837"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162707"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040314043623"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040731053740"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040314043900"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040314044652"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20040723094220.1"><vh>checkAllPythonCode</vh>
<v t="ekr.20040723094220.2"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220.3"><vh>checkPythonCode</vh>
<v t="ekr.20040723094220.4"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220.5"><vh>checkPythonNode</vh></v>
<v t="ekr.20040723094220.6"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20040412060927"><vh>c.dumpOutline</vh></v>
<v t="ekr.20040711135959.1"><vh>Pretty Print commands</vh>
<v t="ekr.20040712053025"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20040712053025.1"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20040711135244.5"><vh>class prettyPrinter</vh>
<v t="ekr.20040711135244.6"><vh>__init__</vh></v>
<v t="ekr.20040713093048"><vh>clear</vh></v>
<v t="ekr.20040713064323"><vh>dumpLines</vh></v>
<v t="ekr.20040711135244.7"><vh>dumpToken</vh></v>
<v t="ekr.20040711135244.8"><vh>get</vh></v>
<v t="ekr.20040711135244.4"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040711135244.9"><vh>put</vh></v>
<v t="ekr.20040711135244.10"><vh>putNormalToken</vh></v>
<v t="ekr.20040711135244.11"><vh>putOperator</vh></v>
<v t="ekr.20040711135244.12"><vh>putToken</vh></v>
<v t="ekr.20040713070356"><vh>replaceBody</vh></v>
<v t="ekr.20040713091855"><vh>endUndo</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040719151353"><vh>(Fixed MAJOR bug in p.isAncestorOf)</vh>
<v t="ekr.20040722043212"><vh>Notes</vh></v>
<v t="ekr.20040722043212.1"><vh>Traceback</vh></v>
<v t="ekr.20040307104131.1"><vh>p.isAncestorOf</vh></v>
</v>
<v t="ekr.20040722045721"><vh>Examined possible compatibility problems using old-style scripts: NO PROBLEM)</vh>
<v t="ekr.20040722045721.1"><vh>Notes</vh></v>
</v>
<v t="ekr.20040722052045"><vh>(Examined find.selectNextVnode)</vh>
<v t="ekr.20040722052045.1"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3081"><vh>selectNextVnode</vh></v>
<v t="ekr.20031218072017.3075"><vh>findNextMatch</vh></v>
</v>
<v t="ekr.20040721151247"><vh>(Fixed bug in putTnodes)</vh>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1575"><vh>putTnodes</vh>
<v t="ekr.20031218072017.1576"><vh>&lt;&lt; write only those tnodes that were referenced &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040506075328.3"><vh>(Perfect Import)</vh>
<v t="ekr.20040717133553"><vh>What I did</vh></v>
<v t="ekr.20040716105102.1"><vh>(Fixed bugs with handling @nonl)</vh>
<v t="EKR.20040505080156.2"><vh>removeSentinelsFromFile/Lines</vh>
<v t="ekr.20040716105102"><vh>&lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;</vh></v>
</v>
<v t="EKR.20040504150046.6"><vh>create_mapping</vh></v>
</v>
<v t="ekr.20040718042049"><vh>From atFile...</vh>
<v t="ekr.20031218072017.2756"><vh>Reading (4.x)</vh>
<v t="ekr.20040321064134.5"><vh>createThinChild (4.2: @thin only)</vh></v>
<v t="ekr.20031218072017.2757"><vh>new_df.readOpenFile</vh></v>
<v t="ekr.20031218072017.2007"><vh>findChild 4.x (@file only)</vh>
<v t="ekr.20040716061450"><vh>&lt;&lt; Check the headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2758"><vh>scanText4 &amp; allies</vh>
<v t="ekr.20031218072017.2759"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2760"><vh>&lt;&lt; report unexpected end of text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2761"><vh>readNormalLine</vh>
<v t="ekr.20031218072017.2762"><vh>&lt;&lt; Skip the leading stuff &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2763"><vh>&lt;&lt; Append s to docOut &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2764"><vh>start sentinels</vh>
<v t="EKR.20040430081719"><vh>readStartAll (4.2)</vh></v>
<v t="ekr.20031218072017.1752"><vh>readStartAt &amp; readStartDoc</vh></v>
<v t="ekr.20031218072017.2765"><vh>readStartLeo</vh></v>
<v t="EKR.20040524070500"><vh>readStartMiddle</vh></v>
<v t="ekr.20031218072017.2766"><vh>readStartNode (4.x)</vh>
<v t="EKR.20040427105350"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2767"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2768"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2769"><vh>readStartOthers</vh></v>
</v>
<v t="ekr.20031218072017.2770"><vh>end sentinels</vh>
<v t="EKR.20040430081719.1"><vh>readEndAll (4.2)</vh></v>
<v t="ekr.20031218072017.1954"><vh>readEndAt &amp; readEndDoc</vh></v>
<v t="ekr.20031218072017.2771"><vh>readEndLeo</vh></v>
<v t="EKR.20040524071414"><vh>readEndMiddle</vh></v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2773"><vh>readEndOthers</vh></v>
<v t="ekr.20031218072017.1753"><vh>readLastDocLine</vh>
<v t="ekr.20031218072017.1754"><vh>&lt;&lt; new code &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1755"><vh>&lt;&lt; old code &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2774"><vh>Unpaired sentinels</vh>
<v t="ekr.20031218072017.2775"><vh>ignoreOldSentinel</vh></v>
<v t="ekr.20031218072017.2776"><vh>readAfterRef</vh></v>
<v t="EKR.20040520093903"><vh>readClone</vh></v>
<v t="ekr.20031218072017.2777"><vh>readComment</vh></v>
<v t="ekr.20031218072017.2778"><vh>readDelims</vh></v>
<v t="ekr.20031218072017.2779"><vh>readDirective</vh>
<v t="EKR.20040625104908"><vh>&lt;&lt; handle @language &gt;&gt;</vh></v>
<v t="EKR.20040625104908.1"><vh>&lt;&lt; handle @comment &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2780"><vh>readNl</vh></v>
<v t="ekr.20031218072017.2781"><vh>readNonl</vh></v>
<v t="ekr.20031218072017.2782"><vh>readRef</vh></v>
<v t="ekr.20031218072017.2783"><vh>readVerbatim</vh></v>
</v>
<v t="ekr.20031218072017.2784"><vh>badEndSentinel, push/popSentinelStack</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2114"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2757"><vh>new_df.readOpenFile</vh></v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040718042049.1"><vh>From leoGlobals...</vh>
<v t="EKR.20040504150046.4"><vh>g.comment_delims_from_extension</vh></v>
<v t="ekr.20040331083824.1"><vh>g.fileLikeObject</vh></v>
<v t="EKR.20040504154039"><vh>g.is_sentinel</vh>
<v t="ekr.20040719161756"><vh>&lt;&lt; is_sentinel doc tests &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040504150046"><vh>class mulderUpdateAlgorithm (leoGlobals)</vh>
<v t="EKR.20040504150046.3"><vh>__init__</vh></v>
<v t="EKR.20040504150046.9"><vh>copy_sentinels</vh></v>
<v t="EKR.20040504155109"><vh>copy_time</vh></v>
<v t="EKR.20040504150046.6"><vh>create_mapping</vh></v>
<v t="EKR.20040505080156"><vh>Get or remove sentinel lines</vh>
<v t="EKR.20040505081121"><vh>separateSentinelsFromFile/Lines</vh></v>
<v t="EKR.20040505080156.2"><vh>removeSentinelsFromFile/Lines</vh>
<v t="ekr.20040716105102"><vh>&lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;</vh></v>
</v>
<v t="EKR.20040505080156.3"><vh>getSentinelsFromFile/Lines</vh></v>
</v>
<v t="EKR.20040504150046.10"><vh>propagateDiffsToSentinelsFile</vh>
<v t="EKR.20040504150046.11"><vh>&lt;&lt; init propagateDiffsToSentinelsFile vars &gt;&gt;</vh></v>
<v t="EKR.20040504150046.12"><vh>&lt;&lt;paranoia check&gt;&gt;</vh></v>
</v>
<v t="EKR.20040504145804.1"><vh>propagateDiffsToSentinelsLines (called from perfect import)</vh>
<v t="EKR.20040504145804.2"><vh>&lt;&lt; init propagateDiffsToSentinelsLines vars &gt;&gt;</vh></v>
<v t="EKR.20040504145804.3"><vh>&lt;&lt; copy the sentinels at the beginning of the file &gt;&gt;</vh></v>
<v t="EKR.20040504145804.4"><vh>&lt;&lt; update and check the loop invariant&gt;&gt;</vh></v>
<v t="EKR.20040504145804.5"><vh>&lt;&lt; handle 'equal' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.6"><vh>&lt;&lt; handle 'replace' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.7"><vh>&lt;&lt; handle 'delete' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.8"><vh>&lt;&lt; handle 'insert' tag &gt;&gt;</vh></v>
<v t="EKR.20040504145804.9"><vh>&lt;&lt; copy the sentinels at the end of the file &gt;&gt;</vh></v>
</v>
<v t="EKR.20040504150046.5"><vh>report_mismatch</vh></v>
<v t="ekr.20040718101315"><vh>stripWhitespaceFromBlankLines(before_lines)</vh></v>
<v t="EKR.20040504160820"><vh>write_if_changed</vh>
<v t="EKR.20040504160820.1"><vh>&lt;&lt; make backup file &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3212"><vh>importFilesCommand</vh>
<v t="ekr.20031218072017.3213"><vh>&lt;&lt; Create a parent for two files having a common prefix &gt;&gt;</vh></v>
</v>
<v t="EKR.20040506075328.2"><vh>perfectImport</vh>
<v t="ekr.20040717112739"><vh>&lt;&lt; about this algorithm &gt;&gt;</vh></v>
<v t="ekr.20040716065356"><vh>&lt;&lt; clear all dirty bits &gt;&gt;</vh></v>
<v t="ekr.20040716064333"><vh>&lt;&lt; Assign file indices  &gt;&gt;</vh></v>
<v t="ekr.20040716064333.1"><vh>&lt;&lt; Write root's tree to to string s &gt;&gt;</vh></v>
<v t="ekr.20040717132539"><vh>&lt;&lt; put the corrected fat lines in a new node &gt;&gt;</vh></v>
<v t="ekr.20040717113036"><vh>&lt;&lt; correct root's tree using write_lines &gt;&gt;</vh></v>
<v t="ekr.20040718035658"><vh>&lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</vh>
<v t="ekr.20040718045423"><vh>&lt;&lt; dump the files &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20040722210735"><vh>(Investigated write logic to see how it handles whitespace)</vh>
<v t="ekr.20040722211908"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2134"><vh>putCodeLine</vh></v>
</v>
<v t="ekr.20040723054701"><vh>(Fixed new bug in p.setBodyStringOrPane)</vh>
<v t="ekr.20040723054701.1"><vh>Notes</vh></v>
<v t="ekr.20040305223522"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20031218072017.4037"><vh>setSelectionAreas (tkinterBody)</vh></v>
</v>
<v t="ekr.20040723093558.2"><vh>(Created g.stripBlankLines and regularizeTrailingNewlines)</vh>
<v t="ekr.20040723093558.1"><vh>stripBlankLines</vh></v>
<v t="ekr.20040723093558"><vh>regularizeTrailingNewlines</vh></v>
</v>
<v t="ekr.20040723094220.7"><vh>(Improved and simplified Syntax Checking commands)</vh>
<v t="ekr.20040711135959.2"><vh>Check Outline submenu...</vh>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh>
<v t="ekr.20040314062338"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040313150633"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040323155951"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040314035615"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040314035615.1"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040314035615.2"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040323155951.1"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040323161837"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162707"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040314043623"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040731053740"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040314043900"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040314044652"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220"><vh>Check Outline commands &amp; allies</vh>
<v t="ekr.20040723094220.1"><vh>checkAllPythonCode</vh>
<v t="ekr.20040723094220.2"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220.3"><vh>checkPythonCode</vh>
<v t="ekr.20040723094220.4"><vh>&lt;&lt; print dots &gt;&gt;</vh></v>
</v>
<v t="ekr.20040723094220.5"><vh>checkPythonNode</vh></v>
<v t="ekr.20040723094220.6"><vh>tabNannyNode</vh></v>
</v>
<v t="ekr.20040412060927"><vh>c.dumpOutline</vh></v>
<v t="ekr.20040711135959.1"><vh>Pretty Print commands</vh>
<v t="ekr.20040712053025"><vh>prettyPrintAllPythonCode</vh></v>
<v t="ekr.20040712053025.1"><vh>prettyPrintPythonCode</vh></v>
<v t="ekr.20040711135244.5"><vh>class prettyPrinter</vh>
<v t="ekr.20040711135244.6"><vh>__init__</vh></v>
<v t="ekr.20040713093048"><vh>clear</vh></v>
<v t="ekr.20040713064323"><vh>dumpLines</vh></v>
<v t="ekr.20040711135244.7"><vh>dumpToken</vh></v>
<v t="ekr.20040711135244.8"><vh>get</vh></v>
<v t="ekr.20040711135244.4"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040711135244.9"><vh>put</vh></v>
<v t="ekr.20040711135244.10"><vh>putNormalToken</vh></v>
<v t="ekr.20040711135244.11"><vh>putOperator</vh></v>
<v t="ekr.20040711135244.12"><vh>putToken</vh></v>
<v t="ekr.20040713070356"><vh>replaceBody</vh></v>
<v t="ekr.20040713091855"><vh>endUndo</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040725043937"><vh>(Simplified edit_text)</vh>
<v t="ekr.20040725043937.1"><vh>Notes</vh></v>
</v>
<v t="ekr.20040723050246"><vh>(Fixed big performance bug in the read code)</vh>
<v t="ekr.20040730090103"><vh>Notes: </vh></v>
<v t="ekr.20031218072017.1596"><vh>g.doHook</vh></v>
<v t="ekr.20031218072017.3398"><vh>v.setMarked &amp; initMarkedBit</vh></v>
<v t="ekr.20031218072017.1553"><vh>getLeoFile</vh>
<v t="ekr.20031218072017.1554"><vh>&lt;&lt; warn on read-only files &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1555"><vh>&lt;&lt; scan all the xml elements &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1556"><vh>&lt;&lt; raise an alert &gt;&gt;</vh></v>
<v t="EKR.20040627120120"><vh>&lt;&lt; restore attributes in descendent tnodes &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040730061923"><vh>(Fixed undo headline problem)</vh>
<v t="EKR.20040526090701.2"><vh>redoChangeHeadline</vh></v>
<v t="EKR.20040526090701.6"><vh>undoChangeHeadline</vh></v>
<v t="ekr.20040305223225"><vh>p.setHeadStringOrHeadline</vh></v>
</v>
<v t="ekr.20040709053152"><vh>(Fixed bug: @thin badDirectory/name caused too much traceback)</vh>
<v t="ekr.20040730162633"><vh>Traceback &amp; Notes</vh></v>
<v t="ekr.20031218072017.2720"><vh>atFile.openWriteFile (used by both old and new code)</vh></v>
<v t="ekr.20031218072017.2707"><vh>writeError</vh></v>
</v>
<v t="ekr.20040702064435"><vh>(Allow collapsed xml tags in .leo files)</vh>
<v t="ekr.20040730165221"><vh>Request</vh></v>
<v t="ekr.20040730174218"><vh>Notes</vh></v>
<v t="EKR.20040526204706.7"><vh>getOpenTag</vh></v>
<v t="ekr.20031218072017.3023"><vh>getCloneWindows</vh></v>
<v t="ekr.20031218072017.2064"><vh>getFindPanelSettings</vh>
<v t="ekr.20031218072017.2065"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2306"><vh>getGlobals</vh></v>
<v t="ekr.20031218072017.2062"><vh>getPrefs</vh>
<v t="ekr.20031218072017.2063"><vh>getTargetLanguage</vh></v>
</v>
</v>
<v t="ekr.20040730191553"><vh>Fixed bug: new outline code wasn't updating cloned and joined headlines.</vh></v>
<v t="ekr.20040731053740.1"><vh>Check outline now checks that p.edit_text.get matches p.headString()</vh>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh>
<v t="ekr.20040314062338"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040313150633"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040323155951"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040314035615"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040314035615.1"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040314035615.2"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040323155951.1"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040323161837"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162707"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040314043623"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040731053740"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040314043900"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040314044652"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040731055419"><vh>(Fixed problems with confirm save box)</vh>
<v t="ekr.20040731070513"><vh>What I did</vh></v>
<v t="ekr.20040731070513.1"><vh>Report</vh></v>
<v t="ekr.20031218072017.3859"><vh> class leoTkinterDialog</vh>
<v t="ekr.20031218072017.3860"><vh>__init__ (leoDialog)</vh></v>
<v t="ekr.20031218072017.3861"><vh>cancelButton, noButton, okButton, yesButton</vh></v>
<v t="ekr.20031218072017.3862"><vh>center</vh></v>
<v t="ekr.20031218072017.3863"><vh>createButtons</vh></v>
<v t="ekr.20031218072017.3864"><vh>createMessageFrame</vh></v>
<v t="ekr.20031218072017.3865"><vh>createTopFrame</vh></v>
<v t="ekr.20040731065422"><vh>onClose</vh></v>
<v t="ekr.20031218072017.3866"><vh>run</vh></v>
</v>
<v t="ekr.20031218072017.2609"><vh>app.closeLeoWindow</vh></v>
</v>
<v t="ekr.20040731084117"><vh>(Fixed a recent change bug: empty change text was converted to &lt;)</vh>
<v t="EKR.20040526204706.7"><vh>getOpenTag</vh></v>
<v t="ekr.20031218072017.2064"><vh>getFindPanelSettings</vh>
<v t="ekr.20031218072017.2065"><vh>&lt;&lt; Set defaults of all flags &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040630214448.1"><vh>(Improved how es_exception gets line number of errors)</vh>
<v t="ekr.20040731082738"><vh>Notes</vh></v>
<v t="ekr.20031218072017.3112"><vh>es_exception</vh>
<v t="ekr.20040731211839"><vh>&lt;&lt; look for lines containing a specific message &gt;&gt;</vh>
<v t="EKR.20040612223431"><vh>&lt;&lt; compute n from the line &gt;&gt;</vh></v>
</v>
<v t="ekr.20040731204831"><vh>getLastTracebackLineNumber</vh></v>
</v>
</v>
<v t="ekr.20040802063546"><vh>(Fixed MAJOR bug: changing headline now marks subnodes dirty)</vh>
<v t="ekr.20040802064903.2"><vh>Report</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
</v>
<v t="ekr.20040801054717"><vh>(Ignore @all nodes in Go To Line Number command)</vh>
<v t="ekr.20031218072017.2864"><vh>goToLineNumber &amp; allies</vh>
<v t="ekr.20031218072017.2865" a="M"><vh>&lt;&lt; set root to the nearest ancestor @file node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2866"><vh>&lt;&lt; read the file into lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2867"><vh>&lt;&lt; get n, the line number, from a dialog &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2868"><vh>&lt;&lt; count outline lines, setting p,n2,found &gt;&gt; (@file-nosent only)</vh></v>
<v t="ekr.20031218072017.2869"><vh>&lt;&lt; set p to the node given by vnodeName and gnx or childIndex or n &gt;&gt;</vh>
<v t="EKR.20040609110138"><vh>&lt;&lt; 4.2: get node from gnx &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2870"><vh>&lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;</vh>
<v t="ekr.20031218072017.2871"><vh>&lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2872"><vh>&lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = false &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2873"><vh>&lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2874"><vh>&lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2875"><vh>&lt;&lt; select p and make it visible &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2876"><vh>&lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2877"><vh>convertLineToVnodeNameIndexLine</vh>
<v t="ekr.20031218072017.2878"><vh>&lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2879"><vh>&lt;&lt; scan back to  @+node, setting offset,nodeSentinelLine &gt;&gt;</vh>
<v t="ekr.20031218072017.2880"><vh>&lt;&lt; handle delim while scanning backward &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2881"><vh>&lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2882"><vh>skipToMatchingNodeSentinel</vh></v>
</v>
<v t="ekr.20040802082208"><vh>Test...These exist in leoProjects.txt: we should not go there</vh>
<v t="ekr.20031218072017.1319"><vh>(Key handlers) </vh>
<v t="ekr.20031218072017.1320"><vh>body key handlers</vh>
<v t="ekr.20031218072017.1321"><vh>idle_body_key</vh>
<v t="ekr.20031218072017.1322"><vh>&lt;&lt; return if nothing has changed &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1323"><vh>&lt;&lt; set removeTrailing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1324"><vh>&lt;&lt; Do auto indent &gt;&gt; (David McNab)</vh></v>
<v t="ekr.20031218072017.1325"><vh>&lt;&lt; convert tab to blanks &gt;&gt;</vh></v>
<v t="EKR.20040604090913"><vh>&lt;&lt; handle backspace with negative tab_width &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1326"><vh>&lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1327"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1328"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (called from core)</vh></v>
<v t="ekr.20031218072017.1330"><vh>onBodyKey</vh>
<v t="ekr.20040105223536"><vh>handleStatusLineKey</vh>
<v t="ekr.20040105223536.1"><vh>&lt;&lt; trace the key event &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1331"><vh>onBodyWillChange</vh></v>
</v>
<v t="ekr.20040803072955.91"><vh>idle_head_key</vh>
<v t="ekr.20040803072955.92"><vh>&lt;&lt; set head to vnode text &gt;&gt;</vh></v>
<v t="ekr.20040803072955.93"><vh>&lt;&lt; set the widget text to head &gt;&gt;</vh></v>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; set s to the widget text &gt;&gt;</vh></v>
<v t="ekr.20040803072955.95"><vh>&lt;&lt; update p &gt;&gt;</vh></v>
<v t="ekr.20040803072955.96"><vh>&lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;</vh></v>
<v t="ekr.20040803072955.97"><vh>&lt;&lt; update the screen &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040802100054"><vh>Integrated new outline code into core</vh></v>
<v t="ekr.20040802100609"><vh>(Give update warning only once per derived file)</vh>
<v t="ekr.20031218072017.2759"><vh>&lt;&lt; init ivars for scanText4 &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2772"><vh>readEndNode (4.x)</vh>
<v t="ekr.20040717133944"><vh>&lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040713062342"><vh>(Made sure tnodeList is updated properly in all situations)</vh>
<v t="ekr.20040803091155"><vh>What I did: putVnode deletes unneeded tnodeLists!</vh>
<v t="ekr.20031218072017.1863"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040803084520"><vh>Notes</vh></v>
<v t="ekr.20031218072017.2072"><vh>c.checkOutline</vh>
<v t="ekr.20040314062338"><vh>&lt;&lt; assert equivalence of lastVisible methods &gt;&gt;</vh></v>
<v t="ekr.20040313150633"><vh>&lt;&lt; remove unused tnodeList &gt;&gt;</vh></v>
<v t="ekr.20040323155951"><vh>&lt;&lt; do full tests &gt;&gt;</vh>
<v t="ekr.20040314035615"><vh>assert consistency of threadNext &amp; threadBack links</vh></v>
<v t="ekr.20040314035615.1"><vh>assert consistency of next and back links</vh></v>
<v t="ekr.20040314035615.2"><vh>assert consistency of parent and child links</vh></v>
<v t="ekr.20040323155951.1"><vh>assert consistency of directParents and parent</vh></v>
<v t="ekr.20040323161837"><vh>assert consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162707"><vh>assert that clones actually share subtrees</vh></v>
<v t="ekr.20040314043623"><vh>assert consistency of vnodeList</vh></v>
<v t="ekr.20040731053740"><vh>assert that p.headString() matches p.edit_text.get</vh></v>
</v>
<v t="ekr.20040314043900"><vh>&lt;&lt;print summary message &gt;&gt;</vh></v>
<v t="ekr.20040314044652"><vh>&lt;&lt; give test failed message &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803082633"><vh>From atFile...</vh>
<v t="ekr.20031218072017.2766"><vh>readStartNode (4.x)</vh>
<v t="EKR.20040427105350"><vh>&lt;&lt; set gnx and bump i &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2767"><vh>&lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2768"><vh>&lt;&lt; Check the filename in the sentinel &gt;&gt;</vh></v>
</v>
<v t="ekr.20040321064134.5"><vh>createThinChild (4.2: @thin only)</vh></v>
<v t="ekr.20031218072017.2007"><vh>findChild 4.x (@file only)</vh>
<v t="ekr.20040716061450"><vh>&lt;&lt; Check the headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2322"><vh>old_df.write</vh>
<v t="ekr.20031218072017.2323"><vh>&lt;&lt; initialize &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2324"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2325"><vh>&lt;&lt; write then entire @file tree &gt;&gt; (3.x)</vh>
<v t="ekr.20031218072017.2326"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (3.x)</vh></v>
<v t="ekr.20031218072017.2327"><vh>&lt;&lt; write the derived file&gt;&gt;</vh></v>
<v t="ekr.20031218072017.2328"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (3.x)</vh></v>
</v>
<v t="ekr.20031218072017.2330"><vh>&lt;&lt; finish writing &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2114" a="M"><vh>new_df.write</vh>
<v t="ekr.20031218072017.2116"><vh>&lt;&lt; open the file; return on error &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2121"><vh>&lt;&lt; set dirty and orphan bits on error &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2001"><vh>putOpenNodeSentinel (sets tnodeList) 4.x</vh></v>
<v t="EKR.20040506075328"><vh>new_df.writeOpenFile</vh>
<v t="EKR.20040506075328.1"><vh>&lt;&lt; init atFile ivars for writing &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2118"><vh>&lt;&lt; put all @first lines in root &gt;&gt; (4.x)</vh></v>
<v t="ekr.20031218072017.2119"><vh>&lt;&lt; put all @last lines in root &gt;&gt; (4.x)</vh></v>
</v>
<v t="ekr.20031218072017.2122"><vh>new_df.norefWrite</vh>
<v t="ekr.20031218072017.2123"><vh>&lt;&lt; write root's tree &gt;&gt;</vh>
<v t="ekr.20031218072017.2124"><vh>&lt;&lt; put all @first lines in root &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2125"><vh>&lt;&lt; put optional @comment sentinel lines &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2126"><vh>&lt;&lt; Write p's node &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2127"><vh>&lt;&lt; put all @last lines in root &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040803082633.1"><vh>From leoFileCommands...</vh>
<v t="ekr.20031218072017.2008"><vh>getTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20031218072017.2002"><vh>putTnodeList (4.0,4.2)</vh></v>
<v t="ekr.20031218072017.1566"><vh>getVnode changed for 4.2)</vh>
<v t="ekr.20031218072017.1567"><vh>&lt;&lt; Handle vnode attribute bits  &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1568"><vh>&lt;&lt; Set the remembered status bits &gt;&gt;</vh></v>
<v t="ekr.20040326055828"><vh>&lt;&lt; Append to current or top stack &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1863" a="M"><vh>putVnode (3.x and 4.x)</vh>
<v t="ekr.20031218072017.1864"><vh>&lt;&lt; Put tnode index &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1865"><vh>&lt;&lt; Put attribute bits &gt;&gt;</vh></v>
<v t="ekr.20040324082713"><vh>&lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;</vh></v>
<v t="ekr.20040702085529"><vh>&lt;&lt; issue informational messages &gt;&gt;</vh></v>
<v t="ekr.20031218072017.1866"><vh>&lt;&lt; Write the head text &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2015"><vh>top_df.writeAll</vh>
<v t="ekr.20031218072017.2016"><vh>&lt;&lt; Clear all orphan bits &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2017"><vh>&lt;&lt; handle v's tree &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2018"><vh>&lt;&lt; say the command is finished &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2012"><vh>writeAtFileNodes</vh></v>
<v t="ekr.20031218072017.1666"><vh>writeDirtyAtFileNodes</vh></v>
<v t="ekr.20031218072017.2013"><vh>writeMissingAtFileNodes</vh></v>
</v>
</v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
expanded="ekr.20040803100035,"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="EKR.20040430163619" a="TV"><vh>To do: 4.2</vh>
<v t="ekr.20040323195916.1"><vh>Unit tests</vh>
<v t="EKR.20040628085616.1"><vh>Test error recovery when reading descendentTnodeUa's</vh></v>
<v t="EKR.20040621184626"><vh>Finish unit tests for @asis</vh></v>
</v>
<v t="ekr.20040803100035" a="E"><vh>Run Pychecker</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
</v>
<v t="EKR.20040422132037"><vh>Linux bugs 3</vh>
<v t="EKR.20040422132037.5"><vh>Backspace problems on Linux</vh>
<v t="EKR.20040422132037.6"><vh>Dave Hein: fix</vh></v>
</v>
<v t="EKR.20040422132037.7"><vh>Bug: vpython and mac</vh></v>
<v t="EKR.20040422132037.8"><vh>Mouse / Paste Anomalies</vh></v>
</v>
<v t="EKR.20040609155110"><vh>Docs</vh>
<v t="EKR.20040503091612"><vh>Dangers of @file-thin: converting to @file-thin</vh></v>
<v t="ekr.20031218072017.756"><vh>Document how to use pdb plugin</vh></v>
<v t="EKR.20040608091618"><vh>Document @thin and @all on Leo's web site</vh></v>
<v t="EKR.20040610130112"><vh>Document @killcolor on Leo's web site</vh></v>
<v t="EKR.20040610143355"><vh>Document Paste Retaining Clones</vh></v>
<v t="EKR.20040609101343"><vh>Contribute to Python success stories</vh>
<v t="EKR.20040609101343.1"><vh>@url http://python.oreilly.com/news/python_success_stories.pdf</vh></v>
</v>
<v t="EKR.20040607073134"><vh>Download and study wingide</vh>
<v t="EKR.20040607073134.1"><vh>@url http://wingide.com/</vh></v>
</v>
<v t="EKR.20040611081747.1"><vh>Look at windows scripting</vh></v>
<v t="EKR.20040616112407"><vh>Create a FAQ entry about using @thin in a cooperative environment</vh></v>
</v>
<v t="ekr.20040706080747"><vh>Plugins</vh>
<v t="ekr.20040629121906"><vh>Don't specify font in buttons on the Mac</vh></v>
<v t="ekr.20040629121906.1"><vh>Fix Node Navagator bugs</vh></v>
<v t="EKR.20040622060649"><vh>Fix plugin bugs</vh></v>
<v t="EKR.20040616111653"><vh>Test: Get cleo working with @thin trees</vh></v>
<v t="EKR.20040625160558"><vh>(Fix problems with nmarks plugin)</vh></v>
<v t="EKR.20040618070817"><vh>Install latest version of dynabutton</vh>
<v t="EKR.20040618070854"><vh>@url http://rclick.netfirms.com/rCpython.htm</vh></v>
</v>
<v t="ekr.20040706080747.1"><vh>Make sure all plugins work with 4.2 code base</vh></v>
<v t="ekr.20040310092400.1"><vh>Use calltips in outline pane Isn't this a plugin??</vh>
<v t="ekr.20040324075752"><vh>Request</vh></v>
<v t="ekr.20040324071749"><vh>CallTips.py</vh>
<v t="ekr.20040324071749.2"><vh>class CallTips</vh>
<v t="ekr.20040324071749.4"><vh>__init__</vh></v>
<v t="ekr.20040324071749.5"><vh>close</vh></v>
<v t="ekr.20040324071749.6"><vh>_make_tk_calltip_window</vh></v>
<v t="ekr.20040324071749.7"><vh>_remove_calltip_window</vh></v>
<v t="ekr.20040324071749.8"><vh>paren_open_event</vh></v>
<v t="ekr.20040324071749.9"><vh>paren_close_event</vh></v>
<v t="ekr.20040324071749.10"><vh>check_calltip_cancel_event</vh></v>
<v t="ekr.20040324071749.11"><vh>calltip_cancel_event</vh></v>
<v t="ekr.20040324071749.12"><vh>get_name_at_cursor</vh></v>
<v t="ekr.20040324071749.13"><vh>fetch_tip</vh></v>
<v t="ekr.20040324071749.14"><vh>get_entity</vh></v>
</v>
<v t="ekr.20040324071749.15"><vh>_find_constructor</vh></v>
<v t="ekr.20040324071749.16"><vh>get_arg_text</vh></v>
<v t="ekr.20040324071749.17"><vh>t1</vh></v>
</v>
<v t="ekr.20040324072124"><vh>CallTipWindow.py</vh>
<v t="ekr.20040324072124.2"><vh>class CallTip</vh>
<v t="ekr.20040324072124.3"><vh>__init__</vh></v>
<v t="ekr.20040324072124.4"><vh>showtip</vh>
<v t="ekr.20040324073536"><vh>&lt;&lt; remove the border &gt;&gt;</vh></v>
<v t="ekr.20040324073536.1"><vh>&lt;&lt; Mac-specific code &gt;&gt;</vh></v>
</v>
<v t="ekr.20040324072124.5"><vh>hidetip</vh></v>
</v>
<v t="ekr.20040324072124.6"><vh>class container (test code)</vh>
<v t="ekr.20040324072124.7"><vh>__init__</vh></v>
<v t="ekr.20040324072124.8"><vh>calltip_show</vh></v>
<v t="ekr.20040324072124.9"><vh>calltip_hide</vh></v>
</v>
<v t="ekr.20040324072124.10"><vh>main</vh></v>
</v>
</v>
<v t="ekr.20040701041539"><vh>(Check plugins for memory leaks &amp; other performance problems)</vh>
<v t="ekr.20040705074955"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1588"><vh>Garbage Collection</vh>
<v t="ekr.20031218072017.1589"><vh>clearAllIvars</vh></v>
<v t="ekr.20031218072017.1590"><vh>collectGarbage</vh>
<v t="ekr.20031218072017.1591"><vh>&lt;&lt; make a list of the new objects &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1592"><vh>printGc</vh>
<v t="ekr.20040703054646"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
<v t="ekr.20040703065638"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.1593"><vh>printGcRefs</vh></v>
</v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20031218072017.2812"><vh>c.__init__ &amp;  initIvars</vh>
<v t="ekr.20040731071037"><vh>initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707060750"><vh>RsT plugin should say where files get written</vh></v>
</v>
<v t="ekr.20040629110559"><vh>Cool Mac stuff</vh>
<v t="ekr.20040629111136"><vh>Native Max OS X Leo app</vh>
<v t="ekr.20040629111733"><vh>@url http://idisk.mac.com/genthaler-Public/Leo.zip (download)</vh></v>
</v>
<v t="ekr.20040629111733.1"><vh>@url http://www.wordtech-software.com/leo.html  (Mac Bundle)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine</vh></v>
<v t="ekr.20040629121554.2" a="M"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2415"><vh> Scripts</vh>
<v t="ekr.20040327103735.2"><vh>Script Tools (leoGlobals.py)</vh>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20040321065415"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
</v>
<v t="EKR.20040502195524"><vh>@thin ../scripts/leoScripts.txt</vh></v>
<v t="EKR.20040502194930"><vh>@thin ../scripts/tangle_done.py</vh></v>
<v t="ekr.20031218072017.2537"><vh>@thin ../scripts/untangle_done.py</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20031218072017.2620"><vh>@thin leoAtFile.py </vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,ekr.20031218072017.2865,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20031218072017.3001"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20031218072017.3626"><vh>@thin leoColorPanel.py</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3652"><vh>@thin leoFontPanel.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3812"><vh>@thin leoPrefs.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3822"><vh>@thin leoTkinterColorPanels.py</vh></v>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3909"><vh>@thin leoTkinterFontPanel.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20031218072017.4122"><vh>@thin leoTkinterPrefs.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040422132037">@nocolor</t>
<t tx="EKR.20040422132037.5">Shift+Ctrl+BkSp doesn't delete node</t>
<t tx="EKR.20040422132037.6">By: dthein ( Dave Hein ) 
 RE: BUG: Shift+Ctrl+BkSp doesn't delete node   
2004-01-15 03:30  

 OK, the cause of the keymapping problem is a issue with the X11 keyboard mapping, not with Tk.

If you have this problem on your system, issue the command:

xmodmap -pke 

and look in the results for the line for keycode 22. I'll bet it shows something like:

keycode 22 = BackSpace Terminate_Server

That second token ("Terminate_Server") is what is supposed to be mapped to Shift-Backspace. You want this second token to be either not present or to be BackSpace.

To fix this, create a file (e.g. .Xmodmap) and give it the content:

keycode 22 = BackSpace

then run the command:

xmodmap .Xmodmap

And you'll have fixed the problem.

Now, on my system this also disables the ability to terminate the X server using Ctrl-Alt-BackSpace ... this is because of some conflict with xdb (xdb is the newer keyboard mapping facility in XFree86 ... xmodmap is the old original X11 keyboard mapping facility). I'm still working on that.

I'm also not able to get xmodmap to make this change during X11 startup (again because of conflicts with xdb). But I'm working on that as well.</t>
<t tx="EKR.20040422132037.7">Jon Schull &lt;jschull@softlock.com&gt;  
Date:  2003/12/30 Tue PM 05:50:51 EST 
To:  edreamleo@charter.net 
Subject:  Leo, Mac OS X 10.3, and VPython 
             
I've been evaluating leo or vpython programming on  Mac OS X 10.3, and 
have some observations and a suggestion.

Observations.
		Leo runs under X11 as well as under OS X.
		My X11 python configuration was created using the recipe at XXX 
(which enables vpython).
		The OS X configuration is vanilla MacPython from MacPython.org, along 
with AquaTclTk batteries included XXX.
		In both environments I can run leo under python leo.py and under idle.
		Under OS X we get font smoothing, but we can't run visual python 
programs (python crashes;  this is a known incompatibility with 
MacPython.)
	
		Under X11 we can run visual python programs like this one
			#box.py
			from visual import *
			box()
			
    And we can even run them under leo (under X11). HOWEVER, when the 
visual python program is terminated, leo vanishes (leo and the vp 
program apparently run in the same space)
	
	Under x11, we can keep leo alive by putting the vp program in its own 
space:
	
		os.popen3('/sw/bin/python /Users/jis/box.py')
	
	However,  this doesn't let us see the output of stderr and stdout.  
Those text streams are available...
		
		def do(cmd='ls'):
			from os import popen3
			pIn,pOut,pErr=0,1,2
			popenResults=popen3(cmd)
			print popenResults[pOut].read()
			print popenResults[pErr].read()
		
		import os	
		do('/sw/bin/python /Users/jis/box.py')
		
	...but only when the vpython program terminates.
	
	Here's the good news:  if we execute our vp program with 
/sw/bin/idle.py rather than with python, we get to see the program 
output in real time (under idle, under X11).
	
		import os	
		os.chdir('/sw/lib/python2.3/idlelib')
		os.popen3('/sw/bin/python idle.py -r /Users/jis/box.py')
		
		#this runs as an executed script in leo, and produces a live idle 
with real time ongoing output.
	
	Now, while idle is running, leo sits in suspended animation.  But when 
the vpython program terminates, we are left in idle, and when idle is 
terminated, leo becomes active again.
	
	It would be even better if leo were not suspended (using os.spawn, 
perhaps) but the real point is that I would really really like leo's 
"Execute script" command to execute code this way and spare me having 
to  hard-write the path to box.py.  It ought to be possible to 
eliminate os.chdir as well.

------------------
Jon Schull, Ph.D.
Associate Professor
Information Technology
Rochester Institute of Technology
schull@digitalgoods.com 585-738-6696
</t>
<t tx="EKR.20040422132037.8">@nocolor

By: Bill Drissel - drissel
2004-04-13 19:43  

Xserver (XFree86 under Cygwin) on PC (W2000); controlling Linux Red Hat;
buncha windows up including one Leo window and many xterms and Xemacs.

A: means action, R: means result

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; locate mouse symbol in text
R: text shows in body pane; headline is not marked with blue square; text is not colorized; text is not saved to file

A: hilite text in Xemacs window; move mouse symbol to Leo body pane; middle click; up arrow to locate Ibeam in text
R: Joy! colorizes, marks headline and saves!

A: hilite headline text; type on KB
R: keystrokes replace hilited text

A: hilite text in Xemacs window; hilite headline; middle click
R: hilited text appended to headline rather than replacing

This last anomaly seems to persist regardless of how the headline is hilited and regardless of pasting method (middle click or Control-V)</t>
<t tx="EKR.20040427105350"># We have skipped past the opening colon of the gnx.
j = s.find(':',i)
if j == -1:
    g.trace("no closing colon",g.get_line(s,i))
    at.readError("Expecting gnx in @+node sentinel")
    return # 5/17/04
else:
    gnx = s[i:j]
    i = j + 1 # Skip the i</t>
<t tx="EKR.20040429084140"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="EKR.20040430080943.1">def putAtAllLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+all")
    else:
        at.putSentinel("@+all")
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putSentinel("@-all")
    at.indent -= delta</t>
<t tx="EKR.20040430080943.2">@
This code puts only the first of two or more cloned siblings, preceding the
clone with an @clone n sentinel.

This is a debatable choice: the cloned tree appears only once in the derived
file. This should be benign; the text created by @all is likely to be used only
for recreating the outline in Leo. The representation in the derived file
doesn't matter much.
@c

def putAtAllChild(self,p):
    
    at = self
    
    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1:
        if thisClonedSibIndex == 1:
            at.putSentinel("@clone %d" % (clonedSibs))
        else: return # Don't write second or greater trees.

    at.putOpenNodeSentinel(p,inAtAll=True) # Suppress warnings about @file nodes.
    at.putAtAllBody(p) 
    
    for child in p.children_iter():
        at.putAtAllChild(child)

    at.putCloseNodeSentinel(p,inAtAll=True)</t>
<t tx="EKR.20040430081109">def putRefLine(self,s,i,n1,n2,p):
    
    """Put a line containing one or more references."""
    
    at = self
    
    # Compute delta only once.
    delta = self.putRefAt(s,i,n1,n2,p,delta=None)
    if delta is None: return # 11/23/03
    
    while 1:
        i = n2 + 2
        hasRef,n1,n2 = at.findSectionName(s,i)
        if hasRef:
            self.putAfterMiddleRef(s,i,n1,delta)
            self.putRefAt(s,n1,n1,n2,p,delta)
        else:
            break
    
    self.putAfterLastRef(s,i,delta)
</t>
<t tx="EKR.20040430081109.1"></t>
<t tx="EKR.20040430081109.2"></t>
<t tx="EKR.20040430081719">def readStartAll (self,s,i):
    
    """Read an @+all sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+all"))
    else:
        assert(g.match(s,j,"+all"))

    # Make sure that the generated at-all is properly indented.
    at.out.append(leadingWs + "@all\n")
    
    at.endSentinelStack.append(endAll)</t>
<t tx="EKR.20040430081719.1">def readEndAll (self,s,i):
    
    """Read an @-all sentinel."""
    
    at = self
    at.popSentinelStack(endAll)</t>
<t tx="EKR.20040430104717">def putAtAllBody(self,p,putCloseSentinel=True):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.setVisited()   # Make sure v is never expanded again.
    p.v.t.setVisited() # Use the tnode for the orphans check.
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        if inCode:
            # Use verbatim sentinels to write all directives.
            at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
        i = next_i

    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="EKR.20040430104717.1"># 11/20/03: except in nosentinel mode.
# 1/30/04: and especially in scripting mode.
# If we add a trailing newline, we'll generate an @nonl sentinel below.

if s:
    trailingNewlineFlag = s and s[-1] == '\n'
    if at.sentinels and not trailingNewlineFlag:
        s = s + '\n'
else:
    trailingNewlineFlag = True # don't need to generate an @nonl</t>
<t tx="EKR.20040430152000">def isAtAllNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@all")
    return flag</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040430163619"></t>
<t tx="EKR.20040503091612">Using @ignore with @file-thin is asking for trouble.
If you remove the @ignore and then save, you will lose data.

How to recover the data:
	- Read Outline.
	- Remove @ignore
	- Import derived file... </t>
<t tx="EKR.20040504145804.1">def propagateDiffsToSentinelsLines (self,
    i_lines,j_lines,fat_lines,mapping):
    
    """Compare the 'i_lines' with 'j_lines' and propagate the diffs back into
    'write_lines' making sure that all sentinels of 'fat_lines' are copied.

    i/j_lines have no sentinels.  fat_lines does."""

    &lt;&lt; init propagateDiffsToSentinelsLines vars &gt;&gt;
    &lt;&lt; copy the sentinels at the beginning of the file &gt;&gt;
    for tag, i1, i2, j1, j2 in matcher.get_opcodes():
        if testing:
            if verbose: print
            print "Opcode %7s %3d %3d %3d %3d" % (tag,i1,i2,j1,j2)
            if verbose: print
        &lt;&lt; update and check the loop invariant &gt;&gt;
        if tag == 'equal':
            &lt;&lt; handle 'equal' tag &gt;&gt;
        elif tag == 'replace':
            &lt;&lt; handle 'replace' tag &gt;&gt;
        elif tag == 'delete':
            &lt;&lt; handle 'delete' tag &gt;&gt;
        elif tag == 'insert':
            &lt;&lt; handle 'insert' tag &gt;&gt;
        else: assert 0,"bad tag"
    &lt;&lt; copy the sentinels at the end of the file &gt;&gt;
    return write_lines</t>
<t tx="EKR.20040504145804.2"># Indices into i_lines, j_lines &amp; fat_lines.
i_pos = j_pos = fat_pos = 0

# These vars check that all ranges returned by get_opcodes() are contiguous.
i2_old = j2_old = -1

# Create the output lines.
write_lines = []

matcher = difflib.SequenceMatcher(None,i_lines,j_lines)

testing = self.testing
verbose = self.verbose</t>
<t tx="EKR.20040504145804.3">while fat_pos &lt; mapping[0]:

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "copy initial line",fat_pos,line,
    fat_pos += 1
</t>
<t tx="EKR.20040504145804.4"># We need the ranges returned by get_opcodes to completely cover the source lines being compared.
# We also need the ranges not to overlap.

assert(i2_old in (-1,i1))
assert(j2_old in (-1,j1))

i2_old = i2 ; j2_old = j2

# Check the loop invariants.
assert i_pos == i1
assert j_pos == j1
assert fat_pos == mapping[i1]

if 0: # not yet.
    if testing: # A bit costly.
        t_sourcelines,t_sentinel_lines = push_filter_lines(write_lines, delims)
        # Check that we have all the modifications so far.
        assert t_sourcelines == j_lines[:j1],"t_sourcelines == j_lines[:j1]"
        # Check that we kept all sentinels so far.
        assert t_sentinel_lines == push_filter_lines(fat_lines[:fat_pos], delims)[1]</t>
<t tx="EKR.20040504145804.5"># Copy the lines, including sentinels.
while fat_pos &lt;= mapping[i2-1]:
    line = fat_lines[fat_pos]
    if 0: # too verbose.
        if testing: print "Equal: copying ", line,
    write_lines.append(line)
    fat_pos += 1

if testing and verbose:
    print "Equal: synch i", i_pos,i2
    print "Equal: synch j", j_pos,j2

i_pos = i2
j_pos = j2

# Copy the sentinels which might follow the lines.       
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i2-1,i2)</t>
<t tx="EKR.20040504145804.6">@ Replace lines that may span sentinels.

For now, we put all the new contents after the first sentinel.

A more complex approach: run the difflib across the different lines and try to
construct a mapping changed line =&gt; orignal line.
@c

while j_pos &lt; j2:
    line = j_lines[j_pos]
    if testing:
        print "Replace i:",i_pos,repr(i_lines[i_pos])
        print "Replace j:",j_pos,repr(line)
        i_pos += 1

    write_lines.append(line)
    j_pos += 1

i_pos = i2

# Copy the sentinels which might be between the changed code.         
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)</t>
<t tx="EKR.20040504145804.7">if testing and verbose:
    print "delete: i",i_pos,i1
    print "delete: j",j_pos,j1

j_pos = j2
i_pos = i2

# Restore any deleted sentinels.
fat_pos = self.copy_sentinels(write_lines,fat_lines,fat_pos,mapping,i1,i2)</t>
<t tx="EKR.20040504145804.8">while j_pos &lt; j2:
    line = j_lines[j_pos]
    if testing: print "Insert:", line,
    write_lines.append(line)
    j_pos += 1

# The input streams are already in synch.</t>
<t tx="EKR.20040504145804.9">while fat_pos &lt; len(fat_lines):

    line = fat_lines[fat_pos]
    write_lines.append(line)
    if testing:
        print "Append last line",line
    fat_pos += 1
</t>
<t tx="EKR.20040504150046">import difflib,shutil

class mulderUpdateAlgorithm:
    
    """A class to update derived files using
    diffs in files without sentinels.
    """
    
    @others
    
def doMulderUpdateAlgorithm(sourcefilename,targetfilename):

    mu = mulderUpdateAlgorithm()

    mu.pull_source(sourcefilename,targetfilename)
    mu.copy_time(targetfilename,sourcefilename)</t>
<t tx="EKR.20040504150046.3">def __init__ (self,testing=False,verbose=False):
    
    self.testing = testing
    self.verbose = False
    self.do_backups = False</t>
<t tx="EKR.20040504150046.4">def comment_delims_from_extension(filename):
    
    """
    Return the comment delims corresponding to the filename's extension.

    &gt;&gt;&gt; g.comment_delims_from_extension(".py")
    ('#', None, None)

    &gt;&gt;&gt; g.comment_delims_from_extension(".c")
    ('//', '/*', '*/')
    
    &gt;&gt;&gt; g.comment_delims_from_extension(".html")
    (None, '&lt;!--', '--&gt;')

    """

    root, ext = os.path.splitext(filename)
    if ext == '.tmp':
        root, ext = os.path.splitext(root)
        
    language = g.app.extension_dict.get(ext[1:])
    if ext:
        
        return g.set_delims_from_language(language)
    else:
        g.trace("unknown extension %s" % ext)
        return None,None,None</t>
<t tx="EKR.20040504150046.5">def report_mismatch (self,lines1,lines2,message,lines1_message,lines2_message):

    """
    Generate a report when something goes wrong.
    """

    print '='*20
    print message
    
    if 0:
        print lines1_message
        print '-'*20
        for line in lines1:
          print line,
         
        print '='*20
    
        print lines2_message
        print '-'*20
        for line in lines2:
            print line,</t>
<t tx="EKR.20040504150046.6">def create_mapping (self,lines,delims):
    """

    'lines' is a list of lines of a file with sentinels.
 
    Returns:

    result: lines with all sentinels removed.

    mapping: a list such that result[mapping[i]] == lines[i]
    for all i in range(len(result))

    """
    
    if not lines:
        return [],[]

    # Create mapping and set i to the index of the last non-sentinel line.
    mapping = []
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            mapping.append(i)

    # Create a last mapping entry for copy_sentinels.
    mapping.append(i)
    
    # Use removeSentinelsFromLines to handle @nonl properly.
    stripped_lines = self.removeSentinelsFromLines(lines,delims)

    return stripped_lines, mapping</t>
<t tx="EKR.20040504150046.9">@ This script retains _all_ sentinels.  If lines are replaced, or deleted,
we restore deleted sentinel lines by checking for gaps in the mapping.
@c

def copy_sentinels (self,write_lines,fat_lines,fat_pos,mapping,startline,endline):
    """
    
    Copy sentinel lines from fat_lines to write_lines.

    Copy all sentinels _after_ the current reader postion up to,
    but not including, mapping[endline].

    """

    j_last = mapping[startline]
    i = startline + 1
    while i &lt;= endline:
        j = mapping[i]
        if j_last + 1 != j:
            fat_pos = j_last + 1
            # Copy the deleted sentinels that comprise the gap.
            while fat_pos &lt; j:
                line = fat_lines[fat_pos]
                write_lines.append(line)
                if self.testing and self.verbose: print "Copy sentinel:",fat_pos,line,
                fat_pos += 1
        j_last = j ; i += 1

    fat_pos = mapping[endline]
    return fat_pos</t>
<t tx="EKR.20040504150046.10">def propagateDiffsToSentinelsFile(self,sourcefilename,targetfilename):
    
    &lt;&lt; init propagateDiffsToSentinelsFile vars &gt;&gt;
    
    write_lines = self.propagateDiffsToSentinelsLines(
        i_lines,j_lines,fat_lines,mapping)
        
    # Update _source_ file if it is not the same as write_lines.
    written = self.write_if_changed(write_lines,targetfilename,sourcefilename)
    if written:
        &lt;&lt; paranoia check&gt;&gt;</t>
<t tx="EKR.20040504150046.11"># Get the sentinel comment delims.
delims = self.comment_delims_from_extension(sourcefilename)
if not delims:
    return

try:
    # Create the readers.
    sfile = file(sourcefilename)
    tfile = file(targetfilename)
    
    fat_lines = sfile.readlines() # Contains sentinels.
    j_lines   = tfile.readlines() # No sentinels.
    
    i_lines,mapping = self.create_mapping(fat_lines,delims)
    
    sfile.close()
    tfile.close()
except:
    g.es_exception("can not open files")
    return</t>
<t tx="EKR.20040504150046.12"># Check that 'push' will re-create the changed file.
strippedLines,sentinel_lines = self.separateSentinelsFromFile(sourcefilename)

if strippedLines != j_lines:
    self.report_mismatch(strippedLines, j_lines,
        "Propagating diffs did not work as expected",
        "Content of sourcefile:",
        "Content of modified file:")

# Check that no sentinels got lost.
fat_sentinel_lines = self.getSentinelsFromLines(fat_lines,delims)

if sentinel_lines != fat_sentinel_lines:
    self.report_mismatch(sentinel_lines,fat_sentinel_lines,
        "Propagating diffs modified sentinel lines:",
        "Current sentinel lines:",
        "Old sentinel lines:")</t>
<t tx="EKR.20040504154039">def is_sentinel (line,delims):
    
    &lt;&lt; is_sentinel doc tests &gt;&gt;
    
    delim1,delim2,delim3 = delims
    
    line = line.lstrip()

    if delim1:
        return line.startswith(delim1+'@')
    elif delim2 and delim3:
        i = line.find(delim2+'@')
        j = line.find(delim3)
        return 0 == i &lt; j
    else:
        g.es("Can't happen: is_sentinel",color="red")
        return False
</t>
<t tx="EKR.20040504155109">def copy_time(self,sourcefilename,targetfilename):
    
    """
    Set the target file's modification time to
    that of the source file.
    """

    st = os.stat(sourcefilename)

    if hasattr(os, 'utime'):
        os.utime(targetfilename, (st.st_atime, st.st_mtime))
    elif hasattr(os, 'mtime'):
        os.mtime(targetfilename, st.st_mtime)
    else:
        g.trace("Can not set modification time")</t>
<t tx="EKR.20040504160820">def write_if_changed(self,lines,sourcefilename,targetfilename):
    """
    
    Replaces target file if it is not the same as 'lines',
    and makes the modification date of target file the same as the source file.
    
    Optionally backs up the overwritten file.

    """
    
    copy = not os.path.exists(targetfilename) or lines != file(targetfilename).readlines()
        
    if self.testing:
        if copy:
            print "Writing",targetfilename,"without sentinals"
        else:
            print "Files are identical"

    if copy:
        if self.do_backups:
            &lt;&lt; make backup file &gt;&gt;
        outfile = open(targetfilename, "w")
        for line in lines:
            outfile.write(line)
        outfile.close()
        self.copy_time(sourcefilename,targetfilename)
    return copy
</t>
<t tx="EKR.20040504160820.1">if os.path.exists(targetfilename):
    count = 0
    backupname = "%s.~%s~" % (targetfilename,count)
    while os.path.exists(backupname):
        count += 1
        backupname = "%s.~%s~" % (targetfilename,count)
    os.rename(targetfilename, backupname)
    if testing:
        print "backup file in ", backupname</t>
<t tx="EKR.20040505080156"># These routines originally were part of push_filter &amp; push_filter_lines.</t>
<t tx="EKR.20040505080156.2">def removeSentinelsFromFile (self,filename):
    
    """Return a copy of file with all sentinels removed."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return removeSentinelsFromLines(lines,delims)
    
def removeSentinelsFromLines (self,lines,delims):

    """Return a copy of lines with all sentinels removed."""
    
    delim1,delim2,delim3 = delims
    result = [] ; last_nosent_i = -1
    for i in xrange(len(lines)):
        if not g.is_sentinel(lines[i],delims):
            result.append(lines[i])
            last_nosent_i = i
    &lt;&lt; remove the newline from result[-1] if line[i] is followed by @nonl &gt;&gt;
    return result</t>
<t tx="EKR.20040505080156.3">def getSentinelsFromFile (self,filename,delims):
    
    """Returns all sentinels lines in a file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)

    return getSentinelsFromLines(lines,delims)
    
def getSentinelsFromLines (self,lines,delims):
    
    """Returns all sentinels lines in lines."""
    
    return [line for line in lines if g.is_sentinel(line,delims)]</t>
<t tx="EKR.20040505081121">def separateSentinelsFromFile (self,filename):
    
    """Separate the lines of the file into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the file."""
    
    lines = file(filename).readlines()
    delims = g.comment_delims_from_extension(filename)
    
    return self.separateSentinelsFromLines(lines,delims)
    
def separateSentinelsFromLines (self,lines,delims):
    
    """Separate lines (a list of lines) into a tuple of two lists,
    containing the sentinel and non-sentinel lines of the original list."""
    
    strippedLines = self.removeSentinelsFromLines(lines,delims)
    sentinelLines = self.getSentinelsFromLines(lines,delims)
    
    return strippedLines,sentinelLines</t>
<t tx="EKR.20040506075328">def writeOpenFile(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    at = self ; c = at.c
    
    &lt;&lt; init atFile ivars for writing &gt;&gt;
    root.clearAllVisitedInTree() # Clear both vnode and tnode bits.
    root.clearVisitedInTree()

    &lt;&lt; put all @first lines in root &gt;&gt;

    # Put the main part of the file.
    at.putOpenLeoSentinel("@+leo-ver=4")
    at.putInitialComment()
    at.putOpenNodeSentinel(root)
    at.putBody(root)
    at.putCloseNodeSentinel(root)
    at.putSentinel("@-leo")
    root.setVisited()
    
    &lt;&lt; put all @last lines in root &gt;&gt;
    
    if not toString and not nosentinels:
        at.warnAboutOrphandAndIgnoredNodes()</t>
<t tx="EKR.20040506075328.1"># Set flags telling what kind of writing we are doing.
at.sentinels = not nosentinels
at.thinFile = thinFile
at.raw = False
assert(at.toStringFlag == toString) # Must have been set earlier.

# Init other ivars.
at.errors = 0
c.setIvarsFromPrefs()
at.root = root
at.root.v.t.tnodeList = []

c.endEditing() # Capture the current headline.</t>
<t tx="EKR.20040506075328.2">def perfectImport (self,fileName,p,testing=False,verbose=False,convertBlankLines=True,verify=True):
    
    &lt;&lt; about this algorithm &gt;&gt;
    c = p.c ; root = p.copy()
    df = c.atFileCommands.new_df
    if testing:
        &lt;&lt; clear all dirty bits &gt;&gt;
    &lt;&lt; Assign file indices &gt;&gt;
    &lt;&lt; Write root's tree to to string s &gt;&gt;

    # Set up the data for the algorithm.
    mu = g.mulderUpdateAlgorithm(testing=testing,verbose=verbose)
    delims = g.comment_delims_from_extension(fileName)
    fat_lines = g.splitLines(s) # Keep the line endings.
    i_lines,mapping = mu.create_mapping(fat_lines,delims)
    j_lines = file(fileName).readlines()
    
    # Correct write_lines using the algorihm.
    if i_lines != j_lines:
        if verbose:
            g.es("Running Perfect Import",color="blue")
        write_lines = mu.propagateDiffsToSentinelsLines(i_lines,j_lines,fat_lines,mapping)
        if 0: # For testing.
            &lt;&lt; put the corrected fat lines in a new node &gt;&gt;
        &lt;&lt; correct root's tree using write_lines &gt;&gt;
    if verify:
        &lt;&lt; verify that writing the tree would produce the original file &gt;&gt;</t>
<t tx="EKR.20040506075328.3"></t>
<t tx="EKR.20040519090151"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040520093903">def readClone (self,s,i):
    
    at = self ; tag = "clone"

    assert(g.match(s,i,tag))
    
    # Skip the tag and whitespace.
    i = g.skip_ws(s,i+len(tag))
    
    # Get the clone count.
    junk,val = g.skip_long(s,i)
    
    if val == None:
        at.readError("Invalid count in @clone sentinel")
    else:
        at.cloneSibCount	 = val</t>
<t tx="EKR.20040524070500">def readStartMiddle (self,s,i):
    
    """Read an @+middle sentinel."""
    
    at = self
    
    at.readStartNode(s,i,middle=True)</t>
<t tx="EKR.20040524071414">def readEndMiddle (self,s,i):
    
    """Read an @-middle sentinel."""
    
    at = self
    
    at.readEndNode(s,i,middle=True)</t>
<t tx="EKR.20040526090701.1">def redoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead += 1
        d = u.getBead(u.bead+1)
        assert(d)
        # g.trace(u.undoType,u.p,u.newText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.v.setTnodeText(u.newText)
            u.p.setDirty()
            count += 1
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.newText)
            count += 1
        else: assert(False)

    g.es("redo %d instances" % count)</t>
<t tx="EKR.20040526090701.2">def redoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.newText)
    
    u.p.setHeadStringOrHeadline(u.newText)
    
    c.selectVnode(u.p)</t>
<t tx="EKR.20040526090701.5">def undoChangeAll (self):
    
    u = self ; c = u.c

    count = 0
    while 1:
        u.bead -= 1
        d = u.getBead(u.bead)
        assert(d)
        # g.trace(u.undoType,u.p,u.oldText)
        if u.undoType in ("Change All","Pretty Print"):
            c.selectVnode(u.p)
            break
        elif u.undoType == "Change":
            u.p.setTnodeText(u.oldText)
            count += 1
            u.p.setDirty()
        elif u.undoType == "Change Headline":
            u.p.initHeadString(u.oldText)
            count += 1
        else: assert False, "bad undo type:" % u.undoType

    g.es("undo %d instances" % count)</t>
<t tx="EKR.20040526090701.6">def undoChangeHeadline (self):
    
    u = self ; c = u.c
    
    # g.trace(u.oldText)
    
    u.p.setHeadStringOrHeadline(u.oldText)
    
    c.selectVnode(u.p)

    </t>
<t tx="EKR.20040526204706.7">def getOpenTag (self,tag):
    
    """
    Look ahead for collapsed tag: tag may or may not end in "&gt;"
    Skips tag and /&gt; if found, otherwise does not alter index.
    Returns True if the closing part was found.
    Throws BadLeoFile if the tag does not exist.
    """

    if tag[-1] == "&gt;":
        # Only the tag itself or a collapsed tag are valid.
        if self.matchTag(tag):
            return False # Not a collapsed tag.
        elif self.matchTag(tag[:-1]):
            # It must be a collapsed tag.
            self.skipWs()
            if self.matchTag("/&gt;"):
                return True
        print "getOpenTag(", tag, ") failed:"
        raise BadLeoFile("expecting" + tag)
    else:
        # The tag need not be followed by "/&gt;"
        if self.matchTag(tag):
            old_index = self.fileIndex
            self.skipWs()
            if self.matchTag("/&gt;"):
                return True
            else:
                self.fileIndex = old_index
                return False
        else:
            print "getOpenTag(", tag, ") failed:"
            raise BadLeoFile("expecting" + tag)</t>
<t tx="EKR.20040604090913"># Get the preceeding characters.
prev   =c.frame.bodyCtrl.get("insert linestart","insert")
allPrev=c.frame.bodyCtrl.get("1.0","insert")
n = len(allPrev)
try:
    oldAllPrev = body[:n]
    assert(allPrev==oldAllPrev)
    deletedChar = body[n:n+1]
except (IndexError,AssertionError):
    deletedChar = None

if deletedChar in (u' ',' '):
    n = len(prev) ; w = abs(tab_width)
    n2 = n % w # Delete up to n2 - 1 spaces.
    if n2 == w - 1: # Delete spaces only if they could have come from a tab.
        count = 0
        while n2 &gt; 0:
            n2 -= 1
            ch = prev[n-count-1]
            # g.trace(count,repr(ch))
            if ch in (u' ',' '): count += 1
            else: break
        # g.trace(count,(n%w))
        if count &gt; 0:
            c.frame.bodyCtrl.delete("insert -%dc" % count,"insert")</t>
<t tx="EKR.20040607073134"></t>
<t tx="EKR.20040607073134.1"></t>
<t tx="EKR.20040608091618"></t>
<t tx="EKR.20040609101343"></t>
<t tx="EKR.20040609101343.1"></t>
<t tx="EKR.20040609110138">found = False
gnx = g.app.nodeIndices.scanGnx(gnx,0)

# g.trace(vnodeName)
# g.trace(gnx)

for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        # g.trace(p.v.t.fileIndex)
        if p.v.t.fileIndex == gnx:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="EKR.20040609155110"></t>
<t tx="EKR.20040610130112"></t>
<t tx="EKR.20040610143355"></t>
<t tx="EKR.20040611081747.1">------cut openleo.pys
@path c:\bIn\pys\
@lineending crnl
@
w04609p09:57:19 a pys to open leo and do something.
you need the win32 extensions and you have to enable 
the script engine. details how on google or on the win32 page.

the sendkeys method can insert any test or control codes
msdn or microsoft.com/scripting

@c
pypath = r'C:\c\py\Python233'
py =  pypath + r'\python.exe -itOO '
leosrc = r'c:\c\leo\leo4CVS233\src'
name = "blank.leo"

WshShell = WScript.CreateObject("WScript.Shell")

#look like it comes up untitled 
# if it cant find an existing leo of that name?

WshShell.Run(py + leosrc + r'\Leo.py ../' + name)
WScript.Sleep(4900) 

wname = "untitled"

WshShell.AppActivate(wname);  WScript.Sleep(2100)
WshShell.SendKeys("%Fe");   WScript.Sleep(1300);  #^Q

---end openleo.pys</t>
<t tx="EKR.20040612215018">lines = g.splitLines(script)

s = '-' * 20
print s; g.es(s)

if 1:
    # Just print the error line.
    s = "line %d: %s" % (n,lines[n-1])
    print s, ; g.es(s,newline=False)
else:
    i = max(0,n-2)
    j = min(n+2,len(lines))
    # g.trace(n,i,j)
    while i &lt; j:
        ch = g.choose(i==n-1,'*',' ')
        s = "%s line %d: %s" % (ch,i+1,lines[i])
        print s, ; g.es(s,newline=False)
        i += 1</t>
<t tx="EKR.20040612223431">i += len(tag)
j = line.find(',',i)
if j &gt; i: n = line[i:j]
else:     n = line[i:].strip()
# g.trace(n)
try: n = int(n)
except (TypeError,ValueError): n = None</t>
<t tx="EKR.20040614071102.1">def getScript (c,p,oneNodeOnly=False):

    if not p: p = c.currentPosition()
    old_body = p.bodyString()
    
    try:
        script = None
        # 7/7/04: Allow p not to be the present position.
        if p == c.currentPosition():
            if c.frame.body.hasTextSelection():
                # Temporarily replace v's body text with just the selected text.
                s = c.frame.body.getSelectedText()
                p.v.setTnodeText(s)
            else:
                s = c.frame.body.getAllText()
        else:
            s = p.bodyString()
    
        if s.strip():
            g.app.scriptDict["script1"]=s
            df = c.atFileCommands.new_df
            df.scanAllDirectives(p,scripting=True)
            # Force Python comment delims.
            df.startSentinelComment = "#"
            df.endSentinelComment = None
            df.write(p.copy(),nosentinels=False,toString=True,oneNodeOnly=oneNodeOnly)
            script = df.stringOutput
            assert(p)
            g.app.scriptDict["script2"]=script
            error = len(script) == 0
    except:
        s = "unexpected exception"
        print s ; g.es(s)
        g.es_exception()
        script = None

    p.v.setTnodeText(old_body)
    return script</t>
<t tx="EKR.20040616111653"></t>
<t tx="EKR.20040616112407">@nocolor

The general idea is that developers should use @thin in a cvs environment, and only commit thin derived files.

Consider .leo files to be private in a cooperative environment.  Only "reference" .leo files get committed to cvs: each developer uses a private copy.

Edward</t>
<t tx="EKR.20040618070817"></t>
<t tx="EKR.20040618070854"></t>
<t tx="EKR.20040620094529">def oblank(self):
    self.os(' ')

def oblanks (self,n):
    self.os(' ' * abs(n))
    
def otabs(self,n):
    self.os('\t' * abs(n))</t>
<t tx="EKR.20040620094529.1">def onl(self):
    
    """Write a newline to the output stream."""

    self.os(self.output_newline)
    
def onl_sent(self):
    
    """Write a newline to the output stream, provided we are outputting sentinels."""

    if self.sentinels:
        self.onl()</t>
<t tx="EKR.20040620094529.2">def os (self,s):
    
    """Write a string to the output stream.
    
    All output produced by leoAtFile module goes here."""
    
    if s and self.outputFile:
        try:
            s = g.toEncodedString(s,self.encoding,reportErrors=True)
            self.outputFile.write(s)
        except:
            g.es("exception writing:",s)
            g.es_exception(full=True)</t>
<t tx="EKR.20040621184626">@ - Support toString in asis methods
</t>
<t tx="EKR.20040622060649">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2629405
By: nobody

nodenavigator plugin gets confused 
when you open another leo,
its recent becomes the recent 
of the new leo. which wouldent be bad 
as a sideeffect if it didn't also loose 
all the old previously visited nodes. 
and of course, if you close the new leo,
its completely hosed for good. marks too.

searchbox has a similar problem, reported before with fix. 
search, open new leo, go back to first 
hit go it searches in the new leo.

#@@tabwidth -4 in pluginsmanager.txt 
but there are tabs in the file

double clicking the @rst in leoDoc.leo
Leo's HTML Users Guide (Created using the rst2 plugin)
failed and took down some plugins too.
&lt;string&gt;:51: (ERROR/3) Unknown target name: "front Matter".
&lt;string&gt;:51: (ERROR/3) Unknown target name: "front Matter".
list.index(x): x not in list
Exiting due to error.  Use "--traceback" to diagnose.
Please report errors to &lt;docutils-users@lists.sf.net&gt;.
Include "--traceback" output, Docutils version (0.3.2),
Python version (2.3.3), your OS type &amp; version, and the
command line used.
exception in app.hookFunction
[...]
  File "c:\c\leo\tempLeo42\leo\plugins\rst2.py", line 149, in onIconDoubleClick
    output = pub.publish()
  File "C:\C\PY\PYTHON233\Lib\site-packages\docutils\core.py", line 222, in
publish
    sys.exit(1)
SystemExit: 1
other @rst generated html works fine.
have both recent versions docutils and silvercity
also the print in the rst2 plugin describing
the conversions it makes are lost to the console. should be g.es() to the log
window.

you might concider going straight to a release candidate with so few bugs
reported.

Leo 4.2 alpha 3, build  1.117 , June 1, 2004
Python 2.3.3, Tk 8.4.3, win32

e</t>
<t tx="EKR.20040625103148">self.putSentinel("@" + directive)

# Skip the keyword and whitespace.
i = k + len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = ""
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @language directive: %s" % line,color="blue")</t>
<t tx="EKR.20040625103148.1">self.putSentinel("@" + directive)

j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

# g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = None
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    g.es("Ignoring bad @comment directive: %s" % line,color="blue")</t>
<t tx="EKR.20040625104908"># Skip the keyword and whitespace.
i += len("@language")
i = g.skip_ws(s,i)
j = g.skip_c_id(s,i)
language = s[i:j]

delim1,delim2,delim3 = g.set_delims_from_language(language)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    at.startSentinelComment = delim1
    at.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    at.startSentinelComment = delim2
    at.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @@language sentinel: %s" % line,color="red")</t>
<t tx="EKR.20040625104908.1">j = g.skip_line(s,i)
line = s[i:j]
delim1,delim2,delim3 = g.set_delims_from_string(line)

#g.trace(g.get_line(s,i))
#g.trace(delim1,delim2,delim3)

# Returns a tuple (single,start,end) of comment delims
if delim1:
    self.startSentinelComment = delim1
    self.endSentinelComment = "" # Must not be None.
elif delim2 and delim3:
    self.startSentinelComment = delim2
    self.endSentinelComment = delim3
else:
    line = g.get_line(s,i)
    g.es("Ignoring bad @comment sentinel: %s" % line,color="red")</t>
<t tx="EKR.20040625160558"># Doesn't become active until a node is marked.
# Node isn't necessarily visible in outine pane when selected.</t>
<t tx="EKR.20040627100424">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.restoreStderr()
    g.restoreStdout()</t>
<t tx="EKR.20040627120120">for resultDict in self.descendentUnknownAttributesDictList:
    for gnx in resultDict.keys():
        tref = self.canonicalTnodeIndex(gnx)
        t = self.tnodesDict.get(tref)
        if t: t.unknownAttributes = resultDict[gnx]
        else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
            
marks = {} ; expanded = {}
for gnx in self.descendentExpandedList:
    t = self.tnodesDict.get(gnx)
    if t: expanded[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")
    
for gnx in self.descendentMarksList:
    t = self.tnodesDict.get(gnx)
    if t: marks[t]=t
    else: g.trace("can not find tnode: gnx = %s" % gnx,color="red")

if marks or expanded:
    # g.trace("marks",len(marks),"expanded",len(expanded))
    for p in c.all_positions_iter():
        if marks.get(p.v.t):
            p.v.initMarkedBit()
                # This was the problem: was p.setMark.
                # There was a big performance bug in the mark hook in the Node Navigator plugin.
        if expanded.get(p.v.t):
            p.expand()
    # g.trace("done")</t>
<t tx="EKR.20040628085616.1"></t>
<t tx="ekr.20031218072017.368"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "_\\_ _(_ _)_", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20031218072017.756"></t>
<t tx="ekr.20031218072017.838">def createBindings (self,frame):
    
    t = self.bodyCtrl
    
    # Event handlers...
    t.bind("&lt;Button-1&gt;", frame.OnBodyClick)
    t.bind("&lt;Button-3&gt;", frame.OnBodyRClick)
    t.bind("&lt;Double-Button-1&gt;", frame.OnBodyDoubleClick)
    t.bind("&lt;Key&gt;", frame.body.onBodyKey)

    # Gui-dependent commands...
    t.bind(g.virtual_event_name("Cut"), frame.OnCut)
    t.bind(g.virtual_event_name("Copy"), frame.OnCopy)
    t.bind(g.virtual_event_name("Paste"), frame.OnPaste)</t>
<t tx="ekr.20031218072017.839">self.editMenuTopTable = (
    ("Can't Undo","Ctrl+Z",c.undoer.undo), # &amp;U reserved for Undo
    ("Can't Redo","Shift+Ctrl+Z",c.undoer.redo), # &amp;R reserved for Redo
    ("-",None,None),
    ("Cu&amp;t","Ctrl+X",f.OnCutFromMenu), 
    ("Cop&amp;y","Ctrl+C",f.OnCopyFromMenu),
    ("&amp;Paste","Ctrl+V",f.OnPasteFromMenu),
    ("&amp;Delete",None,c.delete),
    ("Select &amp;All","Ctrl+A",f.body.selectAllText),
    ("-",None,None))</t>
<t tx="ekr.20031218072017.892">def __init__ (self,v,stack):

    """Create a new position."""
    
    if v: self.c = v.c
    else: self.c = g.top()
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.
    
    g.app.positions += 1
    
    # Note: __getattr__ implements p.t.</t>
<t tx="ekr.20031218072017.1149">try:
    mode = g.app.config.output_newline
    mode = g.choose(mode=="platform",'w','wb')
    file = open(newFileName,mode)
    s = g.toEncodedString(s,self.encoding,reportErrors=True)
    file.write(s)
    file.close()
    g.es("created: " + newFileName)
except:
    g.es("exception creating: " + newFileName)
    g.es_exception()</t>
<t tx="ekr.20031218072017.1260"># The caller passes [root_node] or None as the second arg.  This allows us to distinguish between None and [None].

def get_directives_dict(s,root=None):
    
    """Scans root for @directives found in globalDirectivesList.

    Returns a dict containing pointers to the start of each directive"""

    if root: root_node = root[0]
    dict = {}
    i = 0 ; n = len(s)
    while i &lt; n:
        if s[i] == '@' and i+1 &lt; n:
            &lt;&lt; set dict for @ directives &gt;&gt;
        elif root and g.match(s,i,"&lt;&lt;"):
            &lt;&lt; set dict["root"] for noweb * chunks &gt;&gt;
        i = g.skip_line(s,i)
    return dict</t>
<t tx="ekr.20031218072017.1261">j = g.skip_c_id(s,i+1)
word = s[i+1:j]
if word in g.globalDirectiveList:
    if dict.has_key(word):
        # Ignore second value.
        pass
        # g.es("Warning: conflicting values for %s" % (word), color="blue")
    else:
        dict [word] = i</t>
<t tx="ekr.20031218072017.1262">@ The following looks for chunk definitions of the form &lt; &lt; * &gt; &gt; =. If found, we take this to be equivalent to @root filename if the headline has the form @root filename.
@c

i = g.skip_ws(s,i+2)
if i &lt; n and s[i] == '*' :
    i = g.skip_ws(s,i+1) # Skip the '*'
    if g.match(s,i,"&gt;&gt;="):
        # &lt; &lt; * &gt; &gt; = implies that @root should appear in the headline.
        i += 3
        if root_node:
            dict["root"]=0 # value not immportant
        else:
            g.es(g.angleBrackets("*") + "= requires @root in the headline")</t>
<t tx="ekr.20031218072017.1319">@ These routines are involved in many projects.  Cloning them over and over can slow down Leo a lot.
</t>
<t tx="ekr.20031218072017.1320">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="ekr.20031218072017.1321">def idle_body_key (self,p,oldSel,undoType,ch=None,oldYview=None,newSel=None,oldText=None):
    
    """Update the body pane at idle time."""

    # g.trace(ch,ord(ch))
    c = self.c
    if not c: return "break"
    if not p: return "break"
    if p != c.currentPosition(): return "break"

    if g.doHook("bodykey1",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return "break" # The hook claims to have handled the event.
    body = p.bodyString()
    if not newSel:
        newSel = c.frame.body.getTextSelection()
    if oldText != None:
        s = oldText
    else:
        s = c.frame.body.getAllText()
    &lt;&lt; return if nothing has changed &gt;&gt;
    &lt;&lt; set removeTrailing &gt;&gt;
    if ch in ('\t','\n','\r',chr(8)):
        d = g.scanDirectives(c,p) # Support @tab_width directive properly.
        tab_width = d.get("tabwidth",c.tab_width) # ; g.trace(tab_width)
        if ch in ('\n','\r'):
            &lt;&lt; Do auto indent &gt;&gt;
        elif ch == '\t' and tab_width &lt; 0:
            &lt;&lt; convert tab to blanks &gt;&gt;
        elif ch in (chr(8)) and tab_width &lt; 0:
            &lt;&lt; handle backspace with negative tab_width &gt;&gt;
    &lt;&lt; set s to widget text, removing trailing newlines if necessary &gt;&gt;
    if undoType: # 11/6/03: set oldText properly when oldText param exists.
        if not oldText: oldText = body
        newText = s
        c.undoer.setUndoTypingParams(p,undoType,oldText,newText,oldSel,newSel,oldYview=oldYview)
    p.v.setTnodeText(s)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed:
        c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
    return "break"
</t>
<t tx="ekr.20031218072017.1322"># 6/22/03: Make sure we handle delete key properly.
if ch not in ('\n','\r',chr(8)):

    if s == body:
        return "break"

    # Do nothing for control characters.
    if (ch == None or len(ch) == 0) and body == s[:-1]:
        return "break"</t>
<t tx="ekr.20031218072017.1323">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = s ; old = body

if len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True

if 0:
    print removeTrailing
    print repr(ch)
    print repr(oldText)
    print repr(old)
    print repr(new)</t>
<t tx="ekr.20031218072017.1324"># Do nothing if we are in @nocolor mode or if we are executing a Change command.
if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
    # Get the previous line.
    s=c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk,width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s[-1]==':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if g.app.config.getBoolWindowPref("smart_auto_indent"):
        # Added Nov 18 by David McNab, david@rebirthing.co.nz
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width]
        tabex = 0
        for i in range(0, len(s)):
            if s[i] == '\t':
                tabex += tab_width - 1
            if s[i] in '([{':
                brackets.append(i+tabex + 1)
            elif s[i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
        # end patch by David McNab
    ws = g.computeLeadingWhitespace (width,tab_width)
    if ws and len(ws) &gt; 0:
        c.frame.bodyCtrl.insert("insert", ws)
        removeTrailing = False # bug fix: 11/18</t>
<t tx="ekr.20031218072017.1325"># Do nothing if we are executing a Change command.
if undoType != "Change":
    
    # Get the characters preceeding the tab.
    prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")
    
    if 1: # 6/26/03: Convert tab no matter where it is.

        w = g.computeWidth(prev,tab_width)
        w2 = (abs(tab_width) - (w % abs(tab_width)))
        # g.trace("prev w:",w,"prev chars:",prev)
        c.frame.bodyCtrl.delete("insert -1c")
        c.frame.bodyCtrl.insert("insert",' ' * w2)
    
    else: # Convert only leading tabs.
    
        # Get the characters preceeding the tab.
        prev=c.frame.bodyCtrl.get("insert linestart","insert -1c")

        # Do nothing if there are non-whitespace in prev:
        all_ws = True
        for ch in prev:
            if ch != ' ' and ch != '\t':
                all_ws = False
        if all_ws:
            w = g.computeWidth(prev,tab_width)
            w2 = (abs(tab_width) - (w % abs(tab_width)))
            # g.trace("prev w:",w,"prev chars:",prev)
            c.frame.bodyCtrl.delete("insert -1c")
            c.frame.bodyCtrl.insert("insert",' ' * w2)</t>
<t tx="ekr.20031218072017.1326">s = c.frame.body.getAllText()
if len(s) &gt; 0 and s[-1] == '\n' and removeTrailing:
    s = s[:-1]
    
# Major change: 6/12/04
if s == body:
    # print "no real change"
    return "break"</t>
<t tx="ekr.20031218072017.1327">self.frame.scanForTabWidth(p)

incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)

self.forceFullRecolorFlag = False</t>
<t tx="ekr.20031218072017.1328">redraw_flag = False

c.beginUpdate()

# Update dirty bits.
if not p.isDirty() and p.setDirty(): # Sets all cloned and @file dirty bits
    redraw_flag = True
    
# Update icons.
val = p.computeIcon()

# 7/8/04: During unit tests the node may not have been drawn,
# So p.v.iconVal may not exist yet.
if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
    p.v.iconVal = val
    redraw_flag = True

c.endUpdate(redraw_flag) # redraw only if necessary</t>
<t tx="ekr.20031218072017.1329"># Called by command handlers that have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    """Handle a change to the body pane."""
    
    c = self.c
    if not p:
        p = c.currentPosition()

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    self.idle_body_key(p,oldSel,undoType,oldYview=oldYview,newSel=newSel,oldText=oldText)</t>
<t tx="ekr.20031218072017.1330">def onBodyKey (self,event):
    
    """Handle any key press event in the body pane."""

    c = self.c ; ch = event.char 
    oldSel = c.frame.body.getTextSelection()
    
    p = c.currentPosition()

    # g.trace(repr(ch))

    if 0: # won't work when menu keys are bound.
        self.handleStatusLineKey(event)
        
    # g.trace(p)
        
    # We must execute this even if len(ch) &gt; 0 to delete spurious trailing newlines.
    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,"Typing",ch)

</t>
<t tx="ekr.20031218072017.1331"># Called by command handlers that change the text just before idle time.

def onBodyWillChange (self,p,undoType,oldSel=None,oldYview=None):
    
    """Queue the body changed idle handler."""
    
    c = self.c

    if not oldSel:
        oldSel = c.frame.body.getTextSelection()

    if not p:
        p = c.currentPosition()

    self.c.frame.bodyCtrl.after_idle(self.idle_body_key,p,oldSel,undoType,oldYview)</t>
<t tx="ekr.20031218072017.1391">@ Perhaps this routine should be the basis of atFile.scanAllDirectives and tangle.scanAllDirectives, but I am loath to make any further to these two already-infamous routines.  Also, this code does not check for @color and @nocolor directives: leoColor.useSyntaxColoring does that.
@c

def scanDirectives(c,p=None):
    
    """Scan vnode v and v's ancestors looking for directives.

    Returns a dict containing the results, including defaults."""

    if c == None or g.top() == None:
        return {} # For unit tests.
    if p is None:
        p = c.currentPosition()

    &lt;&lt; Set local vars &gt;&gt;
    old = {}
    pluginsList = [] # 5/17/03: a list of items for use by plugins.
    for p in p.self_and_parents_iter():
        s = p.v.t.bodyString
        dict = g.get_directives_dict(s)
        &lt;&lt; Test for @comment and @language &gt;&gt;
        &lt;&lt; Test for @encoding &gt;&gt;
        &lt;&lt; Test for @lineending &gt;&gt;
        &lt;&lt; Test for @pagewidth &gt;&gt;
        &lt;&lt; Test for @path &gt;&gt;
        &lt;&lt; Test for @tabwidth &gt;&gt;
        &lt;&lt; Test for @wrap and @nowrap &gt;&gt;
        g.doHook("scan-directives",c=c,v=p,s=s,
            old_dict=old,dict=dict,pluginsList=pluginsList)
        old.update(dict)

    if path == None: path = g.getBaseDirectory()

    return {
        "delims"    : (delim1,delim2,delim3),
        "encoding"  : encoding,
        "language"  : language,
        "lineending": lineending,
        "pagewidth" : page_width,
        "path"      : path,
        "tabwidth"  : tab_width,
        "pluginsList": pluginsList,
        "wrap"      : wrap }</t>
<t tx="ekr.20031218072017.1392">page_width = c.page_width
tab_width  = c.tab_width
language = c.target_language
delim1, delim2, delim3 = g.set_delims_from_language(c.target_language)
path = None
encoding = None # 2/25/03: This must be none so that the caller can set a proper default.
lineending = g.getOutputNewline() # 4/24/03 initialize from config settings.
wrap = app.config.getBoolWindowPref("body_pane_wraps") # 7/7/03: this is a window pref.</t>
<t tx="ekr.20031218072017.1393"># @language and @comment may coexist in @file trees.
# For this to be effective the @comment directive should follow the @language directive.

if not old.has_key("comment") and dict.has_key("comment"):
    k = dict["comment"]
    delim1,delim2,delim3 = g.set_delims_from_string(s[k:])

# Reversion fix: 12/06/02: We must use elif here, not if.
elif not old.has_key("language") and dict.has_key("language"):
    k = dict["language"]
    language,delim1,delim2,delim3 = g.set_language(s,k)</t>
<t tx="ekr.20031218072017.1394">if not old.has_key("encoding") and dict.has_key("encoding"):
    
    e = g.scanAtEncodingDirective(s,dict)
    if e:
        encoding = e
</t>
<t tx="ekr.20031218072017.1395">if not old.has_key("lineending") and dict.has_key("lineending"):
    
    e = g.scanAtLineendingDirective(s,dict)
    if e:
        lineending = e
</t>
<t tx="ekr.20031218072017.1396">if dict.has_key("pagewidth") and not old.has_key("pagewidth"):
    
    w = g.scanAtPagewidthDirective(s,dict)
    if w and w &gt; 0:
        page_width = w</t>
<t tx="ekr.20031218072017.1397">if not path and not old.has_key("path") and dict.has_key("path"):

    k = dict["path"]
    &lt;&lt; compute relative path from s[k:] &gt;&gt;
    if path and len(path) &gt; 0:
        base = g.getBaseDirectory() # returns "" on error.
        path = g.os_path_join(base,path)
        </t>
<t tx="ekr.20031218072017.1398">j = i = k + len("@path")
i = g.skip_to_end_of_line(s,i)
path = string.strip(s[j:i])

# Remove leading and trailing delims if they exist.
if len(path) &gt; 2 and (
    (path[0]=='&lt;' and path[-1] == '&gt;') or
    (path[0]=='"' and path[-1] == '"') ):
    path = path[1:-1]

path = string.strip(path)
if 0: # 11/14/02: we want a _relative_ path, not an absolute path.
    path = g.os_path_join(app.loadDir,path)</t>
<t tx="ekr.20031218072017.1399">if dict.has_key("tabwidth") and not old.has_key("tabwidth"):
    
    w = g.scanAtTabwidthDirective(s,dict)
    if w and w != 0:
        tab_width = w</t>
<t tx="ekr.20031218072017.1400">if not old.has_key("wrap") and not old.has_key("nowrap"):
    
    if dict.has_key("wrap"):
        wrap = True
    elif dict.has_key("nowrap"):
        wrap = False</t>
<t tx="ekr.20031218072017.1493"># Handle text undo and redo.
# The terminology is for undo: converts _new_ text into _old_ text.

def undoRedoText (self,p,
    leading,trailing, # Number of matching leading &amp; trailing lines.
    oldMidLines,newMidLines, # Lists of unmatched lines.
    oldNewlines,newNewlines, # Number of trailing newlines.
    tag="undo", # "undo" or "redo"
    undoType=None):

    u = self ; c = u.c
    assert(p == c.currentPosition())
    v = p.v

    &lt;&lt; Incrementally update the Tk.Text widget &gt;&gt;
    &lt;&lt; Compute the result using v's body text &gt;&gt;
    # g.trace(v)
    # g.trace("old:",v.bodyString())
    v.setTnodeText(result)
    # g.trace("new:",v.bodyString())
    &lt;&lt; Get textResult from the Tk.Text widget &gt;&gt;
    if textResult == result:
        if undoType in ("Cut","Paste"):
            # g.trace("non-incremental undo")
            c.frame.body.recolor(p,incremental=False)
        else:
            # g.trace("incremental undo:",leading,trailing)
            c.frame.body.recolor_range(p,leading,trailing)
    else: # 11/19/02: # Rewrite the pane and do a full recolor.
        if u.debug_print:
            &lt;&lt; print mismatch trace &gt;&gt;
        # g.trace("non-incremental undo")
        p.setBodyStringOrPane(result)</t>
<t tx="ekr.20031218072017.1494"># Only update the changed lines.
mid_text = string.join(oldMidLines,'\n')
new_mid_len = len(newMidLines)
# Maybe this could be simplified, and it is good to treat the "end" with care.
if trailing == 0:
    c.frame.body.deleteLine(leading)
    if leading &gt; 0:
        c.frame.body.insertAtEnd('\n')
    c.frame.body.insertAtEnd(mid_text)
else:
    if new_mid_len &gt; 0:
        c.frame.body.deleteLines(leading,new_mid_len)
    elif leading &gt; 0:
        c.frame.body.insertAtStartOfLine(leading,'\n')
    c.frame.body.insertAtStartOfLine(leading,mid_text)
# Try to end the Tk.Text widget with oldNewlines newlines.
# This may be off by one, and we don't care because
# we never use body text to compute undo results!
s = c.frame.body.getAllText()
newlines = 0 ; i = len(s) - 1
while i &gt;= 0 and s[i] == '\n':
    newlines += 1 ; i -= 1
while newlines &gt; oldNewlines:
    c.frame.body.deleteLastChar()
    newlines -= 1
if oldNewlines &gt; newlines:
    c.frame.body.insertAtEnd('\n'*(oldNewlines-newlines))</t>
<t tx="ekr.20031218072017.1495"># Recreate the text using the present body text.
body = v.bodyString()
body = g.toUnicode(body,"utf-8")
body_lines = body.split('\n')
s = []
if leading &gt; 0:
    s.extend(body_lines[:leading])
if len(oldMidLines) &gt; 0:
    s.extend(oldMidLines)
if trailing &gt; 0:
    s.extend(body_lines[-trailing:])
s = string.join(s,'\n')
# Remove trailing newlines in s.
while len(s) &gt; 0 and s[-1] == '\n':
    s = s[:-1]
# Add oldNewlines newlines.
if oldNewlines &gt; 0:
    s = s + '\n' * oldNewlines
result = s
if u.debug_print:
    print "body:  ",body
    print "result:",result</t>
<t tx="ekr.20031218072017.1496">textResult = c.frame.body.getAllText()

if textResult != result:
    # Remove the newline from textResult if that is the only difference.
    if len(textResult) &gt; 0 and textResult[:-1] == result:
        textResult = result</t>
<t tx="ekr.20031218072017.1497">print "undo mismatch"
print "expected:",result
print "actual  :",textResult</t>
<t tx="ekr.20031218072017.1553"># The caller should enclose this in begin/endUpdate.

def getLeoFile (self,fileName,atFileNodesFlag=True):

    c = self.c
    c.setChanged(False) # 10/1/03: May be set when reading @file nodes.
    &lt;&lt; warn on read-only files &gt;&gt;
    self.mFileName = c.mFileName
    self.tnodesDict = {}
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.descendentUnknownAttributesDictList = []
    ok = True
    c.loading = True # disable c.changed
    
    try:
        &lt;&lt; scan all the xml elements &gt;&gt;
    except BadLeoFile, message:
        &lt;&lt; raise an alert &gt;&gt;
        ok = False

    c.frame.tree.redraw_now(scroll=False)
    
    if ok and atFileNodesFlag:
        c.atFileCommands.readAll(c.rootVnode(),partialFlag=False)

    if not c.currentPosition():
        c.setCurrentPosition(c.rootPosition())

    c.selectVnode(c.currentPosition()) # load body pane
    c.loading = False # reenable c.changed
    c.setChanged(c.changed) # Refresh the changed marker.
    &lt;&lt; restore attributes in descendent tnodes &gt;&gt;
    self.descendentUnknownAttributesDictList = []
    self.descendentExpandedList = []
    self.descendentMarksList = []
    self.tnodesDict = {}
    return ok, self.ratio</t>
<t tx="ekr.20031218072017.1554">try:
    self.read_only = False
    self.read_only = not os.access(fileName,os.W_OK)
    if self.read_only:
        g.es("read only: " + fileName,color="red")
except:
    if 0: # testing only: access may not exist on all platforms.
        g.es("exception getting file access")
        g.es_exception()</t>
<t tx="ekr.20031218072017.1555">self.getXmlVersionTag()
self.getXmlStylesheetTag()

self.getTag("&lt;leo_file&gt;") # Must match exactly.
self.getLeoHeader()
self.getGlobals()
self.getPrefs()
self.getFindPanelSettings()

# Causes window to appear.
c.frame.resizePanesToRatio(c.frame.ratio,c.frame.secondary_ratio) 
g.es("reading: " + fileName)

self.getVnodes()
self.getTnodes()
self.getCloneWindows()
self.getTag("&lt;/leo_file&gt;")</t>
<t tx="ekr.20031218072017.1556"># All other exceptions are Leo bugs.

g.es_exception()
g.alert(self.mFileName + " is not a valid Leo file: " + str(message))</t>
<t tx="ekr.20031218072017.1566">def getVnode (self,parent,back,skip,appendToCurrentStack,appendToTopStack):

    c = self.c ; v = None
    setCurrent = setExpanded = setMarked = setOrphan = setTop = False
    tref = -1 ; headline = "" ; tnodeList = None ; attrDict = {} 
    # we have already matched &lt;v.
    while 1:
        if self.matchTag("a=\""):
            &lt;&lt; Handle vnode attribute bits &gt;&gt;
        elif self.matchTag("t="):
            # New for 4.1.  Read either "Tnnn" or "gnx".
            tref = self.getDqString()
        elif self.matchTag("vtag=\"V"):
            self.getIndex() ; self.getDquote() # ignored
        elif self.matchTag("tnodeList="):
            s = self.getDqString()
            tnodeList = self.getTnodeList(s) # New for 4.0
        elif self.matchTag("descendentTnodeUnknownAttributes="):
            # New for 4.2
            s = self.getDqString()
            dict = self.getDescendentUnknownAttributes(s)
            if dict:
                self.descendentUnknownAttributesDictList.append(dict)
        elif self.matchTag("expanded="): # New in 4.2
            s = self.getDqString()
            self.descendentExpandedList.extend(self.getDescendentAttributes(s,tag="expanded"))
        elif self.matchTag("marks="): # New in 4.2
            s = self.getDqString()
            self.descendentMarksList.extend(self.getDescendentAttributes(s,tag="marks"))
        elif self.matchTag("&gt;"):
            break
        else: # New for 4.0: allow unknown attributes.
            # New in 4.2: allow pickle'd and hexlify'ed values.
            attr,val = self.getUnknownAttribute("vnode")
            if attr: attrDict[attr] = val
    # Headlines are optional.
    if self.matchTag("&lt;vh&gt;"):
        headline = self.getEscapedString() ; self.getTag("&lt;/vh&gt;")
    
    # g.trace("skip:",skip,"parent:",parent,"back:",back,"headline:",headline)
    if skip:
        v = self.getExistingVnode(tref,headline)
    if v is None:
        v,skip2 = self.createVnode(parent,back,tref,headline,attrDict)
        skip = skip or skip2
        if tnodeList:
            v.t.tnodeList = tnodeList # New for 4.0, 4.2: now in tnode.

    &lt;&lt; Set the remembered status bits &gt;&gt;

    # Recursively create all nested nodes.
    parent = v ; back = None
    while self.matchTag("&lt;v"):
        append1 = appendToCurrentStack and len(self.currentVnodeStack) == 0
        append2 = appendToTopStack and len(self.topVnodeStack) == 0
        back = self.getVnode(parent,back,skip,
            appendToCurrentStack=append1,appendToTopStack=append2)
            
    &lt;&lt; Append to current or top stack &gt;&gt;

    # End this vnode.
    self.getTag("&lt;/v&gt;")
    return v</t>
<t tx="ekr.20031218072017.1567"># The a=" has already been seen.
while 1:
    if   self.matchChar('C'): pass # Not used: clone bits are recomputed later.
    elif self.matchChar('D'): pass # Not used.
    elif self.matchChar('E'): setExpanded = True
    elif self.matchChar('M'): setMarked = True
    elif self.matchChar('O'): setOrphan = True
    elif self.matchChar('T'): setTop = True
    elif self.matchChar('V'): setCurrent = True
    else: break

self.getDquote()</t>
<t tx="ekr.20031218072017.1568">if setCurrent:
    self.currentVnodeStack = [v]

if setTop:
    self.topVnodeStack = [v]
    
if setExpanded:
    v.initExpandedBit()
    
if setMarked:
    v.initMarkedBit() # 3/25/03: Do not call setMarkedBit here!

if setOrphan:
    v.setOrphan()</t>
<t tx="ekr.20031218072017.1575">def putTnodes (self):
    
    """Puts all tnodes as required for copy or save commands"""

    c = self.c

    self.put("&lt;tnodes&gt;") ; self.put_nl()
    &lt;&lt; write only those tnodes that were referenced &gt;&gt;
    self.put("&lt;/tnodes&gt;") ; self.put_nl()</t>
<t tx="ekr.20031218072017.1576">if self.usingClipboard: # write the current tree.
    iter = c.currentPosition().self_and_subtree_iter()
else: # write everything
    iter = c.allNodes_iter()

# Populate tnodes
tnodes = {}

for p in iter:
    index = p.v.t.fileIndex
    assert(index)
    tnodes[index] = p.v.t

# Put all tnodes in index order.
keys = tnodes.keys() ; keys.sort()
for index in keys:
    # g.trace(index)
    t = tnodes.get(index)
    assert(t)
    # Write only those tnodes whose vnodes were written.
    if t.isWriteBit(): # 5/3/04
        self.putTnode(t)</t>
<t tx="ekr.20031218072017.1588">debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

if debugGC:
    try: 
        import gc
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            # gc.DEBUG_LEAK | # Same as all below.
            # gc.DEBUG_COLLECTABLE
            # gc.DEBUG_UNCOLLECTABLE
            gc.DEBUG_INSTANCES |
            gc.DEBUG_OBJECTS
            # gc.DEBUG_SAVEALL
        )
    except ImportError:
        traceback.print_exc()

@others</t>
<t tx="ekr.20031218072017.1589">def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
</t>
<t tx="ekr.20031218072017.1590">def collectGarbage(message=None):
    
    if not debugGC: return
    
    if not message:
        message = g.callerName(n=2)
    
    try: gc.collect()
    except: pass
    
    if 0:
        g.printGc(message)
    
    if 1: # This isn't needed unless we want to look at individual objects.
    
        &lt;&lt; make a list of the new objects &gt;&gt;
        print "%25s: %d new, %d total objects" % (message,len(newObjects),len(objects))
</t>
<t tx="ekr.20031218072017.1591"># WARNING: the id trick is not proper because newly allocated objects can have the same address as old objets.

global lastObjectsDict
objects = gc.get_objects()

newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]

lastObjectsDict = {}
for o in objects:
    lastObjectsDict[id(o)]=o</t>
<t tx="ekr.20031218072017.1592">def printGc(message=None,onlyPrintChanges=False):
    
    if not debugGC: return None
    
    if not message:
        message = g.callerName(n=2)
    
    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount

        print '-' * 30
        print "garbage: %d, objects: %+6d =%7d %s" % (n,delta,n2,message)
        
        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

        lastObjectCount = n2
        return delta
    except:
        traceback.print_exc()
        return None</t>
<t tx="ekr.20031218072017.1593">def printGcRefs (verbose=True):

    refs = gc.get_referrers(app.windowList[0])
    print '-' * 30

    if verbose:
        print "refs of", app.windowList[0]
        for ref in refs:
            print type(ref)
    else:
        print "%d referers" % len(refs)</t>
<t tx="ekr.20031218072017.1596">@ This global function calls a hook routine.  Hooks are identified by the tag param.
Returns the value returned by the hook routine, or None if the there is an exception.

We look for a hook routine in three places:
1. g.top().hookFunction
2. app.hookFunction
3. leoPlugins.doPlugins()
We set app.hookError on all exceptions.  Scripts may reset app.hookError to try again.
@c

def doHook(tag,*args,**keywords):
    
    if g.app.killed or g.app.hookError:
        return None
    
    # New in 4.2.  We call the idle-time handlers for all open windows.
    c = keywords.get("c")
    
    if 0: # Don't use trace here!
        if tag != "idle":
            print "doHook",tag,c

    if not g.app.config.use_plugins:
        if tag == "start1":
            g.es("Plugins disabled: use_plugins is 0",color="blue")
        return None
    elif c and c.hookFunction:
        try:
            return c.hookFunction(tag,keywords)
        except:
            g.es("exception in c.hookFunction for " + c.frame.getTitle())
    elif g.app.hookFunction:
        try:
            return g.app.hookFunction(tag,keywords)
        except:
            g.es("exception in app.hookFunction")
    else:
        import leoPlugins
        try:
            g.app.hookFunction = leoPlugins.doPlugins
            return app.hookFunction(tag,keywords)
        except:
            g.app.hookFunction = None
            g.es("exception in plugin")

    # Handle all exceptions.
    g.es_exception()
    g.app.hookError = True # Supress this function.
    g.app.idleTimeHook = False # Supress idle-time hook
    return None # No return value</t>
<t tx="ekr.20031218072017.1666">def writeDirtyAtFileNodes (self): # fileCommands

    """The Write Dirty @file Nodes command"""
    
    c = self.c

    self.assignFileIndices() # 4/3/04
    changedFiles = c.atFileCommands.writeAll(writeDirtyAtFileNodesFlag=True)
    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.</t>
<t tx="ekr.20031218072017.1720">def save(self,fileName):

    c = self.c ; v = c.currentVnode()

    # New in 4.2.  Return ok flag so shutdown logic knows if all went well.
    ok = g.doHook("save1",c=c,v=v,fileName=fileName)
    if ok is None:
        c.beginUpdate()
        c.endEditing()# Set the current headline text.
        self.setDefaultDirectoryForNewFiles(fileName)
        ok = self.write_Leo_file(fileName,False) # outlineOnlyFlag
        if ok:
            c.setChanged(False) # Clears all dirty bits.
            g.es("saved: " + g.shortFileName(fileName))
            if g.app.config.save_clears_undo_buffer:
                g.es("clearing undo")
                c.undoer.clearUndoState()
        c.endUpdate()
    g.doHook("save2",c=c,v=v,fileName=fileName)
    return ok</t>
<t tx="ekr.20031218072017.1745"></t>
<t tx="ekr.20031218072017.1746">def putBlankDocLine (self):
    
    at = self
    
    at.putPending(split=False)

    if not at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.startSentinelComment) ; at.oblank()

    at.onl()</t>
<t tx="ekr.20031218072017.1747">def putStartDocLine (self,s,i,kind):
    
    """Write the start of a doc part."""
    
    at = self ; at.docKind = kind
    
    sentinel = g.choose(kind == docDirective,"@+doc","@+at")
    directive = g.choose(kind == docDirective,"@doc","@")
    
    if 0: # New code: put whatever follows the directive in the sentinel
        # Skip past the directive.
        i += len(directive)
        j = g.skip_to_end_of_line(s,i)
        follow = s[i:j]
    
        # Put the opening @+doc or @-doc sentinel, including whatever follows the directive.
        at.putSentinel(sentinel + follow)

        # Put the opening comment if we are using block comments.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    else: # old code.
        # Skip past the directive.
        i += len(directive)
    
        # Get the trailing whitespace.
        j = g.skip_ws(s,i)
        ws = s[i:j]
        
        # Put the opening @+doc or @-doc sentinel, including trailing whitespace.
        at.putSentinel(sentinel + ws)
    
        # Put the opening comment.
        if at.endSentinelComment:
            at.putIndent(at.indent)
            at.os(at.startSentinelComment) ; at.onl()
    
        # Put an @nonl sentinel if there is significant text following @doc or @.
        if not g.is_nl(s,j):
            # Doesn't work if we are using block comments.
            at.putSentinel("@nonl")
            at.putDocLine(s,j)</t>
<t tx="ekr.20031218072017.1748">def putDocLine (self,s,i):
    
    """Handle one line of a doc part.
    
    Output complete lines and split long lines and queue pending lines.
    Inserted newlines are always preceded by whitespace."""
    
    at = self
    j = g.skip_line(s,i)
    s = s[i:j]

    if at.endSentinelComment:
        leading = at.indent
    else:
        leading = at.indent + len(at.startSentinelComment) + 1

    if not s or s[0] == '\n':
        # A blank line.
        at.putBlankDocLine()
    else:
        &lt;&lt; append words to pending line, splitting the line if needed &gt;&gt;
</t>
<t tx="ekr.20031218072017.1749">@ All inserted newlines are preceeded by whitespace:
we remove trailing whitespace from lines that have not been split.
@c

i = 0
while i &lt; len(s):

    # Scan to the next word.
    word1 = i # Start of the current word.
    word2 = i = g.skip_ws(s,i)
    while i &lt; len(s) and s[i] not in (' ','\t'):
        i += 1
    word3 = i = g.skip_ws(s,i)
    # g.trace(s[word1:i])
    
    if leading + word3 - word1 + len(''.join(at.pending)) &gt;= at.page_width:
        if at.pending:
            # g.trace("splitting long line.")
            # Ouput the pending line, and start a new line.
            at.putPending(split=True)
            at.pending = [s[word2:word3]]
        else:
            # Output a long word on a line by itself.
            # g.trace("long word:",s[word2:word3])
            at.pending = [s[word2:word3]]
            at.putPending(split=True)
    else:
        # Append the entire word to the pending line.
        # g.trace("appending",s[word1:word3])
        at.pending.append(s[word1:word3])
            
# Output the remaining line: no more is left.
at.putPending(split=False)</t>
<t tx="ekr.20031218072017.1750">def putEndDocLine (self):
    
    """Write the conclusion of a doc part."""
    
    at = self
    
    at.putPending(split=False)
    
    # Put the closing delimiter if we are using block comments.
    if at.endSentinelComment:
        at.putIndent(at.indent)
        at.os(at.endSentinelComment)
        at.onl() # Note: no trailing whitespace.

    sentinel = g.choose(at.docKind == docDirective,"@-doc","@-at")
    at.putSentinel(sentinel)</t>
<t tx="ekr.20031218072017.1751">def putPending (self,split):
    
    """Write the pending part of a doc part.
    
    We retain trailing whitespace iff the split flag is True."""
    
    at = self ; s = ''.join(at.pending) ; at.pending = []
    
    # g.trace("split",s)
    
    # Remove trailing newline temporarily.  We'll add it back later.
    if s and s[-1] == '\n':
        s = s[:-1]

    if not split:
        s = s.rstrip()
        if not s:
            return

    at.putIndent(at.indent)

    if not at.endSentinelComment:
        at.os(at.startSentinelComment) ; at.oblank()

    at.os(s) ; at.onl()</t>
<t tx="ekr.20031218072017.1752">def readStartAt (self,s,i):
    """Read an @+at sentinel."""
    at = self ; assert(g.match(s,i,"+at"))
    if 0:# new code: append whatever follows the sentinel.
        i += 3 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 3 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ['@' + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endAt)
    
def readStartDoc (self,s,i):
    """Read an @+doc sentinel."""
    at = self ; assert(g.match(s,i,"+doc"))
    if 0: # new code: append whatever follows the sentinel.
        i += 4 ; j = self.skipToEndSentinel(s,i) ; follow = s[i:j]
        at.out.append('@' + follow) ; at.docOut = []
    else:
        i += 4 ; j = g.skip_ws(s,i) ; ws = s[i:j]
        at.docOut = ["@doc" + ws + '\n'] # This newline may be removed by a following @nonl
    at.inCode = False
    at.endSentinelStack.append(endDoc)
    
def skipToEndSentinel(self,s,i):
    end = self.endSentinelComment
    if end:
        j = s.find(end,i)
        if j == -1:
            return g.skip_to_end_of_line(s,i)
        else:
            return j
    else:
        return g.skip_to_end_of_line(s,i)</t>
<t tx="ekr.20031218072017.1753">def readLastDocLine (self,tag):
    
    """Read the @c line that terminates the doc part.
    tag is @doc or @."""
    
    at = self
    end = at.endSentinelComment
    start = at.startSentinelComment
    s = ''.join(at.docOut)
    
    if 0: # new code.
        &lt;&lt; new code &gt;&gt;
    else:
        &lt;&lt; old code &gt;&gt;</t>
<t tx="ekr.20031218072017.1754">if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(s) # The tag has already been removed.
at.docOut = []</t>
<t tx="ekr.20031218072017.1755"># Remove the @doc or @space.  We'll add it back at the end.
if g.match(s,0,tag):
    s = s[len(tag):]
else:
    at.readError("Missing start of doc part")
    return

if end:
    # Remove opening block delim.
    if g.match(s,0,start):
        s = s[len(start):]
    else:
        at.readError("Missing open block comment")
        g.trace(s)
        return
        
    # Remove trailing newline.
    if s[-1] == '\n':
        s = s[:-1]

    # Remove closing block delim.
    if s[-len(end):] == end:
        s = s[:-len(end)]
    else:
        at.readError("Missing close block comment")
        return

at.out.append(tag + s)
at.docOut = []</t>
<t tx="ekr.20031218072017.1810">def importDerivedFiles (self,parent,paths):
    
    c = self.c ; at = c.atFileCommands
    current = c.currentVnode()
    
    c.beginUpdate()
    
    for fileName in paths:
        v = parent.insertAfter()
        v.initHeadString("Imported @file " + fileName)
        c.undoer.setUndoParams("Import",v,select=current)
        at.read(v,importFileName=fileName)
        c.selectVnode(v)
        v.expand()

    c.endUpdate()</t>
<t tx="ekr.20031218072017.1863">def putVnode (self,p):

    """Write a &lt;v&gt; element corresponding to a vnode."""

    fc = self ; c = fc.c ; v = p.v
    isThin = p.isAtThinFileNode()
    isIgnore = False
    for p2 in p.self_and_parents_iter():
        if p2.isAtIgnoreNode():
            isIgnore = True ; break
    isOrphan = p.isOrphan()
    forceWrite = isIgnore or not isThin or (isThin and isOrphan)

    fc.put("&lt;v")
    &lt;&lt; Put tnode index &gt;&gt;
    &lt;&lt; Put attribute bits &gt;&gt;
    &lt;&lt; Put tnodeList and unKnownAttributes &gt;&gt;
    fc.put("&gt;")
    &lt;&lt; Write the head text &gt;&gt;

    if not self.usingClipboard:
        &lt;&lt; issue informational messages &gt;&gt;

   # New in 4.2: don't write child nodes of @file-thin trees (except when writing to clipboard)
    if p.hasChildren():
        if forceWrite or self.usingClipboard:
            fc.put_nl()
            # This optimization eliminates all "recursive" copies.
            p.moveToFirstChild()
            while 1:
                fc.putVnode(p)
                if p.hasNext(): p.moveToNext()
                else:           break
            p.moveToParent()

    fc.put("&lt;/v&gt;") ; fc.put_nl()</t>
<t tx="ekr.20031218072017.1864">if v.t.fileIndex:
    if g.app.use_gnx:
        gnx = g.app.nodeIndices.toString(v.t.fileIndex)
        fc.put(" t=") ; fc.put_in_dquotes(gnx)
    else:
        fc.put(" t=") ; fc.put_in_dquotes("T" + str(v.t.fileIndex))
        
    # g.trace(v.t)
    if forceWrite or self.usingClipboard:
        v.t.setWriteBit() # 4.2: Indicate we wrote the body text.
else:
    g.trace(v.t.fileIndex,v)
    g.es("error writing file(bad v.t.fileIndex)!")
    g.es("try using the Save To command")</t>
<t tx="ekr.20031218072017.1865">attr = ""
if p.v.isExpanded(): attr += "E"
if p.v.isMarked():   attr += "M"
if p.v.isOrphan():   attr += "O"

if 1: # No longer a bottleneck now that we use p.equal rather than p.__cmp__
    # Almost 30% of the entire writing time came from here!!!
    if p.equal(self.topPosition):     attr += "T" # was a bottleneck
    if p.equal(self.currentPosition): attr += "V" # was a bottleneck

if attr: fc.put(' a="%s"' % attr)</t>
<t tx="ekr.20031218072017.1866">headString = p.v.headString()

if headString:
    fc.put("&lt;vh&gt;")
    fc.putEscapedString(headString)
    fc.put("&lt;/vh&gt;")</t>
<t tx="ekr.20031218072017.1921">@ It is important for PHP and other situations that @first and @last directives get translated to verbatim lines that do _not_ include what follows the @first &amp; @last directives.
@c

def putDirective(self,s,i):
    
    """Output a sentinel a directive or reference s."""

    tag = "@delims"
    assert(i &lt; len(s) and s[i] == '@')
    k = i
    j = g.skip_to_end_of_line(s,i)
    directive = s[i:j]

    if g.match_word(s,k,"@delims"):
        &lt;&lt; handle @delims &gt;&gt;
    elif g.match_word(s,k,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,k,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;
    elif g.match_word(s,k,"@last"):
        self.putSentinel("@@last") # 10/27/03: Convert to an verbatim line _without_ anything else.
    elif g.match_word(s,k,"@first"):
        self.putSentinel("@@first") # 10/27/03: Convert to an verbatim line _without_ anything else.
    else:
        self.putSentinel("@" + directive)

    i = g.skip_line(s,k)
    return i</t>
<t tx="ekr.20031218072017.1922"># Put a space to protect the last delim.
self.putSentinel(directive + " ") # 10/23/02: put @delims, not @@delims

# Skip the keyword and whitespace.
j = i = g.skip_ws(s,k+len(tag))

# Get the first delim.
while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
    i += 1
if j &lt; i:
    self.startSentinelComment = s[j:i]
    # Get the optional second delim.
    j = i = g.skip_ws(s,i)
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    self.endSentinelComment = g.choose(j&lt;i, s[j:i], "")
else:
    self.writeError("Bad @delims directive")</t>
<t tx="ekr.20031218072017.1954">def readEndAt (self,s,i):
    
    """Read an @-at sentinel."""

    at = self
    at.readLastDocLine("@")
    at.popSentinelStack(endAt)
    at.inCode = True
        
def readEndDoc (self,s,i):
    
    """Read an @-doc sentinel."""

    at = self
    at.readLastDocLine("@doc")
    at.popSentinelStack(endDoc)
    at.inCode = True</t>
<t tx="ekr.20031218072017.2001">def putOpenNodeSentinel(self,p,inAtAll=False,inAtOthers=False,middle=False):
    
    """Write @+node sentinel for p."""
    
    at = self

    if not inAtAll and p.isAtFileNode() and p != at.root:
        at.writeError("@file not valid in: " + p.headString())
        return
        
    # g.trace(at.thinFile,p)
        
    s = at.nodeSentinelText(p)
    
    if middle:
        at.putSentinel("@+middle:" + s)
    else:
        at.putSentinel("@+node:" + s)
    
    if not at.thinFile:
        # Append the n'th tnode to the root's tnode list.
        at.root.v.t.tnodeList.append(p.v.t)</t>
<t tx="ekr.20031218072017.2002">def putTnodeList (self,v):
    
    """Put the tnodeList attribute of a tnode."""
    
    # g.trace(v)
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!

    fc = self ; nodeIndices = g.app.nodeIndices
    tnodeList = v.t.tnodeList
    if tnodeList:
        # g.trace("%4d" % len(tnodeList),v)
        fc.put(" tnodeList=") ; fc.put_dquote()
        if g.app.use_gnx:
            for t in tnodeList:
                try: # Will fail for None or any pre 4.1 file index.
                    id,time,n = t.fileIndex
                except:
                    g.trace("assigning gnx for ",v,t)
                    gnx = nodeIndices.getNewIndex()
                    v.t.setFileIndex(gnx) # Don't convert to string until the actual write.
            s = ','.join([nodeIndices.toString(t.fileIndex) for t in tnodeList])
        else:
            s = ','.join([str(t.fileIndex) for t in tnodeList])
        fc.put(s) ; fc.put_dquote()</t>
<t tx="ekr.20031218072017.2007">def findChild (self,headline):
    
    """Return the next tnode in at.root.t.tnodeList."""

    at = self ; v = at.root.v

    if not hasattr(v.t,"tnodeList"):
        at.readError("no tnodeList for " + repr(v))
        g.es("Write the @file node or use the Import Derived File command")
        g.trace("no tnodeList for ",v)
        return None
        
    if at.tnodeListIndex &gt;= len(v.t.tnodeList):
        at.readError("bad tnodeList index: %d, %s" % (at.tnodeListIndex,repr(v)))
        g.trace("bad tnodeList index",at.tnodeListIndex,len(v.t.tnodeList),v)
        return None
        
    t = v.t.tnodeList[at.tnodeListIndex]
    assert(t)
    at.tnodeListIndex += 1

    # Get any vnode joined to t.
    try:
        v = t.vnodeList[0]
    except:
        at.readError("No vnodeList for tnode: %s" % repr(t))
        g.trace(at.tnodeListIndex)
        return None
        
    # Don't check the headline.  It simply causes problems.
    t.setVisited() # Supress warning about unvisited node.
    return t
    
    if 0: # Old code:
        &lt;&lt; Check the headlines &gt;&gt;</t>
<t tx="ekr.20031218072017.2008">def getTnodeList (self,s):

    """Parse a list of tnode indices in string s."""
    
    # Remember: entries in the tnodeList correspond to @+node sentinels, _not_ to tnodes!
    
    fc = self ; 

    indexList = s.split(',') # The list never ends in a comma.
    tnodeList = []
    for index in indexList:
        index = self.canonicalTnodeIndex(index)
        t = fc.tnodesDict.get(index)
        if not t:
            # Not an error: create a new tnode and put it in fc.tnodesDict.
            # g.trace("not allocated: %s" % index)
            t = self.newTnode(index)
        tnodeList.append(t)
        
    # if tnodeList: g.trace(len(tnodeList))
    return tnodeList
</t>
<t tx="ekr.20031218072017.2012">def writeAtFileNodes (self):
    
    c = self.c

    self.assignFileIndices() # 4/3/04
    changedFiles = c.atFileCommands.writeAll(writeAtFileNodesFlag=True)
    assert(changedFiles != None)
    if changedFiles:
        g.es("auto-saving outline",color="blue")
        c.save() # Must be done to set or clear tnodeList.</t>
<t tx="ekr.20031218072017.2013">def writeMissingAtFileNodes (self):

    c = self.c ; v = c.currentVnode()

    if v:
        at = c.atFileCommands
        self.assignFileIndices() # 4/3/04
        changedFiles = at.writeMissing(v)
        assert(changedFiles != None)
        if changedFiles:
            g.es("auto-saving outline",color="blue")
            c.save() # Must be done to set or clear tnodeList.</t>
<t tx="ekr.20031218072017.2015">def writeAll(self,writeAtFileNodesFlag=False,writeDirtyAtFileNodesFlag=False,toString=False):
    
    """Write @file nodes in all or part of the outline"""

    at = self ; c = at.c
    write_new = not g.app.config.write_old_format_derived_files
    df = g.choose(write_new,at.new_df,at.old_df)
    df.initIvars()
    writtenFiles = [] # Files that might be written again.
    mustAutoSave = False

    if writeAtFileNodesFlag:
        # Write all nodes in the selected tree.
        p = c.currentPosition()
        after = p.nodeAfterTree()
    else:
        # Write dirty nodes in the entire outline.
        p =  c.rootPosition()
        after = c.nullPosition()

    &lt;&lt; Clear all orphan bits &gt;&gt;
    while p and p != after:
        if p.isAnyAtFileNode() or p.isAtIgnoreNode():
            &lt;&lt; handle v's tree &gt;&gt;
            p.moveToNodeAfterTree()
        else:
            p.moveToThreadNext()

    &lt;&lt; say the command is finished &gt;&gt;
    return mustAutoSave</t>
<t tx="ekr.20031218072017.2016">@ We must clear these bits because they may have been set on a previous write.
Calls to atFile::write may set the orphan bits in @file nodes.
If so, write_Leo_file will write the entire @file tree.
@c
    
for v2 in p.self_and_subtree_iter():
    v2.clearOrphan()</t>
<t tx="ekr.20031218072017.2017">if p.v.isDirty() or writeAtFileNodesFlag or p.v.t in writtenFiles:

    df.fileChangedFlag = False # 1/9/04
    autoSave = False
    
    # Tricky: @ignore not recognised in @silentfile nodes.
    if p.isAtAsisFileNode():
        at.asisWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtIgnoreNode():
        pass
    elif p.isAtNorefFileNode():
        at.norefWrite(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True
    elif p.isAtNoSentFileNode():
        at.write(p,nosentinels=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave
    elif p.isAtThinFileNode():
        at.write(p,thinFile=True,toString=toString)
        writtenFiles.append(p.v.t) # No need for autosave.
    elif p.isAtFileNode():
        at.write(p,toString=toString)
        writtenFiles.append(p.v.t) ; autoSave = True

    if df.fileChangedFlag and autoSave: # Set by replaceTargetFileIfDifferent.
        mustAutoSave = True</t>
<t tx="ekr.20031218072017.2018">if writeAtFileNodesFlag or writeDirtyAtFileNodesFlag:
    if len(writtenFiles) &gt; 0:
        g.es("finished")
    elif writeAtFileNodesFlag:
        g.es("no @file nodes in the selected tree")
    else:
        g.es("no dirty @file nodes")</t>
<t tx="ekr.20031218072017.2062">def getPrefs (self):

    c = self.c ; config = g.app.config
    
    if self.getOpenTag("&lt;preferences"):
        return # &lt;preferences/&gt; seeen

    table = (
        ("allow_rich_text",None,None), # Ignored.
        ("tab_width","tab_width",self.getLong),
        ("page_width","page_width",self.getLong),
        ("tangle_bat","tangle_batch_flag",self.getBool),
        ("untangle_bat","untangle_batch_flag",self.getBool),
        ("output_doc_chunks","output_doc_flag",self.getBool),
        ("noweb_flag",None,None), # Ignored.
        ("extended_noweb_flag",None,None), # Ignored.
        ("defaultTargetLanguage","target_language",self.getTargetLanguage),
        ("use_header_flag","use_header_flag",self.getBool))
    
    while 1:
        found = False
        for tag,var,f in table:
            if self.matchTag("%s=" % tag):
                if var:
                    self.getDquote() ; val = f() ; self.getDquote()
                    setattr(c,var,val)
                else:
                    self.getDqString()
                found = True ; break
        if not found:
            if self.matchTag("&gt;"):
                break
            else: # New in 4.1: ignore all other tags.
                self.getUnknownTag()

    while 1:
        if self.matchTag("&lt;defaultDirectory&gt;"):
            # New in version 0.16.
            c.tangle_directory = self.getEscapedString()
            self.getTag("&lt;/defaultDirectory&gt;")
            if not g.os_path_exists(c.tangle_directory):
                g.es("default tangle directory not found:" + c.tangle_directory)
        elif self.matchTag("&lt;TSyntaxMemo_options&gt;"):
            self.getEscapedString() # ignored
            self.getTag("&lt;/TSyntaxMemo_options&gt;")
        else: break
    self.getTag("&lt;/preferences&gt;")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    if config.configsExist:
        config.setCommandsIvars(c)</t>
<t tx="ekr.20031218072017.2063">def getTargetLanguage (self):
    
    # Must match longer tags before short prefixes.
    for name in g.app.language_delims_dict.keys():
        if self.matchTagWordIgnoringCase(name):
            language = name.replace("/","")
            # self.getDquote()
            return language
            
    return "c" # default</t>
<t tx="ekr.20031218072017.2064">def getFindPanelSettings (self):

    c = self.c ; config = g.app.config ; findFrame = g.app.findFrame
    &lt;&lt; Set defaults of all flags &gt;&gt;
    if not self.getOpenTag("&lt;find_panel_settings"):
        while 1:
            if   self.matchTag("batch="): c.batch_flag = self.getDqBool()
            elif self.matchTag("ignore_case="): c.ignore_case_flag = self.getDqBool()
            elif self.matchTag("mark_changes="): c.mark_changes_flag = self.getDqBool()
            elif self.matchTag("mark_finds="): c.mark_finds_flag = self.getDqBool()
            elif self.matchTag("node_only="): c.node_only_flag = self.getDqBool()
            elif self.matchTag("pattern_match="): c.pattern_match_flag = self.getDqBool()
            elif self.matchTag("reverse="): c.reverse_flag = self.getDqBool()
            elif self.matchTag("script_change="): c.script_change_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("script_search="): c.script_search_flag = self.getDqBool() # 11/05/03
            elif self.matchTag("search_headline="): c.search_headline_flag = self.getDqBool()
            elif self.matchTag("search_body="): c.search_body_flag = self.getDqBool()
            elif self.matchTag("selection_only="): c.selection_only_flag = self.getDqBool() # 11/9/03
            elif self.matchTag("suboutline_only="): c.suboutline_only_flag = self.getDqBool()
            elif self.matchTag("whole_word="): c.whole_word_flag = self.getDqBool()
            elif self.matchTag("wrap="): c.wrap_flag = self.getDqBool()
            elif self.matchTag("&gt;"): break
            else: self.getUnknownTag() # New in 4.1: ignore all other tags.

        # # 7/31/04: Allow only &lt;find_string&gt; or &lt;find_string/&gt;
        if self.getOpenTag("&lt;find_string&gt;"): 
            c.find_text = ""
        else:
            c.find_text = self.getEscapedString()
            self.getTag("&lt;/find_string&gt;")
        # 7/31/04: Allow only &lt;change_string&gt; or &lt;change_string/&gt;
        if self.getOpenTag("&lt;change_string&gt;"): 
            c.change_text = ""
        else:
            c.change_text = self.getEscapedString()
            self.getTag("&lt;/change_string&gt;")
        #
        self.getTag("&lt;/find_panel_settings&gt;")
    
    # Override .leo file's preferences if settings are in leoConfig.txt.
    config.setCommandsFindIvars(c)
    # Update the settings immediately.
    if g.app.gui.guiName() == "tkinter":
        g.app.findFrame.init(c)</t>
<t tx="ekr.20031218072017.2065">if g.app.gui.guiName() == "tkinter":

    for var in findFrame.intKeys:
        attr = "%s_flag" % (var)
        setattr(c,attr,False)
        # g.trace(attr)
</t>
<t tx="ekr.20031218072017.2072">def checkOutline (self,verbose=True,unittest=False,full=True):
    
    """Report any possible clone errors in the outline.
    
    Remove any unused tnodeLists."""
    
    c = self ; count = 1 ; errors = 0
    isTkinter = g.app.gui and g.app.gui.guiName() == "tkinter"

    if full and not unittest:
        g.es("all tests enabled: this may take awhile",color="blue")

    p = c.rootPosition()
    &lt;&lt; assert equivalence of lastVisible methods &gt;&gt;
    for p in c.allNodes_iter():
        try:
            count += 1
            &lt;&lt; remove unused tnodeList &gt;&gt;
            if full: # Unit tests usually set this false.
                &lt;&lt; do full tests &gt;&gt;
        except AssertionError,message:
            errors += 1
            &lt;&lt; give test failed message &gt;&gt;
    if verbose or not unittest:
        &lt;&lt; print summary message &gt;&gt;
    return errors</t>
<t tx="ekr.20031218072017.2106"></t>
<t tx="ekr.20031218072017.2107">def putRefAt (self,s,i,n1,n2,p,delta):
    
    """Put a reference at s[n1:n2+2] from p."""
    
    at = self ; name = s[n1:n2+2]

    ref = g.findReference(name,p)
    if not ref:
        if not at.perfectImportRoot: # A kludge: we shouldn't be importing derived files here!
            at.writeError(
                "undefined section: %s\n\treferenced from: %s" %
                ( name,p.headString()))
        return None
    
    # Expand the ref.
    if not delta:
        junk,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)

    at.putLeadInSentinel(s,i,n1,delta)
    
    inBetween = []
    if at.thinFile: # @+-middle used only in thin files.
        parent = ref.parent()
        while parent != p:
            inBetween.append(parent)
            parent = parent.parent()
        
    at.indent += delta
    
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + name)
    else:
        at.putSentinel("@" + name)
        
    if inBetween:
        for p2 in inBetween:
            at.putOpenNodeSentinel(p2,middle=True)
        
    at.putOpenNodeSentinel(ref)
    at.putBody(ref)
    at.putCloseNodeSentinel(ref)
    
    if inBetween:
        inBetween.reverse()
        for p2 in inBetween:
            at.putCloseNodeSentinel(p2,middle=True)
    
    at.indent -= delta
    
    return delta</t>
<t tx="ekr.20031218072017.2108">def putAfterLastRef (self,s,start,delta):
    
    """Handle whatever follows the last ref of a line."""
    
    at = self
    
    j = g.skip_ws(s,start)
    
    if j &lt; len(s) and s[j] != '\n':
        end = g.skip_line(s,start)
        after = s[start:end] # Ends with a newline only if the line did.
        # Temporarily readjust delta to make @afterref look better.
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after)
        if at.sentinels and after and after[-1] != '\n':
            at.onl() # Add a newline if the line didn't end with one.
        at.indent -= delta
    else:
        # Temporarily readjust delta to make @nl look better.
        at.indent += delta
        at.putSentinel("@nl")
        at.indent -= delta</t>
<t tx="ekr.20031218072017.2109">def putAfterMiddleRef (self,s,start,end,delta):
    
    """Handle whatever follows a ref that is not the last ref of a line."""
    
    at = self
    
    if start &lt; end:
        after = s[start:end]
        at.indent += delta
        at.putSentinel("@afterref")
        at.os(after) ; at.onl_sent() # Not a real newline.
        at.putSentinel("@nonl")
        at.indent -= delta</t>
<t tx="ekr.20031218072017.2111"></t>
<t tx="ekr.20031218072017.2112"></t>
<t tx="ekr.20031218072017.2113"># 4.0: Don't use newline-pending logic.

def closeWriteFile (self):
    
    at = self
    if at.outputFile:
        at.outputFile.flush()
        if self.toStringFlag:
            self.stringOutput = self.outputFile.get()
        at.outputFile.close()
        at.outputFile = None</t>
<t tx="ekr.20031218072017.2114"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    """Write a 4.x derived file."""
    
    at = self ; c = at.c

    &lt;&lt; open the file; return on error &gt;&gt;
    try:
        self.writeOpenFile(root,nosentinels,thinFile,toString,oneNodeOnly)
        if toString:
            at.closeWriteFile()
            # Major bug: failure to clear this wipes out headlines!
            # Minor bug: sometimes this causes slight problems...
            at.root.v.t.tnodeList = [] 
        else:
            at.closeWriteFile()
            &lt;&lt; set dirty and orphan bits on error &gt;&gt;
    except:
        if toString:
            g.es("exception preprocessing script",color="blue")
            g.es_exception(full=False)
            at.root.v.t.tnodeList = []
        else:
            at.handleWriteException() # Sets dirty and orphan bits.</t>
<t tx="ekr.20031218072017.2116">if toString:
    at.targetFileName = "&lt;new_df.write string-file&gt;"
elif nosentinels:
    at.targetFileName = root.atNoSentFileNodeName()
elif thinFile:
    at.targetFileName = root.atThinFileNodeName()
else:
    at.targetFileName = root.atFileNodeName()
    
ok = at.openWriteFile(root,toString)
    
if not ok:
    return</t>
<t tx="ekr.20031218072017.2118">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    self.os(line) ; self.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20031218072017.2119">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"

# 4/17/04 Use g.splitLines to preserve trailing newlines.
lines = g.splitLines(root.v.t.bodyString)
n = len(lines) ; j = k = n - 1

# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    elif not line.strip():
        j -= 1
    else: break
    
# Write the @last lines.
for line in lines[j+1:k+1]:
    if g.match(line,0,tag):
        i = len(tag) ; i = g.skip_ws(line,i)
        self.os(line[i:])</t>
<t tx="ekr.20031218072017.2121"># Setting the orphan and dirty flags tells Leo to write the tree..

if at.errors &gt; 0 or at.root.isOrphan():
    root.setOrphan()
    root.setDirty() # Make _sure_ we try to rewrite this file.
    os.remove(at.outputFileName) # Delete the temp file.
    g.es("Not written: " + at.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    at.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20031218072017.2122">def norefWrite(self,root,toString=False):

    at = self

    c = at.c ; at.root = root
    at.errors = 0
    at.root.t.tnodeList = [] # 9/26/03: after beta 1 release.
    at.sentinels = True # 10/1/03
    at.thinFile = False # 5/17/04
    c.endEditing() # Capture the current headline.
    try:
        at.targetFileName = root.atNorefFileNodeName()
        ok = at.openWriteFile(root,toString)
        if not ok: return
        &lt;&lt; write root's tree &gt;&gt;
        at.closeWriteFile()
        at.replaceTargetFileIfDifferent()
        root.clearOrphan() ; root.clearDirty()
    except:
        at.handleWriteException(root)
        
rawWrite = norefWrite
</t>
<t tx="ekr.20031218072017.2123">&lt;&lt; put all @first lines in root &gt;&gt;
at.putOpenLeoSentinel("@+leo-ver=4")
&lt;&lt; put optional @comment sentinel lines &gt;&gt;

for p in root.self_and_subtree_iter():
    &lt;&lt; Write p's node &gt;&gt;

at.putSentinel("@-leo")
&lt;&lt; put all @last lines in root &gt;&gt;</t>
<t tx="ekr.20031218072017.2124">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # Write @first line, whether empty or not
    line = s[j:i]
    at.putBuffered(line) ; at.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20031218072017.2125">s2 = g.app.config.output_initial_comment
if s2:
    lines = string.split(s2,"\\n")
    for line in lines:
        line = line.replace("@date",time.asctime())
        if len(line)&gt; 0:
            at.putSentinel("@comment " + line)
</t>
<t tx="ekr.20031218072017.2126">at.putOpenNodeSentinel(p,inAtOthers=True)

s = p.bodyString()
if s and len(s) &gt; 0:
    s = g.toEncodedString(s,at.encoding,reportErrors=True) # 3/7/03
    at.outputStringWithLineEndings(s)
    
# Put an @nonl sentinel if s does not end in a newline.
if s and s[-1] != '\n':
    at.onl_sent() ; at.putSentinel("@nonl")

at.putCloseNodeSentinel(p,inAtOthers=True)</t>
<t tx="ekr.20031218072017.2127">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    at.putBuffered(line[i:]) ; at.onl()</t>
<t tx="ekr.20031218072017.2128">def putBody(self,p,putCloseSentinel=True,oneNodeOnly=False):
    
    """ Generate the body enclosed in sentinel lines."""

    at = self ; s = p.bodyString()
    
    p.v.t.setVisited() # Suppress orphans check.
    p.v.setVisited() # Make sure v is never expanded again.
    if not at.thinFile:
        p.v.t.setWriteBit() # Mark the tnode to be written.
        
    if not at.thinFile and not s: return
    inCode = True
    &lt;&lt; Make sure all lines end in a newline &gt;&gt;
    i = 0
    while i &lt; len(s):
        next_i = g.skip_line(s,i)
        assert(next_i &gt; i)
        kind = at.directiveKind(s,i)
        &lt;&lt; handle line at s[i] &gt;&gt;
        i = next_i
    if not inCode:
        at.putEndDocLine()
    if at.sentinels and not trailingNewlineFlag:
        at.putSentinel("@nonl")</t>
<t tx="ekr.20031218072017.2129">if kind == noDirective:
    if not oneNodeOnly:
        if inCode:
            hasRef,n1,n2 = at.findSectionName(s,i)
            if hasRef and not at.raw:
                at.putRefLine(s,i,n1,n2,p)
            else:
                at.putCodeLine(s,i)
        else:
            at.putDocLine(s,i)
elif kind in (docDirective,atDirective):
    assert(not at.pending)
    at.putStartDocLine(s,i,kind)
    inCode = False
elif kind in (cDirective,codeDirective):
    # Only @c and @code end a doc part.
    if not inCode:
        at.putEndDocLine() 
    at.putDirective(s,i)
    inCode = True
elif kind == allDirective:
    if not oneNodeOnly:
        if inCode: at.putAtAllLine(s,i,p)
        else: at.putDocLine(s,i)
elif kind == othersDirective:
    if not oneNodeOnly:
        if inCode: at.putAtOthersLine(s,i,p)
        else: at.putDocLine(s,i) # 12/7/03
elif kind == rawDirective:
    at.raw = True
    at.putSentinel("@@raw")
elif kind == endRawDirective:
    at.raw = False
    at.putSentinel("@@end_raw")
    i = g.skip_line(s,i)
elif kind == miscDirective:
    at.putDirective(s,i)
else:
    assert(0) # Unknown directive.</t>
<t tx="ekr.20031218072017.2130"></t>
<t tx="ekr.20031218072017.2131">def inAtOthers(self,p):
    
    """Returns True if p should be included in the expansion of the at-others directive
    
    in the body text of p's parent."""

    # Return False if this has been expanded previously.
    if  p.v.isVisited():
        # g.trace("previously visited",p.v)
        return False
    
    # Return False if this is a definition node.
    h = p.headString() ; i = g.skip_ws(h,0)
    isSection,junk = self.isSectionName(h,i)
    if isSection:
        # g.trace("is section",p)
        return False

    # Return False if p's body contains an @ignore directive.
    if p.isAtIgnoreNode():
        # g.trace("is @ignore",p)
        return False
    else:
        # g.trace("ok",p)
        return True</t>
<t tx="ekr.20031218072017.2132">def putAtOthersChild(self,p):
    
    at = self

    clonedSibs,thisClonedSibIndex = at.scanForClonedSibs(p.v)
    if clonedSibs &gt; 1 and thisClonedSibIndex == 1:
        at.writeError("Cloned siblings are not valid in @thin trees")

    at.putOpenNodeSentinel(p,inAtOthers=True)
    at.putBody(p) 
    
    # Insert expansions of all children.
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)
            
    at.putCloseNodeSentinel(p,inAtOthers=True)</t>
<t tx="ekr.20031218072017.2133">def putAtOthersLine (self,s,i,p):
    
    """Put the expansion of @others."""
    
    at = self
    j,delta = g.skip_leading_ws_with_indent(s,i,at.tab_width)
    at.putLeadInSentinel(s,i,j,delta)

    at.indent += delta
    if at.leadingWs:
        at.putSentinel("@" + at.leadingWs + "@+others")
    else:
        at.putSentinel("@+others")
    
    for child in p.children_iter():
        if at.inAtOthers(child):
            at.putAtOthersChild(child)

    at.putSentinel("@-others")
    at.indent -= delta</t>
<t tx="ekr.20031218072017.2134">def putCodeLine (self,s,i):
    
    """Put a normal code line."""
    
    at = self
    
    # Put @verbatim sentinel if required.
    k = g.skip_ws(s,i)
    if g.match(s,k,self.startSentinelComment + '@'):
        self.putSentinel("@verbatim")

    j = g.skip_line(s,i)
    line = s[i:j]

    # g.app.config.write_strips_blank_lines
    if 0: # 7/22/04: Don't put any whitespace in otherwise blank lines.
        if line.strip(): # The line has non-empty content.
            if not at.raw:
                at.putIndent(at.indent)
        
            if line[-1:]=="\n":
                at.os(line[:-1])
                at.onl()
            else:
                at.os(line)
        elif line and line[-1] == '\n':
            at.onl()
        else:
            g.trace("Can't happen: completely empty line")
    else:
        # 1/29/04: Don't put leading indent if the line is empty!
        if line and not at.raw:
            at.putIndent(at.indent)
    
        if line[-1:]=="\n":
            at.os(line[:-1])
            at.onl()
        else:
            at.os(line)</t>
<t tx="ekr.20031218072017.2135"></t>
<t tx="ekr.20031218072017.2136"># Returns the kind of at-directive or noDirective.

def directiveKind(self,s,i):

    at = self
    n = len(s)
    if i &gt;= n or s[i] != '@':
        j = g.skip_ws(s,i)
        if g.match_word(s,j,"@others"):
            return othersDirective
        elif g.match_word(s,j,"@all"):
            return allDirective
        else:
            return noDirective

    table = (
        ("@all",allDirective),
        ("@c",cDirective),
        ("@code",codeDirective),
        ("@doc",docDirective),
        ("@end_raw",endRawDirective),
        ("@others",othersDirective),
        ("@raw",rawDirective))

    # This code rarely gets executed, so simple code suffices.
    if i+1 &gt;= n or g.match(s,i,"@ ") or g.match(s,i,"@\t") or g.match(s,i,"@\n"):
        # 10/25/02: @space is not recognized in cweb mode.
        # 11/15/02: Noweb doc parts are _never_ scanned in cweb mode.
        return g.choose(at.language=="cweb",
            noDirective,atDirective)

    # 10/28/02: @c and @(nonalpha) are not recognized in cweb mode.
    # We treat @(nonalpha) separately because @ is in the colorizer table.
    if at.language=="cweb" and (
        g.match_word(s,i,"@c") or
        i+1&gt;= n or s[i+1] not in string.ascii_letters):
        return noDirective

    for name,directive in table:
        if g.match_word(s,i,name):
            return directive

    # 10/14/02: return miscDirective only for real directives.
    for name in leoColor.leoKeywords:
        if g.match_word(s,i,name):
            return miscDirective

    return noDirective</t>
<t tx="ekr.20031218072017.2137">def findSectionName(self,s,i):
    
    end = s.find('\n',i)
    if end == -1:
        n1 = s.find("&lt;&lt;",i)
        n2 = s.find("&gt;&gt;",i)
    else:
        n1 = s.find("&lt;&lt;",i,end)
        n2 = s.find("&gt;&gt;",i,end)

    return -1 &lt; n1 &lt; n2, n1, n2</t>
<t tx="ekr.20031218072017.2138"># Note:  self.outputFile may be either a fileLikeObject or a real file.

</t>
<t tx="ekr.20031218072017.2140">def executeScript(self,p=None,script=None):

    """This executes body text as a Python script.
    
    We execute the selected text, or the entire body text if no text is selected."""
    
    c = self ; error = False ; s = None ; script1 = script

    if not script:
        script = g.getScript(c,p)
    &lt;&lt; redirect output &gt;&gt;
    if script:
        script = script.strip()
    if script:
        script += '\n' # Make sure we end the script properly.
        try:
            exec script in {} # Use {} to get a pristine environment!
            &lt;&lt; unredirect output &gt;&gt;
            if not script1:
                g.es("end of script",color="purple")
        except:
            &lt;&lt; unredirect output &gt;&gt;
            g.es("exception executing script")
            n = g.es_exception(full=False,c=c)
            if n is not None:
                &lt;&lt; dump the lines of script near the error &gt;&gt;
                if p and not script1:
                    c.goToScriptLineNumber(p,script,n)
            c.frame.tree.redrawAfterException()
    elif not error:
        &lt;&lt; unredirect output &gt;&gt;
        g.es("no script selected",color="blue")
        
    # Force a redraw _after_ all messages have been output.
    c.redraw() </t>
<t tx="ekr.20031218072017.2143">if g.app.config.redirect_execute_script_output_to_log_pane:

    g.redirectStdout() # Redirect stdout
    g.redirectStderr() # Redirect stderr</t>
<t tx="ekr.20031218072017.2278">@ Warning:
g.importFromPath uses imp.load_module, and that is equivalent to reload!
Calling this function to reload Leo files will crash Leo!
@c

def importFromPath (name,path,verbose=False):
    
    import imp

    try:
        file = None ; data = None ; result = None
        try:
            fn = g.shortFileName(name)
            mod_name,ext = g.os_path_splitext(fn)
            path = g.os_path_normpath(path)
            if g.CheckVersion(sys.version,"2.3"):
                path = g.toEncodedString(path,app.tkEncoding)
            else:
                path = str(path) # May throw exception.
            try:
                data = imp.find_module(mod_name,[path]) # This can open the file.
            except ImportError:
                if verbose:
                    s = "Can not import %s from %s" % (mod_name,path)
                    print s ; g.es(s,color="blue")
            if data:
                file,pathname,description = data
                try:
                    result = imp.load_module(mod_name,file,pathname,description)
                except ImportError:
                    g.es_exception()
        except:
            g.es_exception()

    # Put no return statements before here!
    finally: 
        if file: file.close()

    return result</t>
<t tx="ekr.20031218072017.2306">def getGlobals (self):

    if self.getOpenTag("&lt;globals"):
        # &lt;globals/&gt; seen: set reasonable defaults:
        self.ratio = 0.5
        y,x,h,w = 50,50,500,700
    else:
        self.getTag("body_outline_ratio=\"")
        self.ratio = self.getDouble() ; self.getDquote() ; self.getTag("&gt;")

        self.getTag("&lt;global_window_position")
        y,x,h,w = self.getPosition()
        self.getTag("/&gt;")

        self.getTag("&lt;global_log_window_position")
        self.getPosition()
        self.getTag("/&gt;") # no longer used.

        self.getTag("&lt;/globals&gt;")

    # 7/15/02: Redraw the window before writing into it.
    self.frame.setTopGeometry(w,h,x,y)
    self.frame.deiconify()
    self.frame.lift()
    self.frame.update()</t>
<t tx="ekr.20031218072017.2322"># This is the entry point to the write code.  root should be an @file vnode.

def write(self,root,nosentinels=False,thinFile=False,toString=False,oneNodeOnly=False):
    
    if thinFile:
        self.error("@file-thin not supported before 4.2")
        return
    
    # Remove any old tnodeList.
    if hasattr(root.v.t,"tnodeList"):
        # g.trace("removing tnodeList for ",root)
        delattr(root.v.t,"tnodeList")

    c = self.c
    &lt;&lt; initialize &gt;&gt;
    try:
        &lt;&lt; open the file; return on error &gt;&gt;
        root.clearAllVisitedInTree() # 1/28/04: clear both vnode and tnode bits.
        &lt;&lt; write then entire @file tree &gt;&gt;
        self.closeWriteFile()
        if not nosentinels:
            self.warnAboutOrphandAndIgnoredNodes()
        &lt;&lt; finish writing &gt;&gt;
    except:
        self.handleWriteException()
</t>
<t tx="ekr.20031218072017.2323">self.sentinels = not nosentinels
self.raw = False

self.errors = 0 # 9/26/02
c.setIvarsFromPrefs()
self.root = root
c.endEditing() # Capture the current headline.</t>
<t tx="ekr.20031218072017.2324">if nosentinels:
    self.targetFileName = root.atNoSentFileNodeName()
else:
    self.targetFileName = root.atFileNodeName()

ok = self.openWriteFile(root,toString)
if not ok: return</t>
<t tx="ekr.20031218072017.2325">next = root.nodeAfterTree()

&lt;&lt; put all @first lines in root &gt;&gt;
&lt;&lt; write the derived file &gt;&gt;
&lt;&lt; put all @last lines in root &gt;&gt;

root.setVisited()</t>
<t tx="ekr.20031218072017.2326">@ Write any @first lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines preceding the @+leo sentinel.
@c

s = root.v.t.bodyString
tag = "@first"
i = 0
while g.match(s,i,tag):
    i += len(tag)
    i = g.skip_ws(s,i)
    j = i
    i = g.skip_to_end_of_line(s,i)
    # 21-SEP-2002 DTHEIN: write @first line, whether empty or not
    line = s[j:i]
    self.putBuffered(line) ; self.onl()
    i = g.skip_nl(s,i)</t>
<t tx="ekr.20031218072017.2327">tag1 = "@+leo"

self.putOpenLeoSentinel(tag1)
self.putInitialComment()
self.putOpenNodeSentinel(root)
self.putBodyPart(root)
self.putCloseNodeSentinel(root)
self.putSentinel("@-leo")</t>
<t tx="ekr.20031218072017.2328">@ Write any @last lines.  These lines are also converted to @verbatim lines, so the read logic simply ignores lines following the @-leo sentinel.
@c

tag = "@last"
lines = string.split(root.v.t.bodyString,'\n')
n = len(lines) ; j = k = n - 1
# Don't write an empty last line.
if j &gt;= 0 and len(lines[j])==0:
    j = k = n - 2
# Scan backwards for @last directives.
while j &gt;= 0:
    line = lines[j]
    if g.match(line,0,tag): j -= 1
    else: break
# Write the @last lines.
for line in lines[j+1:k+1]:
    i = len(tag) ; i = g.skip_ws(line,i)
    self.putBuffered(line[i:]) ; self.onl()</t>
<t tx="ekr.20031218072017.2330">@ We set the orphan and dirty flags if there are problems writing the file to force write_Leo_file to write the tree to the .leo file.
@c

if self.errors &gt; 0 or self.root.isOrphan():
    root.setOrphan()
    root.setDirty() # 2/9/02: make _sure_ we try to rewrite this file.
    os.remove(self.outputFileName) # Delete the temp file.
    g.es("Not written: " + self.outputFileName)
else:
    root.clearOrphan()
    root.clearDirty()
    self.replaceTargetFileIfDifferent()</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
lst: a list (Do _not_ use list, it is a Python global!)
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode

See the child of this node called "Overview of Code" for more documentation.</t>
<t tx="ekr.20031218072017.2415"></t>
<t tx="ekr.20031218072017.2418">def initScriptFind(findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
    
    import leoTest
    import leoGlobals as g
    
    # Find the scripts.
    c = g.top() ; p = c.currentPosition()
    u = leoTest.testUtils()
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    g.app.findFrame.init(c)
    c.findPanel()</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 1: # Set to 1 for lint-like testing.
    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        print ; print "Warning: pychecker.checker running..." ; print
    except:
        pass</t>
<t tx="ekr.20031218072017.2609">def closeLeoWindow (self,frame):
    
    """Attempt to close a Leo window.
    
    Return False if the user veto's the close."""
    
    c = frame.c
    
    if c.promptingForClose:
        # There is already a dialog open asking what to do.
        return False

    if c.changed:
        c.promptingForClose = True
        veto = frame.promptForSave()
        c.promptingForClose = False
        if veto: return False

    g.app.setLog(None) # no log until we reactive a window.
    
    g.doHook("close-frame",c=c) # This may remove frame from the window list.
    
    if frame in g.app.windowList:
        g.app.destroyWindow(frame)
    
    if g.app.windowList:
        # Pick a window to activate so we can set the log.
        w = g.app.windowList[0]
        w.deiconify()
        w.lift()
        g.app.setLog(w.log)
    else:
        g.app.finishQuit()

    return True # The window has been closed.</t>
<t tx="ekr.20031218072017.2707">def writeError(self,message):

    if self.errors == 0:
        g.es_error("errors writing: " + self.targetFileName)

    self.error(message)
    self.root.setOrphan()
    self.root.setDirty()</t>
<t tx="ekr.20031218072017.2720"># Open files.  Set root.orphan and root.dirty flags and return on errors.

def openWriteFile (self,root,toString):
    
    self.toStringFlag = toString
    self.errors = 0 # Bug fix: 6/25/04.
    self.root = root # Bug fix: 7/30/04: needed by error logic.

    try:
        self.scanAllDirectives(root)
        valid = self.errors == 0
    except:
        self.writeError("exception in atFile.scanAllDirectives")
        g.es_exception()
        valid = False
        
    if valid and toString:
        self.targetFileName = self.outputFileName = "&lt;string-file&gt;"
        self.outputFile = g.fileLikeObject()
        self.stringOutput = ""
        return valid

    if valid:
        try:
            fn = self.targetFileName
            self.shortFileName = fn # name to use in status messages.
            self.targetFileName = g.os_path_join(self.default_directory,fn)
            self.targetFileName = g.os_path_normpath(self.targetFileName)
            path = g.os_path_dirname(self.targetFileName)
            if not path or not g.os_path_exists(path):
                self.writeError("path does not exist: " + path)
                valid = False
        except:
            self.writeError("exception creating path:" + fn)
            g.es_exception()
            valid = False

    if valid and g.os_path_exists(self.targetFileName):
        try:
            if not os.access(self.targetFileName,os.W_OK):
                self.writeError("can not create: read only: " + self.targetFileName)
                valid = False
        except:
            pass # os.access() may not exist on all platforms.
        
    if valid:
        try:
            root.clearOrphan() # Bug fix: 5/25/04.
            self.outputFileName = self.targetFileName + ".tmp"
            self.outputFile = open(self.outputFileName,'wb')
            if self.outputFile is None:
                self.writeError("can not create " + self.outputFileName)
                valid = False
        except:
            g.es("exception creating:" + self.outputFileName)
            g.es_exception()
            valid = False
            self.outputFile = None # 3/22/04

    if not valid:
        root.setOrphan()
        root.setDirty()
        self.outputFile = None # 1/29/04
    
    return valid</t>
<t tx="ekr.20031218072017.2756"></t>
<t tx="ekr.20031218072017.2757">def readOpenFile(self,root,file,firstLines,perfectImportRoot=None):
    
    """Read an open 4.x thick or thin derived file."""
    
    at = self
    
    # This is safe (just barely) because only this method calls scanText4&gt;
    at.perfectImportRoot = perfectImportRoot

    # Scan the 4.x file.
    at.tnodeListIndex = 0
    # at.thinFile tells scanText4 whether this is a thin file or not.
    lastLines = at.scanText4(file,root)
    root.v.t.setVisited() # Disable warning about set nodes.
    
    # Handle first and last lines.
    try: body = root.v.t.tempBodyString
    except: body = ""
    lines = body.split('\n')
    at.completeFirstDirectives(lines,firstLines)
    at.completeLastDirectives(lines,lastLines)
    s = '\n'.join(lines).replace('\r', '')
    root.v.t.tempBodyString = s</t>
<t tx="ekr.20031218072017.2758">def scanText4 (self,file,p):
    
    """Scan a 4.x derived file non-recursively."""

    at = self
    &lt;&lt; init ivars for scanText4 &gt;&gt;
    while at.errors == 0 and not at.done:
        s = at.readLine(file)
        if len(s) == 0: break
        kind = at.sentinelKind(s)
        # g.trace(at.sentinelName(kind),s.strip())
        if kind == noSentinel:
            i = 0
        else:
            i = at.skipSentinelStart(s,0)
        func = at.dispatch_dict[kind]
        func(s,i)

    if at.errors == 0 and not at.done:
        &lt;&lt; report unexpected end of text &gt;&gt;

    return at.lastLines
</t>
<t tx="ekr.20031218072017.2759"># Unstacked ivars...
at.cloneSibCount = 0
at.done = False
at.inCode = True
at.indent = 0 # Changed only for sentinels.
at.lastLines = [] # The lines after @-leo
at.leadingWs = ""
at.root = p
at.rootSeen = False
at.updateWarningGiven = False

# Stacked ivars...
at.endSentinelStack = [endLeo] # We have already handled the @+leo sentinel.
at.out = [] ; at.outStack = []
at.t = p.v.t ; at.tStack = []
at.lastThinNode = p.v ; at.thinNodeStack = [p.v]

if 0: # Useful for debugging.
    if hasattr(p.v.t,"tnodeList"):
        g.trace("len(tnodeList)",len(p.v.t.tnodeList),p.v)
    else:
        g.trace("no tnodeList",p.v)
        
# g.trace(at.startSentinelComment)</t>
<t tx="ekr.20031218072017.2760">assert(at.endSentinelStack)

at.readError(
    "Unexpected end of file. Expecting %s sentinel" %
    at.sentinelName(at.endSentinelStack[-1]))</t>
<t tx="ekr.20031218072017.2761">def readNormalLine (self,s,i):

    at = self
    
    if at.inCode:
        if not at.raw:
            s = g.removeLeadingWhitespace(s,at.indent,at.tab_width)
        at.out.append(s)
    else:
        &lt;&lt; Skip the leading stuff &gt;&gt;
        &lt;&lt; Append s to docOut &gt;&gt;</t>
<t tx="ekr.20031218072017.2762">if len(at.endSentinelComment) == 0:
    # Skip the single comment delim and a blank.
    i = g.skip_ws(s,0)
    if g.match(s,i,at.startSentinelComment):
        i += len(at.startSentinelComment)
        if g.match(s,i," "): i += 1
else:
    i = at.skipIndent(s,0,at.indent)

</t>
<t tx="ekr.20031218072017.2763">line = s[i:-1] # remove newline for rstrip.

if line == line.rstrip():
    # no trailing whitespace: the newline is real.
    at.docOut.append(line + '\n')
else:
    # trailing whitespace: the newline is fake.
    at.docOut.append(line)</t>
<t tx="ekr.20031218072017.2764"></t>
<t tx="ekr.20031218072017.2765">def readStartLeo (self,s,i):
    
    """Read an unexpected @+leo sentinel."""

    at = self
    assert(g.match(s,i,"+leo"))
    at.readError("Ignoring unexpected @+leo sentinel")</t>
<t tx="ekr.20031218072017.2766">def readStartNode (self,s,i,middle=False):
    
    """Read an @+node or @+middle sentinel."""
    
    at = self
    if middle:
        assert(g.match(s,i,"+middle:"))
        i += 8
    else:
        assert(g.match(s,i,"+node:"))
        i += 6
    
    if at.thinFile:
        &lt;&lt; set gnx and bump i &gt;&gt;
    &lt;&lt; Set headline, undoing the CWEB hack &gt;&gt;
    if not at.root_seen:
        at.root_seen = True
        &lt;&lt; Check the filename in the sentinel &gt;&gt;

    i,newIndent = g.skip_leading_ws_with_indent(s,0,at.tab_width)
    at.indentStack.append(at.indent) ; at.indent = newIndent
    
    at.outStack.append(at.out) ; at.out = []
    at.tStack.append(at.t)

    if at.importing:
        p = at.createImportedNode(at.root,at.c,headline)
        at.t = p.v.t
    elif at.thinFile:
        at.thinNodeStack.append(at.lastThinNode)
        at.lastThinNode = v = at.createThinChild(gnx,headline)
        at.t = v.t
    else:
        at.t = at.findChild(headline)
    
    at.endSentinelStack.append(endNode)</t>
<t tx="ekr.20031218072017.2767"># Set headline to the rest of the line.
# Don't strip leading whitespace."

if len(at.endSentinelComment) == 0:
    headline = s[i:-1].rstrip()
else:
    k = s.rfind(at.endSentinelComment,i)
    headline = s[i:k].rstrip() # works if k == -1

# Undo the CWEB hack: undouble @ signs if the opening comment delim ends in '@'.
if at.startSentinelComment[-1:] == '@':
    headline = headline.replace('@@','@')</t>
<t tx="ekr.20031218072017.2768">if 0: # This doesn't work so well in cooperative environments.
    if not at.importing:

        h = headline.strip()
        
        if h[:5] == "@file":
            i,junk,junk = g.scanAtFileOptions(h)
            fileName = string.strip(h[i:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        elif h[:8] == "@rawfile":
            fileName = string.strip(h[8:])
            if fileName != at.targetFileName:
                at.readError("File name in @node sentinel does not match file's name")
        else:
            at.readError("Missing @file in root @node sentinel")</t>
<t tx="ekr.20031218072017.2769">def readStartOthers (self,s,i):
    
    """Read an @+others sentinel."""

    at = self
    j = g.skip_ws(s,i)
    leadingWs = s[i:j]
    if leadingWs:
        assert(g.match(s,j,"@+others"))
    else:
        assert(g.match(s,j,"+others"))

    # Make sure that the generated at-others is properly indented.
    at.out.append(leadingWs + "@others\n")
    
    at.endSentinelStack.append(endOthers)</t>
<t tx="ekr.20031218072017.2770"></t>
<t tx="ekr.20031218072017.2771">def readEndLeo (self,s,i):
    
    """Read an @-leo sentinel."""
    
    at = self

    # Ignore everything after @-leo.
    # Such lines were presumably written by @last.
    while 1:
        s = at.readLine(at.file)
        if len(s) == 0: break
        at.lastLines.append(s) # Capture all trailing lines, even if empty.

    at.done = True</t>
<t tx="ekr.20031218072017.2772">def readEndNode (self,s,i,middle=False):
    
    """Handle end-of-node processing for @-others and @-ref sentinels."""

    at = self ; c = self.c
    
    # End raw mode.
    at.raw = False
    
    # Set the temporary body text.
    s = ''.join(at.out)
    s = g.toUnicode(s,g.app.tkEncoding) # 9/28/03

    if at.importing:
        at.t.bodyString = s
    elif middle: 
        pass # Middle sentinels never alter text.
    else:
        if hasattr(at.t,"tempBodyString") and s != at.t.tempBodyString:
            old = at.t.tempBodyString
        elif at.t.hasBody() and s != at.t.getBody():
            old = at.t.getBody()
        else:
            old = None
        if old:
            if at.perfectImportRoot:
                &lt;&lt; bump at.correctedLines and tell about the correction &gt;&gt;
                p.setMarked()
                at.t.bodyString = s # Just etting at.t.tempBodyString won't work here.
                at.t.setDirty() # Mark the node dirty.  Ancestors will be marked dirty later.
                at.c.setChanged(True)
            else:
                if not at.updateWarningGiven:
                    at.updateWarningGiven = True
                    g.es("Warning: updating changed text",color="blue")
                #g.es("old...\n%s\n" % old)
                #g.es("new...\n%s\n" % s)
                # Just set the dirty bit. Ancestors will be marked dirty later.
                at.t.setDirty()
                if 1: # We must avoid the full setChanged logic here!
                    c.changed = True
                else: # Far too slow for mass changes.
                    at.c.setChanged(True)
        at.t.tempBodyString = s

    # Indicate that the tnode has been set in the derived file.
    at.t.setVisited()

    # End the previous node sentinel.
    at.indent = at.indentStack.pop()
    at.out = at.outStack.pop()
    at.t = at.tStack.pop()
    if at.thinFile and not at.importing:
        at.lastThinNode = at.thinNodeStack.pop()

    at.popSentinelStack(endNode)</t>
<t tx="ekr.20031218072017.2773">def readEndOthers (self,s,i):
    
    """Read an @-others sentinel."""
    
    at = self
    at.popSentinelStack(endOthers)</t>
<t tx="ekr.20031218072017.2774"></t>
<t tx="ekr.20031218072017.2775">def  ignoreOldSentinel (self,s,i):
    
    """Ignore an 3.x sentinel."""
    
    g.es("Ignoring 3.x sentinel: " + s.strip(), color="blue")</t>
<t tx="ekr.20031218072017.2776">def  readAfterRef (self,s,i):
    
    """Read an @afterref sentinel."""
    
    at = self
    assert(g.match(s,i,"afterref"))
    
    # Append the next line to the text.
    s = at.readLine(at.file)
    at.out.append(s)</t>
<t tx="ekr.20031218072017.2777">def readComment (self,s,i):
    
    """Read an @comment sentinel."""

    assert(g.match(s,i,"comment"))

    # Just ignore the comment line!
</t>
<t tx="ekr.20031218072017.2778">def readDelims (self,s,i):
    
    """Read an @delims sentinel."""
    
    at = self
    assert(g.match(s,i-1,"@delims"));

    # Skip the keyword and whitespace.
    i0 = i-1
    i = g.skip_ws(s,i-1+7)
        
    # Get the first delim.
    j = i
    while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
        i += 1
    
    if j &lt; i:
        at.startSentinelComment = s[j:i]
        # print "delim1:", at.startSentinelComment
    
        # Get the optional second delim.
        j = i = g.skip_ws(s,i)
        while i &lt; len(s) and not g.is_ws(s[i]) and not g.is_nl(s,i):
            i += 1
        end = g.choose(j&lt;i,s[j:i],"")
        i2 = g.skip_ws(s,i)
        if end == at.endSentinelComment and (i2 &gt;= len(s) or g.is_nl(s,i2)):
            at.endSentinelComment = "" # Not really two params.
            line = s[i0:j]
            line = line.rstrip()
            at.out.append(line+'\n')
        else:
            at.endSentinelComment = end
            # print "delim2:",end
            line = s[i0:i]
            line = line.rstrip()
            at.out.append(line+'\n')
    else:
        at.readError("Bad @delims")
        # Append the bad @delims line to the body text.
        at.out.append("@delims")</t>
<t tx="ekr.20031218072017.2779">def readDirective (self,s,i):
    
    """Read an @@sentinel."""
    
    at = self
    assert(g.match(s,i,"@")) # The first '@' has already been eaten.
    
    if g.match_word(s,i,"@raw"):
        at.raw = True
    elif g.match_word(s,i,"@end_raw"):
        at.raw = False
    
    e = at.endSentinelComment
    s2 = s[i:]
    if len(e) &gt; 0:
        k = s.rfind(e,i)
        if k != -1:
            s2 = s[i:k] + '\n'
        
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        s2 = s2.replace('@@','@')
        
    if g.match_word(s,i,"@language"):
        &lt;&lt; handle @language &gt;&gt;
    elif g.match_word(s,i,"@comment"):
        &lt;&lt; handle @comment &gt;&gt;

    at.out.append(s2)</t>
<t tx="ekr.20031218072017.2780">def readNl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nl"))
    
    if at.inCode:
        at.out.append('\n')
    else:
        at.docOut.append('\n')</t>
<t tx="ekr.20031218072017.2781">def readNonl (self,s,i):
    
    """Handle an @nonl sentinel."""
    
    at = self
    assert(g.match(s,i,"nonl"))
    
    if at.inCode:
        s = ''.join(at.out)
        if s and s[-1] == '\n':
            at.out = [s[:-1]]
        else:
            g.trace("out:",s)
            at.readError("unexpected @nonl directive in code part")	
    else:
        s = ''.join(at.pending)
        if s:
            if s and s[-1] == '\n':
                at.pending = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in pending doc part")
        else:
            s = ''.join(at.docOut)
            if s and s[-1] == '\n':
                at.docOut = [s[:-1]]
            else:
                g.trace("docOut:",s)
                at.readError("unexpected @nonl directive in doc part")</t>
<t tx="ekr.20031218072017.2782">@ The sentinel contains an @ followed by a section name in angle brackets.  This code is different from the code for the @@ sentinel: the expansion of the reference does not include a trailing newline.
@c

def readRef (self,s,i):
    
    """Handle an @&lt;&lt; sentinel."""
    
    at = self
    j = g.skip_ws(s,i)
    assert(g.match(s,j,"&lt;&lt;"))
    
    if len(at.endSentinelComment) == 0:
        line = s[i:-1] # No trailing newline
    else:
        k = s.find(at.endSentinelComment,i)
        line = s[i:k] # No trailing newline, whatever k is.
            
    # Undo the cweb hack.
    start = at.startSentinelComment
    if start and len(start) &gt; 0 and start[-1] == '@':
        line = line.replace('@@','@')

    at.out.append(line)
</t>
<t tx="ekr.20031218072017.2783">def readVerbatim (self,s,i):
    
    """Read an @verbatim sentinel."""
    
    at = self
    assert(g.match(s,i,"verbatim"))
    
    # Append the next line to the text.
    s = at.readLine(at.file) 
    i = at.skipIndent(s,0,at.indent)
    at.out.append(s[i:])</t>
<t tx="ekr.20031218072017.2784">def badEndSentinel (self,expectedKind):
    
    """Handle a mismatched ending sentinel."""

    at = self
    assert(at.endSentinelStack)
    at.readError("Ignoring %s sentinel.  Expecting %s" %
        (at.sentinelName(at.endSentinelStack[-1]),
         at.sentinelName(expectedKind)))
         
def popSentinelStack (self,expectedKind):
    
    """Pop an entry from endSentinelStack and check it."""
    
    at = self
    if at.endSentinelStack and at.endSentinelStack[-1] == expectedKind:
        at.endSentinelStack.pop()
    else:
        at.badEndSentinel(expectedKind)</t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    self.frame = frame
    self.mFileName = fileName
    self.initIvars()

    # initialize the sub-commanders
    self.fileCommands = leoFileCommands.fileCommands(self)
    self.atFileCommands = leoAtFile.atFile(self)
    self.importCommands = leoImport.leoImportCommands(self)
    self.tangleCommands = leoTangle.tangleCommands(self)
    
    if 0 and g.debugGC:
        print
        print "*** using Null undoer ***"
        print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# per-document info...
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errrors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # 8/11/02: Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of vnodes for the Nodes dialog.

# 4.1: for hoist/dehoist commands.
self.hoistStack = [] # Stack of nodes to be root of drawn tree.  Affects only drawing routines.

self.recentFiles = [] # 4.1: moved to commands class.  List of recent files</t>
<t tx="ekr.20031218072017.2821">def open(self):

    c = self
    &lt;&lt; Set closeFlag if the only open window is empty &gt;&gt;

    fileName = g.app.gui.runOpenFileDialog(
        title="Open",
        filetypes=[("Leo files", "*.leo"), ("All files", "*")],
        defaultextension=".leo")

    if fileName and len(fileName) &gt; 0:
        ok, frame = g.openWithFileName(fileName,c)
        if ok and closeFlag:
            g.app.destroyWindow(c.frame)</t>
<t tx="ekr.20031218072017.2822">@ If this is the only open window was opened when the app started, and the window has never been written to or saved, then we will automatically close that window if this open command completes successfully.
@c
    
closeFlag = (
    c.frame.startupWindow==True and # The window was open on startup
    c.changed==False and c.frame.saved==False and # The window has never been changed
    g.app.numberOfWindows == 1) # Only one untitled window has ever been opened
</t>
<t tx="ekr.20031218072017.2849"></t>
<t tx="ekr.20031218072017.2850">def exportHeadlines (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="headlines.txt",
        title="Export Headlines",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.exportHeadlines(fileName)

</t>
<t tx="ekr.20031218072017.2851">def flattenOutline (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="flat.txt",
        title="Flatten Outline",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.flattenOutline(fileName)

</t>
<t tx="ekr.20031218072017.2852">def importAtRoot (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @root",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@root")
</t>
<t tx="ekr.20031218072017.2853">def importAtFile (self):
    
    c = self

    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Import To @file",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFilesCommand (names,"@file")</t>
<t tx="ekr.20031218072017.2854">def importCWEBFiles (self):
    
    c = self
    
    filetypes = [
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import CWEB Files",
        filetypes=filetypes,
        defaultextension=".w",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"cweb")
</t>
<t tx="ekr.20031218072017.2855">def importFlattenedOutline (self):
    
    c = self
    
    types = [("Text files","*.txt"), ("All files","*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import MORE Text",
        filetypes=types,
        defaultextension=".py",
        multiple=True)

    if names:
        c.importCommands.importFlattenedOutline(names)
</t>
<t tx="ekr.20031218072017.2856">def importNowebFiles (self):
    
    c = self

    filetypes = [
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    names = g.app.gui.runOpenFileDialog(
        title="Import Noweb Files",
        filetypes=filetypes,
        defaultextension=".nw",
        multiple=True)

    if names:
        c.importCommands.importWebCommand(names,"noweb")
</t>
<t tx="ekr.20031218072017.2857">def outlineToCWEB (self):
    
    c = self

    filetypes=[
        ("CWEB files", "*.w"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="cweb.w",
        title="Outline To CWEB",
        filetypes=filetypes,
        defaultextension=".w")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.outlineToWeb(fileName,"cweb")

</t>
<t tx="ekr.20031218072017.2858">def outlineToNoweb (self):
    
    c = self
    
    filetypes=[
        ("Noweb files", "*.nw"),
        ("Text files", "*.txt"),
        ("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile=self.outlineToNowebDefaultFileName,
        title="Outline To Noweb",
        filetypes=filetypes,
        defaultextension=".nw")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.outlineToWeb(fileName,"noweb")
        c.outlineToNowebDefaultFileName = fileName

</t>
<t tx="ekr.20031218072017.2859">def removeSentinels (self):
    
    c = self
    
    types = [
        ("All files","*"),
        ("C/C++ files","*.c"),
        ("C/C++ files","*.cpp"),
        ("C/C++ files","*.h"),
        ("C/C++ files","*.hpp"),
        ("Java files","*.java"),
        ("Pascal files","*.pas"),
        ("Python files","*.py") ]

    names = g.app.gui.runOpenFileDialog(
        title="Remove Sentinels",
        filetypes=types,
        defaultextension=".py")

    if names:
        c.importCommands.removeSentinelsCommand (names)</t>
<t tx="ekr.20031218072017.2860">def weave (self):
    
    c = self

    filetypes = [("Text files", "*.txt"),("All files", "*")]

    fileName = g.app.gui.runSaveFileDialog(
        initialfile="weave.txt",
        title="Weave",
        filetypes=filetypes,
        defaultextension=".txt")

    if fileName and len(fileName) &gt; 0:
        c.importCommands.weave(fileName)
</t>
<t tx="ekr.20031218072017.2864">def goToLineNumber (self,root=None,lines=None,n=None):

    c = self ; p = c.currentPosition() ; root1 = root
    if root is None:
        &lt;&lt; set root to the nearest ancestor @file node &gt;&gt;
    if lines is None:
        &lt;&lt; read the file into lines &gt;&gt;
    if n is None:
        &lt;&lt; get n, the line number, from a dialog &gt;&gt;
    if n==1:
        p = root ; n2 = 1 ; found = True
    elif n &gt;= len(lines):
        p = root ; found = False
        n2 = p.bodyString().count('\n')
    elif root.isAtAsisFileNode():
        &lt;&lt; count outline lines, setting p,n2,found &gt;&gt;
    else:
        vnodeName,childIndex,gnx,n2,delim = self.convertLineToVnodeNameIndexLine(lines,n,root)
        found = True
        if not vnodeName:
            g.es("error handling: " + root.headString())
            return
        &lt;&lt; set p to the node given by vnodeName and gnx or childIndex or n &gt;&gt;
    &lt;&lt; select p and make it visible &gt;&gt;
    &lt;&lt; put the cursor on line n2 of the body text &gt;&gt;</t>
<t tx="ekr.20031218072017.2865">fileName = None
for p in p.self_and_parents_iter():
    fileName = p.anyAtFileNodeName()
    if fileName: break

# New in 4.2: Search the entire tree for joined nodes.
if not fileName:
    p1 = c.currentPosition()
    for p in c.all_positions_iter():
        if p.v.t == p1.v.t and p != p1:
            # Found a joined position.
            for p in p.self_and_parents_iter():
                fileName = p.anyAtFileNodeName()
                # New in 4.2 b3: ignore @all nodes.
                if fileName and not p.isAtAllNode(): break
        if fileName: break
    
if fileName:
    root = p.copy()
else:
    g.es("Go to line number: ancestor must be @file node", color="blue")
    return</t>
<t tx="ekr.20031218072017.2866"># 1/26/03: calculate the full path.
d = g.scanDirectives(c)
path = d.get("path")

fileName = g.os_path_join(path,fileName)

try:
    file=open(fileName)
    lines = file.readlines()
    file.close()
except:
    g.es("not found: " + fileName)
    return</t>
<t tx="ekr.20031218072017.2867">n = g.app.gui.runAskOkCancelNumberDialog("Enter Line Number","Line number:")
if n == -1:
    return</t>
<t tx="ekr.20031218072017.2868">p = lastv = root
prev = 0 ; found = False

for p in p.self_and_subtree_iter():
    lastv = p.copy()
    s = p.bodyString()
    lines = s.count('\n')
    if len(s) &gt; 0 and s[-1] != '\n':
        lines += 1
    # print lines,prev,p
    if prev + lines &gt;= n:
        found = True ; break
    prev += lines

p = lastv
n2 = max(1,n-prev)</t>
<t tx="ekr.20031218072017.2869">if gnx:
    &lt;&lt; 4.2: get node from gnx &gt;&gt;
elif childIndex == -1:
    &lt;&lt; 4.x: scan for the node using tnodeList and n &gt;&gt;
else:
    &lt;&lt; 3.x: scan for the node with the given childIndex &gt;&gt;</t>
<t tx="ekr.20031218072017.2870"># This is about the best that can be done without replicating the entire atFile write logic.

ok = True

if not hasattr(root.v.t,"tnodeList"):
    s = "no child index for " + root.headString()
    print s ; g.es(s, color="red")
    ok = False

if ok:
    tnodeList = root.v.t.tnodeList
    &lt;&lt; set tnodeIndex to the number of +node sentinels before line n &gt;&gt;
    tnodeIndex = max(0,tnodeIndex)
    &lt;&lt; set p to the first vnode whose tnode is tnodeList[tnodeIndex] or set ok = False &gt;&gt;
            
if not ok:
    # Fall back to the old logic.
    &lt;&lt; set p to the first node whose headline matches vnodeName &gt;&gt;</t>
<t tx="ekr.20031218072017.2871">tnodeIndex = -1 # Don't count the @file node.
scanned = 0 # count of lines scanned.

for s in lines:
    if scanned &gt;= n:
        break
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        i += len(delim)
        if g.match(s,i,"+node"):
            # g.trace(tnodeIndex,s.rstrip())
            tnodeIndex += 1
    scanned += 1</t>
<t tx="ekr.20031218072017.2872">@ We use the tnodeList to find a _tnode_ corresponding to the proper node, so the user will for sure be editing the proper text, even if several nodes happen to have the same headline.  This is really all that we need.

However, this code has no good way of distinguishing between different cloned vnodes in the file: they all have the same tnode.  So this code just picks p = t.vnodeList[0] and leaves it at that.

The only way to do better is to scan the outline, replicating the write logic to determine which vnode created the given line.  That's way too difficult, and it would create an unwanted dependency in this code.
@c

# g.trace("tnodeIndex",tnodeIndex)
if tnodeIndex &lt; len(tnodeList):
    t = tnodeList[tnodeIndex]
    # Find the first vnode whose tnode is t.
    found = False
    for p in root.self_and_subtree_iter():
        if p.v.t == t:
            found = True ; break
    if not found:
        s = "tnode not found for " + vnodeName
        print s ; g.es(s, color="red") ; ok = False
    elif p.headString().strip() != vnodeName:
        if 0: # Apparently this error doesn't prevent a later scan for working properly.
            s = "Mismatched vnodeName\nExpecting: %s\n got: %s" % (p.headString(),vnodeName)
            print s ; g.es(s, color="red")
        ok = False
else:
    if root1 is None: # Kludge: disable this message when called by goToScriptLineNumber.
        s = "Invalid computed tnodeIndex: %d" % tnodeIndex
        print s ; g.es(s, color = "red")
    ok = False</t>
<t tx="ekr.20031218072017.2873">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        found = True ; break

if not found:
    s = "not found: " + vnodeName
    print s ; g.es(s, color="red")
    return</t>
<t tx="ekr.20031218072017.2874">found = False
for p in root.self_and_subtree_iter():
    if p.matchHeadline(vnodeName):
        if childIndex &lt;= 0 or p.childIndex() + 1 == childIndex:
            found = True ; break

if not found:
    g.es("not found: " + vnodeName, color="red")
    return</t>
<t tx="ekr.20031218072017.2875">c.beginUpdate()
c.frame.tree.expandAllAncestors(p)
c.selectVnode(p)
c.endUpdate()</t>
<t tx="ekr.20031218072017.2876">if found:
    c.frame.body.setInsertPointToStartOfLine(n2-1)
else:
    c.frame.body.setInsertionPointToEnd()
    g.es("%d lines" % len(lines), color="blue")

c.frame.body.makeInsertPointVisible()</t>
<t tx="ekr.20031218072017.2877">@ We count "real" lines in the derived files, ignoring all sentinels that do not arise from source lines.  When the indicated line is found, we scan backwards for an @+body line, get the vnode's name from that line and set p to the indicated vnode.  This will fail if vnode names have been changed, and that can't be helped.

Returns (vnodeName,offset)

vnodeName: the name found in the previous @+body sentinel.
offset: the offset within p of the desired line.
@c

def convertLineToVnodeNameIndexLine (self,lines,n,root):
    
    """Convert a line number n to a vnode name, (child index or gnx) and line number."""
    
    c = self ; at = c.atFileCommands
    childIndex = 0 ; gnx = None ; newDerivedFile = False
    thinFile = root.isAtThinFileNode()
    &lt;&lt; set delim, leoLine from the @+leo line &gt;&gt;
    if not delim:
        g.es("bad @+leo sentinel")
        return None,None,None,None,None
    &lt;&lt; scan back to @+node, setting offset,nodeSentinelLine &gt;&gt;
    if nodeSentinelLine == -1:
        # The line precedes the first @+node sentinel
        # g.trace("before first line")
        return root.headString(),0,gnx,1,delim # 10/13/03
    s = lines[nodeSentinelLine]
    # g.trace(s)
    &lt;&lt; set vnodeName and (childIndex or gnx) from s &gt;&gt;
    # g.trace("childIndex,offset",childIndex,offset,vnodeName)
    return vnodeName,childIndex,gnx,offset,delim
</t>
<t tx="ekr.20031218072017.2878"># Find the @+leo line.
tag = "@+leo"
i = 0 
while i &lt; len(lines) and lines[i].find(tag)==-1:
    i += 1
leoLine = i # Index of the line containing the leo sentinel

if leoLine &lt; len(lines):
    s = lines[leoLine]
    valid,newDerivedFile,start,end = at.parseLeoSentinel(s)
    if valid: delim = start + '@'
    else:     delim = None
else:
    delim = None
</t>
<t tx="ekr.20031218072017.2879">offset = 0 # This is essentially the Tk line number.
nodeSentinelLine = -1
line = n - 1
while line &gt;= 0:
    s = lines[line]
    # g.trace(s)
    i = g.skip_ws(s,0)
    if g.match(s,i,delim):
        &lt;&lt; handle delim while scanning backward &gt;&gt;
    else:
        offset += 1 # Assume the line is real.  A dubious assumption.
    line -= 1</t>
<t tx="ekr.20031218072017.2880">if line == n:
    g.es("line "+str(n)+" is a sentinel line")
i += len(delim)

if g.match(s,i,"-node"):
    # The end of a nested section.
    line = self.skipToMatchingNodeSentinel(lines,line,delim)
elif g.match(s,i,"+node"):
    nodeSentinelLine = line
    break
elif g.match(s,i,"&lt;&lt;") or g.match(s,i,"@first"):
    offset += 1 # Count these as a "real" lines.</t>
<t tx="ekr.20031218072017.2881">if newDerivedFile:
    i = 0
    if thinFile:
        # gnx is lies between the first and second ':':
        i = s.find(':',i)
        if i &gt; 0:
            i += 1
            j = s.find(':',i)
            if j &gt; 0:
                gnx = s[i:j]
            else: i = len(s)
        else: i = len(s)
    # vnode name is everything following the first or second':'
    # childIndex is -1 as a flag for later code.
    i = s.find(':',i)
    if i &gt; -1: vnodeName = s[i+1:].strip()
    else: vnodeName = None
    childIndex = -1
else:
    # vnode name is everything following the third ':'
    i = 0 ; colons = 0
    while i &lt; len(s) and colons &lt; 3:
        if s[i] == ':':
            colons += 1
            if colons == 1 and i+1 &lt; len(s) and s[i+1] in string.digits:
                junk,childIndex = g.skip_long(s,i+1)
        i += 1
    vnodeName = s[i:].strip()
    
# g.trace("gnx",gnx,"vnodeName:",vnodeName)
if not vnodeName:
    vnodeName = None
    g.es("bad @+node sentinel")</t>
<t tx="ekr.20031218072017.2882">def skipToMatchingNodeSentinel (self,lines,n,delim):
    
    s = lines[n]
    i = g.skip_ws(s,0)
    assert(g.match(s,i,delim))
    i += len(delim)
    if g.match(s,i,"+node"):
        start="+node" ; end="-node" ; delta=1
    else:
        assert(g.match(s,i,"-node"))
        start="-node" ; end="+node" ; delta=-1
    # Scan to matching @+-node delim.
    n += delta ; level = 0
    while 0 &lt;= n &lt; len(lines):
        s = lines[n] ; i = g.skip_ws(s,0)
        if g.match(s,i,delim):
            i += len(delim)
            if g.match(s,i,start):
                level += 1
            elif g.match(s,i,end):
                if level == 0: break
                else: level -= 1
        n += delta
        
    # g.trace(n)
    return n</t>
<t tx="ekr.20031218072017.3023"># For compatibility with old file formats.

def getCloneWindows (self):

    if not self.matchTag("&lt;clone_windows&gt;"):
        return # &lt;clone_windows/&gt; seen.

    while self.matchTag("&lt;clone_window vtag=\"V"):
        self.getLong() ; self.getDquote() ; self.getTag("&gt;")
        if not self.getOpenTag("&lt;global_window_position"):
            self.getTag("&lt;global_window_position")
            self.getPosition()
            self.getTag("/&gt;")
        self.getTag("&lt;/clone_window&gt;")
    self.getTag("&lt;/clone_windows&gt;")</t>
<t tx="ekr.20031218072017.3046">def write_Leo_file(self,fileName,outlineOnlyFlag):

    c = self.c ; config = g.app.config

    self.assignFileIndices()
    if not outlineOnlyFlag:
        &lt;&lt; write all @file nodes &gt;&gt;
    &lt;&lt; return if the .leo file is read-only &gt;&gt;
    try:
        &lt;&lt; create backup file &gt;&gt;
        self.mFileName = fileName
        &lt;&lt; create the output file &gt;&gt;
        &lt;&lt; update leoConfig.txt &gt;&gt;
        &lt;&lt; put the .leo file &gt;&gt;
    except:
        &lt;&lt; report the exception &gt;&gt;
        &lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
        return False
    if self.outputFile:
        &lt;&lt; close the output file &gt;&gt;
        &lt;&lt; delete backup file &gt;&gt;
        return True
    else: # This probably will never happen because errors should raise exceptions.
        &lt;&lt; erase filename and rename backupName to fileName &gt;&gt;
        return False
        
write_LEO_file = write_Leo_file # For compatibility with old plugins.</t>
<t tx="ekr.20031218072017.3047"># rename fileName to fileName.bak if fileName exists.
if g.os_path_exists(fileName):
    try:
        backupName = g.os_path_join(g.app.loadDir,fileName)
        backupName = fileName + ".bak"
        if g.os_path_exists(backupName):
            os.unlink(backupName)
        # os.rename(fileName,backupName)
        g.utils_rename(fileName,backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception creating backup file: " + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception creating backup file: " + backupName)
        g.es_exception()
        backupName = None
        return False
else:
    backupName = None</t>
<t tx="ekr.20031218072017.3048">if backupName and g.os_path_exists(backupName):
    try:
        os.unlink(backupName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting backup file:" + backupName)
            g.es_exception()
        return False
    except:
        g.es("exception deleting backup file:" + backupName)
        g.es_exception()
        return False
</t>
<t tx="ekr.20031218072017.3049">g.es("error writing " + fileName)

if fileName and g.os_path_exists(fileName):
    try:
        os.unlink(fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception deleting: " + fileName)
            g.es_exception()
    except:
        g.es("exception deleting: " + fileName)
        g.es_exception()
        
if backupName:
    g.es("restoring " + fileName + " from " + backupName)
    try:
        g.utils_rename(backupName, fileName)
    except OSError:
        if self.read_only:
            g.es("read only",color="red")
        else:
            g.es("exception renaming " + backupName + " to " + fileName)
            g.es_exception()
    except:
        g.es("exception renaming " + backupName + " to " + fileName)
        g.es_exception()</t>
<t tx="ekr.20031218072017.3075"># Resumes the search where it left off.
# The caller must call set_first_incremental_search or set_first_batch_search.

def findNextMatch(self):

    c = self.c

    if not c.search_headline_flag and not c.search_body_flag:
        return None, None

    if len(c.find_text) == 0:
        return None, None

    v = self.v
    while v:
        pos, newpos = self.search()
        if pos:
            if c.mark_finds_flag:
                v.setMarked()
                c.frame.tree.drawIcon(v) # redraw only the icon.
            return pos, newpos
        elif self.errors:
            return None,None # Abort the search.
        elif c.node_only_flag:
            return None,None # We are only searching one node.
        else:
            v = self.v = self.selectNextVnode()
    return None, None</t>
<t tx="ekr.20031218072017.3081"># Selects the next node to be searched.

def selectNextVnode(self):

    c = self.c ; v = self.v

    if c.selection_only_flag:
        return None

    # Start suboutline only searches.
    if c.suboutline_only_flag and not self.onlyVnode:
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.onlyVnode = v 

    # Start wrapped searches.
    if self.wrapping and not self.wrapVnode:
        assert(self.wrapPos != None)
        # v.copy not needed because the find code never calls p.moveToX.
        # Furthermore, v might be None, so v.copy() would be wrong!
        self.wrapVnode = v 

    if self.in_headline and c.search_body_flag:
        # just switch to body pane.
        self.in_headline = False
        self.initNextText()
        # g.trace(v)
        return v

    if c.reverse_flag: v = v.threadBack()
    else:              v = v.threadNext()

    # Wrap if needed.
    if not v and self.wrapping and not c.suboutline_only_flag:
        v = c.rootVnode()
        if c.reverse_flag:
            # Set search_v to the last node of the tree.
            while v and v.next():
                v = v.next()
            if v: v = v.lastNode()

    # End wrapped searches.
    if self.wrapping and v and v == self.wrapVnode:
        # g.trace("ending wrapped search")
        v = None ; self.resetWrap()

    # End suboutline only searches.
    if (c.suboutline_only_flag and self.onlyVnode and v and
        (v == self.onlyVnode or not self.onlyVnode.isAncestorOf(v))):
        # g.trace("end outline-only")
        v = None ; self.onlyVnode = None

    # v.copy not needed because the find code never calls p.moveToX.
    # Furthermore, v might be None, so v.copy() would be wrong!
    self.v = v # used in initNextText().
    if v: # select v and set the search point within v.
        self.in_headline = c.search_headline_flag
        self.initNextText()
    return v</t>
<t tx="ekr.20031218072017.3097">@
g.CheckVersion() is a generic version checker.  Assumes a
version string of up to four parts, or tokens, with
leftmost token being most significant and each token
becoming less signficant in sequence to the right.

RETURN VALUE

1 if comparison is True
0 if comparison is False

PARAMETERS

version: the version string to be tested
againstVersion: the reference version string to be
              compared against
condition: can be any of "==", "!=", "&gt;=", "&lt;=", "&gt;", or "&lt;"
stringCompare: whether to test a token using only the
             leading integer of the token, or using the
             entire token string.  For example, a value
             of "0.0.1.0" means that we use the integer
             value of the first, second, and fourth
             tokens, but we use a string compare for the
             third version token.
delimiter: the character that separates the tokens in the
         version strings.

The comparison uses the precision of the version string
with the least number of tokens.  For example a test of
"8.4" against "8.3.3" would just compare the first two
tokens.

The version strings are limited to a maximum of 4 tokens.
@c

def CheckVersion( version, againstVersion, condition="&gt;=", stringCompare="0.0.0.0", delimiter='.' ):
    import sre  # Unicode-aware regular expressions
    #
    # tokenize the stringCompare flags
    compareFlag = string.split( stringCompare, '.' )
    #
    # tokenize the version strings
    testVersion = string.split( version, delimiter )
    testAgainst = string.split( againstVersion, delimiter )
    #
    # find the 'precision' of the comparison
    tokenCount = 4
    if tokenCount &gt; len(testAgainst):
        tokenCount = len(testAgainst)
    if tokenCount &gt; len(testVersion):
        tokenCount = len(testVersion)
    #
    # Apply the stringCompare flags
    justInteger = sre.compile("^[0-9]+")
    for i in range(tokenCount):
        if "0" == compareFlag[i]:
            m = justInteger.match( testVersion[i] )
            testVersion[i] = m.group()
            m = justInteger.match( testAgainst[i] )
            testAgainst[i] = m.group()
        elif "1" != compareFlag[i]:
            errMsg = "stringCompare argument must be of " +\
                 "the form \"x.x.x.x\" where each " +\
                 "'x' is either '0' or '1'."
            raise EnvironmentError,errMsg
    #
    # Compare the versions
    if condition == "&gt;=":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 1 # it was equal
    if condition == "&gt;":
        for i in range(tokenCount):
            if testVersion[i] &lt; testAgainst[i]:
                return 0
            if testVersion[i] &gt; testAgainst[i]:
                return 1 # it was greater than
        return 0 # it was equal
    if condition == "==":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 0 # any token was not equal
        return 1 # every token was equal
    if condition == "!=":
        for i in range(tokenCount):
            if testVersion[i] != testAgainst[i]:
                return 1 # any token was not equal
        return 0 # every token was equal
    if condition == "&lt;":
        for i in range(tokenCount):
            if testVersion[i] &gt;= testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 0 # it was equal
    if condition == "&lt;=":
        for i in range(tokenCount):
            if testVersion[i] &gt; testAgainst[i]:
                return 0
            if testVersion[i] &lt; testAgainst[i]:
                return 1 # it was less than
        return 1 # it was equal
    #
    # didn't find a condition that we expected.
    raise EnvironmentError,"condition must be one of '&gt;=', '&gt;', '==', '!=', '&lt;', or '&lt;='."</t>
<t tx="ekr.20031218072017.3112">def es_exception (full=True,c=None,color="red"):
    
    typ,val,tb = sys.exc_info()

    if full:
        lines = traceback.format_exception(typ,val,tb)
    else:
        lines = traceback.format_exception_only(typ,val)
        
    if 1:
        n = g.getLastTracebackLineNumber()
    else:
        # old, kludgy code...
        &lt;&lt; look for lines containing a specific message &gt;&gt;

    for line in lines:
        g.es_error(line,color=color)
        if not g.stdErrIsRedirected():
            print line

    return n</t>
<t tx="ekr.20031218072017.3152">def scanAtFileOptions (h,err_flag=False):
    
    assert(g.match(h,0,"@file"))
    i = len("@file")
    atFileType = "@file"
    optionsList = []

    while g.match(h,i,'-'):
        &lt;&lt; scan another @file option &gt;&gt;
        
    # Convert atFileType to a list of options.
    for fileType,option in (
        ("@silentfile","asis"),
        ("@nosentinelsfile","nosent"),
        ("@rawfile","noref"),
        ("@thinfile","thin")
    ):
        if atFileType == fileType and option not in optionsList:
            optionsList.append(option)
            
    # g.trace(atFileType,optionsList)

    return i,atFileType,optionsList</t>
<t tx="ekr.20031218072017.3153">i += 1 ; err = -1

if g.match_word(h,i,"asis"):
    if atFileType == "@file":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("using -asis option in:" + h)
elif g.match(h,i,"noref"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@rawfile"
    elif atFileType == "@nosentinelsfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -noref in:" + h)
elif g.match(h,i,"nosent"): # Just match the prefix.
    if atFileType == "@file":
        atFileType = "@nosentinelsfile"
    elif atFileType == "@rawfile":
        atFileType = "@silentfile"
    elif err_flag:
        g.es("ignoring redundant -nosent in:" + h)
elif g.match_word(h,i,"thin"):
    if atFileType == "@file":
        atFileType = "@thinfile"
    elif err_flag:
        g.es("using -thin option in:" + h)
else:
    if 0: # doesn't work
        for option in ("fat","new","now","old","thin","wait"):
            if g.match_word(h,i,option):
                optionsList.append(option)
        if len(option) == 0:
            err = i-1
# Scan to the next minus sign.
while i &lt; len(h) and h[i] not in (' ','\t','-'):
    i += 1
if err &gt; -1:
    g.es("unknown option:" + h[err:i] + " in " + h)</t>
<t tx="ekr.20031218072017.3210">def createOutline (self,fileName,parent):

    c = self.c ; current = c.currentVnode()
    junk,self.fileName = g.os_path_split(fileName)
    self.methodName,ext = g.os_path_splitext(self.fileName)
    self.fileType = ext
    self.setEncoding()
    # g.trace(self.fileName,self.fileType)
    # All file types except the following just get copied to the parent node.
    ext = ext.lower()
    appendFileFlag = ext not in (
        ".c", ".cpp", ".cxx", ".el", ".java", ".pas", ".py", ".pyw", ".php")
    &lt;&lt; Read file into s &gt;&gt;
    # Create the top-level headline.
    v = parent.insertAsLastChild()
    c.undoer.setUndoParams("Import",v,select=current)
    if self.treeType == "@file":
        v.initHeadString("@file " + fileName)
    else:
        v.initHeadString(fileName)
        
    self.rootLine = g.choose(self.treeType=="@file","","@root-code "+self.fileName+'\n')

    if appendFileFlag:
        body = "@ignore\n"
        if ext in (".html",".htm"): body += "@language html\n"
        if ext in (".txt",".text"): body += "@nocolor\n"
        v.setBodyStringOrPane(body + self.rootLine + s)
    elif ext in (".c", ".cpp", ".cxx"):
        self.scanCText(s,v)
    elif ext == ".el":
        self.scanElispText(s,v)
    elif ext == ".java":
        self.scanJavaText(s,v,True) #outer level
    elif ext == ".pas":
        self.scanPascalText(s,v)
    elif ext in (".py", ".pyw"):
        self.scanPythonText(s,v)
    elif ext == ".php":
        self.scanPHPText(s,v) # 08-SEP-2002 DTHEIN
    else:
        g.es("createOutline: can't happen")
    return v</t>
<t tx="ekr.20031218072017.3211">try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("can not open " + fileName)
    leoTest.fail()
    return None</t>
<t tx="ekr.20031218072017.3212">def importFilesCommand (self,files,treeType,
    perfectImport=True,testing=False,verbose=False):

    c = self.c
    if c == None: return
    v = current = c.currentVnode()
    if current == None: return
    if len(files) &lt; 1: return
    self.treeType = treeType
    c.beginUpdate()
    if 1: # range of update...
        if len(files) == 2:
            &lt;&lt; Create a parent for two files having a common prefix &gt;&gt;
        for fileName in files:
            v = self.createOutline(fileName,current)
            if v: # createOutline may fail.
                if perfectImport and treeType == "@file": # Can't correct @root trees.
                    self.perfectImport(fileName,v,testing=testing,verbose=verbose,verify=False)
                else:
                    g.es("imported " + fileName,color="blue")
                v.contract()
                v.setDirty()
                c.setChanged(True)
        c.validateOutline()
        current.expand()
    c.endUpdate()
    c.selectVnode(current)</t>
<t tx="ekr.20031218072017.3213">@ The two filenames have a common prefix everything before the last period is the same.  For example, x.h and x.cpp.
@c

name0 = files[0]
name1 = files[1]
prefix0, junk = g.os_path_splitext(name0)
prefix1, junk = g.os_path_splitext(name1)
if len(prefix0) &gt; 0 and prefix0 == prefix1:
    current = current.insertAsLastChild()
    junk, nameExt = g.os_path_split(prefix1)
    name,ext = g.os_path_splitext(prefix1)
    current.initHeadString(name)</t>
<t tx="ekr.20031218072017.3226">def importWebCommand (self,files,webType):

    c = self.c ; current = c.currentVnode()
    if current == None: return
    if not files: return
    self.webType = webType

    c.beginUpdate()
    for fileName in files:
        v = self.createOutlineFromWeb(fileName,current)
        v.contract()
        v.setDirty()
        c.setChanged(True)
    c.selectVnode(current)
    c.endUpdate()</t>
<t tx="ekr.20031218072017.3300">def removeSentinelsCommand (self,paths):

    self.setEncoding()

    for fileName in paths:
        path, self.fileName = g.os_path_split(fileName) # path/fileName
        &lt;&lt; Read file into s &gt;&gt;
        &lt;&lt; set delims from the header line &gt;&gt;
        # g.trace("line: '%s', start: '%s', end: '%s'" % (line_delim,start_delim,end_delim))
        s = self.removeSentinelLines(s,line_delim,start_delim,end_delim)
        ext = g.app.config.remove_sentinels_extension
        if ext == None or len(ext) == 0:
            ext = ".txt"
        if ext[0] == '.':
            newFileName = g.os_path_join(path,fileName+ext)
        else:
            head,ext2 = g.os_path_splitext(fileName) 
            newFileName = g.os_path_join(path,head+ext+ext2)
        # g.trace(repr(s))
        &lt;&lt; Write s into newFileName &gt;&gt;</t>
<t tx="ekr.20031218072017.3301">try:
    file = open(fileName)
    s = file.read()
    s = g.toUnicode(s,self.encoding)
    file.close()
except IOError:
    g.es("Can not open " + fileName, color="blue")
    leoTest.fail()
    return</t>
<t tx="ekr.20031218072017.3302"># Skip any non @+leo lines.
i = 0
while i &lt; len(s) and not g.find_on_line(s,i,"@+leo"):
    i = g.skip_line(s,i)

# Get the comment delims from the @+leo sentinel line.
at = self.c.atFileCommands
j = g.skip_line(s,i) ; line = s[i:j]

valid,new_df,start_delim,end_delim = at.parseLeoSentinel(line)
if not valid:
    g.es("invalid @+leo sentinel in " + fileName)
    return

if end_delim:
    line_delim = None
else:
    line_delim,start_delim = start_delim,None</t>
<t tx="ekr.20031218072017.3346"></t>
<t tx="ekr.20031218072017.3348"># These return the filename following @xxx, in v.headString.
# Return the the empty string if v is not an @xxx node.

def atFileNodeName (self):
    names = ("@file"),
    return self.findAtFileName(names)

def atNoSentinelsFileNodeName (self):
    names = ("@nosent", "@file-nosent", "@nosentinelsfile")
    return self.findAtFileName(names)

def atRawFileNodeName (self):
    names = ("@noref", "@file-noref", "@rawfile")
    return self.findAtFileName(names)
    
def atSilentFileNodeName (self):
    names = ("@asis", "@file-asis", "@silentfile")
    return self.findAtFileName(names)
    
def atThinFileNodeName (self):
    names = ("@thin", "@file-thin", "@thinfile")
    return self.findAtFileName(names)
    
# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName     = atSilentFileNodeName</t>
<t tx="ekr.20031218072017.3350">def anyAtFileNodeName (self):
    
    """Return the file name following an @file node or an empty string."""

    names = (
        "@file",
        "@thin",   "@file-thin",   "@thinfile",
        "@asis",   "@file-asis",   "@silentfile",
        "@noref",  "@file-noref",  "@rawfile",
        "@nosent", "@file-nosent", "@nosentinelsfile")

    return self.findAtFileName(names)</t>
<t tx="ekr.20031218072017.3351">def isAtIgnoreNode (self):

    """Returns True if the receiver contains @ignore in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString, 0, "@ignore")
    return flag</t>
<t tx="ekr.20031218072017.3352">def isAtOthersNode (self):

    """Returns True if the receiver contains @others in its body at the start of a line."""

    flag, i = g.is_special(self.t.bodyString,0,"@others")
    return flag</t>
<t tx="ekr.20031218072017.3353">def matchHeadline (self,pattern):

    """Returns True if the headline matches the pattern ignoring whitespace and case.
    
    The headline may contain characters following the successfully matched pattern."""

    h = string.lower(self.headString())
    h = string.replace(h,' ','')
    h = string.replace(h,'\t','')

    s = string.lower(pattern)
    s = string.replace(s,' ','')
    s = string.replace(s,'\t','')

    # ignore characters in the headline following the match
    return s == h[0:len(s)]</t>
<t tx="ekr.20031218072017.3398">def setMarked (self):

    self.statusBits |= self.markedBit

def initMarkedBit (self):

    self.statusBits |= self.markedBit
</t>
<t tx="ekr.20031218072017.3625"></t>
<t tx="ekr.20031218072017.3692">def promptForSave (self):
    
    """Prompt the user to save changes.
    
    Return True if the user vetos the quit or save operation."""
    
    c = self.c
    name = g.choose(c.mFileName,c.mFileName,self.title)
    type = g.choose(g.app.quitting, "quitting?", "closing?")

    answer = g.app.gui.runAskYesNoCancelDialog(
        "Confirm",
        'Save changes to %s before %s' % (name,type))
        
    # print answer	
    if answer == "cancel":
        return True # Veto.
    elif answer == "no":
        return False # Don't save and don't veto.
    else:
        if not c.mFileName:
            &lt;&lt; Put up a file save dialog to set mFileName &gt;&gt;
        if c.mFileName:
            ok = c.fileCommands.save(c.mFileName)
            return not ok # New in 4.2: Veto if the save did not succeed.
        else:
            return True # Veto.</t>
<t tx="ekr.20031218072017.3693"># Make sure we never pass None to the ctor.
if not c.mFileName:
    c.mFileName = ""

c.mFileName = g.app.gui.runSaveFileDialog(
    initialfile = c.mFileName,
    title="Save",
    filetypes=[("Leo files", "*.leo")],
    defaultextension=".leo")</t>
<t tx="ekr.20031218072017.3752">def defineMenuTables (self):
    
    c = self.c ; f = self.frame
    
    &lt;&lt; define edit menu tables &gt;&gt;
    &lt;&lt; define file menu tables &gt;&gt;
    &lt;&lt; define outline menu tables &gt;&gt;
    &lt;&lt; define window menu tables &gt;&gt;
    &lt;&lt; define help menu tables &gt;&gt;</t>
<t tx="ekr.20031218072017.3753">&lt;&lt; define editMenuTopTable &gt;&gt;
&lt;&lt; define editMenuEditBodyTable &gt;&gt;
&lt;&lt; define editMenuEditHeadlineTable &gt;&gt;
&lt;&lt; define editMenuFindMenuTable &gt;&gt;
&lt;&lt; define editMenuTop2Table &gt;&gt;</t>
<t tx="ekr.20031218072017.3754">self.editMenuEditBodyTable = (
    ("Extract &amp;Section","Shift+Ctrl+E",c.extractSection),
    ("Extract &amp;Names","Shift+Ctrl+N",c.extractSectionNames),
    ("&amp;Extract","Shift+Ctrl+D",c.extract),
    ("-",None,None),
    ("Convert All B&amp;lanks",None,c.convertAllBlanks),
    ("Convert All T&amp;abs",None,c.convertAllTabs),
    ("Convert &amp;Blanks","Shift+Ctrl+B",c.convertBlanks),
    ("Convert &amp;Tabs","Shift+Ctrl+J",c.convertTabs),
    ("Insert Body Time/&amp;Date","Shift+Ctrl+G",c.insertBodyTime),
    ("&amp;Reformat Paragraph","Shift+Ctrl+P",c.reformatParagraph),
    ("-",None,None),
    ("&amp;Indent","Ctrl+]",c.indentBody),
    ("&amp;Unindent","Ctrl+[",c.dedentBody),
    ("&amp;Match Brackets","Ctrl+K",c.findMatchingBracket))</t>
<t tx="ekr.20031218072017.3755">self.editMenuEditHeadlineTable = (
    ("Edit &amp;Headline","Ctrl+H",c.editHeadline),
    ("&amp;End Edit Headline","Escape",f.endEditLabelCommand),
    ("&amp;Abort Edit Headline","Shift-Escape",f.abortEditLabelCommand),
    ("Insert Headline Time/&amp;Date","Shift+Ctrl+H",f.insertHeadlineTime),
    # 2/16/04: restore Toggle Angle Brackets command without any default shortcut.
    ("Toggle Angle Brackets",None,c.toggleAngleBrackets))</t>
<t tx="ekr.20031218072017.3756">self.editMenuFindMenuTable = (
    ("&amp;Find Panel","Ctrl+F",c.findPanel),
    ("-",None,None),
    ("Find &amp;Next","F3",c.findNext),
    ("Find &amp;Previous","F4",c.findPrevious),
    ("&amp;Replace","Ctrl+=",c.replace),
    ("Replace, &amp;Then Find","Ctrl+-",c.replaceThenFind))</t>
<t tx="ekr.20031218072017.3757">try:
    show = c.frame.body.getColorizer().showInvisibles
except:
    show = False

label = g.choose(show,"Hide In&amp;visibles","Show In&amp;visibles")
    
self.editMenuTop2Table = (
    ("&amp;Go To Line Number","Alt+G",c.goToLineNumber),
    ("&amp;Execute Script","Alt+Shift+E",c.executeScript),
    ("Set Fon&amp;t...","Shift+Alt+T",c.fontPanel),
    ("Set &amp;Colors...","Shift+Alt+C",c.colorPanel),
    (label,"Alt+V",c.viewAllCharacters),
    ("-",None,None),
    ("Prefere&amp;nces","Ctrl+Y",c.preferences))</t>
<t tx="ekr.20031218072017.3758">&lt;&lt; define fileMenuTopTable &gt;&gt;
&lt;&lt; define fileMenuTop2Table &gt;&gt;
&lt;&lt; define fileMenuReadWriteMenuTable &gt;&gt;
&lt;&lt; define fileMenuTangleMenuTable &gt;&gt;
&lt;&lt; define fileMenuUntangleMenuTable &gt;&gt;
&lt;&lt; define fileMenuImportMenuTable &gt;&gt;
&lt;&lt; define fileMenuExportMenuTable &gt;&gt;
&lt;&lt; define fileMenuTop3MenuTable &gt;&gt;</t>
<t tx="ekr.20031218072017.3759">self.fileMenuTopTable = (
    ("&amp;New","Ctrl+N",c.new),
    ("&amp;Open...","Ctrl+O",c.open))</t>
<t tx="ekr.20031218072017.3760">self.fileMenuTop2Table = (
    ("-",None,None),
    ("&amp;Close","Ctrl+W",c.close),
    ("&amp;Save","Ctrl+S",c.save),
    ("Save &amp;As","Shift+Ctrl+S",c.saveAs),
    ("Save To",None,c.saveTo), # &amp;Tangle
    ("Re&amp;vert To Saved",None,c.revert)) # &amp;Read/Write</t>
<t tx="ekr.20031218072017.3761">self.fileMenuReadWriteMenuTable = (
    ("&amp;Read Outline Only","Shift+Ctrl+R",c.readOutlineOnly),
    ("Read @file &amp;Nodes",None,c.readAtFileNodes),
    ("-",None,None),
    ("Write &amp;Dirty @file Nodes","Shift+Ctrl+Q",c.fileCommands.writeDirtyAtFileNodes),
    ("Write &amp;Missing @file Nodes",None,c.fileCommands.writeMissingAtFileNodes),
    ("Write &amp;Outline Only",None,c.fileCommands.writeOutlineOnly),
    ("&amp;Write @file Nodes","Shift+Ctrl+W",c.fileCommands.writeAtFileNodes),
    ("-",None,None),
    ("Write 4.x Derived Files",None,c.writeNewDerivedFiles),
    ("Write 3.x Derived Files",None,c.writeOldDerivedFiles))</t>
<t tx="ekr.20031218072017.3762">self.fileMenuTangleMenuTable = (
    ("Tangle &amp;All","Shift+Ctrl+A",c.tangleAll),
    ("Tangle &amp;Marked","Shift+Ctrl+M",c.tangleMarked),
    ("&amp;Tangle","Shift+Ctrl+T",c.tangle))</t>
<t tx="ekr.20031218072017.3763">self.fileMenuUntangleMenuTable = (
    ("Untangle &amp;All",None,c.untangleAll),
    ("Untangle &amp;Marked",None,c.untangleMarked),
    ("&amp;Untangle","Shift+Ctrl+U",c.untangle))</t>
<t tx="ekr.20031218072017.3764">self.fileMenuImportMenuTable = (
    ("Import Derived File",None,c.importDerivedFile),
    ("Import To @&amp;file","Shift+Ctrl+F",c.importAtFile),
    ("Import To @&amp;root",None,c.importAtRoot),
    ("Import &amp;CWEB Files",None,c.importCWEBFiles),
    
    ("Import &amp;noweb Files",None,c.importNowebFiles),
    ("Import Flattened &amp;Outline",None,c.importFlattenedOutline))</t>
<t tx="ekr.20031218072017.3765">self.fileMenuExportMenuTable = [
    ("Export &amp;Headlines",None,c.exportHeadlines),
    ("Outline To &amp;CWEB",None,c.outlineToCWEB),
    ("Outline To &amp;Noweb",None,c.outlineToNoweb),
    ("&amp;Flatten Outline",None,c.flattenOutline),
    ("&amp;Remove Sentinels",None,c.removeSentinels),
    ("&amp;Weave",None,c.weave)]</t>
<t tx="ekr.20031218072017.3766">self.fileMenuTop3MenuTable = (
    ("E&amp;xit","Ctrl-Q",g.app.onQuit),)</t>
<t tx="ekr.20031218072017.3767">&lt;&lt; define outlineMenuTopMenuTable &gt;&gt;
&lt;&lt; define outlineMenuCheckOutlineMenuTable &gt;&gt;
&lt;&lt; define outlineMenuExpandContractMenuTable &gt;&gt;
&lt;&lt; define outlineMenuMoveMenuTable &gt;&gt;
&lt;&lt; define outlineMenuMarkMenuTable &gt;&gt;
&lt;&lt; define outlineMenuGoToMenuTable &gt;&gt;</t>
<t tx="ekr.20031218072017.3768">self.outlineMenuTopMenuTable = (
    ("C&amp;ut Node","Shift+Ctrl+X",c.cutOutline),
    ("C&amp;opy Node","Shift+Ctrl+C",c.copyOutline),
    ("&amp;Paste Node","Shift+Ctrl+V",c.pasteOutline),
    ("Paste &amp;Retaining Clones",None,c.pasteOutlineRetainingClones),
    ("&amp;Delete Node","Shift+Ctrl+BkSp",c.deleteOutline),
    ("-",None,None),
    ("&amp;Insert Node","Ctrl+I",c.insertHeadline),
    ("&amp;Clone Node","Ctrl+`",c.clone),
    ("Sort Childre&amp;n",None,c.sortChildren), # Conflicted with Hoist.
    ("&amp;Sort Siblings","Alt-A",c.sortSiblings),
    ("-",None,None),
    ("&amp;Hoist",None,c.hoist),
    ("D&amp;e-Hoist",None,f.c.dehoist),
    ("-",None,None))
    
# Ampersand bindings:  c,d,e,h,i,k,m,n,o,p,r,s,u
</t>
<t tx="ekr.20031218072017.3769">self.outlineMenuExpandContractMenuTable = (
    ("&amp;Contract All","Alt+-",c.contractAllHeadlines),
    ("Contract &amp;Node","Alt+[",c.contractNode),
    ("Contract &amp;Parent","Alt+0",c.contractParent),
    ("-",None,None),
    ("Expand P&amp;rev Level","Alt+.",c.expandPrevLevel),
    ("Expand N&amp;ext Level","Alt+=",c.expandNextLevel),
    ("-",None,None),
    ("Expand To Level &amp;1","Alt+1",c.expandLevel1),
    ("Expand To Level &amp;2","Alt+2",c.expandLevel2),
    ("Expand To Level &amp;3","Alt+3",c.expandLevel3),
    ("Expand To Level &amp;4","Alt+4",c.expandLevel4),
    ("Expand To Level &amp;5","Alt+5",c.expandLevel5),
    ("Expand To Level &amp;6","Alt+6",c.expandLevel6),
    ("Expand To Level &amp;7","Alt+7",c.expandLevel7),
    ("Expand To Level &amp;8","Alt+8",c.expandLevel8),
    # ("Expand To Level &amp;9","Alt+9",c.expandLevel9),
    ("-",None,None),
    ("Expand &amp;All","Alt+9",c.expandAllHeadlines),
    ("Expand N&amp;ode","Alt+]",c.expandNode))</t>
<t tx="ekr.20031218072017.3770">self.outlineMenuMoveMenuTable = (
    ("Move &amp;Down", "Ctrl+D",c.moveOutlineDown),
    ("Move &amp;Left", "Ctrl+L",c.moveOutlineLeft),
    ("Move &amp;Right","Ctrl+R",c.moveOutlineRight),
    ("Move &amp;Up",   "Ctrl+U",c.moveOutlineUp),
    ("-",None,None),
    ("&amp;Promote","Ctrl+{",c.promote),
    ("&amp;Demote", "Ctrl+}",c.demote))</t>
<t tx="ekr.20031218072017.3771">self.outlineMenuMarkMenuTable = (
    ("&amp;Mark","Ctrl-M",c.markHeadline),
    ("Mark &amp;Subheads","Alt+S",c.markSubheads),
    ("Mark Changed &amp;Items","Alt+C",c.markChangedHeadlines),
    ("Mark Changed &amp;Roots","Alt+R",c.markChangedRoots),
    ("Mark &amp;Clones","Alt+K",c.markClones),
    ("&amp;Unmark All","Alt+U",c.unmarkAll))</t>
<t tx="ekr.20031218072017.3772">self.outlineMenuGoToMenuTable = (
    ("Go Back",None,c.goPrevVisitedNode), # Usually use buttons for this.
    ("Go Forward",None,c.goNextVisitedNode),
    ("-",None,None),
    ("Go To Next &amp;Marked","Alt+M",c.goToNextMarkedHeadline),
    ("Go To Next C&amp;hanged","Alt+D",c.goToNextDirtyHeadline),
    ("Go To Next &amp;Clone","Alt+N",c.goToNextClone),
    ("-",None,None),
    ("Go To &amp;First Node","Alt+Shift+G",c.goToFirstNode),
    ("Go To &amp;Last Node","Alt+Shift+H",c.goToLastNode),
    ("Go To &amp;Parent","Alt+Shift+P",c.goToParent),
    ("Go To P&amp;rev Sibling","Alt+Shift+R",c.goToPrevSibling),
    ("Go To Next &amp;Sibling","Alt+Shift+S",c.goToNextSibling),
    ("-",None,None),
    ("Go To Prev V&amp;isible","Alt-UpArrow",c.selectVisBack),
    ("Go To Next &amp;Visible","Alt-DnArrow",c.selectVisNext),
    ("Go To Prev Node","Alt-Shift+UpArrow",c.selectThreadBack),
    ("Go To Next Node","Alt-Shift-DnArrow",c.selectThreadNext))</t>
<t tx="ekr.20031218072017.3773">self.windowMenuTopTable = (
    ("&amp;Equal Sized Panes","Ctrl-E",f.equalSizedPanes),
    ("Toggle &amp;Active Pane","Ctrl-T",f.toggleActivePane),
    ("Toggle &amp;Split Direction",None,f.toggleSplitDirection),
    ("-",None,None),
    ("Resize To Screen",None,f.resizeToScreen),
    ("Casca&amp;de",None,f.cascade),
    ("&amp;Minimize All",None,f.minimizeAll),
    ("-",None,None),
    ("Open &amp;Compare Window",None,c.openCompareWindow),
    ("Open &amp;Python Window","Alt+P",c.openPythonWindow))</t>
<t tx="ekr.20031218072017.3774">self.helpMenuTopTable = (
    ("&amp;About Leo...",None,c.about),
    ("Online &amp;Home Page",None,c.leoHome),
    ("-",None,None),
    ("Open Online &amp;Tutorial",None,c.leoTutorial))
    
self.helpMenuTop2Table = (
    ("Open &amp;Offline Tutorial",None,f.leoHelp),)
    
self.helpMenuTop3Table = (
    ("Open Leo&amp;Docs.leo",None,c.leoDocumentation),
    ("-",None,None),
    ("Open Leo&amp;Config.leo",None,c.leoConfig),
    ("Apply &amp;Settings",None,c.applyConfig))</t>
<t tx="ekr.20031218072017.3797">outlineMenu = self.createNewMenu("&amp;Outline")

self.createMenuEntries(outlineMenu,self.outlineMenuTopMenuTable)

&lt;&lt; create check submenu &gt;&gt;
&lt;&lt; create expand/contract submenu &gt;&gt;
&lt;&lt; create move submenu &gt;&gt;
&lt;&lt; create mark submenu &gt;&gt;
&lt;&lt; create goto submenu &gt;&gt;</t>
<t tx="ekr.20031218072017.3798">expandMenu = self.createNewMenu("&amp;Expand/Contract...","Outline")

self.createMenuEntries(expandMenu,self.outlineMenuExpandContractMenuTable)</t>
<t tx="ekr.20031218072017.3799">moveSelectMenu = self.createNewMenu("&amp;Move...","Outline")

self.createMenuEntries(moveSelectMenu,self.outlineMenuMoveMenuTable)</t>
<t tx="ekr.20031218072017.3800">markMenu = self.createNewMenu("M&amp;ark/Unmark...","Outline")

self.createMenuEntries(markMenu,self.outlineMenuMarkMenuTable)</t>
<t tx="ekr.20031218072017.3801">gotoMenu = self.createNewMenu("&amp;Go To...","Outline")

self.createMenuEntries(gotoMenu,self.outlineMenuGoToMenuTable)</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3859">class leoTkinterDialog:
    """The base class for all Leo Tkinter dialogs"""
    @others</t>
<t tx="ekr.20031218072017.3860">def __init__(self,title="",resizeable=True,canClose=True):
    
    """Constructor for the leoTkinterDialog class."""
    
    self.answer = None # Value returned from run()
    self.resizeable = resizeable
    self.title = title
    self.modal = None
    
    self.buttonsFrame = None # Frame to hold typical dialog buttons.
    self.defaultButtonCommand = None  # Command to call when user closes the window by clicking the close box.
    self.frame = None # The outermost frame.
    self.root = None # g.app.root
    self.top = None # The toplevel Tk widget.
    self.focus_widget = None # The widget to get the first focus.
    self.canClose = canClose</t>
<t tx="ekr.20031218072017.3861">def cancelButton(self):
    
    """Do default click action in cancel button."""
    
    self.answer="cancel"
    self.top.destroy()
    
def noButton(self):
    
    """Do default click action in no button."""
    
    self.answer="no"
    self.top.destroy()
    
def okButton(self):
    
    """Do default click action in ok button."""
    
    self.answer="ok"
    self.top.destroy()

def yesButton(self):
    
    """Do default click action in yes button."""

    self.answer="yes"
    self.top.destroy()</t>
<t tx="ekr.20031218072017.3862">def center(self):
    
    """Center any leoTkinterDialog."""
    
    g.app.gui.center_dialog(self.top)
</t>
<t tx="ekr.20031218072017.3863">def createButtons (self,buttons):
    
    """Create a row of buttons.
    
    buttons is a list of dictionaries containing the properties of each button."""
    
    assert(self.frame)
    self.buttonsFrame = f = Tk.Frame(self.top)
    f.pack(side="top",padx=30)

    # Buttons is a list of dictionaries, with an empty dictionary at the end if there is only one entry.
    buttonList = []
    for d in buttons:
        text = d.get("text","&lt;missing button name&gt;")
        isDefault = d.get("default",False)
        underline = d.get("underline",0)
        command = d.get("command",None)
        bd = g.choose(isDefault,4,2)

        b = Tk.Button(f,width=6,text=text,bd=bd,underline=underline,command=command)
        b.pack(side="left",padx=5,pady=10)
        buttonList.append(b)
        
        if isDefault and command:
            self.defaultButtonCommand = command
        
    return buttonList</t>
<t tx="ekr.20031218072017.3864">def createMessageFrame (self,message):
    
    """Create a frame containing a Tk.Label widget."""

    label = Tk.Label(self.frame,text=message)
    label.pack(pady=10)
</t>
<t tx="ekr.20031218072017.3865">def createTopFrame(self):
    
    """Create the Tk.Toplevel widget for a leoTkinterDialog."""
    
    self.root = g.app.root

    self.top = Tk.Toplevel(self.root)
    self.top.title(self.title)

    if not self.resizeable:
        self.top.resizable(0,0) # neither height or width is resizable.

    self.frame = Tk.Frame(self.top)
    self.frame.pack(side="top",expand=1,fill="both")
    
    if not self.canClose:
        self.top.protocol("WM_DELETE_WINDOW", self.onClose)
    
    # Do this at idle time.
    def callback(top=self.top):
        g.app.gui.attachLeoIcon(top)
    
    self.top.after_idle(callback)</t>
<t tx="ekr.20031218072017.3866">def run (self,modal):
    
    """Run a leoTkinterDialog."""

    self.modal = modal
    
    self.center() # Do this after all packing complete.
    self.top.lift() # 7/31/04

    if self.modal:
        self.top.grab_set() # Make the dialog a modal dialog.
        if self.focus_widget == None:
            self.focus_widget = self.top
        self.focus_widget.focus_set() # Get all keystrokes.	
        self.root.wait_window(self.top)
        return self.answer
    else:
        self.root.wait_window(self.top)
        return None</t>
<t tx="ekr.20031218072017.3944">def createCanvas (self,parentFrame):
    
    frame = self ; config = g.app.config
    
    scrolls = config.getBoolWindowPref('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)

    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", self.OnMouseWheel)
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 1:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20031218072017.3975">def OnActivateBody (self,event=None):

    try:
        frame = self ; c = frame.c ; gui = g.app.gui
        g.app.setLog(frame.log,"OnActivateBody")
        w = gui.get_focus(frame)
        if w != frame.body.bodyCtrl:
            self.tree.OnDeactivate()
            # Reference to bodyCtrl is allowable in an event handler.
            gui.set_focus(c,frame.body.bodyCtrl) 
    except:
        g.es_event_exception("activate body")</t>
<t tx="ekr.20031218072017.3977">def OnBodyClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyclick1",c=c,v=v,event=event):
            self.OnActivateBody(event=event)
        g.doHook("bodyclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("bodyclick")

def OnBodyRClick(self,event=None):
    
    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodyrclick1",c=c,v=v,event=event):
            pass # By default Leo does nothing.
        g.doHook("bodyrclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("iconrclick")</t>
<t tx="ekr.20031218072017.3978">def OnBodyDoubleClick (self,event=None):

    try:
        c = self.c ; v = c.currentVnode()
        if not g.doHook("bodydclick1",c=c,v=v,event=event):
            if event: # 8/4/02: prevent wandering insertion point.
                index = "@%d,%d" % (event.x, event.y) # Find where we clicked
                # 7/9/04
                event.widget.tag_add('sel', 'insert wordstart', 'insert wordend')
            body = self.bodyCtrl
            start = body.index(index + " wordstart")
            end = body.index(index + " wordend")
            self.body.setTextSelection(start,end)
        g.doHook("bodydclick2",c=c,v=v,event=event)
    except:
        g.es_event_exception("bodydclick")
        
    return "break" # Restore this to handle proper double-click logic.</t>
<t tx="ekr.20031218072017.4024">def setTextSelection (self,i,j=None):
    
    # Allow the user to pass either a 2-tuple or two separate args.
    if i is None:
        i,j = "1.0","1.0"
    elif len(i) == 2:
        i,j = i

    g.app.gui.setTextSelection(self.bodyCtrl,i,j)</t>
<t tx="ekr.20031218072017.4037">def setSelectionAreas (self,before,sel,after):
    
    """Replace the body text by before + sel + after and
    set the selection so that the sel text is selected."""

    t = self.bodyCtrl ; gui = g.app.gui
    t.delete("1.0","end")

    if before: t.insert("1.0",before)
    sel_start = t.index("end-1c") # 10/24/03: -1c

    if sel: t.insert("end",sel)
    sel_end = t.index("end")

    if after:
        # A horrible Tk kludge.  Remove a trailing newline so we don't keep extending the text.
        if after[-1] == '\n':
            after = after[:-1]
        t.insert("end",after)

    gui.setTextSelection(t,sel_start,sel_end)
    # g.trace(sel_start,sel_end)
    
    return t.index(sel_start), t.index(sel_end)</t>
<t tx="ekr.20031218072017.4057">def runOpenFileDialog(self,title,filetypes,defaultextension,multiple=False):

    """Create and run an Tkinter open file dialog ."""
    
    # askopenfilenames only exists in Python 2.3 or later
    if multiple and g.CheckVersion(sys.version,"2.3"):
        files = tkFileDialog.askopenfilenames(
            title=title, filetypes=filetypes)
        return list(files)
    else:
        file = tkFileDialog.askopenfilename(
            title=title, filetypes=filetypes)
        if multiple: return [file]
        else:        return file
    
        # DTHEIN 2004.01.31: remove default extension on open,
        # so that we can open files without extensions

def runSaveFileDialog(self,initialfile,title,filetypes,defaultextension):

    """Create and run an Tkinter save file dialog ."""

    return tkFileDialog.asksaveasfilename(
        initialfile=initialfile,
        title=title,
        filetypes=filetypes)
    # EKR: 2004.01.31: remove default extensions on save too.
    # defaultextension=defaultextension)</t>
<t tx="ekr.20031218072017.4089">def setTextSelection (self,t,start,end):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return

    if t.compare(start, "&gt;", end):
        start,end = end,start
        
    t.tag_remove("sel","1.0",start)
    t.tag_add("sel",start,end)
    t.tag_remove("sel",end,"end")
    t.mark_set("insert",end)</t>
<t tx="ekr.20040105223536">def handleStatusLineKey (self,event):
    
    c = self.c ; frame = c.frame
    ch = event.char ; keysym = event.keysym
    keycode = event.keycode ; state = event.state

    if 1: # ch and len(ch)&gt;0:
        &lt;&lt; trace the key event &gt;&gt;

    try:
        status = self.keyStatus
    except:
        status = [] ; frame.clearStatusLine()
    
    for sym,name in (
        ("Alt_L","Alt"),("Alt_R","Alt"),
        ("Control_L","Control"),("Control_R","Control"),
        ("Escape","Esc"),
        ("Shift_L","Shift"), ("Shift_R","Shift")):
        if keysym == sym:
            if name not in status:
                status.append(name)
                frame.putStatusLine(name + ' ')
            break
    else:
        status = [] ; frame.clearStatusLine()

    self.keyStatus = status</t>
<t tx="ekr.20040105223536.1">try:    self.keyCount += 1
except: self.keyCount  = 1

printable = g.choose(ch == keysym and state &lt; 4,"printable","")

print "%4d %s %d %s %x %s" % (
    self.keyCount,repr(ch),keycode,keysym,state,printable)</t>
<t tx="ekr.20040303163330"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed</t>
<t tx="ekr.20040303175026.9"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="ekr.20040305223225">def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()</t>
<t tx="ekr.20040305223522">def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="ekr.20040306211032">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="ekr.20040307104131.1">def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False</t>
<t tx="ekr.20040310092400.1"></t>
<t tx="ekr.20040313150633"># Empty tnodeLists are not errors.
v = p.v

# New in 4.2: tnode list is in tnode.
if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
    if 0:
        s = "deleting tnodeList for " + repr(v)
        print ; print s ; g.es(s,color="blue")
    delattr(v.t,"tnodeList")</t>
<t tx="ekr.20040314035615">threadBack = p.threadBack()
threadNext = p.threadNext()

if threadBack:
    assert p == threadBack.threadNext(), "p==threadBack.threadNext"

if threadNext:
    assert p == threadNext.threadBack(), "p==threadNext.threadBack"</t>
<t tx="ekr.20040314035615.1">back = p.back()
next = p.next()

if back:
    assert p == back.next(), "p==back.next"
        
if next:
    assert p == next.back(), "p==next.back"</t>
<t tx="ekr.20040314035615.2">if p.hasParent():
    n = p.childIndex()
    assert p == p.parent().moveToNthChild(n), "p==parent.moveToNthChild"
    
for child in p.children_iter():
    assert p == child.parent(), "p==child.parent"

if p.hasNext():
    assert p.next().parent() == p.parent(), "next.parent==parent"
    
if p.hasBack():
    assert p.back().parent() == p.parent(), "back.parent==parent"</t>
<t tx="ekr.20040314043623">vnodeList = p.v.t.vnodeList
    
for v in vnodeList:
    
    try:
        assert v.t == p.v.t
    except AssertionError:
        print "p",p
        print "v",v
        print "p.v",p.v
        print "v.t",v.t
        print "p.v.t",p.v.t
        raise AssertionError, "v.t == p.v.t"

    if p.v.isCloned():
        assert v.isCloned(), "v.isCloned"
        assert len(vnodeList) &gt; 1, "len(vnodeList) &gt; 1"
    else:
        assert not v.isCloned(), "not v.isCloned"
        assert len(vnodeList) == 1, "len(vnodeList) == 1"</t>
<t tx="ekr.20040314043900">if full:
    print
    g.enl()

s = "%d nodes checked, %d errors" % (count,errors)
if errors or verbose:
    print s ; g.es(s,color="red")
elif verbose:
    g.es(s,color="green")</t>
<t tx="ekr.20040314044652">s = "test failed: %s %s" % (message,repr(p))
print s ; print
g.es(s,color="red")</t>
<t tx="ekr.20040314062338">if 0:
    g.app.debug = True

    p1 = p.oldLastVisible()
    p2 = p.lastVisible()
    
    if p1 != p2:
        print "oldLastVisible",p1
        print "   lastVisible",p2
    
    assert p1 and p2 and p1 == p2, "oldLastVisible==lastVisible"
    assert p1.isVisible() and p2.isVisible(), "p1.isVisible() and p2.isVisible()"
    
    g.app.debug = False</t>
<t tx="ekr.20040321064134.5">def createThinChild (self,gnxString,headline):

    """Find or create a new vnode whose parent is at.lastThinNode."""

    at = self ; v = at.root.v ; c = at.c ; indices = g.app.nodeIndices
    last = at.lastThinNode ; lastIndex = last.t.fileIndex
    gnx = indices.scanGnx(gnxString,0)
    #g.trace("last",last,last.t.fileIndex)
    #g.trace("args",indices.areEqual(gnx,last.t.fileIndex),gnxString,headline)
    
    # See if there is already a child with the proper index.
    child = at.lastThinNode.firstChild()
    while child and not indices.areEqual(gnx,child.t.fileIndex):
        child = child.next()

    if at.cloneSibCount &gt; 1:
        n = at.cloneSibCount ; at.cloneSibCount = 0
        if child: clonedSibs,junk = at.scanForClonedSibs(child)
        else: clonedSibs = 0
        copies = n - clonedSibs
        # g.trace(copies,headline)
    else:
        if indices.areEqual(gnx,lastIndex):
            return last
        if child:
            return child
        copies = 1 # Create exactly one copy.

    while copies &gt; 0:
        copies -= 1
        # Create the tnode only if it does not already exist.
        tnodesDict = c.fileCommands.tnodesDict
        t = tnodesDict.get(gnxString)
        if t:
            assert(indices.areEqual(t.fileIndex,gnx))
        else:
            t = leoNodes.tnode(bodyString=None,headString=headline)
            t.fileIndex = gnx
            tnodesDict[gnxString] = t
        parent = at.lastThinNode
        child = leoNodes.vnode(c,t)
        t.vnodeList.append(child)
        child.linkAsNthChild(parent,parent.numberOfChildren())
        # g.trace("creating node",child,gnx)

    return child</t>
<t tx="ekr.20040321065415">def findNodeInTree(p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    c = p.c
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(headline):
    
    c = g.top()
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(headline):
    
    c = g.top()
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20040323155951">if not unittest:
    if count % 100 == 0:
        g.es('.',newline=False)
    if count % 2000 == 0:
        g.enl()

@others</t>
<t tx="ekr.20040323155951.1">if p.hasParent():
    t = p.parent().v.t
    for v in p.directParents():
        try:
            assert v.t == t
        except:
            print "p",p
            print "p.directParents",p.directParents()
            print "v",v
            print "v.t",v.t
            print "t = p.parent().v.t",t
            raise AssertionError,"v.t == t"
</t>
<t tx="ekr.20040323161837">if p.isCloned():
    parents = p.v.t.vnodeList
    for child in p.children_iter():
        vparents = child.directParents()
        assert len(parents) == len(vparents), "len(parents) == len(vparents)"
        for parent in parents:
            assert parent in vparents, "parent in vparents"
        for parent in vparents:
            assert parent in parents, "parent in parents"</t>
<t tx="ekr.20040323162707">if p.isCloned() and p.hasChildren():
    childv = p.firstChild().v
    assert childv == p.v.t._firstChild, "childv == p.v.t._firstChild"
    assert id(childv) == id(p.v.t._firstChild), "id(childv) == id(p.v.t._firstChild)"
    for v in p.v.t.vnodeList:
        assert v.t._firstChild == childv, "v.t._firstChild == childv"
        assert id(v.t._firstChild) == id(childv), "id(v.t._firstChild) == id(childv)"</t>
<t tx="ekr.20040323195916.1">@nocolor

- Unit tests for node iterators.

- Unit tests for undo/redo.

** Test for memory leaks.

- Test tangle/untangle commands.

- Create unit tests for Find commands.

- Create unit tests for all dialogs.

- Run profiler on code.</t>
<t tx="ekr.20040324071749">"""CallTips.py - An IDLE Extension to Jog Your Memory

Call Tips are floating windows which display function, class, and method
parameter and docstring information when you type an opening parenthesis, and
which disappear when you type a closing parenthesis.

Future plans include extending the functionality to include class attributes.

"""

import sys
import string
import types

import CallTipWindow

import __main__

@others
</t>
<t tx="ekr.20040324071749.2">class CallTips:
	menudefs = [ ]
	
@others

</t>
<t tx="ekr.20040324071749.4">def __init__(self, editwin=None):

    if editwin == None:  # subprocess and test
        self.editwin = None
        return

    self.editwin = editwin
    self.text = editwin.text
    self.calltip = None
    self._make_calltip_window = self._make_tk_calltip_window</t>
<t tx="ekr.20040324071749.5">def close(self):

    self._make_calltip_window = None
</t>
<t tx="ekr.20040324071749.6">def _make_tk_calltip_window(self):
	
    # See __init__ for usage
    return CallTipWindow.CallTip(self.text)</t>
<t tx="ekr.20040324071749.7">def _remove_calltip_window(self):

    if self.calltip:
        self.calltip.hidetip()
        self.calltip = None</t>
<t tx="ekr.20040324071749.8">def paren_open_event(self, event):

    self._remove_calltip_window()
    name = self.get_name_at_cursor()
    arg_text = self.fetch_tip(name)
    if arg_text:
        self.calltip_start = self.text.index("insert")
        self.calltip = self._make_calltip_window()
        self.calltip.showtip(arg_text)
    return "" #so the event is handled normally.</t>
<t tx="ekr.20040324071749.9">def paren_close_event(self, event):

    # Now just hides, but later we should check if other
    # paren'd expressions remain open.
    self._remove_calltip_window()

    return "" #so the event is handled normally.
</t>
<t tx="ekr.20040324071749.10">def check_calltip_cancel_event(self, event):

    if self.calltip:
        # If we have moved before the start of the calltip,
        # or off the calltip line, then cancel the tip.
        # (Later need to be smarter about multi-line, etc)
        if self.text.compare("insert", "&lt;=", self.calltip_start) or \
           self.text.compare("insert", "&gt;", self.calltip_start
                             + " lineend"):
            self._remove_calltip_window()

    return "" #so the event is handled normally.
</t>
<t tx="ekr.20040324071749.11">def calltip_cancel_event(self, event):

    self._remove_calltip_window()

    return "" #so the event is handled normally.
</t>
<t tx="ekr.20040324071749.12">__IDCHARS = "._" + string.ascii_letters + string.digits

def get_name_at_cursor(self):
    idchars = self.__IDCHARS
    str = self.text.get("insert linestart", "insert")
    i = len(str)
    while i and str[i-1] in idchars:
        i -= 1
    return str[i:]
</t>
<t tx="ekr.20040324071749.13">def fetch_tip(self, name):

    """Return the argument list and docstring of a function or class

    If there is a Python subprocess, get the calltip there.  Otherwise,
    either fetch_tip() is running in the subprocess itself or it was called
    in an IDLE EditorWindow before any script had been run.

    The subprocess environment is that of the most recently run script.  If
    two unrelated modules are being edited some calltips in the current
    module may be inoperative if the module was not the last to run.

    """
    try:
        rpcclt = self.editwin.flist.pyshell.interp.rpcclt
    except:
        rpcclt = None
    if rpcclt:
        return rpcclt.remotecall("exec", "get_the_calltip",
                                 (name,), {})
    else:
        entity = self.get_entity(name)
        return get_arg_text(entity)</t>
<t tx="ekr.20040324071749.14">def get_entity(self, name):

    "Lookup name in a namespace spanning sys.modules and __main.dict__"
    if name:
        namespace = sys.modules.copy()
        namespace.update(__main__.__dict__)
        try:
            return eval(name, namespace)
        except:
            return None</t>
<t tx="ekr.20040324071749.15">def _find_constructor(class_ob):
	
    # Given a class object, return a function object used for the
    # constructor (ie, __init__() ) or None if we can't find one.
	
    try:
        return class_ob.__init__.im_func
    except AttributeError:
        for base in class_ob.__bases__:
            rc = _find_constructor(base)
            if rc is not None: return rc
    return None

</t>
<t tx="ekr.20040324071749.16">def get_arg_text(ob):
    "Get a string describing the arguments for the given object"
    argText = ""
    if ob is not None:
        argOffset = 0
        if type(ob)==types.ClassType:
            # Look for the highest __init__ in the class chain.
            fob = _find_constructor(ob)
            if fob is None:
                fob = lambda: None
            else:
                argOffset = 1
        elif type(ob)==types.MethodType:
            # bit of a hack for methods - turn it into a function
            # but we drop the "self" param.
            fob = ob.im_func
            argOffset = 1
        else:
            fob = ob
        # Try and build one for Python defined functions
        if type(fob) in [types.FunctionType, types.LambdaType]:
            try:
                realArgs = fob.func_code.co_varnames[argOffset:fob.func_code.co_argcount]
                defaults = fob.func_defaults or []
                defaults = list(map(lambda name: "=%s" % name, defaults))
                defaults = [""] * (len(realArgs)-len(defaults)) + defaults
                items = map(lambda arg, dflt: arg+dflt, realArgs, defaults)
                if fob.func_code.co_flags &amp; 0x4:
                    items.append("...")
                if fob.func_code.co_flags &amp; 0x8:
                    items.append("***")
                argText = ", ".join(items)
                argText = "(%s)" % argText
            except:
                pass
        # See if we can use the docstring
        doc = getattr(ob, "__doc__", "")
        if doc:
            doc = doc.lstrip()
            pos = doc.find("\n")
            if pos &lt; 0 or pos &gt; 70:
                pos = 70
            if argText:
                argText += "\n"
            argText += doc[:pos]
    return argText
</t>
<t tx="ekr.20040324071749.17">#################################################
#
# Test code
#
if __name__=='__main__':

    def t1(): "()"
    def t2(a, b=None): "(a, b=None)"
    def t3(a, *args): "(a, ...)"
    def t4(*args): "(...)"
    def t5(a, *args): "(a, ...)"
    def t6(a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    class TC:
        "(a=None, ...)"
        def __init__(self, a=None, *b): "(a=None, ...)"
        def t1(self): "()"
        def t2(self, a, b=None): "(a, b=None)"
        def t3(self, a, *args): "(a, ...)"
        def t4(self, *args): "(...)"
        def t5(self, a, *args): "(a, ...)"
        def t6(self, a, b=None, *args, **kw): "(a, b=None, ..., ***)"

    def test(tests):
        ct = CallTips()
        failed=[]
        for t in tests:
            expected = t.__doc__ + "\n" + t.__doc__
            name = t.__name__
            arg_text = ct.fetch_tip(name)
            if arg_text != expected:
                failed.append(t)
                print "%s - expected %s, but got %s" % (t, expected,
                                                        get_arg_text(entity))
        print "%d of %d tests failed" % (len(failed), len(tests))

    tc = TC()
    tests = (t1, t2, t3, t4, t5, t6,
             TC, tc.t1, tc.t2, tc.t3, tc.t4, tc.t5, tc.t6)

    test(tests)
</t>
<t tx="ekr.20040324072124">"""A CallTip window class for Tkinter/IDLE.

After ToolTip.py, which uses ideas gleaned from PySol
Used by the CallTips IDLE extension.

"""

import Tkinter as Tk
import leoGlobals as g

@others

if 1:
	main()</t>
<t tx="ekr.20040324072124.2">class CallTip:

@others
</t>
<t tx="ekr.20040324072124.3">def __init__(self,widget):

	self.widget = widget
	self.tipwindow = None
	self.id = None
	self.x = self.y = 0</t>
<t tx="ekr.20040324072124.4">def showtip (self,text):

	""" Display text in calltip window"""

	if self.tipwindow or not text: return

	# truncate overly long calltip
	if len(text) &gt;= 79: text = text[:75] + ' ...'
	self.text = text

	self.widget.see("insert")
	x,y,cx,cy = self.widget.bbox("insert")
	x = x + self.widget.winfo_rootx() + 2
	y = y + cy + self.widget.winfo_rooty()
	self.tipwindow = tw = Tk.Toplevel(self.widget)

	&lt;&lt; remove the border &gt;&gt;
	tw.wm_geometry("+%d+%d" % (x, y))
	&lt;&lt; Mac-specific code &gt;&gt;

	label = Tk.Label(tw,text=text, justify="left",
		background="#ffffe0",relief="solid",borderwidth=1,
		font=self.widget['font'])

	label.pack()</t>
<t tx="ekr.20040324072124.5">def hidetip(self):

	tw = self.tipwindow
	self.tipwindow = None
	if tw:
		tw.destroy()</t>
<t tx="ekr.20040324072124.6">class container: # Conceptually an editor_window

@others</t>
<t tx="ekr.20040324072124.7">def __init__(self):

	root = Tk.Tk()
	text = self.text = Tk.Text(root)
	text.pack(side="left", fill="both", expand=1)
	text.insert("insert","string.split")
	root.update()
	self.calltip = CallTip(text)

	text.event_add(g.virtual_event_name("calltip-show"),"(")
	text.event_add(g.virtual_event_name("calltip-hide"),")")

	text.bind(g.virtual_event_name("calltip-show"),self.calltip_show)
	text.bind(g.virtual_event_name("calltip-hide"),self.calltip_hide)

	text.focus_set()
	root.mainloop()</t>
<t tx="ekr.20040324072124.8">def calltip_show(self, event):

	self.calltip.showtip("Hello world")</t>
<t tx="ekr.20040324072124.9">def calltip_hide(self, event):

	self.calltip.hidetip()</t>
<t tx="ekr.20040324072124.10">def main():

	# Test code
	c=container()</t>
<t tx="ekr.20040324073536">@
The following command has two effects:
- It removes the calltip window border (good)
- Causes (at least on Linux) the calltip to show as a top level window,
  burning through any other window dragged over it.
  Also, shows on all viewports!
@c

tw.wm_overrideredirect(1)</t>
<t tx="ekr.20040324073536.1">@
This command is only needed and available on Tk &gt;= 8.4.0 for OSX.
Without it, call tips intrude on the typing process by grabbing the focus.
@c

try:
	tw.tk.call("::tk::unsupported::MacWindowStyle",
		"style",tw._w,"help","noActivates")
except Tk.TclError:
	pass</t>
<t tx="ekr.20040324075752">@nocolor

https://sourceforge.net/forum/message.php?msg_id=2460535
By: nobody

See CallTipWindow.py in IDLE 1.0.2

Fairly simple implementation - uses a new toplevel window without a border.

Read the comments in the code for potential drawbacks on some platforms.

Regards, Myles.</t>
<t tx="ekr.20040324080359">try:
    # Write all @file nodes and set orphan bits.
    c.atFileCommands.writeAll()
except:
    g.es_error("exception writing derived files")
    g.es_exception()
    return False</t>
<t tx="ekr.20040324080359.1"># self.read_only is not valid for Save As and Save To commands.

if g.os_path_exists(fileName):
    try:
        if not os.access(fileName,os.W_OK):
            g.es("can not create: read only: " + fileName,color="red")
            return False
    except:
        pass # os.access() may not exist on all platforms.</t>
<t tx="ekr.20040324080359.2">self.outputFile = open(fileName, 'wb') # 9/18/02
if not self.outputFile:
    g.es("can not open " + fileName)
    &lt;&lt; delete backup file &gt;&gt;
    return False</t>
<t tx="ekr.20040324080819">c.setIvarsFromFind()
config.setConfigFindIvars(c)
c.setIvarsFromPrefs()
config.setCommandsIvars(c)
config.update()</t>
<t tx="ekr.20040324080819.1">self.putProlog()
self.putHeader()
self.putGlobals()
self.putPrefs()
self.putFindSettings()
#start = g.getTime()
self.putVnodes()
#start = g.printDiffTime("vnodes ",start)
self.putTnodes()
#start = g.printDiffTime("tnodes ",start)
self.putPostlog()</t>
<t tx="ekr.20040324080819.2">g.es("exception writing: " + fileName)
g.es_exception() 
if self.outputFile:
    try:
        self.outputFile.close()
        self.outputFile = None
    except:
        g.es("exception closing: " + fileName)
        g.es_exception()</t>
<t tx="ekr.20040324080819.3">try:
    self.outputFile.close()
    self.outputFile = None
except:
    g.es("exception closing: " + fileName)
    g.es_exception()</t>
<t tx="ekr.20040324082713"># Write the tnodeList only for @file nodes.
# New in 4.2: tnode list is in tnode.

if 0: # Debugging.
    if v.isAnyAtFileNode():
        if hasattr(v.t,"tnodeList"):
            g.trace(v.headString(),len(v.t.tnodeList))
        else:
            g.trace(v.headString(),"no tnodeList")

if hasattr(v.t,"tnodeList") and len(v.t.tnodeList) &gt; 0 and v.isAnyAtFileNode():
    if isThin:
        if g.app.unitTesting:
            g.app.unitTestDict["warning"] = True
        g.es("deleting tnode list for %s" % p.headString(),color="blue")
        # This is safe: cloning can't change the type of this node!
        delattr(v.t,"tnodeList")
    else:
        fc.putTnodeList(v) # New in 4.0

if hasattr(v,"unknownAttributes"): # New in 4.0
    self.putUnknownAttributes(v)
    
if p.hasChildren() and not forceWrite and not self.usingClipboard:
    # We put the entire tree when using the clipboard, so no need for this.
    self.putDescendentUnknownAttributes(p)
    self.putDescendentAttributes(p)</t>
<t tx="ekr.20040325073709">def isAtFileNode (self):
    return g.choose(self.atFileNodeName(),True,False)
    
def isAtNoSentinelsFileNode (self):
    return g.choose(self.atNoSentinelsFileNodeName(),True,False)

def isAtRawFileNode (self): # @file-noref
    return g.choose(self.atRawFileNodeName(),True,False)

def isAtSilentFileNode (self): # @file-asis
    return g.choose(self.atSilentFileNodeName(),True,False)

def isAtThinFileNode (self):
    return g.choose(self.atThinFileNodeName(),True,False)
    
# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode</t>
<t tx="ekr.20040326031436">def isAnyAtFileNode (self):
    
    """Return True if v is any kind of @file or related node."""
    
    # This routine should be as fast as possible.
    # It is called once for every vnode when writing a file.

    h = self.headString()
    return h and h[0] == '@' and self.anyAtFileNodeName()</t>
<t tx="ekr.20040326055828">if not setCurrent and len(self.currentVnodeStack) &gt; 0 and appendToCurrentStack:
    #g.trace("append current",v)
    self.currentVnodeStack.append(v)
    
if not setTop and len(self.topVnodeStack) &gt; 0 and appendToTopStack:
    #g.trace("append top",v)
    self.topVnodeStack.append(v)</t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040331083824.1"># Note: we could use StringIo for this.

class fileLikeObject:

    """Define a file-like object for redirecting writes to a string.
    
    The caller is responsible for handling newlines correctly."""

    def __init__(self):
        self.list = []
        self.ptr = 0

    def clear (self):   self.list = []

    def close (self): pass
    def flush (self): pass

    def get (self):
        return ''.join(self.list)
        
    def readline(self): # New for read-from-string (readOpenFile).
        if self.ptr &lt; len(self.list):
            line = self.list[self.ptr]
            # g.trace(repr(line))
            self.ptr += 1
            return line
        else: return ""

    def write (self,s):
        if s: self.list.append(s)</t>
<t tx="ekr.20040412060927">def dumpOutline (self):
    
    """ Dump all nodes in the outline."""
    
    c = self

    for p in c.allNodes_iter():
        p.dump()</t>
<t tx="ekr.20040629110559"></t>
<t tx="ekr.20040629111136">
http://sourceforge.net/forum/message.php?msg_id=2630116
By: genthaler

Hi Mac OS X users,

I've put a native Mac OS X Leo application at

http://idisk.mac.com/genthaler-Public/Leo.zip

Just unzip it and put it in /Applications or ~/Applications

The Leo version I've used is 4.2a3 i.e. the latest version on SF. Living on
the edge...

It includes application and document icons (just the 32*32 ones, I don't have
time to create 128*128) as well as .leo extension associations.

AFAIK, it requires 10.3 (it uses the python in
/System/Library/Frameworks/Python.framework) and the MacPython-Panther addon
(http://ftp.cwi.nl/jack/python/mac/MacPython-Panther-2.3-2.dmg).
It also requires Aqua Tcl/Tk - I used the BI version from
http://prdownloads.sourceforge.net/tcltkaqua/TclTkAquaBI-8.4.6.1.dmg?download
The standard version should work, though.

Once they're installed, use /Applications/MacPython-2.3/PackageManager to install
_tkinter.

The control -&gt; command key swapping announced above works nicely too. I changed
EditHeadline in leoConfig.leo (&lt;&lt; F-keys and others &gt;&gt;) to Ctrl+Command+H so
that Command-H still hides the application in standard fashion.

An accidental goodness is that the Leo plugins folder coincides with the standard
Mac OS X application bundle plugins folder - this means that you can use the
Finder's Get Info window to add, delete, enable &amp; disable Leo plugins!

One minor unpleasantness is that you can only double-click or drag-drop a document
icon when Leo isn't open, and Leo closes when the last document is closed. You
can still use Leo's File-&gt;Open to open multiple documents, though.

Ed, feel free to copy this into the download area.

Guenther.</t>
<t tx="ekr.20040629111733"></t>
<t tx="ekr.20040629111733.1"></t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.2 beta 3, build %s, August 5, 2004" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.147 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = g.app.config.getWindowPref("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, %s" % (n1,n2,n3,tkLevel,sys.platform))
    g.enl()</t>
<t tx="ekr.20040629121906"></t>
<t tx="ekr.20040629121906.1">- Names don't show up in the Marks button until a node has been marked.

- Parent nodes don't always get expanded.

- Leaks memory slightly.</t>
<t tx="ekr.20040630214448.1"></t>
<t tx="ekr.20040701041539"></t>
<t tx="ekr.20040702064435"></t>
<t tx="ekr.20040702085529">if p.isAtThinFileNode and p.isOrphan():
    g.es("Writing erroneous: %s" % p.headString(),color="blue")
    p.clearOrphan()

if 0: # For testing.
    if p.isAtIgnoreNode():
         for p2 in p.self_and_subtree_iter():
                if p2.isAtThinFileNode():
                    g.es("Writing @ignore'd: %s" % p2.headString(),color="blue")</t>
<t tx="ekr.20040703054646">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    typesDict[type(obj)] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        print "%+6d =%7d %s" % (delta2,n2,key)
    
lastTypesDict = typesDict
typesDict = {}</t>
<t tx="ekr.20040703065638">import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            print ; print obj
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            print "args", args
            if varargs: print "varargs",varargs
            if varkw: print "varkw",varkw
            if defaults:
                print "defaults..."
                for s in defaults: print s

lastFunctionsDict = funcDict
funcDict = {}</t>
<t tx="ekr.20040705071418"></t>
<t tx="ekr.20040705074955">@killcolor

Leo's core looks pretty good.  Most (all?) of the "leaks" happen in the undo logic.

There are a few leaks in plugins.</t>
<t tx="ekr.20040705194708"></t>
<t tx="ekr.20040705195048">def skip_id(s,i,chars=None):

    n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
</t>
<t tx="ekr.20040705201018">def findAtFileName (self,names):
    
    """Return the name following one of the names in nameList.
    Return an empty string."""

    h = self.headString()
    
    if not g.match(h,0,'@'):
        return ""
    
    i = g.skip_id(h,1,'-')
    word = h[:i]
    if word in names and g.match_word(h,0,word):
        name = h[i:].strip()
        # g.trace(word,name)
        return name
    else:
        return ""</t>
<t tx="ekr.20040706080316"></t>
<t tx="ekr.20040706080747"></t>
<t tx="ekr.20040706080747.1"></t>
<t tx="ekr.20040706111156">@killcolor

- Leo now vetos the shutdown logic if saving a dirty file fails.

- Leo prints in red the warning about not being able save the read-only file.

- The user can use the Save To command to save the file. The Save To command
does not clear the file's dirty bit, so Leo will prompt again to save the file.
The user will have to ignore this prompt in order to exit. This is basically
correct: the _original_ file has not been saved.</t>
<t tx="ekr.20040707060750"></t>
<t tx="ekr.20040707144444"></t>
<t tx="ekr.20040707150139">@killcolor

- g.getScript implicitly assumed that p == c.currentPosition.
  I removed that assumption.

- The scriptButton callback in the scripting.py plugin no longer calls c.executeScript.
  It's simpler and easier to call exec directly.

- Improved c.checkOutline:
    - Added full keyword arg.
    - Print more if verbose is on.</t>
<t tx="ekr.20040709053152"></t>
<t tx="ekr.20040709064521"></t>
<t tx="ekr.20040709065122">@killcolor

- Added to manifest.in:
    
include doc/default.css
include doc/leo_rst.css
include doc/silver_city.css

- Added to leo.nsi:

File c:\prog\leoCVS\leo\doc\default.css
File c:\prog\leoCVS\leo\doc\leo_rst.css
File c:\prog\leoCVS\leo\doc\silver_city.css

- Uploaded leo-stylesheets.zip to plugins package at SourceForge.</t>
<t tx="ekr.20040709075150"></t>
<t tx="ekr.20040709075150.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=2655535
By: nobody

I think this solves your request:

@color

def selectWord( event ):
    event.widget.tag_add( 'sel', 'insert wordstart', 'insert' )
textwidget.bind( '&lt;Double-Button-1&gt;', selectWord )

@nocolor

add it to the code where the Text widget editor is created and you should have
the behavior and not feel grief anymore.  Oh yeah, 'textwidget' needs to be
the reference to the Text editor, whatever it's called.  This is actually shorter
than I thought it was going to be. :)

EKR: This doesn't seem to work, regardless of where it is placed.
</t>
<t tx="ekr.20040709080432">http://sourceforge.net/forum/message.php?msg_id=2649750</t>
<t tx="ekr.20040709081208">import threading
import time
way = 'Down' # global.
ev = threading.Event()

def run(ev = ev):
    global way
    while 1:
        ev.wait()
        if way=='Down': canvas.yview("scroll", 1,"units")
        else:           canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()
    
def exe(event,ev=ev,theWay='Down',canvas=canvas):
    global way
    if event.widget!=canvas: return
    if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    way = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    canvas.bind_all('&lt;Shift Button-3&gt;',exe)
    canvas.bind_all('&lt;Shift Button-1&gt;',lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;', off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;', off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;', exe)
    canvas.bind_all( '&lt;Button-1&gt;', lambda event,way='Up': exe(event,theWay=way))
    canvas.bind_all( '&lt;ButtonRelease-1&gt;', off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;', off)</t>
<t tx="ekr.20040709085421"></t>
<t tx="ekr.20040709094545"></t>
<t tx="ekr.20040709101338">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2653456
By: nobody

askopenfilenames allows you to select and return multiple file names. This does
work on Windows.  I haven't tested it on Linux.</t>
<t tx="ekr.20040709104835"></t>
<t tx="ekr.20040709104835.1"></t>
<t tx="ekr.20040709144318.1"></t>
<t tx="ekr.20040709151825"></t>
<t tx="ekr.20040711135244"></t>
<t tx="ekr.20040711135244.2">@ignore
@language python
@tabwidth -4</t>
<t tx="ekr.20040711135244.4">def prettyPrintNode(self,p,dump):

    pp = self ; c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        pp.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            pp.putToken(token5tuple)
        lines = pp.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        pp.dumpLines(p,lines)
    else:
        pp.replaceBody(p,lines)</t>
<t tx="ekr.20040711135244.5">class prettyPrinter:
    
    @others</t>
<t tx="ekr.20040711135244.6">def __init__ (self,c):
    
    self.changed = False
    self.line = 0
    self.lines = []
    self.col = 0
    self.array = []
    self.parenLevel = 0
    self.bracketLevel = 0
    self.c = c
    self.p = c.currentPosition()
    self.prevName = None</t>
<t tx="ekr.20040711135244.7">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = str(t5) # can fail
    name = token.tok_name[t1].lower()
    val = str(t2) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20040711135244.8">def get (self):
    
    return self.lines</t>
<t tx="ekr.20040711135244.9">def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20040711135244.10">def putNormalToken (self,token5tuple):

    a = self.array
    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4
    line = t5
    name = token.tok_name[t1].lower()
    val = t2
    startLine = self.line != srow
    self.line = srow

    if startLine:
        ws = line[0:scol]
        if ws: a.append(ws)

    # g.trace(name,repr(val))
    if name in ("nl","newline","endmarker"):
        if name in ("nl","newline"):
            a.append('\n')
        self.lines.append(''.join(a))
        self.array = []
    elif name == "op":
        self.putOperator(val)
    elif name == "name":
        a.append("%s " % val)
        if self.prevName == "def": # A personal idiosyncracy.
            a.append(' ') # Retain the blank before '('.
        self.prevName = val
    elif name == "number":
        a.append(val)
    elif name in ("comment","string"):
        # These may span lines, so duplicate the end-of-line logic.
        lines = g.splitLines(val)
        for line in lines:
            a.append(line)
            if line and line[-1] == '\n':
                self.lines.append(''.join(a))
                self.array = []
    elif name == "errortoken":
        a.append(val)
        if val == '@':
            # Preserve whitespace after @.
            i = g.skip_ws(line,scol+1)
            ws = line[scol+1:i]
            if ws: a.append(ws)
    elif name == "indent":
        a.append(val)
    elif name == "dedent":
        pass
    else:
        print "unknown: %s" % (name)</t>
<t tx="ekr.20040711135244.11">def putOperator (self,val):
    
    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel &gt; 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel &gt; 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)</t>
<t tx="ekr.20040711135244.12">def putToken (self,token5tuple):
    
    if 1:
        self.putNormalToken(token5tuple)
    else:
        self.dumpToken(token5tuple)</t>
<t tx="ekr.20040711135959.1"></t>
<t tx="ekr.20040711135959.2"></t>
<t tx="ekr.20040711140738">self.outlineMenuCheckOutlineMenuTable = (

    ("Check &amp;Outline",None,c.checkOutline),
    ("&amp;Dump Outline",None,c.dumpOutline),
    ("-",None,None),
    ("Check &amp;All Python Code",None,c.checkAllPythonCode),
    ("&amp;Check Python &amp;Code",None,c.checkPythonCode),
    ("-",None,None),
    ("Pretty P&amp;rint All Python Code",None,c.prettyPrintAllPythonCode),
    ("&amp;Pretty Print Python Code",None,c.prettyPrintPythonCode),
    
)

# shortcuts used: a,c,d,o,p,r</t>
<t tx="ekr.20040711140738.1">checkOutlineMenu = self.createNewMenu("Chec&amp;k...","Outline")

self.createMenuEntries(checkOutlineMenu,self.outlineMenuCheckOutlineMenuTable)</t>
<t tx="ekr.20040711141625"></t>
<t tx="ekr.20040712045017">@killcolor

- Added onNodeOnly option to new_df.write.  This allows the Check Python command to get one node at a time for checking.

- Fixed bug in putNormalToken: @others was turned into others if there was leading whitespace.

- Fixed bug in setBodyStringOrPane (!).  The new code sets the selection properly.</t>
<t tx="ekr.20040712053025">def prettyPrintAllPythonCode (self,dump=False):

    c = self ; pp = c.prettyPrinter(c)

    for p in c.all_positions_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":

            pp.prettyPrintNode(p,dump=dump)
            
    pp.endUndo()</t>
<t tx="ekr.20040712053025.1">def prettyPrintPythonCode (self,p=None,dump=False):

    c = self
    
    if p: root = p.copy()
    else: root = c.currentPosition();
    
    pp = c.prettyPrinter(c)
    
    for p in root.self_and_subtree_iter():
        
        # Unlike scanDirectives, scanForAtLanguage ignores @comment.
        if g.scanForAtLanguage(c,p) == "python":
    
            pp.prettyPrintNode(p,dump=dump)
          
    pp.endUndo()</t>
<t tx="ekr.20040712082657"></t>
<t tx="ekr.20040712084911.1">def scanForAtLanguage(c,p):
    
    """Scan position p and p's ancestors looking only for @language and @ignore directives.

    Returns the language found, or c.target_language."""
    

    if c and p:
        for p in p.self_and_parents_iter():
            s = p.bodyString()
            d = g.get_directives_dict(s)
            if d.has_key("language"):
                k = d["language"]
                language,delim1,delim2,delim3 = g.set_language(s,k)
                return language # Continue looking for @ignore

    return c.target_language</t>
<t tx="ekr.20040712100041"></t>
<t tx="ekr.20040712112449"># This is no longer used: we use toString logic instead.</t>
<t tx="ekr.20040712135130"></t>
<t tx="ekr.20040712135130.1">@language plain

For some reason, spurious entries in a tnodeList for @thin trees wipes out all the headlines in the @thin tree.  This needs more investigation.

This happened when running c.checkPythonCode from a script.  Apparently the script set tnodeList by mistake.

The quick fix was to set at.root.v.t.tnodeList = [] in the toString logic in new_df.write.</t>
<t tx="ekr.20040712144354"></t>
<t tx="ekr.20040713062342"></t>
<t tx="ekr.20040713064323">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 1:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20040713070356">def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)</t>
<t tx="ekr.20040713081916"></t>
<t tx="ekr.20040713085052"># We borrow most of the Change/Change all logic.</t>
<t tx="ekr.20040713091855">def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)</t>
<t tx="ekr.20040713093048">def clear (self):
    self.lines = []</t>
<t tx="ekr.20040713094547">@killcolor

- More options, of course.  The following methods do the actual reformatting:
    
    - putOperator:      puts whitespace around operators.
    - putNormalToken:   puts whitespace around everything else.

Note that you can use putToken to dump lines for debugging.

- Once you have determined the 8323 formatting options that would be necessary to make _you_ happy, you can create those options in leoConfig.txt or a plugin :-)
</t>
<t tx="ekr.20040715094645"></t>
<t tx="ekr.20040715100724">@killcolor

https://sourceforge.net/forum/message.php?msg_id=2665410
By: bwmulder

I just updated from CVS. The attempt to open LeoPyRef.leo fails because
of runOpenFileDialog.

If "multiple" is false, it calls tkFileDialog.askopenfilename, and then makes
a list out of the result of this function, which is a list of characters.

Maybe this function should be really split into two versions: one for exactly
one file, and another one for a list of files? Probably the latter should *always*
return a list, even if the corresponding function really only returns one
filename.

[I am running on Windows XP].
</t>
<t tx="ekr.20040715155607">def scanForAtIgnore(c,p):
    
    """Scan position p and its ancestors looking for @ignore directives."""
    
    language = c.target_language

    if c is None or g.top() is None:
        return False # For unit tests.

    for p in p.self_and_parents_iter():
        s = p.bodyString()
        d = g.get_directives_dict(s)
        if d.has_key("ignore"):
            return True

    return False</t>
<t tx="ekr.20040715171241">@nocolor

when opening a leo document that contains an @file, say like @file helloworld.bas, leo reports upon opening that:

Leo Log Window...
Leo 4.2 beta 2, build 1.128 , July 5, 2004
Python 2.3.4, Tk 8.4.3, win32
File encoding: UTF-8
reading: D:\Programming\HelloWorld.leo
reading: @file helloworld.bas
----- error reading @file helloworld.bas
Mismatched headline.
Expecting: @file helloworld
got: @file helloworld.bas
leoConfig.txt encoding: utf-8
@run encoding: mbcs
13 plugins loaded
leoID = fil
</t>
<t tx="ekr.20040716061450">if headline.strip() == v.headString().strip():
    t.setVisited() # Supress warning about unvisited node.
    return t
else:
    at.readError(
        "Mismatched headline.\nExpecting: %s\ngot: %s" %
        (headline,v.headString()))
    g.trace("Mismatched headline",headline,v.headString())
    g.trace(at.tnodeListIndex,len(at.root.v.t.tnodeList))
    return None</t>
<t tx="ekr.20040716064333">nodeIndices = g.app.nodeIndices

nodeIndices.setTimestamp()

for p2 in root.self_and_subtree_iter():
    try: # Will fail for None or any pre 4.1 file index.
        id,time,n = p2.v.t.fileIndex
    except TypeError:
        p2.v.t.fileIndex = nodeIndices.getNewIndex()</t>
<t tx="ekr.20040716064333.1">df.write(root,thinFile=True,toString=True)
s = df.stringOutput
if not s: return
</t>
<t tx="ekr.20040716065356">for p2 in p.self_and_subtree_iter():
    p2.clearDirty()</t>
<t tx="ekr.20040716105102">i = last_nosent_i

if i + 1 &lt; len(lines):

    line = lines[i+1]
    j = g.skip_ws(line,0)

    if match(line,j,delim1):
        j += len(delim1)

        if g.match(line,j,"@nonl"):
            line = lines[i]
            if line[-1] == '\n':
                assert(result[-1] == line)
                result[-1] = line[:-1]</t>
<t tx="ekr.20040716105102.1"></t>
<t tx="ekr.20040717112739">@nocolor
@

This algorithm corrects the result of an Import To @file command so that it is guaranteed that the result of writing the imported file will be identical to the original file except for any sentinels that have been inserted.

On entry, p points to the newly imported outline.

We correct the outline by applying Bernhard Mulder's algorithm.

1.  We use the atFile.write code to write the newly imported outline to a string s.  This string contains represents a thin derived file, so it can be used to recreate then entire outline structure without any other information.

Splitting s into lines creates the fat_lines argument to mu methods.

2. We make corrections to fat_lines using Mulder's algorithm.  The corrected fat_lines represents the corrected outline.  To do this, we set the arguments as follows:

- i_lines: fat_lines stripped of sentinels
- j_lines to the lines of the original imported file.

The algorithm updates fat_lines using diffs between i_lines and j_lines.

3. Mulder's algorithm doesn't specify which nodes have been changed.  In fact, it Mulder's algorithm doesn't really understand nodes at all.  Therefore, if we want to mark changed nodes we do so by comparing the original version of the imported outline with the corrected version of the outline.</t>
<t tx="ekr.20040717113036">@ Notes:
1. This code must overwrite the newly-imported tree because the gnx's in
write_lines refer to those nodes.

2. The code in readEndNode now reports when nodes change during importing. This
code also marks changed nodes.
@c

try:
    df.correctedLines = 0
    df.targetFileName = "&lt;perfectImport string-file&gt;"
    df.inputFile = fo = g.fileLikeObject()
    df.file = fo # Strange, that this is needed.  Should be cleaned up.
    for line in write_lines:
        fo.write(line)
    firstLines,junk = c.atFileCommands.scanHeader(fo,df.targetFileName)
    # To do: pass params to readEndNode.
    df.readOpenFile(root,fo,firstLines,perfectImportRoot=root)
    n = df.correctedLines
    if verbose:
        g.es("%d marked node%s corrected" % (n,g.choose(n==1,'','s')),color="blue")
except:
    g.es("Exception in Perfect Import",color="red")
    g.es_exception()
    s = None</t>
<t tx="ekr.20040717132539">write_lines_node = root.insertAfter()
write_lines_node.initHeadString("write_lines")
s = ''.join(write_lines)
write_lines_node.scriptSetBodyString(s,encoding=g.app.tkEncoding)</t>
<t tx="ekr.20040717133553">@killcolor

- Added readline method to fileLikeObject class: new_df.readOpenFile calls readline.

- Added perfectImportRoot keyword arg to new_df.readOpenFile.

- Added perfectImportRoot ivar to new_df class.

- readEndNode counts the number of corrected nodes, and marks all corrected nodes.

- Forced at.perfectImportRoot = False in top-level read code.
    This corrects a problem with reading LeoDocs.leo during unit tests.</t>
<t tx="ekr.20040717133944"># Report the number of corrected nodes.
at.correctedLines += 1

found = False
for p in at.perfectImportRoot.self_and_subtree_iter():
    if p.v.t == at.t:
        found = True ; break

if found:
    if 0: # Not needed: we mark all corrected nodes.
        g.es("Correcting %s" % p.headString(),color="blue")
    if 0: # For debugging.
        print ; print '-' * 40
        print "old",len(old)
        for line in g.splitLines(old):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
        print "new",len(s)
        for line in g.splitLines(s):
            #line = line.replace(' ','&lt; &gt;').replace('\t','&lt;TAB&gt;')
            print repr(str(line))
        print ; print '-' * 40
else:
    # This should never happen.
    g.es("Correcting hidden node: t=%s" % repr(at.t),color="red")</t>
<t tx="ekr.20040718035658">try:
    # Read the original file into before_lines.
    before = file(fileName)
    before_lines = before.readlines()
    before.close()
    
    # Write the tree into after_lines.
    df.write(root,thinFile=True,toString=True)
    after_lines1 = g.splitLines(df.stringOutput)
    
    # Strip sentinels from after_lines and compare.
    after_lines = mu.removeSentinelsFromLines(after_lines1,delims)
    
    # A major kludge: Leo can not represent unindented blank lines in indented nodes!
    # We ignore the problem here by stripping whitespace from blank lines.
    # We shall need output options to handle such lines.
    if convertBlankLines:
        mu.stripWhitespaceFromBlankLines(before_lines)
        mu.stripWhitespaceFromBlankLines(after_lines)
    if before_lines == after_lines:
        if verbose:
            g.es("Perfect Import verified",color="blue")
    else:
        leoTest.fail()
        if verbose:
            g.es("Perfect Import failed verification test!",color="red")
            &lt;&lt; dump the files &gt;&gt;
except IOError:
    g.es("Can not reopen %s!" % fileName,color="red")
    leoTest.fail()</t>
<t tx="ekr.20040718042049"></t>
<t tx="ekr.20040718042049.1"></t>
<t tx="ekr.20040718045423">print len(before_lines),len(after_lines)

if len(before_lines)==len(after_lines):
    for i in xrange(len(before_lines)):
        extra = 3
        if before_lines[i] != after_lines[i]:
            j = max(0,i-extra)
            print '-' * 20
            while j &lt; i + extra + 1:
                leader = g.choose(i == j,"* ","  ")
                print "%s%3d" % (leader,j), repr(before_lines[j])
                print "%s%3d" % (leader,j), repr(after_lines[j])
                j += 1
else:
    for i in xrange(min(len(before_lines),len(after_lines))):
        if before_lines[i] != after_lines[i]:
            extra = 5
            print "first mismatch at line %d" % i
            print "printing %d lines after mismatch" % extra
            print "before..."
            for j in xrange(i+1+extra):
                print "%3d" % j, repr(before_lines[j])
            print
            print "after..."
            for k in xrange(1+extra):
                print "%3d" % (i+k), repr(after_lines[i+k])
            print
            print "with sentinels"
            j = 0 ; k = 0
            while k &lt; i + 1 + extra:
                print "%3d" % k,repr(after_lines1[j])
                if not g.is_sentinel(after_lines1[j],delims):
                    k += 1
                j += 1
            break</t>
<t tx="ekr.20040718101315">def stripWhitespaceFromBlankLines (self,lines):
    
    # All backslashes must be doubled.

    """Strip blanks and tabs from lines containing only blanks and tabs.
    
    &gt;&gt;&gt; import leoGlobals as g
    &gt;&gt;&gt; s = "a\\n \\t\\n\\t\\t \\t\\nb"
    &gt;&gt;&gt; theLines = g.splitLines(s)
    &gt;&gt;&gt; theLines
    ['a\\n', ' \\t\\n', '\\t\\t \\t\\n', 'b']
    &gt;&gt;&gt; g.mulderUpdateAlgorithm().stripWhitespaceFromBlankLines(theLines)
    ['a\\n', '\\n', '\\n', 'b']
    """

    for i in xrange(len(lines)):
        stripped_line = lines[i].lstrip(" \t")
        if stripped_line in ('\n',''):
            lines[i] = stripped_line
            
    return lines</t>
<t tx="ekr.20040718163531"></t>
<t tx="ekr.20040718163531.1">By: Bernhard Mulder - bwmulder
Python check/pretty printing bug  
2004-07-18 13:09
It seems that the new python pretty printing / checking code has problems with triple quoted strings.

I tried this with an (updated) version of the basic_undo code posted on my site. </t>
<t tx="ekr.20040719151353"></t>
<t tx="ekr.20040719161756">"""

Return True if line starts with a sentinel comment.

&gt;&gt;&gt; py_delims = comment_delims_from_extension('.py')
&gt;&gt;&gt; is_sentinel("#@+node",py_delims)
True
&gt;&gt;&gt; is_sentinel("#comment",py_delims)
False

&gt;&gt;&gt; c_delims = comment_delims_from_extension('.c')
&gt;&gt;&gt; is_sentinel("//@+node",c_delims)
True
&gt;&gt;&gt; is_sentinel("//comment",c_delims)
False

&gt;&gt;&gt; html_delims = comment_delims_from_extension('.html')
&gt;&gt;&gt; is_sentinel("&lt;!--@+node--&gt;",html_delims)
True
&gt;&gt;&gt; is_sentinel("&lt;!--comment--&gt;",html_delims)
False

"""</t>
<t tx="ekr.20040721151247"># The new code only writes tnodes for the current tree when pasting to the clipboard.</t>
<t tx="ekr.20040722043212">@killcolor

- p.isAncestorOf is used only in the move methods and in find.selectNextVnode.

- It is likely that the bug does not affect the move methods significantly.</t>
<t tx="ekr.20040722043212.1">exception executing command

Traceback (most recent call last):
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 166, in doCommand
    command()
  File "C:\prog\leoCVS\leo\src\leoCommands.py", line 2458, in findNext
    g.app.findFrame.findNextCommand(c)
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 230, in findNextCommand
    self.findNext()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 554, in findNext
    pos, newpos = self.findNextMatch()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 594, in findNextMatch
    v = self.v = self.selectNextVnode()
  File "c:\prog\leoCVS\leo\src\leoFind.py", line 743, in selectNextVnode
    if (c.suboutline_only_flag and self.onlyVnode and v and
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 1867, in isAncestorOf
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3133, in vParentWithStack
    return self.stack[n],n-1 # simulate popping the stack.

IndexError: list index out of range</t>
<t tx="ekr.20040722045721"></t>
<t tx="ekr.20040722045721.1">@killcolor

1.  Assignments.

find.selectNextVnode has several assignments like:

self.wrapVnode = v

However, this is _completely_ safe because the find code never calls p.moveToX.  Therefore, the assigned postion never changes!

Indeed, the code uses v.threadNext and v.threadBack, and these never change positions, they create new ones.


2. Assigning None to a possition.

This will work properly in all situations.

3.  Tests for equality against None

This should work properly.  p.__cmp__ allows tests against None.
</t>
<t tx="ekr.20040722052045"></t>
<t tx="ekr.20040722052045.1">@killcolor

We do _not_ have to make copies when assigning to an ivar because the find code never calls p.moveToX.

Furthermore, v.copy will fail if v is None.</t>
<t tx="ekr.20040722210735"></t>
<t tx="ekr.20040722211908">@killcolor

Apparently the code already intends to strip whitespace.  However, the old code has a bug that prevents this from happening.

Warning: changing from the old to the new code will change virtually every file.  I'm not sure I want to do this.  Maybe this is where the option should be implemented?

What about blank lines in doc parts?</t>
<t tx="ekr.20040723050246"></t>
<t tx="ekr.20040723054701"></t>
<t tx="ekr.20040723054701.1">@nocolor

A recent change omitted the call to setSelectionAreas.  This was wrong: it fails to update the body pane, so the change doesn't take.

The new code calls setSelectionAreas to update the body pane and setTextSelection to force an empty selection.</t>
<t tx="ekr.20040723093558">@

The caller should call g.stripBlankLines before calling this routine if desired.

This routine does _not_ simply call rstrip(): that would delete all trailing whitespace-only lines, and in some cases that would change the meaning of program or data.

@c

def regularizeTrailingNewlines(s,kind):
    
    """Kind is 'asis', 'zero' or 'one'."""
    
    pass</t>
<t tx="ekr.20040723093558.1">def stripBlankLines(s):
    
    lines = g.splitLines(s)

    for i in xrange(len(lines)):

        line = lines[i]
        j = g.skip_ws(line,0)
        if j &gt;= len(line):
            lines[i] = ''
            # g.trace("%4d %s" % (i,repr(lines[i])))
        elif line[j] == '\n':
            lines[i] = '\n'
            # g.trace("%4d %s" % (i,repr(lines[i])))
            
    return ''.join(lines)
</t>
<t tx="ekr.20040723093558.2"># These are the heart of a two new commands.</t>
<t tx="ekr.20040723094220"></t>
<t tx="ekr.20040723094220.1">def checkAllPythonCode(self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"

    for p in c.all_positions_iter():
        
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    return "surprise" # abort
                if unittest and result != "ok":
                    print "Syntax error in %s" % p.headString()
                    return result # End the unit test: it has failed.
            
    if not unittest:
        g.es("Check complete",color="blue")
        
    return result</t>
<t tx="ekr.20040723094220.2">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()</t>
<t tx="ekr.20040723094220.3">def checkPythonCode (self,unittest=False,ignoreAtIgnore=True):
    
    c = self ; count = 0 ; result = "ok"
    
    if not unittest:
        g.es("checking all Python code   ")
    
    for p in c.currentPosition().self_and_subtree_iter():
        
        count += 1
        if not unittest:
            &lt;&lt; print dots &gt;&gt;

        if g.scanForAtLanguage(c,p) == "python":
            if not ignoreAtIgnore or not g.scanForAtIgnore(c,p):
                try:
                    c.checkPythonNode(p,unittest)
                except (SyntaxError,tokenize.TokenError,tabnanny.NannyNag):
                    result = "error" # Continue to check.
                except:
                    return "surprise" # abort

    if not unittest:
        g.es("Check complete",color="blue")
        
    # We _can_ return a result for unit tests because we aren't using doCommand.
    return result</t>
<t tx="ekr.20040723094220.4">if count % 100 == 0:
    g.es('.',newline=False)

if count % 2000 == 0:
    g.enl()</t>
<t tx="ekr.20040723094220.5">def checkPythonNode (self,p,unittest=False):

    c = self
    
    h = p.headString()
    body = g.getScript(c,p.copy(),oneNodeOnly=True)
    if not body: return

    try:
        compiler.parse(body + '\n')
    except SyntaxError:
        if unittest:
            raise
        else:
            g.es("Syntax error in: %s" % h,color="blue")
            g.es_exception(full=False,color="black")
            p.setMarked()

    c.tabNannyNode(p,h,body,unittest)</t>
<t tx="ekr.20040723094220.6"># This code is based on tabnanny.check.

def tabNannyNode (self,p,headline,body,unittest=False):

    """Check indentation using tabnanny."""

    try:
        # readline = g.readLinesGenerator(body).next
        readline = g.readLinesClass(body).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError, msg:
        if unittest:
            raise
        else:
            g.es("Token error in %s" % headline,color="blue")
            g.es(str(msg))
            p.setMarked()

    except tabnanny.NannyNag, nag:
        if unittest:
            raise
        else:
            badline = nag.get_lineno()
            line    = nag.get_line()
            message = nag.get_msg()
            g.es("Indentation error in %s, line %d" % (headline, badline),color="blue")
            g.es(message)
            g.es("offending line:\n%s" % repr(str(line))[1:-1])
            p.setMarked()
        
    except:
        g.trace("unexpected exception")
        g.es_exception()
        if unittest: raise
</t>
<t tx="ekr.20040723094220.7"></t>
<t tx="ekr.20040725043937">def </t>
<t tx="ekr.20040725043937.1">@killcolor

Removed v.edit_text.

p.edit_text now just returns tree.edit_text.

I did this to avoid messing with edit_text in the outlines plugin.</t>
<t tx="ekr.20040730061923"># We must make sure that state is "normal" in p.setHeadStringOrHeadline.</t>
<t tx="ekr.20040730090103">@killcolor

The problem was in g.doHook("set-mark",c=self.c,v=self).

There was a _big_ performance bug in the nodenavigator plugin.</t>
<t tx="ekr.20040730162633"># Solution: openWriteFile must set self.root for the exception handling logic.

http://sourceforge.net/forum/message.php?msg_id=2654109

# @thin leo/4

errors writing: C:\prog\leoCVS\leo\test\leo\4
path does not exist: C:\prog\leoCVS\leo\test\leo
exception creating path:leo/4
Unexpected exception while writing @thin leo/4

Traceback (most recent call last):
    
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 731, in write
    try:    df.write(p,nosentinels=nosentinels,thinFile=thinFile,toString=toString,oneNodeOnly=oneNodeOnly)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 4766, in write
    ok = at.openWriteFile(root,toString)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2740, in openWriteFile
    self.writeError("exception creating path:" + fn)
  File "C:\prog\leoCVS\leo\src\leoAtFile.py", line 2347, in writeError
    self.root.setOrphan()
AttributeError: 'NoneType' object has no attribute 'setOrphan'
</t>
<t tx="ekr.20040730165221">@nocolor
@language html
http://sourceforge.net/forum/message.php?msg_id=2645776
By: billp9619

Yes this works now. However, the opposite should also be true ...that instead
of &lt;find_string&gt;&lt;/find_string&gt; an outside process or editor is free to change
it to &lt;find_string/&gt;. This currently causes Leo to fail to load the file reprting
it was looking for &lt;/find_string&gt;.

This is original Leo xml:

@color
&lt;preferences&gt; 
&lt;/preferences&gt;
&lt;find_panel_settings&gt;
&lt;find_string&gt;&lt;/find_string&gt;
&lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;
@nocolor

My xml editor automatically changed it to this:

@color
&lt;preferences/&gt; &lt;!-- was ok --&gt;
&lt;find_panel_settings&gt;
&lt;find_string/&gt; &lt;!-- now ok --&gt;
&lt;change_string/&gt; &lt;!-- now ok --&gt;
&lt;/find_panel_settings&gt;
@nocolor

Leo will not load the edited "/&gt;" type empty tags. 

Both forms of empty tags should always be accepted because it is officially
identical in meaning for xml.</t>
<t tx="ekr.20040730174218">@nocolor

- getOpenTag returns True if the end of the tag was seen. (It throws an exception if the tag isn't seen at all).

- Add comments in several places to make what getOpenTag clearer.

- getFindPanelSettings has allowed &lt;find_panel_settings/&gt; for some time.

- For compatibility with older versions of Leo, Leo still writes:

&lt;find_panel_settings&gt;
    &lt;find_string&gt;&lt;/find_string&gt;
    &lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;

- Leo now allows the &lt;find_string&gt; and &lt;change_string&gt; tags to be collapsed.  For example,

&lt;find_panel_settings&gt;
    &lt;find_string/&gt;
    &lt;change_string/&gt;
&lt;/find_panel_settings&gt;

- Changed getPrefs to allow &lt;preferences/&gt;

- Changed getGlobals to set reasonable defaults for &lt;globals/&gt;

- The &lt;leo_file&gt; and &lt;globals tags must not be terminated immediately.

- Leo writes &lt;defaultDirectory&gt; and &lt;TSyntaxMemo_options&gt; tags only if there is non-empty text between the opening and closing tags, so collapsing the tags is invalid.

- Therefore, the absolutely minimal .leo file is:

@color
@language html

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings/&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

@nocolor

I updated the empty_leo_file plugin to use this code.  This is also the contents test/minimalLeoFile.leo.

- The minimal .leo file that Leo might actually write is more like this:

@color

&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header/&gt;
&lt;globals/&gt;
&lt;preferences/&gt;
&lt;find_panel_settings&gt;
    &lt;find_string/&gt;
    &lt;change_string/&gt;
&lt;/find_panel_settings&gt;
&lt;vnodes/&gt;
&lt;tnodes/&gt;
&lt;/leo_file&gt;

This is the contents of test/minimalLeoFile2.leo.</t>
<t tx="ekr.20040730191553"></t>
<t tx="ekr.20040731053740"># Not a great test: it only tests visible nodes.
# This test may fail if a joined node is being editred.

if isTkinter:
    t = p.edit_text()
    if t:
        s = t.get("1.0","end")
        assert p.headString().strip() == s.strip(), "May fail if joined node is being edited"</t>
<t tx="ekr.20040731053740.1"></t>
<t tx="ekr.20040731055419"></t>
<t tx="ekr.20040731065422">def onClose (self):
    
    """Disable all attempts to close this frame with the close box."""
    
    pass</t>
<t tx="ekr.20040731070513">@nocolor

- Added a call to self.top.lift() in base run() method.

- Disable additional prompting dialogs if one is already open.</t>
<t tx="ekr.20040731070513.1">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2683931
By: billp9619

Using Win XP:

On closing an unsaved file with changes , a Confirm" message box pops up. The
Leo main outline is locked but this Confirm box could be underneath the
Outline...acting like an independent window(if outline receives focus again
by clicking on it, etc.) Normally applications force these type of prompts to
stay on top of the related appl. window.

The above can can be confusing.  But it can be worse.

If I right click on the Leo icon on the task bar and select "Close" (say I am
confused now), what happens is it pops up another Confirm box.

After closing ...the extra Confirm boxes are left behind with no associated
Leo outline.

Leo Log Window...
Leo 4.2 beta 2, build  1.128 , July 5, 2004
Python 2.3.4, Tk 8.4.3, win32</t>
<t tx="ekr.20040731071037">def initIvars(self):

    &lt;&lt; initialize ivars &gt;&gt;
    self.setIvarsFromFind()</t>
<t tx="ekr.20040731082738">@killcolor

This was tricky to get correct. The aha is that we must compute line numbers for
SyntaxErrors differently from other errors.

The traceback methods are very strange in this regard. For SyntaxError's,
format_exception_only computes the line number. For all other errors, extract_tb
gives the proper line number. It took a _long_ time to figure this out...

In the end, the calculations in getLastTracebackLineNumber are fairly
straightforward. In particular, it unpacks the line number for SyntaxErrors
using code lifted directly from format_exception_only.</t>
<t tx="ekr.20040731084117"></t>
<t tx="ekr.20040731204831">def getLastTracebackLineNumber():
    
    typ,val,tb = sys.exc_info()
    
    if typ is exceptions.SyntaxError:
        # Syntax errors are a special case.
        # extract_tb does _not_ return the proper line number!
        # This code similar to the code in format_exception_only(!!)
        try:
            msg,(filename, lineno, offset, line) = val
            return lineno
        except:
            g.trace("bad line number")
            return 0

    else:
        # The proper line number is the second element in the last tuple.
        data = traceback.extract_tb(tb)
        item = data[-1]
        n = item[1]
        return n</t>
<t tx="ekr.20040731211839">errList = traceback.format_exception(typ,val,tb)

print ; print "es_exception (format_exception)"
for item in errList:
    print item
# Strip cruft lines.
s1 = "Traceback (most recent call last):"
s2 = "exec script in {}"
lines = []
for line in errList[-4:]:
    if n is None:
        tag = 'File "&lt;string&gt;", line'
        i = line.find(tag)
        if i &gt; -1:
            &lt;&lt; compute n from the line &gt;&gt;
    if not g.match(line,0,s1) and line.find(s2) == -1:
        lines.append(line)</t>
<t tx="ekr.20040801054717"></t>
<t tx="ekr.20040802063546"></t>
<t tx="ekr.20040802064903.2">@killcolor
http://sourceforge.net/forum/message.php?msg_id=2692347

+headline
++@thin a
++@thin b

I changed the headline, then saved the leo. apparently
the @thins in the subnode weren't marked dirty.
on next open I got a bunch of
getLeoFile: can not find tnode: gnx = leo4u.20040614190317
...
click on the @thin was empty, then it became a subnode of itself.
all without the leo marked as modifyed!

is the bug is that headline changes don't mark subnodes dirty?
I know edits in parent bodys now do, 
even if nothing should change in the @thin or @file.
now I see why.

in the @thin
#@+node:leo4u.20040730175028.1:@thin a.py

in the leo
&lt;v t="leo4u.20040511113712"
marks="leo4u.20040728143234.3,leo4u.20040728143234.4,leo4u.20040728143234.5,"
expanded="leo4u.20040614190317,leo4u.20040728160724,leo4u.20040728143234,leo4u.2
0040728143234.2,"&gt;&lt;vh&gt;@thin a.py&lt;/vh&gt;&lt;/v&gt;

from cvs the other day.
Leo 4.2 beta 2, build  1.141 , July 5, 2004
Python 2.3.3, Tk 8.4.3, win32</t>
<t tx="ekr.20040802082208"></t>
<t tx="ekr.20040802100054">@killcolor

- Copied the code from the leoPlugins.leo.
- Removed all clones in project section to the old code.</t>
<t tx="ekr.20040802100609"># This prevents redundant warnings during mass updates.</t>
<t tx="ekr.20040803072955.91">def idle_head_key (self,p,ch=None):
    
    """Update headline text at idle time."""
    
    c = self.c

    if not p or p != c.currentPosition():
        return "break"
        
    edit_text = self.edit_text(p)
    index = edit_text.index("insert")

    if g.doHook("headkey1",c=c,p=p,ch=ch):
        return "break" # The hook claims to have handled the event.
        
    &lt;&lt; set head to vnode text &gt;&gt;
    done = ch in ('\r','\n')
    if done:
        &lt;&lt; set the widget text to head &gt;&gt;
    &lt;&lt; set s to the widget text &gt;&gt;
    changed = s != head
    if changed:
        c.undoer.setUndoParams("Change Headline",p,newText=s,oldText=head)
        &lt;&lt; update p &gt;&gt;
    if done or changed:
        &lt;&lt; reconfigure p and all nodes joined to p &gt;&gt;
        &lt;&lt; update the screen &gt;&gt;

    g.doHook("headkey2",c=c,p=p,ch=ch)
    return "break"</t>
<t tx="ekr.20040803072955.92">head = p.headString()
if head == None:
    head = u""
head = g.toUnicode(head,"utf-8")</t>
<t tx="ekr.20040803072955.93">self.setText(edit_text,head,tag="idle_head_key")
edit_text.mark_set("insert",index)</t>
<t tx="ekr.20040803072955.94">s = edit_text.get("1.0","end")

# Don't truncate if the user is hitting return.
# That should just end editing.
if 1:
    # Truncate headline text to workaround Tk problems...
    # Another kludge: remove one or two trailing newlines before warning of truncation.
    if s and s[-1] == '\n': s = s[:-1]
    if s and s[-1] == '\n': s = s[:-1]
    i = s.find('\n')
    if i &gt; -1:
        # g.trace(i,len(s),repr(s))
        g.es("Truncating headline to one line",color="blue")
        s = s[:i]
    if len(s) &gt; 250:
        g.es("Truncating headline to 250 characters",color="blue")
        s = s[:250]

s = g.toUnicode(s,g.app.tkEncoding)

if not s:
    s = u""
    
if 0: # 6/10/04: No longer needed.  This was stressing Tk needlessly.
    s = s.replace('\n','')
    s = s.replace('\r','')</t>
<t tx="ekr.20040803072955.95">c.beginUpdate()
if 1: # update...
    # Update changed bit.
    if not c.changed:
        c.setChanged(True)
    # Update all dirty bits.
    # Bug fix 8/2/04: must call p.setDirty even if p is dirty!
    p.setDirty()
    # Update p.
    p.initHeadString(s)
    self.setText(edit_text,s,tag="idle_head_key2")
    edit_text.mark_set("insert",index)
c.endUpdate(False) # do not redraw now.</t>
<t tx="ekr.20040803072955.96"># Reconfigure p's headline.
if done:
    self.setDisabledLabelState(p)

edit_text.configure(width=self.headWidth(p))</t>
<t tx="ekr.20040803072955.97">if done:
    # g.trace("done")
    c.beginUpdate()
    self.endEditLabel()
    c.endUpdate()

elif changed:
    # g.trace("changed")
    # Update p immediately.  Joined nodes are redrawn later by endEditLabel.
    # Redrawing the whole screen now messes up the cursor in the headline.
    self.drawIcon(p) # just redraw the icon.</t>
<t tx="ekr.20040803082633"></t>
<t tx="ekr.20040803082633.1"></t>
<t tx="ekr.20040803084520">@killcolor

New in 4.0:  &lt;v&gt; elements corresponding to @file nodes now contain tnodeList attributes.  The tnodeList attribute allows the read code in leoAtFile.py to recreate the order in which nodes should appear in the outline.  The tnodeList attribute is a list of gnx's: global node indices for tnodes.

N.B. Leo does _not_ write tnodeList attributes for @thin trees: @thin trees contain gnx's in each node.

N.B. tnodeList are _created_ by the atFile code but _written_ by the fileCommands code (to the .leo file).  Therefore, we must make SURE to autoSave .leo files whenever any @file node is written.

***** Possible bug.  The present code in putVnode DOES write tnodeList attributes for @thin tree.
THIS MAKES NO SENSE!!!!  Instead, the code should clear the tnodeList instead of writing it!

** When atFile classes are unified, it would make sense to clear root.v.t.tnodeList before _all_ writes.

Writing:

- atFile.old_df.write removes the tnodeList if it exist.
    - tnodeList is not needed in old-style derived files.
    - ????? WHY DOESN'T THIS SOLVE ALL tnodeList PROBLEMS ?????
- new_df.writeOpenFile sets at.root.v.t.tnodeList = [] initially.
- new_df.write _clears_ this after writing to a string.
    - ????? This caused problems when executing scripts, BUT WHY ?????
- atFile.new_df.putOpenNodeSentinel appends the tnode of the node being written to this list.
- top_df.writeAll returns mustAutoSave if any @file node was written.
    writing an @thin node does _not_ set mustAutoSave.

Reading:

- atFile.findChild returns the next tnode on this list.</t>
<t tx="ekr.20040803091155">@nocolor

A MAJOR change: putVnode doesn't put tnodeLists for @thin nodes.

Instead it issues an informational message and deletes the tnodeList.

@color</t>
<t tx="ekr.20040803100035"></t>
</tnodes>
</leo_file>
