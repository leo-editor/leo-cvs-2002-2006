<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="6289" clone_windows="0"/>
<globals body_outline_ratio="0.61487236404">
	<global_window_position top="9" left="464" height="901" width="776"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="EKR.20040519090151"><vh>Diary</vh>
<v t="ekr.20031218072017"><vh>@thin ../doc/leoDiary.txt</vh></v>
</v>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"
marks="ekr.20040701152235.15,ekr.20040701152235.16,"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20031218072017.828,ekr.20031218072017.734,ekr.20040831092540,ekr.20031218072017.1863,"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>signOnWithVersion</vh></v>
</v>
<v t="ekr.20031218072017.2415"><vh> Scripts</vh>
<v t="ekr.20040327103735.2"><vh>Script Tools (leoGlobals.py)</vh>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20040321065415"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
</v>
<v t="EKR.20040502195524"><vh>@thin ../scripts/leoScripts.txt</vh></v>
<v t="EKR.20040502194930"><vh>@thin ../scripts/tangle_done.py</vh></v>
<v t="ekr.20031218072017.2537"><vh>@thin ../scripts/untangle_done.py</vh></v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,ekr.20031218072017.2865,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20031218072017.3001"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"
marks="ekr.20031218072017.1863,"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20031218072017.3626"><vh>@thin leoColorPanel.py</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3652"><vh>@thin leoFontPanel.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3812"><vh>@thin leoPrefs.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3822"><vh>@thin leoTkinterColorPanels.py</vh></v>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3909"><vh>@thin leoTkinterFontPanel.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20031218072017.4122"><vh>@thin leoTkinterPrefs.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
<v t="ekr.20041006103243" a="E"><vh>Talk</vh>
<v t="ekr.20041006104224"><vh>Intro</vh>
<v t="ekr.20041006104224.1"><vh>Emotion: get across my excitement</vh></v>
<v t="ekr.20041006104224.2"><vh>Story: ski trip</vh></v>
</v>
<v t="ekr.20041006105206"><vh>Overview</vh>
<v t="ekr.20041006103243.2"><vh>1. Leo organizes everything as an outline</vh>
<v t="ekr.20041006103243.3"><vh>Outlines may contains huge amounts of data</vh></v>
<v t="ekr.20041006103243.4"><vh>Leo's nodes contain headlines and body text</vh></v>
<v t="ekr.20041006103243.5"><vh>Leo has many tools for creating oultine nodes from existing text</vh></v>
</v>
<v t="ekr.20041006103243.6"><vh>2.  Outlines create derived files</vh>
<v t="ekr.20041006105206.2" a="E"><vh>Leo embeds structure within "flat" derived files</vh></v>
<v t="ekr.20041006110548"><vh>Structure is contained within OPTIONAL sentinel comments</vh></v>
</v>
<v t="ekr.20041006105206.1"><vh>3.  Leo lets you organize projects as YOU want</vh></v>
</v>
<v t="ekr.20041006104224.3"><vh>Practice:  Look and feel</vh>
<v t="ekr.20041006103243.21"><vh>Outlines organize programs</vh>
<v t="ekr.20041006105452"><vh>Example 1: outlines organize methods</vh>
<v t="ekr.20031218072017.889"><vh>class position</vh>
<v t="ekr.20031218072017.890"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040228094013"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20040117170612"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__</vh></v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040310153624"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20040325142015"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="ekr.20040306212636"><vh>Getters</vh>
<v t="ekr.20040306210951"><vh> vnode proxies</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20040306212151"><vh>p.Extra Attributes</vh></v>
<v t="ekr.20040306220230"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20040306214401"><vh>p.Status bits</vh></v>
<v t="ekr.20040306220230.1"><vh>p.edit_text</vh></v>
<v t="ekr.20040323160302"><vh>p.directParents</vh></v>
<v t="ekr.20040326064330"><vh>p.childIndex</vh></v>
</v>
<v t="ekr.20040306214240.2"><vh>children</vh>
<v t="ekr.20040306214240.3"><vh>p.hasChildren</vh></v>
<v t="ekr.20040306212636.1"><vh>p.numberOfChildren</vh></v>
</v>
<v t="ekr.20040307104131.3"><vh>p.exists</vh></v>
<v t="ekr.20040306215548"><vh>p.findRoot</vh></v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20040227212621"><vh>p.hasX</vh>
<v t="ekr.20040227224946"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20040307104131.1"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040803111240"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20040803140033.4"><vh>isCurrentPosition</vh></v>
<v t="ekr.20040803140033.5"><vh>isRootPosition</vh></v>
</v>
<v t="ekr.20040306215056"><vh>p.isCloned</vh></v>
<v t="ekr.20040307104131.2"><vh>p.isRoot</vh></v>
<v t="ekr.20040117162509.16"><vh>p.isVisible</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20040305222924"><vh>Setters</vh>
<v t="ekr.20040306220634"><vh>vnode proxies</vh>
<v t="ekr.20040306220634.9"><vh> Status bits</vh></v>
<v t="ekr.20040306220634.8"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20040306220634.29"><vh>p.setSelection</vh></v>
<v t="ekr.20040306220634.31"><vh>p.trimTrailingLines</vh></v>
<v t="ekr.20040315034158"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20040315031401"><vh>Head &amp; body text (position)</vh>
<v t="ekr.20040315032503"><vh>p.appendStringToBody</vh></v>
<v t="ekr.20040305223522"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20040305222924.1"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20040305223225"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="ekr.20040315031445"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20040312015908"><vh>Visited bits</vh>
<v t="ekr.20040312015705"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="ekr.20040315023430"><vh>File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>moreBody</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.12"><vh>p.sortChildren</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040228094013.1"><vh>p.utils...</vh>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20040409203454"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
</v>
<v t="ekr.20041006105452.1"><vh>The @others directive refers to all unnamed descendents</vh></v>
</v>
<v t="ekr.20041006105452.2"><vh>Example 2: sections clarify complex code</vh>
<v t="ekr.20041006103243.22"><vh>tree.select</vh>
<v t="ekr.20041006103243.23"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20041006103243.24"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20041006103243.25"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20041006103243.26"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20041006103243.27"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20041006105452.3"><vh>sections must be defined in a descendent node</vh></v>
<v t="ekr.20041006105452.4"><vh>sections work like macros</vh></v>
</v>
</v>
<v t="ekr.20041006105206.4"><vh>Outlines organize data</vh>
<v t="ekr.20041006103243.28"><vh>&lt;&lt; define colorizer keywords &gt;&gt; colorizer</vh>
<v t="ekr.20041006103243.29"><vh>actionscript keywords</vh></v>
<v t="ekr.20041006103243.30"><vh>c# keywords</vh></v>
<v t="ekr.20041006103243.31"><vh>c/c++ keywords</vh></v>
<v t="ekr.20041006103243.32"><vh>css keywords</vh></v>
<v t="ekr.20041006103243.33"><vh>elisp keywords</vh></v>
<v t="ekr.20041006103243.34"><vh>html keywords</vh></v>
<v t="ekr.20041006103243.35"><vh>java keywords</vh></v>
<v t="ekr.20041006103243.36"><vh>latex keywords</vh></v>
<v t="ekr.20041006103243.37"><vh>pascal keywords</vh></v>
<v t="ekr.20041006103243.38"><vh>perl keywords</vh></v>
<v t="ekr.20041006103243.39"><vh>php keywords</vh></v>
<v t="ekr.20041006103243.40"><vh>python keywords</vh></v>
<v t="ekr.20041006103243.41"><vh>rapidq keywords</vh></v>
<v t="ekr.20041006103243.42"><vh>rebol keywords</vh></v>
<v t="ekr.20041006103243.43"><vh>shell keywords</vh></v>
<v t="ekr.20041006103243.44"><vh>tcl/tk keywords</vh></v>
</v>
</v>
<v t="ekr.20041006103243.8"><vh>Clones allow multiple views of data within a SINGLE outline</vh>
<v t="ekr.20041006103243.9"><vh>(Added option to disable left click logic in outline pane)</vh>
<v t="ekr.20041006103243.10"><vh>Notes</vh></v>
<v t="ekr.20041006103243.11"><vh>__init__</vh>
<v t="ekr.20041006103243.12"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20041006103243.13"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20041006103243.14"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20041006103243.15"><vh>createPermanentBindings</vh></v>
<v t="ekr.20041006103243.16" a="M"><vh>newBox</vh></v>
<v t="ekr.20041006103243.17" a="M"><vh>drawClickBox</vh>
<v t="ekr.20041006103243.18"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20041006103243.45" a="E"><vh>Leo is a browser with a memory</vh>
<v t="ekr.20041006110548.1"><vh>NewHeadline</vh></v>
</v>
<v t="ekr.20041006103243.46"><vh>Leo's Execute Script command understands directives and sections</vh>
<v t="ekr.20041006103243.47" a="E"><vh>Leo's @directives are valid in scripts</vh></v>
<v t="ekr.20041006103243.48"><vh>Leo's sections are vaiid in scripts</vh>
<v t="ekr.20041006103243.49"><vh>getFontSettings</vh></v>
<v t="ekr.20041006104908"><vh>&lt;&lt; print font of body pane &gt;&gt;</vh></v>
<v t="ekr.20041006104908.1"><vh>&lt;&lt; print font of log pane &gt;&gt;</vh></v>
<v t="ekr.20041006104908.2"><vh>&lt;&lt; print font of tree pane &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20041006104224.6"><vh>Theory:  why Leo is important</vh>
<v t="ekr.20041006103243.51"><vh>Outlines create a framework for metadata as well as data</vh>
<v t="ekr.20041006104908.3"><vh>Similar to power of complex numbers</vh></v>
</v>
<v t="ekr.20041006103243.52"><vh>Structure is  co-equal with program and data</vh>
<v t="ekr.20041006103243.54" a="E"><vh>Programs are outlines &amp; vice versa</vh>
<v t="ekr.20031218072017.889"><vh>class position</vh>
<v t="ekr.20031218072017.890"><vh>&lt;&lt; about the position class &gt;&gt;</vh></v>
<v t="ekr.20040228094013"><vh> ctor &amp; other special methods...</vh>
<v t="ekr.20031218072017.893"><vh>p.__cmp__</vh></v>
<v t="ekr.20040117170612"><vh>p.__getattr__  ON:  must be ON if use_plugins</vh></v>
<v t="ekr.20031218072017.892"><vh>p.__init__</vh></v>
<v t="ekr.20040117173448"><vh>p.__nonzero__</vh></v>
<v t="ekr.20040301205720"><vh>p.__str__ and p.__repr__</vh></v>
<v t="ekr.20040117171654"><vh>p.copy</vh></v>
<v t="ekr.20040310153624"><vh>p.dump &amp; p.vnodeListIds</vh></v>
<v t="ekr.20040325142015"><vh>p.equal &amp; isEqual</vh></v>
</v>
<v t="ekr.20040306212636"><vh>Getters</vh>
<v t="ekr.20040306210951"><vh> vnode proxies</vh>
<v t="ekr.20040306211032"><vh>p.Comparisons</vh></v>
<v t="ekr.20040306212151"><vh>p.Extra Attributes</vh></v>
<v t="ekr.20040306220230"><vh>p.Headline &amp; body strings</vh></v>
<v t="ekr.20040306214401"><vh>p.Status bits</vh></v>
<v t="ekr.20040306220230.1"><vh>p.edit_text</vh></v>
<v t="ekr.20040323160302"><vh>p.directParents</vh></v>
<v t="ekr.20040326064330"><vh>p.childIndex</vh></v>
</v>
<v t="ekr.20040306214240.2"><vh>children</vh>
<v t="ekr.20040306214240.3"><vh>p.hasChildren</vh></v>
<v t="ekr.20040306212636.1"><vh>p.numberOfChildren</vh></v>
</v>
<v t="ekr.20040307104131.3"><vh>p.exists</vh></v>
<v t="ekr.20040306215548"><vh>p.findRoot</vh></v>
<v t="ekr.20031218072017.915"><vh>p.getX &amp; vnode compatibility traversal routines</vh></v>
<v t="ekr.20040227212621"><vh>p.hasX</vh>
<v t="ekr.20040227224946"><vh>hasThreadNext (the only complex hasX method)</vh></v>
</v>
<v t="ekr.20040307104131.1"><vh>p.isAncestorOf</vh></v>
<v t="ekr.20040803111240"><vh>p.isCurrentPosition &amp; isRootPosition</vh>
<v t="ekr.20040803140033.4"><vh>isCurrentPosition</vh></v>
<v t="ekr.20040803140033.5"><vh>isRootPosition</vh></v>
</v>
<v t="ekr.20040306215056"><vh>p.isCloned</vh></v>
<v t="ekr.20040307104131.2"><vh>p.isRoot</vh></v>
<v t="ekr.20040117162509.16"><vh>p.isVisible</vh></v>
<v t="ekr.20031218072017.4146"><vh>p.lastVisible &amp; oldLastVisible</vh></v>
<v t="ekr.20040227214711"><vh>p.level &amp; simpleLevel</vh></v>
</v>
<v t="ekr.20040305222924"><vh>Setters</vh>
<v t="ekr.20040306220634"><vh>vnode proxies</vh>
<v t="ekr.20040306220634.9"><vh> Status bits</vh></v>
<v t="ekr.20040306220634.8"><vh>p.computeIcon &amp; p.setIcon</vh></v>
<v t="ekr.20040306220634.29"><vh>p.setSelection</vh></v>
<v t="ekr.20040306220634.31"><vh>p.trimTrailingLines</vh></v>
<v t="ekr.20040315034158"><vh>p.setTnodeText</vh></v>
</v>
<v t="ekr.20040315031401"><vh>Head &amp; body text (position)</vh>
<v t="ekr.20040315032503"><vh>p.appendStringToBody</vh></v>
<v t="ekr.20040305223522"><vh>p.setBodyStringOrPane &amp; p.setBodyTextOrPane</vh></v>
<v t="ekr.20040305222924.1"><vh>p.setHeadString &amp; p.initHeadString</vh></v>
<v t="ekr.20040305223225"><vh>p.setHeadStringOrHeadline</vh></v>
<v t="ekr.20040315031445"><vh>p.scriptSetBodyString</vh></v>
</v>
<v t="ekr.20040312015908"><vh>Visited bits</vh>
<v t="ekr.20040312015705"><vh>p.clearAllVisited</vh></v>
<v t="ekr.20040306220634.17"><vh>p.clearVisitedInTree</vh></v>
<v t="ekr.20031218072017.3388"><vh>p.clearAllVisitedInTree (4.2)</vh></v>
</v>
<v t="ekr.20040305162628"><vh>p.Dirty bits</vh>
<v t="ekr.20040311113514"><vh>p.clearDirty</vh></v>
<v t="ekr.20040318125934"><vh>p.findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040303214038"><vh>p.setAllAncestorAtFileNodesDirty</vh></v>
<v t="ekr.20040303163330"><vh>p.setDirty</vh></v>
<v t="ekr.20040702104823"><vh>p.inAtIgnoreRange</vh></v>
</v>
</v>
<v t="ekr.20040315023430"><vh>File Conversion</vh>
<v t="ekr.20040315023430.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315023430.2"><vh>moreHead</vh></v>
<v t="ekr.20040315023430.3"><vh>moreBody</vh></v>
</v>
<v t="ekr.20040305162628.1"><vh>p.Iterators</vh>
<v t="EKR.20040529103843"><vh>p.tnodes_iter &amp; unique_tnodes_iter</vh></v>
<v t="EKR.20040529103945"><vh>p.vnodes_iter &amp; unique_vnodes_iter</vh></v>
<v t="ekr.20040305171133"><vh>p.allNodes_iter</vh>
<v t="ekr.20040305171133.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305171133.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305173559"><vh>p.subtree_iter</vh>
<v t="ekr.20040305173559.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173559.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305172211.1"><vh>p.children_iter</vh>
<v t="ekr.20040305172211.2"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172211.3"><vh>next</vh></v>
</v>
<v t="ekr.20040305172855"><vh>p.parents_iter</vh>
<v t="ekr.20040305172855.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305172855.2"><vh>next</vh></v>
</v>
<v t="ekr.20040305173343"><vh>p.siblings_iter</vh>
<v t="ekr.20040305173343.1"><vh>__init__ &amp; __iter__</vh></v>
<v t="ekr.20040305173343.2"><vh>next</vh></v>
</v>
</v>
<v t="ekr.20040303175026"><vh>p.Moving, Inserting, Deleting, Cloning, Sorting (position)</vh>
<v t="ekr.20040303175026.2"><vh>p.doDelete</vh></v>
<v t="ekr.20040303175026.3"><vh>p.insertAfter</vh></v>
<v t="ekr.20040303175026.4"><vh>p.insertAsLastChild</vh></v>
<v t="ekr.20040303175026.5"><vh>p.insertAsNthChild</vh></v>
<v t="ekr.20040303175026.6"><vh>p.moveToRoot</vh></v>
<v t="ekr.20040303175026.8"><vh>p.clone</vh></v>
<v t="ekr.20040303175026.9"><vh>p.copyTreeAfter, copyTreeTo</vh></v>
<v t="ekr.20040303175026.10"><vh>p.moveAfter</vh></v>
<v t="ekr.20040306060312"><vh>p.moveToLastChildOf</vh></v>
<v t="ekr.20040303175026.11"><vh>p.moveToNthChildOf</vh></v>
<v t="ekr.20040303175026.12"><vh>p.sortChildren</vh></v>
<v t="ekr.20040303175026.13"><vh>p.validateOutlineWithParent</vh>
<v t="ekr.20040303175026.14"><vh>&lt;&lt; validate parent ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.15"><vh>&lt;&lt; validate childIndex ivar &gt;&gt;</vh></v>
<v t="ekr.20040303175026.16"><vh>&lt;&lt; validate x ivar &gt;&gt;</vh></v>
</v>
<v t="ekr.20040310062332.1"><vh>p.invalidOutline</vh></v>
</v>
<v t="ekr.20031218072017.928"><vh>p.moveToX</vh>
<v t="ekr.20031218072017.930"><vh>p.moveToBack</vh></v>
<v t="ekr.20031218072017.931"><vh>p.moveToFirstChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.932"><vh>p.moveToLastChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.933"><vh>p.moveToLastNode (Big improvement for 4.2)</vh></v>
<v t="ekr.20031218072017.934"><vh>p.moveToNext</vh></v>
<v t="ekr.20031218072017.935"><vh>p.moveToNodeAfterTree</vh></v>
<v t="ekr.20031218072017.936"><vh>p.moveToNthChild (pushes stack for cloned nodes)</vh></v>
<v t="ekr.20031218072017.937"><vh>p.moveToParent (pops stack when multiple parents)</vh></v>
<v t="ekr.20031218072017.938"><vh>p.moveToThreadBack</vh></v>
<v t="ekr.20031218072017.939"><vh>p.moveToThreadNext</vh></v>
<v t="ekr.20031218072017.940"><vh>p.moveToVisBack</vh></v>
<v t="ekr.20031218072017.941"><vh>p.moveToVisNext</vh></v>
</v>
<v t="ekr.20040228094013.1"><vh>p.utils...</vh>
<v t="ekr.20040228060340"><vh>p.vParentWithStack</vh>
<v t="ekr.20040228060340.1"><vh>&lt;&lt; about the vParentWithStack utility method &gt;&gt;</vh></v>
</v>
<v t="ekr.20040409203454"><vh>p.restoreLinksInTree</vh></v>
<v t="ekr.20040409203454.1"><vh>p.deleteLinksInTree &amp; allies</vh>
<v t="ekr.20040410170806"><vh>p.deleteLinksInSubtree</vh></v>
<v t="ekr.20040410170806.1"><vh>p.adjustParentLinksInSubtree</vh></v>
</v>
</v>
<v t="ekr.20040310062332"><vh>p.Link/Unlink methods</vh>
<v t="ekr.20040310062332.2"><vh>p.linkAfter</vh></v>
<v t="ekr.20040310062332.3"><vh>p.linkAsNthChild</vh></v>
<v t="ekr.20040310062332.4"><vh>p.linkAsRoot</vh></v>
<v t="ekr.20040310062332.5"><vh>p.unlink</vh></v>
</v>
</v>
</v>
<v t="ekr.20041006103243.179"><vh>Data are outlines &amp; vice versa</vh>
<v t="EKR.20040619133116"><vh>Unit testing...</vh>
<v t="ekr.20040327114250" tnodeList="ekr.20040327114250"><vh>@file c:\prog\test\unittest\batchTest.py</vh></v>
<v t="ekr.20040712101754"><vh>Unit Tests</vh>
<v t="ekr.20040716144017"><vh>Perfect Import tests</vh>
<v t="ekr.20040716071029.6"><vh>@test inserting a line: no trailing newline</vh>
<v t="ekr.20040716071856.1"><vh>-input</vh></v>
<v t="ekr.20040716081019"><vh>-input-after</vh></v>
<v t="ekr.20040716071856"><vh>-output-sent</vh></v>
<v t="ekr.20040716091245"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716084934"><vh>-i_lines</vh></v>
<v t="ekr.20040716084934.1"><vh>-j_lines</vh></v>
<v t="ekr.20040716081943"><vh>-result</vh></v>
</v>
<v t="ekr.20040716140926"><vh>@test replace one line</vh>
<v t="ekr.20040716140926.1"><vh>-input</vh></v>
<v t="ekr.20040716140926.2"><vh>-input-after</vh></v>
<v t="ekr.20040716140926.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716140926.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716140926.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716140926.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716140926.7"><vh>-result</vh></v>
</v>
<v t="ekr.20040716141621"><vh>@test replace multiple lines</vh>
<v t="ekr.20040716141621.1"><vh>-input</vh></v>
<v t="ekr.20040716141621.2"><vh>-input-after</vh></v>
<v t="ekr.20040716141621.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716141621.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716141621.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716141621.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716141621.7"><vh>-result</vh></v>
</v>
<v t="ekr.20040716142121"><vh>@test replace across sentinel blocks: Succeeds ONLY when ignoring sentinels</vh>
<v t="ekr.20040716142423"><vh>-input</vh>
<v t="ekr.20040716142423.1"><vh>Node 1</vh></v>
<v t="ekr.20040716142423.2"><vh>Node 2</vh></v>
</v>
<v t="ekr.20040716142121.2"><vh>-input-after</vh>
<v t="ekr.20040717071133"><vh>Node 1</vh></v>
<v t="ekr.20040717071133.1"><vh>Node 2</vh></v>
</v>
<v t="ekr.20040716142121.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716142121.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716142121.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716142121.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716142121.7"><vh>-result</vh></v>
</v>
</v>
<v t="ekr.20040712101754.7"><vh>Import/Export tests</vh>
<v t="ekr.20040712101754.8"><vh>@suite Import tests</vh></v>
<v t="ekr.20040712101754.9"><vh>@suite Export tests</vh></v>
<v t="ekr.20040712101754.10"><vh>importTests</vh>
<v t="ekr.20040712101754.11"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.12"><vh>importAtRoot</vh>
<v t="ekr.20040712101754.13"><vh>dialog</vh></v>
</v>
<v t="ekr.20040831095833"><vh>importDerivedFile</vh>
<v t="ekr.20040831095833.1"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.16"><vh>importNowebFiles</vh>
<v t="ekr.20040712101754.17"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.18"><vh>importFlattenedOutline</vh>
<v t="ekr.20040712101754.19"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.20"><vh>importCWEBFiles</vh>
<v t="ekr.20040712101754.21"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.22"><vh>removeSentinels</vh>
<v t="ekr.20040712101754.23"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.14"><vh>importAtFile</vh>
<v t="ekr.20040712101754.15"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040712101754.24"><vh>exportTests</vh>
<v t="ekr.20040712101754.25"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.26"><vh>exportHeadlines</vh>
<v t="ekr.20040712101754.27"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.28"><vh>flattenOutline</vh>
<v t="ekr.20040712101754.29"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.30"><vh>weave</vh>
<v t="ekr.20040712101754.31"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.32"><vh>outlineToNoweb</vh>
<v t="ekr.20040712101754.33"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.34"><vh>outlineToCWEB</vh>
<v t="ekr.20040712101754.35"><vh>dialog</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.2"><vh>Test Leo files...</vh>
<v t="ekr.20040730181601"><vh>@test minimalLeoFile.leo</vh></v>
<v t="ekr.20040730181610"><vh>@test minimalLeoFile2.leo</vh></v>
<v t="ekr.20040831104758"><vh>@test minimalLeoFile3.leo</vh></v>
<v t="ekr.20040712101754.3"><vh>@test test.leo</vh></v>
<v t="ekr.20040803090901"><vh>@test leoDist.leo</vh></v>
<v t="ekr.20040712101754.4"><vh>@test LeoPy.leo</vh></v>
<v t="ekr.20040712101754.5"><vh>@test leoPlugins.leo</vh></v>
<v t="ekr.20040712101754.6"><vh>@test LeoDocs.leo</vh></v>
<v t="ekr.20040831101747"><vh>@test line endings of Linux scripts</vh></v>
</v>
<v t="ekr.20040712101754.36"><vh>Non-file tests</vh>
<v t="ekr.20040712101754.37"><vh>@suite Edit body tests</vh>
<v t="ekr.20040712101754.38"><vh>editBodyTests</vh>
<v t="ekr.20040712101754.39"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.40"><vh>extractSection</vh>
<v t="ekr.20040712101754.41"><vh>before</vh></v>
<v t="ekr.20040712101754.42"><vh>after</vh>
<v t="ekr.20040712101754.43"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040712101754.44"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.45"><vh>indentBody</vh>
<v t="ekr.20040712101754.46"><vh>before</vh></v>
<v t="ekr.20040712101754.47"><vh>after</vh></v>
<v t="ekr.20040712101754.48"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.49"><vh>dedentBody</vh>
<v t="ekr.20040712101754.50"><vh>before</vh></v>
<v t="ekr.20040712101754.51"><vh>after</vh></v>
<v t="ekr.20040712101754.52"><vh>selection</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.53"><vh>@suite Reformat Paragraph Tests</vh>
<v t="ekr.20040712101754.54"><vh>What I did</vh></v>
<v t="ekr.20040712101754.55"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040712101754.56"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.57"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040712101754.58"><vh>before</vh></v>
<v t="ekr.20040712101754.59"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.60"><vh>testTrailingNewline</vh>
<v t="ekr.20040712101754.61"><vh>before</vh></v>
<v t="ekr.20040712101754.62"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.63"><vh>testMixedLineLengths</vh>
<v t="ekr.20040712101754.64"><vh>before</vh></v>
<v t="ekr.20040712101754.65"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.66"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040712101754.67"><vh>before</vh></v>
<v t="ekr.20040712101754.68"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.69"><vh>testNoChangeRequired</vh>
<v t="ekr.20040712101754.70"><vh>before</vh></v>
<v t="ekr.20040712101754.71"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.72"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040712101754.73"><vh>before</vh></v>
<v t="ekr.20040712101754.74"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.75"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040712101754.76"><vh>before</vh></v>
<v t="ekr.20040712101754.77"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.78"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040712101754.79"><vh>before</vh></v>
<v t="ekr.20040712101754.80"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.81"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040712101754.82"><vh>before</vh></v>
<v t="ekr.20040712101754.83"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.84"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040712101754.85"><vh>before</vh></v>
<v t="ekr.20040712101754.86"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.87"><vh>testMultiParagraph</vh>
<v t="ekr.20040712101754.88"><vh>before</vh></v>
<v t="ekr.20040712101754.89"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.90"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040712101754.91"><vh>before</vh></v>
<v t="ekr.20040712101754.92"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.93"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040712101754.94"><vh>before</vh></v>
<v t="ekr.20040712101754.95"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.96"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040712101754.97"><vh>before</vh></v>
<v t="ekr.20040712101754.98"><vh>after</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.99"><vh>@test c iters</vh>
<v t="ekr.20040712101754.100"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="ekr.20040712101754.101"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20040802065214"><vh>@test changing headline marks descendent @thin nodes dirty</vh>
<v t="ekr.20040802065214.1"><vh>bogus</vh></v>
</v>
<v t="ekr.20040712101754.272"><vh>@test CheckOutline</vh></v>
<v t="ekr.20040802071519"><vh>@test p.setBodyStringOrPane</vh>
<v t="ekr.20040802071519.1"><vh>child</vh></v>
</v>
<v t="ekr.20040713070526"><vh>@test Pretty Print command</vh>
<v t="ekr.20040713123617"><vh>tempNode</vh></v>
<v t="ekr.20040713071919"><vh>before</vh></v>
<v t="ekr.20040713123828.1"><vh>after</vh></v>
</v>
<v t="ekr.20040803091512"><vh>@test bogus tnodeList doesn't corrupt @thin nodes</vh></v>
<v t="ekr.20040917062206"><vh>@test g.cantImport returns None</vh></v>
<v t="ekr.20040712101754.102"><vh>atFileTests...</vh>
<v t="ekr.20040712101754.103"><vh>@test @file no newline</vh>
<v t="ekr.20040712101754.104"><vh>@@file</vh></v>
<v t="ekr.20040712101754.105"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.106"><vh>@test @file one newline</vh>
<v t="ekr.20040712101754.107"><vh>@@file</vh></v>
<v t="ekr.20040712101754.108"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.109"><vh>@test @file two newlines</vh>
<v t="ekr.20040712101754.110"><vh>@@file</vh></v>
<v t="ekr.20040712101754.111"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.12"><vh>@test @thin</vh>
<v t="ekr.20040707141957.13"><vh>@@thin</vh></v>
<v t="ekr.20040707141957.14"><vh>Output</vh></v>
</v>
</v>
<v t="ekr.20040712101754.115"><vh>Colorizer tests...</vh>
<v t="ekr.20040712101754.116"><vh>@test @comment after @language plain</vh>
<v t="ekr.20040712101754.117"><vh>Test</vh></v>
</v>
<v t="ekr.20040712101754.118"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20040712101754.119"><vh>Actionscript</vh></v>
</v>
<v t="ekr.20040712101754.120"><vh>@test colorizer C</vh>
<v t="ekr.20040712101754.121"><vh>C</vh></v>
</v>
<v t="ekr.20040712101754.122"><vh>@test colorizer C#</vh>
<v t="ekr.20040712101754.123"><vh>C#</vh></v>
</v>
<v t="ekr.20040712101754.124"><vh>@test colorizer css</vh>
<v t="ekr.20040712101754.125"><vh>css</vh></v>
</v>
<v t="ekr.20040712101754.126"><vh>@test colorizer CWEB</vh>
<v t="ekr.20040712101754.127"><vh>CWEB</vh>
<v t="ekr.20040712101754.128"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040712101754.129"><vh>@test colorizer elisp</vh>
<v t="ekr.20040712101754.130"><vh>elisp</vh></v>
</v>
<v t="ekr.20040712101754.131"><vh>@test colorizer HTML string bug</vh>
<v t="ekr.20040712101754.132"><vh>String bug in html</vh></v>
</v>
<v t="ekr.20040712101754.133"><vh>@test colorizer HTML1</vh>
<v t="ekr.20040712101754.134"><vh>HTML1</vh></v>
</v>
<v t="ekr.20040712101754.135"><vh>@test colorizer HTML2</vh>
<v t="ekr.20040712101754.136"><vh>HTML2</vh></v>
</v>
<v t="ekr.20040712101754.137"><vh>@test colorizer LaTex</vh>
<v t="ekr.20040712101754.138"><vh>LaTex</vh></v>
</v>
<v t="ekr.20040712101754.139"><vh>@test colorizer mixed</vh>
<v t="ekr.20040712101754.140"><vh>Mixed</vh></v>
</v>
<v t="ekr.20040712101754.141"><vh>@test colorizer PHP</vh>
<v t="ekr.20040712101754.142"><vh>PHP</vh></v>
</v>
<v t="ekr.20040712101754.143"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="ekr.20040712101754.144"><vh>python.xml</vh>
<v t="ekr.20040712101754.145"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="ekr.20040712101754.146"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="ekr.20040712101754.147"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="ekr.20040712101754.148"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="ekr.20040712101754.149"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="ekr.20040712101754.150"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="ekr.20040712101754.151"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="ekr.20040712101754.152"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="ekr.20040712101754.153"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.154"><vh>@test colorizer Python1</vh>
<v t="ekr.20040712101754.155"><vh>Python1</vh></v>
</v>
<v t="ekr.20040712101754.156"><vh>@test colorizer Python2</vh>
<v t="ekr.20040712101754.157"><vh>Python2</vh></v>
</v>
<v t="ekr.20040712101754.158"><vh>@test colorizer rapidq</vh>
<v t="ekr.20040712101754.159"><vh>rapidq</vh></v>
</v>
<v t="ekr.20040712101754.160"><vh>@test colorizer Rebol</vh>
<v t="ekr.20040712101754.161"><vh>Rebol</vh></v>
</v>
<v t="ekr.20040712101754.162"><vh>@test colorizer shell</vh>
<v t="ekr.20040712101754.163"><vh>shell</vh></v>
</v>
<v t="ekr.20040712101754.164"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="ekr.20040712101754.165"><vh>tex.xml</vh>
<v t="ekr.20040712101754.166"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="ekr.20040712101754.167"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040712101754.168"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20040712101754.169"><vh>wikiTest1</vh></v>
</v>
<v t="ekr.20040712101754.170"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20040712101754.171"><vh>wikiTest2</vh></v>
</v>
<v t="ekr.20040712101754.172"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20040712101754.173"><vh>wikiTest3</vh></v>
</v>
</v>
<v t="ekr.20040712101754.174"><vh>Mini tests...</vh>
<v t="ekr.20040712101754.175"><vh>@test p.t == p.v.t</vh></v>
<v t="ekr.20040712101754.176"><vh>@test python keywords</vh></v>
<v t="ekr.20040712101754.177"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20040712101754.178"><vh>File Conversion</vh>
<v t="ekr.20040712101754.179"><vh>moreHead</vh></v>
<v t="ekr.20040712101754.180"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20040712101754.181"><vh>inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
</v>
<v t="ekr.20040712101754.184"><vh>@test consistency of p.v.t.vnodeList &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040712101754.185"><vh>@test that cloned nodes actually share subtrees</vh></v>
<v t="ekr.20040712101754.186"><vh>@test batch mode</vh></v>
</v>
<v t="ekr.20040712101754.187"><vh>Position tests...</vh>
<v t="ekr.20040712101754.188"><vh>@test p.iters and v.iters</vh>
<v t="ekr.20040712101754.189"><vh>child1</vh>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.192"><vh>c</vh></v>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.193"><vh>d</vh>
<v t="ekr.20040712101754.194"><vh>e</vh></v>
</v>
</v>
<v t="ekr.20040712101754.195"><vh>child2</vh></v>
<v t="ekr.20040712101754.196"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="ekr.20040712101754.197"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="ekr.20040712101754.198"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20040712101754.199"><vh>@test p.comparisons</vh></v>
<v t="ekr.20040712101754.200"><vh>@test that clones share subtrees</vh></v>
<v t="ekr.20040712101754.201"><vh>@test consistency of c.allNodes_iter() and p.ThreadNext()</vh></v>
<v t="ekr.20040712101754.202"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20040712101754.203"><vh>@test consistency of level</vh></v>
<v t="ekr.20040712101754.204"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20040712101754.205"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20040712101754.206"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20040712101754.207"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20040712101754.208"><vh>@test consistency of tnodeListAndParents</vh></v>
<v t="ekr.20040712101754.209"><vh>@test hasNextBack</vh></v>
<v t="ekr.20040712101754.210"><vh>@test hasParentChild</vh></v>
<v t="ekr.20040712101754.211"><vh>@test hasThreadNextBack</vh></v>
<v t="ekr.20040712101754.212"><vh>@test vnode list</vh></v>
<v t="ekr.20040722055040"><vh>@test isAncestorOf</vh></v>
</v>
<v t="ekr.20040723062819"><vh>Syntax Checks...</vh>
<v t="EKR.20040612095237"><vh>@test checkPythonCode (bad syntax)</vh>
<v t="EKR.20040610192622.1"><vh>Check Syntax data (bad)</vh></v>
</v>
<v t="ekr.20040715154319"><vh>@test checkPythonCode (bad tabnanny)</vh>
<v t="EKR.20040610194209.1"><vh>TabNanny data (bad)</vh></v>
</v>
<v t="ekr.20040712101813"><vh>@test checkAllPythonCode</vh></v>
</v>
</v>
<v t="ekr.20040712101754.274"><vh>@suite run all doctests in leo*.py</vh></v>
<v t="ekr.20040712101754.261"><vh>Plugins tests</vh>
<v t="ekr.20040801141212"><vh>@suite test syntax of all plugins correctly</vh>
<v t="ekr.20040801141543"><vh>class parseFileTestCase</vh>
<v t="ekr.20040801141543.1"><vh>__init__</vh></v>
<v t="ekr.20040801141543.3"><vh>runTest</vh></v>
<v t="ekr.20040801141543.5"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040801145836"><vh>(dangerous) @suite run unitTest method of plugins</vh>
<v t="ekr.20040801150333"><vh>class runPluginTestCase</vh>
<v t="ekr.20040801150333.1"><vh>__init__</vh></v>
<v t="ekr.20040801150333.2"><vh>runTest</vh></v>
<v t="ekr.20040801150333.3"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040801124822.1"><vh>@test plugins/nodenavigator.py</vh></v>
</v>
<v t="ekr.20040712101754.213"><vh>Unfinished tests...</vh>
<v t="ekr.20040712101754.214"><vh>Outline tests (Sometimes fails)</vh>
<v t="ekr.20040712101754.215"><vh>test of p.copyTreeAfter and p.copyTreeFromSelfTo</vh>
<v t="ekr.20040712101754.216"><vh>root1</vh>
<v t="ekr.20040712101754.217"><vh>a</vh>
<v t="ekr.20040712101754.218"><vh>c</vh>
<v t="ekr.20040712101754.219"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20040712101754.220"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.221"><vh>Manual test of testUtils.replaceOutline</vh>
<v t="ekr.20040712101754.222"><vh>outline1</vh>
<v t="ekr.20040712101754.223"><vh>a</vh></v>
</v>
<v t="ekr.20040712101754.224"><vh>outline2</vh>
<v t="ekr.20040712101754.225"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.226"><vh>testUtils.replaceOutline</vh></v>
<v t="ekr.20040712101754.227"><vh>@@ suite Outline/Undo tests</vh>
<v t="ekr.20040712101754.228"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040712101754.229"><vh>class outlineTestCase</vh>
<v t="ekr.20040712101754.230"><vh>__init__</vh></v>
<v t="ekr.20040712101754.231"><vh>outlineCommand</vh></v>
<v t="ekr.20040712101754.232"><vh>runTest</vh></v>
<v t="ekr.20040712101754.233"><vh>setUp</vh></v>
<v t="ekr.20040712101754.234"><vh>tearDown</vh></v>
<v t="ekr.20040712101754.235"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040712101754.236"><vh>outlineTests</vh>
<v t="ekr.20040712101754.237"><vh>moveOutlineDown</vh>
<v t="ekr.20040712101754.238"><vh>before</vh>
<v t="ekr.20040712101754.239"><vh>a</vh></v>
<v t="ekr.20040712101754.240"><vh>move</vh></v>
<v t="ekr.20040712101754.241"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.242"><vh>after</vh>
<v t="ekr.20040712101754.243"><vh>a</vh></v>
<v t="ekr.20040712101754.244"><vh>b</vh></v>
<v t="ekr.20040712101754.245"><vh>move</vh></v>
</v>
<v t="ekr.20040712101754.246"><vh>ref</vh>
<v t="ekr.20040712101754.247"><vh>a</vh></v>
<v t="ekr.20040712101754.248"><vh>move</vh></v>
<v t="ekr.20040712101754.249"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.250"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040712101754.251"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040712101754.252"><vh>moveOutlineUp</vh></v>
</v>
</v>
<v t="ekr.20040712101754.253"><vh>Find Command tests...(Not finished)</vh>
<v t="ekr.20040712101754.254"><vh>@suite Find sommands tests</vh>
<v t="ekr.20040712101754.255"><vh>class findCommandTestCase</vh>
<v t="ekr.20040712101754.256"><vh>setUp</vh></v>
<v t="ekr.20040712101754.257"><vh>testFindCommand</vh></v>
<v t="ekr.20040712101754.258"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040712101754.259"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040712101754.260"><vh>findTests</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707081532.1"><vh>Do @test</vh></v>
<v t="ekr.20041001194357"><vh>@button unit test</vh></v>
</v>
</v>
</v>
<v t="ekr.20041006110307" a="E"><vh>Structure is an official part of the language</vh>
<v t="ekr.20041006110307.1"><vh>Nodes inherit directives from ancestor nodes</vh></v>
<v t="ekr.20041006110307.2"><vh>Sections must be defined in descendent nodes</vh></v>
</v>
</v>
<v t="ekr.20041006104908.4"><vh>Future directions</vh>
<v t="ekr.20041006104224.5"><vh>I don't know where it is going</vh></v>
<v t="ekr.20041006110013"><vh>Better cvs support</vh></v>
<v t="ekr.20041006110013.1"><vh>More configurations options</vh></v>
</v>
<v t="ekr.20041006103243.519" a="TV"><vh>Patterns: The World According to Leo</vh>
<v t="ekr.20041006110732"><vh>You can't do this in Emacs</vh></v>
<v t="ekr.20041006103243.520"><vh>Anti-patterns post</vh></v>
<v t="ekr.20041006103243.521"><vh>Use headlines to hold metadata</vh></v>
<v t="ekr.20041006103243.522"><vh>Clone patterns</vh>
<v t="ekr.20041006103243.523"><vh>Organize coding tasks with clones and task headlines</vh></v>
<v t="ekr.20041006103243.524"><vh>Create functions or methods instead of sharing sections</vh></v>
</v>
<v t="ekr.20041006103243.525"><vh>Organizing patterns</vh>
<v t="ekr.20041006103243.526"><vh>Organize files with headlines</vh></v>
<v t="ekr.20041006103243.527"><vh>Organize classes with headlines</vh></v>
<v t="ekr.20041006103243.528"><vh>Organize methods with headlines</vh></v>
<v t="ekr.20041006103243.529"><vh>Organize project notes with headlines</vh></v>
<v t="ekr.20041006103243.530"><vh>Organize tasks with headlines</vh></v>
</v>
<v t="ekr.20041006103243.531"><vh>Coding patterns 8</vh>
<v t="ekr.20041006103243.532"><vh>Use @others to avoid naming sections</vh></v>
<v t="ekr.20041006103243.533"><vh>Use sections to clarify code</vh></v>
<v t="ekr.20041006103243.534"><vh>Use sections to highlight if statements</vh></v>
<v t="ekr.20041006103243.535"><vh>Use sections to highlight while statements</vh></v>
<v t="ekr.20041006103243.536"><vh>Use sections to make methods fit on a page</vh></v>
<v t="ekr.20041006103243.524"><vh>Create functions or methods instead of sharing sections</vh></v>
<v t="ekr.20041006103243.537"><vh>Use sections to show patterns in code: </vh></v>
<v t="ekr.20041006103243.538"><vh>Use nested @others to put multiple classes in a file</vh></v>
</v>
<v t="ekr.20041006103243.539"><vh>Refactoring pattenrs</vh>
<v t="ekr.20041006103243.540"><vh>Nodes are methods:  moving methods</vh></v>
<v t="ekr.20041006103243.541"><vh>Use clones to abstract code for timeit</vh></v>
</v>
<v t="ekr.20041006103243.542"><vh>Pattens of good style</vh></v>
<v t="ekr.20041006103243.543"><vh>Patterns of bad style</vh></v>
<v t="ekr.20041006103243.544"><vh>Project management patterns</vh></v>
<v t="ekr.20041006103243.545"><vh>Plugins patterns 3</vh>
<v t="ekr.20041006103243.546"><vh>Use plugins to override Leo's internals</vh></v>
<v t="ekr.20041006103243.547"><vh>Use plugins to add funtionality</vh></v>
<v t="ekr.20041006103243.548"><vh>Use g.app.scriptData to communicate with scripts</vh></v>
</v>
<v t="ekr.20041006103243.549"><vh>Script patterns 2</vh>
<v t="ekr.20041006103243.550"><vh>import leoGlobals as g to access Leo's utility funtions</vh></v>
<v t="ekr.20041006103243.551"><vh>Use the script button to bring data to scripts (or is it scripts to data?)</vh></v>
</v>
<v t="ekr.20041006103243.552"><vh>Find/Change patterns 1</vh>
<v t="ekr.20041006103243.553"><vh>Use sciprt find/replace for complex interactive searches</vh></v>
</v>
<v t="ekr.20041006103243.554"><vh>Unit test patters  11</vh>
<v t="ekr.20041006103243.555"><vh>Use g.app.unitTestDict to communicate with unit tests</vh></v>
<v t="ekr.20041006103243.551"><vh>Use the script button to bring data to scripts (or is it scripts to data?)</vh></v>
<v t="ekr.20041006103243.521"><vh>Use headlines to hold metadata</vh></v>
<v t="ekr.20041006103243.556"><vh>Use scripts instead of unit test classes</vh></v>
<v t="ekr.20041006103243.557"><vh>@test</vh></v>
<v t="ekr.20041006103243.558"><vh>@suite</vh></v>
<v t="ekr.20041006103243.559"><vh>@suite run all doctests</vh></v>
<v t="ekr.20041006103243.560"><vh>Use try:finally instead of tearDown</vh></v>
<v t="ekr.20041006103243.561"><vh>Use children to hold test data</vh></v>
<v t="ekr.20041006103243.562"><vh>Use children to hold intermediate results</vh></v>
<v t="ekr.20041006103243.563"><vh>Use functions/methods for common setup code</vh></v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151"></t>
<t tx="EKR.20040519090151.2">@ The present code is almost useless if there is a crash in Leo's core (instead of the script itself).</t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040529103843">def tnodes_iter(self):
    
    """Return all tnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_tnodes_iter(self):
    
    """Return all unique tnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="EKR.20040529103945">def vnodes_iter(self):
    
    """Return all vnode's in a positions subtree."""
    
    p = self
    for p in p.self_and_subtree_iter():
        yield p.v
        
def unique_vnodes_iter(self):
    
    """Return all unique vnode's in a positions subtree."""
    
    p = self
    marks = {}
    for p in p.self_and_subtree_iter():
        if p.v not in marks:
            marks[p.v] = p.v
            yield p.v</t>
<t tx="EKR.20040610192622.1">import string

string.join(a,b] # A syntax error</t>
<t tx="EKR.20040610194209.1">@tabwidth 4

# Tabnanny _only_ checks errors involving tabs.
# It does _not_ check other indentation errors.
# It does _not_ check syntax.

if 1: # Essential, so we don't create a syntax error.
    a = 5
	b = 6 #Contains tab.
    c = 3</t>
<t tx="EKR.20040612095237">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import unittest

c = g.top()

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False,suppressErrors=True)

assert result=="error", "checkPythonCode returns: %s" % result
</t>
<t tx="EKR.20040619133116"></t>
<t tx="ekr.20031218072017.889"># Warning: this code implies substantial changes to code that uses them, both core and scripts.

class position (object):
    
    """A class representing a position in a traversal of a tree containing shared tnodes."""

    &lt;&lt; about the position class &gt;&gt;
    
    @others
</t>
<t tx="ekr.20031218072017.890">@ This class provides tree traversal methods that operate on positions, not vnodes.  Positions encapsulate the notion of present position within a traversal.

Positions consist of a vnode and a stack of parent nodes used to determine the next parent when a vnode has mutliple parents.

Calling, e.g., p.moveToThreadNext() results in p being an invalid position.  That is, p represents the position following the last node of the outline.  The test "if p" is the _only_ correct way to test whether a position p is valid.  In particular, tests like "if p is None" or "if p is not None" will not work properly.

The only changes to vnodes and tnodes needed to implement shared tnodes are:

- The firstChild field becomes part of tnodes.
- t.vnodes contains a list of all vnodes sharing the tnode.

The advantages of using shared tnodes:

- Leo no longer needs to create or destroy "dependent" trees when changing descendents of cloned trees.
- There is no need for join links and no such things as joined nodes.

These advantages are extremely important: Leo is now scalable to very large outlines.

An important complication is the need to avoid creating temporary positions while traversing trees:
- Several routines use p.vParentWithStack to avoid having to call tempPosition.moveToParent().
  These include p.level, p.isVisible, p.hasThreadNext and p.vThreadNext.
- p.moveToLastNode and p.moveToThreadBack use new algorithms that don't use temporary data.
- Several lookahead routines compute whether a position exists without computing the actual position.</t>
<t tx="ekr.20031218072017.892">def __init__ (self,v,stack,trace=True):

    """Create a new position."""
    
    if v: self.c = v.c
    else: self.c = g.top()
    self.v = v
    assert(v is None or v.t)
    self.stack = stack[:] # Creating a copy here is safest and best.

    g.app.positions += 1
    
    if g.app.tracePositions and trace:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)
    
    # Note: __getattr__ implements p.t.
</t>
<t tx="ekr.20031218072017.893">def __cmp__(self,p2):

    """Return 0 if two postions are equivalent."""

    # Use p.equal if speed is crucial.
    p1 = self

    if p2 is None: # Allow tests like "p == None"
        if p1.v: return 1 # not equal
        else:    return 0 # equal

    # Check entire stack quickly.
    # The stack contains vnodes, so this is not a recursive call.
    if p1.v != p2.v or p1.stack != p2.stack:
        return 1 # notEqual

    # This is slow: do this last!
    if p1.childIndex() != p2.childIndex():
        # Disambiguate clones having the same parents.
        return 1 # notEqual

    return 0 # equal</t>
<t tx="ekr.20031218072017.915"># These methods are useful abbreviations.
# Warning: they make copies of positions, so they should be used _sparingly_

def getBack          (self): return self.copy().moveToBack()
def getFirstChild    (self): return self.copy().moveToFirstChild()
def getLastChild     (self): return self.copy().moveToLastChild()
def getLastNode      (self): return self.copy().moveToLastNode()
def getLastVisible   (self): return self.copy().moveToLastVisible()
def getNext          (self): return self.copy().moveToNext()
def getNodeAfterTree (self): return self.copy().moveToNodeAfterTree()
def getNthChild    (self,n): return self.copy().moveToNthChild(n)
def getParent        (self): return self.copy().moveToParent()
def getThreadBack    (self): return self.copy().moveToThreadBack()
def getThreadNext    (self): return self.copy().moveToThreadNext()
def getVisBack       (self): return self.copy().moveToVisBack()
def getVisNext       (self): return self.copy().moveToVisNext()

# These are efficient enough now that iterators are the normal way to traverse the tree!

back          = getBack
firstChild    = getFirstChild
lastChild     = getLastChild
lastNode      = getLastNode
lastVisible   = getLastVisible # New in 4.2 (was in tk tree code).
next          = getNext
nodeAfterTree = getNodeAfterTree
nthChild      = getNthChild
parent        = getParent
threadBack    = getThreadBack
threadNext    = getThreadNext
visBack       = getVisBack
visNext       = getVisNext</t>
<t tx="ekr.20031218072017.928">@
These routines change self to a new position "in place".
That is, these methods must _never_ call p.copy().

When moving to a nonexistent position, these routines simply set p.v = None,
leaving the p.stack unchanged. This allows the caller to "undo" the effect of
the invalid move by simply restoring the previous value of p.v.

These routines all return self on exit so the following kind of code will work:
    after = p.copy().moveToNodeAfterTree()</t>
<t tx="ekr.20031218072017.930">def moveToBack (self):
    
    """Move self to its previous sibling."""
    
    p = self

    p.v = p.v and p.v._back
    
    return p</t>
<t tx="ekr.20031218072017.931">def moveToFirstChild (self):

    """Move a position to it's first child's position."""
    
    p = self

    if p:
        child = p.v.t._firstChild
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
        
    return p

</t>
<t tx="ekr.20031218072017.932">def moveToLastChild (self):
    
    """Move a position to it's last child's position."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            child = p.v.lastChild()
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p
</t>
<t tx="ekr.20031218072017.933">def moveToLastNode (self):
    
    """Move a position to last node of its tree.
    
    N.B. Returns p if p has no children."""
    
    p = self
    
    # Huge improvement for 4.2.
    while p.hasChildren():
        p.moveToLastChild()

    return p</t>
<t tx="ekr.20031218072017.934">def moveToNext (self):
    
    """Move a position to its next sibling."""
    
    p = self
    
    p.v = p.v and p.v._next
    
    return p</t>
<t tx="ekr.20031218072017.935">def moveToNodeAfterTree (self):
    
    """Move a position to the node after the position's tree."""
    
    p = self
    
    while p:
        if p.hasNext():
            p.moveToNext()
            break
        p.moveToParent()

    return p
</t>
<t tx="ekr.20031218072017.936">def moveToNthChild (self,n):
    
    p = self
    
    if p:
        child = p.v.nthChild(n) # Must call vnode method here!
        if child:
            if p.isCloned():
                p.stack.append(p.v)
                # g.trace("push",p.v,p)
            p.v = child
        else:
            p.v = None
            
    return p</t>
<t tx="ekr.20031218072017.937">def moveToParent (self):
    
    """Move a position to its parent position."""
    
    p = self
    
    if not p: return p # 10/30/04

    if p.v._parent and len(p.v._parent.t.vnodeList) == 1:
        p.v = p.v._parent
    elif p.stack:
        p.v = p.stack.pop()
        # g.trace("pop",p.v,p)
    else:
        p.v = None

    return p</t>
<t tx="ekr.20031218072017.938">def moveToThreadBack (self):
    
    """Move a position to it's threadBack position."""

    p = self

    if p.hasBack():
        p.moveToBack()
        p.moveToLastNode()
    else:
        p.moveToParent()

    return p</t>
<t tx="ekr.20031218072017.939">def moveToThreadNext (self):
    
    """Move a position to the next a position in threading order."""
    
    p = self

    if p:
        if p.v.t._firstChild:
            p.moveToFirstChild()
        elif p.v._next:
            p.moveToNext()
        else:
            p.moveToParent()
            while p:
                if p.v._next:
                    p.moveToNext()
                    break #found
                p.moveToParent()
            # not found.
                
    return p</t>
<t tx="ekr.20031218072017.940">def moveToVisBack (self):
    
    """Move a position to the position of the previous visible node."""

    p = self
    
    if p:
        p.moveToThreadBack()
        while p and not p.isVisible():
            p.moveToThreadBack()

    assert(not p or p.isVisible())
    return p</t>
<t tx="ekr.20031218072017.941">def moveToVisNext (self):
    
    """Move a position to the position of the next visible node."""

    p = self

    p.moveToThreadNext()
    while p and not p.isVisible():
        p.moveToThreadNext()
            
    return p</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
lst: a list (Do _not_ use list, it is a Python global!)
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode

See the child of this node called "Overview of Code" for more documentation.</t>
<t tx="ekr.20031218072017.2415"></t>
<t tx="ekr.20031218072017.2418">def initScriptFind(findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
    
    import leoTest
    import leoGlobals as g
    
    # Find the scripts.
    c = g.top() ; p = c.currentPosition()
    u = leoTest.testUtils()
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    g.app.findFrame.init(c)
    c.findPanel()</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.3388">def clearAllVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.v.clearVisited()
        p.v.t.clearVisited()
        p.v.t.clearWriteBit()</t>
<t tx="ekr.20031218072017.3625"></t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.4146">def oldLastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    assert(p.isVisible())
    last = p.copy()
    while 1:
        if g.app.debug: g.trace(last)
        p.moveToVisNext()
        if not p: break
        last = p.copy()
    return last
        
def lastVisible(self):
    """Move to the last visible node of the entire tree."""
    p = self.c.rootPosition()
    # Move to the last top-level node.
    while p.hasNext():
        if g.app.debug: g.trace(p)
        p.moveToNext()
    assert(p.isVisible())
    # Move to the last visible child.
    while p.hasChildren() and p.isExpanded():
        if g.app.debug: g.trace(p)
        p.moveToLastChild()
    assert(p.isVisible())
    if g.app.debug: g.trace(p)
    return p</t>
<t tx="ekr.20040117162509.16">def isVisible (self):
    
    """Return True if all of a position's parents are expanded."""

    # v.isVisible no longer exists.
    p = self

    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1

    v,n = p.vParentWithStack(v,p.stack,n)
    while v:
        if not v.isExpanded():
            return False
        v,n = p.vParentWithStack(v,p.stack,n)

    return True</t>
<t tx="ekr.20040117170612">if 1: # Good for compatibility, bad for finding conversion problems.

    def __getattr__ (self,attr):
        
        """Convert references to p.t into references to p.v.t.
        
        N.B. This automatically keeps p.t in synch with p.v.t."""

        if attr=="t":
            return self.v.t
        elif attr=="__del__":
            # This works around a Python 2.2 wierdness.
            return AttributeError # Silently ignore this.
        else:
            # Only called when normal lookup fails.
            print "unknown position attribute:",attr
            # import traceback ; traceback.print_stack()
            raise AttributeError</t>
<t tx="ekr.20040117171654"># Using this routine can generate huge numbers of temporary positions during a tree traversal.

def copy (self):
    
    """"Return an independent copy of a position."""
    
    if g.app.tracePositions:
        g.trace("%-25s %-25s %s" % (
            g.callerName(4),g.callerName(3),g.callerName(2)),align=10)

    return position(self.v,self.stack,trace=False)</t>
<t tx="ekr.20040117173448">@
The test "if p" is the _only_ correct way to test whether a position p is valid.
In particular, tests like "if p is None" or "if p is not None" will not work properly.
@c

def __nonzero__ ( self):
    
    """Return True if a position is valid."""
    
    # if g.app.trace: "__nonzero__",self.v

    return self.v is not None</t>
<t tx="ekr.20040227212621">def hasBack(self):
    return self.v and self.v._back

hasFirstChild = hasChildren
    
def hasNext(self):
    return self.v and self.v._next
    
def hasParent(self):
    return self.v and self.v._parent is not None
    
def hasThreadBack(self):
    return self.hasParent() or self.hasBack() # Much cheaper than computing the actual value.
    
hasVisBack = hasThreadBack</t>
<t tx="ekr.20040227214711">def simpleLevel(self):
    
    p = self ; level = 0
    for parent in p.parents_iter():
        level += 1
    return level

def level(self,verbose=False):
    
    # if g.app.debug: simpleLevel = self.simpleLevel()
    
    p = self ; level = 0
    if not p: return level
        
    # Avoid calling p.copy() or copying the stack.
    v = p.v ; n = len(p.stack)-1
    while 1:
        assert(p)
        v,n = p.vParentWithStack(v,p.stack,n)
        if v:
            level += 1
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
        else:
            if verbose: g.trace(level,"level %2d, n: %2d" % (level,n))
            # if g.app.debug: assert(level==simpleLevel)
            break
    return level</t>
<t tx="ekr.20040227224946">def hasThreadNext(self):

    p = self ; v = p.v
    if not p.v: return False

    if v.t._firstChild or v._next:
        return True
    else:
        n = len(p.stack)-1
        v,n = p.vParentWithStack(v,p.stack,n)
        while v:
            if v._next:
                return True
            v,n = p.vParentWithStack(v,p.stack,n)
        return False

hasVisNext = hasThreadNext</t>
<t tx="ekr.20040228060340"># A crucial utility method.
# The p.level(), p.isVisible() and p.hasThreadNext() methods show how to use this method.

&lt;&lt; about the vParentWithStack utility method &gt;&gt;

def vParentWithStack(self,v,stack,n):
    
    """A utility that allows the computation of p.v without calling p.copy().
    
    v,stack[:n] correspond to p.v,p.stack for some intermediate position p.

    Returns (v,n) such that v,stack[:n] correpond to the parent position of p."""

    if not v:
        return None,n
    elif v._parent and len(v._parent.t.vnodeList) == 1:
        return v._parent,n # don't change stack.
    elif stack and n &gt;= 0:
        return self.stack[n],n-1 # simulate popping the stack.
    else:
        return None,n</t>
<t tx="ekr.20040228060340.1">@ 
This method allows us to simulate calls to p.parent() without generating any intermediate data.

For example, the code below will compute the same values for list1 and list2:

# The first way depends on the call to p.copy:
list1 = []
p=p.copy() # odious.
while p:
    p = p.moveToParent()
    if p: list1.append(p.v)

# The second way uses p.vParentWithStack to avoid all odious intermediate data.

list2 = []
n = len(p.stack)-1
v,n = p.vParentWithStack(v,p.stack,n)
while v:
    list2.append(v)
    v,n = p.vParentWithStack(v,p.stack,n)

</t>
<t tx="ekr.20040228094013"></t>
<t tx="ekr.20040228094013.1"></t>
<t tx="ekr.20040301205720">def __str__ (self):
    
    p = self
    
    if p.v:
        return "&lt;pos %d lvl: %d [%d] %s&gt;" % (id(p),p.level(),len(p.stack),p.cleanHeadString())
    else:
        return "&lt;pos %d        [%d] None&gt;" % (id(p),len(p.stack))
        
__repr__ = __str__</t>
<t tx="ekr.20040303163330"># Ensures that all ancestor and descentent @file nodes are marked dirty.
# It is much safer to do it this way.

def setDirty (self,setDescendentsDirty=True):

    p = self ; c = p.c
    
    # g.trace(g.app.count) ; g.app.count += 1

    c.beginUpdate()
    if 1: # update...
        changed = False
        if not p.v.t.isDirty():
            p.v.t.setDirty()
            changed = True
        # N.B. This must be called even if p.v is already dirty.
        # Typing can change the @ignore state!
        if p.setAllAncestorAtFileNodesDirty(setDescendentsDirty):
            changed = True
    c.endUpdate(changed)

    return changed</t>
<t tx="ekr.20040303175026"></t>
<t tx="ekr.20040303175026.2">@ This is the main delete routine.  It deletes the receiver's entire tree from the screen.  Because of the undo command we never actually delete vnodes or tnodes.
@c

def doDelete (self,newPosition):

    """Deletes position p from the outline.  May be undone.

    Returns newPosition."""

    p = self ; c = p.c

    assert(newPosition != p)
    p.setDirty() # Mark @file nodes dirty!
    p.unlink()
    p.deleteLinksInTree()
    c.selectVnode(newPosition)
    
    return newPosition

</t>
<t tx="ekr.20040303175026.3">def insertAfter (self,t=None):

    """Inserts a new position after self.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")

    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAfter(p)

    return p2</t>
<t tx="ekr.20040303175026.4">def insertAsLastChild (self,t=None):

    """Inserts a new vnode as the last child of self.
    
    Returns the newly created position."""
    
    p = self
    n = p.numberOfChildren()

    if not t:
        t = tnode(headString="NewHeadline")
    
    return p.insertAsNthChild(n,t)</t>
<t tx="ekr.20040303175026.5">def insertAsNthChild (self,n,t=None):

    """Inserts a new node as the the nth child of self.
    self must have at least n-1 children.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    p2 = self.copy()

    if not t:
        t = tnode(headString="NewHeadline")
    
    p2.v = vnode(c,t)
    p2.v.iconVal = 0
    p2.linkAsNthChild(p,n)

    return p2</t>
<t tx="ekr.20040303175026.6">def moveToRoot (self,oldRoot=None):

    """Moves a position to the root position."""

    p = self # Do NOT copy the position!
    p.unlink()
    p.linkAsRoot(oldRoot)
    
    return p</t>
<t tx="ekr.20040303175026.8">def clone (self,back):
    
    """Create a clone of back.
    
    Returns the newly created position."""
    
    p = self ; c = p.c
    
    # g.trace(p,back)

    p2 = back.copy()
    p2.v = vnode(c,back.v.t)
    p2.linkAfter(back)

    return p2</t>
<t tx="ekr.20040303175026.9"># This is used by unit tests.

def copyTreeAfter(self):
    p = self
    p2 = p.insertAfter()
    p.copyTreeFromSelfTo(p2)
    return p2
    
def copyTreeFromSelfTo(self,p2):
    p = self
    p2.v.t.headString = p.headString()
    p2.v.t.bodyString = p.bodyString()
    for child in p.children_iter(copy=True):
        child2 = p2.insertAsLastChild()
        child.copyTreeFromSelfTo(child2)</t>
<t tx="ekr.20040303175026.10">def moveAfter (self,a):

    """Move a position after position a."""
    
    p = self ; c = p.c # Do NOT copy the position!
    p.unlink()
    p.linkAfter(a)
    
    # Moving a node after another node can create a new root node.
    if not a.hasParent() and not a.hasBack():
        c.setRootPosition(a)

    return p</t>
<t tx="ekr.20040303175026.11">def moveToNthChildOf (self,parent,n):

    """Move a position to the nth child of parent."""

    p = self ; c = p.c # Do NOT copy the position!
    
    # g.trace(p,parent,n)

    p.unlink()
    p.linkAsNthChild(parent,n)
    
    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        c.setRootPosition(parent)

    return p
</t>
<t tx="ekr.20040303175026.12">def sortChildren (self):
    
    p = self

    # Create a list of (headline,position) tuples
    pairs = []
    for child in p.children_iter():
        pairs.append((string.lower(child.headString()),child.copy())) # do we need to copy?

    # Sort the list on the headlines.
    pairs.sort()

    # Move the children.
    index = 0
    for headline,child in pairs:
        child.moveToNthChildOf(p,index)
        index += 1</t>
<t tx="ekr.20040303175026.13"># This routine checks the structure of the receiver's tree.

def validateOutlineWithParent (self,pv):
    
    p = self
    result = True # optimists get only unpleasant surprises.
    parent = p.getParent()
    childIndex = p.childIndex()
    
    # g.trace(p,parent,pv)
    &lt;&lt; validate parent ivar &gt;&gt;
    &lt;&lt; validate childIndex ivar &gt;&gt;
    &lt;&lt; validate x ivar &gt;&gt;

    # Recursively validate all the children.
    for child in p.children_iter():
        r = child.validateOutlineWithParent(p)
        if not r: result = False

    return result</t>
<t tx="ekr.20040303175026.14">if parent != pv:
    p.invalidOutline( "Invalid parent link: " + repr(parent))</t>
<t tx="ekr.20040303175026.15">if pv:
    if childIndex &lt; 0:
        p.invalidOutline ( "missing childIndex" + childIndex )
    elif childIndex &gt;= pv.numberOfChildren():
        p.invalidOutline ( "missing children entry for index: " + childIndex )
elif childIndex &lt; 0:
    p.invalidOutline ( "negative childIndex" + childIndex )</t>
<t tx="ekr.20040303175026.16">if not p.v.t and pv:
    self.invalidOutline ( "Empty t" )</t>
<t tx="ekr.20040303214038">def setAllAncestorAtFileNodesDirty (self,setDescendentsDirty=False):

    p = self ; c = p.c
    changed = False
    
    # Calculate all nodes that are joined to v or parents of such nodes.
    nodes = p.findAllPotentiallyDirtyNodes()
    
    if setDescendentsDirty:
        # N.B. Only mark _direct_ descendents of nodes.
        # Using the findAllPotentiallyDirtyNodes algorithm would mark way too many nodes.
        for p2 in p.subtree_iter():
            # Only @thin nodes need to be marked.
            if p2.v not in nodes and p2.isAtThinFileNode():
                nodes.append(p2.v)
    
    c.beginUpdate()
    if 1: # update...
        count = 0 # for debugging.
        for v in nodes:
            if not v.t.isDirty() and v.isAnyAtFileNode():
                # g.trace(v)
                changed = True
                v.t.setDirty() # Do not call v.setDirty here!
                count += 1
        # g.trace(count,changed)
    c.endUpdate(changed)
    return changed</t>
<t tx="ekr.20040305162628"></t>
<t tx="ekr.20040305162628.1">@ 3/18/04: a crucial optimization:

Iterators make no copies at all if they would return an empty sequence.
@c

@others</t>
<t tx="ekr.20040305171133">class allNodes_iter_class:

    """Returns a list of positions in the entire outline."""

    @others

def allNodes_iter (self,copy=False):
    
    return self.allNodes_iter_class(self,copy)</t>
<t tx="ekr.20040305171133.1">def __init__(self,p,copy):

    self.first = p.c.rootPosition().copy()
    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20040305171133.3">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305172211.1">class children_iter_class:

    """Returns a list of children of a position."""

    @others

def children_iter (self,copy=False):
    
    return self.children_iter_class(self,copy)</t>
<t tx="ekr.20040305172211.2">def __init__(self,p,copy):

    if p.hasChildren():
        self.first = p.copy().moveToFirstChild()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self
</t>
<t tx="ekr.20040305172211.3">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305172855">class parents_iter_class:

    """Returns a list of positions of a position."""

    @others

def parents_iter (self,copy=False):
    
    p = self

    return self.parents_iter_class(self,copy,includeSelf=False)
    
def self_and_parents_iter(self,copy=False):
    
    return self.parents_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20040305172855.1">def __init__(self,p,copy,includeSelf):

    if includeSelf:
        self.first = p.copy()
    elif p.hasParent():
        self.first = p.copy().moveToParent()
    else:
        self.first = None

    self.p = None
    self.copy = copy

def __iter__(self):

    return self</t>
<t tx="ekr.20040305172855.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToParent()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration
</t>
<t tx="ekr.20040305173343">class siblings_iter_class:

    """Returns a list of siblings of a position."""

    @others

def siblings_iter (self,copy=False,following=False):
    
    return self.siblings_iter_class(self,copy,following)
    
self_and_siblings_iter = siblings_iter
    
def following_siblings_iter (self,copy=False):
    
    return self.siblings_iter_class(self,copy,following=True)</t>
<t tx="ekr.20040305173343.1">def __init__(self,p,copy,following):
    
    # We always include p, even if following is True.
    
    if following:
        self.first = p.copy()
    else:
        p = p.copy()
        while p.hasBack():
            p.moveToBack()
        self.first = p

    self.p = None
    self.copy = copy

def __iter__(self):
    
    return self

</t>
<t tx="ekr.20040305173343.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToNext()

    if self.p:
        if self.copy: return self.p.copy()
        else:         return self.p
    else: raise StopIteration</t>
<t tx="ekr.20040305173559">class subtree_iter_class:

    """Returns a list of positions in a subtree, possibly including the root of the subtree."""

    @others

def subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=False)
    
def self_and_subtree_iter (self,copy=False):
    
    return self.subtree_iter_class(self,copy,includeSelf=True)</t>
<t tx="ekr.20040305173559.1">def __init__(self,p,copy,includeSelf):
    
    if includeSelf:
        self.first = p.copy()
        self.after = p.nodeAfterTree()
    elif p.hasChildren():
        self.first = p.copy().moveToFirstChild() 
        self.after = p.nodeAfterTree()
    else:
        self.first = None
        self.after = None

    self.p = None
    self.copy = copy
    
def __iter__(self):

    return self
</t>
<t tx="ekr.20040305173559.2">def next(self):
    
    if self.first:
        self.p = self.first
        self.first = None

    elif self.p:
        self.p.moveToThreadNext()

    if self.p and self.p != self.after:
        if self.copy: return self.p.copy()
        else:         return self.p
    else:
        raise StopIteration</t>
<t tx="ekr.20040305222924"></t>
<t tx="ekr.20040305222924.1">def setHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
    p.setDirty()
    
def initHeadString (self,s,encoding="utf-8"):
    
    p = self
    p.v.initHeadString(s,encoding)
</t>
<t tx="ekr.20040305223225">def setHeadStringOrHeadline (self,s,encoding="utf-8"):

    p = self ; c = p.c
    
    t = p.edit_text()
    
    p.initHeadString(s,encoding)

    if t:
        
        state = t.cget("state")
        # g.trace(state,s)
        t.configure(state="normal")
        t.delete("1.0","end")
        t.insert("end",s)
        t.configure(state=state)

    p.setDirty()</t>
<t tx="ekr.20040305223522">def setBodyStringOrPane (self,s,encoding="utf-8"):

    p = self ; v = p.v ; c = p.c
    if not c or not v: return

    s = g.toUnicode(s,encoding)
    if p == c.currentPosition():
        # 7/23/04: Revert to previous code, but force an empty selection.
        c.frame.body.setSelectionAreas(s,None,None)
        c.frame.body.setTextSelection(None)
        # This code destoys all tags, so we must recolor.
        c.recolor()
        
    # Keep the body text in the tnode up-to-date.
    if v.t.bodyString != s:
        v.setTnodeText(s)
        v.t.setSelection(0,0)
        p.setDirty()
        if not c.isChanged():
            c.setChanged(True)

setBodyTextOrPane = setBodyStringOrPane # Compatibility with old scripts</t>
<t tx="ekr.20040306060312">def moveToLastChildOf (self,parent):

    """Move a position to the last child of parent."""

    p = self # Do NOT copy the position!

    p.unlink()
    n = p.numberOfChildren()
    p.linkAsNthChild(parent,n)

    # Moving a node can create a new root node.
    if not parent.hasParent() and not parent.hasBack():
        p.c.setRootPosition(parent)
        
    return p
</t>
<t tx="ekr.20040306210951"></t>
<t tx="ekr.20040306211032">def anyAtFileNodeName         (self): return self.v.anyAtFileNodeName()
def atFileNodeName            (self): return self.v.atFileNodeName()
def atNoSentinelsFileNodeName (self): return self.v.atNoSentinelsFileNodeName()
def atRawFileNodeName         (self): return self.v.atRawFileNodeName()
def atSilentFileNodeName      (self): return self.v.atSilentFileNodeName()
def atThinFileNodeName        (self): return self.v.atThinFileNodeName()

# New names, less confusing
atNoSentFileNodeName  = atNoSentinelsFileNodeName
atNorefFileNodeName   = atRawFileNodeName
atAsisFileNodeName    = atSilentFileNodeName

def isAnyAtFileNode         (self): return self.v.isAnyAtFileNode()
def isAtAllNode             (self): return self.v.isAtAllNode()
def isAtFileNode            (self): return self.v.isAtFileNode()
def isAtIgnoreNode          (self): return self.v.isAtIgnoreNode()
def isAtNoSentinelsFileNode (self): return self.v.isAtNoSentinelsFileNode()
def isAtOthersNode          (self): return self.v.isAtOthersNode()
def isAtRawFileNode         (self): return self.v.isAtRawFileNode()
def isAtSilentFileNode      (self): return self.v.isAtSilentFileNode()
def isAtThinFileNode        (self): return self.v.isAtThinFileNode()

# New names, less confusing:
isAtNoSentFileNode = isAtNoSentinelsFileNode
isAtNorefFileNode  = isAtRawFileNode
isAtAsisFileNode   = isAtSilentFileNode

# Utilities.
def matchHeadline (self,pattern): return self.v.matchHeadline(pattern)
## def afterHeadlineMatch (self,s): return self.v.afterHeadlineMatch(s)</t>
<t tx="ekr.20040306212151">def extraAttributes (self):
    
    return self.v.extraAttributes()

def setExtraAttributes (self,data):

    return self.v.setExtraAttributes(data)</t>
<t tx="ekr.20040306212636"></t>
<t tx="ekr.20040306212636.1">def numberOfChildren (self):
    
    return self.v.numberOfChildren()
</t>
<t tx="ekr.20040306214240.2"></t>
<t tx="ekr.20040306214240.3">def hasChildren(self):
    
    p = self
    # g.trace(p,p.v)
    return p.v and p.v.t and p.v.t._firstChild</t>
<t tx="ekr.20040306214401">def isDirty     (self): return self.v.isDirty()
def isExpanded  (self): return self.v.isExpanded()
def isMarked    (self): return self.v.isMarked()
def isOrphan    (self): return self.v.isOrphan()
def isSelected  (self): return self.v.isSelected()
def isTopBitSet (self): return self.v.isTopBitSet()
def isVisited   (self): return self.v.isVisited()
def status      (self): return self.v.status()</t>
<t tx="ekr.20040306215056">def isCloned (self):
    
    return len(self.v.t.vnodeList) &gt; 1</t>
<t tx="ekr.20040306215548">def findRoot (self):
    
    return self.c.frame.rootPosition()</t>
<t tx="ekr.20040306220230">def bodyString (self):
    
    return self.v.bodyString()

def headString (self):
    
    return self.v.headString()
    
def cleanHeadString (self):
    
    return self.v.cleanHeadString()
</t>
<t tx="ekr.20040306220230.1">def edit_text (self):
    
    # New in 4.3 beta 3: let the tree classes do all the work.
    
    p = self ; c = p.c
    
    return c.frame.tree.edit_text(p)</t>
<t tx="ekr.20040306220634"></t>
<t tx="ekr.20040306220634.8">def computeIcon (self):
    
    return self.v.computeIcon()
    
def setIcon (self):

    pass # Compatibility routine for old scripts</t>
<t tx="ekr.20040306220634.9"># Clone bits are no longer used.
# Dirty bits are handled carefully by the position class.

def clearMarked  (self):
    g.doHook("clear-mark",c=self.c,p=self)
    return self.v.clearMarked()

def clearOrphan  (self): return self.v.clearOrphan()
def clearVisited (self): return self.v.clearVisited()

def contract (self): return self.v.contract()
def expand   (self): return self.v.expand()

def initExpandedBit    (self): return self.v.initExpandedBit()
def initMarkedBit      (self): return self.v.initMarkedBit()
def initStatus (self, status): return self.v.initStatus()
    
def setMarked (self):
    g.doHook("set-mark",c=self.c,p=self)
    return self.v.setMarked()

def setOrphan   (self): return self.v.setOrphan()
def setSelected (self): return self.v.setSelected()
def setVisited  (self): return self.v.setVisited()</t>
<t tx="ekr.20040306220634.17"># Compatibility routine for scripts.

def clearVisitedInTree (self):
    
    for p in self.self_and_subtree_iter():
        p.clearVisited()
</t>
<t tx="ekr.20040306220634.29">def setSelection (self,start,length):

    return self.v.setSelection(start,length)</t>
<t tx="ekr.20040306220634.31">def trimTrailingLines (self):

    return self.v.trimTrailingLines()</t>
<t tx="ekr.20040307104131.1">def isAncestorOf (self, p2):
    
    p = self
    
    if 0: # Avoid the copies made in the iterator.
        for p3 in p2.parents_iter():
            if p3 == p:
                return True

    # Avoid calling p.copy() or copying the stack.
    v2 = p2.v ; n = len(p2.stack)-1
        # Major bug fix 7/22/04: changed len(p.stack) to len(p2.stack.)
    v2,n = p2.vParentWithStack(v2,p2.stack,n)
    while v2:
        if v2 == p.v:
            return True
        v2,n = p2.vParentWithStack(v2,p2.stack,n)

    return False</t>
<t tx="ekr.20040307104131.2">def isRoot (self):
    
    p = self

    return not p.hasParent() and not p.hasBack()</t>
<t tx="ekr.20040307104131.3">def exists(self,c):
    
    """Return True if a position exists in c's tree"""
    
    p = self.copy()
    
    # This code must be fast.
    root = c.rootPosition()
    while p:
        if p == root:
            return True
        if p.hasParent():
            p.moveToParent()
        else:
            p.moveToBack()
        
    return False</t>
<t tx="ekr.20040310062332"># These remain in 4.2:  linking and unlinking does not depend on position.

# These are private routines:  the position class does not define proxies for these.</t>
<t tx="ekr.20040310062332.1">def invalidOutline (self, message):
    
    p = self

    if p.hasParent():
        node = p.parent()
    else:
        node = p

    g.alert("invalid outline: %s\n%s" % (message,node))</t>
<t tx="ekr.20040310062332.2">def linkAfter (self,after):

    """Link self after v."""
    
    p = self
    # g.trace(p,after)
    
    p.stack = after.stack[:] # 3/12/04
    p.v._parent = after.v._parent
    
    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
    
    p.v._back = after.v
    p.v._next = after.v._next
    
    after.v._next = p.v
    
    if p.v._next:
        p.v._next._back = p.v

    if 0:
        g.trace('-'*20,after)
        p.dump(label="p")
        after.dump(label="back")
        if p.hasNext(): p.next().dump(label="next")</t>
<t tx="ekr.20040310062332.3">def linkAsNthChild (self,parent,n):

    """Links self as the n'th child of vnode pv"""
    
    # g.trace(self,parent,n)
    p = self

    # Recreate the stack using the parent.
    p.stack = parent.stack[:] 
    if parent.isCloned():
        p.stack.append(parent.v)

    p.v._parent = parent.v

    # Add v to it's tnode's vnodeList.
    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)

    if n == 0:
        child1 = parent.v.t._firstChild
        p.v._back = None
        p.v._next = child1
        if child1:
            child1._back = p.v
        parent.v.t._firstChild = p.v
    else:
        prev = parent.nthChild(n-1) # zero based
        assert(prev)
        p.v._back = prev.v
        p.v._next = prev.v._next
        prev.v._next = p.v
        if p.v._next:
            p.v._next._back = p.v
            
    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        parent.dump(label="parent")</t>
<t tx="ekr.20040310062332.4">def linkAsRoot (self,oldRoot):
    
    """Link self as the root node."""
    
    # g.trace(self,oldRoot)

    p = self ; v = p.v
    if oldRoot: oldRootVnode = oldRoot.v
    else:       oldRootVnode = None
    
    p.stack = [] # Clear the stack.
    
    # Clear all links except the child link.
    v._parent = None
    v._back = None
    v._next = oldRootVnode # Bug fix: 3/12/04
    
    # Add v to it's tnode's vnodeList. Bug fix: 5/02/04.
    if v not in v.t.vnodeList:
        v.t.vnodeList.append(v)

    # Link in the rest of the tree only when oldRoot != None.
    # Otherwise, we are calling this routine from init code and
    # we want to start with a pristine tree.
    if oldRoot:
        oldRoot.v._back = v # Bug fix: 3/12/04

    p.c.setRootPosition(p)
    
    if 0:
        p.dump(label="root")
</t>
<t tx="ekr.20040310062332.5">def unlink (self):

    """Unlinks a position p from the tree before moving or deleting.
    
    The p.v._fistChild link does NOT change."""

    p = self ; v = p.v ; parent = p.parent()
    
    # Note:  p.parent() is not necessarily the same as v._parent.
    
    if parent:
        assert(p.v and p.v._parent in p.v.directParents())
        assert(parent.v in p.v.directParents())

    # g.trace("parent",parent," child:",v.t._firstChild," back:",v._back, " next:",v._next)
    
    # Special case the root.
    if p == p.c.rootPosition():
        assert(p.v._next)
        p.c.setRootPosition(p.next())
    
    # Remove v from it's tnode's vnodeList.
    vnodeList = v.t.vnodeList
    if v in vnodeList:
        vnodeList.remove(v)
    assert(v not in vnodeList)
    
    # Reset the firstChild link in its direct father.
    if parent and parent.v.t._firstChild == v:
        parent.v.t._firstChild = v._next

    # Do _not_ delete the links in any child nodes.

    # Clear the links in other nodes.
    if v._back: v._back._next = v._next
    if v._next: v._next._back = v._back

    # Unlink _this_ node.
    v._parent = v._next = v._back = None

    if 0:
        g.trace('-'*20)
        p.dump(label="p")
        if parent: parent.dump(label="parent")
</t>
<t tx="ekr.20040310153624">def dumpLink (self,link):

    return g.choose(link,link,"&lt;none&gt;")

def dump (self,label=""):
    
    p = self
    print '-'*10,label,p
    if p.v:
        p.v.dump() # Don't print a label
        
def vnodeListIds (self):
    
    p = self
    return [id(v) for v in p.v.t.vnodeList]</t>
<t tx="ekr.20040311113514">def clearDirty (self):

    p = self
    p.v.clearDirty()</t>
<t tx="ekr.20040312015705"># Compatibility routine for scripts.

def clearAllVisited (self):
    
    for p in self.allNodes_iter():
        p.clearVisited()</t>
<t tx="ekr.20040312015908"></t>
<t tx="ekr.20040315023430">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315023430.1">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.self_and_subtree_iter():
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)
</t>
<t tx="ekr.20040315023430.2">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040315023430.3">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; array = []
    lines = string.split(p.bodyString(),'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s) and s[i] in ('+','-','\\'):
            s = s[:i] + '\\' + s[i:]
        array.append(s)
    return '\n'.join(array)</t>
<t tx="ekr.20040315031401"></t>
<t tx="ekr.20040315031445">def scriptSetBodyString (self,s,encoding="utf-8"):
    
    """Update the body string for the receiver.
    
    Should be called only from scripts: does NOT update body text."""

    self.v.t.bodyString = g.toUnicode(s,encoding)</t>
<t tx="ekr.20040315032503">def appendStringToBody (self,s,encoding="utf-8"):
    
    p = self
    if not s: return
    
    body = p.bodyString()
    assert(g.isUnicode(body))
    s = g.toUnicode(s,encoding)

    p.setBodyStringOrPane(body + s,encoding)</t>
<t tx="ekr.20040315034158">def setTnodeText (self,s,encoding="utf-8"):
    
    return self.v.setTnodeText(s,encoding)</t>
<t tx="ekr.20040318125934">def findAllPotentiallyDirtyNodes(self):
    
    p = self 
    
    # Start with all nodes in the vnodeList.
    nodes = []
    newNodes = p.v.t.vnodeList[:]

    # Add nodes until no more are added.
    while newNodes:
        addedNodes = []
        nodes.extend(newNodes)
        for v in newNodes:
            for v2 in v.t.vnodeList:
                if v2 not in nodes and v2 not in addedNodes:
                    addedNodes.append(v2)
                for v3 in v2.directParents():
                    if v3 not in nodes and v3 not in addedNodes:
                        addedNodes.append(v3)
        newNodes = addedNodes[:]

    # g.trace(len(nodes))
    return nodes</t>
<t tx="ekr.20040321065415">def findNodeInTree(p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    c = p.c
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(headline):
    
    c = g.top()
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(headline):
    
    c = g.top()
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20040323160302">def directParents (self):
    
    return self.v.directParents()
</t>
<t tx="ekr.20040325142015">def equal(self,p2):

    """Return True if two postions are equivalent.
    
    Use this method when the speed comparisons is crucial
    
    N.B. Unlike __cmp__, p2 must not be None.
    
    &gt;&gt;&gt; c = g.top() ; p = c.currentPosition() ; root = c.rootPosition()
    &gt;&gt;&gt; n = g.app.positions
    &gt;&gt;&gt; assert p.equal(p.copy()) is True
    &gt;&gt;&gt; assert p.equal(root) is False
    &gt;&gt;&gt; assert g.app.positions == n + 1
    &gt;&gt;&gt; 
    """

    p1 = self
    
    # if g.app.trace: "equal",p1.v,p2.v

    # Check entire stack quickly.
    # The stack contains vnodes, so this does not call p.__cmp__.
    return (
        p1.v == p2.v and
        p1.stack == p2.stack and
        p1.childIndex() == p2.childIndex())
        
isEqual = equal
</t>
<t tx="ekr.20040326064330">def childIndex(self):
    
    p = self ; v = p.v
    
    # This is time-critical code!
    
    # 3/25/04: Much faster code:
    if not v or not v._back:
        return 0

    n = 0 ; v = v._back
    while v:
        n += 1
        v = v._back

    return n</t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040327114250">@ignore

# A file to be executed in batch mode as part of unit testing.

@language python
@tabwidth -4

path = r"c:\prog\test\unittest\createdFile.txt"
f = None
try:
    f = open(path,"w")
    f.write("This is a test")
finally:
    if f: f.close()</t>
<t tx="ekr.20040409203454">def restoreLinksInTree (self):

    """Restore links when undoing a delete node operation."""
    
    root = p = self

    if p.v not in p.v.t.vnodeList:
        p.v.t.vnodeList.append(p.v)
        
    for p in root.children_iter():
        p.restoreLinksInTree()</t>
<t tx="ekr.20040409203454.1">def deleteLinksInTree (self):
    
    """Delete and otherwise adjust links when deleting node."""
    
    root = self

    root.deleteLinksInSubtree()
    
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20040410170806">def deleteLinksInSubtree (self):

    root = p = self

    # Delete p.v from the vnodeList
    if p.v in p.v.t.vnodeList:
        p.v.t.vnodeList.remove(p.v)
        assert(p.v not in p.v.t.vnodeList)
        # g.trace("deleted",p.v,p.vnodeListIds())
    else:
        # g.trace("not in vnodeList",p.v,p.vnodeListIds())
        pass

    if len(p.v.t.vnodeList) == 0:
        # This node is not shared by other nodes.
        for p in root.children_iter():
            p.deleteLinksInSubtree()</t>
<t tx="ekr.20040410170806.1">def adjustParentLinksInSubtree (self,parent):
    
    root = p = self
    
    assert(parent)
    
    if p.v._parent and parent.v.t.vnodeList and p.v._parent not in parent.v.t.vnodeList:
        p.v._parent = parent.v.t.vnodeList[0]
        
    for p in root.children_iter():
        p.adjustParentLinksInSubtree(parent=root)</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.2 final, build %s, September 20, 2004" % c.getBuildNumber()
</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.163 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = g.app.config.getWindowPref("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, %s" % (n1,n2,n3,tkLevel,sys.platform))
    g.enl()</t>
<t tx="ekr.20040702104823">def inAtIgnoreRange (self):
    
    """Returns True if position p or one of p's parents is an @ignore node."""
    
    p = self
    
    for p in p.self_and_parents_iter():
        if p.isAtIgnoreNode():
            return True

    return False</t>
<t tx="ekr.20040707081532.1"># You can run all tests by selecting the Unit Test headline.

import leoTest
reload(leoTest)

leoTest.doTests(all=False)</t>
<t tx="ekr.20040707141957.12">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.13">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.14">#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:@@thin
Line 1

#@@last
#@nonl
#@-node:ekr.20040707141957.13:@@thin
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040712101754"></t>
<t tx="ekr.20040712101754.2">@language python
@tabwidth -4</t>
<t tx="ekr.20040712101754.3">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040712101754.4">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","src","LeoPy.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.5">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","plugins","leoPlugins.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.6">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.7">@language python
@tabwidth -4</t>
<t tx="ekr.20040712101754.8"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("importTests",doImport=True)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.9"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g

import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("exportTests",doImport=False)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.10">@language plain</t>
<t tx="ekr.20040712101754.11"></t>
<t tx="ekr.20040712101754.12"></t>
<t tx="ekr.20040712101754.13">openFileDialog
c:\\prog\\test\\perfectImport\\formatter.py</t>
<t tx="ekr.20040712101754.14"></t>
<t tx="ekr.20040712101754.15">openFileDialog
c:\\prog\\test\\perfectImport\\formatter.py</t>
<t tx="ekr.20040712101754.16"></t>
<t tx="ekr.20040712101754.17">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040712101754.18"></t>
<t tx="ekr.20040712101754.19">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040712101754.20"></t>
<t tx="ekr.20040712101754.21">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040712101754.22"></t>
<t tx="ekr.20040712101754.23">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040712101754.24">@language plain</t>
<t tx="ekr.20040712101754.25"></t>
<t tx="ekr.20040712101754.26"></t>
<t tx="ekr.20040712101754.27">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040712101754.28"></t>
<t tx="ekr.20040712101754.29">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040712101754.30"></t>
<t tx="ekr.20040712101754.31">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040712101754.32"></t>
<t tx="ekr.20040712101754.33">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040712101754.34"></t>
<t tx="ekr.20040712101754.35">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040712101754.36"></t>
<t tx="ekr.20040712101754.37"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeEditBodySuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.38">@language plain

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.</t>
<t tx="ekr.20040712101754.39"></t>
<t tx="ekr.20040712101754.40"></t>
<t tx="ekr.20040712101754.41">before
&lt;&lt; section &gt;&gt;
sec line 1
    sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040712101754.42">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040712101754.43">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20040712101754.44">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040712101754.45"></t>
<t tx="ekr.20040712101754.46">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040712101754.47">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040712101754.48">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040712101754.49"></t>
<t tx="ekr.20040712101754.50">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040712101754.51">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040712101754.52">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040712101754.53"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeReformatParagraphSuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.54">@language plain

Changed made by EKR on 7/8/04.

- Created @suite node to call makeReformatParagraphSuite

- Used makeSuite(reformatParagraphTestCase,'test') in makeReformatParagraphSuite instead of list of tests.

- modified setUp to handle these new conventions.
    - Search for reformatParagraphsTests anywhere in the tree
    - Created tempNode inside reformatParagraphsTests tree.</t>
<t tx="ekr.20040712101754.55">@language plain

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth and language formatting directives
</t>
<t tx="ekr.20040712101754.56"></t>
<t tx="ekr.20040712101754.57">@language plain
@pagewidth 40
@tabwidth 8

Wrap a long line, no trailing newline.</t>
<t tx="ekr.20040712101754.58">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040712101754.59">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040712101754.60">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040712101754.61">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040712101754.62">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040712101754.63">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040712101754.64">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040712101754.65">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040712101754.66">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040712101754.67">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040712101754.68">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040712101754.69">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040712101754.70">This line is under 40 chars.</t>
<t tx="ekr.20040712101754.71">This line is under 40 chars.</t>
<t tx="ekr.20040712101754.72">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040712101754.73">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040712101754.74">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040712101754.75">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040712101754.76">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040712101754.77">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040712101754.78">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040712101754.79">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040712101754.80">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040712101754.81">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040712101754.82">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040712101754.83">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040712101754.84">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040712101754.85">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20040712101754.86">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040712101754.87">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Multiple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040712101754.88">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040712101754.89">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040712101754.90">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040712101754.91">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040712101754.92">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040712101754.93">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040712101754.94">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040712101754.95">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040712101754.96">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040712101754.97">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040712101754.98">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040712101754.99">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
    print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

if 0: # all nodes
    for v in c.all_vnodes_iter(): print v
    for t in c.all_tnodes_iter(): print t
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print v
    for t in c.all_unique_tnodes_iter(): print t</t>
<t tx="ekr.20040712101754.100">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"</t>
<t tx="ekr.20040712101754.101">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20040712101754.102">@language plain</t>
<t tx="ekr.20040712101754.103">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.104">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040712101754.105">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@nonl
#@-node:@@file
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040712101754.106">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.107">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20040712101754.108">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20040712101754.109">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.110">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.111">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.115"></t>
<t tx="ekr.20040712101754.116">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.117">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
continues */

More plain text.</t>
<t tx="ekr.20040712101754.118">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.119">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040712101754.120">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.121">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040712101754.122">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.123">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040712101754.124">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.125">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20040712101754.126">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.127">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section references are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040712101754.128">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20040712101754.129">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.130">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040712101754.131">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.132">@language html

b = "cd"
d
</t>
<t tx="ekr.20040712101754.133">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.134">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040712101754.135">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.136">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040712101754.137">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.138">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040712101754.139">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.140">@ignore
@ doc
@c
@language c
    @others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040712101754.141">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.142">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20040712101754.143">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.144">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20040712101754.145">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="ekr.20040712101754.146">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="ekr.20040712101754.147">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="ekr.20040712101754.148">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="ekr.20040712101754.149">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="ekr.20040712101754.150">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="ekr.20040712101754.151">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="ekr.20040712101754.152">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20040712101754.153">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20040712101754.154">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.155">@language python

"""python
string""" ; following = a

'this\
is'''</t>
<t tx="ekr.20040712101754.156">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.157">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
    
def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20040712101754.158">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.159">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20040712101754.160">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.161">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040712101754.162">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.163"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20040712101754.164">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.165">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20040712101754.166">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="ekr.20040712101754.167">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="ekr.20040712101754.168">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.169"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

import leoGlobals as g ; print g.app().loadDir</t>
<t tx="ekr.20040712101754.170">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.171"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

import leoGlobals as g ; print g.app().loadDir
</t>
<t tx="ekr.20040712101754.172">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.173"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass</t>
<t tx="ekr.20040712101754.174"></t>
<t tx="ekr.20040712101754.175">import leoGlobals as g
c = g.top()
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
    assert(p.t == p.v.t)</t>
<t tx="ekr.20040712101754.176">import leoGlobals as g
c = g.top()

c.frame.body.colorizer.python_keywords.append("as")</t>
<t tx="ekr.20040712101754.177">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

p = p.firstChild()
assert(p.headString()=="File Conversion")
p.convertTreeToString()</t>
<t tx="ekr.20040712101754.178">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040712101754.179">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040712101754.180">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.bodyString() ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040712101754.181"># The actual test is in a child node.</t>
<t tx="ekr.20040712101754.182"></t>
<t tx="ekr.20040712101754.183">import leoGlobals as g
c = g.top()

try:
    for p in c.allNodes_iter():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            if p.v._parent: parents1 = p.v._parent.t.vnodeList
            else:           parents1 = []
            parents2 = p.v.directParents()
        
        assert len(parents1) == len(parents2), "length mismatch: %s, %s" % (p,p.v._parent)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print "parents1"
    for parent in parents1: print parent
    print "parents2"
    for parent in parents2: print parent
    raise</t>
<t tx="ekr.20040712101754.184">import leoGlobals as g
c = g.top()
try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert len(parents) == len(vparents), "length mismatch: %s,%s" % (p,child)
                for parent in parents:
                    assert parent in vparents, "not in vparents: %s,%s" % (p,child)
                for parent in vparents:
                    assert parent in parents, "not in parents: %s,%s" % (p,child)
except AssertionError:
    print "parents..."
    for parent in parents: print parent
    print "vparents..."
    for parent in vparents: print parent
    raise # for unittest.</t>
<t tx="ekr.20040712101754.185">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040712101754.186">import os

path = r"c:\prog\test\unittest\createdFile.txt"

s = r"c:\python23\python c:\prog\LeoCVS\leo\src\leo.py -script c:\prog\test\unittest\batchTest.py"

if os.path.exists(path):
    print ; print "@test batch mode: deleting",path
    os.remove(path)

os.system(s)
assert(os.path.exists(path))
</t>
<t tx="ekr.20040712101754.187"></t>
<t tx="ekr.20040712101754.188">import leoNodes
import leoGlobals as g

c = g.top()
current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print v
    for v in vList2: print v

if 0:
    print len(allList),len(vList1),len(vList2)

&lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="ekr.20040712101754.189"></t>
<t tx="ekr.20040712101754.190"></t>
<t tx="ekr.20040712101754.191"></t>
<t tx="ekr.20040712101754.192"></t>
<t tx="ekr.20040712101754.193"></t>
<t tx="ekr.20040712101754.194"></t>
<t tx="ekr.20040712101754.195"></t>
<t tx="ekr.20040712101754.196">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    # print "consistency tests pass"

except AssertionError:
    print tag
    print "list1"
    for v in list1: print v
    print "list2"
    for v in list2: print v
    raise</t>
<t tx="ekr.20040712101754.197">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20040712101754.198">if 0:
    for v in current.vnodes_iter(): print v
    for v in current.unique_vnodes_iter(): print v

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print v
    for t in root.tnodes_iter(): print t

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print v
    for t in child.tnodes_iter(): print t</t>
<t tx="ekr.20040712101754.199">import leoGlobals as g
c = g.top()
p = c.currentPosition()
    
assert(p == p.copy())
assert(p != p.threadNext())</t>
<t tx="ekr.20040712101754.200">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040712101754.201">import leoGlobals as g
c = g.top()

for copy in (True,False):
    p2 = c.rootPosition()
    for p in c.allNodes_iter(copy=copy):
        assert p==p2, "%s != %s" % (p,p2)
        p2.moveToThreadNext()
        
    assert not p2, repr(p2)
</t>
<t tx="ekr.20040712101754.202">import leoGlobals as g
c = g.top()

for copy in (True,False):
    for p in c.allNodes_iter(copy=copy):
        
        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToNext()

    assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.203">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)
        
    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())</t>
<t tx="ekr.20040712101754.204">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040712101754.205">import leoGlobals as g
c = g.top()

for copy in (True,False):

    for p in c.allNodes_iter():
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToParent()

        assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.206"># Test consistency of p.parent, p.next, p.back and p.firstChild.

import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))
        
    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())
        
    if p.hasBack():
        assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040712101754.207">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040712101754.208">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned():
        parents = p.v.t.vnodeList
        for child in p.children_iter():
            vparents = child.v.directParents()
            assert(len(parents) == len(vparents))
            for parent in parents:
                assert(parent in vparents)
            for parent in vparents:
                assert(parent in parents)</t>
<t tx="ekr.20040712101754.209">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))
            
    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))</t>
<t tx="ekr.20040712101754.210">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))
            
    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))</t>
<t tx="ekr.20040712101754.211">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))
            
    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040712101754.212">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    vnodeList = p.v.t.vnodeList

    for v in vnodeList:

        assert(v.t == p.v.t)
        if p.v.isCloned():
            assert(v.isCloned())
            assert(len(vnodeList) &gt; 1)
        else:
            assert(not v.isCloned())
            assert(len(vnodeList) == 1)</t>
<t tx="ekr.20040712101754.213"></t>
<t tx="ekr.20040712101754.214"></t>
<t tx="ekr.20040712101754.215">import leoGlobals as g
import leoNodes

c = g.top();  p = c.currentPosition()
root1 = p.firstChild()

root2 = root1.copyTreeAfter()
root2.initHeadString("root2")
c.checkOutline()
c.redraw()
root2.doDelete(root1)
c.checkOutline()
c.redraw()</t>
<t tx="ekr.20040712101754.216"></t>
<t tx="ekr.20040712101754.217"></t>
<t tx="ekr.20040712101754.218"></t>
<t tx="ekr.20040712101754.219"></t>
<t tx="ekr.20040712101754.220"></t>
<t tx="ekr.20040712101754.221">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.headString()=="outline1")
assert(outline2.headString()=="outline2")

u.replaceOutline(c,outline1,outline2)
c.redraw()
c.checkOutline()</t>
<t tx="ekr.20040712101754.222"></t>
<t tx="ekr.20040712101754.223"></t>
<t tx="ekr.20040712101754.224"></t>
<t tx="ekr.20040712101754.225"></t>
<t tx="ekr.20040712101754.226">def replaceOutline (self,c,outline1,outline2):
    
    """Replace outline1 by a copy of outline 2,
    
    retaining the headline of outline1."""

    u = self
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete(copy)</t>
<t tx="ekr.20040712101754.227"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = makeOutlineSuite("outlineTests")

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.228">def makeOutlineSuite(parentHeadline):
    
    """Create an outline test for every descendant of testParentHeadline.."""
    
    c = g.top() ; v = c.currentVnode()
    u = leoTest.testUtils()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    parent = u.findNodeAnywhere(c,parentHeadline)
    
    for child in parent.children_iter(copy=True):
        before = u.findNodeInTree(child,"before")
        after  = u.findNodeInTree(child,"after")
        ref    = u.findNodeInTree(child,"ref")
        if before and after and ref:
            test = outlineTestCase(c,child,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040712101754.229">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20040712101754.230">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.u = leoTest.testUtils()

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref</t>
<t tx="ekr.20040712101754.231">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert move, "no move node"
    
    c.selectVnode(move)
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()

    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))</t>
<t tx="ekr.20040712101754.232">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20040712101754.233">def setUp(self,*args,**keys):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert self.u.compareOutlines(self.before,self.ref,compareHeadlines=False),\
        "compare failed"
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20040712101754.234">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()</t>
<t tx="ekr.20040712101754.235">def shortDescription (self):
    
    return self.parent.headString()</t>
<t tx="ekr.20040712101754.236"></t>
<t tx="ekr.20040712101754.237"></t>
<t tx="ekr.20040712101754.238"></t>
<t tx="ekr.20040712101754.239"></t>
<t tx="ekr.20040712101754.240"></t>
<t tx="ekr.20040712101754.241"></t>
<t tx="ekr.20040712101754.242"></t>
<t tx="ekr.20040712101754.243"></t>
<t tx="ekr.20040712101754.244"></t>
<t tx="ekr.20040712101754.245"></t>
<t tx="ekr.20040712101754.246"></t>
<t tx="ekr.20040712101754.247"></t>
<t tx="ekr.20040712101754.248"></t>
<t tx="ekr.20040712101754.249"></t>
<t tx="ekr.20040712101754.250"></t>
<t tx="ekr.20040712101754.251"></t>
<t tx="ekr.20040712101754.252"></t>
<t tx="ekr.20040712101754.253"></t>
<t tx="ekr.20040712101754.254"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = unittest.makeSuite(findCommandTestCase,'test')

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.255">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20040712101754.256">def setUp(self,*args,**keys):
    
    self.u = u = leoTest.testUtils()
    self.c = c = g.top()
    self.find_p = u.findNodeAnywhere(c,"findTests")
    
    assert(self.find_p)
</t>
<t tx="ekr.20040712101754.257">def testFindCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.258">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.259">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.260">aaa</t>
<t tx="ekr.20040712101754.261"></t>
<t tx="ekr.20040712101754.272">import leoGlobals as g

c = g.top()
errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.
assert errors == 0, "Check Outline reported %d errors" % errors</t>
<t tx="ekr.20040712101754.274">import leoGlobals as g
import unittest
import leoTest
reload(leoTest)
import sys

c = g.top()

# DocTestSuite exists in Python 2.3 and above.

if g.CheckVersion(sys.version, "2.3"):

    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    
    suite = leoTest.createUnitTestsFromDoctests(modules)
                                
    if suite:
        g.app.scriptDict['suite'] = suite
        
else:
    # Create an empty suite to suppress a warning.
    g.app.scriptDict['suite'] = unittest.TestSuite()
    print
    print "Can't create unit tests from doctests"
    print "doctest.DocTestSuite requires Python 2.3 or above."
    print</t>
<t tx="ekr.20040712101813">import leoGlobals as g

c = g.top()

result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20040713070526">@language python 

import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

dump = False 
all = False 

if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = u.findNodeInTree(p,"tempNode")
    before = u.findNodeInTree(p,"before")
    after = u.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.bodyString())
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.bodyString() == after.bodyString()</t>
<t tx="ekr.20040713071919">@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "  "
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others</t>
<t tx="ekr.20040713123617">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c 

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "  "
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others </t>
<t tx="ekr.20040713123828.1">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c 

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "  "
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others </t>
<t tx="ekr.20040715154319">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import unittest

c = g.top()

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False,suppressErrors=True)

assert result=="error", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20040716071029.6"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716071856">#@+leo-ver=4-thin
#@+node:ekr.20040716071856.1:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716071856.1:-input
#@-leo
</t>
<t tx="ekr.20040716071856.1">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716081019">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716081943">#@+leo-ver=4-thin
#@+node:ekr.20040716071856.1:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716071856.1:-input
#@-leo
</t>
<t tx="ekr.20040716084934">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716084934.1">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716091245">#@+leo-ver=4-thin
#@+node:ekr.20040716081019:-input-after
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716081019:-input-after
#@-leo
</t>
<t tx="ekr.20040716140926"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716140926.1">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.2">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.3">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.1:-input
Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.1:-input
#@-leo
</t>
<t tx="ekr.20040716140926.4">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.2:-input-after
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.2:-input-after
#@-leo
</t>
<t tx="ekr.20040716140926.5">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.6">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.7">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.1:-input
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.1:-input
#@-leo
</t>
<t tx="ekr.20040716141621"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716141621.1">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.2">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.3">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.1:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.1:-input
#@-leo
</t>
<t tx="ekr.20040716141621.4">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.2:-input-after
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.2:-input-after
#@-leo
</t>
<t tx="ekr.20040716141621.5">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.6">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.7">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.1:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.1:-input
#@-leo
</t>
<t tx="ekr.20040716142121"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

ignoreSentinelsInCompare = True # Fails when False

assert leoTest.runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=ignoreSentinelsInCompare)</t>
<t tx="ekr.20040716142121.2">root line 1
root line 2</t>
<t tx="ekr.20040716142121.3">#@+leo-ver=4-thin
#@+node:ekr.20040716142423:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142423:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.1:Node 1
node 1: line 1
node 1: line 2
#@-node:ekr.20040716142423.1:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.2:Node 2
node 2: line 1
node 2: line 2
#@-node:ekr.20040716142423.2:Node 2
#@-leo
</t>
<t tx="ekr.20040716142121.4">#@+leo-ver=4-thin
#@+node:ekr.20040716142121.2:-input-after
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142121.2:-input-after
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040717071133:Node 1
node 1: line 1
These lines should be totally different
#@-node:ekr.20040717071133:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040717071133.1:Node 2
and should span node boundaries
node 2: line 2
#@-node:ekr.20040717071133.1:Node 2
#@-leo
</t>
<t tx="ekr.20040716142121.5">root line 1
root line 2
node 1: line 1
node 1: line 2
node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20040716142121.6">root line 1
root line 2
node 1: line 1
These lines should be totally different
and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20040716142121.7">#@+leo-ver=4-thin
#@+node:ekr.20040716142423:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142423:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.1:Node 1
node 1: line 1
These lines should be totally different
and should span node boundaries
#@-node:ekr.20040716142423.1:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.2:Node 2
node 2: line 2
#@-node:ekr.20040716142423.2:Node 2
#@-leo
</t>
<t tx="ekr.20040716142423">root line 1
root line 2</t>
<t tx="ekr.20040716142423.1">node 1: line 1
node 1: line 2
</t>
<t tx="ekr.20040716142423.2">node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20040716144017"># See the node called "About the Perfect Import tests" in leoTests.py for how to set up these tests.
</t>
<t tx="ekr.20040717071133">node 1: line 1
These lines should be totally different
</t>
<t tx="ekr.20040717071133.1">and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20040722055040">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    child = p.firstChild()
    while child:
        for parent in p.self_and_parents_iter():
            assert parent.isAncestorOf(child)
        child.moveToNext()

    next = p.next()
    assert not p.isAncestorOf(next)</t>
<t tx="ekr.20040723062819"></t>
<t tx="ekr.20040730181601">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","minimalLeoFile.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040730181610">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","minimalLeoFile2.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040801124822.1">import leoGlobals as g
import leoTest
reload(leoTest)

leoTest.testPlugin("nodenavigator.py",verbose=False)</t>
<t tx="ekr.20040801141212"># N.B.  We don't import the files: multiple imports might cause problems.
import leoGlobals as g
import unittest
import leoTest
reload(leoTest)

c = g.top()

@others

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():

    f = file(path)
    assert f, "File not found: %s" % path
    s = f.read() ; f.close()
    test = parseFileTestCase(c,path,checkCompile=True,checkTabs=True)
    suite.addTest(test)

if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040801141543">class parseFileTestCase (unittest.TestCase):

    @others</t>
<t tx="ekr.20040801141543.1">def __init__ (self,c,path,checkCompile,checkTabs):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.checkCompile = checkCompile
    self.checkTabs = checkTabs
    assert self.checkCompile or self.checkTabs, "not checking anything"</t>
<t tx="ekr.20040801141543.3">def runTest(self):
    
    c = self.c ; path = self.path

    s = file(path).read()

    if self.checkCompile:
        leoTest.checkFileSyntax(path,s)

    if self.checkTabs:
        leoTest.checkFileTabs(path,s)</t>
<t tx="ekr.20040801141543.5">def shortDescription (self):
    
    fn = str(g.shortFileName(self.path))
    
    if self.checkCompile and self.checkTabs:
        return "Test syntax and tabbing of %s plugin" % fn
    elif self.checkCompile:
        return "Test syntax of %s plugin" % fn
    else:
        return "Test tabbing of %s plugin" % fn</t>
<t tx="ekr.20040801145836"># WARNING: Importing files this way tends to crash test.leo.

import leoGlobals as g
import unittest
import leoTest
reload(leoTest)

c = g.top()
verbose = False

@others

suite = unittest.makeSuite(unittest.TestCase)

g.app.unitTesting = True # Disable additional installation.

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():
    dir,fileName = g.os_path_split(path)
    try:
        module = g.importFromPath(fileName,dir)
    except:
        s = "Can not import %s" % path
        print s ; g.es(s)
        module = None
    
    # Run any unit tests in the module itself.
    if module and hasattr(module,"unitTest"):
        if verbose:
            print "Creating unit test for plugins/%s..." % fileName
        test = runPluginTestCase(c,path,module,verbose=verbose)
        suite.addTest(test)

    g.app.unitTesting = True # Disable additional installation.

if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040801150333">class runPluginTestCase (unittest.TestCase):

    @others</t>
<t tx="ekr.20040801150333.1">def __init__ (self,c,path,module,verbose=False):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.module = module</t>
<t tx="ekr.20040801150333.2">def runTest(self):
    
    fn = g.shortFileName(self.path)
    
    self.module.unitTest(verbose=verbose)</t>
<t tx="ekr.20040801150333.3">def shortDescription (self):
    
    fn = str(g.shortFileName(self.path))
    
    return "Run unitTest function in %s plugin if it exists" % fn</t>
<t tx="ekr.20040802065214"># Make sure that changing this headline marks descendant @thin nodes dirty.

import leoGlobals as g

c = g.top() ; p = c.currentPosition()

h = p.headString()

c.beginUpdate()
try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.headString() == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    p.setHeadString("changed")
    assert child.isDirty(), "setting descendant @thin nodes dirty failed."
finally:
    p.setHeadString(h)
    child.setHeadString("bogus")
    p.clearDirty()
    child.clearDirty()
c.endUpdate()
</t>
<t tx="ekr.20040802065214.1">test</t>
<t tx="ekr.20040802071519"># Tests that p.setBodyStringOrPane works immediately.

import leoGlobals as g

c = g.top() ; p = c.currentPosition()

h = p.headString()

try:
    child = p.firstChild()
    before = child.bodyString()
    after = "after"
    child.setBodyStringOrPane("after")
    c.selectPosition(child)
    t = c.frame.body.bodyCtrl
    s = t.get("1.0","end")
    assert s.rstrip() == after.rstrip(), \
        "setBodyStringOrPane failed: %s, %s" % (repr(s),repr(after))
finally:
    child.setBodyStringOrPane(before)
    c.selectPosition(p)</t>
<t tx="ekr.20040802071519.1">after</t>
<t tx="ekr.20040803090901">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","dist","leoDist.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040803091512">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; u = leoTest.testUtils()

name = "@thin ../src/leoTest.py"

p = u.findNodeAnywhere(c,name)

assert p, "Can't find %s" % name

p.v.t.tnodeList = ["bogus tnodeList"]

if 0: # This causes p to be written, thereby clearing the tnodeList.
    p.setDirty()
    
if 0: # This actually saves this file, so it is a bit dangerous.
    g.app.unitTesting = True
    g.app.unitTestDict = {}
    c.save()
    ok = g.app.unitTestDict.get("warning")
    assert ok, "putVnode failed to give warning"
    g.app.unitTesting = False</t>
<t tx="ekr.20040803111240"></t>
<t tx="ekr.20040803140033.4">def isCurrentPosition (self):
    
    p = self ; c = p.c
    
    return c.isCurrentPosition(p)
    
</t>
<t tx="ekr.20040803140033.5">def isRootPosition (self):
    
    p = self ; c = p.c
    
    return c.isRootPosition(p)</t>
<t tx="ekr.20040831095833"></t>
<t tx="ekr.20040831095833.1">openFileDialog
c:\\prog\\leoCvs\\leo\\src\\leo.py</t>
<t tx="ekr.20040831101747"># Apparently these file are fine when they are written.
# The problem comes later in the distribution process.

import leoGlobals as g

def checkLinuxLineEndings(filename):
    
    s = open(filename,"rb").read()
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
    assert cr == 0, "cr: %d, nl: %d" % (cr,nl)
    
path = r"c:\prog\leoCvs\leo" # The source file.
# path = r"c:\prog\test" # As distributed.

for file in ("install","uninstall"):
    checkLinuxLineEndings(g.os_path_join(path,file))
</t>
<t tx="ekr.20040831104758">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","minimalLeoFile3.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040917062206">import leoGlobals as g
assert(g.cantImport("xyzzy") is None)</t>
<t tx="ekr.20041001194357"># You can run all tests by selecting the Unit Test headline.

import leoTest
reload(leoTest)

leoTest.doTests(all=False)</t>
<t tx="ekr.20041006103243">@ignore</t>
<t tx="ekr.20041006103243.2">@killcolor

- 

- .
   </t>
<t tx="ekr.20041006103243.3"></t>
<t tx="ekr.20041006103243.4"></t>
<t tx="ekr.20041006103243.5"></t>
<t tx="ekr.20041006103243.6"></t>
<t tx="ekr.20041006103243.8"></t>
<t tx="ekr.20041006103243.9"></t>
<t tx="ekr.20041006103243.10">@killcolor

http://sourceforge.net/forum/message.php?msg_id=2706676
By: nobody

Ive downloaded 4.2B3 and really really dont want to use the left click select/expand
anywhere Tree functionality( Ive never had a problem selecting the node I want
:) ).  I looked in the config file and didnt see an option for turning it off.
So do I need to hack the leo code to do this?

Option name: expanded_click_area</t>
<t tx="ekr.20041006103243.11">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.redrawing = False # Used only to disable traces.
    self.trace = False
    self.verbose = False
    self.useBindtags = True
    self.generation = 0
    self.dragging = False
    self.prevPositions = 0
    self.expanded_click_area = g.app.config.getBoolWindowPref("expanded_click_area")
    
    self.createPermanentBindings()
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are unchanging positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {} # Keys are vnodes, values are Tk.Text widgets
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = {} # Keys are vnodes, values are Tk.Text widgets
    self.freeUserIcons = []</t>
<t tx="ekr.20041006103243.12">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20041006103243.13"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.disableRedraw = False # True: reschedule a redraw for later.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw)</t>
<t tx="ekr.20041006103243.14"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20041006103243.15">def createPermanentBindings (self):
    
    canvas = self.canvas

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','&lt;Button-1&gt;', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','&lt;Button-1&gt;',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','&lt;Button-1&gt;', self.onIconBoxClick)
    canvas.tag_bind('iconBox','&lt;Double-1&gt;', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','&lt;Button-3&gt;', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','&lt;B1-Motion&gt;',            self.onDrag)
    canvas.tag_bind('iconBox','&lt;Any-ButtonRelease-1&gt;',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = Tk.Text(canvas) # This _must_ be a Text widget attached to the canvas!
        if 1: # Either way works properly.
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick)
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick)
            t.bind("&lt;Key&gt;",      self.onHeadlineKey)
        else:
            t.bind("&lt;Button-1&gt;", self.onHeadlineClick, '+')
            t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick, '+')
            t.bind("&lt;Key&gt;",      self.onHeadlineKey, '+')
        t.bind("&lt;Control-t&gt;",self.onControlT)
    
        # newText() attaches these bindings to all headlines.
        self.textBindings = t.bindtags()</t>
<t tx="ekr.20041006103243.16">def newBox (self,p,x,y,image):
    
    canvas = self.canvas ; tag = "plusBox" # 9/5/04: was plugBox.

    if self.freeBoxes:
        theId = self.freeBoxes.pop(0)
        canvas.coords(theId,x,y)
        canvas.itemconfigure(theId,image=image)
    else:
        theId = canvas.create_image(x,y,image=image,tag=tag)
        
    if self.trace and self.verbose:
        g.trace("%3d %3d %3d %8s" % (theId,x,y,' '),p.headString(),align=-20)

    assert(theId not in self.visibleBoxes)
    self.visibleBoxes.append(theId)

    assert(not self.ids.get(theId))
    assert(p)
    self.ids[theId] = p

    return theId</t>
<t tx="ekr.20041006103243.17">def drawClickBox (self,p,y):

    canvas = self.canvas ; h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        theId = self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20041006103243.18">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20041006103243.21">@color</t>
<t tx="ekr.20041006103243.22"># Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()

    if not p: return
    
    if self.trace and self.verbose: g.trace(p.headString())

    if not g.doHook("unselect1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # 3/26/03: Suppress duplicate call.
            try: # may fail during initialization
                self.idle_scrollTo(p)
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_v=p,old_v=old_p)
    
    # g.printGc()</t>
<t tx="ekr.20041006103243.23"># Remember the position of the scrollbar before making any changes.
yview=body.yview()
insertSpot = c.frame.body.getInsertionPoint()

if old_p and old_p != p:
    if self.trace and self.verbose:
        g.trace("unselect:",old_p.headString())
    self.endEditLabel() # sets editPosition = None
    self.setUnselectedLabelState(old_p)

if old_p and old_p.edit_text():
    old_p.v.t.scrollBarSpot = yview
    old_p.v.t.insertSpot = insertSpot
</t>
<t tx="ekr.20041006103243.24">frame.setWrap(p)

# 6/14/04: Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s,tag="select:set body",isHeadline=False)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v.t.insertSpot != None: # 9/21/02: moved from c.selectVnode
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")</t>
<t tx="ekr.20041006103243.25">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20041006103243.26"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20041006103243.27">self.c.setCurrentPosition(p)
if p != old_p:
    self.setSelectedLabelState(p)
self.frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook
g.app.gui.set_focus(c,c.frame.bodyCtrl)</t>
<t tx="ekr.20041006103243.28">@others

cweb_keywords = c_keywords
perlpod_keywords = perl_keywords</t>
<t tx="ekr.20041006103243.29">actionscript_keywords = [
#Jason 2003-07-03 
#Actionscript keywords for Leo adapted from UltraEdit syntax highlighting
"break", "call", "continue", "delete", "do", "else", "false", "for", "function", "goto", "if", "in", "new", "null", "return", "true", "typeof", "undefined", "var", "void", "while", "with", "#include", "catch", "constructor", "prototype", "this", "try", "_parent", "_root", "__proto__", "ASnative", "abs", "acos", "appendChild", "asfunction", "asin", "atan", "atan2", "attachMovie", "attachSound", "attributes", "BACKSPACE", "CAPSLOCK", "CONTROL", "ceil", "charAt", "charCodeAt", "childNodes", "chr", "cloneNode", "close", "concat", "connect", "cos", "createElement", "createTextNode", "DELETEKEY", "DOWN", "docTypeDecl", "duplicateMovieClip", "END", "ENTER", "ESCAPE", "enterFrame", "entry", "equal", "eval", "evaluate", "exp", "firstChild", "floor", "fromCharCode", "fscommand", "getAscii", "getBeginIndex", "getBounds", "getBytesLoaded", "getBytesTotal", "getCaretIndex", "getCode", "getDate", "getDay", "getEndIndex", "getFocus", "getFullYear", "getHours", "getMilliseconds", "getMinutes", "getMonth", "getPan", "getProperty", "getRGB", "getSeconds", "getTime", "getTimer", "getTimezoneOffset", "getTransform", "getURL", "getUTCDate", "getUTCDay", "getUTCFullYear", "getUTCHours", "getUTCMilliseconds", "getUTCMinutes", "getUTCMonth", "getUTCSeconds", "getVersion", "getVolume", "getYear", "globalToLocal", "gotoAndPlay", "gotoAndStop", "HOME", "haschildNodes", "hide", "hitTest", "INSERT", "Infinity", "ifFrameLoaded", "ignoreWhite", "indexOf", "insertBefore", "int", "isDown", "isFinite", "isNaN", "isToggled", "join", "keycode", "keyDown", "keyUp", "LEFT", "LN10", "LN2", "LOG10E", "LOG2E", "lastChild", "lastIndexOf", "length", "load", "loaded", "loadMovie", "loadMovieNum", "loadVariables", "loadVariablesNum", "localToGlobal", "log", "MAX_VALUE", "MIN_VALUE", "max", "maxscroll", "mbchr", "mblength", "mbord", "mbsubstring", "min", "NEGATIVE_INFINITY", "NaN", "newline", "nextFrame", "nextScene", "nextSibling", "nodeName", "nodeType", "nodeValue", "on", "onClipEvent", "onClose", "onConnect", "onData", "onLoad", "onXML", "ord", "PGDN", "PGUP", "PI", "POSITIVE_INFINITY", "parentNode", "parseFloat", "parseInt", "parseXML", "play", "pop", "pow", "press", "prevFrame", "previousSibling", "prevScene", "print", "printAsBitmap", "printAsBitmapNum", "printNum", "push", "RIGHT", "random", "release", "removeMovieClip", "removeNode", "reverse", "round", "SPACE", "SQRT1_2", "SQRT2", "scroll", "send", "sendAndLoad", "set", "setDate", "setFocus", "setFullYear", "setHours", "setMilliseconds", "setMinutes", "setMonth", "setPan", "setProperty", "setRGB", "setSeconds", "setSelection", "setTime", "setTransform", "setUTCDate", "setUTCFullYear", "setUTCHours", "setUTCMilliseconds", "setUTCMinutes", "setUTCMonth", "setUTCSeconds", "setVolume", "setYear", "shift", "show", "sin", "slice", "sort", "start", "startDrag", "status", "stop", "stopAllSounds", "stopDrag", "substr", "substring", "swapDepths", "splice", "split", "sqrt", "TAB", "tan", "targetPath", "tellTarget", "toggleHighQuality", "toLowerCase", "toString", "toUpperCase", "trace", "UP", "UTC", "unescape", "unloadMovie", "unLoadMovieNum", "unshift", "updateAfterEvent", "valueOf", "xmlDecl", "_alpha", "_currentframe", "_droptarget", "_focusrect", "_framesloaded", "_height", "_highquality", "_name", "_quality", "_rotation", "_soundbuftime", "_target", "_totalframes", "_url", "_visible", "_width", "_x", "_xmouse", "_xscale", "_y", "_ymouse", "_yscale", "and", "add", "eq", "ge", "gt", "le", "lt", "ne", "not", "or", "Array", "Boolean", "Color", "Date", "Key", "Math", "MovieClip", "Mouse", "Number", "Object", "Selection", "Sound", "String", "XML", "XMLSocket"
]</t>
<t tx="ekr.20041006103243.30">csharp_keywords = [
    "abstract","as",
    "base","bool","break","byte",
    "case","catch","char","checked","class","const","continue",
    "decimal","default","delegate","do","double",
    "else","enum","event","explicit","extern",
    "false","finally","fixed","float","for","foreach",
    "get","goto",
    "if","implicit","in","int","interface","internal","is",
    "lock","long",
    "namespace","new","null",
    "object","operator","out","override",
    "params","partial","private","protected","public",
    "readonly","ref","return",
    "sbyte","sealed","set","short","sizeof","stackalloc",
    "static","string","struct","switch",
    "this","throw","true","try","typeof",
    "uint","ulong","unchecked","unsafe","ushort","using",
    "value","virtual","void","volatile",
    "where","while",
    "yield"]</t>
<t tx="ekr.20041006103243.31">c_keywords = [
    # C keywords
    "auto","break","case","char","continue",
    "default","do","double","else","enum","extern",
    "float","for","goto","if","int","long","register","return",
    "short","signed","sizeof","static","struct","switch",
    "typedef","union","unsigned","void","volatile","while",
    # C++ keywords
    "asm","bool","catch","class","const","const_cast",
    "delete","dynamic_cast","explicit","false","friend",
    "inline","mutable","namespace","new","operator",
    "private","protected","public","reinterpret_cast","static_cast",
    "template","this","throw","true","try",
    "typeid","typename","using","virtual","wchar_t"]</t>
<t tx="ekr.20041006103243.32">css_keywords = [
#html tags
"address", "applet", "area", "a", "base", "basefont",
"big", "blockquote", "body", "br", "b", "caption", "center",
"cite", "code", "dd", "dfn", "dir", "div", "dl", "dt", "em", "font",
"form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "hr", "html", "img",
"input", "isindex", "i", "kbd", "link", "li", "link", "map", "menu",
"meta", "ol", "option", "param", "pre", "p", "samp",
"select", "small", "span", "strike", "strong", "style", "sub", "sup",
"table", "td", "textarea", "th", "title", "tr", "tt", "ul", "u", "var",
#units
"mm", "cm", "in", "pt", "pc", "em", "ex", "px",
#colors
"aqua", "black", "blue", "fuchsia", "gray", "green", "lime", "maroon", "navy", "olive", "purple", "red", "silver", "teal", "yellow", "white",
#important directive
"!important",
#font rules
"font", "font-family", "font-style", "font-variant", "font-weight", "font-size",
#font values
"cursive", "fantasy", "monospace", "normal", "italic", "oblique", "small-caps",
"bold", "bolder", "lighter", "medium", "larger", "smaller",
"serif", "sans-serif",
#background rules
"background", "background-color", "background-image", "background-repeat", "background-attachment", "background-position",
#background values
"contained", "none", "top", "center", "bottom", "left", "right", "scroll", "fixed",
"repeat", "repeat-x", "repeat-y", "no-repeat",
#text rules
"word-spacing", "letter-spacing", "text-decoration", "vertical-align", "text-transform", "text-align", "text-indent", "text-transform", "text-shadow", "unicode-bidi", "line-height",
#text values
"normal", "none", "underline", "overline", "blink", "sub", "super", "middle", "top", "text-top", "text-bottom",
"capitalize", "uppercase", "lowercase", "none", "left", "right", "center", "justify",
"line-through",
#box rules
"margin", "margin-top", "margin-bottom", "margin-left", "margin-right",
"margin", "padding-top", "padding-bottom", "padding-left", "padding-right",
"border", "border-width", "border-style", "border-top", "border-top-width", "border-top-style", "border-bottom", "border-bottom-width", "border-bottom-style", "border-left", "border-left-width", "border-left-style", "border-right", "border-right-width", "border-right-style", "border-color",
#box values
"width", "height", "float", "clear",
"auto", "thin", "medium", "thick", "left", "right", "none", "both",
"none", "dotted", "dashed", "solid", "double", "groove", "ridge", "inset", "outset",
#display rules
"display", "white-space", 
"min-width", "max-width", "min-height", "max-height",
"outline-color", "outline-style", "outline-width",
#display values
"run-in", "inline-block", "list-item", "block", "inline", "none", "normal", "pre", "nowrap", "table-cell", "table-row", "table-row-group", "table-header-group", "inline-table", "table-column", "table-column-group", "table-cell", "table-caption"
#list rules
"list-style", "list-style-type", "list-style-image", "list-style-position",
#list values
"disc", "circle", "square", "decimal", "decimal-leading-zero", "none",
"lower-roman", "upper-roman", "lower-alpha", "upper-alpha", "lower-latin", "upper-latin",
#table rules
"border-collapse", "caption-side",
#table-values
"empty-cells", "table-layout",
#misc values/rules
"counter-increment", "counter-reset",
"marker-offset", "z-index",
"cursor", "direction", "marks", "quotes",
"clip", "content", "orphans", "overflow", "visibility",
#aural rules
"pitch", "range", "pitch-during", "cue-after", "pause-after", "cue-before", "pause-before", "speak-header", "speak-numeral", "speak-punctuation", "speed-rate", "play-during", "voice-family",
#aural values
"stress", "azimuth", "elevation", "pitch", "richness", "volume",
"page-break", "page-after", "page-inside"]</t>
<t tx="ekr.20041006103243.33"># EKR: needs more work.
elisp_keywords = [
    # Maybe...
    "error","princ",
    # More typical of other lisps...
    "apply","eval",
    "t","nil",
    "and","or","not",
    "cons","car","cdr",
    "cond",
    "defconst","defun","defvar",
    "eq","ne","equal","gt","ge","lt","le",
    "if",
    "let",
    "mapcar",
    "prog","progn",
    "set","setq",
    "type-of",
    "unless",
    "when","while"]</t>
<t tx="ekr.20041006103243.34"># No longer used by syntax colorer.
html_keywords = []

if 0: # Not used at present.
    unused_keywords = [
        # html constructs.
        "a","body","cf",
        "h1","h2","h3","h4","h5","h6",
        "head","html","hr",
        "i","img","li","lu","meta",
        "p","title","ul",
        # Common tags
        "caption","col","colgroup",
        "table","tbody","td","tfoot","th","thead","tr",
        "script","style"]

    html_specials = [ "&lt;%","%&gt;" ]</t>
<t tx="ekr.20041006103243.35">java_keywords = [
    "abstract","boolean","break","byte","byvalue",
    "case","cast","catch","char","class","const","continue",
    "default","do","double","else","extends",
    "false","final","finally","float","for","future",
    "generic","goto","if","implements","import","inner",
    "instanceof","int","interface","long","native",
    "new","null","operator","outer",
    "package","private","protected","public","rest","return",
    "short","static","super","switch","synchronized",
    "this","throw","transient","true","try",
    "var","void","volatile","while"]</t>
<t tx="ekr.20041006103243.36">#If you see two idenitical words, with minor capitalization differences
#DO NOT ASSUME that they are the same word. For example \vert produces
#a single vertical line and \Vert produces a double vertical line
#Marcus A. Martin.

latex_special_keyword_characters = "@(){}%"

latex_keywords = [
    #special keyworlds
    "\\%", # 11/9/03
    "\\@", "\\(", "\\)", "\\{", "\\}",
    #A
    "\\acute", "\\addcontentsline", "\\addtocontents", "\\addtocounter", "\\address",
    "\\addtolength", "\\addvspace", "\\AE", "\\ae", "\\aleph", "\\alph", "\\angle",
    "\\appendix", 
    "\\approx",	"\\arabic", "\\arccos", "\\arcsin", "\\arctan", "\\ast", "\\author",
    #B
    "\\b", "\\backmatter", "\\backslash", "\\bar", "\\baselineskip", "\\baselinestretch",
    "\\begin", "\\beta", "\\bezier", "\\bf", "\\bfseries", "\\bibitem", "\\bigcap", 
    "\\bigcup", "\\bigodot", "\\bigoplus", "\\bigotimes", "\\bigskip", "\\biguplus", 
    "\\bigvee", "\\bigwedge",	"\\bmod", "\\boldmath", "\\Box", "\\breve", "\\bullet",
    #C
    "\\c", "\\cal", "\\caption", "\\cdot", "\\cdots", "\\centering", "\\chapter", 
    "\\check", "\\chi", "\\circ", "\\circle", "\\cite", "\\cleardoublepage", "\\clearpage", 
    "\\cline",	"\\closing", "\\clubsuit", "\\coprod", "\\copywright", "\\cos", "\\cosh", 
    "\\cot", "\\coth",	"csc",
    #D
    "\\d", "\\dag", "\\dashbox", "\\date", "\\ddag", "\\ddot", "\\ddots", "\\decl", 
    "\\deg", "\\Delta", 
    "\\delta", "\\depthits", "\\det", 
    "\\DH", "\\dh", "\\Diamond", "\\diamondsuit", "\\dim", "\\div", "\\DJ", "\\dj", 
    "\\documentclass", "\\documentstyle", 
    "\\dot", "\\dotfil", "\\downarrow",
    #E
    "\\ell", "\\em", "\\emph", "\\end", "\\enlargethispage", "\\ensuremath", 
    "\\enumi", "\\enuii", "\\enumiii", "\\enuiv", "\\epsilon", "\\equation", "\\equiv",	
    "\\eta", "\\example", "\\exists", "\\exp",
    #F
    "\\fbox", "\\figure", "\\flat", "\\flushbottom", "\\fnsymbol", "\\footnote", 
    "\\footnotemark", "\\fotenotesize", 
    "\\footnotetext", "\\forall", "\\frac", "\\frame", "\\framebox", "\\frenchspacing", 
    "\\frontmatter",
    #G
    "\\Gamma", "\\gamma", "\\gcd", "\\geq", "\\gg", "\\grave", "\\guillemotleft", 
    "\\guillemotright",	"\\guilsinglleft", "\\guilsinglright",
    #H
    "\\H", "\\hat", "\\hbar", "\\heartsuit", "\\heightits", "\\hfill", "\\hline", "\\hom",
    "\\hrulefill",	"\\hspace", "\\huge",	"\\Huge",	"\\hyphenation"
    #I
    "\\Im", "\\imath", "\\include", "includeonly", "indent", "\\index", "\\inf", "\\infty", 
    "\\input", "\\int", "\\iota",	"\\it", "\\item", "\\itshape",
    #J
    "\\jmath", "\\Join",
    #K
    "\\k", "\\kappa", "\\ker", "\\kill",
    #L
    "\\label", "\\Lambda", "\\lambda", "\\langle", "\\large", "\\Large", "\\LARGE", 
    "\\LaTeX", "\\LaTeXe", 
    "\\ldots", "\\leadsto", "\\left", "\\Leftarrow", "\\leftarrow", "\\lefteqn", "\\leq",
    "\\lg", "\\lhd", "\\lim", "\\liminf", "\\limsup", "\\line", 	"\\linebreak", 
    "\\linethickness", "\\linewidth",	"\\listfiles",
    "\\ll", "\\ln", "\\location", "\\log", "\\Longleftarrow", "\\longleftarrow", 
    "\\Longrightarrow",	"longrightarrow",
    #M
    "\\mainmatter", "\\makebox", "\\makeglossary", "\\makeindex","\\maketitle", "\\markboth", "\\markright",
    "\\mathbf", "\\mathcal", "\\mathit", "\\mathnormal", "\\mathop",
    "\\mathrm", "\\mathsf", "\\mathtt", "\\max", "\\mbox", "\\mdseries", "\\medskip",
    "\\mho", "\\min", "\\mp", "\\mpfootnote", "\\mu", "\\multicolumn", "\\multiput",
    #N
    "\\nabla", "\\natural", "\\nearrow", "\\neq", "\\newcommand", "\\newcounter", 
    "\\newenvironment", "\\newfont",
    "\\newlength",	"\\newline", "\\newpage", "\\newsavebox", "\\newtheorem", "\\NG", "\\ng",
    "\\nocite", "\\noindent", "\\nolinbreak", "\\nopagebreak", "\\normalsize",
    "\\not", "\\nu", "nwarrow",
    #O
    "\\Omega", "\\omega", "\\onecolumn", "\\oint", "\\opening", "\\oval", 
    "\\overbrace", "\\overline",
    #P
    "\\P", "\\page", "\\pagebreak", "\\pagenumbering", "\\pageref", "\\pagestyle", 
    "\\par", "\\parbox",	"\\paragraph", "\\parindent", "\\parskip", "\\part", 
    "\\partial", "\\per", "\\Phi", 	"\\phi",	"\\Pi", "\\pi", "\\pm", 
    "\\pmod", "\\pounds", "\\prime", "\\printindex", "\\prod", "\\propto", "\\protext", 
    "\\providecomamnd", "\\Psi",	"\\psi", "\\put",
    #Q
    "\\qbezier", "\\quoteblbase", "\\quotesinglbase",
    #R
    "\\r", "\\raggedbottom", "\\raggedleft", "\\raggedright", "\\raisebox", "\\rangle", 
    "\\Re", "\\ref", 	"\\renewcommand", "\\renewenvironment", "\\rhd", "\\rho", "\\right", 
    "\\Rightarrow",	"\\rightarrow", "\\rm", "\\rmfamily",
    "\\Roman", "\\roman", "\\rule", 
    #S
    "\\s", "\\samepage", "\\savebox", "\\sbox", "\\sc", "\\scriptsize", "\\scshape", 
    "\\searrow",	"\\sec", "\\section",
    "\\setcounter", "\\setlength", "\\settowidth", "\\settodepth", "\\settoheight", 
    "\\settowidth", "\\sf", "\\sffamily", "\\sharp", "\\shortstack", "\\Sigma", "\\sigma", 
    "\\signature", "\\sim", "\\simeq", "\\sin", "\\sinh", "\\sl", "\\SLiTeX",
    "\\slshape", "\\small", "\\smallskip", "\\spadesuit", "\\sqrt", "\\sqsubset",	
    "\\sqsupset", "\\SS",
    "\\stackrel", "\\star", "\\subsection", "\\subset", 
    "\\subsubsection", "\\sum", "\\sup", "\\supressfloats", "\\surd", "\\swarrow",
    #T
    "\\t", "\\table", "\\tableofcontents", "\\tabularnewline", "\\tan", "\\tanh", 
    "\\tau", "\\telephone",	"\\TeX", "\\textbf",
    "\\textbullet", "\\textcircled", "\\textcompworkmark",	"\\textemdash", 
    "\\textendash", "\\textexclamdown", "\\textheight", "\\textquestiondown", 
    "\\textquoteblleft", "\\textquoteblright", "\\textquoteleft",
    "\\textperiod", "\\textquotebl", "\\textquoteright", "\\textmd", "\\textit", "\\textrm", 
    "\\textsc", "\\textsl", "\\textsf", "\\textsuperscript", "\\texttt", "\\textup",
    "\\textvisiblespace", "\\textwidth", "\\TH", "\\th", "\\thanks", "\\thebibligraphy",
    "\\Theta", "theta", 
    "\\tilde", "\\thinlines", 
    "\\thispagestyle", "\\times", "\\tiny", "\\title",	"\\today", "\\totalheightits", 
    "\\triangle", "\\tt", 
    "\\ttfamily", "\\twocoloumn", "\\typeout", "\\typein",
    #U
    "\\u", "\\underbrace", "\\underline", "\\unitlength", "\\unlhd", "\\unrhd", "\\Uparrow",
    "\\uparrow",	"\\updownarrow", "\\upshape", "\\Upsilon", "\\upsilon", "\\usebox",	
    "\\usecounter", "\\usepackage", 
    #V
    "\\v", "\\value", "\\varepsilon", "\\varphi", "\\varpi", "\\varrho", "\\varsigma", 
    "\\vartheta", "\\vdots", "\\vec", "\\vector", "\\verb", "\\Vert", "\\vert", 	"\\vfill",
    "\\vline", "\\vphantom", "\\vspace",
    #W
    "\\widehat", "\\widetilde", "\\widthits", "\\wp",
    #X
    "\\Xi", "\\xi",
    #Z
    "\\zeta" ]</t>
<t tx="ekr.20041006103243.37">pascal_keywords = [
    "and","array","as","begin",
    "case","const","class","constructor","cdecl"
    "div","do","downto","destructor","dispid","dynamic",
    "else","end","except","external",
    "false","file","for","forward","function","finally",
    "goto","if","in","is","label","library",
    "mod","message","nil","not","nodefault""of","or","on",
    "procedure","program","packed","pascal",
    "private","protected","public","published",
    "record","repeat","raise","read","register",
    "set","string","shl","shr","stdcall",
    "then","to","true","type","try","until","unit","uses",
    "var","virtual","while","with","xor"
    # object pascal
    "asm","absolute","abstract","assembler","at","automated",
    "finalization",
    "implementation","inherited","initialization","inline","interface",
    "object","override","resident","resourcestring",
    "threadvar",
    # limited contexts
    "exports","property","default","write","stored","index","name" ]</t>
<t tx="ekr.20041006103243.38">perl_keywords = [
    "continue","do","else","elsif","format","for","format","for","foreach",
    "if","local","package","sub","tr","unless","until","while","y",
    # Comparison operators
    "cmp","eq","ge","gt","le","lt","ne",
    # Matching ooperators
    "m","s",
    # Unary functions
    "alarm","caller","chdir","cos","chroot","exit","eval","exp",
    "getpgrp","getprotobyname","gethostbyname","getnetbyname","gmtime",
    "hex","int","length","localtime","log","ord","oct",
    "require","reset","rand","rmdir","readlink",
    "scalar","sin","sleep","sqrt","srand","umask",
    # Transfer ops
    "next","last","redo","go","dump",
    # File operations...
    "select","open",
    # FL ops
    "binmode","close","closedir","eof",
    "fileno","getc","getpeername","getsockname","lstat",
    "readdir","rewinddir","stat","tell","telldir","write",
    # FL2 ops
    "bind","connect","flock","listen","opendir",
    "seekdir","shutdown","truncate",
    # FL32 ops
    "accept","pipe",
    # FL3 ops
    "fcntl","getsockopt","ioctl","read",
    "seek","send","sysread","syswrite",
    # FL4 &amp; FL5 ops
    "recv","setsocket","socket","socketpair",
    # Array operations
    "pop","shift","split","delete",
    # FLIST ops
    "sprintf","grep","join","pack",
    # LVAL ops
    "chop","defined","study","undef",
    # f0 ops
    "endhostent","endnetent","endservent","endprotoent",
    "endpwent","endgrent","fork",
    "getgrent","gethostent","getlogin","getnetent","getppid",
    "getprotoent","getpwent","getservent",
    "setgrent","setpwent","time","times","wait","wantarray",
    # f1 ops
    "getgrgid","getgrnam","getprotobynumber","getpwnam","getpwuid",
    "sethostent","setnetent","setprotoent","setservent",
    # f2 ops
    "atan2","crypt",
    "gethostbyaddr","getnetbyaddr","getpriority","getservbyname","getservbyport",
    "index","link","mkdir","msgget","rename",
    "semop","setpgrp","symlink","unpack","waitpid",
    # f2 or 3 ops
    "index","rindex","substr",
    # f3 ops
    "msgctl","msgsnd","semget","setpriority","shmctl","shmget","vec",
    # f4 &amp; f5 ops
    "semctl","shmread","shmwrite","msgrcv",
    # Assoc ops
    "dbmclose","each","keys","values",
    # List ops
    "chmod","chown","die","exec","kill",
    "print","printf","return","reverse",
    "sort","system","syscall","unlink","utime","warn"]</t>
<t tx="ekr.20041006103243.39">php_keywords = [ # 08-SEP-2002 DTHEIN
    "__CLASS__", "__FILE__", "__FUNCTION__", "__LINE__",
    "and", "as", "break",
    "case", "cfunction", "class", "const", "continue",
    "declare", "default", "do",
    "else", "elseif", "enddeclare", "endfor", "endforeach",
    "endif", "endswitch",  "endwhile", "eval", "extends",
    "for", "foreach", "function", "global", "if",
    "new", "old_function", "or", "static", "switch",
    "use", "var", "while", "xor" ]
    
# The following are supposed to be followed by ()
php_paren_keywords = [
    "array", "die", "echo", "empty", "exit",
    "include", "include_once", "isset", "list",
    "print", "require", "require_once", "return",
    "unset" ]
    
# The following are handled by special case code:
# "&lt;?php", "?&gt;"
</t>
<t tx="ekr.20041006103243.40">python_keywords = [
    "and",       "del",       "for",       "is",        "raise",    
    "assert",    "elif",      "from",      "lambda",    "return",   
    "break",     "else",      "global",    "not",       "try",      
    "class",     "except",    "if",        "or",        "yield",   
    "continue",  "exec",      "import",    "pass",      "while",
    "def",       "finally",   "in",        "print"]</t>
<t tx="ekr.20041006103243.41">rapidq_keywords = [
# Syntax file for RapidQ
"$APPTYPE","$DEFINE","$ELSE","$ENDIF","$ESCAPECHARS","$IFDEF","$IFNDEF",
"$INCLUDE","$MACRO","$OPTIMIZE","$OPTION","$RESOURCE","$TYPECHECK","$UNDEF",
"ABS","ACOS","ALIAS","AND","AS","ASC","ASIN","ATAN","ATN","BIN$","BIND","BYTE",
"CALL","CALLBACK","CALLFUNC","CASE","CEIL","CHDIR","CHDRIVE","CHR$","CINT",
"CLNG","CLS","CODEPTR","COMMAND$","COMMANDCOUNT","CONSOLE","CONST","CONSTRUCTOR",
"CONVBASE$","COS","CREATE","CSRLIN","CURDIR$","DATA","DATE$","DEC","DECLARE",
"DEFBYTE","DEFDBL","DEFDWORD","DEFINT","DEFLNG","DEFSHORT","DEFSNG","DEFSTR",
"DEFWORD","DELETE$","DIM","DIR$","DIREXISTS","DO","DOEVENTS","DOUBLE","DWORD",
"ELSE","ELSEIF","END","ENVIRON","ENVIRON$","EVENT","EXIT","EXP","EXTENDS",
"EXTRACTRESOURCE","FIELD$","FILEEXISTS","FIX","FLOOR","FOR","FORMAT$","FRAC",
"FUNCTION","FUNCTIONI","GET$","GOSUB","GOTO","HEX$","IF","INC","INITARRAY",
"INKEY$","INP","INPUT","INPUT$","INPUTHANDLE","INSERT$","INSTR","INT","INTEGER",
"INV","IS","ISCONSOLE","KILL","KILLMESSAGE","LBOUND","LCASE$","LEFT$","LEN",
"LFLUSH","LIB","LIBRARYINST","LOCATE","LOG","LONG","LOOP","LPRINT","LTRIM$",
"MEMCMP","MESSAGEBOX","MESSAGEDLG","MID$","MKDIR","MOD","MOUSEX","MOUSEY",
"NEXT","NOT","OFF","ON","OR","OUT","OUTPUTHANDLE","PARAMSTR$","PARAMSTRCOUNT",
"PARAMVAL","PARAMVALCOUNT","PCOPY","PEEK","PLAYWAV","POKE","POS","POSTMESSAGE",
"PRINT","PROPERTY","QUICKSORT","RANDOMIZE","REDIM","RENAME","REPLACE$",
"REPLACESUBSTR$","RESOURCE","RESOURCECOUNT","RESTORE","RESULT","RETURN",
"REVERSE$","RGB","RIGHT$","RINSTR","RMDIR","RND","ROUND","RTRIM$","RUN",
"SCREEN","SELECT","SENDER","SENDMESSAGE","SETCONSOLETITLE","SGN","SHELL",
"SHL","SHORT","SHOWMESSAGE","SHR","SIN","SINGLE","SIZEOF","SLEEP","SOUND",
"SPACE$","SQR","STACK","STATIC","STEP","STR$","STRF$","STRING","STRING$",
"SUB","SUBI","SWAP","TALLY","TAN","THEN","TIME$","TIMER","TO","TYPE","UBOUND",
"UCASE$","UNLOADLIBRARY","UNTIL","VAL","VARIANT","VARPTR","VARPTR$","VARTYPE",
"WEND","WHILE","WITH","WORD","XOR"]</t>
<t tx="ekr.20041006103243.42">rebol_keywords = [
#Jason 2003-07-03 
#based on UltraEdit syntax highlighting
"about", "abs", "absolute", "add", "alert", "alias", "all", "alter", "and", "and~", "any", "append", "arccosine", "arcsine", "arctangent", "array", "ask", "at",  
"back", "bind", "boot-prefs", "break", "browse", "build-port", "build-tag",  
"call", "caret-to-offset", "catch", "center-face", "change", "change-dir", "charset", "checksum", "choose", "clean-path", "clear", "clear-fields", "close", "comment", "complement", "compose", "compress", "confirm", "continue-post", "context", "copy", "cosine", "create-request", "crypt", "cvs-date", "cvs-version",  
"debase", "decode-cgi", "decode-url", "decompress", "deflag-face", "dehex", "delete", "demo", "desktop", "detab", "dh-compute-key", "dh-generate-key", "dh-make-key", "difference", "dirize", "disarm", "dispatch", "divide", "do", "do-boot", "do-events", "do-face", "do-face-alt", "does", "dsa-generate-key", "dsa-make-key", "dsa-make-signature", "dsa-verify-signature",  
"echo", "editor", "either", "else", "emailer", "enbase", "entab", "exclude", "exit", "exp", "extract", 
"fifth", "find", "find-key-face", "find-window", "flag-face", "first", "flash", "focus", "for", "forall", "foreach", "forever", "form", "forskip", "fourth", "free", "func", "function",  
"get", "get-modes", "get-net-info", "get-style",  
"halt", "has", "head", "help", "hide", "hide-popup",  
"if", "import-email", "in", "inform", "input", "insert", "insert-event-func", "intersect", 
"join", 
"last", "launch", "launch-thru", "layout", "license", "list-dir", "load", "load-image", "load-prefs", "load-thru", "log-10", "log-2", "log-e", "loop", "lowercase",  
"make", "make-dir", "make-face", "max", "maximum", "maximum-of", "min", "minimum", "minimum-of", "mold", "multiply",  
"negate", "net-error", "next", "not", "now",  
"offset-to-caret", "open", "open-events", "or", "or~", 
"parse", "parse-email-addrs", "parse-header", "parse-header-date", "parse-xml", "path-thru", "pick", "poke", "power", "prin", "print", "probe", "protect", "protect-system",  
"q", "query", "quit",  
"random", "read", "read-io", "read-net", "read-thru", "reboot", "recycle", "reduce", "reform", "rejoin", "remainder", "remold", "remove", "remove-event-func", "rename", "repeat", "repend", "replace", "request", "request-color", "request-date", "request-download", "request-file", "request-list", "request-pass", "request-text", "resend", "return", "reverse", "rsa-encrypt", "rsa-generate-key", "rsa-make-key", 
"save", "save-prefs", "save-user", "scroll-para", "second", "secure", "select", "send", "send-and-check", "set", "set-modes", "set-font", "set-net", "set-para", "set-style", "set-user", "set-user-name", "show", "show-popup", "sine", "size-text", "skip", "sort", "source", "split-path", "square-root", "stylize", "subtract", "switch",  
"tail", "tangent", "textinfo", "third", "throw", "throw-on-error", "to", "to-binary", "to-bitset", "to-block", "to-char", "to-date", "to-decimal", "to-email", "to-event", "to-file", "to-get-word", "to-hash", "to-hex", "to-idate", "to-image", "to-integer", "to-issue", "to-list", "to-lit-path", "to-lit-word", "to-local-file", "to-logic", "to-money", "to-none", "to-pair", "to-paren", "to-path", "to-rebol-file", "to-refinement", "to-set-path", "to-set-word", "to-string", "to-tag", "to-time", "to-tuple", "to-url", "to-word", "trace", "trim", "try",  
"unfocus", "union", "unique", "uninstall", "unprotect", "unset", "until", "unview", "update", "upgrade", "uppercase", "usage", "use",  
"vbug", "view", "view-install", "view-prefs",  
"wait", "what", "what-dir", "while", "write", "write-io",  
"xor", "xor~",  
"action!", "any-block!", "any-function!", "any-string!", "any-type!", "any-word!",  
"binary!", "bitset!", "block!",  
"char!",  
"datatype!", "date!", "decimal!", 
"email!", "error!", "event!",  
"file!", "function!",  
"get-word!",  
"hash!",  
"image!", "integer!", "issue!",  
"library!", "list!", "lit-path!", "lit-word!", "logic!",  
"money!",  
"native!", "none!", "number!",  
"object!", "op!",  
"pair!", "paren!", "path!", "port!",  
"refinement!", "routine!",  
"series!", "set-path!", "set-word!", "string!", "struct!", "symbol!",  
"tag!", "time!", "tuple!",  
"unset!", "url!",  
"word!",  
"any-block?", "any-function?", "any-string?", "any-type?", "any-word?",  
"binary?", "bitset?", "block?",  
"char?", "connected?", "crypt-strength?", 
"datatype?", "date?", "decimal?", "dir?",  
"email?", "empty?", "equal?", "error?", "even?", "event?", "exists?", "exists-key?",
"file?", "flag-face?", "found?", "function?",  
"get-word?", "greater-or-equal?", "greater?",  
"hash?", "head?",  
"image?", "in-window?", "index?", "info?", "input?", "inside?", "integer?", "issue?",  
"length?", "lesser-or-equal?", "lesser?", "library?", "link-app?", "link?", "list?", "lit-path?", "lit-word?", "logic?",  
"modified?", "money?",  
"native?", "negative?", "none?", "not-equal?", "number?",  
"object?", "odd?", "offset?", "op?", "outside?",  
"pair?", "paren?", "path?", "port?", "positive?",  
"refinement?", "routine?",  
"same?", "screen-offset?", "script?", "series?", "set-path?", "set-word?", "size?", "span?", "strict-equal?", "strict-not-equal?", "string?", "struct?",  
"tag?", "tail?", "time?", "tuple?", "type?",  
"unset?", "url?",  
"value?", "view?", 
"within?", "word?",  
"zero?"
]</t>
<t tx="ekr.20041006103243.43">shell_keywords = [
    # reserved keywords
    "case","do","done","elif","else","esac","fi",
    "for","if","in","then",
    "until","while",
    "break","cd","chdir","continue","eval","exec",
    "exit","kill","newgrp","pwd","read","readonly",
    "return","shift","test","trap","ulimit",
    "umask","wait" ]</t>
<t tx="ekr.20041006103243.44">tcltk_keywords = [ # Only the tcl keywords are here.
    "after",     "append",    "array",
    "bgerror",   "binary",    "break",
    "catch",     "cd",        "clock",
    "close",     "concat",    "continue",
    "dde",
    "encoding",  "eof",       "eval",
    "exec",      "exit",      "expr",
    "fblocked",  "fconfigure","fcopy",     "file",      "fileevent",
    "filename",  "flush",     "for",       "foreach",   "format",
    "gets",      "glob",      "global",
    "history",
    "if",        "incr",      "info",      "interp",
    "join",
    "lappend",   "lindex",    "linsert",   "list",      "llength",
    "load",      "lrange",    "lreplace",  "lsearch",   "lsort",
    "memory",    "msgcat",
    "namespace",
    "open",
    "package",   "parray",    "pid",
    "proc",      "puts",      "pwd",
    "read",      "regexp",    "registry",   "regsub",
    "rename",    "resource",  "return",
    "scan",      "seek",      "set",        "socket",   "source",
    "split",     "string",    "subst",      "switch",
    "tell",      "time",      "trace",
    "unknown",   "unset",     "update",     "uplevel",   "upvar",
    "variable",  "vwait",
    "while" ]</t>
<t tx="ekr.20041006103243.45"></t>
<t tx="ekr.20041006103243.46">@color</t>
<t tx="ekr.20041006103243.47">@color # &lt;---  A Leo directive

import leoGlobals as g

g.es("Thanks for inviting me to Chicago!",color="blue")
</t>
<t tx="ekr.20041006103243.48">import leoGlobals as g
import tkFont

@others  # &lt;---- a Leo directive.

c = g.top()

if 1:
    &lt;&lt; print font of body pane &gt;&gt;  # &lt;---- a section reference.

if 1:
    &lt;&lt; print font of log pane &gt;&gt;
    
if 1:
    &lt;&lt; print font of tree pane &gt;&gt;</t>
<t tx="ekr.20041006103243.49">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="ekr.20041006103243.51">Body text contains data; headlines contains meta-data.</t>
<t tx="ekr.20041006103243.52">The old world:  Applications are programs (algorithms) + data.

The Leo world:  Applications are data, outlines (structure) and algorithms.

- Programs _are_ outlines.
- Data _are_ outlines.
- Outlines _are_ programs.
- Outlines _are data.

This has specific, concrete, practical implications, e.g., in unit testing.</t>
<t tx="ekr.20041006103243.54">@color</t>
<t tx="ekr.20041006103243.179">@color</t>
<t tx="ekr.20041006103243.519"></t>
<t tx="ekr.20041006103243.520">@killcolor

&gt; I wouln't call these bugs...just flat out wrong Leo usage, that might appear good but ends up hurting you.

The book will discuss these.  The case you talk about may be the most important.  The general rule is that you can delete a clone without deleting the last copy of any of the text of the cloned tree, but you must be very careful of deleting a non-cloned node.

There aren't too many anti-patterns.  Probably the second most common anti-pattern is using named sections when @others would do.  I reserve named sections usually for those cases where the order of code (text) does matter.  For example, if every method of a class is in a class, the order of methods shouldn't matter, and won't matter unless you are doing something very strange.  A related pattern, stuff that should appear at the start of a class would be in a named section.

Probably this is pretty obvious to those who use Leo frequently, but this will be discussed in prelimary patterns.</t>
<t tx="ekr.20041006103243.521"></t>
<t tx="ekr.20041006103243.522"></t>
<t tx="ekr.20041006103243.523"></t>
<t tx="ekr.20041006103243.524"></t>
<t tx="ekr.20041006103243.525"></t>
<t tx="ekr.20041006103243.526"></t>
<t tx="ekr.20041006103243.527"></t>
<t tx="ekr.20041006103243.528"></t>
<t tx="ekr.20041006103243.529"></t>
<t tx="ekr.20041006103243.530"></t>
<t tx="ekr.20041006103243.531"></t>
<t tx="ekr.20041006103243.532"></t>
<t tx="ekr.20041006103243.533"></t>
<t tx="ekr.20041006103243.534"></t>
<t tx="ekr.20041006103243.535"></t>
<t tx="ekr.20041006103243.536"></t>
<t tx="ekr.20041006103243.537">Use section names like the following:
    
&lt;&lt; about this module &gt;&gt;
&lt;&lt; imports for this module &gt;&gt;
</t>
<t tx="ekr.20041006103243.538"></t>
<t tx="ekr.20041006103243.539"></t>
<t tx="ekr.20041006103243.540">@killcolor

Im curious as to your opinions as to what Refactorings are made easy by Leo. I use nodes as containers for methods. Yesterday I moved a node out of one class into another, hence moved a method into another class. This was easy. Thats it. So following the pattern of 'node is method' a refactoring was made simple.

Do other Leo users have refactorings that are made easy by usage patterns, such as the 'node is method' pattern? Id love to hear about them. If there is some twist I can apply to my Outline that makes code manipulation easier, its worth its weight in gold!( well a refactoring cant weigh anything, but you get my drift...)</t>
<t tx="ekr.20041006103243.541">@killcolor

RE: Refactoring Patterns in Leo  
2004-08-26 20:44
I stumbled on something I plan to use more the other day. take a few lines of code
maybe in a time critical section you would rather not make a function or method.
make that a named section node.
clone the node outside the outline
inside a function as if you were going to
extract it as a seperate function.
feed it those things it needs
return those things it will change.
add some doctesting.
run timeit on the node.
with doctests in place you can easily
try a few other formulations.
all w/o disturbing the previous source.
idealy this will be something w/o allot of
depandance on globals or much setup.
makeup your own example and try it out.

e </t>
<t tx="ekr.20041006103243.542"></t>
<t tx="ekr.20041006103243.543"></t>
<t tx="ekr.20041006103243.544"></t>
<t tx="ekr.20041006103243.545"></t>
<t tx="ekr.20041006103243.546"></t>
<t tx="ekr.20041006103243.547"></t>
<t tx="ekr.20041006103243.548"></t>
<t tx="ekr.20041006103243.549"></t>
<t tx="ekr.20041006103243.550"></t>
<t tx="ekr.20041006103243.551"></t>
<t tx="ekr.20041006103243.552"></t>
<t tx="ekr.20041006103243.553"></t>
<t tx="ekr.20041006103243.554"></t>
<t tx="ekr.20041006103243.555"></t>
<t tx="ekr.20041006103243.556"></t>
<t tx="ekr.20041006103243.557"></t>
<t tx="ekr.20041006103243.558"></t>
<t tx="ekr.20041006103243.559"></t>
<t tx="ekr.20041006103243.560"></t>
<t tx="ekr.20041006103243.561"></t>
<t tx="ekr.20041006103243.562"></t>
<t tx="ekr.20041006103243.563"></t>
<t tx="ekr.20041006104224"></t>
<t tx="ekr.20041006104224.1"></t>
<t tx="ekr.20041006104224.2"></t>
<t tx="ekr.20041006104224.3">@nocolor

Leo makes so-called literate programming practical.</t>
<t tx="ekr.20041006104224.5"></t>
<t tx="ekr.20041006104224.6">@nocolor</t>
<t tx="ekr.20041006104908">fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
g.es("body:",fn,name,size,slant,weight)</t>
<t tx="ekr.20041006104908.1">fn = c.frame.log.getFontConfig()
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
g.es("log:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="ekr.20041006104908.2">font = c.frame.tree.getFont()
name,size,slant,weight = getFontSettings(font)
g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="ekr.20041006104908.3">- Complex numbers (R x R) create something new to mathematics that is much more than R.

- Leo's nodes (Headlines x Body) creates something new that is much more than just text.</t>
<t tx="ekr.20041006104908.4"></t>
<t tx="ekr.20041006105206"></t>
<t tx="ekr.20041006105206.1"></t>
<t tx="ekr.20041006105206.2"></t>
<t tx="ekr.20041006105206.4">@color</t>
<t tx="ekr.20041006105452"></t>
<t tx="ekr.20041006105452.1"></t>
<t tx="ekr.20041006105452.2"></t>
<t tx="ekr.20041006105452.3"></t>
<t tx="ekr.20041006105452.4"></t>
<t tx="ekr.20041006110013"></t>
<t tx="ekr.20041006110013.1"></t>
<t tx="ekr.20041006110307"></t>
<t tx="ekr.20041006110307.1"></t>
<t tx="ekr.20041006110307.2"></t>
<t tx="ekr.20041006110548"></t>
<t tx="ekr.20041006110548.1"></t>
<t tx="ekr.20041006110732"></t>
</tnodes>
</leo_file>
