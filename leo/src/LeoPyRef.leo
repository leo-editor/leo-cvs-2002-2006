<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="9069" clone_windows="0"/>
<globals body_outline_ratio="0.480459770115">
	<global_window_position top="31" left="406" height="870" width="793"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20040117181936"
marks="ekr.20060122193554,ekr.20060116083359.1,"><vh>@thin ../doc/leoToDo.txt</vh></v>
<v t="ekr.20060207133601" descendentTnodeUnknownAttributes="7d71005814000000656b722e32303036303230313135303534372e3871017d710255092f3e0d0a3c742074787103551a7a6f7263616e6461212e32303035303932353136303131382e31710473732e"><vh>@thin ../doc/leoToDoLater.txt</vh></v>
</v>
<v t="ekr.20050924073836"><vh>4.4 projects</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20060203112912.1"><vh>Initing</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt; (commands)</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3941"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20031218072017.1801"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20031218072017.1802"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3942"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20041221122440"><vh>f.component &amp; components</vh></v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20051121092320"><vh>f.enableTclTraces</vh></v>
</v>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20041221071131"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20041221071131.1"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050119210541"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041221123325"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20041223130032"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20041221195402"><vh>Pmw...</vh>
<v t="ekr.20041221073427"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20031218072017.3946"><vh>resizePanesToRatio</vh>
<v t="ekr.20050104084531"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221075743"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20041221185246"><vh>Tk...</vh>
<v t="ekr.20041221073427.1"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20031218072017.3947"><vh>bindBar</vh></v>
<v t="ekr.20031218072017.3949"><vh>divideAnySplitter</vh></v>
<v t="ekr.20031218072017.3950"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20031218072017.3951"><vh>onDrag...</vh></v>
<v t="ekr.20031218072017.3952"><vh>placeSplitter</vh></v>
<v t="ekr.20031218072017.998"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3964"><vh>Destroying the frame</vh>
<v t="ekr.20031218072017.1975"><vh>destroyAllObjects</vh>
<v t="ekr.20031218072017.1976"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3965"><vh>destroyAllPanels</vh></v>
<v t="ekr.20031218072017.1974"><vh>destroySelf (tkFrame)</vh></v>
</v>
</v>
<v t="ekr.20050920085536.1"><vh> Birth (keyHandler)</vh>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20060115195302"><vh>setDefaultUnboundKeyAction</vh></v>
</v>
</v>
<v t="ekr.20060204105811"><vh>Recent</vh>
<v t="ekr.20060207194124"><vh>Commands with recent problems</vh>
<v t="ekr.20031218072017.1761"><vh>c.insertHeadline</vh></v>
<v t="ekr.20051026092433.1"><vh>backwardDeleteCharacter</vh>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2052"><vh>g.openWithFileName</vh></v>
</v>
<v t="ekr.20031218072017.1588"><vh>Garbage Collection</vh>
<v t="ekr.20060127162818"><vh>enable_gc_debug</vh></v>
<v t="ekr.20031218072017.1589"><vh>clearAllIvars</vh></v>
<v t="ekr.20060205043324"><vh>Called from commands</vh>
<v t="ekr.20031218072017.1590"><vh>collectGarbage</vh></v>
<v t="ekr.20060205043324.1"><vh>printGcSummary</vh></v>
<v t="ekr.20060202161935"><vh>printGcAll</vh></v>
<v t="ekr.20060127164729.1"><vh>printGcObjects</vh>
<v t="ekr.20040703065638"><vh>&lt;&lt; print added functions &gt;&gt;</vh></v>
<v t="ekr.20040703054646"><vh>&lt;&lt; print number of each type of object &gt;&gt;</vh></v>
</v>
<v t="ekr.20060127165509"><vh>printGcVerbose</vh></v>
</v>
<v t="ekr.20060205043324.2"><vh>Called from unit tests</vh>
<v t="ekr.20031218072017.1592"><vh>printGc</vh>
<v t="ekr.20031218072017.1593"><vh>printGcRefs</vh></v>
</v>
</v>
</v>
<v t="ekr.20051023094009"><vh>Search classes</vh>
<v t="ekr.20060123125256"><vh>class minibufferFind (the findHandler)</vh>
<v t="ekr.20060123125317.2"><vh> ctor (minibufferFind)</vh></v>
<v t="ekr.20060124140114"><vh> Options</vh>
<v t="ekr.20060124123133"><vh>setFindScope</vh></v>
<v t="ekr.20060124122844"><vh>setOption</vh></v>
<v t="ekr.20060125082510"><vh>getOption</vh></v>
<v t="ekr.20060125074939"><vh>showFindOptions</vh></v>
<v t="ekr.20060124135401"><vh>toggleOption</vh></v>
<v t="ekr.20060205105950"><vh>setupChangePattern</vh></v>
<v t="ekr.20060125091234"><vh>setupSearchPattern</vh></v>
</v>
<v t="ekr.20060124134356"><vh> setupArgs</vh></v>
<v t="ekr.20060128080201"><vh>cloneFindAll</vh></v>
<v t="ekr.20060204120158"><vh>findAgain</vh></v>
<v t="ekr.20060205105950.1"><vh>generalChangeHelper</vh></v>
<v t="ekr.20060124181213.4"><vh>generalSearchHelper</vh></v>
<v t="ekr.20050920084036.113"><vh>replaceString</vh>
<v t="ekr.20050920084036.114"><vh>&lt;&lt; do the replace &gt;&gt;</vh></v>
</v>
<v t="ekr.20060124140224.3"><vh>reSearchBackward/Forward</vh></v>
<v t="ekr.20060124140224.1"><vh>seachForward/Backward</vh></v>
<v t="ekr.20060125093807"><vh>searchWithPresentOptions</vh></v>
<v t="ekr.20060124140224.2"><vh>wordSearchBackward/Forward</vh></v>
</v>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__</vh>
<v t="ekr.20051020120306.12"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>createBindings (findTab)</vh></v>
<v t="ekr.20051020120306.13"><vh>createFrame (findTab)</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.19"><vh>find.init</vh>
<v t="ekr.20051020120306.20"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020120306.21"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020120306.22"><vh>find.update_ivars</vh></v>
<v t="ekr.20051023183028"><vh>findButtonCallback</vh></v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20060204120158.1"><vh>findAgainCommand</vh></v>
<v t="ekr.20060128075225"><vh>cloneFindAllCommand</vh></v>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.27"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020120306.28"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20051020120306.1"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020120306.2"><vh>__init__</vh>
<v t="ekr.20051020120306.3"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.4"><vh>bindHotKey</vh></v>
<v t="ekr.20051020120306.5"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20060123131421"><vh>Top-level methods</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>Find Tab commands</vh></v>
<v t="ekr.20060124115801"><vh>getHandler</vh></v>
<v t="ekr.20060123115459"><vh>Find options wrappers</vh></v>
<v t="ekr.20060124093828"><vh>Find wrappers</vh></v>
<v t="ekr.20060204120158.2"><vh>findAgain</vh></v>
</v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler &amp; helper</vh></v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
<v t="ekr.20060203072636"><vh>endSearch</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2949"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20031218072017.2950"><vh>c.begin/endUpdate</vh></v>
<v t="ekr.20031218072017.2951"><vh>c.bringToFront</vh></v>
<v t="ekr.20060205103842"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060207140352"><vh>c.masterFocusHandler</vh></v>
<v t="ekr.20060208143543"><vh>c.noKnownFocus</vh></v>
<v t="ekr.20031218072017.2953"><vh>c.recolor &amp; requestRecolor</vh></v>
<v t="ekr.20051216171520"><vh>c.recolor_now</vh></v>
<v t="ekr.20031218072017.2954"><vh>c.redraw_now</vh></v>
<v t="ekr.20060207142332"><vh>c.traceFocus</vh></v>
<v t="ekr.20060205111103"><vh>c.widget_name</vh></v>
<v t="ekr.20050120092028"><vh>c.xWantsFocus/Now</vh></v>
</v>
<v t="ekr.20031218072017.4039"><vh>class leoTkinterLog</vh>
<v t="ekr.20051016095907"><vh>tkLog Birth</vh>
<v t="ekr.20031218072017.4040"><vh>tkLog.__init__</vh></v>
<v t="ekr.20031218072017.4042"><vh>tkLog.createControl</vh></v>
<v t="ekr.20051016103459"><vh>tkLog.createTextWidget</vh></v>
<v t="ekr.20051019134106.1"><vh>tkLog.makeTabMenu</vh></v>
</v>
<v t="ekr.20051016095907.1"><vh>Config &amp; get/saveState</vh>
<v t="ekr.20031218072017.4041"><vh>tkLog.configureBorder &amp; configureFont</vh></v>
<v t="ekr.20031218072017.4043"><vh>tkLog.getFontConfig</vh></v>
<v t="ekr.20041222043017"><vh>tkLog.restoreAllState</vh></v>
<v t="ekr.20041222043017.1"><vh>tkLog.saveAllState</vh></v>
<v t="ekr.20041217135735.2"><vh>tkLog.setColorFromConfig</vh></v>
<v t="ekr.20031218072017.4046"><vh>tkLog.setFontFromConfig</vh></v>
</v>
<v t="ekr.20051016095907.2"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20031218072017.4045"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20031218072017.4044"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20051016101927"><vh>put &amp; putnl (tkLog)</vh>
<v t="ekr.20031218072017.1473"><vh>put</vh>
<v t="EKR.20040423082910"><vh>&lt;&lt; put s to log control &gt;&gt;</vh></v>
<v t="EKR.20040423082910.1"><vh>&lt;&lt; put s to logWaiting and print s &gt;&gt;</vh></v>
</v>
<v t="ekr.20051016101927.1"><vh>putnl</vh></v>
</v>
<v t="ekr.20051018061932"><vh>Tab (TkLog)</vh>
<v t="ekr.20051017212057"><vh>clearTab</vh></v>
<v t="ekr.20051024173701"><vh>createTab</vh>
<v t="ekr.20051018072306"><vh>&lt;&lt; Create the tab's text widget &gt;&gt;</vh></v>
</v>
<v t="ekr.20051018102027"><vh>deleteTab</vh></v>
<v t="ekr.20060204124347"><vh>hideTab</vh></v>
<v t="ekr.20051027114433"><vh>getSelectedTab</vh></v>
<v t="ekr.20051018061932.1"><vh>lower/raiseTab</vh></v>
<v t="ekr.20051019170806"><vh>renameTab</vh></v>
<v t="ekr.20051016101724.1"><vh>selectTab</vh></v>
<v t="ekr.20051022162730"><vh>setTabBindings</vh></v>
<v t="ekr.20051019134106"><vh>Tab menu callbacks &amp; helpers</vh>
<v t="ekr.20051019134422"><vh>onRightClick &amp; onClick</vh></v>
<v t="ekr.20051019140004.1"><vh>newTabFromMenu</vh></v>
<v t="ekr.20051019165401"><vh>renameTabFromMenu</vh></v>
<v t="ekr.20051019172811"><vh>getTabName</vh></v>
</v>
</v>
</v>
<v t="ekr.20060129052538.1"><vh>Master event handlers (keyHandler)</vh>
<v t="ekr.20060127183752"><vh>masterKeyHandler &amp; helper</vh>
<v t="ekr.20060205221734"><vh>masterKeyHandlerHelper</vh></v>
</v>
<v t="ekr.20060129052538.2"><vh>masterClickHandler</vh></v>
<v t="ekr.20060131084938"><vh>masterDoubleClickHandler</vh></v>
<v t="ekr.20060128090219"><vh>masterMenuHandler</vh></v>
</v>
</v>
<v t="ekr.20060208080524"><vh>Recent 4.4b2 projects</vh>
<v t="ekr.20060206062108.1"><vh>What I did: 2-6-05</vh></v>
<v t="ekr.20060207091145"><vh>Fixed undo problem in headlines</vh>
<v t="ekr.20060207110408"><vh>Notes</vh></v>
<v t="ekr.20040803072955.58"><vh>redraw_now &amp; helper</vh>
<v t="ekr.20040803072955.59"><vh>redrawHelper</vh></v>
</v>
<v t="ekr.20040803072955.127"><vh>editLabel</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
<v t="ekr.20050318085713.1"><vh>undoNodeContents</vh></v>
<v t="ekr.20050318085432.7"><vh>redoNodeContents</vh></v>
<v t="ekr.20060207101443"><vh>tree.setHeadline (new in 4.4b2)</vh></v>
</v>
<v t="ekr.20060207110750"><vh>What I did: 2-7-05</vh></v>
<v t="ekr.20060207135120"><vh>Created c.masterFocusHandler and made it work</vh>
<v t="ekr.20060207164200"><vh>What I did</vh></v>
<v t="ekr.20040803072955.15"><vh> Birth... (tkTree)</vh>
<v t="ekr.20040803072955.16"><vh>__init__ (tkTree)</vh>
<v t="ekr.20040803072955.17"><vh>&lt;&lt; define drawing constants &gt;&gt;</vh></v>
<v t="ekr.20040803072955.18"><vh>&lt;&lt; old ivars &gt;&gt;</vh></v>
<v t="ekr.20040803072955.19"><vh>&lt;&lt; inject callbacks into the position class &gt;&gt;</vh></v>
</v>
<v t="ekr.20051024102724"><vh>tkTtree.setBindings</vh>
<v t="ekr.20060131173440"><vh>&lt;&lt; make bindings for a common binding widget &gt;&gt;</vh></v>
<v t="ekr.20060131173440.2"><vh>&lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.21"><vh>injectCallbacks</vh>
<v t="ekr.20040803072955.22"><vh>&lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;</vh>
<v t="ekr.20040803072955.23"><vh>OnHyperLinkControlClick</vh></v>
<v t="ekr.20040803072955.24"><vh>OnHyperLinkEnter</vh></v>
<v t="ekr.20040803072955.25"><vh>OnHyperLinkLeave</vh></v>
</v>
</v>
</v>
<v t="ekr.20040803072955.71"><vh>Event handlers (tkTree)</vh>
<v t="ekr.20051105103233"><vh>Helpers</vh>
<v t="ekr.20040803072955.72"><vh>checkWidgetList</vh></v>
<v t="ekr.20040803072955.73"><vh>dumpWidgetList</vh></v>
<v t="ekr.20040803072955.75"><vh>edit_widget</vh></v>
<v t="ekr.20040803072955.74"><vh>eventToPosition</vh></v>
<v t="ekr.20040803072955.76"><vh>findEditWidget</vh></v>
<v t="ekr.20040803072955.109"><vh>findVnodeWithIconId</vh></v>
</v>
<v t="ekr.20040803072955.78"><vh>Click Box...</vh>
<v t="ekr.20040803072955.79"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20040803072955.99"><vh>Dragging</vh>
<v t="ekr.20041111115908"><vh>endDrag</vh>
<v t="ekr.20040803072955.104"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20041111114148"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20041111114944"><vh>startDrag</vh></v>
<v t="ekr.20040803072955.100"><vh>onContinueDrag</vh>
<v t="ekr.20040803072955.101"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.102"><vh>onDrag</vh></v>
<v t="ekr.20040803072955.103"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040803072955.80"><vh>Icon Box...</vh>
<v t="ekr.20040803072955.81"><vh>onIconBoxClick</vh></v>
<v t="ekr.20040803072955.89"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20040803072955.82"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20040803072955.105"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20040803072955.106"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.84"><vh>Text Box...</vh>
<v t="ekr.20040803072955.85"><vh>configureTextState</vh></v>
<v t="ekr.20040803072955.86"><vh>onCtontrolT</vh></v>
<v t="ekr.20040803072955.87"><vh>onHeadlineClick</vh></v>
<v t="ekr.20040803072955.83"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20040803072955.108"><vh>tree.OnDeactivate</vh></v>
<v t="ekr.20040803072955.110"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20040803072955.111"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20040803072955.112"><vh>createPopupMenu</vh>
<v t="ekr.20040803072955.113"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.114"><vh>enablePopupMenuItems</vh>
<v t="ekr.20040803072955.115"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.116"><vh>showPopupMenu</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2373"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20060207103936"><vh>setInputState is messing with body focus</vh>
<v t="ekr.20031218072017.3995"><vh>Tk bindings...</vh></v>
<v t="ekr.20060205103842"><vh>c.get/request/set_focus</vh></v>
<v t="ekr.20060120200818"><vh>setInputState</vh></v>
<v t="ekr.20060120193743"><vh>showStateAndMode</vh></v>
</v>
<v t="ekr.20060206165304"><vh>Fixed find.success bug</vh>
<v t="ekr.20031218072017.4059"><vh>app.gui.Tkinter.utils</vh>
<v t="ekr.20031218072017.844"><vh>Clipboard (tkGui)</vh>
<v t="ekr.20031218072017.845"><vh>replaceClipboardWith</vh></v>
<v t="ekr.20031218072017.846"><vh>getTextFromClipboard</vh></v>
</v>
<v t="ekr.20031218072017.4060"><vh>Dialog</vh>
<v t="ekr.20031218072017.4061"><vh>get_window_info</vh></v>
<v t="ekr.20031218072017.4062"><vh>center_dialog</vh></v>
<v t="ekr.20031218072017.4063"><vh>create_labeled_frame</vh></v>
</v>
<v t="ekr.20031218072017.4064"><vh>Focus</vh>
<v t="ekr.20031218072017.4065"><vh>get_focus</vh></v>
<v t="ekr.20031218072017.2373"><vh>set_focus (app.gui)</vh></v>
</v>
<v t="ekr.20031218072017.4066"><vh>Font</vh>
<v t="ekr.20031218072017.2187"><vh>tkGui.getFontFromParams</vh></v>
</v>
<v t="ekr.20031218072017.4067"><vh>Icons</vh>
<v t="ekr.20031218072017.4068"><vh>attachLeoIcon &amp; createLeoIcon</vh>
<v t="ekr.20031218072017.4069"><vh>&lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;</vh></v>
<v t="ekr.20031218072017.4070"><vh>createLeoIcon</vh></v>
</v>
</v>
<v t="ekr.20031218072017.4071"><vh>Idle Time</vh>
<v t="ekr.20031218072017.4072"><vh>tkinterGui.setIdleTimeHook</vh></v>
<v t="ekr.20031218072017.4073"><vh>setIdleTimeHookAfterDelay</vh></v>
</v>
<v t="ekr.20031218072017.4074"><vh>Indices (Tk)</vh>
<v t="ekr.20031218072017.4075"><vh>firstIndex</vh></v>
<v t="ekr.20031218072017.4076"><vh>lastIndex</vh></v>
<v t="ekr.20031218072017.4077"><vh>moveIndexBackward</vh></v>
<v t="ekr.20031218072017.4078"><vh>moveIndexForward &amp; moveIndexToNextLine</vh></v>
<v t="ekr.20031218072017.4079"><vh>compareIndices</vh></v>
<v t="ekr.20031218072017.4080"><vh>getindex</vh></v>
</v>
<v t="ekr.20031218072017.4081"><vh>Insert Point</vh>
<v t="ekr.20031218072017.4082"><vh>getInsertPoint</vh></v>
<v t="ekr.20031218072017.4083"><vh>setInsertPoint</vh></v>
</v>
<v t="ekr.20031218072017.4084"><vh>Selection</vh>
<v t="ekr.20031218072017.4085"><vh>getSelectionRange</vh></v>
<v t="ekr.20051126125950"><vh>getSelectedText</vh></v>
<v t="ekr.20031218072017.4086"><vh>getTextSelection</vh></v>
<v t="ekr.20051126171929"><vh>hasSelection</vh></v>
<v t="ekr.20031218072017.4088"><vh>setSelectionRangeWithLength</vh></v>
<v t="ekr.20031218072017.4089"><vh>setTextSelection &amp; setSelectionRange</vh></v>
</v>
<v t="ekr.20031218072017.4090"><vh>Text</vh>
<v t="ekr.20031218072017.4091"><vh>getAllText</vh></v>
<v t="ekr.20031218072017.4092"><vh>getCharAfterIndex</vh></v>
<v t="ekr.20031218072017.4093"><vh>getCharAtIndex</vh></v>
<v t="ekr.20031218072017.4094"><vh>getCharBeforeIndex</vh></v>
<v t="ekr.20031218072017.4095"><vh>getLineContainingIndex</vh></v>
<v t="ekr.20031218072017.4096"><vh>replaceSelectionRangeWithText (leoTkinterGui)</vh></v>
</v>
<v t="ekr.20031218072017.4097"><vh>Visibility</vh>
<v t="ekr.20031218072017.4098"><vh>makeIndexVisible</vh></v>
</v>
<v t="ekr.20051220144507"><vh>isTextWidget</vh></v>
</v>
<v t="ekr.20031218072017.3907"><vh>bringToFront</vh></v>
<v t="ekr.20031218072017.3089"><vh>restore</vh></v>
<v t="ekr.20031218072017.3091"><vh>showSuccess</vh></v>
</v>
<v t="ekr.20060208064636"><vh>Fixed recent blunder so click in headline works</vh>
<v t="ekr.20040803072955.127"><vh>editLabel</vh></v>
<v t="ekr.20040803072955.135"><vh>setEditLabelState</vh></v>
<v t="ekr.20040803072955.105"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20040803072955.106"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.87"><vh>onHeadlineClick</vh></v>
</v>
<v t="ekr.20060206124634"><vh>Fixed tree icon bug</vh>
<v t="ekr.20060208081656"><vh>Notes</vh></v>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkBody) &amp; removeTrailingNewlines</vh>
<v t="ekr.20051026143009"><vh>removeTrailingNewlines</vh></v>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20060208195315"><vh>Added unit tests for key dicts</vh></v>
</v>
</v>
<v t="ekr.20060206103355"><vh>To do 4.4b2</vh>
<v t="ekr.20060122183914.1"><vh>Urgent commands for mouseless Leo (4)</vh>
<v t="ekr.20060122193554" a="M"><vh>prev-line and next-line do not remember column properly</vh></v>
<v t="ekr.20060116083359.1" a="M"><vh>expand-pane &amp; contract-pane</vh></v>
<v t="ekr.20060116080040.2"><vh>activate-xxx-menu commands</vh></v>
<v t="ekr.20060206103531"><vh>(maybe) select-find-tab-find-text &amp; select-find-tab-change-text</vh></v>
</v>
<v t="ekr.20060122183914"><vh>Fix minor bugs 10</vh>
<v t="ekr.20060206131908"><vh>pasteText (with empty text?) crashed when pasting into minibuffer</vh></v>
<v t="ekr.20060122185244.2"><vh>Fix unindent command</vh></v>
<v t="ekr.20060206113925"><vh>Make sure yield works with Python 2.2</vh></v>
<v t="ekr.20060206113925.1"><vh>Fix problem with body_gmt_time setting</vh></v>
<v t="ekr.20060121101642"><vh>Make sure save updates the open directory</vh></v>
<v t="ekr.20050707085637"><vh>Suggestions from an emacs user 3</vh>
<v t="ekr.20060116082302.1"><vh>Use os.getenv('User") if it exists to get initial cvs name</vh></v>
<v t="ekr.20060116083043"><vh>Two help menus on the Mac</vh></v>
<v t="ekr.20060116083043.1"><vh>Add context-menus on nodes or text</vh></v>
</v>
<v t="ekr.20060114055611"><vh>Fix sort-lines problems</vh></v>
<v t="ekr.20060124082357"><vh>Fix problem with view plugin</vh></v>
</v>
<v t="ekr.20060206104510"><vh>Docs</vh>
<v t="ekr.20060206105450"><vh>Finish apropos-find-commands</vh></v>
<v t="ekr.20060124090925"><vh>Posting</vh></v>
<v t="ekr.20051103091115.1"><vh>(done) Reorganize Find/Change settings</vh></v>
<v t="ekr.20060206104722"><vh>(done) Allow modes to inherit bindings</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2406" a="V"><vh>Code</vh>
<v t="ekr.20031218072017.2606"><vh>&lt;&lt; Import pychecker &gt;&gt;</vh></v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>c.signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20040629121554.2,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3093"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20060123151617"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20050710142719"><vh>@thin leoEditCommands.py</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040423082910">if color:
    if color not in self.colorTags:
        self.colorTags.append(color)
        self.logCtrl.tag_config(color,foreground=color)
    self.logCtrl.insert("end",s)
    self.logCtrl.tag_add(color,"end-%dc" % (len(s)+1),"end-1c")
    self.logCtrl.tag_add("black","end")
else:
    self.logCtrl.insert("end",s)

self.logCtrl.see("end")
self.forceLogUpdate(s)</t>
<t tx="EKR.20040423082910.1">g.app.logWaiting.append((s,color),)

print "Null tkinter log"

if type(s) == type(u""):
    s = g.toEncodedString(s,"ascii")

print s</t>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="ekr.20031218072017.844">@

The following are called only when g.app.gui.win32clipboard is not None, and
presently that never happens.</t>
<t tx="ekr.20031218072017.845">def replaceClipboardWith (self,s):

    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard

    if wcb:
        try:
            wcb.OpenClipboard(0)
            wcb.EmptyClipboard()
            wcb.SetClipboardText(s)
            wcb.CloseClipboard()
        except:
            g.es_exception()
    else:
        self.root.clipboard_clear()
        self.root.clipboard_append(s)</t>
<t tx="ekr.20031218072017.846">def getTextFromClipboard (self):
    
    # g.app.gui.win32clipboard is always None.
    wcb = g.app.gui.win32clipboard
    
    if wcb:
        try:
            wcb.OpenClipboard(0)
            data = wcb.GetClipboardData()
            wcb.CloseClipboard()
            # g.trace(data)
            return data
        except TypeError:
            # g.trace(None)
            return None
        except:
            g.es_exception()
            return None
    else:
        try:
            s = self.root.selection_get(selection="CLIPBOARD")
            return s
        except:
            return None</t>
<t tx="ekr.20031218072017.998">def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20031218072017.1329"># This is the only key handler for the body pane.
def onBodyChanged (self,undoType,
    oldSel=None,oldText=None,oldYview=None,removeTrailing=None):
    
    '''Update Leo after the body has been changed.'''
    
    body = self ; c = self.c ; bodyCtrl = body.bodyCtrl
    p = c.currentPosition()
    insert = bodyCtrl.index('insert')
    ch = g.choose(insert=='1.0','',bodyCtrl.get('insert-1c'))
    # ch = bodyCtrl.get('insert-1c')
    newText = bodyCtrl.get('1.0','end')
    newSel = g.app.gui.getTextSelection(bodyCtrl)
    if oldText is None: oldText = p.bodyString()
    if removeTrailing is None:
        removeTrailing = self.removeTrailingNewlines(oldText,newText,ch)
    if removeTrailing and newText:
        newText = newText[:-1]
    changed = oldText != newText
    if 0:
        g.trace('removeTrailing',removeTrailing,'changed',changed,
            'ch',repr(ch),'newText',repr(newText),'oldText',repr(oldText),
            g.callers())
    if changed:
        c.undoer.setUndoTypingParams(p,undoType,
            oldText=oldText,newText=newText,oldSel=oldSel,newSel=newSel,oldYview=oldYview)
        p.v.setTnodeText(newText)
        p.v.t.insertSpot = body.getInsertionPoint()
        &lt;&lt; recolor the body &gt;&gt;
        if not c.changed: c.setChanged(True)
        &lt;&lt; redraw the screen if necessary &gt;&gt;</t>
<t tx="ekr.20031218072017.1473"># All output to the log stream eventually comes here.
def put (self,s,color=None,tabName='Log'):
    
    c = self.c
    
    # print 'tkLog.put',self.c.shortFileName(),tabName,g.callers()

    if g.app.quitting or not c or not c.exists:
        return

    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        &lt;&lt; put s to log control &gt;&gt;
        self.logCtrl.update_idletasks()
    else:
        &lt;&lt; put s to logWaiting and print s &gt;&gt;</t>
<t tx="ekr.20031218072017.1588"># debugGC = False # Must be true to enable traces below.

lastObjectCount = 0
lastObjectsDict = {}
lastTypesDict = {}
lastFunctionsDict = {}

@others
</t>
<t tx="ekr.20031218072017.1589">def clearAllIvars (o):
    
    """Clear all ivars of o, a member of some class."""
    
    o.__dict__.clear()
</t>
<t tx="ekr.20031218072017.1590">def collectGarbage():
    
    if not g.app.trace_gc: return
    
    if not g.app.trace_gc_inited:
        g.enable_gc_debug()
    
    if not g.app.trace_gc_inited:
        g.app.trace_gc = False
    
    try: gc.collect()
    except: pass
</t>
<t tx="ekr.20031218072017.1592">def printGc(message=None):
    
    if not g.app.trace_gc: return None
    
    if not message:
        message = g.callerName(n=2)
        
    printGcObjects(message)
    printGcRefs(message)
    
    if g.app.trace_gc_verbose:
        printGcVerbose(message)
        
    
</t>
<t tx="ekr.20031218072017.1593">def printGcRefs (message=''):

    refs = gc.get_referrers(app.windowList[0])
    g.es_print('-' * 30,message)

    if g.app.trace_gc_verbose:
        g.es_print("refs of", app.windowList[0])
        for ref in refs:
            g.es_print(type(ref))
    else:
        g.es_print("%d referers" % len(refs))</t>
<t tx="ekr.20031218072017.1761">def insertHeadline (self,event=None,op_name="Insert Node"):
    
    '''Insert a node after the presently selected node.'''

    c = self ; u = c.undoer
    current = c.currentPosition()
    
    if not current: return

    c.beginUpdate()
    try:
        undoData = c.undoer.beforeInsertNode(current)
        # Make sure the new node is visible when hoisting.
        if ((current.hasChildren() and current.isExpanded()) or
            (c.hoistStack and current == c.hoistStack[-1].p)):
            p = current.insertAsNthChild(0)
        else:
            p = current.insertAfter()
        dirtyVnodeList = p.setAllAncestorAtFileNodesDirty()
        c.setChanged(True)
        u.afterInsertNode(p,op_name,undoData,dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate(False,scroll=True)
        c.editPosition(p)

    return p # for mod_labels plugin.</t>
<t tx="ekr.20031218072017.1801">def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    &lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</t>
<t tx="ekr.20031218072017.1802"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None</t>
<t tx="ekr.20031218072017.1974">def destroySelf (self):
    
    # Remember these: we are about to destroy all of our ivars!
    top = self.top 
    c = self.c
    
    # Indicate that the commander is no longer valid.
    c.exists = False 
    
    # g.trace(self)

    # Important: this destroys all the object of the commander too.
    self.destroyAllObjects()
    
    c.exists = False # Make sure this one ivar has not been destroyed.

    top.destroy()</t>
<t tx="ekr.20031218072017.1975">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)</t>
<t tx="ekr.20031218072017.1976"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="ekr.20031218072017.2052">def openWithFileName(fileName,old_c,
    enableLog=True,readAtFileNodesFlag=True):
    
    """Create a Leo Frame for the indicated fileName if the file exists."""

    if not fileName or len(fileName) == 0:
        return False, None
        
    def munge(name):
        name = name or ''
        return g.os_path_normpath(name).lower()

    # Create a full, normalized, Unicode path name, preserving case.
    fileName = g.os_path_normpath(g.os_path_abspath(fileName))

    # If the file is already open just bring its window to the front.
    theList = app.windowList
    for frame in theList:
        if munge(fileName) == munge(frame.c.mFileName):
            frame.bringToFront()
            frame.c.setLog()
            return True, frame
    try:
        if old_c:
            # New in 4.4: We must read the file *twice*.
            # The first time sets settings for the later call to c.finishCreate.
            # g.trace('***** prereading',fileName)
            c2 = g.app.config.openSettingsFile(fileName)
            if c2: g.app.config.updateSettings(c2,localFlag=True)
        # Open the file in binary mode to allow 0x1a in bodies &amp; headlines.
        theFile = open(fileName,'rb')
        c,frame = app.newLeoCommanderAndFrame(fileName)
        frame.log.enable(enableLog)
        g.app.writeWaitingLog() # New in 4.3: write queued log first.
        c.beginUpdate()
        try:
            if not g.doHook("open1",old_c=old_c,c=c,new_c=c,fileName=fileName):
                c.setLog()
                app.lockLog()
                frame.c.fileCommands.open(
                    theFile,fileName,
                    readAtFileNodesFlag=readAtFileNodesFlag) # closes file.
                app.unlockLog()
                for frame in g.app.windowList:
                    # The recent files list has been updated by menu.updateRecentFiles.
                    frame.c.config.setRecentFiles(g.app.config.recentFiles)
            # Bug fix in 4.4.
            frame.openDirectory = g.os_path_dirname(fileName)
            g.doHook("open2",old_c=old_c,c=c,new_c=frame.c,fileName=fileName)
        finally:
            c.endUpdate()
            k = c.k
            k and k.setInputState(k.unboundKeyAction)
            c.bodyWantsFocusNow()
        return True, frame
    except IOError:
        # Do not use string + here: it will fail for non-ascii strings!
        if not g.app.unitTesting:
            g.es("can not open: %s" % (fileName), color="blue")
        return False, None
    except Exception:
        g.es("exceptions opening: %s" % (fileName),color="red")
        g.es_exception()
        return False, None</t>
<t tx="ekr.20031218072017.2176">def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    c.setLog()
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    c.bodyWantsFocusNow()
    # f.enableTclTraces()</t>
<t tx="ekr.20031218072017.2187">def getFontFromParams(self,family,size,slant,weight,defaultSize=12):
    
    __pychecker__ = '--no-argsused' # defaultSize not used.

    family_name = family
    
    try:
        font = tkFont.Font(family=family,size=size,slant=slant,weight=weight)
        # if g.app.trace: g.trace(font)
        return font
    except:
        g.es("exception setting font from ",family_name)
        g.es("family,size,slant,weight:",family,size,slant,weight)
        # g.es_exception() # This just confuses people.
        return g.app.config.defaultFont</t>
<t tx="ekr.20031218072017.2373">set_focus_count = 0

def set_focus(self,c,w):
    
    __pychecker__ = '--no-argsused' # c not used at present.
    
    """Put the focus on the widget."""
    
    if 0: # Big trace if we have unexpected focus.
        w2 = c.frame.outerFrame.focus_get()
        wname = c.widget_name(w2)
        for s in ('canvas','log','mini','body','head'):
            if wname.startswith(s): break
        else:
            if w2:
                g.trace('*'*40,'Previous widget',wname)
                g.trace(repr(w2),g.callers())
                
    if not g.app.unitTesting and c.config.getBool('trace_g.app.gui.set_focus'):
        self.set_focus_count += 1
        g.trace('%4d %10s' % (self.set_focus_count,c.widget_name(w)),g.callers())
    
    if w:
        try:
            if 0: # No longer needed.
                # A call to findTab.bringToFront caused
                # the focus problems with Pmw.Notebook.
                w.update()

            # It's possible that the widget doesn't exist now.
            w.focus_set()
            return True
        except Exception:
            # g.es_exception()
            return False</t>
<t tx="ekr.20031218072017.2406">@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode
z:  a local temp.</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2606">@color

# __pychecker__ = '--no-argsused'

# See pycheckrc file in leoDist.leo for a list of erroneous warnings to be suppressed.

if 0: # Set to 1 for lint-like testing.
      # Use t23.bat: only on Python 2.3.

    try:
        import pychecker.checker
        # This works.  We may want to set options here...
        # from pychecker import Config 
        # print pychecker
        print ; print "Warning (in leo.py): pychecker.checker running..." ; print
    except:
        print ; print 'Can not import pychecker' ; print</t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    c.exists = True # Indicate that this class exists and has not been destroyed.
        # Do this early in the startup process so we can call hooks.
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = c.config.getBool('useTextMinibuffer')
    self.showMinibuffer = c.config.getBool('useMinibuffer')
    self.stayInTree = c.config.getBool('stayInTreeAfterSelect')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# Delayed focus.
self.hasFocusWidget = None
self.requestedFocusWidget = None

# Official ivars.
self.gui = g.app.gui

# Interlocks to prevent premature closing of a window.
self.inCommand = False
self.requestCloseWindow = False

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = self.k = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.2949"></t>
<t tx="ekr.20031218072017.2950">@
**Important** These methods ensure that exactly zero or one (depending on the
argument to endUpdate) redraws exist within the section of code bounded by
c.beginUpdate and c.endUpdate. This greatly simplifies and clarifies the code.

Callers should ensure that every beginUpdate is matched with an endUpdate by
using the following pattern:
    c.beginUpdate()
    try:
        &lt;&lt; whatever &gt;&gt;
    finally:
        c.endUpdate()
@c

def beginUpdate(self):
    
    '''Suppress redraws of the tree (except for explict calls to c.redraw_now)
    until the matching call to endUpdate.'''
    
    c = self
    c.frame.tree.beginUpdate()
    
def endUpdate(self,flag=True,scroll=False):
    
    '''Redraw the screen if flag is True.'''

    c = self
    c.frame.tree.endUpdate(flag,scroll=scroll)

BeginUpdate = beginUpdate # Compatibility with old scripts
EndUpdate = endUpdate # Compatibility with old scripts
</t>
<t tx="ekr.20031218072017.2951">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20031218072017.2953">def recolor(self):

    c = self
    c.frame.body.recolor(c.currentPosition())
    
def requestRecolor (self):
    
    c = self
    c.frame.requestRecolorFlag = True</t>
<t tx="ekr.20031218072017.2954">def redraw_now (self):
    
    c = self
    
    if g.app.quitting or not c.exists or not hasattr(c.frame,'top'):
        return # nullFrame's do not have a top frame.

    c.frame.tree.redraw_now()
    c.frame.top.update_idletasks()
    
    if c.frame.requestRecolorFlag:
        c.frame.requestRecolorFlag = False
        c.recolor()

# Compatibility with old scripts
redraw = force_redraw = redraw_now</t>
<t tx="ekr.20031218072017.3089"># Restores the screen after a search fails

def restore (self,data):

    c = self.c ; gui = g.app.gui
    in_headline,p,t,insert,start,end = data
    
    c.frame.bringToFront() # Needed on the Mac

    # Don't try to reedit headline.
    c.selectPosition(p)
    if not in_headline:

        # Looks good and provides clear indication of failure or termination.
        gui.setSelectionRange(t,insert,insert)
        gui.setInsertPoint(t,insert)
        gui.makeIndexVisible(t,insert)
    
    g.trace(c.widget_name(t))
    c.widgetWantsFocusNow(t)</t>
<t tx="ekr.20031218072017.3091">def showSuccess(self,pos,newpos):

    """Displays the final result.

    Returns self.dummy_vnode, p.edit_widget() or c.frame.bodyCtrl with
    "insert" and "sel" points set properly."""

    c = self.c ; p = self.p ; gui = g.app.gui
    
    c.frame.bringToFront() # Needed on the Mac
    c.beginUpdate()
    try:
        c.selectPosition(p)
    finally:
        c.endUpdate(scroll=True)
    if self.in_headline:
        c.editPosition(p)
    # Set the focus and selection after the redraw.
    t = g.choose(self.in_headline,p.edit_widget(),c.frame.bodyCtrl)
    insert = g.choose(self.reverse,pos,newpos)
    # New in 4.4a3: a much better way to ensure progress in backward searches.
    gui.setSelectionRange(t,pos,newpos,insert=insert)
    c.widgetWantsFocusNow(t)
    gui.makeIndexVisible(t,insert)
    if self.wrap and not self.wrapPosition:
        self.wrapPosition = self.p</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3907">def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()
    c.widgetWantsFocusNow(t)
    
    # Apparently, the text can not be adjusted unless the widget has focus...
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # New in 4.3: don't highlight the stupid added trailing newline!
    gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.</t>
<t tx="ekr.20031218072017.3941"></t>
<t tx="ekr.20031218072017.3942">def __repr__ (self):

    return "&lt;leoTkinterFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20031218072017.3944">def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas</t>
<t tx="ekr.20031218072017.3946">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2,g.callers())
    
    if use_Pmw and Pmw:
        &lt;&lt; resize the Pmw panes &gt;&gt;
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20031218072017.3947">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="ekr.20031218072017.3949"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="ekr.20031218072017.3950"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20031218072017.3951">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot = top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax = top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot = top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax = top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="ekr.20031218072017.3952">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="ekr.20031218072017.3964"></t>
<t tx="ekr.20031218072017.3965">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()</t>
<t tx="ekr.20031218072017.3995">def bringToFront (self):
    self.top.deiconify()
    self.top.lift()

def getFocus(self):
    """Returns the widget that has focus, or body if None."""
    try:
        # This method is unreliable while focus is changing.
        # The call to update_idletasks may help.  Or not.
        self.top.update_idletasks()
        f = self.top.focus_displayof()
    except Exception:
        f = None
    if f:
        return f
    else:
        return self.bodyCtrl
        
def getTitle (self):
    return self.top.title()
    
def setTitle (self,title):
    return self.top.title(title)
    
def get_window_info(self):
    return g.app.gui.get_window_info(self.top)
    
def iconify(self):
    self.top.iconify()

def deiconify (self):
    self.top.deiconify()
    
def lift (self):
    self.top.lift()
    
def update (self):
    self.top.update()</t>
<t tx="ekr.20031218072017.4039">class leoTkinterLog (leoFrame.leoLog):
    
    """A class that represents the log pane of a Tkinter window."""

    @others</t>
<t tx="ekr.20031218072017.4040">def __init__ (self,frame,parentFrame):
    
    # g.trace("leoTkinterLog")
    
    self.c = c = frame.c # Also set in the base constructor, but we need it here.
    
    self.colorTags = []
        # The list of color names used as tags in present tab.
        # This gest switched by selectTab.

    self.wrap = g.choose(c.config.getBool('log_pane_wraps'),"word","none")
    
    # New in 4.4a2: The log pane is a Pmw.Notebook...

    self.nb = None      # The Pmw.Notebook that holds all the tabs.
    self.colorTagsDict = {} # Keys are page names.  Values are saved colorTags lists.
    self.frameDict = {}  # Keys are page names. Values are Tk.Frames.
    self.logNumber = 0 # To create unique name fields for Tk.Text widgets.
    self.menu = None # A menu that pops up on right clicks in the hull or in tabs.
    self.textDict = {}  # Keys are page names. Values are Tk.Text widgets.
    self.newTabCount = 0 # Number of new tabs created.
    
    # Official status variables.  Can be used by client code.
    self.tabName = None # The name of the active tab.
    self.logCtrl = None # Same as self.textDict.get(self.tabName)
    self.tabFrame = None # Same as self.frameDict.get(self.tabName)
    
    # Call the base class constructor and calls createControl.
    leoFrame.leoLog.__init__(self,frame,parentFrame)
</t>
<t tx="ekr.20031218072017.4041">def configureBorder(self,border):
    
    self.logCtrl.configure(bd=border)
    
def configureFont(self,font):

    self.logCtrl.configure(font=font)</t>
<t tx="ekr.20031218072017.4042">def createControl (self,parentFrame):

    c = self.c

    self.nb = Pmw.NoteBook(parentFrame,
        borderwidth = 1, pagemargin = 0,
        raisecommand = self.raiseTab,
        lowercommand = self.lowerTab,
        arrownavigation = 0,
    )

    menu = self.makeTabMenu(tabName=None)

    def hullMenuCallback(event):
        g.trace()
        self.onRightClick(event,menu)

    self.nb.bind('&lt;Button-3&gt;',hullMenuCallback)

    self.nb.pack(fill='both',expand=1)
    self.selectTab('Log') # create the tab and make it the active tab.
    return self.logCtrl</t>
<t tx="ekr.20031218072017.4043">def getFontConfig (self):

    font = self.logCtrl.cget("font")
    # g.trace(font)
    return font</t>
<t tx="ekr.20031218072017.4044">def hasFocus (self):
    
    return self.c.get_focus() == self.logCtrl</t>
<t tx="ekr.20031218072017.4045">def onActivateLog (self,event=None):

    try:
        self.c.setLog()
        self.frame.tree.OnDeactivate()
        self.c.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20031218072017.4046">def SetWidgetFontFromConfig (self,logCtrl=None):

    c = self.c

    if not logCtrl: logCtrl = self.logCtrl

    font = c.config.getFontFromParams(
        "log_text_font_family", "log_text_font_size",
        "log_text_font_slant", "log_text_font_weight",
        c.config.defaultLogFontSize)

    self.fontRef = font # ESSENTIAL: retain a link to font.
    logCtrl.configure(font=font)

    # g.trace("LOG",logCtrl.cget("font"),font.cget("family"),font.cget("weight"))

    bg = c.config.getColor("log_text_background_color")
    if bg:
        try: logCtrl.configure(bg=bg)
        except: pass

    fg = c.config.getColor("log_text_foreground_color")
    if fg:
        try: logCtrl.configure(fg=fg)
        except: pass
        
setFontFromConfig = SetWidgetFontFromConfig # Renaming supresses a pychecker warning.</t>
<t tx="ekr.20031218072017.4059"></t>
<t tx="ekr.20031218072017.4060"></t>
<t tx="ekr.20031218072017.4061"># WARNING: Call this routine _after_ creating a dialog.
# (This routine inhibits the grid and pack geometry managers.)

def get_window_info (self,top):
    
    top.update_idletasks() # Required to get proper info.

    # Get the information about top and the screen.
    geom = top.geometry() # geom = "WidthxHeight+XOffset+YOffset"
    dim,x,y = string.split(geom,'+')
    w,h = string.split(dim,'x')
    w,h,x,y = int(w),int(h),int(x),int(y)
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4062">def center_dialog(self,top):

    """Center the dialog on the screen.

    WARNING: Call this routine _after_ creating a dialog.
    (This routine inhibits the grid and pack geometry managers.)"""

    sw = top.winfo_screenwidth()
    sh = top.winfo_screenheight()
    w,h,x,y = self.get_window_info(top)
    
    # Set the new window coordinates, leaving w and h unchanged.
    x = (sw - w)/2
    y = (sh - h)/2
    top.geometry("%dx%d%+d%+d" % (w,h,x,y))
    
    return w,h,x,y</t>
<t tx="ekr.20031218072017.4063"># Returns frames w and f.
# Typically the caller would pack w into other frames, and pack content into f.

def create_labeled_frame (self,parent,
    caption=None,relief="groove",bd=2,padx=0,pady=0):

    # Create w, the master frame.
    w = Tk.Frame(parent)
    w.grid(sticky="news")
    
    # Configure w as a grid with 5 rows and columns.
    # The middle of this grid will contain f, the expandable content area.
    w.columnconfigure(1,minsize=bd)
    w.columnconfigure(2,minsize=padx)
    w.columnconfigure(3,weight=1)
    w.columnconfigure(4,minsize=padx)
    w.columnconfigure(5,minsize=bd)
    
    w.rowconfigure(1,minsize=bd)
    w.rowconfigure(2,minsize=pady)
    w.rowconfigure(3,weight=1)
    w.rowconfigure(4,minsize=pady)
    w.rowconfigure(5,minsize=bd)

    # Create the border spanning all rows and columns.
    border = Tk.Frame(w,bd=bd,relief=relief) # padx=padx,pady=pady)
    border.grid(row=1,column=1,rowspan=5,columnspan=5,sticky="news")
    
    # Create the content frame, f, in the center of the grid.
    f = Tk.Frame(w,bd=bd)
    f.grid(row=3,column=3,sticky="news")
    
    # Add the caption.
    if caption and len(caption) &gt; 0:
        caption = Tk.Label(parent,text=caption,highlightthickness=0,bd=0)
        caption.tkraise(w)
        caption.grid(in_=w,row=0,column=2,rowspan=2,columnspan=3,padx=4,sticky="w")

    return w,f</t>
<t tx="ekr.20031218072017.4064"></t>
<t tx="ekr.20031218072017.4065">def get_focus(self,c):
    
    """Returns the widget that has focus, or body if None."""

    return c.frame.top.focus_displayof()</t>
<t tx="ekr.20031218072017.4066"></t>
<t tx="ekr.20031218072017.4067"></t>
<t tx="ekr.20031218072017.4068">def attachLeoIcon (self,w):
    
    """Try to attach a Leo icon to the Leo Window.
    
    Use tk's wm_iconbitmap function if available (tk 8.3.4 or greater).
    Otherwise, try to use the Python Imaging Library and the tkIcon package."""

    if self.bitmap != None:
        # We don't need PIL or tkicon: this is tk 8.3.4 or greater.
        try:
            w.wm_iconbitmap(self.bitmap)
        except:
            self.bitmap = None
    
    if self.bitmap == None:
        try:
            &lt;&lt; try to use the PIL and tkIcon packages to draw the icon &gt;&gt;
        except:
            # import traceback ; traceback.print_exc()
            self.leoIcon = None</t>
<t tx="ekr.20031218072017.4069">@ This code requires Fredrik Lundh's PIL and tkIcon packages:

Download PIL    from http://www.pythonware.com/downloads/index.htm#pil
Download tkIcon from http://www.effbot.org/downloads/#tkIcon

Many thanks to Jonathan M. Gilligan for suggesting this code.
@c

import Image
import tkIcon

# Wait until the window has been drawn once before attaching the icon in OnVisiblity.
def visibilityCallback(event,self=self,w=w):
    __pychecker__ = '--no-argsused' # event not used.
    try: self.leoIcon.attach(w.winfo_id())
    except: pass
w.bind("&lt;Visibility&gt;",visibilityCallback)
if not self.leoIcon:
    # Load a 16 by 16 gif.  Using .gif rather than an .ico allows us to specify transparency.
    icon_file_name = g.os_path_join(g.app.loadDir,'..','Icons','LeoWin.gif')
    icon_file_name = g.os_path_normpath(icon_file_name)
    icon_image = Image.open(icon_file_name)
    if 1: # Doesn't resize.
        self.leoIcon = self.createLeoIcon(icon_image)
    else: # Assumes 64x64
        self.leoIcon = tkIcon.Icon(icon_image)</t>
<t tx="ekr.20031218072017.4070"># This code is adapted from tkIcon.__init__
# Unlike the tkIcon code, this code does _not_ resize the icon file.

def createLeoIcon (self,icon):
    
    try:
        import Image,_tkicon
        
        i = icon ; m = None
        # create transparency mask
        if i.mode == "P":
            try:
                t = i.info["transparency"]
                m = i.point(lambda i, t=t: i==t, "1")
            except KeyError: pass
        elif i.mode == "RGBA":
            # get transparency layer
            m = i.split()[3].point(lambda i: i == 0, "1")
        if not m:
            m = Image.new("1", i.size, 0) # opaque
        # clear unused parts of the original image
        i = i.convert("RGB")
        i.paste((0, 0, 0), (0, 0), m)
        # create icon
        m = m.tostring("raw", ("1", 0, 1))
        c = i.tostring("raw", ("BGRX", 0, -1))
        return _tkicon.new(i.size, c, m)
    except:
        return None</t>
<t tx="ekr.20031218072017.4071"></t>
<t tx="ekr.20031218072017.4072">def setIdleTimeHook (self,idleTimeHookHandler):

    if self.root:
        self.root.after_idle(idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4073">def setIdleTimeHookAfterDelay (self,idleTimeHookHandler):
    
    if self.root:
        g.app.root.after(g.app.idleTimeDelay,idleTimeHookHandler)</t>
<t tx="ekr.20031218072017.4074"></t>
<t tx="ekr.20031218072017.4075">def firstIndex (self):

    return "1.0"</t>
<t tx="ekr.20031218072017.4076">def lastIndex (self):

    return "end"</t>
<t tx="ekr.20031218072017.4077">def moveIndexBackward(self,index,n):

    return "%s-%dc" % (index,n)
</t>
<t tx="ekr.20031218072017.4078">def moveIndexForward(self,t,index,n):

    newpos = t.index("%s+%dc" % (index,n))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)
    
def moveIndexToNextLine(self,t,index):

    newpos = t.index("%s linestart + 1lines" % (index))
    
    return g.choose(t.compare(newpos,"==","end"),None,newpos)</t>
<t tx="ekr.20031218072017.4079">def compareIndices (self,t,n1,rel,n2):
    
    try:
        return t.compare(n1,rel,n2)
    except Exception:
        return False</t>
<t tx="ekr.20031218072017.4080">def getindex(self,text,index):
    
    """Convert string index of the form line.col into a tuple of two ints."""
    
    return tuple(map(int,string.split(text.index(index), ".")))</t>
<t tx="ekr.20031218072017.4081"></t>
<t tx="ekr.20031218072017.4082">def getInsertPoint(self,t):
    
    try:
        return t.index("insert")
    except Exception:
        return '1.0'</t>
<t tx="ekr.20031218072017.4083">def setInsertPoint (self,t,pos):

    try:
        t.mark_set("insert",pos)
    except Exception:
        pass</t>
<t tx="ekr.20031218072017.4084"></t>
<t tx="ekr.20031218072017.4085">def getSelectionRange (self,t):
    
    try:
        return t.tag_ranges("sel")
    except Exception:
        return 0,0</t>
<t tx="ekr.20031218072017.4086">def getTextSelection (self,t,sort=True):
    
    """Return a tuple representing the selected range of t, a Tk.Text widget.
    
    Return a tuple giving the insertion point if no range of text is selected."""

    # To get the current selection.
    try:
        sel = t.tag_ranges("sel")
    except Exception:
        return 0,0

    if len(sel) == 2:
        i,j = sel
        if sort:
            if t.compare(i, "&gt;", j):
                i,j = j,i
        return i,j
    else:
        # Return the insertion point if there is no selected text.
        insert = t.index("insert")
        return insert,insert</t>
<t tx="ekr.20031218072017.4088">def setSelectionRangeWithLength(self,t,start,length):
    
    return g.app.gui.setTextSelection(t,start,"%s+%dc" % (start,length))</t>
<t tx="ekr.20031218072017.4089">def setTextSelection (self,t,start,end,insert='sel.end'):
    
    """tk gui: set the selection range in Tk.Text widget t."""

    if not start or not end:
        return
        
    try:
        if t.compare(start, "&gt;", end):
            start,end = end,start
            
        t.tag_remove("sel","1.0",start)
        t.tag_add("sel",start,end)
        t.tag_remove("sel",end,"end")
        
        # New in 4.4a5: this logic ensures compatibility with previous code.
        if insert == 'sel.end':
            g.app.gui.setInsertPoint(t,end)
        elif insert is not None:
            g.app.gui.setInsertPoint(t,insert)
    except Exception:
        pass
    
setSelectionRange = setTextSelection</t>
<t tx="ekr.20031218072017.4090"></t>
<t tx="ekr.20031218072017.4091">def getAllText (self,t):
    
    """Return all the text of Tk.Text t converted to unicode."""

    s = t.get("1.0","end")
    if s is None:
        return u""
    else:
        return g.toUnicode(s,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4092">def getCharAfterIndex (self,t,index):
    
    if t.compare(index + "+1c","&gt;=","end"):
        return None
    else:
        ch = t.get(index + "+1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4093">def getCharAtIndex (self,t,index):
    ch = t.get(index)
    return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4094">def getCharBeforeIndex (self,t,index):
    
    index = t.index(index)
    if index == "1.0":
        return None
    else:
        ch = t.get(index + "-1c")
        return g.toUnicode(ch,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4095">def getLineContainingIndex (self,t,index):

    line = t.get(index + " linestart", index + " lineend")
    return g.toUnicode(line,g.app.tkEncoding)</t>
<t tx="ekr.20031218072017.4096">def replaceSelectionRangeWithText (self,t,start,end,text):

    t.delete(start,end)
    t.insert(start,text)</t>
<t tx="ekr.20031218072017.4097"></t>
<t tx="ekr.20031218072017.4098">def makeIndexVisible(self,t,index):

    return t.see(index)</t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 beta 1, build %s, January 17, 2006" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.400 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s, Pmw %s\n%s" % (n1,n2,n3,tkLevel,Pmw.version(),version))
    g.enl()</t>
<t tx="ekr.20040703054646">global lastTypesDict
typesDict = {}

for obj in gc.get_objects():
    n = typesDict.get(type(obj),0)
    t = type(obj)
    if t == 'instance':
        try: t = obj.__class__
        except: pass
    typesDict[t] = n + 1
    
# Create the union of all the keys.
keys = typesDict.keys()
for key in lastTypesDict.keys():
    if key not in keys:
        keys.append(key)

keys.sort()
for key in keys:
    n1 = lastTypesDict.get(key,0)
    n2 = typesDict.get(key,0)
    delta2 = n2-n1
    if delta2 != 0:
        g.es_print("%+6d =%7d %s" % (delta2,n2,key))
    
lastTypesDict = typesDict
typesDict = {}</t>
<t tx="ekr.20040703065638">import types
import inspect

global lastFunctionsDict

funcDict = {}

for obj in gc.get_objects():
    if type(obj) == types.FunctionType:
        key = repr(obj) # Don't create a pointer to the object!
        funcDict[key]=None 
        if not lastFunctionsDict.has_key(key):
            g.es_print(obj)
            args, varargs, varkw,defaults  = inspect.getargspec(obj)
            g.es_print("args", args)
            if varargs: g.es_print("varargs",varargs)
            if varkw: g.es_print("varkw",varkw)
            if defaults:
                g.es_print("defaults...")
                for s in defaults: g.es_print(s)

lastFunctionsDict = funcDict
funcDict = {}</t>
<t tx="ekr.20040709081208"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)</t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20040803072955.15"></t>
<t tx="ekr.20040803072955.16">def __init__(self,c,frame,canvas):
    
    # Init the base class.
    leoFrame.leoTree.__init__(self,frame)
    
    # Configuration and debugging settings.
    self.stayInTree             = c.config.getBool('stayInTreeAfterSelect')
    self.expanded_click_area    = c.config.getBool("expanded_click_area")
    self.trace_stats            = c.config.getBool('show_tree_stats')
    self.trace                  = c.config.getBool('trace_tree')
    self.trace_alloc            = c.config.getBool('trace_tree_alloc')
    self.trace_edit             = c.config.getBool('trace_tree_edit')
    self.trace_gc               = c.config.getBool('trace_gc')
    self.trace_redraw_now       = c.config.getBool('trace_redraw_now')

    # Objects associated with this tree.
    self.canvas = canvas
    
    &lt;&lt; define drawing constants &gt;&gt;
    &lt;&lt; old ivars &gt;&gt;
    &lt;&lt; inject callbacks into the position class &gt;&gt;
    
    self.dragging = False
    self.generation = 0
    self.prevPositions = 0
    self.redrawing = False # Used only to disable traces.
    self.redrawCount = 0 # Count for debugging.
    self.revertHeadline = None # Previous headline text for abortEditLabel.
    
    # New in 4.4: We should stay in the tree to use per-pane bindings.
    self.textBindings = [] # Set in setBindings.
    self.textNumber = 0 # To make names unique.
    self.updateCount = 0 # Drawing is enabled only if self.updateCount &lt;= 0
    self.verbose = True
    
    self.setEditPosition(None) # Set positions returned by leoTree.editPosition()
    
    # Keys are id's, values are positions...
    self.ids = {}
    self.iconIds = {}

    # Lists of visible (in-use) widgets...
    self.visibleBoxes = []
    self.visibleClickBoxes = []
    self.visibleIcons = []
    self.visibleLines = []
    self.visibleText  = {}
        # Pre 4.4b2: Keys are vnodes, values are Tk.Text widgets.
        #     4.4b2: Keys are p.key(), values are Tk.Text widgets.
    self.visibleUserIcons = []

    # Lists of free, hidden widgets...
    self.freeBoxes = []
    self.freeClickBoxes = []
    self.freeIcons = []
    self.freeLines = []
    self.freeText = [] # New in 4.4b2: a list of free Tk.Text widgets
   
    self.freeUserIcons = []</t>
<t tx="ekr.20040803072955.17">self.box_padding = 5 # extra padding between box and icon
self.box_width = 9 + self.box_padding
self.icon_width = 20
self.text_indent = 4 # extra padding between icon and tex

self.hline_y = 7 # Vertical offset of horizontal line
self.root_left = 7 + self.box_width
self.root_top = 2

self.default_line_height = 17 + 2 # default if can't set line_height from font.
self.line_height = self.default_line_height</t>
<t tx="ekr.20040803072955.18"># Miscellaneous info.
self.iconimages = {} # Image cache set by getIconImage().
self.active = False # True if tree is active
self._editPosition = None # Returned by leoTree.editPosition()
self.lineyoffset = 0 # y offset for this headline.
self.lastClickFrameId = None # id of last entered clickBox.
self.lastColoredText = None # last colored text widget.

# Set self.font and self.fontName.
self.setFontFromConfig()
self.setColorFromConfig()

# Drag and drop
self.drag_p = None
self.controlDrag = False # True: control was down when drag started.

# Keep track of popup menu so we can handle behavior better on Linux Context menu
self.popupMenu = None

# Incremental redraws:
self.allocateOnlyVisibleNodes = False # True: enable incremental redraws.
self.prevMoveToFrac = None
self.visibleArea = None
self.expandedVisibleArea = None

if self.allocateOnlyVisibleNodes:
    self.frame.bar1.bind("&lt;B1-ButtonRelease&gt;", self.redraw_now)</t>
<t tx="ekr.20040803072955.19"># The new code injects 3 callbacks for the colorizer.

if not leoTkinterTree.callbacksInjected: # Class var.
    leoTkinterTree.callbacksInjected = True
    self.injectCallbacks()</t>
<t tx="ekr.20040803072955.21">def injectCallbacks(self):
    
    &lt;&lt; define tkinter callbacks to be injected in the position class &gt;&gt;

    for f in (OnHyperLinkControlClick,OnHyperLinkEnter,OnHyperLinkLeave):
        
        g.funcToMethod(f,leoNodes.position)</t>
<t tx="ekr.20040803072955.22"># N.B. These vnode methods are entitled to know about details of the leoTkinterTree class.

@others

</t>
<t tx="ekr.20040803072955.23">def OnHyperLinkControlClick (self,event):
    
    """Callback injected into position class."""
    
    p = self ; c = p.c
    try:
        if not g.doHook("hypercclick1",c=c,p=p,v=p,event=event):
            c.beginUpdate()
            try:
                c.selectPosition(p)
            finally:
                c.endUpdate()
            c.frame.bodyCtrl.mark_set("insert","1.0")
        g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hypercclick")</t>
<t tx="ekr.20040803072955.24">def OnHyperLinkEnter (self,event=None):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperenter1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="green")
        g.doHook("hyperenter2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperenter")</t>
<t tx="ekr.20040803072955.25">def OnHyperLinkLeave (self,event=None):
    
    """Callback injected into position class."""

    try:
        p = self ; c = p.c
        if not g.doHook("hyperleave1",c=c,p=p,v=p,event=event):
            if 0: # This works, and isn't very useful.
                c.frame.bodyCtrl.tag_config(p.tagName,background="white")
        g.doHook("hyperleave2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("hyperleave")</t>
<t tx="ekr.20040803072955.58"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

# New in 4.4b2: suppress scrolling by default.

def redraw_now (self,scroll=False):

    if g.app.quitting or self.drag_p or self.frame not in g.app.windowList:
        return
        
    c = self.c ;  self.redrawCount += 1
    
    if not g.app.unitTesting:
        if self.trace_gc:
            if (self.redrawCount % 5) == 0:
                g.printGcSummary(trace=True)
        if self.trace_redraw_now or self.trace_alloc:
            g.trace(self.redrawCount,g.callers())
            if self.trace_stats:
                g.print_stats()
                g.clear_stats()
                
    # New in 4.4b2: Call endEditLabel, but suppress the redraw.
    self.beginUpdate()
    try:
        self.endEditLabel()
    finally:
        self.endUpdate(False)

    # Do the actual redraw.
    self.expandAllAncestors(c.currentPosition())
    self.redrawHelper(scroll=scroll)
    self.canvas.update_idletasks() # Important for unit tests.
    c.masterFocusHandler()
    
redraw = redraw_now # Compatibility</t>
<t tx="ekr.20040803072955.59">def redrawHelper (self,scroll=True):
    
    c = self.c
    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        if scroll:
            self.canvas.update_idletasks() # Essential.
            self.scrollTo()
            
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20040803072955.71"></t>
<t tx="ekr.20040803072955.72">def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True</t>
<t tx="ekr.20040803072955.73">def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t</t>
<t tx="ekr.20040803072955.74">def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId:
            g.es_print('oops: eventToPosition failed')
            return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None</t>
<t tx="ekr.20040803072955.75">def edit_widget (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)
    
edit_text = edit_widget # For compatibility.</t>
<t tx="ekr.20040803072955.76">def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c

    if p and c:
        aTuple = self.visibleText.get(p.key())
        if aTuple:
            t,theId = aTuple
            # if self.trace: g.trace('%4d' % (theId),self.textAddr(t),p.headString())
            return t
        else:
            # g.trace('oops: not found',p)
            return None

    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20040803072955.78"></t>
<t tx="ekr.20040803072955.79">def onClickBoxClick (self,event):
    
    c = self.c ; p1 = c.currentPosition()
    c.setLog()
    p = self.eventToPosition(event)

    c.beginUpdate()
    try:
        if p and not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
            c.endEditing()
            self.active = True
            if p == p1 or c.config.getBool('initialClickExpandsOrContractsNode'):
                if p.isExpanded(): p.contract()
                else:              p.expand()
            self.select(p)
            if c.frame.findPanel:
                c.frame.findPanel.handleUserClick(p)
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
        g.doHook("boxclick2",c=c,p=p,v=p,event=event)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20040803072955.80"></t>
<t tx="ekr.20040803072955.81">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.endEditLabel()
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040803072955.82">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    c.setLog()
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.endEditLabel() # Bug fix: 11/30/05
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20040803072955.83">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'
        
    c.setLog()

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    # 'continue' *is* correct here.
    # 'break' would make it impossible to unselect the headline text.
    return 'continue'
</t>
<t tx="ekr.20040803072955.84"></t>
<t tx="ekr.20040803072955.85">def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setEditLabelState(p) # selected, editing.
        else:
            self.setSelectedLabelState(p) # selected, not editing.
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20040803072955.86"># This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20040803072955.87">def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget

    try:
        p = w.leo_position
    except AttributeError:
        g.trace('*'*20,'oops')
        return 'break'
        
    # g.trace(p.headString())
    
    c.setLog()

    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            returnVal = self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        returnVal = 'break'
        g.es_event_exception("headclick")

    # 'continue' is sometimes correct here.
    # 'break' would make it impossible to unselect the headline text.
    # g.trace('returnVal',returnVal,'stayInTree',self.stayInTree)
    return returnVal</t>
<t tx="ekr.20040803072955.88">def onHeadlineKey (self,event):
    
    '''Handle a key event in a headline.'''

    w = event and event.widget or None
    ch = event and event.char or ''
    
    # g.trace(g.callers())

    # Testing for ch here prevents flashing in the headline
    # when the control key is held down.
    if ch:
        # g.trace(repr(ch),g.callers())
        self.updateHead(event,w)

    return 'break' # Required
</t>
<t tx="ekr.20040803072955.89">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p:
        g.trace('*'*20,'oops')
        return
    
    c.setLog()

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return 'break'
</t>
<t tx="ekr.20040803072955.90"></t>
<t tx="ekr.20040803072955.91"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = self.edit_widget(p)
    if not w: return
    
    ch = '\r' # New in 4.4: we only report the final keystroke.
    if g.doHook("headkey1",c=c,p=p,v=p,ch=ch):
        return # The hook claims to have handled the event.

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    c.beginUpdate()
    try:
        # Make the change official, but undo to the *old* revert point.
        oldRevert = self.revertHeadline
        changed = s != oldRevert
        self.revertHeadline = s
        p.initHeadString(s)
        if self.trace_edit and not g.app.unitTesting:
            if changed:
                g.trace('changed: old',repr(oldRevert),'new',repr(s))
        if changed:
            undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)
            if not c.changed: c.setChanged(True)
            dirtyVnodeList = p.setDirty()
            u.afterChangeNodeContents(p,undoType,undoData,
                dirtyVnodeList=dirtyVnodeList)
    finally:
        c.endUpdate()
        if changed:
            if self.stayInTree:
                c.treeWantsFocus()
            else:
                c.bodyWantsFocus()
   
    g.doHook("headkey2",c=c,p=p,v=p,ch=ch)
</t>
<t tx="ekr.20040803072955.94"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20040803072955.99"></t>
<t tx="ekr.20040803072955.100">def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20040803072955.101"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.</t>
<t tx="ekr.20040803072955.102">def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return

    c.setLog()
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20040803072955.103">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    c = self.c ; p = self.drag_p
    if not p: return

    c.setLog()
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20040803072955.104">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20040803072955.105">def OnActivateHeadline (self,p,event=None):
    
    '''Handle common process when any part of a headline is clicked.'''
    
    # g.trace(p.headString())
    
    returnVal = 'break' # Default: do nothing more.

    try:
        c = self.c
        c.setLog()
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")
        
    return returnVal</t>
<t tx="ekr.20040803072955.106">if p == c.currentPosition():
    # g.trace("is current")
    # The *second* click in the headline starts editing.
    if self.active:
        self.editLabel(p)
        returnVal = 'continue'
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.treeWantsFocusNow()
        returnVal = 'break'
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.treeWantsFocusNow()
    else:
        c.bodyWantsFocusNow()
    returnVal = 'break'

# The next click *in the same headline* will start editing.
self.active = True</t>
<t tx="ekr.20040803072955.108">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    
    # g.trace(g.callers())
   
    c.beginUpdate()
    try:
        tree.endEditLabel()
        tree.dimEditLabel()
    finally:
        c.endUpdate(False)</t>
<t tx="ekr.20040803072955.109">def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None</t>
<t tx="ekr.20040803072955.110">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        c.setLog()

        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20040803072955.111">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()</t>
<t tx="ekr.20040803072955.112">def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)</t>
<t tx="ekr.20040803072955.113">table = (
    ("&amp;Read @file Nodes",c.readAtFileNodes),
    ("&amp;Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&amp;Tangle",c.tangle),
    ("&amp;Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &amp;Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&amp;Paste Node",c.pasteOutline),
    ("&amp;Delete Node",c.deleteOutline),
    ("-",None),
    ("&amp;Insert Node",c.insertHeadline),
    ("&amp;Clone Node",c.clone),
    ("Sort C&amp;hildren",c.sortChildren),
    ("&amp;Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)</t>
<t tx="ekr.20040803072955.114">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20040803072955.115">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20040803072955.116">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.widgetWantsFocus(menu)</t>
<t tx="ekr.20040803072955.127">def editLabel (self,p):
    
    """Start editing p's headline."""
    
    c = self.c

    if self.editPosition() and p != self.editPosition():
        c.beginUpdate()
        try:
            self.endEditLabel()
        finally:
            c.endUpdate(False)

    self.setEditPosition(p) # That is, self._editPosition = p
    
    if self.trace_edit and not g.app.unitTesting:
        g.trace(p.headString(),g.choose(p.edit_widget(),'','no edit widget'))

    if p and p.edit_widget():
        self.revertHeadline = p.headString() # New in 4.4b2: helps undo.
        self.setEditLabelState(p) # Sets the focus immediately.
        c.headlineWantsFocus(p) # Make sure the focus sticks.</t>
<t tx="ekr.20040803072955.135">def setEditLabelState (self,p): # selected, editing

    c = self.c ; w = p.edit_widget()

    if p and w:
        c.widgetWantsFocusNow(w)
        self.setEditHeadlineColors(p)
        w.tag_remove("sel","1.0","end")
        w.tag_add("sel","1.0","end")
    else:
        g.trace('no edit_widget')
        
setNormalLabelState = setEditLabelState # For compatibility.</t>
<t tx="ekr.20041111114148"># g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)</t>
<t tx="ekr.20041111114944"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    c.setLog()
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    # g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"</t>
<t tx="ekr.20041111115908">def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""

    c = self.c ; p = self.drag_p
    c.setLog()
    canvas = self.canvas
    if not event: return

    c.beginUpdate()
    try:
        &lt;&lt; set vdrag, childFlag &gt;&gt;
        if c.config.getBool("allow_clone_drags"):
            if not c.config.getBool("look_for_control_drag_on_mouse_down"):
                self.controlDrag = c.frame.controlKeyIsDown
    
        if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
            &lt;&lt; drag p to vdrag &gt;&gt;
        elif self.trace and self.verbose:
            g.trace("Cancel drag")
        
        # Reset the old cursor by brute force.
        self.canvas['cursor'] = "arrow"
        self.dragging = False
        self.drag_p = None
    finally:
        # Must set self.drag_p = None first.
        c.endUpdate()
        c.recolor_now() # Dragging can affect coloring.</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041217135735.2">def setColorFromConfig (self):
    
    c = self.c
    
    bg = c.config.getColor("log_pane_background_color") or 'white'
    
    try:
        self.logCtrl.configure(bg=bg)
    except:
        g.es("exception setting log pane background color")
        g.es_exception()</t>
<t tx="ekr.20041221071131">def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas</t>
<t tx="ekr.20041221071131.1">def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")
        
    # g.trace('canvas',repr(canvas),'name',frame.c.widget_name(canvas))

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 0:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20041221073427">def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame</t>
<t tx="ekr.20041221073427.1">def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2</t>
<t tx="ekr.20041221075743">@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)</t>
<t tx="ekr.20041221122440">def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()</t>
<t tx="ekr.20041221123325">def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        &lt;&lt; create Pmw splitters and their components &gt;&gt;
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="ekr.20041221185246">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.</t>
<t tx="ekr.20041221195402"></t>
<t tx="ekr.20041222043017">def restoreAllState (self,d):
    
    '''Restore the log from a dict created by saveAllState.'''
    
    logCtrl = self.logCtrl

    # Restore the text.
    text = d.get('text')
    logCtrl.insert('end',text)

    # Restore all colors.
    colors = d.get('colors')
    for color in colors.keys():
        if color not in self.colorTags:
            self.colorTags.append(color)
            logCtrl.tag_config(color,foreground=color)
        items = list(colors.get(color))
        while items:
            start,stop = items[0],items[1]
            items = items[2:]
            logCtrl.tag_add(color,start,stop)</t>
<t tx="ekr.20041222043017.1">def saveAllState (self):
    
    '''Return a dict containing all data needed to recreate the log in another widget.'''
    
    logCtrl = self.logCtrl ; colors = {}

    # Save the text
    text = logCtrl.get('1.0','end')

    # Save color tags.
    tag_names = logCtrl.tag_names()
    for tag in tag_names:
        if tag in self.colorTags:
            colors[tag] = logCtrl.tag_ranges(tag)
            
    d = {'text':text,'colors': colors}
    # g.trace('\n',g.dictToString(d))
    return d</t>
<t tx="ekr.20041223130032"># Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20050104084531">self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))</t>
<t tx="ekr.20050119210541"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)</t>
<t tx="ekr.20050120092028">def bodyWantsFocus(self):
    c = self ; body = c.frame.body
    c.request_focus(body and body.bodyCtrl)
    
def bodyWantsFocusNow(self):
    c = self ; body = c.frame.body
    c.set_focus(body and body.bodyCtrl)
        
def headlineWantsFocus(self,p):
    c = self
    c.request_focus(p and p.edit_widget())
    
def headlineWantsFocusNow(self,p):
    c = self
    c.set_focus(p and p.edit_widget())
    
def logWantsFocus(self):
    c = self ; log = c.frame.log
    c.request_focus(log and log.logCtrl)
    
def logWantsFocusNow(self):
    c = self ; log = c.frame.log
    c.set_focus(log and log.logCtrl)

def minibufferWantsFocus(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocus()
    
def minibufferWantsFocusNow(self):
    c = self ; k = c.k
    k and k.minibufferWantsFocusNow()

def treeWantsFocus(self):
    c = self ; tree = c.frame.tree
    c.request_focus(tree and tree.canvas)
    
def treeWantsFocusNow(self):
    c = self ; tree = c.frame.tree
    c.set_focus(tree and tree.canvas)
    
def widgetWantsFocus(self,w):
    c = self ; c.request_focus(w)
    
def widgetWantsFocusNow(self,w):
    c = self ; c.set_focus(w)
</t>
<t tx="ekr.20050208133438">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.logCtrl.update_idletasks()</t>
<t tx="ekr.20050318085432.7">def redoNodeContents (self):
    
    u = self ; c = u.c
    
    u.p.setTnodeText(u.newBody)
    u.p.initHeadString(u.newHead)
    c.frame.tree.setHeadline(u.p,u.newHead) # New in 4.4b2.
    
    # g.trace('newHead',u.newHead,'revert',c.frame.tree.revertHeadline)
    
    if u.groupCount == 0 and u.newSel:
        u.c.frame.body.setTextSelection(u.newSel)
    
    u.updateMarks('new')
    
    for v in u.dirtyVnodeList:
        v.t.setDirty()</t>
<t tx="ekr.20050318085713.1">def undoNodeContents (self):
    
    '''Undo all changes to the contents of a node,
    including headline and body text, and dirty and marked bits.
    '''
    
    u = self ; c = u.c
    
    u.p.setTnodeText(u.oldBody)
    u.p.initHeadString(u.oldHead)
    c.frame.tree.setHeadline(u.p,u.oldHead) # New in 4.4b2.

    if u.groupCount == 0 and u.oldSel:
        u.c.frame.body.setTextSelection(u.oldSel)
    
    u.updateMarks('old')
    
    for v in u.dirtyVnodeList:
        v.t.clearDirty()</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050707085637">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3237845
By: eichin

Finally, one comment from the talk that bothered me for a while and didn't click
until later - "emacs doesn't really have an outline mode".  This is true, at
face value - outline mode in fact is just some regexp and hiding kludging, powerful
in it's own way but not "deep".  However, the operations felt familiar, and
it wasn't until I went home and checked mail that I caught it -- *GNUS* is actually
surprisingly close in function set to an outliner.  Not in any immediately useful
way, but it both clarifies why I think emacs could work this way *and* possibly
clarifies why gnus users are so engaged by the interface :-)  Though that does
mean gnus might be a reasonable source of suggestions for key bindings...</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050920084036.113">def replaceString (self,event):

    k = self.k ; state = k.getState('replace-string')
    pattern_match = self.getOption ('pattern_match')
    prompt = 'Replace ' + g.choose(pattern_match,'Regex','String')

    if state == 0:
        self.widget = event.widget
        s = '%s: ' % prompt
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',1,self.replaceString)
    elif state == 1:
        self._sString = k.arg
        s = '%s: %s With: ' % (prompt,self._sString)
        k.setLabelBlue(s,protect=True)
        k.getArg(event,'replace-string',2,self.replaceString)
    elif state == 2:
        k.clearState()
        if 1: # Use the legacy find command.
            k.clearState()
            k.resetLabel()
            k.showStateAndMode()
            self.generalChangeHelper(self._sString,k.arg)
        else:
            self._rpString = k.arg ; w = self.widget
            &lt;&lt; do the replace &gt;&gt;
            k.setLabelGrey('Replaced %s occurance%s' % (count,g.choose(count==1,'','s')))
            self._useRegex = False</t>
<t tx="ekr.20050920084036.114"># g.es('%s %s by %s' % (prompt,repr(self._sString),repr(self._rpString)),color='blue')
i = 'insert' ; end = 'end' ; count = 0
if w.tag_ranges('sel'):
    i = w.index('sel.first')
    end = w.index('sel.last')
if self._useRegex:
    txt = w.get(i,end)
    try:
        pattern = re.compile(self._sString)
    except:
        k.keyboardQuit(event)
        k.setLabel("Illegal regular expression")
        return
    count = len(pattern.findall(txt))
    if count:
        ntxt = pattern.sub(self._rpString,txt)
        w.delete(i,end)
        w.insert(i,ntxt)
else:
    # Problem: adds newline at end of text.
    txt = w.get(i,end)
    count = txt.count(self._sString)
    if count:
        ntxt = txt.replace(self._sString,self._rpString)
        w.delete(i,end)
        w.insert(i,ntxt)</t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    self.minibufferFindHandler = None
    
    # The last kind of search
    
    # self.forward = True
    # self.incremental = True
    # self.regexp = False
    # self.word = True
    #self.searchString = ''
    #self.replaceString = '' # Not used yet.
    
    try:
        self.w = c.frame.body.bodyCtrl
    except AttributeError:
        self.w = None</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):
    
    return {
        'clone-find-all':                       self.cloneFindAll,
        
        'find-tab-find':                        self.findTabFindNext,
        'find-tab-find-prev':                   self.findTabFindPrev,
        'find-tab-change':                      self.findTabChange,
        'find-tab-change-all':                  self.findTabChangeAll,
        'find-tab-change-then-find':            self.findTabChangeThenFind,
                    
        'hide-find-tab':                        self.hideFindTab,
            
        'isearch-forward':                      self.isearchForward,
        'isearch-backward':                     self.isearchBackward,
        'isearch-forward-regexp':               self.isearchForwardRegexp,
        'isearch-backward-regexp':              self.isearchBackwardRegexp,
                    
        'open-find-tab':                        self.openFindTab,
    
        'replace-string':                       self.replaceString,
                    
        're-search-forward':                    self.reSearchForward,
        're-search-backward':                   self.reSearchBackward,

        'search-again':                         self.findAgain,
        # Uses existing search pattern.
        
        'search-forward':                       self.searchForward,
        'search-backward':                      self.searchBackward,
        'search-with-present-options':          self.searchWithPresentOptions,
        # Prompts for search pattern.

        'set-find-everywhere':                  self.setFindScopeEveryWhere,
        'set-find-node-only':                   self.setFindScopeNodeOnly,
        'set-find-suboutline-only':             self.setFindScopeSuboutlineOnly,
        
        'show-find-options':                    self.showFindOptions,

        'toggle-find-ignore-case-option':       self.toggleIgnoreCaseOption,
        'toggle-find-in-body-option':           self.toggleSearchBodyOption,
        'toggle-find-in-headline-option':       self.toggleSearchHeadlineOption,
        'toggle-find-mark-changes-option':      self.toggleMarkChangesOption,
        'toggle-find-mark-finds-option':        self.toggleMarkFindsOption,
        'toggle-find-regex-option':             self.toggleRegexOption,
        'toggle-find-reverse-option':           self.toggleReverseOption,
        'toggle-find-word-option':              self.toggleWholeWordOption,
        'toggle-find-wrap-around-option':       self.toggleWrapSearchOption,
        
        'word-search-forward':                  self.wordSearchForward,
        'word-search-backward':                 self.wordSearchBackward,
    }</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,regexp):

    c = self.c ; k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)
    c.minibufferWantsFocus()</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = self.w
    pattern = k.getLabel(ignorePrompt=True)
    if not pattern: return
    
    self.searchString = pattern
    self.incremental = True
    self.forward = forward
    self.regexp = regexp
   
    try:
        i = None
        if forward:
            i = w.search(pattern,"insert + 1c",stopindex='end',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the top of the buffer.
                    i = w.search(pattern,'1.0',stopindex='insert',regexp=regexp)
        else:
            i = w.search(pattern,'insert',backwards=True,stopindex='1.0',regexp=regexp)
            if 0: # Not so useful when searches can cross buffer boundaries.
                if not i: # Start again at the bottom of the buffer.
                    i = w.search(pattern,'end',backwards=True,stopindex='insert',regexp=regexp)
    except: pass
        
    # Don't call endSearch here.  We'll do that when the user hits return.
    if i and not i.isspace():
        w.mark_set('insert',i)
        w.see('insert')</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    c = self.c ; k = self.k ; w = self.w
    
    if not event:
        g.trace('no event',g.callers())
        return
    keysym = event.keysym
    ch = event.char
    if keysym == 'Control_L': return
    
    c.bodyWantsFocus()
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        s = self.searchString
        i = w.index('insert')
        j = w.index('insert +%sc' % len(s))
        if not self.forward: i,j = j,i
        self.endSearch(i,j)
        return

    if ch == '\b':
        g.trace('backspace not handled yet')
        return
    
    if ch:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        i = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if i:
            self.searchString = s
        else:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event):

    k = self.k ; w = self.w

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d

    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20050920085536.1"></t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.
    
    Important: this is the last step in the startup process.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands',c.fileName()) # g.callers())
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = c.k = k = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    if g.app.config and g.app.config.inited:
        # A 'real' .leo file.
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        k.finishCreate()
    else:
        # A leoSettings.leo file.
        c.commandsDict = {}

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)
        
    c.bodyWantsFocusNow()</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
    
    # g.trace('keyHandler')
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()

    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20050923213858">self.abbreviationsDict = {} # Abbreviations created by @alias nodes.

# Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are lists of g.bunch(pane,func,commandName)
# Previously defined binding tags.
self.bindtagsDict = {}
    # Keys are strings (the tag), values are 'True'
    
self.masterBindingsDict = {}
    # keys are scope names: 'all','text',etc. or mode names.
    # Values are dicts: keys are strokes, values are g.bunch(commandName,func,pane,stroke)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

self.abortAllModesKey = None
self.fullCommandKey = None
self.universalArgKey = None

# Keepting track of the characters in the mini-buffer.
self.arg_completion = True
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []
self.stroke = None

# For onIdleTime
self.idleCount = 0

# For modes
self.afterGetArgState = None
self.argTabList = []
self.modeBindingsDict = {}</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None # The name of the command being executed.
self.funcReturn = None # For k.simulateCommand
self.inputModeBindings = {}
self.inputModeName = '' # The name of the input mode, or None.
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)
self.setDefaultUnboundKeyAction()</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict.
    
    c.commandsDict:        keys are command names, values are funcions f.
    k.inverseCommandsDict: keys are f.__name__, values are minibuffer command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        try:
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))
                
        except Exception:
            g.es_exception()
            g.trace(repr(name),repr(f),g.callers())</t>
<t tx="ekr.20051009044751">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    if 0:
        f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
        f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)
        f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
        f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)</t>
<t tx="ekr.20051009044920"># Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()</t>
<t tx="ekr.20051009045208">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()</t>
<t tx="ekr.20051009045300"># Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(c,v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()
    c.editPosition(p)</t>
<t tx="ekr.20051016095907"></t>
<t tx="ekr.20051016095907.1"></t>
<t tx="ekr.20051016095907.2"></t>
<t tx="ekr.20051016101724.1">def selectTab (self,tabName):

    '''Create the tab if necessary and make it active.'''

    c = self.c ; tabFrame = self.frameDict.get(tabName)

    if tabFrame:
        # Switch to a new colorTags list.
        newColorTags = self.colorTagsDict.get(tabName)
        self.colorTagsDict [self.tabName] = self.colorTags [:]
        self.colorTags = newColorTags
    else:
        self.createTab(tabName)
        
    self.nb.selectpage(tabName)
    # Update the status vars.
    self.tabName = tabName
    self.logCtrl = self.textDict.get(tabName)
    self.tabFrame = self.frameDict.get(tabName)

    return tabFrame</t>
<t tx="ekr.20051016101927">@ Printing uses self.logCtrl, so this code need not concern itself
with which tab is active.

Also, selectTab switches the contents of colorTags, so that is not concern.
It may be that Pmw will allow us to dispense with the colorTags logic...</t>
<t tx="ekr.20051016101927.1">def putnl (self,tabName='Log'):

    if g.app.quitting:
        return
    if tabName:
        self.selectTab(tabName)
    
    if self.logCtrl:
        self.logCtrl.insert("end",'\n')
        self.logCtrl.see("end")
        self.forceLogUpdate('\n')
    else:
        # Put a newline to logWaiting and print newline
        g.app.logWaiting.append(('\n',"black"),)
        print "Null tkinter log"
        print
</t>
<t tx="ekr.20051016103459">def createTextWidget (self,parentFrame):
    
    self.logNumber += 1
    log = Tk.Text(parentFrame,name="log-%d" % self.logNumber,
        setgrid=0,wrap=self.wrap,bd=2,bg="white",relief="flat")
    
    logBar = Tk.Scrollbar(parentFrame,name="logBar")

    log['yscrollcommand'] = logBar.set
    logBar['command'] = log.yview
    
    logBar.pack(side="right", fill="y")
    # rr 8/14/02 added horizontal elevator 
    if self.wrap == "none": 
        logXBar = Tk.Scrollbar( 
            parentFrame,name='logXBar',orient="horizontal") 
        log['xscrollcommand'] = logXBar.set 
        logXBar['command'] = log.xview 
        logXBar.pack(side="bottom", fill="x")
    log.pack(expand=1, fill="both")

    return log</t>
<t tx="ekr.20051017212057">def clearTab (self,tabName):
    
    self.selectTab(tabName)
    t = self.logCtrl
    t and t.delete('1.0','end')</t>
<t tx="ekr.20051018061932"></t>
<t tx="ekr.20051018061932.1">def lowerTab (self,tabName):
    
    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='grey80')
    self.c.bodyWantsFocus()

def raiseTab (self,tabName):

    if tabName:
        b = self.nb.tab(tabName) # b is a Tk.Button.
        b.config(bg='LightSteelBlue1')
    self.c.bodyWantsFocus()</t>
<t tx="ekr.20051018072306">t = self.createTextWidget(tabFrame)

# Set the background color.
configName = 'log_pane_%s_tab_background_color' % tabName
bg = c.config.getColor(configName) or 'MistyRose1'
try: t.configure(bg=bg)
except Exception: pass # Could be a user error.

self.SetWidgetFontFromConfig(logCtrl=t)

self.frameDict [tabName] = tabFrame
self.textDict [tabName] = t

# Switch to a new colorTags list.
if self.tabName:
    self.colorTagsDict [self.tabName] = self.colorTags [:]

self.colorTags = ['black']
self.colorTagsDict [tabName] = self.colorTags</t>
<t tx="ekr.20051018102027">def deleteTab (self,tabName):
    
    if tabName == 'Log':
        pass

    elif tabName in ('Find','Spell'):
        self.selectTab('Log')
    
    elif tabName in self.nb.pagenames():
        self.nb.delete(tabName)
        self.colorTagsDict [tabName] = []
        self.textDict [tabName] = None
        self.frameDict [tabName] = None
        self.tabName = None
        self.selectTab('Log')
        
    # New in Leo 4.4b1.
    self.c.bodyWantsFocus()</t>
<t tx="ekr.20051019134106"></t>
<t tx="ekr.20051019134106.1">def makeTabMenu (self,tabName=None):

    '''Create a tab popup menu.'''

    c = self.c
    hull = self.nb.component('hull') # A Tk.Canvas.
    
    menu = Tk.Menu(hull,tearoff=0)
    menu.add_command(label='New Tab',command=self.newTabFromMenu)
    
    if tabName:
        # Important: tabName is the name when the tab is created.
        # It is not affected by renaming, so we don't have to keep
        # track of the correspondence between this name and what is in the label.
        def deleteTabCallback():
            self.deleteTab(tabName)
            
        label = g.choose(
            tabName in ('Find','Spell'),'Hide This Tab','Delete This Tab')
        menu.add_command(label=label,command=deleteTabCallback)
 
        def renameTabCallback():
            self.renameTabFromMenu(tabName)

        menu.add_command(label='Rename This Tab',command=renameTabCallback)

    return menu</t>
<t tx="ekr.20051019134422">def onRightClick (self,event,menu):
    
    c = self.c
    menu.post(event.x_root,event.y_root)
    
    
def onClick (self,event,tabName):

    self.selectTab(tabName)</t>
<t tx="ekr.20051019140004.1">def newTabFromMenu (self,tabName='Log'):

    self.selectTab(tabName)
    
    # This is called by getTabName.
    def selectTabCallback (newName):
        self.selectTab(newName)

    self.getTabName(selectTabCallback)</t>
<t tx="ekr.20051019165401">def renameTabFromMenu (self,tabName):

    if tabName in ('Log','Completions'):
        g.es('can not rename %s tab' % (tabName),color='blue')
    else:
        def renameTabCallback (newName):
            self.renameTab(tabName,newName)

        self.getTabName(renameTabCallback)</t>
<t tx="ekr.20051019170806">def renameTab (self,oldName,newName):
    
    label = self.nb.tab(oldName)
    label.configure(text=newName)</t>
<t tx="ekr.20051019172811">def getTabName (self,exitCallback):
    
    canvas = self.nb.component('hull')

    # Overlay what is there!
    f = Tk.Frame(canvas)
    f.pack(side='top',fill='both',expand=1)
    
    row1 = Tk.Frame(f)
    row1.pack(side='top',expand=0,fill='x',pady=10)
    row2 = Tk.Frame(f)
    row2.pack(side='top',expand=0,fill='x')

    Tk.Label(row1,text='Tab name').pack(side='left')

    e = Tk.Entry(row1,background='white')
    e.pack(side='left')

    def getNameCallback (event=None):
        s = e.get().strip()
        f.pack_forget()
        if s: exitCallback(s)
        
    def closeTabNameCallback (event=None):
        f.pack_forget()
        
    b = Tk.Button(row2,text='Ok',width=6,command=getNameCallback)
    b.pack(side='left',padx=10)
    
    b = Tk.Button(row2,text='Cancel',width=6,command=closeTabNameCallback)
    b.pack(side='left')

    e.focus_force()
    e.bind('&lt;Return&gt;',getNameCallback)</t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None,show=True):

    c = self.c ; log = c.frame.log ; tabName = 'Find'
    
    wasOpen = log.frameDict.get(tabName)

    if wasOpen:
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)

    if show or wasOpen or c.config.getBool('minibufferSearchesShowFindTab'):
        pass # self.findTabHandler.bringToFront()
    else:
        log.hideTab(tabName)</t>
<t tx="ekr.20051020120306.1">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020120306.2">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020120306.3">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020120306.4">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)</t>
<t tx="ekr.20051020120306.5"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind.leoFind):
    
    '''An adapter class that implements Leo's Find tab.'''

    @others</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):
    
    # g.trace('findTab')

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    self.frame = self.outerFrame = self.top = None
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    self.optionsOnly = c.config.getBool('show_only_find_tab_options')
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 
    self.outerScrolledFrame = None

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020120306.12">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    # g.trace('findTab')
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    
    if  self.optionsOnly:
        buttons = []
    else:
        &lt;&lt; Create two columns of buttons &gt;&gt;
    
    # Pack this last so buttons don't get squashed when frame is resized.
    self.outerScrolledFrame.pack(side='top',expand=1,fill='both',padx=2,pady=2)
    
    if 0: # These dont work in the new binding scheme.  Use shortcuts or mode bindings instead.
        for w in buttons:
            w.bindHotKey(ftxt)
            w.bindHotKey(ctxt)</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.top.pack(side='top',expand=0,fill='both',pady=5)
    # Don't expand, so the frame goes to the top.

self.outerScrolledFrame = Pmw.ScrolledFrame(
    parentFrame,usehullsize = 1)

self.outerFrame = outer = self.outerScrolledFrame.component('frame')
self.outerFrame.configure(background=bg)

for z in ('borderframe','clipper','frame','hull'):
    self.outerScrolledFrame.component(z).configure(relief='flat',background=bg)</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

if self.optionsOnly:
    # Use one-line boxes.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=1,width=25,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=1,width=25,name='change-text')
else:
    # Use bigger boxes for scripts.
    self.find_ctrl = ftxt = Tk.Text(
        fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
    self.change_ctrl = ctxt = Tk.Text(
        cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")
        
if self.optionsOnly:
    flab.pack(side="left") ; ftxt.pack(side="left")
    clab.pack(side="left") ; ctxt.pack(side="left")
else:
    flab.pack(side="left") ; ftxt.pack(side="right", expand=1, fill="x")
    clab.pack(side="left") ; ctxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    c = self.c
    c.widgetWantsFocus(w)
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.

radioLists[0] = []

checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole &amp;Word", self.dict["whole_word"]),
    ("&amp;Ignore Case",self.dict["ignore_case"]),
    ("Wrap &amp;Around",self.dict["wrap"]),
    ("&amp;Reverse",    self.dict["reverse"]),
    ('Rege&amp;xp',     self.dict['pattern_match']),
    ("Mark &amp;Finds", self.dict["mark_finds"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outline"),
    (self.dict["radio-search-scope"],"&amp;Suboutline Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
]

checkLists[1] = [
    ("Search &amp;Headline", self.dict["search_headline"]),
    ("Search &amp;Body",     self.dict["search_body"]),
    ("Mark &amp;Changes",    self.dict["mark_changes"]),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;Button-1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    # ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051020120306.19">def init (self,c):
    
    # g.trace('Find Tab')

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020120306.20">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020120306.21">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    # ("selection_only","selection-only")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outline")</t>
<t tx="ekr.20051020120306.22">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    self.p = self.c.currentPosition()
    self.v = self.p.v

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val)
        # g.trace(key,val)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)

    # The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.bodyWantsFocus()</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.widgetWantsFocus(t)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.widgetWantsFocus(t)</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # event

    w = self.frame.focus_get()
    if g.app.gui.isTextWidget(w):
        g.app.gui.setTextSelection(w,"1.0","end")

    return "break"</t>
<t tx="ekr.20051020120306.28">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051022162730">def setTabBindings (self,tabName):
    
    c = self.c ; k = c.k
    tab = self.nb.tab(tabName)
    text = self.textDict.get(tabName)
    
    # Send all event in the text area to the master handlers.
    for kind,handler in (
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClick3Handler),
    ):
        text.bind(kind,handler)
    
    # Clicks in the tab area are harmless: use the old code.
    def tabMenuRightClickCallback(event,menu=self.menu):
        g.trace()
        self.onRightClick(event,menu)
        
    def tabMenuClickCallback(event,tabName=tabName):
        g.trace()
        self.onClick(event,tabName)
    
    tab.bind('&lt;Button-1&gt;',tabMenuClickCallback)
    tab.bind('&lt;Button-3&gt;',tabMenuRightClickCallback)</t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()
        
def findTabChangeAll(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeAllCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.k
    
    def resetWrapCallback(event,self=self,k=k):
        self.resetWrap(event)
        k.masterKeyHandler(event)

    table = (
        ('&lt;Button-1&gt;',  k.masterClickHandler),
        ('&lt;Double-1&gt;',  k.masterClickHandler),
        ('&lt;Button-3&gt;',  k.masterClickHandler),
        ('&lt;Double-3&gt;',  k.masterClickHandler),
        ('&lt;Key&gt;',       k.masterKeyHandler),
        ('&lt;Key&gt;',       resetWrapCallback),
        ('&lt;Return&gt;',    self.findButtonCallback),
        ("&lt;Escape&gt;",    self.hideTab),
    )

    for w in (self.find_ctrl,self.change_ctrl):
        for event, callback in table:
            w.bind(event,callback)
    
    if 0:
        w.bind("&lt;Key&gt;",self.resetWrap,'+')
            # Can't put this in the table bc of the '+' arg.</t>
<t tx="ekr.20051023183028">def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'</t>
<t tx="ekr.20051024102724">def setBindings (self):
    
    '''Create master bindings for all headlines.'''
    
    tree = self ; k = self.c.k
    
    &lt;&lt; make bindings for a common binding widget &gt;&gt;
    self.canvas.bind('&lt;Key&gt;',k.masterKeyHandler)
    &lt;&lt; make bindings for tagged items on the canvas &gt;&gt;</t>
<t tx="ekr.20051024173701">def createTab (self,tabName):
    
    c = self.c ; k = c.k
    tabFrame = self.nb.add(tabName)
    self.menu = self.makeTabMenu(tabName)
    &lt;&lt; Create the tab's text widget &gt;&gt;

    if tabName != 'Log':
        # c.k doesn't exist when the log pane is created.
        # k.makeAllBindings will call setTabBindings('Log')
        self.setTabBindings(tabName)</t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):

    self.setup_command()
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    self.setup_command()
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):

    self.setup_command()
    self.change()
    
def changeAllCommand (self,event=None):

    self.setup_command()
    self.changeAll()
    
def changeThenFindCommand(self,event=None):
    
    self.setup_command()
    self.changeThenFind()</t>
<t tx="ekr.20051026083544.2">def updateHead (self,event,w):
    
    '''Update a headline from an event.
    
    The headline officially changes only when editing ends.'''
    
    c = self.c ; ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)
    
    # g.trace(repr(ch))
    
    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    if s.endswith('\n'):
        s = s[:-1]
    w.configure(width=self.headWidth(s=s))

    if ch in ('\n','\r'):
        self.endEditLabel() # Now calls self.onHeadChanged.
</t>
<t tx="ekr.20051026083733.6">body.colorizer.interrupt()
c.frame.scanForTabWidth(p)
body.recolor_now(p,incremental=not self.forceFullRecolorFlag)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20051026083733.7">c.beginUpdate()
try:
    redraw_flag = False
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons. p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    c.endUpdate(redraw_flag)</t>
<t tx="ekr.20051026092433.1">def backwardDeleteCharacter (self,event=None):
    
    c = self.c ; p = c.currentPosition()
    w = event and event.widget
    if not g.app.gui.isTextWidget(w):
        g.trace('*'*40,'Not a text widget',c.widget_name(w))
        return
    
    wname = c.widget_name(w)
    i,j = g.app.gui.getTextSelection(w)
    # g.trace(wname,i,j)

    if wname.startswith('body'):
        self.beginCommand()
        d = g.scanDirectives(c,p)
        tab_width = d.get("tabwidth",c.tab_width)
        changed = True
        if i != j:
            w.delete(i,j)
        elif i == '1.0':
            changed = False # Bug fix: 1/6/06 (after a5 released).
        elif tab_width &gt; 0:
            w.delete('insert-1c')
        else:
            &lt;&lt; backspace with negative tab_width &gt;&gt;
        self.endCommand(changed=True,setLabel=False) # Necessary to make text changes stick.
    else:
        # No undo in this widget.
        if i != j:
            w.delete(i,j)
        elif i != '1.0':
            # Bug fix: 1/6/06 (after a5 released).
            # Do nothing at the start of the headline.
            w.delete('insert-1c')</t>
<t tx="ekr.20051026092746">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20051026143009">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually
done. We need only make a reasonable guess here. setUndoTypingParams stores the
number of trailing newlines in each undo bead, so whatever we do here can be
faithfully undone and redone.
@c

def removeTrailingNewlines (self,old,new,ch):

    '''Return True if a Tk has erroneously added a trailing newline.'''

    if not new.endswith('\n'):
        # There is no newline to remove.  Probably will never happen.
        return False
    elif not old:
        # Ambigous case.  Formerly always returned False.
        if new == "\n\n":
            return True # Handle a very strange special case.
        else:
            return ch not in ('\r','\n')
    elif old == new[:-1]:
        # A single trailing character has been added.
        return ch not in ('\r','\n') # Was False.
    else:
        # The text didn't have a newline, and now it does.
        # Moveover, some other change has been made to the text,
        # So at worst we have misrepresented the user's intentions slightly.
        return True</t>
<t tx="ekr.20051027114433">def getSelectedTab (self):
    
    return self.tabName</t>
<t tx="ekr.20051029070945"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect
leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803:  Redefining attribute (keyCallback) original line (792)
leoKeys.py:1315: No module attribute (initAllEditCommanders) found

C:\prog\leoCVS\leo\src\leoImport.py:158: No class attribute (_forcedGnxPositionList) found</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051103091115.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3411067
By: rogererens

Also, in the settings of Find/Change, I would choose for grouping the settings
node_only, search_body, search_headline, wrap (and possibly the whole_word option
also) together under search extent radio buttons. Although this organizational
mode mentions radio buttons, check boxes are used for selection_only and
suboutline_only, which I can enable both at the same time.
It's also not (yet?) very clear to me how selection_only, suboutline_only, node_only
(should) interact...</t>
<t tx="ekr.20051105103233"></t>
<t tx="ekr.20051121092320">def enableTclTraces (self):
    
    c = self.c

    def tracewidget(event):
        g.trace('enabling widget trace')
        Pmw.tracetk(event.widget, 1)
    
    def untracewidget(event):
        g.trace('disabling widget trace')
        Pmw.tracetk(event.widget,0)
        
    def focusIn (event):
        print("Focus in  %s (%s)" % (
            event.widget,event.widget.winfo_class()))
        
    def focusOut (event):
        print("Focus out %s (%s)" % (
            event.widget,event.widget.winfo_class()))

    # Put this in unit tests before the assert:
    # c.frame.bar1.unbind_all("&lt;FocusIn&gt;")
    # c.frame.bar1.unbind_all("&lt;FocusOut&gt;")

    # Any widget would do:
    w = c.frame.bar1
    if 1:
        w.bind_all("&lt;FocusIn&gt;", focusIn)
        w.bind_all("&lt;FocusOut&gt;", focusOut)
    else:
        w.bind_all("&lt;Control-1&gt;", tracewidget)
        w.bind_all("&lt;Control-Shift-1&gt;", untracewidget)</t>
<t tx="ekr.20051126125950">def getSelectedText (self,t):

    start, end = self.getTextSelection(t)
    if start and end and start != end:
        s = t.get(start,end)
        if s is None:
            return u""
        else:
            return g.toUnicode(s,g.app.tkEncoding)
    else:
        return u""</t>
<t tx="ekr.20051126171929">def hasSelection (self,widget):
    
    i,j = self.getTextSelection(widget)
    return i and j and i != j</t>
<t tx="ekr.20051216171520">def recolor_now(self,p=None,incremental=False):

    c = self
    if p is None:
        p = c.currentPosition()

    c.frame.body.colorizer.colorize(p,incremental)</t>
<t tx="ekr.20051220144507">def isTextWidget (self,w):
    
    '''Return True if w is a Text widget suitable for text-oriented commands.'''
    
    return w and isinstance(w,Tk.Text) </t>
<t tx="ekr.20060114055611">- It should recolor the text.
- Does it not stick sometimes?</t>
<t tx="ekr.20060115195302">def setDefaultUnboundKeyAction (self):
    
    k = self ; c = k.c

    defaultAction = c.config.getString('top_level_unbound_key_action') or 'insert'
    defaultAction.lower()
    if defaultAction in ('ignore','insert','overwrite'):
        self.unboundKeyAction = defaultAction
    else:
        g.trace('ignoring top_level_unbound_key_action setting: %s' % defaultAction)
        self.unboundKeyAction = 'insert'
        
    k.setInputState(self.unboundKeyAction)</t>
<t tx="ekr.20060116080040.2">These would be an alternative to XP Alt-f, Alt-E, etc.
</t>
<t tx="ekr.20060116082302.1">On startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.</t>
<t tx="ekr.20060116083043">More mac nits: two HELP menus, one is empty; </t>
<t tx="ekr.20060116083043.1"></t>
<t tx="ekr.20060116083359.1"></t>
<t tx="ekr.20060120193743">def showStateAndMode(self):
    
    k = self ; c = k.c ; frame = c.frame
    state = k.unboundKeyAction
    mode = k.getStateKind()
   
    if hasattr(frame,'clearStatusLine'):
        frame.clearStatusLine()
        put = frame.putStatusLine
        if state != 'insert':
            put('state: ',color='blue')
            put(state)
        if mode:
            put(' mode: ',color='blue')
            put(mode)
        
        # Late change.
        c.noKnownFocus()
</t>
<t tx="ekr.20060120200818">def setInputState (self,state,showState=False):

    k = self ; c = k.c

    k.unboundKeyAction = state
    if state != 'insert' or showState:
        k.showStateAndMode()</t>
<t tx="ekr.20060121101642">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3534349
By: edcdave

Thanks for the tip. I did some further checking along this vein and found that
saving the Leo file is not sufficient - I have to exit the document and open
it again before the rst destination directory is set correctly.

While I was testing this, I encountered a problem with the delete key. But I'll
post it in another thread.

Thanks again,
Dave Harris
</t>
<t tx="ekr.20060122183914"></t>
<t tx="ekr.20060122183914.1">@nocolor</t>
<t tx="ekr.20060122185244.2">unindent-region should do nothing if not in body pane, or it should work in all panes.</t>
<t tx="ekr.20060122193554">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3549737

for extend selection,
with binding to arrow keys,
if you switch from up to dn arrow,
the selection restarts again.
this should just change extend direction
while still using the same selection.</t>
<t tx="ekr.20060123115459">def setFindScopeEveryWhere     (self, event): return self.setFindScope('entire-outline')
def setFindScopeNodeOnly       (self, event): return self.setFindScope('node-only')
def setFindScopeSuboutlineOnly (self, event): return self.setFindScope('suboutline-only')

def setFindScope (self, where): self.getHandler().setFindScope(where)

def showFindOptions      (self,event): self.getHandler().showFindOptions()

def toggleIgnoreCaseOption     (self, event): return self.toggleOption('ignore_case')
def toggleMarkChangesOption    (self, event): return self.toggleOption('mark_changes')
def toggleMarkFindsOption      (self, event): return self.toggleOption('mark_finds')
def toggleRegexOption          (self, event): return self.toggleOption('pattern_match')
def toggleReverseOption        (self, event): return self.toggleOption('reverse')
def toggleSearchBodyOption     (self, event): return self.toggleOption('search_body')
def toggleSearchHeadlineOption (self, event): return self.toggleOption('search_headline')
def toggleWholeWordOption      (self, event): return self.toggleOption('whole_word')
def toggleWrapSearchOption     (self, event): return self.toggleOption('wrap')

def toggleOption (self, ivar): self.getHandler().toggleOption(ivar)</t>
<t tx="ekr.20060123125256">class minibufferFind:

    '''An adapter class that implements minibuffer find commands using the (hidden) Find Tab.'''

    @others</t>
<t tx="ekr.20060123125317.2">def __init__(self,c,finder):

    self.c = c
    self.k = c.k
    self.finder = finder
</t>
<t tx="ekr.20060123131421"></t>
<t tx="ekr.20060124082357">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3538274
By: ktenney

The plugin to support @view nodes is not working
for me, when I doubleclick an @view node, the 
cursor changes to an hourglass a couple times, but
nothing happens in the body of the node.

I imported at_view.py into a node, named it
@button at_view.py, and added the following;

v = View(c)
v.icondclick2(None,None)    

This works as a button; clicking the button
when an @view node is selected updates the
node body.

Evidently the issue is with the hooking/calling
mech. not the plugin code itself.</t>
<t tx="ekr.20060124090925">Minibuffer search commands should be nothing a but a thin interface to Leo's already existing tab-search commands.  That is, the searchCommandsClass in leoEditCommands.py will be an adapter class on the leoFind class in leoFind.py.  It won't be a subclass: it will use the already existing class.

Notes:

- The leoFind class will remain essentially unchanged, except possibly for a few new interface methods.  This keeps the project safe.

- The searchCommandsClass can use Leo's complex logic for determining the next node in searches.  Except for incremental searches, the actual searching logic will be delegated to the leoFind class.  This avoids bugs in the search commands (except very old bugs :-)

- In no case will the new search commands make the Find tab visible; it's only the Find tab code that is being reused, not the Find tab interface.

- With perhaps a bit of fudging the find-tab-find command is essentially equivalent to what I was thinking of as the find-again command.  Similarly for find-tab-find-previous.  These aliases for existing commands will make it clear that the find tab does not need to be visible.

- The incremental search commands do not exists in the leoFind classes, so they will be implemented entirely in the searchCommandsClass.  The incremental commands should maintain a list of previous matches.  This allows a) support for backspace and b) an incremental-search-again command.  Furthermore, this list makes it easy to detect the end of a wrapped incremental search.

- Leo will have a set of minibuffer commands that toggle leoFind class ivars.  The searchCommandsClass will use these ivars to guide searches.  (Mostly this will happen automatically because all the real work gets delegated to the leoFind class.)

Presumably, few people will want to bind keys to these toggle-options commands. Rather, user would typically set find options in a mode.  There will be a new 'show-search-options' command that will print the options in the status line.  As a more visual alternative, I am planning new show-find-tab-options command that will show only the checkboxes in the find tab.  These checkboxes will always be up-to-date: that is, the toggle-options commands will update the gui (behind the scenes, unless the find tab is already visible.)

- A new default-search command will call one of the various new minibuffer search commands depending on the setting of these options.  This promises to be very useful.  The find-again command will support previous default and incremental searches, probably with some special-case code.</t>
<t tx="ekr.20060124093828"># def change             (self,event): self.getHandler().changeCommand()
# def changeAll          (self,event): self.getHandler().changeAllCommand()
# def changeThenFind     (self,event): self.getHandler().changeThenFindCommand()
# def findNext           (self,event): self.getHandler().findNextCommand()
# def findPrev           (self,event): self.getHandler().findPrevCommand()

def cloneFindAll       (self,event): self.getHandler().cloneFindAll(event)

def replaceString      (self,event): self.getHandler().replaceString(event)
def reSearchBackward   (self,event): self.getHandler().reSearchBackward(event)
def reSearchForward    (self,event): self.getHandler().reSearchForward(event)
def searchBackward     (self,event): self.getHandler().searchBackward(event)
def searchForward      (self,event): self.getHandler().searchForward(event)
def wordSearchBackward (self,event): self.getHandler().wordSearchBackward(event)
def wordSearchForward  (self,event): self.getHandler().wordSearchForward(event)

def searchWithPresentOptions (self,event):
    self.getHandler().searchWithPresentOptions(event)</t>
<t tx="ekr.20060124115801">def getHandler(self,show=False):
    
    '''Return the minibuffer handler, creating it if necessary.'''
    
    c = self.c
    
    self.openFindTab(show=show)
        # sets self.findTabHandler,
        # but *not* minibufferFindHandler.
    
    if not self.minibufferFindHandler:
        self.minibufferFindHandler = minibufferFind(c,self.findTabHandler)

    return self.minibufferFindHandler</t>
<t tx="ekr.20060124122844">def setOption (self, ivar, val, verbose = False):
    
    h = self.finder

    if ivar in h.intKeys:
        if val is not None:
            var = h.dict.get(ivar)
            var.set(val)
            if verbose and not g.app.unitTesting:
                g.trace('%s = %s' % (ivar,val))

    elif not g.app.unitTesting:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060124123133">def setFindScope(self,where):
    
    '''Set the find-scope radio buttons.
    
    `where` must be in ('node-only','entire-outline','suboutline-only'). '''
    
    h = self.finder
    
    if where in ('node-only','entire-outline','suboutline-only'):
        var = h.dict['radio-search-scope'].get()
        if var:
            h.dict["radio-search-scope"].set(where)
    else:
        g.trace('oops: bad `where` value: %s' % where)</t>
<t tx="ekr.20060124134356">def setupArgs (self,forward=False,regexp=False,word=False,statusLine='',setDefaultSearch=False):
    
    h = self.finder ; k = self.k
    
    if forward is None:
        reverse = None
    else:
        reverse = not forward

    for ivar,val,in (
        ('reverse', reverse),
        ('pattern_match',regexp),
        ('whole_word',word),
    ):
        if val is not None:
            self.setOption(ivar,val,verbose=True)
            
    h.p = p = self.c.currentPosition()
    h.v = p.v
    h.update_ivars()
    self.showFindOptions()
    
    
    
    if statusLine:
        k.setLabelBlue(statusLine,protect=True)
        
        return ### not ready yet.
        if setDefaultSearch:
            t = h.find_ctrl
            s = t.get('1.0','end')
            while s.endswith('\n') or s.endswith('\r'):
                s = s[:-1]
            k.extendLabel(s,select=True)
</t>
<t tx="ekr.20060124135401">def toggleOption (self, ivar):
    
    h = self.finder

    if ivar in h.intKeys:
        var = h.dict.get(ivar)
        val = not var.get()
        var.set(val)
        # g.trace('%s = %s' % (ivar,val),var)
    else:
        g.trace('oops: bad find ivar %s' % ivar)</t>
<t tx="ekr.20060124140114"></t>
<t tx="ekr.20060124140224.1">def searchBackward (self,event):

    k = self.k ; state = k.getState('search-backward')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=False,regexp=False,word=False)
        k.setLabelBlue('Search Backward: ',protect=True)
        k.getArg(event,'search-backward',1,self.searchBackward,completion=False)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)

def searchForward (self,event):

    k = self.k ; state = k.getState('search-forward')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=False)
        k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,'search-forward',1,self.searchForward)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060124140224.2">def wordSearchBackward (self,event):

    k = self.k ; state = k.getState('word-search-backward')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=False,regexp=False,word=True)
        k.setLabelBlue('Word Search Backward: ',protect=True)
        k.getArg(event,'word-search-backward',1,self.wordSearchBackward,completion=False)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)

def wordSearchForward (self,event):

    k = self.k ; state = k.getState('word-search-forward')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=False,word=True)
        k.setLabelBlue('Word Search: ',protect=True)
        k.getArg(event,'word-search-forward',1,self.wordSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060124140224.3">def reSearchBackward (self,event):

    k = self.k ; state = k.getState('re-search-backward')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=False,regexp=True,word=None)
        k.setLabelBlue('Regexp Search backward:',protect=True)
        k.getArg(event,'re-search-backward',1,self.reSearchBackward,completion=False)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)

def reSearchForward (self,event):

    k = self.k ; state = k.getState('re-search-forward')
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=True,regexp=True,word=None)
        k.setLabelBlue('Regexp Search:',protect=True)
        k.getArg(event,'re-search-forward',1,self.reSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060124181213.4">def generalSearchHelper (self,pattern,cloneFindAll=False):
    
    self.setupSearchPattern(pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    if cloneFindAll:
         self.finder.cloneFindAllCommand()
    else:
        # This handles the reverse option.
        self.finder.findNextCommand()</t>
<t tx="ekr.20060125074939">def showFindOptions (self):
    
    '''Show the present find options in the status line.'''
    
    frame = self.c.frame ; z = []
    # Set the scope field.
    head  = self.getOption('search_headline')
    body  = self.getOption('search_body')
    scope = self.getOption('radio-search-scope')
    d = {'entire-outline':'all','suboutline-only':'tree','node-only':'node'}
    scope = d.get(scope) or ''
    head = g.choose(head,'head','')
    body = g.choose(body,'body','')
    sep = g.choose(head and body,'+','')

    frame.clearStatusLine()
    s = '%s%s%s %s  ' % (head,sep,body,scope)
    frame.putStatusLine(s,color='blue')

    # Set the type field.
    script = self.getOption('script_search')
    regex  = self.getOption('pattern_match')
    change = self.getOption('script_change')
    if script:
        s1 = '*Script-find'
        s2 = g.choose(change,'-change*','*')
        z.append(s1+s2)
    elif regex: z.append('regex')
    
    table = (
        ('reverse',         'reverse'),
        ('ignore_case',     'noCase'),
        ('whole_word',      'word'),
        ('wrap',            'wrap'),
        ('mark_changes',    'markChg'),
        ('mark_finds',      'markFnd'),
    )
        
    for ivar,s in table:
        val = self.getOption(ivar)
        if val: z.append(s)

    frame.putStatusLine(' '.join(z))</t>
<t tx="ekr.20060125082510">def getOption (self,ivar,verbose=False):
    
    h = self.finder
    
    var = h.dict.get(ivar)
    if var:
        val = var.get()
        if verbose:
             g.trace('%s = %s' % (ivar,val))
        return val
    else:
        g.trace('bad ivar name: %s' % ivar)
        return None</t>
<t tx="ekr.20060125091234">def setupSearchPattern (self,pattern):
    
    h = self.finder ; t = h.find_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060125093807">def searchWithPresentOptions (self,event):

    k = self.k ; tag = 'search-with-present-options'
    
    state = k.getState(tag)
    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None,
            statusLine='Search: ',setDefaultSearch=True)
        # k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,tag,1,self.searchWithPresentOptions,completion=False)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg)</t>
<t tx="ekr.20060127162818">def enable_gc_debug(event=None):
    
    if gc:
        gc.set_debug(
            gc.DEBUG_STATS | # prints statistics.
            gc.DEBUG_LEAK | # Same as all below.
            gc.DEBUG_COLLECTABLE |
            gc.DEBUG_UNCOLLECTABLE |
            gc.DEBUG_INSTANCES |
            gc.DEBUG_OBJECTS |
            gc.DEBUG_SAVEALL
        )
        g.app.trace_gc_inited = True
    else:
        es('Can not import gc module',color='blue')</t>
<t tx="ekr.20060127164729.1">def printGcObjects(message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()

    global lastObjectCount

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        delta = n2-lastObjectCount
        lastObjectCount = n2

        g.es_print('-' * 30)
        g.es_print("garbage: %d, objects: %d, delta: %d %s" % (n,n2,delta,message))
        
        &lt;&lt; print number of each type of object &gt;&gt;
        if 0:
            &lt;&lt; print added functions &gt;&gt;

    except:
        traceback.print_exc()</t>
<t tx="ekr.20060127165509"># WARNING: the id trick is not proper because newly allocated objects
#          can have the same address as old objets.

def printGcVerbose(message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()

    global lastObjectsDict
    objects = gc.get_objects()
    
    newObjects = [o for o in objects if not lastObjectsDict.has_key(id(o))]
    
    lastObjectsDict = {}
    for o in objects:
        lastObjectsDict[id(o)]=o
        
    dicts = 0 ; seqs = 0
    
    i = 0 ; n = len(newObjects)
    while i &lt; 100 and i &lt; n:
        o = newObjects[i]
        if type(o) == type({}): dicts += 1
        elif type(o) in (type(()),type([])):
            seqs += 1
        else:
            g.es_print(o)
        i += 1
    g.es_print('-' * 40)
    g.es_print('dicts: %d, sequences: %d' % (dicts,seqs))
    g.es_print("%25s: %d new, %d total objects" % (message,len(newObjects),len(objects)))</t>
<t tx="ekr.20060127183752">master_key_count = 0

def masterKeyHandler (self,event):
    
    '''In the new binding scheme, there is only one key binding.
    
    This is the handler for that binding.'''
    
    k = self ; c = k.c
    val = self.masterKeyHandlerHelper(event)
    if val: # Ignore special keys.
        c.frame.updateStatusLine()
        c.masterFocusHandler()
    return val</t>
<t tx="ekr.20060128075225">def cloneFindAllCommand (self,event=None):
    
    self.setup_command()
    self.clone_find_all = True
    self.findAll()
    self.clone_find_all = False
</t>
<t tx="ekr.20060128080201">def cloneFindAll (self,event):

    k = self.k ; tag = 'clone-find-all'
    state = k.getState(tag)

    if state == 0:
        self.w = event and event.widget
        self.setupArgs(forward=None,regexp=None,word=None)
        k.setLabelBlue('Clone Find All: ',protect=True)
        k.getArg(event,tag,1,self.cloneFindAll)
    else:
        k.clearState()
        k.resetLabel()
        k.showStateAndMode()
        self.generalSearchHelper(k.arg,cloneFindAll=True)</t>
<t tx="ekr.20060128090219">def masterMenuHandler (self,stroke,func,commandName):
    
    k = self ; c = k.c ; w = c.frame.getFocus()
    
    # Create a minimal event for commands that require them.
    event = g.Bunch(char='',keysym='',widget=w)
    
    if 1:
        if not g.app.unitTesting:
            g.trace(c.widget_name(w))
    
    return k.masterCommand(event,func,stroke,commandName)</t>
<t tx="ekr.20060129052538.1"></t>
<t tx="ekr.20060129052538.2">def masterClickHandler (self,event,func=None):
    
    k = self ; c = k.c
    if not event: return
    w = event.widget ; wname = c.widget_name(w)
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(wname,func and func.__name__)

    if k.inState('full-command') and c.useTextMinibuffer and w != c.frame.miniBufferWidget:
        g.es_print('Ignoring click outside active minibuffer',color='blue')
        c.minibufferWantsFocus()
        return 'break'

    # Update the selection point immediately for updateStatusLine.
    if wname.startswith('body'):
        try:
            i = w.index('@%s,%s' % (event.x,event.y))
            g.app.gui.setInsertPoint(w,i)
            c.frame.updateStatusLine()
        except Exception:
            pass

    if event and func:
        # Don't even *think* of overriding this.
        val = func(event)
        c.masterFocusHandler()
        return val
    else:
        # All tree callbacks have a func, so we can't be in the tree.
        # g.trace('*'*20,'auto-deactivate tree: %s' % wname)
        c.frame.tree.OnDeactivate()
        c.masterFocusHandler()
        return None
        
masterClick3Handler         = masterClickHandler
masterDoubleClick3Handler   = masterClickHandler</t>
<t tx="ekr.20060131084938">def masterDoubleClickHandler (self,event,func=None):
    
    k = self ; c = k.c ; w = event and event.widget
    
    if c.config.getBool('trace_masterClickHandler'):
        g.trace(c.widget_name(w),func and func.__name__)

    if event and func:
        # Don't event *think* of overriding this.
        return func(event)
    else:
        i = w.index("@%d,%d" % (event.x,event.y))
        g.app.gui.setTextSelection(w,i+' wordstart',i+' wordend')
        return 'break'</t>
<t tx="ekr.20060131173440">self.bindingWidget = t = Tk.Text(self.canvas,name='bindingWidget')

t.bind('&lt;Key&gt;',k.masterKeyHandler)

table = (
    ('&lt;Button-1&gt;',       k.masterClickHandler,          tree.onHeadlineClick),
    ('&lt;Button-3&gt;',       k.masterClick3Handler,         tree.onHeadlineRightClick),
    ('&lt;Double-Button-1&gt;',k.masterDoubleClickHandler,    tree.onHeadlineClick),
    ('&lt;Double-Button-3&gt;',k.masterDoubleClick3Handler,   tree.onHeadlineRightClick),
)

for a,handler,func in table:
    def treeBindingCallback(event,handler=handler,func=func):
        return handler(event,func)
    t.bind(a,treeBindingCallback)
    
self.textBindings = t.bindtags()</t>
<t tx="ekr.20060131173440.2">where = g.choose(self.expanded_click_area,'clickBox','plusBox')

table = (
    (where,    '&lt;Button-1&gt;',self.onClickBoxClick),
    ('iconBox','&lt;Button-1&gt;',self.onIconBoxClick),
    ('iconBox','&lt;Double-1&gt;',self.onIconBoxDoubleClick),
    ('iconBox','&lt;Button-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;Double-3&gt;',self.onIconBoxRightClick),
    ('iconBox','&lt;B1-Motion&gt;',self.onDrag),
    ('iconBox','&lt;Any-ButtonRelease-1&gt;',self.onEndDrag),
)
for tag,event,callback in table:
    self.canvas.tag_bind(tag,event,callback)</t>
<t tx="ekr.20060202161935">def printGcAll (message=''):
    
    if not message:
        message = g.callerName(n=2)
    
    # g.collectGarbage()
    
    d = {} ; objects = gc.get_objects()
    g.es_print('-' * 30)
    g.es_print('%d objects' % len(objects),message)

    for obj in objects:
        t = type(obj)
        if t == 'instance':
            try: t = obj.__class__
            except: pass
        d[t] = d.get(t,0) + 1
        
    if 1: # Sort by n
        
        items = d.items()
        try:
            # Support for keword args to sort function exists in Python 2.4.
            # Support for None as an alternative to omitting cmp exists in Python 2.3.
            items.sort(key=lambda x: x[1],reverse=True)
        except: pass
        for z in items:
            g.es_print('%40s %7d' % (z[0],z[1]))
    else: # Sort by type
        keys = d.keys() ; keys.sort()
        for t in keys:
            g.es_print('%40s %7d' % (t,d.get(t)))
</t>
<t tx="ekr.20060203072636">def endSearch (self,i,j):

    g.app.gui.setTextSelection (self.w,i,j,insert='sel.end')
    self.k.keyboardQuit(event=None)</t>
<t tx="ekr.20060203112912.1"></t>
<t tx="ekr.20060204105811"></t>
<t tx="ekr.20060204120158">def findAgain (self,event):

    f = self.finder
    
    f.p = self.c.currentPosition()
    f.v = self.finder.p.v

    # This handles the reverse option.
    return f.findAgainCommand()
        </t>
<t tx="ekr.20060204120158.1">def findAgainCommand (self):
    
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    if s.endswith('\n'): s = s[:-1]
    
    if s and s != '&lt;find pattern here&gt;':
        self.findNextCommand()
        return True
    else:
        # Tell the caller that to get the find args.
        return False
</t>
<t tx="ekr.20060204120158.2">def findAgain (self,event):
    
    h = self.getHandler()
    
    # h.findAgain returns False if there is no search pattern.
    # In that case, we revert to find-with-present-options.
    if not h.findAgain(event):
        h.searchWithPresentOptions(event)</t>
<t tx="ekr.20060204124347">def hideTab (self,tabName):
    
    __pychecker__ = '--no-argsused' # tabName
    
    self.selectTab('Log')</t>
<t tx="ekr.20060205043324"></t>
<t tx="ekr.20060205043324.1">def printGcSummary (message='',trace=False):
    
    if not message:
        message = g.callerName(n=2)

    # g.collectGarbage()
    enable_gc_debug

    try:
        n = len(gc.garbage)
        n2 = len(gc.get_objects())
        s = 'garbage: %d, objects: %d, %s' % (n,n2,message)
        if trace:
            print s
        else:
            g.es_print(s)
    except:
        traceback.print_exc()</t>
<t tx="ekr.20060205043324.2"></t>
<t tx="ekr.20060205103842">def get_focus (self):
    
    c = self
    return g.app.gui.get_focus(c)
    
def request_focus(self,w):

    c = self
    if w: c.requestedFocusWidget = w
    c.traceFocus(w)
    
def set_focus (self,w):
    
    c = self
    
    if 1: # An optimization.
        c.requestedFocusWidget = w
        c.masterFocusHandler()
    
    else: # Safer, perhaps.
        c.hasFocusWidget = c.requestedFocusWidget = w
        g.app.gui.set_focus(c,w)</t>
<t tx="ekr.20060205105950">def setupChangePattern (self,pattern):
    
    h = self.finder ; t = h.change_ctrl
    
    s = g.toUnicode(pattern,g.app.tkEncoding)
    
    t.delete('1.0','end')
    t.insert('1.0',s)
    
    h.update_ivars()</t>
<t tx="ekr.20060205105950.1">def generalChangeHelper (self,find_pattern,change_pattern):
    
    g.trace(repr(change_pattern))
    
    self.setupSearchPattern(find_pattern)
    self.setupChangePattern(change_pattern)

    self.finder.p = self.c.currentPosition()
    self.finder.v = self.finder.p.v

    # This handles the reverse option.
    self.finder.findNextCommand()</t>
<t tx="ekr.20060205111103">def widget_name (self,widget):
    
    c = self
    
    return c.gui.widget_name(widget)</t>
<t tx="ekr.20060205221734">def masterKeyHandlerHelper (self,event):

    k = self ; c = k.c
    w = event and event.widget
    w_name = c.widget_name(w)
    trace = c.config.getBool('trace_masterKeyHandler') and not g.app.unitTesting
    keysym = event.keysym or ''
    if keysym in ('Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R','Win_L','Win_R'):
        return None
        
    self.master_key_count += 1
    if not g.app.unitTesting and c.config.getBool('trace_gc'):
        if (self.master_key_count % 100) == 0:
            g.printGcSummary(trace=True)

    stroke = k.strokeFromEvent(event)

    # Pass keyboard-quit to k.masterCommand for macro recording.
    if k.abortAllModesKey and stroke == k.abortAllModesKey:
        return k.masterCommand(event,k.keyboardQuit,stroke,'keyboard-quit')
        
    state = k.state.kind
    if trace: g.trace(repr(stroke),'state',state)
    if k.inState():
        # First: honor the 'mini' bindings.
        d = k.masterBindingsDict.get('mini')
        b = d.get(stroke)
        if b:
            # Pass this on for macro recording.
            k.masterCommand(event,b.func,stroke,b.commandName)
            c.minibufferWantsFocus()
            return 'break'
        # Second, pass keys to getArg or full-command modes if they are active.
        if state == 'getArg':
            return k.getArg(event)
        elif state == 'full-command':
            d = k.masterBindingsDict.get('mini')
            b = d.get(stroke)
            if b:
                # Pass this on for macro recording.
                k.masterCommand(event,b.func,stroke,b.commandName)
                c.minibufferWantsFocus()
                return 'break'
            else:
                # Do the default state action.
                k.callStateFunction(event) # Calls end-command.
                return 'break'
        # Third, pass keys to the general mode handler.
        d =  k.masterBindingsDict.get(state)
        if d:
            # A typical state
            b = d.get(stroke)
            g.trace(d.keys())
            if b:
                return k.generalModeHandler (event,
                    commandName=b.commandName,func=b.func,
                    modeName=state,nextMode=b.nextMode)
            else:
                return k.modeHelp(event)
        else:
            g.trace('No state dictionary for %s' % state)
            return 'break'
    
    for key,name in (
        # Order here is similar to bindtags order.
        ('body','body'),
        ('text','head'), # Important: text bindings in head before tree bindings.
        ('tree','head'),
        ('tree','canvas'),
        ('log', 'log'),
        ('text',None), ('all',None),
    ):
        if (
            name and w_name.startswith(name) or
            key == 'text' and g.app.gui.isTextWidget(w) or
            key == 'all'
        ):
            d = k.masterBindingsDict.get(key)
            # g.trace(key,name,d and len(d.keys()))
            if d:
                b = d.get(stroke)
                if b:
                    if trace: g.trace('%s found %s = %s' % (key,b.stroke,b.commandName))
                    return k.masterCommand(event,b.func,b.stroke,b.commandName)

    if stroke.find('Alt+') &gt; -1 or stroke.find('Ctrl+') &gt; -1:
        if trace: g.trace('ignoring unbound special key')
        return 'break'
    else:
        if trace: g.trace(repr(stroke),'no func')
        return k.masterCommand(event,func=None,stroke=stroke,commandName=None)</t>
<t tx="ekr.20060206062108.1">@nocolor

- Ran Leo with Python23 to test memory allocation.

- Call update_idletasks when writing to the log.

- Fixed several tree bugs.

- Updated selection point immediately in masterKeyHandler.
  Otherwise, updateStatusLine would be one click behind.</t>
<t tx="ekr.20060206103355"></t>
<t tx="ekr.20060206103531"></t>
<t tx="ekr.20060206104510">Refer to 4.4b3 to do first list.</t>
<t tx="ekr.20060206104722">
</t>
<t tx="ekr.20060206105450"></t>
<t tx="ekr.20060206113925">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3549737
By: nobody

\src\leoEditCommands.py:340: 
Warning: 'yield' will become a reserved keyword 

for python2.2 leoEditCommands.py needs
from __future__ import generators</t>
<t tx="ekr.20060206113925.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3549737

Warning: ignoring bool:body_gmt_time not string
There may be conflicting settings!</t>
<t tx="ekr.20060206124634"></t>
<t tx="ekr.20060206131908"></t>
<t tx="ekr.20060206165304">Clean up handling of selection.</t>
<t tx="ekr.20060207091145"></t>
<t tx="ekr.20060207101443">def setHeadline (self,p,s):
    
    '''Set the actual text of the headline widget.
    
    This is called from the undo/redo logic to change the text before redrawing.'''
    
    w = self.edit_widget(p)
    if w:
        w.configure(state='normal')
        w.delete('1.0','end')
        if s.endswith('\n') or s.endswith('\r'):
            s = s[:-1]
        w.insert('1.0',s)
        self.revertHeadline = s
        # g.trace(repr(s),w.get('1.0','end'))
    else:
        g.trace('-'*20,'oops')</t>
<t tx="ekr.20060207103936"></t>
<t tx="ekr.20060207110408">@nocolor

In the new drawing scheme, tree.redraw_now always calls c.endEditing, which
calls tree.onHeadChanged. The effect of this was to reverse the action of
undo/redoNodeContents.

The solution was to change the edit widget directly before calling
tree.redraw_now. To do this, I created the new tree.setHeadline method.</t>
<t tx="ekr.20060207110750">@nocolor

Fixed several bugs related to recent changes.
All unit tests now pass.</t>
<t tx="ekr.20060207135120"></t>
<t tx="ekr.20060207140352">def masterFocusHandler (self):
    
    c = self ; 
    trace = not g.app.unitTesting and c.config.getBool('trace_focus')
    
    # Give priority to later requests, but default to previously set widget.
    w = c.requestedFocusWidget or c.hasFocusWidget
    
    if not c.requestedFocusWidget or c.requestedFocusWidget == c.hasFocusWidget:
        if trace: g.trace('*'*20,'no change.')
        c.requestedFocusWidget = None
    elif w:
        # Ignore whatever g.app.gui.get_focus might say.
        ok = g.app.gui.set_focus(c,w)
        if ok: c.hasFocusWidget = w
        c.requestedFocusWidget = None
    else:
        if trace: g.trace('*'*20,'oops: moving to body pane.')
        c.bodyWantsFocusNow()

restoreRequestedFocus = masterFocusHandler</t>
<t tx="ekr.20060207142332">trace_focus_count = 0

def traceFocus (self,w):
    
    c = self

    if not g.app.unitTesting and c.config.getBool('trace_focus'):
        c.trace_focus_count += 1
        g.trace('%4d' % (c.trace_focus_count),
            c.widget_name(w),g.callers())</t>
<t tx="ekr.20060207164200">@nocolor

* Found the reason why focus was *still* sticking in the outline pane:
    - The click handlers must return 'break', not continue.
    - However, OnActivateHeadline must return 'continue' when the headline is active
      so that Tk will handle the click properly.

- UNL does not seem to be causing problems.

- No need to save/restore focus in status line.

- Added several new traces to tkTree class.

* tree.redraw_now now ends editing properly. This fixes lots of bugs. In
particular, it avoid any chance that p.edit_widget won't correspond to the
present position.

- k.masterClickHandler calls tree.OnDeactivate() if there is no callback function.
  This solves most headline focus problems, provided that all panes bind clicks to k.masterClickHandler.

- toggle-active-pane now ends editing properly.

- insert-headline now calls c.editPosition after calling c.endUpdate().</t>
<t tx="ekr.20060207194124"></t>
<t tx="ekr.20060208064636"></t>
<t tx="ekr.20060208080524"></t>
<t tx="ekr.20060208081656">@nocolor

Backspace in empty body text sometimes moved focus to canvas, and sometimes
improperly drew icon.

Made several fixes to onBodyChanged. There was no test for unchanged text! This
could have created all sorts of problems for undo.</t>
<t tx="ekr.20060208143543">def noKnownFocus (self):
    
    '''Indicate that the widget with focus is not known.
    This will force a later call to g.app.gui.set_focus().'''
    
    
    self.hasFocusWidget = None</t>
<t tx="ekr.20060208195315">@ This revealed several problems:
    
- Most find dialog commands do not actually exist. All find commands except
open-find-dialog actuall refer to the find tab.

- Severl other minor shortcut problems.</t>
</tnodes>
</leo_file>
