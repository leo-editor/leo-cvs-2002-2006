<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="8614" clone_windows="0"/>
<globals body_outline_ratio="0.615384615385">
	<global_window_position top="27" left="361" height="871" width="864"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="EKR.20040430162943"><vh>Notes</vh>
<v t="ekr.20031218072017.329"><vh>@thin ../doc/leoNotes.txt</vh></v>
</v>
<v t="EKR.20040519090151.3"><vh>Projects</vh>
<v t="EKR.20040429143933"><vh>@thin leoProjects.txt</vh></v>
</v>
<v t="EKR.20040519090151.2"><vh>To do</vh>
<v t="ekr.20050831131028"><vh>opml</vh>
<v t="ekr.20050831131452"><vh>Original post</vh></v>
<v t="ekr.20050831131452.1"><vh>opml attributes v elements</vh></v>
<v t="ekr.20050912063133"><vh>@url http://sourceforge.net/forum/message.php?msg_id=3273977</vh></v>
<v t="ekr.20050912065811"><vh>@url http://sourceforge.net/forum/message.php?msg_id=3279900 (summary)</vh></v>
<v t="ekr.20050915062404"><vh>My post</vh></v>
</v>
<v t="ekr.20040117181936"
marks="ekr.20051025071455,"><vh>@thin ../doc/leoToDo.txt</vh></v>
</v>
<v t="ekr.20050924073836" a="TV"><vh>4.4 projects</vh>
<v t="ekr.20051029070945"><vh>Pychecker report</vh></v>
<v t="ekr.20051010062551.1"><vh>(key dicts)</vh></v>
<v t="ekr.20051009120608"><vh>(ctors &amp; finishCreate)</vh>
<v t="ekr.20031218072017.2811"><vh> c.Birth &amp; death</vh>
<v t="ekr.20031218072017.2812"><vh>c.__init__</vh></v>
<v t="ekr.20040731071037"><vh>c.initIvars</vh>
<v t="ekr.20031218072017.2813"><vh>&lt;&lt; initialize ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.2814"><vh>c.__repr__ &amp; __str__</vh></v>
<v t="ekr.20041130173135"><vh>c.hash</vh></v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
</v>
<v t="ekr.20050920085536.2"><vh> ctor (keyHandler)</vh>
<v t="ekr.20051006092617"><vh>&lt;&lt; define Tk ivars &gt;&gt;</vh></v>
<v t="ekr.20051006092617.1"><vh>&lt;&lt; define externally visible ivars &gt;&gt;</vh></v>
<v t="ekr.20050923213858"><vh>&lt;&lt; define internal ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20050920093543"><vh>c.finishCreate &amp; helper</vh>
<v t="ekr.20051007143620"><vh>printCommandsDict</vh></v>
</v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20050920094212"><vh>f.createMiniBufferWidget</vh></v>
</v>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
<v t="ekr.20050920084036.188"><vh>leoCommands.getPublicCommands (sets inversCommandDict &amp; leoCallbackDict)</vh>
<v t="ekr.20050920084036.189"><vh>&lt;&lt; define dictionary d of names and Leo commands &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051104105403"><vh>Calls to update_idletasks</vh>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
<v t="ekr.20050924064254"><vh>Label...</vh>
<v t="ekr.20051023132350"><vh>getLabel</vh></v>
<v t="ekr.20051023132350.2"><vh>protectLabel</vh></v>
<v t="ekr.20050920085536.37"><vh>resetLabel</vh></v>
<v t="ekr.20051023132350.1"><vh>setLabel</vh></v>
<v t="ekr.20050920085536.36"><vh>setLabelBlue</vh></v>
<v t="ekr.20050920085536.35"><vh>setLabelGrey</vh></v>
<v t="ekr.20050920085536.38"><vh>updateLabel</vh></v>
</v>
</v>
<v t="ekr.20051103114520.2"><vh>(New World Order)</vh>
<v t="ekr.20051027135712"><vh>a2 Notes</vh></v>
<v t="ekr.20051104101307"><vh>a3 Notes</vh></v>
<v t="ekr.20031218072017.1416"><vh>app.__init__</vh>
<v t="ekr.20031218072017.1417"><vh>&lt;&lt; define global constants &gt;&gt;</vh></v>
<v t="ekr.20031218072017.368"><vh>&lt;&lt; define global data structures &gt;&gt; app</vh></v>
</v>
<v t="ekr.20051029065806"><vh>Commands</vh>
<v t="ekr.20031218072017.2949"><vh>Drawing Utilities (commands)</vh>
<v t="ekr.20031218072017.2950"><vh>beginUpdate</vh></v>
<v t="ekr.20031218072017.2951"><vh>bringToFront</vh></v>
<v t="ekr.20031218072017.2952"><vh>c.endUpdate &amp; test</vh>
<v t="ekr.20050916100046"><vh>test_c_endUpdate</vh></v>
</v>
<v t="ekr.20031218072017.2953"><vh>recolor</vh></v>
<v t="ekr.20031218072017.2954"><vh>redraw &amp; repaint</vh></v>
</v>
<v t="ekr.20031218072017.840"><vh>Cut/Copy/Paste (tkFrame)</vh>
<v t="ekr.20051011072903.2"><vh>copyText</vh></v>
<v t="ekr.20051011072049.2"><vh>cutText</vh></v>
<v t="ekr.20051011072903.5"><vh>pasteText</vh>
<v t="ekr.20051103160025"><vh>&lt;&lt; paste the text into w &gt;&gt;</vh></v>
</v>
<v t="ekr.20051011072903.1"><vh>OnCopyFromMenu</vh></v>
<v t="ekr.20051011072049.1"><vh>OnCutFromMenu</vh></v>
<v t="ekr.20051011072903.4"><vh>OnPasteFromMenu</vh></v>
</v>
<v t="ekr.20031218072017.3981"><vh>abortEditLabelCommand</vh></v>
<v t="ekr.20031218072017.3982"><vh>endEditLabelCommand</vh></v>
<v t="ekr.20031218072017.3070"><vh>changeSelection</vh></v>
<v t="ekr.20031218072017.3983"><vh>insertHeadlineTime</vh></v>
</v>
<v t="ekr.20051022152427"><vh>Focus</vh>
<v t="ekr.20050120083053"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20050120092028"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20050120092028.1"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="ekr.20051022142249"><vh>focus (editCommandsClass)</vh>
<v t="ekr.20051022144825"><vh>focusToBody/Log/Tree/Minibuffer</vh></v>
<v t="ekr.20051022144825.1"><vh>cycleFocus</vh></v>
</v>
<v t="ekr.20051022132934"><vh>Click event handlers (tkTree)</vh>
<v t="ekr.20040803072955.20"><vh>tkTree.createPermanentBindings</vh></v>
<v t="ekr.20051016095907.2"><vh>Focus &amp; update (tkLog)</vh>
<v t="ekr.20031218072017.4045"><vh>tkLog.onActivateLog</vh></v>
<v t="ekr.20031218072017.4044"><vh>tkLog.hasFocus</vh></v>
<v t="ekr.20050208133438"><vh>forceLogUpdate</vh></v>
</v>
<v t="ekr.20031218072017.4003"><vh>Focus (tkBody)</vh></v>
<v t="ekr.20040803072955.108"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20040803072955.87"><vh>onHeadlineClick</vh></v>
<v t="ekr.20051022141020"><vh>onTreeClick</vh></v>
<v t="ekr.20040803072955.105"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20040803072955.106"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040803072955.125"><vh>Selecting &amp; editing... (tkTree)</vh>
<v t="ekr.20040803072955.126"><vh>endEditLabel</vh></v>
<v t="ekr.20040803072955.127"><vh>editLabel</vh></v>
<v t="ekr.20040803072955.128"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.134"><vh>tree.set...LabelState</vh>
<v t="ekr.20040803072955.135"><vh>setNormalLabelState</vh></v>
<v t="ekr.20040803072955.136"><vh>setDisabledLabelState</vh></v>
<v t="ekr.20040803072955.137"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20040803072955.138"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20040803072955.139"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20040803072955.140"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20040803072955.141"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20040803072955.142"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20040803072955.143"><vh>tree.expandAllAncestors</vh></v>
</v>
</v>
<v t="ekr.20051104100739"><vh>Idle Time</vh>
<v t="ekr.20031218072017.1315"><vh>idle time functions (leoGlobals)</vh>
<v t="EKR.20040602125018"><vh>enableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.1"><vh>disableIdleTimeHook</vh></v>
<v t="EKR.20040602125018.2"><vh>idleTimeHookHandler</vh></v>
</v>
<v t="ekr.20050120083053"><vh>Delayed Focus (tkFrame)</vh>
<v t="ekr.20050120092028"><vh>xWantsFocus (tkFrame)</vh></v>
<v t="ekr.20050120092028.1"><vh>set_focus (tkFrame)</vh></v>
</v>
<v t="EKR.20040602125018.2"><vh>idleTimeHookHandler</vh></v>
<v t="ekr.20051025150224"><vh>onIdleTime</vh></v>
</v>
<v t="ekr.20051104100657"><vh>keyHandler</vh>
<v t="ekr.20050920094633"><vh>k.finishCreate &amp; helpers</vh>
<v t="ekr.20051008082929"><vh>createInverseCommandsDict</vh></v>
</v>
<v t="ekr.20050920085536.65"><vh> masterCommand &amp; helpers</vh>
<v t="ekr.20050920085536.67"><vh>&lt;&lt; add character to history &gt;&gt;</vh></v>
<v t="ekr.20050923172809.1"><vh>callStateFunction</vh></v>
<v t="ekr.20050923174229.3"><vh>callKeystrokeFunction (not used)</vh></v>
<v t="ekr.20051026083544"><vh>handleDefaultChar</vh></v>
<v t="ekr.20051103114520"><vh>k.redraw</vh></v>
<v t="ekr.20051103114520.1"><vh>k.setFocus</vh></v>
</v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
</v>
<v t="ekr.20051103161147"><vh>Tree</vh>
<v t="ekr.20040803072955.35"><vh>Drawing...</vh>
<v t="ekr.20040803072955.36"><vh>drawBox</vh></v>
<v t="ekr.20040803072955.37"><vh>drawClickBox</vh>
<v t="ekr.20040803072955.38"><vh>&lt;&lt; change the appearance of headlines &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.39"><vh>drawIcon</vh>
<v t="ekr.20040803072955.40"><vh>&lt;&lt; compute x,y and iconVal &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.41"><vh>drawLine</vh></v>
<v t="ekr.20040803072955.42"><vh>drawNode &amp; force_draw_node (good trace)</vh>
<v t="ekr.20040803072955.43"><vh>force_draw_node</vh></v>
</v>
<v t="ekr.20040803072955.44"><vh>drawText</vh>
<v t="ekr.20040803072955.45"><vh>&lt;&lt; highlight text widget on enter events &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.46"><vh>drawUserIcons</vh></v>
<v t="ekr.20040803072955.47"><vh>drawUserIcon</vh>
<v t="ekr.20040803072955.48"><vh>&lt;&lt; set offsets and pads &gt;&gt;</vh></v>
<v t="ekr.20040803072955.49"><vh>&lt;&lt; draw the icon in string s &gt;&gt;</vh></v>
<v t="ekr.20040803072955.50"><vh>&lt;&lt; draw the icon at file &gt;&gt;</vh></v>
<v t="ekr.20040803072955.51"><vh>&lt;&lt; draw the icon at url &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.52"><vh>drawTopTree</vh></v>
<v t="ekr.20040803072955.53"><vh>drawTree</vh></v>
<v t="ekr.20040803072955.54"><vh>Top level...</vh>
<v t="ekr.20040803072955.55"><vh>tree.redraw</vh></v>
<v t="ekr.20040803072955.56"><vh>tkTree.redrawAfterException</vh></v>
<v t="ekr.20040803072955.57"><vh>force_redraw</vh></v>
<v t="ekr.20040803072955.58"><vh>redraw_now</vh></v>
<v t="ekr.20040803072955.59"><vh>idle_redraw</vh>
<v t="ekr.20040803072955.60"><vh>&lt;&lt; return if disabled, or quitting or dragging &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.61"><vh>idle_second_redraw</vh></v>
</v>
<v t="ekr.20040803072955.62"><vh>Unchanged...</vh>
<v t="ekr.20040803072955.63"><vh>inVisibleArea &amp; inExpandedVisibleArea</vh></v>
<v t="ekr.20040803072955.64"><vh>getIconImage</vh></v>
<v t="ekr.20040803072955.65"><vh>idle_scrollTo</vh>
<v t="ekr.20040803072955.66"><vh>&lt;&lt; compute approximate line height &gt;&gt;</vh></v>
<v t="ekr.20040803072955.67"><vh>&lt;&lt; Compute the fractions to scroll down/up &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.68"><vh>numberOfVisibleNodes</vh></v>
<v t="ekr.20040803072955.69"><vh>scrollTo</vh></v>
<v t="ekr.20040803072955.70"><vh>yoffset</vh></v>
</v>
</v>
<v t="ekr.20040803072955.71"><vh>Event handlers...</vh>
<v t="ekr.20040803072955.72"><vh>checkWidgetList</vh></v>
<v t="ekr.20040803072955.78"><vh>Click Box...</vh>
<v t="ekr.20040803072955.79"><vh>onClickBoxClick</vh></v>
</v>
<v t="ekr.20040803072955.99"><vh>Dragging</vh>
<v t="ekr.20041111115908"><vh>endDrag</vh>
<v t="ekr.20040803072955.104"><vh>&lt;&lt; set vdrag, childFlag &gt;&gt;</vh></v>
<v t="ekr.20041111114148"><vh>&lt;&lt; drag p to vdrag &gt;&gt;</vh></v>
</v>
<v t="ekr.20041111114944"><vh>startDrag</vh></v>
<v t="ekr.20040803072955.100"><vh>onContinueDrag</vh>
<v t="ekr.20040803072955.101"><vh>&lt;&lt; scroll the canvas as needed &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.102"><vh>onDrag</vh></v>
<v t="ekr.20040803072955.103"><vh>onEndDrag</vh></v>
</v>
<v t="ekr.20040803072955.73"><vh>dumpWidgetList</vh></v>
<v t="ekr.20040803072955.75"><vh>edit_text</vh></v>
<v t="ekr.20040803072955.74"><vh>eventToPosition</vh></v>
<v t="ekr.20040803072955.76"><vh>findEditWidget</vh></v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead (new in 4.4a2)</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040803072955.80"><vh>Icon Box...</vh>
<v t="ekr.20040803072955.81"><vh>onIconBoxClick</vh></v>
<v t="ekr.20040803072955.89"><vh>onIconBoxRightClick</vh></v>
<v t="ekr.20040803072955.82"><vh>onIconBoxDoubleClick</vh></v>
</v>
<v t="ekr.20040803072955.105"><vh>OnActivateHeadline (tkTree)</vh>
<v t="ekr.20040803072955.106"><vh>&lt;&lt; activate this window &gt;&gt;</vh></v>
</v>
<v t="ekr.20051022141020"><vh>onTreeClick</vh></v>
<v t="ekr.20040803072955.84"><vh>Text Box...</vh>
<v t="ekr.20040803072955.85"><vh>configureTextState</vh></v>
<v t="ekr.20040803072955.86"><vh>onCtontrolT</vh></v>
<v t="ekr.20040803072955.87"><vh>onHeadlineClick</vh></v>
<v t="ekr.20040803072955.83"><vh>onHeadlineRightClick</vh></v>
</v>
<v t="ekr.20040803072955.109"><vh>tree.findVnodeWithIconId</vh></v>
<v t="ekr.20040803072955.117"><vh>tree.moveUpDown</vh></v>
<v t="ekr.20040803072955.108"><vh>tree.OnDeactivate (caused double-click problem)</vh></v>
<v t="ekr.20040803072955.110"><vh>tree.OnPopup &amp; allies</vh>
<v t="ekr.20040803072955.111"><vh>OnPopupFocusLost</vh></v>
<v t="ekr.20040803072955.112"><vh>createPopupMenu</vh>
<v t="ekr.20040803072955.113"><vh>&lt;&lt; Create the menu table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.114"><vh>enablePopupMenuItems</vh>
<v t="ekr.20040803072955.115"><vh>&lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.116"><vh>showPopupMenu</vh></v>
</v>
</v>
<v t="ekr.20040803072955.125"><vh>Selecting &amp; editing... (tkTree)</vh>
<v t="ekr.20040803072955.126"><vh>endEditLabel</vh></v>
<v t="ekr.20040803072955.127"><vh>editLabel</vh></v>
<v t="ekr.20040803072955.128"><vh>tree.select</vh>
<v t="ekr.20040803072955.129"><vh>&lt;&lt; unselect the old node &gt;&gt; (changed in 4.2)</vh></v>
<v t="ekr.20040803072955.130"><vh>&lt;&lt; select the new node &gt;&gt;</vh></v>
<v t="ekr.20040803072955.131"><vh>&lt;&lt; update c.beadList or c.beadPointer &gt;&gt;</vh></v>
<v t="ekr.20040803072955.132"><vh>&lt;&lt; update c.visitedList &gt;&gt;</vh></v>
<v t="ekr.20040803072955.133"><vh>&lt;&lt; set the current node &gt;&gt;</vh></v>
</v>
<v t="ekr.20040803072955.134"><vh>tree.set...LabelState</vh>
<v t="ekr.20040803072955.135"><vh>setNormalLabelState</vh></v>
<v t="ekr.20040803072955.136"><vh>setDisabledLabelState</vh></v>
<v t="ekr.20040803072955.137"><vh>setSelectedLabelState</vh></v>
<v t="ekr.20040803072955.138"><vh>setUnselectedLabelState</vh></v>
<v t="ekr.20040803072955.139"><vh>setDisabledHeadlineColors</vh></v>
<v t="ekr.20040803072955.140"><vh>setEditHeadlineColors</vh></v>
<v t="ekr.20040803072955.141"><vh>setUnselectedHeadlineColors</vh></v>
</v>
<v t="ekr.20040803072955.142"><vh>dimEditLabel, undimEditLabel</vh></v>
<v t="ekr.20040803072955.143"><vh>tree.expandAllAncestors</vh></v>
</v>
</v>
<v t="ekr.20040803072955.90"><vh>head key handlers</vh>
<v t="ekr.20040803072955.88"><vh>onHeadlineKey</vh></v>
<v t="ekr.20051026083544.2"><vh>updateHead (new in 4.4a2)</vh></v>
<v t="ekr.20040803072955.91"><vh>onHeadChanged</vh>
<v t="ekr.20040803072955.94"><vh>&lt;&lt; truncate s if it has multiple lines &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20031218072017.1320"><vh>body key handlers</vh>
<v t="ekr.20031218072017.1329"><vh>onBodyChanged (tkTree)</vh></v>
<v t="ekr.20051026083733"><vh>updateBody (new in 4.4a2)</vh>
<v t="ekr.20051026083733.6"><vh>&lt;&lt; recolor the body &gt;&gt;</vh></v>
<v t="ekr.20051026171121"><vh>&lt;&lt; handle newline &gt;&gt;</vh></v>
<v t="ekr.20051026143009"><vh>&lt;&lt; remove extra Trailing newlines &gt;&gt;</vh></v>
<v t="ekr.20051026083733.7"><vh>&lt;&lt; redraw the screen if necessary &gt;&gt;</vh></v>
<v t="ekr.20051027172949"><vh>updateAutomatchBracket</vh></v>
<v t="ekr.20051026171121.1"><vh>udpateAutoIndent</vh></v>
<v t="ekr.20051026092433"><vh>updateTab</vh></v>
<v t="ekr.20051026092433.1"><vh>updateBackspace</vh>
<v t="ekr.20051026092746"><vh>&lt;&lt; backspace with negative tab_width &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051104111040"><vh>(Master-click binding)</vh>
<v t="ekr.20031218072017.2253"><vh>OnActivateLeoEvent, OnDeactivateLeoEvent</vh></v>
<v t="ekr.20031218072017.3941"><vh> Birth &amp; Death (tkFrame)</vh>
<v t="ekr.20031218072017.1801"><vh>__init__ (tkFrame)</vh>
<v t="ekr.20031218072017.1802"><vh>&lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3942"><vh>__repr__ (tkFrame)</vh></v>
<v t="ekr.20041221122440"><vh>f.component &amp; components</vh></v>
<v t="ekr.20031218072017.2176"><vh>f.finishCreate &amp; helpers</vh>
<v t="ekr.20051009044751"><vh>createOuterFrames</vh></v>
<v t="ekr.20051009044920"><vh>createIconBarComponents</vh></v>
<v t="ekr.20051009045208"><vh>createSplitterComponents</vh></v>
<v t="ekr.20051009045300"><vh>createStatusLineComponents</vh></v>
<v t="ekr.20051009045404"><vh>createFirstTreeNode</vh></v>
<v t="ekr.20050920094212"><vh>f.createMiniBufferWidget</vh></v>
</v>
<v t="ekr.20031218072017.3944"><vh>f.createCanvas &amp; helpers</vh>
<v t="ekr.20041221071131"><vh>createPmwTreeCanvas</vh></v>
<v t="ekr.20041221071131.1"><vh>createTkTreeCanvas</vh>
<v t="ekr.20050119210541"><vh>&lt;&lt; workaround for mouse-wheel problems &gt;&gt;</vh></v>
<v t="ekr.20040709081208"><vh>&lt;&lt; do scrolling by hand in a separate thread &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041221123325"><vh>createLeoSplitters &amp; helpers</vh>
<v t="ekr.20041223130032"><vh>&lt;&lt; create Pmw splitters and their components &gt;&gt;</vh></v>
<v t="ekr.20041221195402"><vh>Pmw...</vh>
<v t="ekr.20041221073427"><vh>createLeoPmwSplitter</vh></v>
<v t="ekr.20031218072017.3946"><vh>resizePanesToRatio</vh>
<v t="ekr.20050104084531"><vh>&lt;&lt; resize the Pmw panes &gt;&gt;</vh></v>
</v>
<v t="ekr.20041221075743"><vh>onPmwResizeSplitter1/2</vh></v>
</v>
<v t="ekr.20041221185246"><vh>Tk...</vh>
<v t="ekr.20041221073427.1"><vh>createLeoTkSplitter</vh></v>
<v t="ekr.20031218072017.3947"><vh>bindBar</vh></v>
<v t="ekr.20031218072017.3949"><vh>divideAnySplitter</vh></v>
<v t="ekr.20031218072017.3950"><vh>divideLeoSplitter</vh></v>
<v t="ekr.20031218072017.3951"><vh>onDrag...</vh></v>
<v t="ekr.20031218072017.3952"><vh>placeSplitter</vh></v>
<v t="ekr.20031218072017.998"><vh>Scrolling callbacks (frame)</vh></v>
</v>
</v>
<v t="ekr.20031218072017.3964"><vh>Destroying the frame</vh>
<v t="ekr.20031218072017.1975"><vh>destroyAllObjects</vh>
<v t="ekr.20031218072017.1976"><vh>&lt;&lt; clear all vnodes and tnodes in the tree&gt;&gt;</vh></v>
</v>
<v t="ekr.20031218072017.3965"><vh>destroyAllPanels</vh></v>
<v t="ekr.20031218072017.1974"><vh>destroySelf</vh></v>
</v>
</v>
</v>
<v t="ekr.20051103112558"><vh>4.4a3 projects</vh>
<v t="ekr.20051103091115.2"><vh>(Fix crasher in Open logic)</vh>
<v t="ekr.20051103091115.3"><vh>Report</vh></v>
<v t="EKR.20040602125018.2"><vh>idleTimeHookHandler</vh></v>
<v t="ekr.20051025150224"><vh>onIdleTime</vh></v>
</v>
<v t="ekr.20051104094952"><vh>Moved old projects into oldLeoProjects.leo</vh></v>
<v t="ekr.20051104094952.1"><vh>Added scripts.leo and unitTest.leo to distribution</vh></v>
</v>
</v>
<v t="ekr.20050921094025"><vh>4.4 To do</vh>
<v t="ekr.20051104051733"><vh>Use focus-in binding?</vh></v>
<v t="ekr.20051104152338"><vh>Fix bug in Remove Sentinels command</vh>
<v t="ekr.20051104152338.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051104131527"><vh>From e</vh></v>
<v t="ekr.20051104053655"><vh>Create a convenience method to execute minibuffer commands by name</vh></v>
<v t="ekr.20051103092502"><vh>Update screen shots</vh></v>
<v t="ekr.20051103144316"><vh>before a3</vh>
<v t="ekr.20051103094005"><vh>Fix bugs</vh>
<v t="ekr.20051103092502.1"><vh>Update 'e's plugins</vh></v>
<v t="ekr.20051103093034"><vh>Fix problems applying settings</vh>
<v t="ekr.20051103093034.1"><vh>Report</vh></v>
</v>
</v>
</v>
<v t="ekr.20051016162724"><vh>before a4</vh>
<v t="ekr.20051008131807"><vh>*** Unit tests</vh>
<v t="ekr.20051102122405"><vh>Notes</vh></v>
<v t="ekr.20050920085536.16"><vh>bindKey</vh>
<v t="ekr.20051022094136"><vh>&lt;&lt; bind callback to shortcut in pane &gt;&gt;</vh></v>
</v>
<v t="ekr.20051014170754.1"><vh>getShortcutForCommand/Name</vh></v>
<v t="ekr.20050920085536.64"><vh>k.manufactureKeyPressForCommandName</vh></v>
</v>
<v t="ekr.20051103091115"><vh>Update docs for find tab</vh>
<v t="ekr.20051103091115.1"><vh>Report</vh></v>
</v>
<v t="ekr.20051103100302"><vh>Make find tab scrollable</vh></v>
<v t="ekr.20051028061611.1"><vh>Unify all search commands</vh>
<v t="ekr.20051023094009"><vh>Search classes</vh>
<v t="ekr.20051020120306.6"><vh>class findTab (leoFind.leoFind)</vh>
<v t="ekr.20051020120306.10"><vh>Birth &amp; death</vh>
<v t="ekr.20051020120306.11"><vh>__init__</vh>
<v t="ekr.20051020120306.12"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051023181449"><vh>find.createBindings (findTab)</vh></v>
<v t="ekr.20051020120306.13"><vh>find.createFrame</vh>
<v t="ekr.20051020120306.14"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020120306.15"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020120306.16"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.17"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020120306.18"><vh>&lt;&lt; Create two columns of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.19"><vh>find.init</vh>
<v t="ekr.20051020120306.20"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020120306.21"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020120306.22"><vh>find.update_ivars</vh></v>
<v t="ekr.20051023183028"><vh>findButtonCallback</vh></v>
<v t="ekr.20051024192602"><vh> Top level</vh>
<v t="ekr.20051024192642.2"><vh>findNext/PrefCommand</vh></v>
<v t="ekr.20051024192642.3"><vh>change/ThenFindCommand</vh></v>
</v>
<v t="ekr.20051020120306.25"><vh>hideTab</vh></v>
<v t="ekr.20051020120306.26"><vh>bringToFront</vh></v>
<v t="ekr.20051020120306.27"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020120306.28"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
<v t="ekr.20051020120306.1"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020120306.2"><vh>__init__</vh>
<v t="ekr.20051020120306.3"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020120306.4"><vh>bindHotKey</vh></v>
<v t="ekr.20051020120306.5"><vh>buttonCallback</vh></v>
</v>
</v>
<v t="ekr.20050920084036.257"><vh>class searchCommandsClass</vh>
<v t="ekr.20050920084036.258"><vh> ctor</vh></v>
<v t="ekr.20050920084036.259"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051022211617"><vh>find tab...</vh>
<v t="ekr.20051020120306"><vh>openFindTab</vh></v>
<v t="ekr.20051022212004"><vh>commands...</vh></v>
</v>
<v t="ekr.20050920084036.261"><vh>incremental search...</vh>
<v t="ekr.20050920084036.262"><vh>startIncremental</vh></v>
<v t="ekr.20050920084036.264"><vh>iSearchStateHandler &amp; helper</vh>
<v t="ekr.20051002120125"><vh>&lt;&lt; do a non-incremental search &gt;&gt;</vh></v>
<v t="ekr.20050920084036.263"><vh>iSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.265"><vh>scolorizer</vh></v>
</v>
<v t="ekr.20050920084036.267"><vh>non-incremental search...</vh>
<v t="ekr.20050920084036.269"><vh>seachForward/Backward &amp; helper</vh>
<v t="ekr.20050920084036.268"><vh>plainSearchHelper</vh></v>
</v>
<v t="ekr.20051002111614"><vh>wordSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.272"><vh>wordSearchHelper</vh></v>
</v>
<v t="ekr.20050920084036.274"><vh>reSearchBackward/Forward &amp; helper</vh>
<v t="ekr.20050920084036.275"><vh>reSearchHelper</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20051018104223"><vh>Improve minibuffer commands</vh>
<v t="ekr.20051012053017.4"><vh>Search improvements</vh></v>
<v t="ekr.20051014122218"><vh>kill/yank from the xemacs tutorial</vh></v>
<v t="ekr.20051017111216"><vh>Commands to fix</vh>
<v t="ekr.20050920084036.141"><vh>removeBlankLines</vh></v>
<v t="ekr.20050920084036.75"><vh>backToIndentation</vh></v>
<v t="ekr.20050920084036.78"><vh>indentRelative</vh></v>
<v t="ekr.20050920084036.149"><vh>back/forwardWord &amp; helper</vh></v>
<v t="ekr.20050920084036.107"><vh>indentRegion</vh></v>
<v t="ekr.20050920084036.219"><vh>findNextMatch</vh>
<v t="ekr.20051005155611"><vh>&lt;&lt; handle regexp &gt;&gt;</vh></v>
<v t="ekr.20051005160923"><vh>&lt;&lt; handle plain search &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20051012054228"><vh>Vim mode (k.vimMode)</vh></v>
<v t="ekr.20050928144501"><vh>Expand commands to handle Leo environment</vh></v>
<v t="ekr.20051021074728"><vh>Space completion</vh></v>
</v>
<v t="ekr.20051027105304"><vh>before b1</vh>
<v t="ekr.20051028061546"><vh>Improve spell tab</vh>
<v t="ekr.20051025071455" a="M"><vh>Spell classes</vh>
<v t="ekr.20051025071455.3"><vh>&lt;&lt; specify aspell directories &gt;&gt;</vh></v>
<v t="ekr.20051025071455.6"><vh>class Aspell</vh>
<v t="ekr.20051025071455.7"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.8"><vh>__init__</vh></v>
</v>
<v t="ekr.20051025071455.10"><vh>processWord</vh></v>
<v t="ekr.20051025071455.11"><vh>updateDictionary</vh></v>
</v>
<v t="ekr.20051025071455.1"><vh>class spellCommandsClass</vh>
<v t="ekr.20051025080056"><vh>ctor</vh></v>
<v t="ekr.20051025080420"><vh>getPublicCommands (searchCommandsClass)</vh></v>
<v t="ekr.20051025080633"><vh>openSpellTab</vh></v>
<v t="ekr.20051025080420.1"><vh>commands...</vh></v>
</v>
<v t="ekr.20051025071455.18"><vh>class spellTab (leoFind.leoFind)</vh>
<v t="ekr.20051025071455.19"><vh>Birth &amp; death</vh>
<v t="ekr.20051025071455.20"><vh>spellTab.__init__</vh></v>
<v t="ekr.20051025094004"><vh>init_aspell</vh></v>
<v t="ekr.20051025071455.22"><vh>createSpellTab</vh>
<v t="ekr.20051025071455.23"><vh>&lt;&lt; Create the text and suggestion panes &gt;&gt;</vh></v>
<v t="ekr.20051025071455.24"><vh>&lt;&lt; Create the spelling buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025120920"><vh>createBindings</vh></v>
<v t="ekr.20051025071455.16"><vh>readDictionary</vh></v>
</v>
<v t="ekr.20051025071455.29"><vh>Buttons</vh>
<v t="ekr.20051025071455.30"><vh>onAddButton</vh></v>
<v t="ekr.20051025071455.31"><vh>onIgnoreButton</vh></v>
<v t="ekr.20051025071455.32"><vh>onChangeButton &amp; onChangeThenFindButton</vh></v>
<v t="ekr.20051025071455.33"><vh>onFindButton</vh></v>
<v t="ekr.20051025071455.34"><vh>onHideButton</vh></v>
</v>
<v t="ekr.20051025071455.36"><vh>Commands</vh>
<v t="ekr.20051025071455.37"><vh>add</vh></v>
<v t="ekr.20051025071455.38"><vh>change</vh></v>
<v t="ekr.20051025071455.40"><vh>find</vh></v>
<v t="ekr.20051025121408"><vh>hide</vh></v>
<v t="ekr.20051025071455.41"><vh>ignore</vh></v>
</v>
<v t="ekr.20051025071455.42"><vh>Helpers</vh>
<v t="ekr.20051025071455.43"><vh>bringToFront</vh></v>
<v t="ekr.20051025071455.44"><vh>fillbox</vh></v>
<v t="ekr.20051025071455.45"><vh>findNextMisspelledWord</vh>
<v t="ekr.20051025071455.46"><vh>&lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;</vh></v>
</v>
<v t="ekr.20051025071455.47"><vh>findNextWord</vh></v>
<v t="ekr.20051025071455.48"><vh>getSuggestion</vh></v>
<v t="ekr.20051025071455.49"><vh>onMap</vh></v>
<v t="ekr.20051025071455.50"><vh>onSelectListBox</vh></v>
<v t="ekr.20051025071455.51"><vh>update</vh></v>
<v t="ekr.20051025071455.52"><vh>updateButtons</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051028061802"><vh>Use tab for autocompleter</vh>
<v t="ekr.20051025144611"><vh>Autocompleter (Do not delete)</vh>
<v t="ekr.20051025144611.1"><vh>Configuration</vh>
<v t="ekr.20051025144611.2"><vh>autocompleter.ini</vh></v>
<v t="ekr.20051025144611.3"><vh>.ato files in the autocompleter folder</vh></v>
</v>
<v t="ekr.20051025144611.4"><vh>autocompleter.py</vh>
<v t="ekr.20051025144611.5"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20051025144611.6"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20051025144611.7"><vh>&lt;&lt;version history&gt;&gt;</vh></v>
<v t="ekr.20051025144611.8"><vh>&lt;&lt;a note on newCreateControl&gt;&gt;</vh></v>
<v t="ekr.20051025144611.10"><vh>&lt;&lt;coding conventions&gt;&gt;</vh></v>
<v t="ekr.20051025144611.11"><vh>&lt;&lt; configuration &gt;&gt;</vh></v>
<v t="ekr.20051025144611.12"><vh>&lt;&lt; globals &gt;&gt;</vh>
<v t="ekr.20051025144611.13"><vh>&lt;&lt;DictSet&gt;&gt;</vh></v>
</v>
<v t="ekr.20051025144611.14"><vh>&lt;&lt; patterns &gt;&gt;</vh></v>
<v t="ekr.20051025170832"><vh>Initialization</vh>
<v t="ekr.20051025144611.15"><vh>init</vh></v>
<v t="ekr.20051025170832.1"><vh>Config stuff</vh>
<v t="ekr.20051025144611.24"><vh>has read config file meths</vh></v>
<v t="ekr.20051025144611.25"><vh>readConfigFile</vh></v>
<v t="ekr.20051025144611.26"><vh>createConfigFile</vh></v>
<v t="ekr.20051025144611.27"><vh>readLanguageFiles</vh></v>
<v t="ekr.20051025144611.28"><vh>readOutline</vh></v>
</v>
<v t="ekr.20051025144611.16"><vh>watcher</vh></v>
<v t="ekr.20051025144611.23"><vh>initialScan</vh></v>
</v>
<v t="ekr.20051025144611.17"><vh>scanText</vh></v>
<v t="ekr.20051025144611.18"><vh>scanForAutoCompleter</vh></v>
<v t="ekr.20051025144611.19"><vh>scanForCallTip</vh></v>
<v t="ekr.20051025144611.20"><vh>makeAutocompletionList</vh></v>
<v t="ekr.20051025144611.21"><vh>_getCleanString</vh></v>
<v t="ekr.20051025144611.22"><vh>_reverseFindWhitespace</vh></v>
<v t="ekr.20051025144611.29"><vh>reducer</vh></v>
<v t="ekr.20051025144611.30"><vh>unbind</vh></v>
<v t="ekr.20051025144611.31"><vh>moveSelItem</vh></v>
<v t="ekr.20051025144611.32"><vh>processKeyStroke</vh></v>
<v t="ekr.20051025144611.33"><vh>testForUnbind</vh></v>
<v t="ekr.20051025144611.34"><vh>processAutoBox</vh></v>
<v t="ekr.20051025144611.35"><vh>add_item</vh></v>
<v t="ekr.20051025144611.36"><vh>add_bindings</vh></v>
<v t="ekr.20051025144611.37"><vh>configureAutoBox</vh></v>
<v t="ekr.20051025144611.38"><vh>calculatePlace</vh></v>
<v t="ekr.20051025144611.39"><vh>setLanguage</vh></v>
<v t="ekr.20051025144611.40"><vh>newCreateControl</vh></v>
<v t="ekr.20051025144611.41"><vh>addAutoboxAndCalltipWidgets</vh></v>
<v t="ekr.20051025144611.42"><vh>onOpenWindow</vh></v>
</v>
</v>
</v>
<v t="ekr.20051014152256"><vh>Fix long-standing bug in import code</vh>
<v t="ekr.20040930075711"><vh>Handle underindented lines</vh></v>
<v t="ekr.20040722132104"><vh>Write script to report underindented lines</vh></v>
</v>
<v t="ekr.20051014104337.1"><vh>Crash in undo</vh></v>
</v>
<v t="ekr.20050925105522"><vh>Big</vh>
<v t="ekr.20050928144501.1"><vh>Mouseless Leo</vh>
<v t="ekr.20050707085637"><vh>Suggestions from an emacs user</vh></v>
<v t="ekr.20050712092501.1"><vh>xemacs variables</vh>
<v t="ekr.20050712092501.2"><vh>top, bottom, left, right, horizontal vertical, gutter</vh></v>
<v t="ekr.20050712092501.5"><vh>prev...</vh>
<v t="ekr.20050712092501.6"><vh>*</vh></v>
<v t="ekr.20050712092501.7"><vh>:</vh></v>
<v t="ekr.20050712092501.8"><vh>abbrev-</vh></v>
<v t="ekr.20050712092501.9"><vh>after-</vh></v>
<v t="ekr.20050712092501.10"><vh>auto-</vh></v>
<v t="ekr.20050712092501.11"><vh>backup-</vh></v>
<v t="ekr.20050712092501.12"><vh>bbdb</vh></v>
<v t="ekr.20050712092501.13"><vh>before-</vh></v>
<v t="ekr.20050712092501.14"><vh>browse-url-</vh></v>
<v t="ekr.20050712092501.15"><vh>buffer</vh></v>
<v t="ekr.20050712092501.16"><vh>buffers-</vh></v>
<v t="ekr.20050712092501.17"><vh>cl-</vh></v>
<v t="ekr.20050712092501.18"><vh>command-</vh></v>
<v t="ekr.20050712092501.19"><vh>comment-</vh></v>
<v t="ekr.20050712092501.20"><vh>compilation</vh></v>
<v t="ekr.20050712092501.21"><vh>completion</vh></v>
<v t="ekr.20050712092501.22"><vh>configure</vh></v>
<v t="ekr.20050712092501.23"><vh>dabbrev- and dabbrev--</vh></v>
<v t="ekr.20050712094115"><vh>debug-</vh></v>
<v t="ekr.20050712094115.1"><vh>default-</vh></v>
<v t="ekr.20050712094115.2"><vh>global</vh></v>
<v t="ekr.20050712094115.3"><vh>help</vh></v>
<v t="ekr.20050712092501.24"><vh>isearch-</vh></v>
</v>
<v t="ekr.20050712092501.25"><vh>lisp</vh></v>
<v t="ekr.20050712092501.26"><vh>list-</vh></v>
<v t="ekr.20050712094115.4"><vh>load-</vh></v>
<v t="ekr.20050712092501.27"><vh>mail</vh></v>
<v t="ekr.20050712094115.5"><vh>message-</vh></v>
<v t="ekr.20050712092501.28"><vh>minibuffer-</vh></v>
<v t="ekr.20050712092501.29"><vh>mode-</vh></v>
<v t="ekr.20050712092501.30"><vh>modeline-</vh></v>
<v t="ekr.20050712092501.31"><vh>mouse-</vh></v>
<v t="ekr.20050712092501.32"><vh>mswindows-</vh></v>
<v t="ekr.20050712092501.33"><vh>package- &amp; packages-</vh></v>
<v t="ekr.20050712094115.6"><vh>paths-</vh></v>
<v t="ekr.20050712092501.34"><vh>regexp- &amp; search-</vh></v>
<v t="ekr.20050712092501.35"><vh>toolbar-</vh></v>
<v t="ekr.20050712094115.7"><vh>xwem</vh></v>
</v>
</v>
<v t="ekr.20051014161015"><vh>Full input modes</vh>
<v t="ekr.20051103100302.1"><vh>Posting: @input-mode coming</vh></v>
<v t="ekr.20051017140811.1"><vh>@url http://vimdoc.sourceforge.net/htmldoc/usr_03.html (vim must do all these)</vh></v>
</v>
</v>
<v t="ekr.20051012062458.1"><vh>Minor</vh>
<v t="ekr.20050713105353"><vh>Add configuration setting to set menu fonts</vh>
<v t="ekr.20050713105353.1"><vh>Email from Martin Moncrieffe &lt;mcm35@cam.ac.uk&gt;</vh></v>
</v>
<v t="ekr.20050512031131"><vh>Use global_log_window_position to specify outline/log ratio?</vh></v>
<v t="ekr.20050916180203"><vh>Make more commands undoable</vh></v>
<v t="ekr.20051016155819"><vh>treat plugins/options.py  differently?</vh></v>
<v t="ekr.20051101161545"><vh>Allow multiple bindings for the same minibuffer command</vh></v>
</v>
<v t="ekr.20051023192433"><vh>Maybe...</vh></v>
<v t="ekr.20051015123432"><vh>(Methods with pychecker problems)</vh>
<v t="ekr.20051015113252"><vh>Pychecker report</vh></v>
<v t="ekr.20041126060136"><vh>print_list &amp; listToString</vh></v>
<v t="ekr.20051006125633.1"><vh>bindShortcut</vh></v>
<v t="ekr.20051001050607"><vh>endCommand</vh></v>
</v>
<v t="ekr.20051028165515"><vh>Reference</vh>
<v t="ekr.20050930083044"><vh>@url 'http://www.sas.upenn.edu/computing/help/Unix/emacs.html'   (Basic Emacs commands)</vh></v>
<v t="ekr.20051004093536"><vh>@url 'http://www.ling.ed.ac.uk/facilities/help/emacs/emacs_14.html' (Registers)</vh></v>
<v t="ekr.20051005094144"><vh>@url 'http://www.delorie.com/gnu/docs/emacs/emacs_487.html' (Macros)</vh></v>
<v t="ekr.20051017140811"><vh>Original temac bindings</vh></v>
<v t="ekr.20050921094025.254"><vh>All xemacs commands</vh>
<v t="ekr.20050921094025.255"><vh>B: Buffer-menu</vh></v>
<v t="ekr.20050921094025.256"><vh>C, E, F, H</vh></v>
<v t="ekr.20050921094025.257"><vh>I: info</vh></v>
<v t="ekr.20050921094025.258"><vh>L, M, R, T, V: LaTeX,TeX</vh></v>
<v t="ekr.20050921094025.259"><vh>a add- align- append- apropos- auto-</vh></v>
<v t="ekr.20050921094025.260"><vh>b backward- bbdb- beginning- bookmark- br- browse- buffer- build- byte-</vh></v>
<v t="ekr.20050921094025.261"><vh>c c- calc-, call- capitalize- center- checkdoc- command- completion- copy- count- customize- cvs-</vh></v>
<v t="ekr.20050921094025.262"><vh>d dabbrev- define- delete- describe- dictionary dired- display- downcase-</vh></v>
<v t="ekr.20050921094025.263"><vh>e ediff- edir edit- emerge- end- exchange- eshell eval- exit- expand-</vh></v>
<v t="ekr.20050921094025.264"><vh>f fill- find- format- forward-</vh></v>
<v t="ekr.20050921094025.265"><vh>g global- goto- grep-</vh></v>
<v t="ekr.20050921094025.266"><vh>h help- hide- html- hyper-</vh></v>
<v t="ekr.20050921094025.267"><vh>i ibuffer- id-select- igrep- indent- info- insert- isearch- ispell- iswitchb- itimer-</vh></v>
<v t="ekr.20050921094025.268"><vh>j jde-</vh></v>
<v t="ekr.20050921094025.269"><vh>k kill- kimport-</vh></v>
<v t="ekr.20050921094025.270"><vh>l lisp- list- load-</vh></v>
<v t="ekr.20050921094025.271"><vh>m macroexpand- mail- make- mark- minibuffer- mouse- move-</vh></v>
<v t="ekr.20050921094025.272"><vh>n narrow- newline- next-</vh></v>
<v t="ekr.20050921094025.273"><vh>o open- other- outl- outline- overwrite</vh></v>
<v t="ekr.20050921094025.274"><vh>p package- paren- pcomplete- pending- pop- popup- pp- prepend- prettyexapnd- previous- profile- ps- pydoc pymacs- python-</vh></v>
<v t="ekr.20050921094025.275"><vh>q query-</vh></v>
<v t="ekr.20050921094025.276"><vh>r re- read- recentf- recover- recursive- rename- repeat- replace- reverse- run-</vh></v>
<v t="ekr.20050921094025.277"><vh>s save- scroll- search- set- shell- sort- speedbar spell- strokes- suspend- switch- symbol-</vh></v>
<v t="ekr.20050921094025.278"><vh>t tab tags- toggle- toolbar- turn-off turn-on</vh></v>
<v t="ekr.20050921094025.279"><vh>u universal- upcase- url-</vh></v>
<v t="ekr.20050921094025.280"><vh>v view- vm-</vh></v>
<v t="ekr.20050921094025.281"><vh>w win32- winring- word- write-</vh></v>
<v t="ekr.20050921094025.282"><vh>x xwem-</vh></v>
<v t="ekr.20050921094025.283"><vh>y yank-</vh></v>
<v t="ekr.20050921094025.284"><vh>z zap-</vh></v>
</v>
</v>
</v>
<v t="ekr.20031218072017.2406"><vh>Code</vh>
<v t="ekr.20031218072017.2415"><vh> Scripts</vh>
<v t="ekr.20040327103735.2"><vh>Script Tools (leoGlobals.py)</vh>
<v t="ekr.20031218072017.2418"><vh>g.initScriptFind (set up dialog)</vh></v>
<v t="ekr.20040321065415"><vh>g.findNodeInTree, findNodeAnywhere, findTopLevelNode</vh></v>
<v t="ekr.20050503112513.7" a="M"><vh>g.executeFile</vh>
<v t="ekr.20050503112513.8"><vh>&lt;&lt; define subprocess_wrapper &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040502195524"><vh>@thin ../scripts/leoScripts.txt</vh></v>
<v t="EKR.20040502194930"><vh>@thin ../scripts/tangle_done.py</vh></v>
<v t="ekr.20031218072017.2537"><vh>@thin ../scripts/untangle_done.py</vh></v>
</v>
<v t="ekr.20031218072017.2582"><vh> version &amp; signon stuff</vh>
<v t="ekr.20040629121554"><vh>getBuildNumber</vh></v>
<v t="ekr.20040629121554.1" a="M"><vh>getSignOnLine (Contains hard-coded version info)</vh></v>
<v t="ekr.20040629121554.2" a="M" labels="540801000032383634373033303061353332373632363536363666373236353230363336383631366536373635336132373061373033313061353636343635363632303639366536393734353636353732373336393666366532303238373336353663363632393361356337353330333033303631323032303230323036333230336432303733363536633636356337353330333033303631323032303230323036333265373636353732323033643230323232343532363537363639373336393666366533613230333132653332333233353230323432323230323332303433353635333230373537303634363137343635373332303734363836393733326530613730333230613733326571002e"><vh>initVersion</vh></v>
<v t="ekr.20040629121554.3"><vh>signOnWithVersion</vh></v>
</v>
<v t="ekr.20051031040240"><vh>Buttons and settings</vh>
<v t="ekr.20051027111215"><vh>@thin buttons.txt</vh></v>
<v t="ekr.20041119040438"><vh>@settings</vh>
<v t="ekr.20050420073615"><vh>@recent-files</vh></v>
<v t="ekr.20041119042418"><vh>@bool use_plugins = True</vh></v>
<v t="ekr.20041211042119"><vh>@int page_width = 80</vh></v>
</v>
</v>
<v t="ekr.20031218072017.2604"><vh>Core classes...</vh>
<v t="ekr.20031218072017.2605"><vh>@thin leo.py </vh></v>
<v t="ekr.20031218072017.2608"
marks="ekr.20031218072017.2619,"><vh>@thin leoApp.py</vh></v>
<v t="ekr.20041005105605.1"><vh>@thin leoAtFile.py</vh></v>
<v t="ekr.20031218072017.2794"><vh>@thin leoColor.py</vh></v>
<v t="ekr.20031218072017.2810"
marks="ekr.20031218072017.2817,ekr.20040629121554.1,ekr.20040629121554.2,ekr.20040711135244.11,"><vh>@thin leoCommands.py</vh></v>
<v t="ekr.20041117062700"><vh>@thin leoConfig.py</vh></v>
<v t="ekr.20050710142719"
marks="ekr.20051025071455,"><vh>@thin leoEditCommands.py</vh></v>
<v t="ekr.20031218072017.3018"><vh>@thin leoFileCommands.py</vh></v>
<v t="ekr.20031218072017.3093"
marks="ekr.20031218072017.2052,ekr.20050503112513.7,"><vh>@thin leoGlobals.py</vh></v>
<v t="ekr.20031218072017.3206"><vh>@thin leoImport.py</vh></v>
<v t="ekr.20031218072017.3748"><vh>@thin leoKeys.py</vh></v>
<v t="ekr.20031218072017.3320"><vh>@thin leoNodes.py</vh></v>
<v t="ekr.20031218072017.3439"><vh>@thin leoPlugins.py</vh></v>
<v t="ekr.20031218072017.3446"><vh>@thin leoTangle.py</vh></v>
<v t="ekr.20051104075904" annotate="7d71002e"
marks="ekr.20051104075904.12,"><vh>@thin leoTest.py</vh></v>
<v t="ekr.20031218072017.3603"><vh>@thin leoUndo.py</vh></v>
</v>
<v t="ekr.20031218072017.3625"><vh>Gui Base classes</vh>
<v t="ekr.20050721093241"><vh>&lt;&lt; about gui classes and gui plugins &gt;&gt;</vh></v>
<v t="ekr.20031218072017.3630"><vh>@thin leoCompare.py</vh></v>
<v t="ekr.20031218072017.3052"><vh>@thin leoFind.py</vh></v>
<v t="ekr.20031218072017.3655"
marks="ekr.20031218072017.2410,"><vh>@thin leoFrame.py</vh></v>
<v t="ekr.20031218072017.3719"><vh>@thin leoGui.py</vh></v>
<v t="ekr.20031218072017.3749"><vh>@thin leoMenu.py</vh></v>
</v>
<v t="ekr.20031218072017.3821"><vh>Gui Tkinter classes</vh>
<v t="ekr.20031218072017.3838"><vh>@thin leoTkinterComparePanel.py</vh></v>
<v t="ekr.20031218072017.3858"><vh>@thin leoTkinterDialog.py</vh></v>
<v t="ekr.20031218072017.3897"><vh>@thin leoTkinterFind.py</vh></v>
<v t="ekr.20031218072017.3939"><vh>@thin leoTkinterFrame.py</vh></v>
<v t="ekr.20031218072017.4047"><vh>@thin leoTkinterGui.py</vh></v>
<v t="ekr.20031218072017.4099"><vh>@thin leoTkinterKeys.py</vh></v>
<v t="ekr.20031218072017.4100"><vh>@thin leoTkinterMenu.py</vh></v>
<v t="ekr.20040803072955"><vh>@thin leoTkinterTree.py</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040430162943"></t>
<t tx="EKR.20040519090151.2"></t>
<t tx="EKR.20040519090151.3"></t>
<t tx="EKR.20040602125018">@ Enables the "idle" hook.
After enableIdleTimeHook is called, Leo will call the "idle" hook
approximately every g.idleTimeDelay milliseconds.
@c

def enableIdleTimeHook(idleTimeDelay=100):

    if not g.app.idleTimeHook:
        # g.trace('start idle-time hook: %d msec.' % idleTimeDelay)
        # Start idle-time processing only after the first idle-time event.
        g.app.gui.setIdleTimeHook(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
        
    # 1/4/05: Always update these.
    g.app.idleTimeHook = True
    g.app.idleTimeDelay = idleTimeDelay # Delay in msec.</t>
<t tx="EKR.20040602125018.1"># Disables the "idle" hook.
def disableIdleTimeHook():
    
    g.app.idleTimeHook = False</t>
<t tx="EKR.20040602125018.2"># An internal routine used to dispatch the "idle" hook.
trace_count = 0

def idleTimeHookHandler(*args,**keys):
    
    __pychecker__ = '--no-argsused' # args &amp; keys not used.
    
    if 0: # Do not use g.trace here!
        global trace_count ; trace_count += 1
        if trace_count % 10 == 0:
            for w in g.app.windowList:
                c = w.c
                print "idleTimeHookHandler",trace_count,c.shortFileName()

    # New for Python 2.3: may be called during shutdown.
    if g.app.killed: return
    
    top = g.top() # Important: only fire k.onIdleTime for the top window.
    for w in g.app.windowList:
        c = w.c
        # Do NOT compute c.currentPosition.
        # This would be a MAJOR leak of positions.
        # New in 4.4 a2: direct support for k.onIdleTime()
        if 0:
            c and c.keyHandler and c == top and c.keyHandler.onIdleTime()
        g.doHook("idle",c=c)

    # Requeue this routine after g.app.idleTimeDelay msec.
    # (This delay is set by g.enableIdleTimeHook.)
    # Faster requeues overload the system.
    if g.app.idleTimeHook:
        g.app.gui.setIdleTimeHookAfterDelay(g.idleTimeHookHandler)
        g.app.afterHandler = g.idleTimeHookHandler
    else:
        g.app.afterHandler = None</t>
<t tx="ekr.20031218072017.368"># Internally, lower case is used for all language names.
self.language_delims_dict = {
    "ada" : "--",
    "actionscript" : "// /* */", #jason 2003-07-03
    "c" : "// /* */", # C, C++ or objective C.
    "csharp" : "// /* */",	# C#
    "css" : "/* */", # 4/1/04
    "cweb" : "@q@ @&gt;", # Use the "cweb hack"
    "elisp" : ";",
    "forth" : "\\_ _(_ _)", # Use the "REM hack"
    "fortran" : "C",
    "fortran90" : "!",
    "html" : "&lt;!-- --&gt;",
    "java" : "// /* */",
    "latex" : "%",
    "pascal" : "// { }",
    "perl" : "#",
    "perlpod" : "# __=pod__ __=cut__", # 9/25/02: The perlpod hack.
    "php" : "//",
    "plain" : "#", # We must pick something.
    "plsql" : "-- /* */", # SQL scripts qt02537 2005-05-27
    "python" : "#",
    "rapidq" : "'", # fil 2004-march-11
    "rebol" : ";",  # jason 2003-07-03
    "shell" : "#",  # shell scripts
    "tcltk" : "#",
    "unknown" : "#" } # Set when @comment is seen.

self.language_extension_dict = {
    "ada" : "ads",
    "actionscript" : "as", #jason 2003-07-03
    "c" : "c",
    "css" : "css", # 4/1/04
    "cweb" : "w",
    "elisp" : "el",
    "forth" : "forth",
    "fortran" : "f",
    "fortran90" : "f",
    "html" : "html",
    "java" : "java",
    "latex" : "tex", # 1/8/04
    "noweb" : "nw",
    "pascal" : "p",
    "perl" : "perl",
    "perlpod" : "perl",
    "php" : "php",
    "plain" : "txt",
    "python" : "py",
    "plsql" : "sql", # qt02537 2005-05-27
    "rapidq" : "bas", # fil 2004-march-11
    "rebol" : "r",    # jason 2003-07-03
    "shell" : "sh",   # DS 4/1/04
    "tex" : "tex",
    "tcltk" : "tcl",
    "unknown" : "txt" } # Set when @comment is seen.
    
self.extension_dict = {
    "ads"   : "ada",
    "adb"   : "ada",
    "as"    : "actionscript",
    "bas"   : "rapidq",
    "c"     : "c",
    "css"   : "css",
    "el"    : "elisp",
    "forth" : "forth",
    "f"     : "fortran90", # or fortran ?
    "html"  : "html",
    "java"  : "java",
    "noweb" : "nw",
    "p"     : "pascal",
    "perl"  : "perl",
    "php"   : "php",
    "py"    : "python",
    "sql"   : "plsql", # qt02537 2005-05-27
    "r"     : "rebol",
    "sh"    : "shell",
    "tex"   : "tex",
    "txt"   : "plain",
    "tcl"   : "tcltk",
    "w"     : "cweb" }
</t>
<t tx="ekr.20031218072017.840"></t>
<t tx="ekr.20031218072017.998">def setCallback (self,*args,**keys):
    
    """Callback to adjust the scrollbar.
    
    Args is a tuple of two floats describing the fraction of the visible area."""

    # g.trace(self.tree.redrawCount,args)

    apply(self.treeBar.set,args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.setVisibleArea(args)
        
def yviewCallback (self,*args,**keys):
    
    """Tell the canvas to scroll"""
    
    # g.trace(vyiewCallback",args,keys)

    if self.tree.allocateOnlyVisibleNodes:
        self.tree.allocateNodesBeforeScrolling(args)

    apply(self.canvas.yview,args,keys)</t>
<t tx="ekr.20031218072017.1315"></t>
<t tx="ekr.20031218072017.1320">@ The &lt;Key&gt; event generates the event before the body text is changed(!), so we register an idle-event handler to do the work later.

1/17/02: Rather than trying to figure out whether the control or alt keys are down, we always schedule the idle_handler.  The idle_handler sees if any change has, in fact, been made to the body text, and sets the changed and dirty bits only if so.  This is the clean and safe way.

2/19/02: We must distinguish between commands like "Find, Then Change", that call onBodyChanged, and commands like "Cut" and "Paste" that call onBodyWillChange.  The former commands have already changed the body text, and that change must be captured immediately.  The latter commands have not changed the body text, and that change may only be captured at idle time.
@c

@others</t>
<t tx="ekr.20031218072017.1329"># Called by command handlers that may have already changed the text.

def onBodyChanged (self,p,undoType,oldSel=None,oldYview=None,newSel=None,oldText=None):
    
    '''Update Leo after the body *may* have been changed.

    This is a public convenience method: a thin wrapper for updateBody.'''
    
    c = self.c
    if not p:
        g.trace("can't happen: no p")
        return

    if p != c.currentPosition():
        g.trace("can't happen: not current position p")
        return

    self.c.frame.body.colorizer.interrupt()

    event = None ; w = c.frame.body.bodyCtrl

    self.updateBody(event,w,undoType,
        oldSel=oldSel,oldYview=oldYview,newSel=newSel,oldText=oldText)</t>
<t tx="ekr.20031218072017.1416">def __init__(self):

    # These ivars are the global vars of this program.
    self.afterHandler = None
    self.batchMode = False # True: run in batch mode.
    self.commandName = None # The name of the command being executed.
    self.config = None # The leoConfig instance.
    self.count = 0 # General purpose debugging count.
    self.debug = False # True: enable extra debugging tests (not used at present).
        # WARNING: this could greatly slow things down.
    self.debugSwitch = 0
        # 0: default behavior
        # 1: full traces in g.es_exception.
        # 2: call pdb.set_trace in g.es_exception, etc.
    self.dialogs = 0 # Count of open dialogs.
    self.disableSave = False
    self.globalConfigDir = None # The directory that is assumed to contain the global configuration files.
    self.gui = None # The gui class.
    self.hasOpenWithMenu = False # True: open with plugin has been loaded.
    self.hookError = False # True: suppress further calls to hooks.
    self.hookFunction = None # Application wide hook function.
    self.homeDir = None # The user's home directory.
    self.idle_imported = False # True: we have done an import idle
    self.idleTimeDelay = 100 # Delay in msec between calls to "idle time" hook.
    self.idleTimeHook = False # True: the global idleTimeHookHandler will reshedule itself.
    self.initing = True # True: we are initiing the app.
    self.killed = False # True: we are about to destroy the root window.
    self.leoID = None # The id part of gnx's.
    self.loadDir = None # The directory from which Leo was loaded.
    self.loadedPlugins = [] # List of loaded plugins that have signed on.
    self.log = None # The LeoFrame containing the present log.
    self.logIsLocked = False # True: no changes to log are allowed.
    self.logWaiting = [] # List of messages waiting to go to a log.
    self.menuWarningsGiven = False # True: supress warnings in menu code.
    self.newWorldOrder = False # True: redraw and shift focus at end of k.masterCommand
    self.nodeIndices = None # Singleton node indices instance.
    self.numberOfWindows = 0 # Number of opened windows.
    self.openWithFiles = [] # List of data used by Open With command.
    self.openWithFileNum = 0 # Used to generate temp file names for Open With command.
    self.openWithTable = None # The table passed to createOpenWithMenuFromTable.
    self.positions = 0 # Count of the number of positions generated.
    self.quitting = False # True if quitting.  Locks out some events.
    self.realMenuNameDict = {} # Contains translations of menu names and menu item names.
    self.root = None # The hidden main window. Set later.
    self.searchDict = {} # For communication between find/change scripts.
    self.scriptDict = {} # For communication between Execute Script command and scripts.
    self.trace = False # True: enable debugging traces.
    self.tracePositions = False
    self.trace_list = [] # "Sherlock" argument list for tracing().
    self.tkEncoding = "utf-8"
    self.unicodeErrorGiven = True # True: suppres unicode tracebacks.
    self.unitTestDict = {} # For communication between unit tests and code.
    self.unitTesting = False # True if unit testing.
    self.use_psyco = False # Can't be a config param because it is used before config module can be inited.
    self.user_xresources_path = None # Resource file for Tk/tcl.
    self.wantedCommander = None # Used by tkFrame.set_focus.
    self.windowList = [] # Global list of all frames.  Does not include hidden root window.

    # Global panels.  Destroyed when Leo ends.
    self.pythonFrame = None
    
    &lt;&lt; Define global constants &gt;&gt;
    &lt;&lt; Define global data structures &gt;&gt;</t>
<t tx="ekr.20031218072017.1417">self.prolog_string = "&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;"

# New in leo.py 3.0
self.prolog_prefix_string = "&lt;?xml version=\"1.0\" encoding="
self.prolog_postfix_string = "?&gt;"

# leo.py 3.11
self.use_unicode = True # True: use new unicode logic.
</t>
<t tx="ekr.20031218072017.1801">def __init__(self,title,gui):

    # Init the base class.
    leoFrame.leoFrame.__init__(self,gui)

    self.title = title

    leoTkinterFrame.instances += 1

    self.c = None # Set in finishCreate.
    self.iconBar = None

    &lt;&lt; set the leoTkinterFrame ivars &gt;&gt;</t>
<t tx="ekr.20031218072017.1802"># "Official ivars created in createLeoFrame and its allies.
self.bar1 = None
self.bar2 = None
self.body = None
self.bodyBar = None
self.bodyCtrl = None
self.bodyXBar = None
self.f1 = self.f2 = None
self.findPanel = None # Inited when first opened.
self.iconBarComponentName = 'iconBar'
self.iconFrame = None 
self.log = None
self.canvas = None
self.outerFrame = None
self.statusFrame = None
self.statusLineComponentName = 'statusLine'
self.statusText = None 
self.statusLabel = None 
self.top = None
self.tree = None
self.treeBar = None

# Used by event handlers...
self.controlKeyIsDown = False # For control-drags
self.draggedItem = None
self.isActive = True
self.redrawCount = 0
self.wantedWidget = None
self.wantedCallbackScheduled = False
self.scrollWay = None</t>
<t tx="ekr.20031218072017.1974">def destroySelf (self):
    
    top = self.top # Remember this: we are about to destroy all of our ivars!
    
    # g.trace(self)

    self.destroyAllObjects()

    top.destroy()</t>
<t tx="ekr.20031218072017.1975">def destroyAllObjects (self):

    """Clear all links to objects in a Leo window."""

    frame = self ; c = self.c ; tree = frame.tree ; body = self.body

    # Do this first.
    &lt;&lt; clear all vnodes and tnodes in the tree &gt;&gt;

    # Destroy all ivars in subcommanders.
    g.clearAllIvars(c.atFileCommands)
    g.clearAllIvars(c.fileCommands)
    g.clearAllIvars(c.importCommands)
    g.clearAllIvars(c.tangleCommands)
    g.clearAllIvars(c.undoer)
    g.clearAllIvars(c)
    g.clearAllIvars(body.colorizer)
    g.clearAllIvars(body)
    g.clearAllIvars(tree)

    # This must be done last.
    frame.destroyAllPanels()
    g.clearAllIvars(frame)</t>
<t tx="ekr.20031218072017.1976"># Using a dict here is essential for adequate speed.
vList = [] ; tDict = {}

for p in c.allNodes_iter():
    vList.append(p.v)
    if p.v.t:
        key = id(p.v.t)
        if not tDict.has_key(key):
            tDict[key] = p.v.t

for key in tDict.keys():
    g.clearAllIvars(tDict[key])

for v in vList:
    g.clearAllIvars(v)

vList = [] ; tDict = {} # Remove these references immediately.</t>
<t tx="ekr.20031218072017.2176">def finishCreate (self,c):
    
    f = self ; f.c = c
    # g.trace('tkFrame')
    
    # This must be done after creating the commander.
    f.splitVerticalFlag,f.ratio,f.secondary_ratio = f.initialRatios()
    f.createOuterFrames()
    f.createIconBarComponents()
    f.createSplitterComponents()
    f.createStatusLineComponents()
    f.createFirstTreeNode()
    f.menu = leoTkinterMenu.leoTkinterMenu(f)
        # c.finishCreate calls f.createMenuBar later.
    g.app.setLog(f.log,"tkinterFrame.__init__") # the leoTkinterFrame containing the log
    g.app.windowList.append(f)
    c.initVersion()
    c.signOnWithVersion()
    f.miniBufferWidget = f.createMiniBufferWidget()
    f.body.createBindings(f)</t>
<t tx="ekr.20031218072017.2253">def OnActivateLeoEvent(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    g.trace(g.callers(5))

    try:
        g.app.setLog(self.log,"OnActivateLeoEvent")
    except:
        g.es_event_exception("activate Leo")

def OnDeactivateLeoEvent(self,event=None):
    
    if 0: # This causes problems on the Mac.
        try:
            g.app.setLog(None,"OnDeactivateLeoEvent")
        except:
            g.es_event_exception("deactivate Leo")</t>
<t tx="ekr.20031218072017.2406">@language python
@tabwidth -4
@pagewidth 80

@ This section contains all the source code of leo.py.

Leo's code uses the following conventions throughout:

c:  a commander
ch: a character
d:  a dialog or a dict.
g:  the leoGlobal module.
i, j, k: indices into a string
p:  a position.
s:  a string
t:  a tnode or a text widget.
u:  an undoer
v:  a vnode

For more documentation, see the node called "Overview of Leo's code" in LeoDocs.leo.</t>
<t tx="ekr.20031218072017.2415"></t>
<t tx="ekr.20031218072017.2418">def initScriptFind(findHeadline,changeHeadline=None,firstNode=None,
    script_search=True,script_change=True):
        
    __pychecker__ = '--no-argsused' # firstNode is not used.
    
    import leoTest
    import leoGlobals as g

    # Find the scripts.
    c = g.top() ; p = c.currentPosition()
    u = leoTest.testUtils()
    find_p = u.findNodeInTree(p,findHeadline)
    if find_p:
        find_text = find_p.bodyString()
    else:
        g.es("no Find script node",color="red")
        return
    if changeHeadline:
        change_p = u.findNodeInTree(p,changeHeadline)
    else:
        change_p = None
    if change_p:
        change_text = change_p.bodyString()
    else:
        change_text = ""
    # print find_p,change_p
    
    # Initialize the find panel.
    c.script_search_flag = script_search
    c.script_change_flag = script_change and change_text
    if script_search:
        c.find_text = find_text.strip() + "\n"
    else:
        c.find_text = find_text
    if script_change:
        c.change_text = change_text.strip() + "\n"
    else:
        c.change_text = change_text
    c.frame.findPanel.init(c)
    c.showFindPanel()</t>
<t tx="ekr.20031218072017.2582"></t>
<t tx="ekr.20031218072017.2604"></t>
<t tx="ekr.20031218072017.2811"></t>
<t tx="ekr.20031218072017.2812">def __init__(self,frame,fileName):

    c = self
    
    # g.trace('Commands')
    
    # Init ivars with self.x instead of c.x to keep Pychecker happy
    self.frame = frame
    self.mFileName = fileName
        # Do _not_ use os_path_norm: it converts an empty path to '.' (!!)

    # g.trace(c) # Do this after setting c.mFileName.
    c.initIvars()

    self.useTextMinibuffer = True
    self.showMinibuffer = c.config.getBool('useMinibuffer')

    # initialize the sub-commanders.
    # c.finishCreate creates the sub-commanders for edit commands.
    self.fileCommands   = leoFileCommands.fileCommands(c)
    self.atFileCommands = leoAtFile.atFile(c)
    self.importCommands = leoImport.leoImportCommands(c)
    self.tangleCommands = leoTangle.tangleCommands(c)
    leoEditCommands.createEditCommanders(c)

    if 0 and g.debugGC:
        print ; print "*** using Null undoer ***" ; print
        self.undoer = leoUndo.nullUndoer(self)
    else:
        self.undoer = leoUndo.undoer(self)</t>
<t tx="ekr.20031218072017.2813">self._currentPosition = self.nullPosition()
self._rootPosition    = self.nullPosition()
self._topPosition     = self.nullPosition()

# For emacs/vim key handling.
self.commandsDict = None
self.keyHandler = None
self.miniBufferWidget = None

# per-document info...
self.disableCommandsMessage = ''
    # The presence of this message disables all commands.
self.hookFunction = None
self.openDirectory = None

self.expansionLevel = 0  # The expansion level of this outline.
self.expansionNode = None # The last node we expanded or contracted.
self.changed = False # True if any data has been changed since the last save.
self.loading = False # True if we are loading a file: disables c.setChanged()
self.outlineToNowebDefaultFileName = "noweb.nw" # For Outline To Noweb dialog.
self.promptingForClose = False # To lock out additional closing dialogs.

# For tangle/untangle
self.tangle_errors = 0

# Global options
self.page_width = 132
self.tab_width = -4
self.tangle_batch_flag = False
self.untangle_batch_flag = False
# Default Tangle options
self.tangle_directory = ""
self.use_header_flag = False
self.output_doc_flag = False
# Default Target Language
self.target_language = "python" # Required if leoConfig.txt does not exist.

# These are defined here, and updated by the tree.select()
self.beadList = [] # list of vnodes for the Back and Forward commands.
self.beadPointer = -1 # present item in the list.
self.visitedList = [] # list of positions for the Nodes dialog.

# For hoist/dehoist commands.
self.hoistStack = []
    # Stack of nodes to be root of drawn tree.
    # Affects drawing routines and find commands.
self.recentFiles = [] # List of recent files</t>
<t tx="ekr.20031218072017.2814">def __repr__ (self):
    
    return "Commander %d: %s" % (id(self),repr(self.mFileName))
        
__str__ = __repr__

</t>
<t tx="ekr.20031218072017.2949"></t>
<t tx="ekr.20031218072017.2950">def beginUpdate(self):
    
    if g.app.newWorldOrder:
        pass
    else:
        self.frame.tree.beginUpdate()
    
BeginUpdate = beginUpdate # Compatibility with old scripts</t>
<t tx="ekr.20031218072017.2951">def bringToFront(self):

    self.frame.deiconify()

BringToFront = bringToFront # Compatibility with old scripts</t>
<t tx="ekr.20031218072017.2952">def endUpdate(self, flag=True):
    
    '''End a beginUpdate/endUpdate region.
    
    Redraw the tree if this is the outermost endUpdate.
    
    Note that calls to g.es() will disable redraws, so calls to endUpdate
    should follow all such writes to the log pane.
    
    New in Python 4.4:  All of Leo's core code uses this pattern::
        
        c.beginUpdate()
        try:
            ...
        finally:
            c.endUpdate()
        
    Python automatically re-raises an exception after executing a finally block,
    so there is no need to do so here.'''
    
    if g.app.newWorldOrder:
        if flag:
            self.frame.requestRedraw = True
    else:
        try:
            self.frame.tree.endUpdate(flag)
        except Exception:
            pass
    
EndUpdate = endUpdate # Compatibility with old scripts</t>
<t tx="ekr.20031218072017.2953">def recolor(self):

    c = self

    c.frame.body.recolor(c.currentVnode())</t>
<t tx="ekr.20031218072017.2954">def redraw(self):
    
    if g.app.newWorldOrder:
        self.frame.requestRedraw = True
    else:
        self.frame.tree.redraw()
    
# Compatibility with old scripts
Redraw = redraw 
repaint = redraw
Repaint = redraw</t>
<t tx="ekr.20031218072017.3070"># Replace selection with self.change_text.
# If no selection, insert self.change_text at the cursor.

def changeSelection(self):

    c = self.c ; p = self.p ; gui = g.app.gui
    # g.trace(self.in_headline)
    t = g.choose(self.in_headline,p.edit_text(),c.frame.bodyCtrl)
    oldSel = sel = gui.getTextSelection(t)
    if sel and len(sel) == 2:
        start,end = sel
        if start == end:
            sel = None
    if not sel or len(sel) != 2:
        g.es("No text selected")
        return False

    # Replace the selection in _both_ controls.
    start,end = oldSel
    gui.replaceSelectionRangeWithText(t,          start,end,self.change_text)
    gui.replaceSelectionRangeWithText(self.s_ctrl,start,end,self.change_text)

    # Update the selection for the next match.
    gui.setSelectionRangeWithLength(t,start,len(self.change_text))
    newSel = gui.getTextSelection(t)
    c.frame.widgetWantsFocus(t,later=False)

    c.beginUpdate()
    try:
        if self.mark_changes: p.setMarked()
        # update node, undo status, dirty flag, changed mark &amp; recolor
        if self.in_headline:
            c.frame.tree.onHeadChanged(p,'Change')
        else:
            c.frame.body.onBodyChanged(p,'Change',oldSel=oldSel,newSel=newSel)
        c.frame.tree.drawIcon(p) # redraw only the icon.
    finally:
        c.endUpdate(False) # No redraws here: they would destroy the headline selection.
    return True</t>
<t tx="ekr.20031218072017.3625">&lt;&lt; about gui classes and gui plugins &gt;&gt;</t>
<t tx="ekr.20031218072017.3821"></t>
<t tx="ekr.20031218072017.3941"></t>
<t tx="ekr.20031218072017.3942">def __repr__ (self):

    return "&lt;leoTkinterFrame: %s&gt;" % self.title
</t>
<t tx="ekr.20031218072017.3944">def createCanvas (self,parentFrame,pack=True):
    
    c = self.c
    
    scrolls = c.config.getBool('outline_pane_scrolls_horizontally')
    scrolls = g.choose(scrolls,1,0)
    
    if use_Pmw and Pmw:
        canvas = self.createPmwTreeCanvas(parentFrame,scrolls,pack)
    else:
        canvas = self.createTkTreeCanvas(parentFrame,scrolls,pack)

    return canvas</t>
<t tx="ekr.20031218072017.3946">def resizePanesToRatio(self,ratio,ratio2):
    
    # g.trace(ratio,ratio2)
    
    if use_Pmw and Pmw:
        &lt;&lt; resize the Pmw panes &gt;&gt;
    else:
        self.divideLeoSplitter(self.splitVerticalFlag,ratio)
        self.divideLeoSplitter(not self.splitVerticalFlag,ratio2)</t>
<t tx="ekr.20031218072017.3947">def bindBar (self, bar, verticalFlag):

    if verticalFlag == self.splitVerticalFlag:
        bar.bind("&lt;B1-Motion&gt;", self.onDragMainSplitBar)

    else:
        bar.bind("&lt;B1-Motion&gt;", self.onDragSecondarySplitBar)</t>
<t tx="ekr.20031218072017.3949"># This is the general-purpose placer for splitters.
# It is the only general-purpose splitter code in Leo.

def divideAnySplitter (self, frac, verticalFlag, bar, pane1, pane2):

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        bar.place(rely=frac)
        pane1.place(relheight=frac)
        pane2.place(relheight=1-frac)
    else:
        # Panes arranged horizontally; vertical splitter bar
        bar.place(relx=frac)
        pane1.place(relwidth=frac)
        pane2.place(relwidth=1-frac)</t>
<t tx="ekr.20031218072017.3950"># Divides the main or secondary splitter, using the key invariant.
def divideLeoSplitter (self, verticalFlag, frac):

    if self.splitVerticalFlag == verticalFlag:
        self.divideLeoSplitter1(frac,verticalFlag)
        self.ratio = frac # Ratio of body pane to tree pane.
    else:
        self.divideLeoSplitter2(frac,verticalFlag)
        self.secondary_ratio = frac # Ratio of tree pane to log pane.

# Divides the main splitter.
def divideLeoSplitter1 (self, frac, verticalFlag): 
    self.divideAnySplitter(frac, verticalFlag,
        self.bar1, self.split1Pane1, self.split1Pane2)

# Divides the secondary splitter.
def divideLeoSplitter2 (self, frac, verticalFlag): 
    self.divideAnySplitter (frac, verticalFlag,
        self.bar2, self.split2Pane1, self.split2Pane2)</t>
<t tx="ekr.20031218072017.3951">def onDragMainSplitBar (self, event):
    self.onDragSplitterBar(event,self.splitVerticalFlag)

def onDragSecondarySplitBar (self, event):
    self.onDragSplitterBar(event,not self.splitVerticalFlag)

def onDragSplitterBar (self, event, verticalFlag):

    # x and y are the coordinates of the cursor relative to the bar, not the main window.
    bar = event.widget
    x = event.x
    y = event.y
    top = bar.winfo_toplevel()

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        wRoot	= top.winfo_rooty()
        barRoot = bar.winfo_rooty()
        wMax	= top.winfo_height()
        offset = float(barRoot) + y - wRoot
    else:
        # Panes arranged horizontally; vertical splitter bar
        wRoot	= top.winfo_rootx()
        barRoot = bar.winfo_rootx()
        wMax	= top.winfo_width()
        offset = float(barRoot) + x - wRoot

    # Adjust the pixels, not the frac.
    if offset &lt; 3: offset = 3
    if offset &gt; wMax - 2: offset = wMax - 2
    # Redraw the splitter as the drag is occuring.
    frac = float(offset) / wMax
    # g.trace(frac)
    self.divideLeoSplitter(verticalFlag, frac)</t>
<t tx="ekr.20031218072017.3952">def placeSplitter (self,bar,pane1,pane2,verticalFlag):

    if use_Pmw and Pmw:
        return

    if verticalFlag:
        # Panes arranged vertically; horizontal splitter bar
        pane1.place(relx=0.5, rely =   0, anchor="n", relwidth=1.0, relheight=0.5)
        pane2.place(relx=0.5, rely = 1.0, anchor="s", relwidth=1.0, relheight=0.5)
        bar.place  (relx=0.5, rely = 0.5, anchor="c", relwidth=1.0)
    else:
        # Panes arranged horizontally; vertical splitter bar
        # adj gives tree pane more room when tiling vertically.
        adj = g.choose(verticalFlag != self.splitVerticalFlag,0.65,0.5)
        pane1.place(rely=0.5, relx =   0, anchor="w", relheight=1.0, relwidth=adj)
        pane2.place(rely=0.5, relx = 1.0, anchor="e", relheight=1.0, relwidth=1.0-adj)
        bar.place  (rely=0.5, relx = adj, anchor="c", relheight=1.0)</t>
<t tx="ekr.20031218072017.3964"></t>
<t tx="ekr.20031218072017.3965">def destroyAllPanels (self):

    """Destroy all panels attached to this frame."""
    
    panels = (self.comparePanel, self.colorPanel, self.findPanel, self.fontPanel, self.prefsPanel)

    for panel in panels:
        if panel:
            panel.top.destroy()</t>
<t tx="ekr.20031218072017.3981">def abortEditLabelCommand (self):
    
    frame = self ; c = frame.c ; tree = frame.tree
    p = c.currentPosition() ; w = p.edit_text()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Abort Edit Headline")
        return
        
    # g.trace(p == tree.editPosition(),repr(tree.revertHeadline))
        
    if w and p == tree.editPosition():
        # Revert the headline text.
        w.delete("1.0","end")
        w.insert("end",tree.revertHeadline)
    
        # Duplicate relevant logic from tree.onHeadChanged.
        p.initHeadString(tree.revertHeadline)
        tree.endEditLabel()
        c.redraw()
        c.selectPosition(c.currentPosition())</t>
<t tx="ekr.20031218072017.3982">def endEditLabelCommand (self):

    frame = self ; c = frame.c
    
    if g.app.batchMode:
        c.notValidInBatchMode("End Edit Headline")
    else:
        p = c.currentPosition()
        c.frame.tree.onHeadChanged(p)
        c.selectPosition(p)
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20031218072017.3983">def insertHeadlineTime (self):

    frame = self ; c = frame.c ; p = c.currentPosition()
    
    if g.app.batchMode:
        c.notValidInBatchMode("Insert Headline Time")
        return
        
    c.editPosition(p)
    c.frame.tree.setNormalLabelState(p)
    w = p.edit_text()
    if w:
        time = c.getTime(body=False)
        if 1: # We can't know if we were already editing, so insert at end.
            g.app.gui.setSelectionRange(w,'end','end')
            w.insert('end',time)
        else:
            i, j = g.app.gui.getTextSelection(w)
            if i != j:
                w.delete(i,j)
            w.insert("insert",time)
        c.frame.tree.onHeadChanged(p,'Insert Headline Time')</t>
<t tx="ekr.20031218072017.4003">def hasFocus (self):
    
    return self.bodyCtrl == self.frame.top.focus_displayof()
    
def setFocus (self):
    
    self.bodyCtrl.focus_set()</t>
<t tx="ekr.20031218072017.4044">def hasFocus (self):
    
    return g.app.gui.get_focus(self.frame) == self.logCtrl</t>
<t tx="ekr.20031218072017.4045">def onActivateLog (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    try:
        g.app.setLog(self,"OnActivateLog")
        self.frame.tree.OnDeactivate()
        self.frame.logWantsFocus()
    except:
        g.es_event_exception("activate log")</t>
<t tx="ekr.20040321065415">def findNodeInTree(p,headline):

    """Search for a node in v's tree matching the given headline."""
    
    c = p.c
    for p in p.subtree_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()

def findNodeAnywhere(headline):
    
    c = g.top()
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()
    
def findTopLevelNode(headline):
    
    c = g.top()
    for p in c.rootPosition().self_and_siblings_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="ekr.20040327103735.2"></t>
<t tx="ekr.20040629121554">def getBuildNumber(self):
    c = self
    return c.ver[10:-1] # Strip off "(dollar)Revision" and the trailing "$"</t>
<t tx="ekr.20040629121554.1">def getSignOnLine (self):
    c = self
    return "Leo 4.4 alpha 2, build %s, November 2, 2005" % c.getBuildNumber()</t>
<t tx="ekr.20040629121554.2">def initVersion (self):
    c = self
    c.ver = "$Revision: 1.318 $" # CVS updates this.</t>
<t tx="ekr.20040629121554.3">def signOnWithVersion (self):

    c = self
    color = c.config.getColor("log_error_color")
    signon = c.getSignOnLine()
    n1,n2,n3,junk,junk=sys.version_info
    tkLevel = c.frame.top.getvar("tk_patchLevel")
    
    if sys.platform.startswith('win'):
        version = 'Windows '
        try:
            v = os.sys.getwindowsversion()
            version += ', '.join([str(z) for z in v])
        except Exception:
            pass
            
    else: version = sys.platform
    
    g.es("Leo Log Window...",color=color)
    g.es(signon)
    g.es("Python %d.%d.%d, Tk %s\n%s" % (n1,n2,n3,tkLevel,version))
    g.enl()</t>
<t tx="ekr.20040709081208"># New in 4.3: replaced global way with scrollWay ivar.
ev = threading.Event()

def run(self=self,canvas=canvas,ev=ev):

    while 1:
        ev.wait()
        if self.scrollWay =='Down': canvas.yview("scroll", 1,"units")
        else:                       canvas.yview("scroll",-1,"units")
        time.sleep(.1)

t = threading.Thread(target = run)
t.setDaemon(True)
t.start()

def scrollUp(event): scrollUpOrDown(event,'Down')
def scrollDn(event): scrollUpOrDown(event,'Up')
    
def scrollUpOrDown(event,theWay):
    if event.widget!=canvas: return
    if 0: # This seems to interfere with scrolling.
        if canvas.find_overlapping(event.x,event.y,event.x,event.y): return
    ev.set()
    self.scrollWay = theWay
        
def off(event,ev=ev,canvas=canvas):
    if event.widget!=canvas: return
    ev.clear()

if 1: # Use shift-click
    # Shift-button-1 scrolls up, Shift-button-2 scrolls down
    canvas.bind_all('&lt;Shift Button-3&gt;',scrollDn)
    canvas.bind_all('&lt;Shift Button-1&gt;',scrollUp)
    canvas.bind_all('&lt;Shift ButtonRelease-1&gt;',off)
    canvas.bind_all('&lt;Shift ButtonRelease-3&gt;',off)
else: # Use plain click.
    canvas.bind_all( '&lt;Button-3&gt;',scrollDn)
    canvas.bind_all( '&lt;Button-1&gt;',scrollUp)
    canvas.bind_all( '&lt;ButtonRelease-1&gt;',off)
    canvas.bind_all( '&lt;ButtonRelease-3&gt;',off)</t>
<t tx="ekr.20040722132104"></t>
<t tx="ekr.20040731071037">def initIvars(self):

    c = self
    &lt;&lt; initialize ivars &gt;&gt;
    self.config = configSettings(c)
    g.app.config.setIvarsFromSettings(c)</t>
<t tx="ekr.20040803072955.20">def createPermanentBindings (self):
    
    c = self.c ; canvas = self.canvas
    
    canvas.bind('&lt;Button-1&gt;',self.onTreeClick)

    if self.expanded_click_area:
        canvas.tag_bind('clickBox','&lt;Button-1&gt;', self.onClickBoxClick)
    else:
        canvas.tag_bind('plusBox','&lt;Button-1&gt;',   self.onClickBoxClick)

    canvas.tag_bind('iconBox','&lt;Button-1&gt;', self.onIconBoxClick)

    canvas.tag_bind('iconBox','&lt;Double-1&gt;', self.onIconBoxDoubleClick)
    canvas.tag_bind('iconBox','&lt;Button-3&gt;', self.onIconBoxRightClick)
    canvas.tag_bind('iconBox','&lt;B1-Motion&gt;',            self.onDrag)
    canvas.tag_bind('iconBox','&lt;Any-ButtonRelease-1&gt;',  self.onEndDrag)

    if self.useBindtags: # Create a dummy widget to hold all bindings.
        t = self.bindingWidget
        t.bind("&lt;Button-1&gt;", self.onHeadlineClick, '+')
        t.bind("&lt;Button-3&gt;", self.onHeadlineRightClick, '+')
        t.bind("&lt;Key&gt;",      self.onHeadlineKey)
            # There must be only one general key handler.

        if 0: # This does not appear necessary in 4.4.
            t.bind("&lt;Control-t&gt;",self.onControlT)</t>
<t tx="ekr.20040803072955.35"></t>
<t tx="ekr.20040803072955.36">def drawBox (self,p,x,y):

    tree = self ; c = self.c
    y += 7 # draw the box at x, y+7
    
    theId = g.doHook("draw-outline-box",tree=tree,c=c,p=p,v=p,x=x,y=y)
        
    if theId is None:
        iconname = g.choose(p.isExpanded(),"minusnode.gif", "plusnode.gif")
        image = self.getIconImage(iconname)
        theId = self.newBox(p,x,y+self.lineyoffset,image)
        return theId
    else:
        return theId</t>
<t tx="ekr.20040803072955.37">def drawClickBox (self,p,y):

    h = self.line_height
    
    # Define a slighly larger rect to catch clicks.
    if self.expanded_click_area:
        self.newClickBox(p,0,y,1000,y+h-2)
        
        if 0: # A major change to the user interface.
            &lt;&lt; change the appearance of headlines &gt;&gt;</t>
<t tx="ekr.20040803072955.38">
# Define a slighly smaller rect to colorize.
color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
self.canvas.itemconfig(color_rect,fill=defaultColor,outline=defaultColor)

# Color the click box or the headline
def enterRect(event,id=color_rect,p=p,t=self.lastText):
    if 1: # Color or underline the headline
        t2 = self.lastColoredText
        if t2: # decolor the old headline.
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # decolor
                t2.configure(background="white")
        if t and p != self.editPosition():
            if 1: # underline
                t.tag_add('underline','1.0','end')
                t.tag_configure('underline',underline=True)
            else: # color
                t.configure(background="LightSteelBlue1")
            self.lastColoredText = t
        else: self.lastColoredText = None
    else: # Color the click box.
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill=defaultColor,outline=defaultColor)
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)

bind_id = self.canvas.tag_bind(click_rect, "&lt;Enter&gt;", enterRect) # , '+')
self.tagBindings.append((click_rect,bind_id,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040803072955.39">def drawIcon(self,p,x=None,y=None):
    
    """Draws icon for position p at x,y, or at p.v.iconx,p.v.icony if x,y = None,None"""

    c = self.c
    &lt;&lt; compute x,y and iconVal &gt;&gt;

    if not g.doHook("draw-outline-icon",tree=self,c=c,p=p,v=p,x=x,y=y):

        # Get the image.
        imagename = "box%02d.GIF" % val
        image = self.getIconImage(imagename)
        self.newIcon(p,x,y+self.lineyoffset,image)
        
    return 0,self.icon_width # dummy icon height,width</t>
<t tx="ekr.20040803072955.40">v = p.v

if x is None and y is None:
    try:
        x,y = v.iconx, v.icony
    except:
        # Inject the ivars.
        x,y = v.iconx, v.icony = 0,0
else:
    # Inject the ivars.
    v.iconx, v.icony = x,y

y += 2 # draw icon at y + 2

# Always recompute v.iconVal.
# This is an important drawing optimization.
val = v.iconVal = v.computeIcon()
assert(0 &lt;= val &lt;= 15)</t>
<t tx="ekr.20040803072955.41">def drawLine (self,p,x1,y1,x2,y2):
    
    theId = self.newLine(p,x1,y1,x2,y2)
    
    return theId
</t>
<t tx="ekr.20040803072955.42">def drawNode(self,p,x,y):
    
    c = self.c
    
    data = g.doHook("draw-outline-node",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    if self.trace and self.verbose:
        print # Helps format traces

    if 1:
        self.lineyoffset = 0
    else:
        if hasattr(p.v.t,"unknownAttributes"):
            self.lineyoffset = p.v.t.unknownAttributes.get("lineYOffset",0)
        else:
            self.lineyoffset = 0
    
    # Draw the horizontal line.
    self.drawLine(p,
        x,y+7+self.lineyoffset,
        x+self.box_width,y+7+self.lineyoffset)
    
    if self.inVisibleArea(y):
        return self.force_draw_node(p,x,y)
    else:
        return self.line_height,0</t>
<t tx="ekr.20040803072955.43">def force_draw_node(self,p,x,y):

    h = 0 # The total height of the line.
    indent = 0 # The amount to indent this line.
    
    h2,w2 = self.drawUserIcons(p,"beforeBox",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    if p.hasChildren():
        self.drawBox(p,x,y)

    indent += self.box_width
    x += self.box_width # even if box isn't drawn.

    h2,w2 = self.drawUserIcons(p,"beforeIcon",x,y)
    h = max(h,h2) ; x += w2 ; indent += w2

    h2,w2 = self.drawIcon(p,x,y)
    h = max(h,h2) ; x += w2 ; indent += w2/2
    
    # Nothing after here affects indentation.
    h2,w2 = self.drawUserIcons(p,"beforeHeadline",x,y)
    h = max(h,h2) ; x += w2

    h2 = self.drawText(p,x,y)
    h = max(h,h2)
    x += self.widthInPixels(p.headString())

    h2,w2 = self.drawUserIcons(p,"afterHeadline",x,y)
    h = max(h,h2)
    
    self.drawClickBox(p,y)

    return h,indent</t>
<t tx="ekr.20040803072955.44">def drawText(self,p,x,y):
    
    """draw text for position p at nominal coordinates x,y."""
    
    assert(p)

    c = self.c
    x += self.text_indent
    
    data = g.doHook("draw-outline-text-box",tree=self,c=c,p=p,v=p,x=x,y=y)
    if data is not None: return data
    
    self.newText(p,x,y+self.lineyoffset)

    if 0: # old, experimental code.
        &lt;&lt; highlight text widget on enter events &gt;&gt;
   
    self.configureTextState(p)

    return self.line_height</t>
<t tx="ekr.20040803072955.45"># t is the widget returned by self.newText.

canvas = self.canvas
h = self.line_height

if 0: # Define a rect to colorize.

    color_rect = self.canvas.create_rectangle(0,y,1000,y+h-4,tag="colorBox")
    self.canvas.itemconfig(color_rect,fill="",outline="")

    def enterRect(event,id=color_rect):
        if self.lastClickFrameId:
            self.canvas.itemconfig(self.lastClickFrameId,fill="",outline="")
        self.lastClickFrameId = id
        color = "LightSteelBlue1"
        self.canvas.itemconfig(id,fill=color,outline=color)
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)
    
if 0: # Colorize only the headline.

    def enterRect(event,p=p,t=t):
        t2 = self.lastColoredText
        if t2:
            if 1: # deunderline
                t2.tag_delete('underline')
            else: # color
                t2.configure(background="white")
        if p == self.editPosition():
            self.lastColoredText = None
        else:
            self.lastColoredText = t
            if 1: # underline
                t.tag_add('underline','1.0', 'end')
                t.tag_configure('underline',underline = True)
            else: #color
                t.configure(background="LightSteelBlue1")
    
    bind_enter = t.bind( '&lt;Enter&gt;', enterRect, '+' )
    self.bindings.append((t,bind_enter,"&lt;Enter&gt;"),)</t>
<t tx="ekr.20040803072955.46">def drawUserIcons(self,p,where,x,y):
    
    """Draw any icons specified by p.v.t.unknownAttributes["icons"]."""
    
    h,w = 0,0 ; t = p.v.t
    
    if not hasattr(t,"unknownAttributes"):
        return h,w
    
    iconsList = t.unknownAttributes.get("icons")
    if not iconsList:
        return h,w
    
    try:
        for theDict in iconsList:
            h2,w2 = self.drawUserIcon(p,where,x,y,w,theDict)
            h = max(h,h2) ; w += w2
    except:
        g.es_exception()
        
    # g.trace(where,h,w)

    return h,w</t>
<t tx="ekr.20040803072955.47">def drawUserIcon (self,p,where,x,y,w2,theDict):
    
    h,w = 0,0

    if where != theDict.get("where","beforeHeadline"):
        return h,w

    # g.trace(where,x,y,theDict)
    
    &lt;&lt; set offsets and pads &gt;&gt;
    theType = theDict.get("type")
    if theType == "icon":
        if 0: # not ready yet.
            s = theDict.get("icon")
            &lt;&lt; draw the icon in string s &gt;&gt;
    elif theType == "file":
        theFile = theDict.get("file")
        &lt;&lt; draw the icon at file &gt;&gt;
    elif theType == "url":
        ## url = theDict.get("url")
        &lt;&lt; draw the icon at url &gt;&gt;
        
    # Allow user to specify height, width explicitly.
    h = theDict.get("height",h)
    w = theDict.get("width",w)

    return h,w</t>
<t tx="ekr.20040803072955.48">xoffset = theDict.get("xoffset")
try:    xoffset = int(xoffset)
except: xoffset = 0

yoffset = theDict.get("yoffset")
try:    yoffset = int(yoffset)
except: yoffset = 0

xpad = theDict.get("xpad")
try:    xpad = int(xpad)
except: xpad = 0

ypad = theDict.get("ypad")
try:    ypad = int(ypad)
except: ypad = 0</t>
<t tx="ekr.20040803072955.49">pass</t>
<t tx="ekr.20040803072955.50">try:
    image = self.iconimages[theFile]
    # Get the image from the cache if possible.
except KeyError:
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",theFile)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[fullname] = image
    except:
        #g.es("Exception loading: " + fullname)
        #g.es_exception()
        image = None
        
if image:
    theId = self.canvas.create_image(
        x+xoffset+w2,y+yoffset,
        anchor="nw",image=image,tag="userIcon")
    self.ids[theId] = p

    assert(theId not in self.visibleIcons)
    self.visibleUserIcons.append(theId)

    h = image.height() + yoffset + ypad
    w = image.width()  + xoffset + xpad

</t>
<t tx="ekr.20040803072955.51">pass</t>
<t tx="ekr.20040803072955.52">def drawTopTree (self):
    
    """Draws the top-level tree, taking into account the hoist state."""
    
    c = self.c ; canvas = self.canvas
    
    if 0:
        self.redrawCount += 1
        g.trace(self.redrawCount,g.callers(5))

    self.redrawing = True
    
    # Recycle all widgets.
    self.recycleWidgets()
    # Clear all ids so invisible id's don't confuse eventToPosition &amp; findPositionWithIconId
    self.ids = {}
    self.iconIds = {}
    self.generation += 1
    self.drag_p = None # Disable drags across redraws.
    self.dragging = False
    if self.trace:
        if self.verbose:
            print ; print
        delta = g.app.positions - self.prevPositions
        g.trace("**** gen: %3d positions: %5d +%4d" % (
            self.generation,g.app.positions,delta))
    self.prevPositions = g.app.positions

    if c.hoistStack:
        bunch = c.hoistStack[-1]
        self.drawTree(bunch.p,self.root_left,self.root_top,0,0,hoistFlag=True)
    else:
        self.drawTree(c.rootPosition(),self.root_left,self.root_top,0,0)
    
    canvas.lower("lines")  # Lowest.
    canvas.lift("textBox") # Not the Tk.Text widget: it should be low.
    canvas.lift("userIcon")
    canvas.lift("plusBox")
    canvas.lift("clickBox")
    canvas.lift("iconBox") # Higest.

    self.redrawing = False</t>
<t tx="ekr.20040803072955.53">def drawTree(self,p,x,y,h,level,hoistFlag=False):

    tree = self ; c = self.c
    yfirst = ylast = y
    h1 = None
    
    data = g.doHook("draw-sub-outline",tree=tree,
        c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
    if data is not None: return data
    
    while p: # Do not use iterator.
        # N.B. This is the ONLY copy of p that needs to be made.
        # No other drawing routine calls any p.moveTo method.
        const_p = p.copy()
        h,indent = self.drawNode(const_p,x,y)
        if h1 is None: h1 = h
        y += h ; ylast = y
        if p.isExpanded() and p.hasFirstChild():
            # Must make an additional copy here by calling firstChild.
            y = self.drawTree(p.firstChild(),x+indent,y,h,level+1)
        if hoistFlag: break
        else:         p = p.next()
        # g.trace(p)
        
    # Draw the vertical line.
    if level==0: # Special case to get exposed first line exactly right.
        self.drawLine(None,x,yfirst+(h1-1)/2,x,ylast+self.hline_y-h)
    else:
        self.drawLine(None,x,yfirst-h1/2-1,x,ylast+self.hline_y-h)
    return y</t>
<t tx="ekr.20040803072955.54"></t>
<t tx="ekr.20040803072955.55"># Calling redraw inside c.beginUpdate()/c.endUpdate() does nothing.
# This _is_ useful when a flag is passed to c.endUpdate.

def redraw (self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace('*'*20,self.redrawCount,self.updateCount,g.callers(5))
    
    if g.app.newWorldOrder:
        self.c.frame.requestRedraw = True
    else:
        if self.updateCount == 0 and not self.redrawScheduled:
            self.redrawScheduled = True
            self.canvas.after_idle(self.idle_redraw)</t>
<t tx="ekr.20040803072955.56">@ This is called only from doCommand.  The implicit assumption is that doCommand itself is not contained in a beginUpdate/endUpdate pair.
@c

def redrawAfterException (self):
    
    """Make sure drawing is enabled following an exception."""
    
    if g.app.newWorldOrder:
        self.c.frame.requestRedraw = True
    else:
        if not self.redrawScheduled:
            # g.trace('*'*20,self.redrawCount,g.callers(5))
            self.redrawScheduled = True
            self.canvas.after_idle(self.idle_redraw)
            self.updateCount = 0 # would not work if we are in a beginUpdate/endUpdate pair.</t>
<t tx="ekr.20040803072955.57"># Schedules a redraw even if inside beginUpdate/endUpdate
def force_redraw (self):
    
    if g.app.newWorldOrder:
        self.c.frame.requestRedraw = True
    else:
        if not self.redrawScheduled:
            # g.trace('*'*20,self.redrawCount,self.updateCount,g.callers(5))
            self.redrawScheduled = True
            self.canvas.after_idle(self.idle_redraw)</t>
<t tx="ekr.20040803072955.58"># Redraws immediately: used by Find so a redraw doesn't mess up selections in headlines.

def redraw_now (self,scroll=True):
    
    # Bug fix: Cancel any pending redraw "by hand".
    # Make _sure_ that no other redraws take place after this.

    if not g.app.newWorldOrder:
        self.disableRedraw = True
        self.canvas.update_idletasks()
        self.disableRedraw = False
        
    # Now do the actual redraw.

    g.trace('*'*20,self.redrawCount,self.updateCount,g.callers(5))
    self.idle_redraw(scroll=scroll)
    self.c.frame.requestRedraw = False</t>
<t tx="ekr.20040803072955.59">def idle_redraw (self,scroll=True):
    
    c = self.c ; frame = c.frame

    self.redrawScheduled = False # Always do this here.

    &lt;&lt; return if disabled, or quitting or dragging &gt;&gt;

    # g.print_bindings("canvas",self.canvas)
    g.trace(self.redrawCount,self.updateCount,g.callers(5))

    self.expandAllAncestors(c.currentPosition())

    oldcursor = self.canvas['cursor']
    self.canvas['cursor'] = "watch"

    if not g.doHook("redraw-entire-outline",c=c):
        c.setTopVnode(None)
        self.setVisibleAreaToFullCanvas()
        self.drawTopTree()
        # Set up the scroll region after the tree has been redrawn.
        x0, y0, x1, y1 = self.canvas.bbox("all")
        self.canvas.configure(scrollregion=(0, 0, x1, y1))
        # Do a scrolling operation after the scrollbar is redrawn
        if scroll:
            if g.app.newWorldOrder:
                self.idle_scrollTo(c.currentPosition())
            else:
                self.canvas.after_idle(self.idle_scrollTo)
        if 0:
            self.redrawCount += 1
            print "idle_redraw allocated:",self.redrawCount
    g.doHook("after-redraw-outline",c=c)

    self.canvas['cursor'] = oldcursor</t>
<t tx="ekr.20040803072955.60"># g.trace('disableRedraw',self.disableRedraw)

if self.disableRedraw:
    # We have been called as the result of an update_idletasks in the log pane.
    # Don't do anything now.
    return

if frame not in g.app.windowList or g.app.quitting:
    # g.trace("no frame")
    return

if self.drag_p:
    # g.trace("dragging",self.drag_p)
    return</t>
<t tx="ekr.20040803072955.61">def idle_second_redraw (self):
    
    c = self.c
        
    # Erase and redraw the entire tree the SECOND time.
    # This ensures that all visible nodes are allocated.
    c.setTopVnode(None)
    args = self.canvas.yview()
    self.setVisibleArea(args)
    
    if 0:
        self.deleteBindings()
        self.canvas.delete("all")

    self.drawTopTree()
    
    if self.trace:
        print "idle_second_redraw allocated:",self.redrawCount</t>
<t tx="ekr.20040803072955.62"></t>
<t tx="ekr.20040803072955.63">def inVisibleArea (self,y1):
    
    if self.allocateOnlyVisibleNodes:
        if self.visibleArea:
            vis1,vis2 = self.visibleArea
            y2 = y1 + self.line_height
            return y2 &gt;= vis1 and y1 &lt;= vis2
        else: return False
    else:
        return True # This forces all nodes to be allocated on all redraws.
        
def inExpandedVisibleArea (self,y1):
    
    if self.expandedVisibleArea:
        vis1,vis2 = self.expandedVisibleArea
        y2 = y1 + self.line_height
        return y2 &gt;= vis1 and y1 &lt;= vis2
    else:
        return False</t>
<t tx="ekr.20040803072955.64">def getIconImage (self, name):

    # Return the image from the cache if possible.
    if self.iconimages.has_key(name):
        return self.iconimages[name]
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=self.canvas,file=fullname)
        self.iconimages[name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20040803072955.65">def idle_scrollTo(self,p=None):

    """Scrolls the canvas so that p is in view.
    
    This is done at idle time after a redraw so that treeBar.get() will return proper values."""
    
    __pychecker__ = '--no-argsused' # event not used.

    c = self.c ; frame = c.frame
    if not p or not p.exists(c):
        p = c.currentPosition()
    if not p or not p.exists(c):
        # g.trace('current p does not exist',p)
        p = c.rootPosition()
    if not p or not p.exists(c):
        # g.trace('no position')
        return
    try:
        last = p.lastVisible()
        nextToLast = last.visBack()
        h1 = self.yoffset(p)
        h2 = self.yoffset(last)
        &lt;&lt; compute approximate line height &gt;&gt;
        &lt;&lt; Compute the fractions to scroll down/up &gt;&gt;
        if frac &lt;= lo:
            if self.prevMoveToFrac != frac:
                self.prevMoveToFrac = frac
                self.canvas.yview("moveto",frac)
        elif frac2 + (hi - lo) &gt;= hi:
            if self.prevMoveToFrac != frac2:
                self.prevMoveToFrac = frac2
                self.canvas.yview("moveto",frac2)

        if self.allocateOnlyVisibleNodes:
            self.canvas.after_idle(self.idle_second_redraw)
            
        c.setTopVnode(p) # 1/30/04: remember a pseudo "top" node.
        # g.trace("%3d %3d %1.3f %1.3f %1.3f %1.3f" % (h1,h2,frac,frac2,lo,hi))
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.66">if nextToLast: # 2/2/03: compute approximate line height.
    lineHeight = h2 - self.yoffset(nextToLast)
else:
    lineHeight = 20 # A reasonable default.</t>
<t tx="ekr.20040803072955.67">data = frame.treeBar.get()
try: lo, hi = data
except: lo,hi = 0.0,1.0
if h2 &gt; 0.1:
    frac = float(h1)/float(h2) # For scrolling down.
    frac2 = float(h1+lineHeight/2)/float(h2) # For scrolling up.
    frac2 = frac2 - (hi - lo)
else:
    frac = frac2 = 0.0 # probably any value would work here.
    
frac =  max(min(frac,1.0),0.0)
frac2 = max(min(frac2,1.0),0.0)</t>
<t tx="ekr.20040803072955.68">def numberOfVisibleNodes(self):
    
    n = 0 ; p = self.c.rootPosition()
    while p:
        n += 1
        p.moveToVisNext()
    return n</t>
<t tx="ekr.20040803072955.69">def scrollTo (self,p):

    if g.app.newWorldOrder:
         self.idle_scrollTo(p)
    else:
        def scrollToCallback(event=None,self=self,p=p):
            __pychecker__ = '--no-argsused' # event not used.
            self.idle_scrollTo(p)

        self.canvas.after_idle(scrollToCallback)</t>
<t tx="ekr.20040803072955.70">@ We can't just return icony because the tree hasn't been redrawn yet.
For the same reason we can't rely on any TK canvas methods here.
@c

def yoffset(self,p1):
    # if not p1.isVisible(): print "yoffset not visible:",p1
    root = self.c.rootPosition()
    h,flag = self.yoffsetTree(root,p1)
    # flag can be False during initialization.
    # if not flag: print "yoffset fails:",h,v1
    return h

def yoffsetTree(self,p,p1):
    h = 0
    if not p.exists(self.c): return h,False # An extra precaution.
    p = p.copy()
    for p2 in p.siblings_iter():
        # print "yoffsetTree:", p2
        if p2 == p1:
            return h, True
        h += self.line_height
        if p2.isExpanded() and p2.hasChildren():
            child = p2.firstChild()
            h2, flag = self.yoffsetTree(child,p1)
            h += h2
            if flag: return h, True
    return h, False</t>
<t tx="ekr.20040803072955.71"></t>
<t tx="ekr.20040803072955.72">def checkWidgetList (self,tag):
    
    return True # This will fail when the headline actually changes!
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
            
            if h != s:
                self.dumpWidgetList(tag)
                return False
        else:
            self.dumpWidgetList(tag)
            return False
            
    return True</t>
<t tx="ekr.20040803072955.73">def dumpWidgetList (self,tag):
    
    print
    print "checkWidgetList: %s" % tag
    
    for t in self.visibleText:
        
        p = t.leo_position
        if p:
            s = t.get("1.0","end").strip()
            h = p.headString().strip()
    
            addr = self.textAddr(t)
            print "p:",addr,h
            if h != s:
                print "t:",'*' * len(addr),s
        else:
            print "t.leo_position == None",t</t>
<t tx="ekr.20040803072955.74">def eventToPosition (self,event):

    canvas = self.canvas
    x,y = event.x,event.y
    # 7/28/04: Not doing this translation was the real bug.
    x = canvas.canvasx(x) 
    y = canvas.canvasy(y)
    if self.trace: g.trace(x,y)
    item = canvas.find_overlapping(x,y,x,y)
    if not item: return None

    # Item may be a tuple, possibly empty.
    try:    theId = item[0]
    except: theId = item
    if not theId: return None

    p = self.ids.get(theId)
    
    # A kludge: p will be None for vertical lines.
    if not p:
        item = canvas.find_overlapping(x+1,y,x+1,y)
        try:    theId = item[0]
        except: theId = item
        if not theId: return None
        p = self.ids.get(theId)
        # g.trace("was vertical line",p)
    
    if self.trace and self.verbose:
        if p:
            w = self.findEditWidget(p)
            g.trace("%3d %3d %3d %d" % (theId,x,y,id(w)),p.headString())
        else:
            g.trace("%3d %3d %3d" % (theId,x,y),None)
        
    # defensive programming: this copy is not needed.
    if p: return p.copy() # Make _sure_ nobody changes this table!
    else: return None</t>
<t tx="ekr.20040803072955.75">def edit_text (self,p):
    
    """Returns the Tk.Edit widget for position p."""

    return self.findEditWidget(p)</t>
<t tx="ekr.20040803072955.76"># Search the widget list for widget t with t.leo_position == p.

def findEditWidget (self,p):
    
    """Return the Tk.Text item corresponding to p."""

    c = self.c
    
    if c:
        # New in 4.2: the dictionary is a list of pairs(p,v)
        pairs = self.visibleText.get(p.v,[])
        for p2,t2,id2 in pairs:
            assert t2.leo_window_id == id2
            assert t2.leo_position == p2
            if p.equal(p2):
                # g.trace('found',t2)
                return t2
        
    # g.trace(not found',p.headString())
    return None</t>
<t tx="ekr.20040803072955.78"></t>
<t tx="ekr.20040803072955.79">def onClickBoxClick (self,event):
    
    c = self.c
    
    if self.trace and self.verbose: g.trace()
    p = self.eventToPosition(event)
    if not p: return

    if not g.doHook("boxclick1",c=c,p=p,v=p,event=event):
        if p.isExpanded(): p.contract()
        else:              p.expand()
        self.active = True
        # Schedule the redraw _before_ calling select.
        # This disables any call that would configure old text widgets.
        if g.app.newWorldOrder:
            self.redraw_now()
        else:
            self.redraw()
        self.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
        if self.stayInTree:
            c.frame.treeWantsFocus()
        else:
            c.frame.bodyWantsFocus()
    g.doHook("boxclick2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20040803072955.80"></t>
<t tx="ekr.20040803072955.81">def onIconBoxClick (self,event):
    
    c = self.c ; tree = self
    
    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    if not g.doHook("iconclick1",c=c,p=p,v=p,event=event):
        if event:
            self.onDrag(event)
        tree.select(p)
        if c.frame.findPanel:
            c.frame.findPanel.handleUserClick(p)
    g.doHook("iconclick2",c=c,p=p,v=p,event=event)
        
    return "break" # disable expanded box handling.</t>
<t tx="ekr.20040803072955.82">def onIconBoxDoubleClick (self,event):
    
    c = self.c

    p = self.eventToPosition(event)
    if not p: return
    
    if self.trace and self.verbose: g.trace()
    
    try:
        if not g.doHook("icondclick1",c=c,p=p,v=p,event=event):
            self.OnIconDoubleClick(p) # Call the method in the base class.
        g.doHook("icondclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("icondclick")</t>
<t tx="ekr.20040803072955.83">def onHeadlineRightClick (self,event):

    """Handle a right click in any outline widget."""

    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"

    try:
        if not g.doHook("headrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("headrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headrclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.84"></t>
<t tx="ekr.20040803072955.85">def configureTextState (self,p):
    
    if not p: return
    
    if p.isCurrentPosition():
        if p == self.editPosition():
            self.setNormalLabelState(p)
        else:
            self.setDisabledLabelState(p) # selected, disabled
    else:
        self.setUnselectedLabelState(p) # unselected</t>
<t tx="ekr.20040803072955.86"># This works around an apparent Tk bug.

def onControlT (self,event=None):

    # If we don't inhibit further processing the Tx.Text widget switches characters!
    return "break"</t>
<t tx="ekr.20040803072955.87">def onHeadlineClick (self,event):
    
    c = self.c ; w = event.widget
    
    try:
        p = w.leo_position
    except AttributeError:
        return "continue"
        
    # g.trace(p.headString())
    
    try:
        if not g.doHook("headclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
        g.doHook("headclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("headclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.88">def onHeadlineKey (self,event):
    
    """Handle a key event in a headline."""
    
    w = event and event.widget or None
    
    self.updateHead(event,w)

    return 'break' # Required</t>
<t tx="ekr.20040803072955.89">def onIconBoxRightClick (self,event):
    
    """Handle a right click in any outline widget."""

    c = self.c
    
    p = self.eventToPosition(event)
    if not p: return

    try:
        if not g.doHook("iconrclick1",c=c,p=p,v=p,event=event):
            self.OnActivateHeadline(p)
            self.endEditLabel()
            self.OnPopup(p,event)
        g.doHook("iconrclick2",c=c,p=p,v=p,event=event)
    except:
        g.es_event_exception("iconrclick")
        
    return "continue"</t>
<t tx="ekr.20040803072955.90"></t>
<t tx="ekr.20040803072955.91"># Tricky code: do not change without careful thought and testing.

def onHeadChanged (self,p,undoType='Typing'):
    
    '''Officially change a headline.
    Set the old undo text to the previous revert point.'''
    
    c = self.c ; u = c.undoer ; w = p and self.edit_text(p)
    if not w:
        # g.trace('no widget')
        return

    s = w.get('1.0','end')
    &lt;&lt; truncate s if it has multiple lines &gt;&gt;
    changed = s != p.headString()
    
    # Make the change official, but undo to the *old* revert point.
    oldRevert = self.revertHeadline
    self.revertHeadline = s
    p.initHeadString(s)
    # Do not call endEditLabel here: we may have been called from there.
    if p and p.edit_text():
        self.setEditPosition(None)
    if not changed: return

    # g.trace('undo to:',oldRevert)
    undoData = u.beforeChangeNodeContents(p,oldHead=oldRevert)

    c.beginUpdate()
    try:
        if not c.changed: c.setChanged(True)
        dirtyVnodeList = p.setDirty()
    finally:
        c.endUpdate()

    u.afterChangeNodeContents(p,undoType,undoData,
        dirtyVnodeList=dirtyVnodeList)</t>
<t tx="ekr.20040803072955.94"># Remove one or two trailing newlines before warning of truncation.
for i in (0,1):
    if s and s[-1] == '\n':
        if len(s) &gt; 1: s = s[:-1]
        else: s = ''

# Warn if there are multiple lines.
i = s.find('\n')
if i &gt; -1:
    # g.trace(i,len(s),repr(s))
    g.es("Truncating headline to one line",color="blue")
    s = s[:i]

limit = 1000
if len(s) &gt; limit:
    g.es("Truncating headline to %d characters" % (limit),color="blue")
    s = s[:limit]

s = g.toUnicode(s or '',g.app.tkEncoding)</t>
<t tx="ekr.20040803072955.99"></t>
<t tx="ekr.20040803072955.100">def onContinueDrag(self,event):
    
    p = self.drag_p
    if not p: return

    try:
        canvas = self.canvas ; frame = self.c.frame
        if event:
            x,y = event.x,event.y
        else:
            x,y = frame.top.winfo_pointerx(),frame.top.winfo_pointery()
            # Stop the scrolling if we go outside the entire window.
            if x == -1 or y == -1: return 
        if self.dragging: # This gets cleared by onEndDrag()
            &lt;&lt; scroll the canvas as needed &gt;&gt;
    except:
        g.es_event_exception("continue drag")</t>
<t tx="ekr.20040803072955.101"># Scroll the screen up or down one line if the cursor (y) is outside the canvas.
h = canvas.winfo_height()

if y &lt; 0 or y &gt; h:
    lo, hi = frame.treeBar.get()
    n = self.savedNumberOfVisibleNodes
    line_frac = 1.0 / float(n)
    frac = g.choose(y &lt; 0, lo - line_frac, lo + line_frac)
    frac = min(frac,1.0)
    frac = max(frac,0.0)
    # g.es("lo,hi,frac:",lo,hi,frac)
    canvas.yview("moveto", frac)
    
    # Queue up another event to keep scrolling while the cursor is outside the canvas.
    lo, hi = frame.treeBar.get()
    if (y &lt; 0 and lo &gt; 0.1) or (y &gt; h and hi &lt; 0.9):
        canvas.after_idle(self.onContinueDrag,None) # Don't propagate the event.</t>
<t tx="ekr.20040803072955.102">def onDrag(self,event):
    
    c = self.c ; p = self.drag_p
    if not event: return
    
    if not self.dragging:
        if not g.doHook("drag1",c=c,p=p,v=p,event=event):
            self.startDrag(event)
        g.doHook("drag2",c=c,p=p,v=p,event=event)
        
    if not g.doHook("dragging1",c=c,p=p,v=p,event=event):
        self.onContinueDrag(event)
    g.doHook("dragging2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20040803072955.103">def onEndDrag(self,event):
    
    """Tree end-of-drag handler called from vnode event handler."""
    
    g.trace(self.drag_p)
    
    c = self.c ; p = self.drag_p
    if not p: return
    
    if not g.doHook("enddrag1",c=c,p=p,v=p,event=event):
        self.endDrag(event)
    g.doHook("enddrag2",c=c,p=p,v=p,event=event)</t>
<t tx="ekr.20040803072955.104">x,y = event.x,event.y
canvas_x = canvas.canvasx(x)
canvas_y = canvas.canvasy(y)

theId = self.canvas.find_closest(canvas_x,canvas_y)
# theId = self.canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)

vdrag = self.findPositionWithIconId(theId)
childFlag = vdrag and vdrag.hasChildren() and vdrag.isExpanded()</t>
<t tx="ekr.20040803072955.105">def OnActivateHeadline (self,p,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    # g.trace(p.headString())

    try:
        c = self.c
        &lt;&lt; activate this window &gt;&gt;
    except:
        g.es_event_exception("activate tree")</t>
<t tx="ekr.20040803072955.106">if p == c.currentPosition():
    # g.trace("is current")
    if self.active:
        self.editLabel(p)
    else:
        # Set the focus immediately.  This is essential for proper editing.
        c.frame.treeWantsFocus(later=False)
else:
    # g.trace("not current")
    self.select(p)
    if c.frame.findPanel:
        c.frame.findPanel.handleUserClick(p)
    if p.v.t.insertSpot != None:
        c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
        c.frame.bodyCtrl.see(p.v.t.insertSpot)
    else:
        c.frame.bodyCtrl.mark_set("insert","1.0")
        
    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        c.frame.bodyWantsFocus()

self.active = True</t>
<t tx="ekr.20040803072955.108">def OnDeactivate (self,event=None):
    
    """Deactivate the tree pane, dimming any headline being edited."""
    
    __pychecker__ = '--no-argsused' # event not used.

    tree = self ; c = self.c
    focus = g.app.gui.get_focus(c.frame)

    # Doing this on every click would interfere with the double-clicking.
    if not c.frame.log.hasFocus() and focus != c.frame.bodyCtrl:
        try:
            tree.endEditLabel()
            tree.dimEditLabel()
        except:
            g.es_event_exception("deactivate tree")
</t>
<t tx="ekr.20040803072955.109">def findPositionWithIconId (self,theId):
    
    # Due to an old bug, theId may be a tuple.
    try:
        data = self.iconIds.get(theId[0])
    except:
        data = self.iconIds.get(theId)

    if data:
        p,generation = data
        if generation==self.generation:
            if self.trace and self.verbose:
                g.trace(theId,p.headString())
            return p
        else:
            if self.trace and self.verbose:
                g.trace("*** wrong generation: %d ***" % theId)
            return None
    else:
        if self.trace and self.verbose: g.trace(theId,None)
        return None
        
    
</t>
<t tx="ekr.20040803072955.110">def OnPopup (self,p,event):
    
    """Handle right-clicks in the outline."""
    
    # Note: "headrclick" hooks handled by vnode callback routine.

    if event != None:
        c = self.c
        if not g.doHook("create-popup-menu",c=c,p=p,v=p,event=event):
            self.createPopupMenu(event)
        if not g.doHook("enable-popup-menu-items",c=c,p=p,v=p,event=event):
            self.enablePopupMenuItems(p,event)
        if not g.doHook("show-popup-menu",c=c,p=p,v=p,event=event):
            self.showPopupMenu(event)

    return "break"</t>
<t tx="ekr.20040803072955.111">@ On Linux we must do something special to make the popup menu "unpost" if the mouse is clicked elsewhere.  So we have to catch the &lt;FocusOut&gt; event and explicitly unpost.  In order to process the &lt;FocusOut&gt; event, we need to be able to find the reference to the popup window again, so this needs to be an attribute of the tree object; hence, "self.popupMenu".

Aside: though Tk tries to be muli-platform, the interaction with different window managers does cause small differences that will need to be compensated by system specific application code. :-(
@c

# 20-SEP-2002 DTHEIN: This event handler is only needed for Linux.

def OnPopupFocusLost(self,event=None):
    
    __pychecker__ = '--no-argsused' # event not used.

    self.popupMenu.unpost()</t>
<t tx="ekr.20040803072955.112">def createPopupMenu (self,event):
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; frame = c.frame
    
    # If we are going to recreate it, we had better destroy it.
    if self.popupMenu:
        self.popupMenu.destroy()
        self.popupMenu = None
    
    self.popupMenu = menu = Tk.Menu(g.app.root, tearoff=0)
    
    # Add the Open With entries if they exist.
    if g.app.openWithTable:
        frame.menu.createOpenWithMenuItemsFromTable(menu,g.app.openWithTable)
        table = (("-",None,None),)
        frame.menu.createMenuEntries(menu,table)
        
    &lt;&lt; Create the menu table &gt;&gt;
    
    # New in 4.4.  There is no need for a dontBind argument because
    # Bindings from tables are ignored.
    frame.menu.createMenuEntries(menu,table)</t>
<t tx="ekr.20040803072955.113">table = (
    ("&amp;Read @file Nodes",c.readAtFileNodes),
    ("&amp;Write @file Nodes",c.fileCommands.writeAtFileNodes),
    ("-",None),
    ("&amp;Tangle",c.tangle),
    ("&amp;Untangle",c.untangle),
    ("-",None),
    ("Toggle Angle &amp;Brackets",c.toggleAngleBrackets),
    ("-",None),
    ("Cut Node",c.cutOutline),
    ("Copy Node",c.copyOutline),
    ("&amp;Paste Node",c.pasteOutline),
    ("&amp;Delete Node",c.deleteOutline),
    ("-",None),
    ("&amp;Insert Node",c.insertHeadline),
    ("&amp;Clone Node",c.clone),
    ("Sort C&amp;hildren",c.sortChildren),
    ("&amp;Sort Siblings",c.sortSiblings),
    ("-",None),
    ("Contract Parent",c.contractParent),
)</t>
<t tx="ekr.20040803072955.114">def enablePopupMenuItems (self,v,event):
    
    """Enable and disable items in the popup menu."""
    
    __pychecker__ = '--no-argsused' # event not used.
    
    c = self.c ; menu = self.popupMenu

    &lt;&lt; set isAtRoot and isAtFile if v's tree contains @root or @file nodes &gt;&gt;
    isAtFile = g.choose(isAtFile,1,0)
    isAtRoot = g.choose(isAtRoot,1,0)
    canContract = v.parent() != None
    canContract = g.choose(canContract,1,0)
    
    enable = self.frame.menu.enableMenu
    
    for name in ("Read @file Nodes", "Write @file Nodes"):
        enable(menu,name,isAtFile)
    for name in ("Tangle", "Untangle"):
        enable(menu,name,isAtRoot)

    enable(menu,"Cut Node",c.canCutOutline())
    enable(menu,"Delete Node",c.canDeleteHeadline())
    enable(menu,"Paste Node",c.canPasteOutline())
    enable(menu,"Sort Children",c.canSortChildren())
    enable(menu,"Sort Siblings",c.canSortSiblings())
    enable(menu,"Contract Parent",c.canContractParent())</t>
<t tx="ekr.20040803072955.115">isAtFile = False
isAtRoot = False

for v2 in v.self_and_subtree_iter():
    if isAtFile and isAtRoot:
        break
    if (v2.isAtFileNode() or
        v2.isAtNorefFileNode() or
        v2.isAtAsisFileNode() or
        v2.isAtNoSentFileNode()
    ):
        isAtFile = True
        
    isRoot,junk = g.is_special(v2.bodyString(),0,"@root")
    if isRoot:
        isAtRoot = True</t>
<t tx="ekr.20040803072955.116">def showPopupMenu (self,event):
    
    """Show a popup menu."""
    
    c = self.c ; menu = self.popupMenu

    if sys.platform == "linux2": # 20-SEP-2002 DTHEIN: not needed for Windows
        menu.bind("&lt;FocusOut&gt;",self.OnPopupFocusLost)
    
    menu.post(event.x_root, event.y_root)

    # Set the focus immediately so we know when we lose it.
    c.frame.widgetWantsFocus(menu,later=False)</t>
<t tx="ekr.20040803072955.117">def OnUpKey   (self,event=None):
    __pychecker__ = '--no-argsused' # event not used.
    return self.moveUpDown("up")
def OnDownKey (self,event=None):
    __pychecker__ = '--no-argsused' # event not used.
    return self.moveUpDown("down")

def moveUpDown (self,upOrDown):
    c = self.c ; body = c.frame.bodyCtrl
    # Make the insertion cursor visible so bbox won't return an empty list.
    body.see("insert")
    # Find the coordinates of the cursor and set the new height.
    # There may be roundoff errors because character postions may not match exactly.
    ins =  body.index("insert")
    lines,char = g.scanf(ins,"%d.%d")
    x,y,junk,textH = body.bbox("insert")
    bodyW,bodyH = body.winfo_width(),body.winfo_height()
    junk,maxy,junk,junk = body.bbox("@%d,%d" % (bodyW,bodyH))
    # Make sure y is within text boundaries.
    if upOrDown == "up":
        if y &lt;= textH:
            body.yview("scroll",-1,"units")
        else: y = max(y-textH,0)
    else:
        if y &gt;= maxy:
            body.yview("scroll",1,"units")
        else: y = min(y+textH,maxy)
    # Position the cursor on the proper side of the characters.
    newx,newy,width,junk = body.bbox("@%d,%d" % (x,y))
    if x &gt; newx + width/2:
        x = newx + width + 1
    result = body.index("@%d,%d" % (x,y))
    body.mark_set("insert",result)
    # g.trace("entry:  %s.%s" % (lines,char))
    # g.trace("result:",result)
    # g.trace("insert:",body.index("insert"))
    return "break" # Inhibit further bindings.</t>
<t tx="ekr.20040803072955.125"></t>
<t tx="ekr.20040803072955.126">def endEditLabel (self):
    
    """End editing for self.editText."""

    c = self.c ; frame = c.frame
    
    p = self.editPosition()
    self.onHeadChanged(p)
    
    g.trace(p and p.headString())

    if p and p.edit_text():
        if 0: # New in recycled widgets scheme: this could cause a race condition.
            # This will be done in the redraw code becaused editPosition will be None.
            self.setUnselectedLabelState(p)

        self.setEditPosition(None)

        # force a redraw of joined and ancestor headlines.
        self.force_redraw() 

    if self.stayInTree:
        c.frame.treeWantsFocus()
    else:
        frame.bodyWantsFocus()</t>
<t tx="ekr.20040803072955.127">def editLabel (self,p):
    
    """Start editing p.edit_text."""

    if self.editPosition() and p != self.editPosition():
        self.endEditLabel()

    self.setEditPosition(p)

    # Start editing
    if p and p.edit_text():
        
        self.setNormalLabelState(p)
        self.setEditPosition(p)
        self.frame.headlineWantsFocus(p)</t>
<t tx="ekr.20040803072955.128"># Warning: do not try to "optimize" this by returning if p==tree.currentPosition.

def select (self,p,updateBeadList=True):
    
    c = self.c ; frame = c.frame ; body = frame.bodyCtrl
    old_p = c.currentPosition()
    if not p or not p.exists(c): return # Not an error.

    if not g.doHook("unselect1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; unselect the old node &gt;&gt;

    g.doHook("unselect2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    
    if not g.doHook("select1",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p):
        &lt;&lt; select the new node &gt;&gt;
        if p and p != old_p: # Suppress duplicate call.
            try: # may fail during initialization.
                self.idle_scrollTo(p) # p is NOT c.currentPosition() here!
            except: pass
        &lt;&lt; update c.beadList or c.beadPointer &gt;&gt;
        &lt;&lt; update c.visitedList &gt;&gt;

    &lt;&lt; set the current node &gt;&gt;
    
    g.doHook("select2",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
    g.doHook("select3",c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)</t>
<t tx="ekr.20040803072955.129"># Remember the position of the scrollbar before making any changes.
if old_p:

    yview=body.yview()
    insertSpot = c.frame.body.getInsertionPoint()
    
    if old_p != p:
        self.endEditLabel() # sets editPosition = None
        self.setUnselectedLabelState(old_p)
    
    if old_p.edit_text():
        old_p.v.t.scrollBarSpot = yview
        old_p.v.t.insertSpot = insertSpot</t>
<t tx="ekr.20040803072955.130"># Bug fix: we must always set this, even if we never edit the node.
self.revertHeadline = p.headString()

frame.setWrap(p)

# Always do this.  Otherwise there can be problems with trailing hewlines.
s = g.toUnicode(p.v.t.bodyString,"utf-8")
self.setText(body,s)

# We must do a full recoloring: we may be changing context!
self.frame.body.recolor_now(p) # recolor now uses p.copy(), so this is safe.

if p.v and p.v.t.scrollBarSpot != None:
    first,last = p.v.t.scrollBarSpot
    body.yview("moveto",first)

if p.v and p.v.t.insertSpot != None:
    c.frame.bodyCtrl.mark_set("insert",p.v.t.insertSpot)
    c.frame.bodyCtrl.see(p.v.t.insertSpot)
else:
    c.frame.bodyCtrl.mark_set("insert","1.0")
    
# g.trace("select:",p.headString())</t>
<t tx="ekr.20040803072955.131">if updateBeadList:
    
    if c.beadPointer &gt; -1:
        present_p = c.beadList[c.beadPointer]
    else:
        present_p = c.nullPosition()
    
    if p != present_p:
        # Replace the tail of c.beadList by c and make c the present node.
        # print "updating c.beadList"
        c.beadPointer += 1
        c.beadList[c.beadPointer:] = []
        c.beadList.append(p.copy())
        
    # g.trace(c.beadPointer,p,present_p)</t>
<t tx="ekr.20040803072955.132"># Make p the most recently visited position on the list.
if p in c.visitedList:
    c.visitedList.remove(p)

c.visitedList.insert(0,p.copy())</t>
<t tx="ekr.20040803072955.133">c.setCurrentPosition(p)

if p != old_p:
    self.setSelectedLabelState(p)

frame.scanForTabWidth(p) #GS I believe this should also get into the select1 hook

if self.stayInTree:
    c.frame.treeWantsFocus()
else:
    frame.bodyWantsFocus()</t>
<t tx="ekr.20040803072955.134"></t>
<t tx="ekr.20040803072955.135">def setNormalLabelState (self,p): # selected, editing

    if not self.redrawScheduled:
        if p and p.edit_text():
            self.setEditHeadlineColors(p)
            p.edit_text().tag_remove("sel","1.0","end")
            p.edit_text().tag_add("sel","1.0","end")</t>
<t tx="ekr.20040803072955.136">def setDisabledLabelState (self,p): # selected, disabled

    if not self.redrawScheduled:
        if p and p.edit_text():
            self.setDisabledHeadlineColors(p)</t>
<t tx="ekr.20040803072955.137">def setSelectedLabelState (self,p): # selected, not editing

    if not self.redrawScheduled:
        self.setDisabledLabelState(p)

</t>
<t tx="ekr.20040803072955.138">def setUnselectedLabelState (self,p): # not selected.

    if not self.redrawScheduled:
        if p and p.edit_text():
            self.setUnselectedHeadlineColors(p)</t>
<t tx="ekr.20040803072955.139">def setDisabledHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()

    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("disabled",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)

    fg = c.config.getColor("headline_text_selected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_selected_background_color") or 'grey80'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.140">def setEditHeadlineColors (self,p):

    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("edit",id(2),p.headString())
    
    fg    = c.config.getColor("headline_text_editing_foreground_color") or 'black'
    bg    = c.config.getColor("headline_text_editing_background_color") or 'white'
    selfg = c.config.getColor("headline_text_editing_selection_foreground_color")
    selbg = c.config.getColor("headline_text_editing_selection_background_color")
    
    try: # Use system defaults for selection foreground/background
        if selfg and selbg:
            w.configure(
                selectforeground=selfg,selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selfg and not selbg:
            w.configure(
                selectforeground=selfg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        elif selbg and not selfg:
            w.configure(
                selectbackground=selbg,
                state="normal",highlightthickness=1,fg=fg,bg=bg)
        else:
            w.configure(
                state="normal",highlightthickness=1,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.141">def setUnselectedHeadlineColors (self,p):
    
    c = self.c ; w = p.edit_text()
    
    if self.trace and self.verbose:
        if not self.redrawing:
            print "%10s %d %s" % ("unselect",id(w),p.headString())
            # import traceback ; traceback.print_stack(limit=6)
    
    fg = c.config.getColor("headline_text_unselected_foreground_color") or 'black'
    bg = c.config.getColor("headline_text_unselected_background_color") or 'white'
    
    try:
        w.configure(state="disabled",highlightthickness=0,fg=fg,bg=bg)
    except:
        g.es_exception()</t>
<t tx="ekr.20040803072955.142"># Convenience methods so the caller doesn't have to know the present edit node.

def dimEditLabel (self):
    
    p = self.c.currentPosition()
    self.setDisabledLabelState(p)

def undimEditLabel (self):

    p = self.c.currentPosition()
    self.setSelectedLabelState(p)</t>
<t tx="ekr.20040803072955.143">def expandAllAncestors (self,p):
    
    redraw_flag = False

    for p in p.parents_iter():
        if not p.isExpanded():
            p.expand()
            redraw_flag = True

    return redraw_flag</t>
<t tx="ekr.20040930075711">@nocolor

Leo can't represent some files using nodes!

I call this the "underindented blank line" problem.

Example:

@color

class aClass:
    def spam(): pass
# comment line
    def eggs(): pass
    
@nocolor

Leo's import code can't handle this:
    
- If the import code puts the comment line in a node, the line won't be output with the proper indentation!!

- Having the comment line stop the scanning of aClass is even worse.

- This usually shows up with an unindented blank line instead of the comment line.</t>
<t tx="ekr.20041111114148">g.trace("*** end drag   ***",theId,x,y,p.headString(),vdrag.headString())

if self.controlDrag: # Clone p and move the clone.
    if childFlag:
        c.dragCloneToNthChildOf(p,vdrag,0)
    else:
        c.dragCloneAfter(p,vdrag)
else: # Just drag p.
    if childFlag:
        c.dragToNthChildOf(p,vdrag,0)
    else:
        c.dragAfter(p,vdrag)</t>
<t tx="ekr.20041111114944"># This precomputes numberOfVisibleNodes(), a significant optimization.
# We also indicate where findPositionWithIconId() should start looking for tree id's.

def startDrag (self,event):
    
    """The official helper of the onDrag event handler."""
    
    c = self.c ; canvas = self.canvas
    assert(not self.drag_p)
    x = canvas.canvasx(event.x)
    y = canvas.canvasy(event.y)
    theId = canvas.find_closest(x,y)
    # theId = canvas.find_overlapping(canvas_x,canvas_y,canvas_x,canvas_y)
    if theId is None: return
    try: theId = theId[0]
    except: pass
    p = self.ids.get(theId)
    if not p: return
    self.drag_p = p.copy() # defensive programming: not needed.
    self.dragging = True
    g.trace("*** start drag ***",theId,self.drag_p.headString())
    # Only do this once: greatly speeds drags.
    self.savedNumberOfVisibleNodes = self.numberOfVisibleNodes()
    if c.config.getBool("allow_clone_drags"):
        self.controlDrag = c.frame.controlKeyIsDown
        if c.config.getBool("look_for_control_drag_on_mouse_down"):
            if c.config.getBool("enable_drag_messages"):
                if self.controlDrag:
                    g.es("dragged node will be cloned")
                else:
                    g.es("dragged node will be moved")
    else: self.controlDrag = False
    self.canvas['cursor'] = "hand2" # "center_ptr"</t>
<t tx="ekr.20041111115908">def endDrag (self,event):
    
    """The official helper of the onEndDrag event handler."""
    
    c = self.c ; p = self.drag_p
    canvas = self.canvas
    if not event: return

    &lt;&lt; set vdrag, childFlag &gt;&gt;
    if c.config.getBool("allow_clone_drags"):
        if not c.config.getBool("look_for_control_drag_on_mouse_down"):
            self.controlDrag = c.frame.controlKeyIsDown

    if vdrag and vdrag.v.t != p.v.t: # Disallow drag to joined node.
        &lt;&lt; drag p to vdrag &gt;&gt;
    elif self.trace and self.verbose:
        g.trace("Cancel drag")
    
    # Reset the old cursor by brute force.
    self.canvas['cursor'] = "arrow"
    self.dragging = False
    self.drag_p = None
    
    # Must set self.drag_p = None first.
    if g.app.newWorldOrder:
        self.redraw_now()
</t>
<t tx="ekr.20041119040438">@nocolor

This tree contains settings unique to this outline.</t>
<t tx="ekr.20041119042418">True: Leo loads plugins on startup.

Warning: Naive or hostile hooks may execute HOSTILE CODE contained in .leo files. See further warnings in LeoDocs.leo.
</t>
<t tx="ekr.20041126060136">def print_list(aList,tag=None,sort=False,indent=''):
    
    if not aList:
        if tag: print '%s...{}' % tag
        else:   print '{}'
        return
    if sort:
        aList = aList[:] # Sort a copy! Pychecker incorrectly complains.
        aList.sort()
    if tag: print '%s...[' % tag
    else:   print '['
    for e in aList:
        print '%s%s' % (indent,repr(e).strip())
    print ']'

printList = print_list

def listToString(aList,tag=None,sort=False,indent=''):

    if not aList:
        if tag: return '%s...{}' % tag
        else:   return '{}'
    if sort:
        aList = aList[:] # Sort a copy! Pychecker incorrectly complains.
        aList.sort()
    lines = ["%s%s" % (indent,repr(e).strip()) for e in aList]
    s = '\n'.join(lines)
    if tag:
        return '[%s...\n%s\n]' % (tag,s)
    else:
        return '[%s]' % s</t>
<t tx="ekr.20041130173135">def hash (self):

    c = self
    if c.mFileName:
        return g.os_path_abspath(c.mFileName).lower()
    else:
        return 0</t>
<t tx="ekr.20041211042119"></t>
<t tx="ekr.20041221071131">def createPmwTreeCanvas (self,parentFrame,hScrollMode,pack):
    
    hscrollmode = g.choose(hScrollMode,'dynamic','none')
    
    self.scrolledCanvas = scrolledCanvas = Pmw.ScrolledCanvas(
        parentFrame,
        hscrollmode=hscrollmode,
        vscrollmode='dynamic')

    if pack:
        scrolledCanvas.pack(side='top',expand=1,fill="both")

    self.treeBar = scrolledCanvas.component('vertscrollbar')
    
    canvas = scrolledCanvas.component('canvas')
    canvas.configure(background='white')
    
    return canvas</t>
<t tx="ekr.20041221071131.1">def createTkTreeCanvas (self,parentFrame,scrolls,pack):
    
    frame = self
    
    canvas = Tk.Canvas(parentFrame,name="canvas",
        bd=0,bg="white",relief="flat")

    frame.treeBar = treeBar = Tk.Scrollbar(parentFrame,name="treeBar")
    
    # Bind mouse wheel event to canvas
    if sys.platform != "win32": # Works on 98, crashes on XP.
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
        if 1: # New in 4.3.
            &lt;&lt; workaround for mouse-wheel problems &gt;&gt;
        
    canvas['yscrollcommand'] = self.setCallback
    treeBar['command']     = self.yviewCallback
    treeBar.pack(side="right", fill="y")
    if scrolls: 
        treeXBar = Tk.Scrollbar( 
            parentFrame,name='treeXBar',orient="horizontal") 
        canvas['xscrollcommand'] = treeXBar.set 
        treeXBar['command'] = canvas.xview 
        treeXBar.pack(side="bottom", fill="x")
    
    if pack:
        canvas.pack(expand=1,fill="both")

    canvas.bind("&lt;Button-1&gt;", frame.OnActivateTree)

    # Handle mouse wheel in the outline pane.
    if sys.platform == "linux2": # This crashes tcl83.dll
        canvas.bind("&lt;MouseWheel&gt;", frame.OnMouseWheel)
    if 1:
        &lt;&lt; do scrolling by hand in a separate thread &gt;&gt;
    
    # g.print_bindings("canvas",canvas)
    return canvas</t>
<t tx="ekr.20041221073427">def createLeoPmwSplitter (self,parent,verticalFlag,name):
    
    c = self.c
    
    orient = g.choose(verticalFlag,'vertical','horizontal')
    command = g.choose(name=='splitter1',
        self.onPmwResizeSplitter1,self.onPmwResizeSplitter2)

    panedFrame = Pmw.PanedWidget(parent,
        orient=orient,
        separatorthickness = 6, # default is 2
        handlesize = 8,         # default is 8
        command = command)

    panedFrame.pack(expand=1,fill='both')
    
    self.componentClass(c,name,panedFrame,panedFrame)

    return panedFrame</t>
<t tx="ekr.20041221073427.1">def createLeoTkSplitter (self,parent,verticalFlag,componentName):
    
    c = self.c

    # Create the frames.
    f = Tk.Frame(parent,bd=0,relief="flat")
    f.pack(expand=1,fill="both",pady=1)
    
    f1 = Tk.Frame(f)
    f2 = Tk.Frame(f)
    bar = Tk.Frame(f,bd=2,relief="raised",bg="LightSteelBlue2")

    # Configure and place the frames.
    self.configureBar(bar,verticalFlag)
    self.bindBar(bar,verticalFlag)
    self.placeSplitter(bar,f1,f2,verticalFlag)
    
    # Define the splitter, bar and outer frame components.
    # It would be useless to define placed components here.
    # N.B. All frames managed by the placer must descend from splitterFrame1 or splitterFrame2
    self.componentClass(self.c,componentName,f)
    if componentName == 'splitter1':
        self.componentClass(c,'splitter1Frame',f)
        self.componentClass(c,'splitBar1',bar)
    else:
        self.componentClass(c,'splitter2Frame',f)
        self.componentClass(c,'splitBar2',bar)

    return f, bar, f1, f2</t>
<t tx="ekr.20041221075743">@ These methods cause problems because Pmw.PanedWidget's calls these methods way too often.

We don't need to remember changes to pane sizes, for several reasons:
1. The initial secondary ratio is always set by leoFrame.initialRatios().
    - Remembering this ratio implies a change to the file format and is not worth the cost.
    - The user can set these initial ratios with user options.
2. The only benefit of remembering the secondary ratio is when using the Equal Sized Panes command.
    - But resetting the secondary ratio to the default secondary ratio is good enough.
3. Not remembering these ratios simplifies the code enough to be worth doing.
@c

def onPmwResizeSplitter1 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.ratio = n1/(n1+n2)
            # g.trace(self.ratio)
    
def onPmwResizeSplitter2 (self,sizes):
    if 0: # Don't try to remember size changes.
        if not self.initing:
            n1,n2 = sizes
            n1,n2 = float(n1),float(n2)
            self.secondary_ratio = n1/(n1+n2)
            # g.trace(self.secondary_ratio)</t>
<t tx="ekr.20041221122440">def component (self,name):
    
    return self.componentsDict.get(name)
    
def components (self):

    return self.componentsDict.keys()</t>
<t tx="ekr.20041221123325">def createLeoSplitters (self,parentFrame):
    
    if use_Pmw and Pmw:
        &lt;&lt; create Pmw splitters and their components &gt;&gt;
    else:
        # Splitter 1 is the main splitter containing splitter2 and the body pane.
        f1,bar1,split1Pane1,split1Pane2 = self.createLeoTkSplitter(
            parentFrame,self.splitVerticalFlag,'splitter1')

        self.f1,self.bar1 = f1,bar1
        self.split1Pane1,self.split1Pane2 = split1Pane1,split1Pane2

        # Splitter 2 is the secondary splitter containing the tree and log panes.
        f2,bar2,split2Pane1,split2Pane2 = self.createLeoTkSplitter(
            split1Pane1,not self.splitVerticalFlag,'splitter2')

        self.f2,self.bar2 = f2,bar2
        self.split2Pane1,self.split2Pane2 = split2Pane1,split2Pane2</t>
<t tx="ekr.20041221185246">@ The key invariants used throughout this code:

1. self.splitVerticalFlag tells the alignment of the main splitter and
2. not self.splitVerticalFlag tells the alignment of the secondary splitter.

Only the general-purpose divideAnySplitter routine doesn't know about these invariants.  So most of this code is specialized for Leo's window.  OTOH, creating a single splitter window would be much easier than this code.</t>
<t tx="ekr.20041221195402"></t>
<t tx="ekr.20041223130032"># Create splitter1 and its components.
splitter1 = self.createLeoPmwSplitter(parentFrame,self.splitVerticalFlag,'splitter1')
self.split1Pane1 = splitter2Frame = splitter1.add('splitter2Frame',min=50,size=300)
self.split1Pane2 = splitter1.add('body',min=50,size=300)

# Create splitter2 and its components.
splitter2 = self.createLeoPmwSplitter(splitter2Frame,not self.splitVerticalFlag,'splitter2')
self.split2Pane1 = splitter2.add('outline',min=50,size=300)
self.split2Pane2 = splitter2.add('log',min=50,size=50)

# Set the colors of the separator and handle after adding the dynamic frames.
for splitter in (splitter1,splitter2):
    bar = splitter.component('separator-1')
    bar.configure(background='LightSteelBlue2')
    handle = splitter.component('handle-1')
    handle.configure(background='SteelBlue2')</t>
<t tx="ekr.20050104084531">self.ratio = ratio
self.secondary_ratio = ratio2
splitter1 = self.component('splitter1').getObject()
splitter2 = self.component('splitter2').getObject()

if self.splitVerticalFlag:
    # Use ratio to set splitter2 height.
    size = ratio * float(splitter1.winfo_height())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline width.
    size = ratio2 * float(splitter2.winfo_width())
    splitter2.configurepane('outline',size=int(size))
else:
    # Use ratio to set splitter2 width.
    size = ratio * float(splitter1.winfo_width())
    splitter1.configurepane('splitter2Frame',size=int(size))
    # Use ratio2 to set outline height.
    size = ratio2 * float(splitter2.winfo_height())
    splitter2.configurepane('outline',size=int(size))</t>
<t tx="ekr.20050119210541"># Handle mapping of mouse-wheel to buttons 4 and 5.

def mapWheel(e):
    if e.num == 4: # Button 4
        e.delta = 120
        return frame.OnMouseWheel(e)
    elif e.num == 5: # Button 5
        e.delta = -120
        return frame.OnMouseWheel(e)

canvas.bind("&lt;ButtonPress&gt;",mapWheel,add=1)</t>
<t tx="ekr.20050120083053">@ New in 4.3. The proper way to change focus is to call c.frame.xWantsFocus.

Important: This code never calls select, so there can be no race condition here
that alters text improperly.</t>
<t tx="ekr.20050120092028">@ All these do the same thing, but separate names are good for tracing and
makes the intent of the code clearer.
@c 

def bodyWantsFocus(self,later=True):
    if self.body and self.body.bodyCtrl:
        self.set_focus(self.body.bodyCtrl,later=later)
        
def headlineWantsFocus(self,p,later=True):
    w = p and p.edit_text()
    if w:
        self.set_focus(w,later=later)
    
def logWantsFocus(self,later=True):
    if self.log and self.log.logCtrl:
        self.set_focus(self.log.logCtrl,later=later)

def minibufferWantsFocus(self,later=True):
    # Important! We must preserve body selection!
    if 1:
        self.bodyWantsFocus(later=later)
    else:
        if self.c.miniBufferWidget:
            self.set_focus(self.c.miniBufferWidget,later=later)

def treeWantsFocus(self,later=True):
    if self.tree and self.tree.canvas:
        self.set_focus(self.tree.canvas,later=later)
    
def widgetWantsFocus(self,widget,later=True):
    if widget:
        self.set_focus(widget,later=later)</t>
<t tx="ekr.20050120092028.1">@
Very tricky code:
Many Tk calls can mess with the focus, so we must always set the focus,
regardless of what we did previously.

Alas, because of bugs in Tk and/or window managers, we can not call method at
idle time: that would interfere with switching between windows. Instead, the
xWantFocus routines call this with later=True, to queue up a ONE-SHOT call
that actually changes the focus.
@c

def set_focus(self,widget,later=False):
    
    '''Set the focus to the widget specified in the xWantsFocus methods.'''

    c = self.c
    # This is a *very* effective trace.
    # g.trace(widget._name,g.callers(5))
    
    if not widget or g.app.unitTesting:
        # Cancel any previous request.
        self.wantedWidget = None
        g.app.wantedCommander = None

    if g.app.newWorldOrder:
        if later:
            self.wantedWidget = widget
        else:
            g.app.gui.set_focus(c,widget)
            self.wantedWidget = None
    else:
        # Messing with focus may be dangerous in unit tests.
        if later:
            # Queue up the call (just once) for later.
            def setFocusCallback(c=c):
                self.wantedCallbackScheduled = False
                if c == g.app.wantedCommander and c.frame.wantedWidget:
                    # g.trace(c.frame.wantedWidget)
                    g.app.gui.set_focus(
                        g.app.wantedCommander,
                        c.frame.wantedWidget)
                self.wantedWidget = None
                g.app.wantedCommander = None
                    
            # Crucial: This may change what the callback does.
            self.wantedWidget = widget
            g.app.wantedCommander = c
            if not self.wantedCallbackScheduled:
                # g.trace(g.callers(4),c.shortFileName())
                self.wantedCallbackScheduled = True
                # We don't have to wait so long now that we don't call this so often.
                # The difference between 500 msec. and 100 msec. is significant.
                # New in 4.4: set the delay to 1 msec.: the smaller the better.
                self.outerFrame.after(1,setFocusCallback)
        else:
            # g.trace(g.callers(4),c.shortFileName())
            g.app.gui.set_focus(c,widget)
            # Crucial: cancel any previous callback.
            # It may be re-enabled later, but that doesn't matter.
            self.wantedWidget = None
            g.app.wantedCommander = None</t>
<t tx="ekr.20050208133438">def forceLogUpdate (self,s):

    if sys.platform == "darwin": # Does not work on MacOS X.
        try:
            print s, # Don't add a newline.
        except UnicodeError:
            # g.app may not be inited during scripts!
            print g.toEncodedString(s,'utf-8')
    else:
        self.frame.tree.disableRedraw = True
        self.logCtrl.update_idletasks()
        self.frame.tree.disableRedraw = False</t>
<t tx="ekr.20050420073615">c:\prog\leoCVS\leo\doc\LeoDocs.leo
LeoPy.leo
C:\Documents and Settings\Ed\My Documents\ekr.leo
c:\prog\leoCVS\leo\config\leoSettings.leo</t>
<t tx="ekr.20050503112513.7">def executeFile(filename, options= ''):

    if not os.access(filename, os.R_OK): return

    subprocess = g.importExtension('subprocess',None,verbose=False)

    cwd = os.getcwdu()
    fdir, fname = g.os_path_split(filename)
    
    if subprocess: # Only exists in Python 2.4.
        &lt;&lt; define subprocess_wrapper &gt;&gt;
        rc, so, se = subprocess_wrapper('%s %s %s'%(sys.executable, fname, options))
        if rc:
             print 'return code', rc
        print so, se
    else:
        if fdir: os.chdir(fdir)
        d = {'__name__': '__main__'}
        execfile(fname, d)  #, globals()
        os.system('%s %s' % (sys.executable, fname))
        if fdir: os.chdir(cwd)</t>
<t tx="ekr.20050503112513.8">def subprocess_wrapper(cmdlst):
    
    # g.trace(cmdlst, fdir)
    # g.trace(subprocess.list2cmdline([cmdlst]))

    p = subprocess.Popen(cmdlst, cwd=fdir,
        universal_newlines=True,
        stdout=subprocess.PIPE, stderr=subprocess.PIPE)

    stdo, stde = p.communicate()
    return p.wait(), stdo, stde</t>
<t tx="ekr.20050512031131">@nocolor

https://sourceforge.net/forum/message.php?msg_id=3147054
By: niccl

In the CVS leo from 12 May, yet another minor but mildly irritating bug: the
split ratio between log and outline windows isn't restored on re-opening a .leo
file. The  split between body and the others is, however.</t>
<t tx="ekr.20050707085637">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3237845
By: eichin

First, I'd like to thank Mr. Ream for presenting at EuroPython; I've been an
emacs user 'forever' (anyone else remember CCA emacs?) and have seen enough
"this could change your world as much as emacs did" sorts of comments, finally
seeing it on-screen live finally kicked me into trying it myself.

My overall experience was mixed; some of this may be due to my laziness (I just
unpacked 4-3-1 on my mac and ran src/leo.py, which got me a window so I counted
it as working.)  I did the original version of this in leo to attempt to get
some experience with it...

I am an emacs user.  So of course, I will use emacs bindings first - and since
some of them work (c-f, c-b) I get in trouble because the others then don't
(c-p pops up a python shell, c-a does something dramatic.)  *definitely* needs
at least a simple "you're an emacs user, here is basic editing in emacs bindings,
the leo-specific stuff is pushed out of the way."  Note that this is not actually
odd for a mac user - most of the basic emacs bindings work in text entry boxes,
like the Safari textarea I'm typing this in now - I'm not asking for m-x, but
for c-f/c-b/c-n/c-p/c-a/c-e and maybe a few more, but those are key.

Pure keyboard usage is also key - one thing that worried me watching the demo
was that Mr. Ream kept switching back and forth, keyboard to mouse, and that's
bad - and when I say bad, I mean that Raskin's book had a good footnote pointing
to a clinical study showing that RSIs correllated with *mouse* usage, not keyboard
usage, in a mainstream computer user context.  Note that I don't really mean
emacs-level keyboard-only use - just that in a typical hour of leo usage, I
shouldn't need the mouse for anything I use twice.  Having unusual stuff only
menus is fine.  Not having keybindings that I could find for *next-node* and
*prev-node* is *not* fine.  Frankly, just logging everything *you* use in an
hour and adding bindings for it might be enough...

Similarly, think of simple use-cases/workflows and make them easier.  Can node-titles
actually be multiple lines?  If not, why not have hitting return in a node title
take me to the text window? (This is just one example I tried and was surprised
didn't work.)  More critically, I couldn't find any keystroke at all to take
me from editing nodes to editing text, but I may have been confused at that
point.

For another, mac-specific case: *don't steal system bindings*.  M-`
(command-backtick, in macspeak) should cycle windows (M-~ the other direction.)
Breaking this dooms you on the Mac; even if that's an important binding on other
platforms, you just *have* to make it different on the mac - or you will only
have cross platform occasional mac users and *never* have any users who are
primarily mac users.  I suppose I should submit that one as a direct bug report.

Minor nit - on startup, it asked me for a unique id, "possibly your CVS username".
As a non-windows-user, that made no sense at all to me - at very least, it should
fill in os.getenv("USER") as a default, because it's right on non-windows systems,
isn't it?  (If it isn't, there's no explanation at that point that would tell
me otherwise, that's the value I used anyway...)  Just an out-of-box-experience
issue.

Defaulting to python-mode: sure, maybe it's just coloring, but coming into it
expecting it to be primarily a text-in-outlines editor, that confused me a lot.
I don't actually have an answer here - you can't cheat the way emacs does and
use an extension or #! line to decide "this is python code", though you may
be able to use other tricks - but a first time user is probably going to start
with bits of text and *then* move on to code, and if there's a sane way to support
that, please consider it.

More mac nits: two HELP menus, one is empty; "open leo docs.leo" from the help
menu gives a window that doesn't fit on-screen on my mac (tiger 10.4.1 12" powerbook)
and this leaves the resize control off-screen, so I can't fix it either.

Also (not so mac specific, but more glaring on the mac than elsewhere) - no
context-menu on nodes or text, and I couldn't seem to drag nodes with the mouse
at all (one of the things the mouse *is* obviously useful for, especially if
I'm doing a bunch of rearrangement in one place and *not* going back and forth.)

Finally, one comment from the talk that bothered me for a while and didn't click
until later - "emacs doesn't really have an outline mode".  This is true, at
face value - outline mode in fact is just some regexp and hiding kludging, powerful
in it's own way but not "deep".  However, the operations felt familiar, and
it wasn't until I went home and checked mail that I caught it -- *GNUS* is actually
surprisingly close in function set to an outliner.  Not in any immediately useful
way, but it both clarifies why I think emacs could work this way *and* possibly
clarifies why gnus users are so engaged by the interface :-)  Though that does
mean gnus might be a reasonable source of suggestions for key bindings...

Again, thanks for the demo.  It at least inspired a lot of interest, if not
actually a new convert, but I'll be watching more closely, at least.

_Mark_</t>
<t tx="ekr.20050712092501.1">@killcolor

Buffer-menu-buffer-column
Buffer-menu-mode-map
Buffer-menu-popup-menu

Info-default-directory-list
Info-directory-list
Info-frame-plist

Installation-string
Mouse-track-gensym
X-default-timeout
__buffer-dedicated-frame
_history_

abbreviated-calendar-year
abbreviated-home-dir
abbrevs-changed

activate-menubar-hook
activate-popup-menu-hook
ad-default-compilation-action
ad-redefinition-action

adaptive-fill-function
adaptive-fill-mode
adaptive-fill-regexp

add-log-c-like-modes
add-log-lisp-like-modes
add-log-tex-like-modes

adjust-frame-function

all-christian-calendar-holidays
all-hebrew-calendar-holidays
all-islamic-calendar-holidays

allow-deletion-of-last-visible-frame
allow-remote-paths

american-calendar-display-form
american-date-diary-pattern
apache-file-patterns

appt-audible
appt-display-duration
appt-display-mode-line
appt-issue-message

atomic-extent-goto-char-p
autoload-file-name
backward-delete-function
backward-word-regexp
balloon-help-mode
bar-cursor

bdf-directory-list
bell-inhibit-time
bell-volume

binary-file-regexps
binary-process-input
binary-process-output

binhex-begin-line

blink-cursor-mode
blink-matching-delay
blink-matching-paren
blink-matching-paren-distance
blink-matching-paren-dont-ignore-comments
blink-matching-paren-on-screen
blink-paren-function

block-comment-end
block-comment-start
block-movement-size

bookmark-map

bq-at-flag
bq-at-marker
bq-backquote-marker
bq-backtick-marker
bq-comma-flag
bq-comma-marker
bq-dot-flag
bq-dot-marker

built-in-face-specifiers
built-in-glyph-specifiers
busy-pointer-glyph
c++-mode-syntax-table
c-mode-syntax-table

calc-autoload-directory
calc-gnuplot-name
calc-gnuplot-plot-command
calc-gnuplot-print-command
calc-info-filename

calendar-latitude
calendar-load-hook
calendar-location-name
calendar-longitude
calendar-offset
calendar-setup
calendar-time-display-form
calendar-week-start-day

call-count-profile-table
camldebug-command-name
case-fold-search
case-replace
cd-path
cdpath-previous
change-major-mode-hook
change-major-mode-with-file-name
character-set-property
christian-holidays

coding-keymap
coding-system-for-read
coding-system-for-write
colon-double-space
column-number-mode
column-number-start-at-one

complex-buffers-menu-p

continuation-glyph
continue-save-buffer-hooks-tail

control-arrow-glyph

create-console-hook
create-device-hook
create-frame-hook

ctl-arrow
ctl-x-4-map
ctl-x-5-map
ctl-x-map

current-display-table
current-load-list
current-menubar
current-minibuffer-contents
current-minibuffer-point
current-mouse-event
current-prefix-arg

cursor-in-echo-area

custom-background-mode
custom-define-hook
custom-face-attributes
custom-file
custom-file-base
custom-group-hash-table
custom-known-themes
custom-loaded-themes
custom-local-buffer
custom-print-functions

data-directory
data-directory-list


defining-kbd-macro
defun-prompt-regexp
degrees-to-radians

delete-auto-save-files
delete-console-hook
delete-device-hook
delete-dialog-box-hook
delete-exited-processes
delete-frame-hook
delete-key-deletes-forward
delete-old-versions

describe-function-show-arglist
deselect-frame-hook

dialog-frame-plist

diary-display-hook
diary-file
diary-hook
diary-include-string
diary-list-include-blanks
diary-nonmarking-symbol

diff-switches
dir

directory-abbrev-alist
directory-sep-char

dired-backup-if-overwrite
dired-chown-program
dired-compression-method
dired-compression-method-alist
dired-copy-preserve-time
dired-dwim-target
dired-find-file-compare-truenames
dired-find-subdir
dired-gnutar-program
dired-kept-versions
dired-listing-switches
dired-local-variables-file
dired-ls-program
dired-mail-reader
dired-no-confirm
dired-omit-files
dired-refresh-automatically
dired-unshar-program
dired-use-file-transformers
dired-use-ls-dired

disable-animated-pixmaps
disable-auto-save-when-buffer-shrinks
disabled-command-hook

display-buffer-function
display-time-day-and-date
display-warning-minimum-level
display-warning-suppressed-classes
display-warning-tick

divider-pointer-glyph
doc-directory
dont-record-current-mark

drag-divider-event-lag
drag-modeline-event-lag

dragdrop-autoload-tm-view
dragdrop-drop-at-point
dragdrop-drop-log
dragdrop-drop-log-buffer
dragdrop-drop-log-name
dragdrop-protocols

e

early-package-load-path
early-packages

easy-menu-all-popups
ecb-running-emacs-21
ecb-running-xemacs
echo-keystrokes

edebug-all-defs
edebug-all-forms

ediff-menu
ediff-merge-menu
ediff-misc-menu

edit-abbrevs-map
edit-tab-stops-buffer
edit-tab-stops-map

efs-auto-save
efs-auto-save-remotely
efs-path-root-regexp

eldoc-mode

emacs-beta-version
emacs-build-system
emacs-build-time
emacs-lisp-byte-compile-dir-interactive-p
emacs-lisp-mode-hook
emacs-lisp-mode-map
emacs-lisp-mode-menubar-menu
emacs-lisp-mode-popup-menu
emacs-lisp-mode-syntax-table
emacs-major-version
emacs-minor-version
emacs-patch-level
emacs-priority
emacs-program-name
emacs-program-version
emacs-roots
emacs-version

enable-local-eval
enable-local-variables
enable-multibyte-characters
enable-recursive-minibuffers

enter-window-hook
epatch-menu
erc-ctcp-query-DCC-hook
errors-deactivate-region
esc-map
eshell-directory-name
european-calendar-display-form
european-calendar-style
european-date-diary-pattern

eval-expr-error-message-delay
eval-expr-honor-debug-on-error
eval-expr-print-length
eval-expr-print-level
eval-expr-prompt
eval-interactive-verbose

exec-directory
exec-path
exec-suffix-list

executing-kbd-macro
executing-macro
experimental-dragdrop-drop-functions
face-frob-from-locale-first
facemenu-keymap
facemenu-menu
fast-lock-mode
features

file-coding-system
file-coding-system-alist
file-coding-system-for-read
file-name-coding-system
file-name-handler-alist
file-name-history
file-precious-flag

fill-column
fill-individual-varying-indent
fill-paragraph-function
fill-prefix

find-file-compare-truenames
find-file-existing-other-name
find-file-hooks
find-file-not-found-hooks
find-file-not-true-dirname-list
find-file-run-dired
find-file-use-truenames
find-file-visit-truename

first-change-hook
float-epsilon
float-negative-epsilon
float-output-format
flyspell-mode
flyspell-mode-line-string
flyspell-mode-map
focus-follows-mouse

folding-default-keys-function
folding-default-mouse-keys-function
folding-inside-mode-name
folding-mode
folding-mode-hook-no-regexp
folding-mode-marks-alist
folding-mode-string

font-lock-auto-fontify
font-lock-fontify-string-delimiters
font-lock-keywords
font-lock-maximum-decoration
font-lock-maximum-size
font-lock-mode
font-lock-mode-disable-list
font-lock-mode-enable-list
font-lock-mode-hook
font-lock-syntactic-keywords
font-lock-use-colors
font-lock-use-fonts
font-lock-use-maximal-decoration
font-menu-ignore-scaled-fonts
font-menu-this-frame-only-p

footnote-minor-mode-map
footnote-mode-line-string
footnote-mode-map
footnote-prefix

force-dialog-box-use
format-alist
fortran-tab-mode-default
forward-word-regexp

frame
frame-background-mode
frame-icon-glyph
frame-icon-title-format
frame-initial-frame
frame-initial-frame-plist
frame-initial-geometry-arguments
frame-title-format

function-history
function-key-map
fundamental-mode-abbrev-table
gc-cons-threshold
gc-message
gc-pointer-glyph
gdb-command-name
general-holidays
generated-modeline-string

get-frame-for-buffer-default-frame-name
get-frame-for-buffer-default-instance-limit
get-frame-for-buffer-default-to-current

gnats::mode-name

gnus-outlook-deuglify-unwrap-max
gnus-outlook-deuglify-unwrap-min
gnus-outlook-display-hook

gnuserv-frame
goal-column
grep-null-device
grep-regexp-alist
gui-button-shadow-thickness

hack-local-variables-hook
has-modeline-p
haskell-doc-mode
haskell-mode-hook

hebrew-diary-entry-symbol
hebrew-holidays
hebrew-holidays-1
hebrew-holidays-2
hebrew-holidays-3
hebrew-holidays-4

hide-ifdef-initially
hide-ifdef-lines
hide-ifdef-mode-map
hide-ifdef-read-only

hippie-expand-ignore-buffers
hippie-expand-max-buffers
hippie-expand-try-functions-list
hippie-expand-verbose

history
holidays-in-diary-buffer

hs-hide-comments-when-hiding-all
hs-special-modes-alist
hscroll-glyph
html-font-lock-keywords

hyper-apropos-apropos-buf
hyper-apropos-currently-showing
hyper-apropos-face-history
hyper-apropos-help-buf
hyper-apropos-help-history
hyper-apropos-help-map
hyper-apropos-junk-regexp
hyper-apropos-last-regexp
hyper-apropos-map
hyper-apropos-mode-hook
hyper-apropos-prettyprint-long-values
hyper-apropos-programming-apropos
hyper-apropos-regexp-history
hyper-apropos-show-brief-docs
hyper-apropos-shrink-window

hyperb:emacs19-p
hyperb:kotl-p
hyperb:microcruft-os-p
hyperb:mouse-buttons
hyperb:xemacs-p

hypropos-help-map
hypropos-map
hypropos-prettyprint-long-values
hypropos-programming-apropos
hypropos-show-brief-docs
hypropos-shrink-window

icon-name
iconification-data
idl-mode-syntax-table
ignored-local-variables
image-formats-alist
imenu-generic-expression
in-shifted-motion-command

indent-line-function
indent-region-function
indent-tabs-mode

inhibit-auto-save-session
inhibit-autoloads
inhibit-default-init
inhibit-early-packages
inhibit-file-name-handlers
inhibit-file-name-operation
inhibit-first-line-modes-regexps
inhibit-first-line-modes-suffixes
inhibit-help-echo
inhibit-input-event-recording
inhibit-quit
inhibit-read-only
inhibit-site-lisp
inhibit-site-modules
inhibit-startup-message
inhibit-warning-display

init-face-from-resources
init-file-debug
init-file-had-error
init-file-loaded
init-file-user
init-x-toolbar-list

initial-calendar-window-hook
initial-contents
initial-frame-alist
initial-frame-plist
initial-frame-unmapped-p
initial-major-mode
initial-minibuffer-history-position
initial-scratch-message
initial-toolbar-spec
initial-window-system

initialize-face-resources
insert-default-directory
insert-directory-program
insert-file-contents-access-hook
insert-file-contents-error-hook
insert-file-contents-post-hook
insert-file-contents-pre-hook
internal-doc-file-name
internal-error-checking
interpreter-mode-alist
interprogram-cut-function
interprogram-paste-function
invisible-text-glyph
invocation-directory
invocation-name
invocation-path

islamic-diary-entry-symbol
islamic-holidays
iso8859/1-case-table

ispell-dictionary-alist
ispell-dictionary-alist-1
ispell-dictionary-alist-2
ispell-dictionary-alist-3
ispell-dictionary-alist-4
ispell-dictionary-alist-5
ispell-dictionary-alist-6
ispell-html-skip-alists
ispell-local-dictionary-alist
ispell-menu-map
ispell-menu-map-needed
ispell-menu-xemacs
ispell-personal-dictionary
ispell-skip-region-alist
ispell-tex-skip-alists

itimer-edit-map
itimer-edit-start-marker
itimer-inside-driver
itimer-list
itimer-next-wakeup
itimer-process
itimer-short-interval
itimer-timer
itimer-timer-last-wakeup
itimer-version

java-mode-syntax-table
jde-version
jde-which-method-mode
kept-new-versions
kept-old-versions
key-translation-map
keyboard-coding-system
keyboard-translate-table
keyboard-type
keymap
keymap-tick

kill-buffer-hook
kill-buffer-query-functions
kill-emacs-hook
kill-emacs-query-functions
kill-hooks
kill-ring
kill-ring-max
kill-ring-yank-pointer
kill-whole-line

killed-rectangle
kimport:mode-alist
kimport:suffix-alist
last

last-abbrev
last-abbrev-location
last-abbrev-text
last-command
last-command-char
last-command-event
last-command-event-time
last-command-properties
last-error
last-exact-completion
last-help-echo-object
last-input-char
last-input-event
last-input-time
last-kbd-macro
last-package-load-path
last-packages
last-popup-menu-event
last-pressed-toolbar-button
last-undo-buffer

late-package-load-path
late-packages
lazy-lock-mode
lazy-shot-mode
least-negative-float
least-negative-normalized-float
least-positive-float
least-positive-normalized-float
leave-window-hook

ledit-go-to-lisp-string
ledit-go-to-liszt-string
ledit-save-files

lib-complete:cache
lib-complete:max-cache-size
line-move-ignore-invisible
line-number-mode

local-abbrev-table
local-holidays
local-write-file-hooks

log-message-filter-function
log-message-ignore-labels
log-message-ignore-regexps
log-message-max-size
log-warning-minimum-level
log-warning-suppressed-classes

lookup-syntax-properties
lost-selection-hooks
lpr-command
lpr-lp-system
lpr-switches
lpr-windows-system

major-mode
make-annotation-hook
make-backup-files
manual-program
map-frame-hook

mark-diary-entries-hook
mark-diary-entries-in-calendar
mark-holidays-in-calendar
mark-ring
mark-ring-max
mark-ring-unrecorded-commands

max-lisp-eval-depth
max-specpdl-size
mconfig

menu-accelerator-enabled
menu-accelerator-map
menu-accelerator-modifiers
menu-accelerator-prefix
menu-bar-bookmark-map
menu-no-selection-hook

menubar-configuration
menubar-pointer-glyph
menubar-show-keybindings

menubar-visible-p

meta-prefix-char
mh-lib
mh-libs
mh-progs

minimum-line-ascent
minimum-line-descent
minor-mode-alist
minor-mode-map-alist

modifier-keys-are-sticky
modifier-keys-sticky-time

module-directory
module-load-path

most-negative-fixnum
most-negative-float
most-positive-fixnum
most-positive-float
motion-keys-for-shifted-motion

mule-lisp-directory
native-sound-only-on-console
network-coding-system-alist
news-inews-program
news-path
next-line-add-newlines
next-screen-context-lines
nil
no-redraw-on-reenter
nongregorian-diary-listing-hook
nongregorian-diary-marking-hook
noninteractive
nontext-pointer-glyph
normal-auto-fill-function
nroff-electric-mode
nt-fake-unix-uid
null-device
number-of-diary-entries
obarray
objc-mode-syntax-table

occur-buffer
occur-mode-map
occur-nlines
occur-pos-list

oconfig
octal-escape-glyph
oframe
old-whitespace-incremental-mode-line-string
old-whitespace-mode-line-string
only-global-abbrevs
options-save-faces
oriental-holidays
other-holidays
other-window-scroll-buffer
outline-minor-mode
overlay-arrow-position
overlay-arrow-string

overriding-file-coding-system
overriding-local-map
overriding-terminal-local-map

overwrite-mode
overwrite-mode-binary
overwrite-mode-textual
owindow

page-delimiter

paragraph-ignore-fill-prefix
paragraph-separate
paragraph-start

paren-mode
parens-require-spaces
parse-sexp-ignore-comments
parse-sexp-lookup-properties
path-separator
pathname-coding-system

pending-delete-mode
pending-undo-list
permanent-buffers-mode
php-file-patterns
pi
pike-mode-syntax-table
pixel-horizontal-clip-threshold
pixel-vertical-clip-threshold
point-before-scroll

pop-up-frame-alist
pop-up-frame-function
pop-up-frame-plist
pop-up-frames
pop-up-windows

popup-menu-titles
post-command-hook
post-gc-hook
pre-abbrev-expand-hook
pre-command-hook
pre-display-buffer-function
pre-gc-hook
pre-idle-hook
predicate
prefix-arg
prefix-help-command
preloaded-file-list
primary-selection-extent

print-diary-entries-hook
print-escape-newlines
print-gensym
print-gensym-alist
print-length
print-level
print-message-label
print-readably
print-string-length

printer-current-device
printer-name
printer-page-footer
printer-page-header

process-coding-system-alist
process-connection-type
process-environment

progress-abort-glyph
progress-feedback-popup-period
progress-feedback-style
progress-feedback-use-echo-area
progress-gauge-instantiator
progress-glyph-height
progress-layout-glyph
progress-layout-instantiator
progress-stack
progress-text-instantiator

prompt
ps-multibyte-buffer
ps-page-dimensions-database
ps-paper-type
ps-print-color-p
purify-flag
put-buffer-names-in-file-menu
query-replace-help
query-replace-history
query-replace-interactive
query-replace-map
quit-flag
radians-to-degrees

read-command-history
read-expression-history
read-expression-map
read-file-name-map
read-file-name-must-match-map
read-shell-command-map

readp
redisplay-cache-adjustment
redisplay-end-trigger-functions

register-alist
remote-shell-program
remove-message-hook
replace-re-search-function
replace-search-function
require-final-newline
require-match
ret
retry-undefined-key-binding-unshifted
revert-buffer-function
revert-buffer-insert-file-contents-function
revert-buffer-internal-hook
revert-without-query

rmail-default-dont-reply-to-names
rmail-delete-after-output
rmail-dont-reply-to-names
rmail-file-name
rmail-ignored-headers
rmail-last-file
rmail-mail-new-frame
rmail-primary-inbox-list
rmail-retry-setup-hook
rmail-spool-directory

ruby-mode-hook
running-xemacs
same-window-buffer-names
same-window-regexps
save-abbrevs
save-options-file
save-options-init-file
save-some-buffers-query-display-buffer

scroll-conservatively
scroll-on-clipped-lines
scroll-step
scrollbar-height
scrollbar-on-left-p
scrollbar-on-top-p
scrollbar-pointer-glyph
scrollbar-width
scrollbars-visible-p

scsh-program-name

secondary-selection-extent
select-frame-hook
selected-text-type

selection-appender-alist
selection-buffer-killed-alist
selection-coercible-types
selection-coercion-alist
selection-converter-alist
selection-converter-in-alist
selection-converter-out-alist
selection-pointer-glyph
selection-sets-clipboard

selective-display
selective-display-ellipses

self-insert-face
self-insert-face-command
semanticdb-global-mode
send-mail-function
sendmail-program
sentence-end
sentence-end-double-space
sexp-diary-entry-symbol
shared-lisp-mode-map

shell-command-history
shell-command-switch
shell-dumb-shell-regexp
shell-file-name

shifted-motion-keys-select-region
signal-error-on-buffer-boundary

site-directory
site-load-package-file
site-load-packages
site-module-directory
site-start-file

skeleton-filter
solar-holidays
sound-alist

special-display-buffer-names
special-display-frame-alist
special-display-frame-plist
special-display-function
special-display-regexps

splash-frame-static-body
splash-frame-timeout

split-height-threshold
split-width-threshold
split-window-keep-point

stack-trace-on-error
stack-trace-on-signal
standard-indent
standard-input
standard-output
startup-message-timeout
startup-presentation-hack-keymap
status
strokes-mode
suppress-early-error-handler-backtrace
synchronize-minibuffers
synchronous-sounds
system-configuration
system-configuration-options
system-type
t

tab-stop-list
tab-width

table
tar-regexp

teach-extended-commands-p
teach-extended-commands-timeout

temp-buffer-max-height
temp-buffer-show-function
temp-buffer-show-hook
temp-buffer-shrink-to-fit

temporary-goal-column
term-file-prefix
term-setup-hook

terminal-coding-system
terminal-console
terminal-device
terminal-frame

texinfo-close-quote
texinfo-open-quote

text-cursor-visible-p
text-mode-abbrev-table
text-mode-hook
text-mode-map
text-mode-syntax-table
text-mode-variant
text-pointer-glyph

this-command
this-command-properties

three-step-help
today-invisible-calendar-hook
today-visible-calendar-hook
toggle-where-was-i

trace-buffer
track-eol

tramp-completion-file-name-regexp
tramp-completion-file-name-regexp-separate
tramp-completion-file-name-regexp-unified
tramp-file-name-regexp
tramp-file-name-regexp-separate
tramp-file-name-regexp-unified
tramp-unified-filenames

truncate-lines
truncate-partial-width-windows
truncation-glyph

tshell-prompt-pattern
tutorial-supported-languages
uncapitalized-title-word-regexp
uncapitalized-title-words
undo-high-threshold
undo-threshold
universal-argument-map
universal-argument-num-events
unmap-frame-hook
unread-command-event
unread-command-events
unshifted-motion-keys-deselect-region
use-dialog-box
use-hard-newlines
use-left-overflow
use-right-overflow

user-full-name
user-home-init-file-base-list
user-init-directory
user-init-directory-base
user-init-file
user-init-file-base
user-init-file-base-list
user-mail-address

v
values
variable-history
vc-annotate-mode-hook
vc-before-checkin-hook
vc-checkin-hook
vc-cvs-program
vc-log-template
vc-populate-vc-log-hook
version-control
version18p
version20p

view-calendar-holidays-initially
view-default-lines
view-diary-entries-initially
view-lossage-key-count
view-lossage-message-count
view-minor-mode
view-minor-mode-map
view-mode-map
view-search-arg
view-search-string
visible-bell
w3-configuration-directory
warning-count
warning-level-alist
warning-marker
widget-border-width

win32-pipe-read-delay
win32-quote-process-args
win32-start-process-share-console
win32-start-process-show-window

window
window-config-stack-max
window-min-height
window-min-width
window-pixel-scroll-increment
window-scroll-functions
window-setup-hook
window-size-change-functions
window-system

windowed-process-io
words-include-escapes

write-contents-hooks
write-file-data-hooks
write-file-hooks
write-region-annotate-functions
write-region-annotations-so-far
write-region-post-hook
write-region-pre-hook

x-busy-pointer-shape
x-gc-pointer-shape
x-library-search-path
x-mode-pointer-shape
x-nontext-pointer-shape
x-pointer-shape
x-selection-pointer-shape
x-toolbar-pointer-shape

xemacs-betaname
xemacs-codename
xemacs-logo
xemacs-praise-message
xemacs-praise-sound-file
xemacsp

xlib-version
xpm-color-symbols

xslt-process-additional-classpath
xslt-process-key-binding
xslt-process-mode
xslt-process-mode-line-string
xslt-process-mode-map

zenirc-command-queue
zenirc-last-command-queue-exec

zmacs-activate-region-hook
zmacs-deactivate-region-hook
zmacs-region-active-p
zmacs-region-extent
zmacs-region-rectangular-p
zmacs-region-stays
zmacs-regions
</t>
<t tx="ekr.20050712092501.2">bottom-gutter
bottom-gutter-border-width
bottom-gutter-height
bottom-gutter-visible-p

bottom-toolbar
bottom-toolbar-border-width
bottom-toolbar-height
bottom-toolbar-visible-p

gutter-buffers-tab
gutter-buffers-tab-enabled
gutter-buffers-tab-orientation
gutter-buffers-tab-visible-p
gutter-element-visibility-changed-hook

horizontal-scrollbar-visible-p

left-gutter
left-gutter-border-width
left-gutter-visible-p
left-gutter-width

left-margin
left-margin-width

left-toolbar
left-toolbar-border-width
left-toolbar-visible-p
left-toolbar-width

right-gutter
right-gutter-border-width
right-gutter-visible-p
right-gutter-width

right-margin-width

right-toolbar
right-toolbar-border-width
right-toolbar-visible-p
right-toolbar-width

top-gutter
top-gutter-border-width
top-gutter-height
top-gutter-visible-p

top-level

top-toolbar
top-toolbar-border-width
top-toolbar-height
top-toolbar-visible-p

vertical-divider-always-visible-p
vertical-divider-line-width
vertical-divider-map
vertical-divider-shadow-thickness
vertical-divider-spacing
vertical-scrollbar-visible-p</t>
<t tx="ekr.20050712092501.5"></t>
<t tx="ekr.20050712092501.6">*gensym-counter*
*random-state*</t>
<t tx="ekr.20050712092501.7">:
:accelerator
:activate-callback
:active
:active-opstring
:allow-multi-select
:allow-other-keys
:allow-pages
:allow-selection
:args
:author-version
:autoload-end
:autosize
:background
:background-pixmap
:bold
:border
:buttons
:callback
:callback-ex
:color
:color-symbols
:completion-string
:complex
:config
:cost
:count
:create-prompt-on-nonexistent
:dangerous
:data
:deletion
:description
:descriptor
:device
:dim
:duration
:enable
:end
:end1
:end2
:error
:extra-offset
:face
:face-reset-string
:face-set-string
:family
:file
:file-must-exist
:filter
:filter-list
:foreground
:format
:from-end
:full
:full-name
:get
:greedy
:group
:height
:help
:help-echo
:help-string
:horizontally-justify
:hotspot-x
:hotspot-y
:if
:if-not
:image
:immediate
:included
:initial-directory
:initial-filename
:initial-focus
:initial-value
:initialize
:inline
:interactive
:inverse-video
:italic
:items
:justify
:key
:key-sequence
:keys
:label
:link
:load
:margin-width
:mark
:mask-data
:mask-file
:match
:match-alternatives
:maybe
:menu-tag
:modal
:modifier-p
:must-match
:name
:nick
:no-network-button
:no-read-only-return
:opstring
:options
:orientation
:overwrite-prompt
:pageno
:parent
:password
:pitch
:pixel-height
:pixel-width
:port
:prefix
:printer-name
:printer-settings
:properties
:props
:question
:reader
:reference-buffer
:rehash-size
:rehash-threshold
:require
:resource-id
:resource-type
:selected
:selected-page-button
:server
:set
:set-after
:short-description
:size
:sound
:spec
:start
:start-time
:start1
:start2
:strikethru
:style
:suffix
:summarizer
:tag
:tags
:test
:test-not
:text
:title
:type
:underline
:user-data
:validate
:value
:variable-reset-string
:variable-set-string
:version
:vertically-justify
:volume
:weakness
:width
:window
:window-height
:window-width</t>
<t tx="ekr.20050712092501.8">abbrev-all-caps
abbrev-file-name
abbrev-mode
abbrev-start-location
abbrev-start-location-buffer
abbrev-table
abbrev-table-name-list</t>
<t tx="ekr.20050712092501.9">after-change-function
after-change-functions
after-delete-annotation-hook
after-find-file-from-revert-buffer
after-init-hook
after-insert-file-functions
after-load-alist
after-revert-hook
after-save-hook
after-set-visited-file-name-hooks</t>
<t tx="ekr.20050712092501.10">auto-fill-chars
auto-fill-function
auto-fill-inhibit-regexp
auto-gc-threshold
auto-lower-frame
auto-mode-alist
auto-raise-frame
auto-revert-mode
auto-save-default
auto-save-directory
auto-save-directory-fallback
auto-save-file-format
auto-save-hash-directory
auto-save-hash-p
auto-save-interval
auto-save-list-file-name
auto-save-list-file-prefix
auto-save-offer-delete
auto-save-reserved-chars
auto-save-timeout
auto-save-version
auto-save-visited-file-name
auto-show-inhibiting-commands
auto-show-mode
auto-show-shift-amount
auto-show-show-left-margin-threshold</t>
<t tx="ekr.20050712092501.11">backup-by-copying
backup-by-copying-when-linked
backup-by-copying-when-mismatch
backup-enable-predicate
backup-inhibited</t>
<t tx="ekr.20050712092501.12">bbdb-get-addresses-headers
bbdb-get-only-first-address-p
bbdb-sound-volume
bbdb-sounds-directory
bbdb-update-records-mode
bbdb/vm-set-auto-folder-alist-field</t>
<t tx="ekr.20050712092501.13">before-change-function
before-change-functions
before-delete-annotation-hook
before-init-deferred-warnings
before-init-hook
before-revert-hook</t>
<t tx="ekr.20050712092501.14">browse-url-browser-display
browse-url-browser-function
browse-url-galeon-program
browse-url-generic-program
browse-url-grail
browse-url-mozilla-program
browse-url-new-window-flag
browse-url-new-window-p
browse-url-save-file</t>
<t tx="ekr.20050712092501.15">buffer
buffer-auto-save-file-name
buffer-backed-up
buffer-file-coding-system
buffer-file-coding-system-for-read
buffer-file-format
buffer-file-name
buffer-file-number
buffer-file-numbers-unique
buffer-file-truename
buffer-history
buffer-invisibility-spec
buffer-list-changed-hook
buffer-offer-save
buffer-quit-function
buffer-read-only
buffer-saved-size
buffer-string
buffer-undo-list</t>
<t tx="ekr.20050712092501.16">buffers-menu-format-buffer-line-function
buffers-menu-grouping-function
buffers-menu-max-size
buffers-menu-omit-chars-list
buffers-menu-omit-function
buffers-menu-sort-function
buffers-menu-submenus-for-groups-p
buffers-menu-switch-to-buffer-function
buffers-tab-default-buffer-line-length
buffers-tab-face
buffers-tab-filter-functions
buffers-tab-format-buffer-line-function
buffers-tab-grouping-regexp
buffers-tab-max-buffer-line-length
buffers-tab-max-size
buffers-tab-omit-function
buffers-tab-selection-function
buffers-tab-sort-function
buffers-tab-switch-to-buffer-function</t>
<t tx="ekr.20050712092501.17">cl-builtin-clrhash
cl-builtin-gethash
cl-builtin-maphash
cl-builtin-remhash
cl-closure-vars
cl-compiling-file
cl-emacs-type
cl-hacked-flag
cl-macro-environment
cl-macroexpand-cmacs
cl-old-macroexpand
cl-optimize-safety
cl-optimize-speed
cl-proclaims-deferred
cl-struct-Print-context-tags</t>
<t tx="ekr.20050712092501.18">command-debug-status
command-history
command-line-args
command-line-args-left
command-line-default-directory
command-line-processed
command-loop-level
command-switch-alist</t>
<t tx="ekr.20050712092501.19">comment-column
comment-end
comment-indent-function
comment-indent-hook
comment-line-break-function
comment-multi-line
comment-start
comment-start-skip</t>
<t tx="ekr.20050712092501.20">compilation-buffer-name-function
compilation-finish-function
compilation-minor-mode
compilation-minor-mode-map
compilation-mode-hook
compilation-search-path
compilation-shell-minor-mode
compilation-shell-minor-mode-map
compilation-window-height</t>
<t tx="ekr.20050712092501.21">completion
completion-auto-help
completion-base-size
completion-default-help-string
completion-display-completion-list-function
completion-highlight-first-word-only
completion-ignore-case
completion-ignored-extensions
completion-list-mode-abbrev-table
completion-list-mode-map
completion-list-mode-syntax-table
completion-reference-buffer
completion-regexp-list
completion-setup-hook</t>
<t tx="ekr.20050712092501.22">configure-data-directory
configure-doc-directory
configure-exec-directory
configure-exec-prefix-directory
configure-info-directory
configure-info-path
configure-lisp-directory
configure-mail-lock-method
configure-module-directory
configure-mule-lisp-directory
configure-package-path
configure-prefix-directory
configure-site-directory
configure-site-module-directory</t>
<t tx="ekr.20050712092501.23">dabbrev--abbrev-char-regexp
dabbrev--check-other-buffers
dabbrev--eliminate-newlines
dabbrev--friend-buffer-list
dabbrev--last-abbrev-location
dabbrev--last-abbreviation
dabbrev--last-buffer
dabbrev--last-buffer-found
dabbrev--last-case-pattern
dabbrev--last-completion-buffer
dabbrev--last-direction
dabbrev--last-expansion
dabbrev--last-expansion-location
dabbrev--last-obarray
dabbrev--last-table
dabbrev-abbrev-char-regexp
dabbrev-abbrev-skip-leading-regexp
dabbrev-backward-only
dabbrev-case-distinction
dabbrev-case-fold-search
dabbrev-case-replace
dabbrev-check-all-buffers
dabbrev-check-other-buffers
dabbrev-friend-buffer-function
dabbrev-ignored-buffer-names
dabbrev-ignored-buffer-regexps
dabbrev-limit
dabbrev-search-these-buffers-only
dabbrev-select-buffers-function
dabbrev-upcase-means-case-search</t>
<t tx="ekr.20050712092501.24">isearch-adjusted
isearch-barrier
isearch-buffer
isearch-case-fold-search
isearch-cmds
isearch-extent
isearch-fixed-case
isearch-forward
isearch-hide-immediately
isearch-highlight
isearch-highlight-all-matches
isearch-highlight-extents
isearch-highlight-last-case-fold-search
isearch-highlight-last-regexp
isearch-highlight-last-string
isearch-invalid-regexp
isearch-just-started
isearch-message
isearch-mode
isearch-mode-end-hook
isearch-mode-hook
isearch-mode-map
isearch-new-forward
isearch-nonincremental
isearch-op-fun
isearch-opoint
isearch-other-end
isearch-recursive-edit
isearch-regexp
isearch-selected-frame
isearch-slow-terminal-mode
isearch-small-window
isearch-string
isearch-success
isearch-unhidden-extents
isearch-window-configuration
isearch-window-end
isearch-window-start
isearch-within-brackets
isearch-word
isearch-wrapped
isearch-yank-flag</t>
<t tx="ekr.20050712092501.25">lisp-body-indent
lisp-directory
lisp-imenu-generic-expression
lisp-indent-function
lisp-indent-offset
lisp-interaction-mode-map
lisp-interaction-mode-menubar-menu
lisp-interaction-mode-popup-menu
lisp-mode-abbrev-table
lisp-mode-map
lisp-mode-syntax-table</t>
<t tx="ekr.20050712092501.26">list-buffers-directory
list-buffers-header-line
list-buffers-identification
list-diary-entries-hook
list-directory-brief-switches
list-directory-verbose-switches
list-matching-lines-default-context-lines
list-matching-lines-whole-buffer
list-mode-extent
list-mode-extent-old-point
list-mode-hook
list-mode-map</t>
<t tx="ekr.20050712092501.27">mail-abbrev-mailrc-file
mail-alias-file
mail-aliases
mail-archive-file-name
mail-default-directory
mail-default-reply-to
mail-from-style
mail-header-separator
mail-host-address
mail-interactive
mail-lock-method
mail-lock-methods
mail-self-blind
mail-signature
mail-specify-envelope-from
mail-use-rfc822
mail-user-agent
mail-yank-ignored-headers
mail-yank-prefix</t>
<t tx="ekr.20050712092501.28">minibuffer-completion-confirm
minibuffer-completion-predicate
minibuffer-completion-table
minibuffer-confirm-incomplete
minibuffer-default
minibuffer-electric-file-name-behavior
minibuffer-exit-hook
minibuffer-frame-alist
minibuffer-frame-plist
minibuffer-help-form
minibuffer-history
minibuffer-history-minimum-string-length
minibuffer-history-position
minibuffer-history-search-history
minibuffer-history-sexp-flag
minibuffer-history-uniquify
minibuffer-history-variable
minibuffer-local-completion-map
minibuffer-local-isearch-map
minibuffer-local-map
minibuffer-local-must-match-map
minibuffer-max-depth
minibuffer-scroll-window
minibuffer-setup-hook
minibuffer-smart-completion-tracking-behavior</t>
<t tx="ekr.20050712092501.29">mode-compile-after-compile-hook
mode-compile-after-kill-hook
mode-compile-always-save-buffer-p
mode-compile-before-compile-hook
mode-compile-before-kill-hook
mode-compile-chosen-compiler
mode-compile-default-make-options
mode-compile-expert-p
mode-compile-ignore-makefile-backups
mode-compile-ignore-makerule-regexp
mode-compile-make-options
mode-compile-make-program
mode-compile-never-edit-command-p
mode-compile-other-frame-p
mode-compile-preferred-default-makerule
mode-compile-reading-time
mode-compile-save-all-p
mode-compile-version
mode-for-help
mode-line-buffer-identification
mode-line-format
mode-line-map
mode-line-menu
mode-line-modified
mode-line-process
mode-motion-extent
mode-motion-help-echo-string
mode-motion-hook
mode-name
mode-popup-menu
mode-specific-map</t>
<t tx="ekr.20050712092501.30">modeline-3d-p
modeline-buffer-id-extent
modeline-buffer-id-left-extent
modeline-buffer-id-left-map
modeline-buffer-id-right-extent
modeline-buffer-id-right-map
modeline-buffer-identification
modeline-click-swaps-buffers
modeline-format
modeline-map
modeline-menu
modeline-minor-mode-extent
modeline-minor-mode-map
modeline-modified
modeline-modified-extent
modeline-modified-map
modeline-mousable-minor-mode-extent
modeline-multibyte-status
modeline-narrowed-extent
modeline-narrowed-map
modeline-pointer-glyph
modeline-process
modeline-scrolling-method
modeline-shadow-thickness</t>
<t tx="ekr.20050712092501.31">mouse-avoidance-mode
mouse-avoidance-mode-line-string
mouse-enter-frame-hook
mouse-grabbed-buffer
mouse-highlight-priority
mouse-highlight-text
mouse-leave-frame-hook
mouse-motion-handler
mouse-track-activate-strokes
mouse-track-cleanup-hook
mouse-track-click-count
mouse-track-click-hook
mouse-track-down-hook
mouse-track-drag-hook
mouse-track-drag-up-hook
mouse-track-multi-click-time
mouse-track-rectangle-p
mouse-track-scroll-delay
mouse-track-timeout-id
mouse-track-up-hook
mouse-track-up-time
mouse-track-up-x
mouse-track-up-y
mouse-track-x-threshold
mouse-track-y-threshold
mouse-yank-at-point
mouse-yank-function</t>
<t tx="ekr.20050712092501.32">mswindows-alt-by-itself-activates-menu
mswindows-bitmap-file-path
mswindows-construct-process-command-line-alist
mswindows-downcase-file-names
mswindows-dynamic-frame-resize
mswindows-font-regexp
mswindows-get-true-file-attributes
mswindows-ls-round-file-size
mswindows-ls-sort-case-insensitive
mswindows-match-one-cmd-exe-token-regexp
mswindows-mouse-button-max-skew-x
mswindows-mouse-button-max-skew-y
mswindows-mouse-button-tolerance
mswindows-num-mouse-buttons
mswindows-post-win-initted
mswindows-pre-win-initted
mswindows-start-process-inherit-error-mode
mswindows-start-process-share-console
mswindows-system-shells
mswindows-use-system-frame-size-defaults
mswindows-win-initted</t>
<t tx="ekr.20050712092501.33">package-get-base
package-get-download-sites

packages-data-path-depth
packages-hardcoded-lisp
packages-hierarchy-depth
packages-load-path-depth
packages-no-package-hierarchy-regexp
packages-package-list
packages-special-base-regexp
packages-unbytecompiled-lisp
packages-useful-lisp</t>
<t tx="ekr.20050712092501.34">regexp-history
regexp-search-ring
regexp-search-ring-max
regexp-search-ring-yank-pointer

search-caps-disable-folding
search-dialog
search-dialog-direction
search-dialog-regexp
search-exit-option
search-highlight
search-invisible
search-nonincremental-instead
search-ring
search-ring-max
search-ring-update
search-ring-yank-pointer
search-slow-speed
search-slow-window-lines
search-whitespace-regexp</t>
<t tx="ekr.20050712092501.35">toolbar-active
toolbar-blank-press-function
toolbar-buttons-captioned-p
toolbar-captioned-p
toolbar-compile-icon
toolbar-copy-function
toolbar-copy-icon
toolbar-cut-function
toolbar-cut-icon
toolbar-debug-icon
toolbar-dired-function
toolbar-disk-icon
toolbar-file-icon
toolbar-folder-icon
toolbar-help-enabled
toolbar-icon-directory
toolbar-info-frame
toolbar-info-frame-plist
toolbar-info-icon
toolbar-info-use-separate-frame
toolbar-ispell-function
toolbar-last-win-icon
toolbar-mail-commands-alist
toolbar-mail-icon
toolbar-mail-reader
toolbar-map
toolbar-news-commands-alist
toolbar-news-frame
toolbar-news-frame-plist
toolbar-news-frame-properties
toolbar-news-icon
toolbar-news-reader
toolbar-news-use-separate-frame
toolbar-next-win-icon
toolbar-open-function
toolbar-paste-function
toolbar-paste-icon
toolbar-pointer-glyph
toolbar-print-function
toolbar-printer-icon
toolbar-replace-function
toolbar-replace-icon
toolbar-save-function
toolbar-spell-icon
toolbar-undo-function
toolbar-undo-icon
toolbar-vector-compile
toolbar-vector-copy
toolbar-vector-cut
toolbar-vector-debug
toolbar-vector-dired
toolbar-vector-info
toolbar-vector-mail
toolbar-vector-news
toolbar-vector-open
toolbar-vector-paste
toolbar-vector-print
toolbar-vector-replace
toolbar-vector-save
toolbar-vector-spell
toolbar-vector-undo
toolbar-visible-p</t>
<t tx="ekr.20050712094115">debug-ignored-errors
debug-mswindows-process-command-lines
debug-on-error
debug-on-next-call
debug-on-quit
debug-on-signal
debug-paths
debugger</t>
<t tx="ekr.20050712094115.1">default
default-abbrev-mode
default-buffer-file-coding-system
default-case-fold-search
default-ctl-arrow
default-custom-frame-properties
default-directory
default-directory-function
default-file-dialog-filter-alist
default-fill-column
default-frame-alist
default-frame-name
default-frame-plist
default-function-key-map
default-gutter
default-gutter-border-width
default-gutter-height
default-gutter-position
default-gutter-position-changed-hook
default-gutter-visible-p
default-gutter-width
default-justification
default-left-margin
default-major-mode
default-menubar
default-minibuffer-frame
default-mode-line-format
default-modeline-format
default-mouse-track-adjust
default-mouse-track-down-event
default-mouse-track-extent
default-mouse-track-max-anchor
default-mouse-track-min-anchor
default-mouse-track-normalize-point-function
default-mouse-track-previous-point
default-mouse-track-result
default-mouse-track-type
default-mouse-track-type-list
default-mouse-track-window
default-msprinter-frame-plist
default-mswindows-frame-plist
default-popup-menu
default-profiling-interval
default-tab-width
default-text-properties
default-toolbar
default-toolbar-border-width
default-toolbar-height
default-toolbar-position
default-toolbar-visible-p
default-toolbar-width
default-truncate-lines</t>
<t tx="ekr.20050712094115.2">global-abbrev-table
global-auto-revert-mode
global-map
global-mark-ring
global-mark-ring-max
global-mode-string
global-popup-menu
global-semantic-auto-parse-mode
global-semantic-show-dirty-mode
global-semantic-show-unmatched-syntax-mode
global-semantic-summary-mode
global-senator-minor-mode</t>
<t tx="ekr.20050712094115.3">help-buffer-list
help-buffer-prefix-string
help-char
help-echo-owns-message
help-form
help-map
help-max-help-buffers
help-mode-abbrev-table
help-mode-map
help-mode-syntax-table
help-selects-help-window
help-sticky-window
help-symbol-function-and-variable-context-menu
help-symbol-function-context-menu
help-symbol-regexp
help-symbol-variable-context-menu
help-window-config
</t>
<t tx="ekr.20050712094115.4">load-file-name
load-force-doc-strings
load-history
load-home-init-file
load-ignore-elc-files
load-in-progress
load-path
load-read-function
load-user-init-file-p
load-warn-when-source-newer
load-warn-when-source-only
</t>
<t tx="ekr.20050712094115.5">message-archive-header
message-archive-note
message-citation-line-function
message-cite-function
message-cross-post-default
message-cross-post-note
message-cross-post-note-function
message-followup-to-note
message-from-style
message-indent-citation-function
message-mark-insert-begin
message-mark-insert-end
message-send-mail-function
message-signature
message-signature-file
message-signature-insert-empty-line
message-signature-separator
message-stack
message-user-organization-file
message-yank-prefix</t>
<t tx="ekr.20050712094115.6">paths-core-load-path-depth
paths-default-info-directories

paths-el-original-directory-abbrev-alist
paths-el-original-manual-program
paths-el-original-mh-libs
paths-el-original-mh-progs
paths-el-original-news-inews-program
paths-el-original-remote-shell-program
paths-el-original-rmail-spool-directory
paths-el-original-sendmail-program

paths-lisp-filename-regexp
paths-mule-load-path-depth
paths-no-lisp-directory-regexp
paths-site-load-path-depth
paths-version-control-filename-regexp</t>
<t tx="ekr.20050712094115.7">xwem-after-init-hook
xwem-after-init-wins-hook
xwem-applications-alist
xwem-before-init-hook
xwem-before-init-wins-hook
xwem-cl-activate-hook
xwem-cl-change-hook
xwem-cl-create-hook
xwem-cl-deactivate-hook
xwem-cl-destroy-hook
xwem-cl-iconify-hook
xwem-cl-mark-ring
xwem-cl-refit-hook
xwem-cl-state-change-hook
xwem-cl-withdraw-hook
xwem-clgen-map
xwem-client-default-properties
xwem-client-deselect-hook
xwem-client-select-hook
xwem-config-read-hook
xwem-debug-routines
xwem-dedicated-frame-defalut-properties
xwem-default-focus-mode
xwem-default-parent-map
xwem-dir
xwem-embedded-frame-default-properties
xwem-frame-default-properties
xwem-global-map
xwem-help-key
xwem-icons-dir
xwem-icons-list
xwem-kbd-now-grabbing
xwem-kbd-quit-hook
xwem-keyboard-echo-keystrokes
xwem-keyboard-init-hook
xwem-load-hook
xwem-manage-default-properties
xwem-manage-expectances
xwem-manage-list
xwem-messages-ignore-labels
xwem-minibuffer-focusin-hook
xwem-minibuffer-focusout-hook
xwem-override-local-map
xwem-override-map
xwem-post-command-hook
xwem-pre-command-hook
xwem-prefix-arg
xwem-prefix-help-command
xwem-quit-command
xwem-quit-key
xwem-sound-alist
xwem-sound-list
xwem-started
xwem-tabber-click-cl
xwem-tabber-click-frame
xwem-universal-key
xwem-version
xwem-win-min-height
xwem-win-min-width
xwem-win-split-hook
xwem-worklog-load-hook
xwem-worklog-login-hook
xwem-worklog-logout-hook
xwem-worklog-task-pause-hook
xwem-worklog-task-resume-hook
xwem-worklog-task-start-hook
xwem-worklog-task-stop-hook
xwem-worklog-tasks-description</t>
<t tx="ekr.20050713105353"></t>
<t tx="ekr.20050713105353.1">@nocolor

I have looked into leo's code and managed to figure out how to change 
some fonts. Here's what I did to change the menu fonts for example.

Fonts for the menu can be set in Code-&gt;Gui Tkinter classes-&gt;@thin 
leoTkinterMenu.py-&gt;Tkinter menu bindings-&gt;Routines with Tk 
spellings-&gt;new_menu

so to use the system font (linux) I changed the return statement to:

return Tk.Menu(parent,tearoff=tearoff, font=("System",11))

I'll try using .leo_xresources file and see if that works as well.</t>
<t tx="ekr.20050721093241">@nocolor

The following are notes for anyone who is interested in writing alternate gui's for Leo.

Rule 1: Leo's core is (or should be) free of gui-specific code.

Core code calls 'gui wrapper methods' defined by gui-specific classes.  The base classes for these gui-specific classes are in the node Code--&gt;Gui Base classes.

Rule 2: Gui-specific code should be localized.  

The @file nodes contained in the node 'Code--&gt;Gui Tkinter classes' in leoPy.leo contain all of Leo's Tkinter-specific code.  Gui plugins would typically put all similar code in a single file.

Rule 3: Gui-specific code can call gui methods directly.

There are no restrictions about the code in the gui-specific classes.

Rule 4:  Gui-specific classes must implement the 'gui wrapper methods' specified in the gui base classes.

This is the way that gui-specific classes provide gui-specific services to Leo's core.

The alternative would be to implement all gui-specific commands directly in the gui-specific code.  But this would be much more work than needed.  For example, only a few gui-specific wrappers are needed to implement all commands that deal with body text.  Implementing each of these commands 'from scratch' would duplicate a lot of code unnecessarily.

Using the gui wrapper methods is a bit messy for two reasons:

1.  It requires defining enough wrappers (both in the base gui classes and subclasses) so that all gui-specific services needed by Leo's core are available.   Adding a wrapper to a gui base class involves adding it to all gui-specific subclasses.  It's easy to forget to add a wrapper.  The gui base class defines all wrappers as a function that just calls oops().  This prints a warning that the wrapper should be defined in a subclass.

2. The original wrappers assumed Tkinter-like indices.  Wrappers that were defined later assume Python indices (see Rule 5 below).   The newer style wrappers that use Python indices have 'Python' in their name.   Having two sets of wrappers is one of the ugliest features of the present code.  I find it hard to remember which wrappers exist and what exactly they do :-)

Rule 5:  Leo's core should use Python indices, not gui-specific indices.

Leo's core mostly follows this rule: there may be a few exceptions.

A Python index is an int that runs from 0 (beginning of text) to len(s) (end of text s).  That is, there are exactly len(s) + 1 valid indices.  In contrast, Tkinter indices run from "1.0" to "x.y" where text s has x lines and where the length of the last line is y-1. 

Two (recently written) functions in leoGlobals.py support conversions from Python indices to the row/column indices used by Tkinter.

- g.convertPythonIndexToRowCol converts a Python index to a row/column index used by Tkinter.
- g.convertRowColToPythonIndex does the reverse.

Important:  the first Tkinter index is '1.0', not '0.0', but the row returned by g.convertPythonIndexToRowCol is zero based, so the code that actually creates Tkinter indices from row/col must add 1 to the row.  Similar remarks apply when going in the reverse direction.</t>
<t tx="ekr.20050831131028"></t>
<t tx="ekr.20050831131452">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3280949
By: billp9619

&gt;&gt;Making Leo a friendly part of the opml world has the potential to be very
important to Leo. &lt;&lt;

This is probably point 5. and covers the implementation of opml features as
exposed in Leo.

Because Leo is highly scripted there may be many requests... currently out on
the OPML list... that are solveable....such as how to see their outlines as
HTML without passing thru the OPML web server /host. BTW...all this new opml
stuff is only a week or two in production. The first message on
http://groups.yahoo.com/group/opml-newbies/
is July 25.

&gt;&gt; The question of whether to duplicate body text in &lt;outline&gt; elements
is minor&lt;&lt;

Good. 

Really, the opml tools are pretty much raw text/xml  and I was thinking the
default fallback is ... all clone text is "duplicate". If you want clones then
you will take care to only edit them in Leo. But if opml users all know and
use clones routinely in other editors,  then this is good news for opml
as technology.

&gt;&gt;more complicated than it needs to be&lt;&lt;

Well, both Leo and opml have only a few elements and each primarilly uses one
which recusively nests to make up the outline portion. I suppose body nodes
could be included more directly in headlines ... allowing un-numbered headlines
basically, ... but I am not sure that the current way is inferior
or complicated.

 A simpler (forgiving?) format might make it easier to create with external
apps and encourage transforming other xml to Leo via XSLT. It would have to
just "work".

(One thing about Leo's bias towards elements to contain markup, versus attributes,
is that ...you can cheat a little on escaping &amp;quot; in vh or t nodes ?...which
makes code blocks smaller in the Leo xml.)

Your list above is pretty much how I see it as well.

regards,

bill p

</t>
<t tx="ekr.20050831131452.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3282460
By: billp9619

Looking at some discussion of outline formats there was a remark that because
opml places all text in attributes it is limited in not being able to contan
other elements. On xml-dev I also saw some advice about opml followed by the
comment that it is not a good format.

opml is crippled in this regard but  Leo only restricts itself as a choice in
order to  discern leo xml from content.(out of necessity we know).

Of course with xml you can mix vocabularies based on the use of namespaces.
By becoming namespace aware Leo could be adapted for non-escaped markup. The
purpose then is xml parsing of leo as a standard container of other xml. I do
not believe this is unthinkable  for some future capabilities... especially
if such nodes would contain exclusively xml from another namespace.

Just interesting that leo's format is more versatile than opml, 
but, ...by choice for its own purposes, ...
 is in this part "backward" compatible with opml. :)  

regards,

bill p
</t>
<t tx="ekr.20050912063133"></t>
<t tx="ekr.20050912065811"></t>
<t tx="ekr.20050915062404">@nocolor

Hi,

I am the author of Leo http://webpages.charter.net/edreamleo/front.html an outline editor supporting clones http://webpages.charter.net/edreamleo/intro.html#clones-views.

I am interested in having Leo be able to read and write opml files.  My understanding is that applications are free to use attributes of &lt;outline&gt; elements as they please, but I am wondering whether there are guidelines or existing conventions for representing clones.  Have any namespaces been defined for that purpose?

Thanks.

Edward
</t>
<t tx="ekr.20050916100046">def test_c_endUpdate (self):

    try:
        c.beginUpdate()
        try:
            assert(0)
        finally:
            c.endUpdate()
    except AssertionError:
        return
    
    # This will never happen: finally always re-raises a pending exception.
    assert(0,'no re-raise after finally')</t>
<t tx="ekr.20050916180203">@nocolor

Make Alt-arrow commands undoable.
    Example:  Alt-left Alt-right is not the same, in general, as Alt-left, Undo.
    
Make Expand/Contract undoable?
</t>
<t tx="ekr.20050920084036.75">def backToIndentation (self,event):

    w = event.widget

    i = w.index('insert linestart')
    i2 = w.search(r'\w',i,stopindex='%s lineend' % i,regexp=True)
    w.mark_set('insert',i2)
    ### w.update_idletasks()</t>
<t tx="ekr.20050920084036.78">def indentRelative (self,event):

    k = self.k ; w = event.widget

    i = w.index('insert')
    l, c = i.split('.')
    c2 = int(c)
    l2 = int(l) -1
    if l2 &lt; 1: return
    txt = w.get('%s.%s' % (l2,c2),'%s.0 lineend' % l2)
    if len(txt) &lt;= len(w.get('insert','insert lineend')):
        w.insert('insert','\t')
    else:
        reg = re.compile('(\s+)')
        ntxt = reg.split(txt)
        replace_word = re.compile('\w')
        for z in ntxt:
            if z.isspace():
                w.insert('insert',z)
                break
            else:
                z = replace_word.subn(' ',z)
                w.insert('insert',z[0])
                ###w.update_idletasks()</t>
<t tx="ekr.20050920084036.107">def indentRegion (self,event):
    w = event.widget
    mrk = 'sel'
    trange = w.tag_ranges(mrk)
    if len(trange) != 0:
        ind = w.search('\w','%s linestart' % trange[0],stopindex='end',regexp=True)
        if not ind: return
        text = w.get('%s linestart' % ind,'%s lineend' % ind)
        sstring = text.lstrip()
        sstring = sstring [0]
        ws = text.split(sstring)
        if len(ws) &gt; 1:
            ws = ws [0]
        else:
            ws = ''
        s, s1 = trange [0].split('.')
        e, e1 = trange [ -1].split('.')
        s = int(s)
        s = s + 1
        e = int(e) + 1
        for z in xrange(s,e):
            t2 = w.get('%s.0' % z,'%s.0 lineend' % z)
            t2 = t2.lstrip()
            t2 = ws + t2
            w.delete('%s.0' % z,'%s.0 lineend' % z)
            w.insert('%s.0' % z,t2)
        ### w.event_generate('&lt;Key&gt;')
        ### w.update_idletasks()
    self.removeRKeys(w)</t>
<t tx="ekr.20050920084036.141">def removeBlankLines (self,event):
    
    w = event.widget
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) ; dindex = []
    if w.get('insert linestart','insert lineend').strip() == '':
        while str(i1) + '.0' != '1.0':
            i1 -= 1
            g.trace('loop1',i1)
            s = w.get('%s.0' % i1,'%s.0 lineend' % i1).strip()
            if not s:
                dindex.append('%s.0' % i1)
                dindex.append('%s.0 lineend' % i1)
            elif dindex:
                w.delete('%s-1c' % dindex[-2],dindex[1])
                w.event_generate('&lt;Key&gt;')
                w.update_idletasks() # Needed to continue the loop.
                break
            else:
                break
    i = w.index('insert')
    i1, i2 = i.split('.')
    i1 = int(i1) ; dindex = []
    while w.index('%s.0 lineend' % i1) != w.index('end'):
        i1 += 1
        g.trace('loop1',i1)
        s = w.get('%s.0' % i1,'%s.0 lineend' % i1).strip()
        if not s:
            dindex.append('%s.0' % i1)
            dindex.append('%s.0 lineend' % i1)
        elif dindex:
            w.delete('%s-1c' % dindex[0],dindex[-1])
            w.event_generate('&lt;Key&gt;')
            w.update_idletasks() # Needed to continue the loop.
            break
        else:
            break</t>
<t tx="ekr.20050920084036.149">def moveWordHelper (self,event,forward=True):

    '''This function moves the cursor to the next word, direction dependent on the way parameter'''

    c = self.c ; w = event.widget
    
    if forward:
         ind = w.search('\w','insert',stopindex='end',regexp=True)
         if ind: nind = '%s wordend' % ind
         else:   nind = 'end'
    else:
         ind = w.search('\w','insert -1c',stopindex='1.0',regexp=True,backwards=True)
         if ind: nind = '%s wordstart' % ind
         else:   nind = '1.0'

    w.mark_set('insert',nind)
    w.see('insert')
    c.frame.widgetWantsFocus(w)

def backwardWord (self,event):
    self.moveWordHelper(event,forward=False)

def forwardWord (self,event):
    self.moveWordHelper(event,forward=True)</t>
<t tx="ekr.20050920084036.188">def getPublicCommands (self):
    
    '''(leoCommands) Return a dict of the 'legacy' Leo commands.
    A special case used only by this class.
    Put the *raw* command name into the inverse dict, *not* 'leoCallback'.
    
    Also creates k.leoCallBackDict.  Keys are *raw* functions, values are emacs command names.'''
    
    k = self.k ; d2 = {}
    k.leoCallbackDict = {}
    
    &lt;&lt; define dictionary d of names and Leo commands &gt;&gt;
    
    # Create a callback for each item in d.
    keys = d.keys() ; keys.sort()
    for name in keys:
        f = d.get(name)
        # Warning: k.createInverseCommandsDict uses the name of this callback.
        def leoCallback (event,f=f,self=self,name=name):
            return self.c.doCommand(f,name)
        d2 [name] = leoCallback
        k.leoCallbackDict [leoCallback] = f
        k.inverseCommandsDict [f.__name__] = name
        # g.trace('leoCommands %24s = %s' % (f.__name__,name))
        
    return d2</t>
<t tx="ekr.20050920084036.189">c = self.c ; f = c.frame

d = {
    'abort-edit-headline':  f.abortEditLabelCommand,
    'about-leo':            c.about,
    'add-comments':         c.addComments,     
    'cascade-windows':      f.cascade,
    'clear-recent-files':   c.clearRecentFiles,
    'close-window':         c.close,
    'contract-or-go-left':  c.contractNodeOrGoToParent,
    'check-python-code':    c.checkPythonCode,
    'check-all-python-code':c.checkAllPythonCode,
    'check-outline':        c.checkOutline,
    'clear-recent-files':   c.clearRecentFiles,
    'clone-node':           c.clone,
    'close-find-dialog':    c.dismissFindPanel, # Deprecated.
    'contract-node':        c.contractNode,
    'contract-all':         c.contractAllHeadlines,
    'contract-parent':      c.contractParent,
    'convert-all-blanks':   c.convertAllBlanks,
    'convert-all-tabs':     c.convertAllTabs,
    'convert-blanks':       c.convertBlanks,
    'convert-tabs':         c.convertTabs,
    'copy-node':            c.copyOutline,
    'copy-text':            f.copyText,
    'cut-node':             c.cutOutline,
    'cut-text':             f.cutText,
    'de-hoist':             c.dehoist,
    'delete':               c.delete,
    'delete-comments':      c.deleteComments,
    'delete-node':          c.deleteOutline,
    'delete-text':          c.delete,
    'demote':               c.demote,
    'dump-outline':         c.dumpOutline,
    'edit-headline':        c.editHeadline,
    'end-edit-headline':    f.endEditLabelCommand,
    'equal-sized-panes':    f.equalSizedPanes,
    'execute-script':       c.executeScript,
    'exit-leo':             g.app.onQuit,
    'expand-all':           c.expandAllHeadlines,
    'expand-next-level':    c.expandNextLevel,
    'expand-node':          c.expandNode,
    'expand-and-go-right':  c.expandNodeAndGoToFirstChild,
    'expand-or-go-right':   c.expandNodeOrGoToFirstChild,
    'expand-prev-level':    c.expandPrevLevel,
    'expand-to-level-1':    c.expandLevel1,
    'expand-to-level-2':    c.expandLevel2,
    'expand-to-level-3':    c.expandLevel3,
    'expand-to-level-4':    c.expandLevel4,
    'expand-to-level-5':    c.expandLevel5,
    'expand-to-level-6':    c.expandLevel6,
    'expand-to-level-7':    c.expandLevel7,
    'expand-to-level-8':    c.expandLevel8,
    'expand-to-level-9':    c.expandLevel9,
    'export-headlines':     c.exportHeadlines,
    'extract':              c.extract,
    'extract-names':        c.extractSectionNames,
    'extract-section':      c.extractSection,
    'find-dialog-change':       c.replace,              # Deprecated.
    'find-dialog-change-then-find': c.replaceThenFind,  # Deprecated.
    'find-dialog-change-all':   c.replaceAll,           # Deprecated.
    'find-dialog-find-next':    c.findNext,             # Deprecated.
    'find-dialog-find-previous':c.findPrevious,         # Deprecated.
    'flatten-outline':      c.flattenOutline,
    'go-back':              c.goPrevVisitedNode,
    'go-forward':           c.goNextVisitedNode,
    'goto-first-node':      c.goToFirstNode,
    'goto-first-sibling':   c.goToFirstSibling,
    'goto-last-node':       c.goToLastNode,
    'goto-last-sibling':    c.goToLastSibling,
    'goto-last-visible':    c.goToLastVisibleNode,
    'goto-line-number':     c.goToLineNumber,
    'goto-next-changed':    c.goToNextDirtyHeadline,
    'goto-next-clone':      c.goToNextClone,
    'goto-next-marked':     c.goToNextMarkedHeadline,
    'goto-next-node':       c.selectThreadNext,
    'goto-next-sibling':    c.goToNextSibling,
    'goto-next-visible':    c.selectVisNext,
    'goto-parent':          c.goToParent,
    'goto-prev-node':       c.selectThreadBack,
    'goto-prev-sibling':    c.goToPrevSibling,
    'goto-prev-visible':    c.selectVisBack,
    'hoist':                c.hoist,
    'import-at-file':       c.importAtFile,
    'import-at-root':       c.importAtRoot,
    'import-cweb-files':    c.importCWEBFiles,
    'import-derived-file':      c.importDerivedFile,
    'import-flattened-outline': c.importFlattenedOutline,
    'import-noweb-files':       c.importNowebFiles,
    'indent':                   c.indentBody,
    'insert-node':              c.insertHeadline,
    'insert-body-time':         c.insertBodyTime,
    'insert-headline-time':     f.insertHeadlineTime,
    'mark':                     c.markHeadline,
    'mark-changed-items':       c.markChangedHeadlines,
    'mark-changed-roots':       c.markChangedRoots,
    'mark-clones':              c.markClones,
    'mark-subheads':            c.markSubheads,
    'match-bracket':            c.findMatchingBracket,
    'minimize-all':             f.minimizeAll,
    'move-outline-down':        c.moveOutlineDown,
    'move-outline-left':        c.moveOutlineLeft,
    'move-outline-right':       c.moveOutlineRight,
    'move-outline-up':          c.moveOutlineUp,
    'new':                      c.new,
    'open-compare-window':      c.openCompareWindow,
    'open-find-dialog':          c.showFindPanel, # Deprecated.
    'open-leoconfig-leo':       c.openLeoSettings,
    'open-leodocs-leo':         c.leoDocumentation,
    'open-leoplugins-leo':      c.openLeoPlugins,
    'open-online-home':         c.leoHome,
    'open-online-tutorial':     c.leoTutorial,
    'open-offline-tutorial':    f.leoHelp,
    'open-outline':             c.open,
    'open-python-window':       c.openPythonWindow,
    'open-with':                c.openWith,
    'outline-to-CWEB':          c.outlineToCWEB,
    'outline-to-noweb':         c.outlineToNoweb,
    'paste-node':               c.pasteOutline,
    'paste-retaining-clones':   c.pasteOutlineRetainingClones,
    'paste-text':               f.pasteText,
    'pretty-print-all-python-code': c.prettyPrintAllPythonCode,
    'pretty-print-python-code':     c.prettyPrintPythonCode,
    'promote':                  c.promote,
    'read-at-file-nodes':       c.readAtFileNodes,
    'read-outline-only':        c.readOutlineOnly,
    'redo':                     c.undoer.redo,
    'reformat-paragraph':       c.reformatParagraph,
    'remove-sentinels':         c.removeSentinels,
    'replace':                  c.replace,
    'replace-then-find':        c.replaceThenFind,
    'resize-to-screen':         f.resizeToScreen,
    'revert':                   c.revert,
    'save-file':                c.save,
    'save-file-as':             c.saveAs,
    'save-file-to':             c.saveTo,
    'select-all':               f.body.selectAllText,
    'settings':                 c.preferences,
    'set-colors':               c.colorPanel,
    'set-font':                 c.fontPanel,
    'show-invisibles':          c.viewAllCharacters,
    'sort-children':            c.sortChildren,
    'sort-siblings':            c.sortSiblings,
    'tangle':                   c.tangle,
    'tangle-all':               c.tangleAll,
    'tangle-marked':            c.tangleMarked,
    'toggle-active-pane':       f.toggleActivePane,
    'toggle-angle-brackets':    c.toggleAngleBrackets,
    'toggle-split-direction':   f.toggleSplitDirection,
    'undo':                     c.undoer.undo,
    'unindent':                 c.dedentBody,
    'unmark-all':               c.unmarkAll,
    'untangle':                 c.untangle,
    'untangle-all':             c.untangleAll,
    'untangle-marked':          c.untangleMarked,
    'weave':                    c.weave,
    'write-at-file-nodes':      c.fileCommands.writeAtFileNodes,
    'write-dirty-at-file-nodes':    c.fileCommands.writeDirtyAtFileNodes,
    'write-missing-at-file-nodes':  c.fileCommands.writeMissingAtFileNodes,
    'write-outline-only':       c.fileCommands.writeOutlineOnly,
}</t>
<t tx="ekr.20050920084036.219">def findNextMatch (self,event):
    
    '''Find the next match and select it.
    Return True if a match was found.
    Otherwise, call quitSearch and return False.'''

    k = self.k ; w = event.widget
    
    w.tag_delete('qR')

    if self.regexp:
        &lt;&lt; handle regexp &gt;&gt;
    else:
        &lt;&lt; handle plain search &gt;&gt;</t>
<t tx="ekr.20050920084036.257">class searchCommandsClass (baseEditCommandsClass):
    
    '''Implements many kinds of searches.'''

    @others</t>
<t tx="ekr.20050920084036.258">def __init__ (self,c):
    
    # g.trace('searchCommandsClass')

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.findTabHandler = None
    
    self.forward = True
    self.regexp = False

    # For replace-string and replace-regexp
    self._sString = ''
    self._rpString = ''</t>
<t tx="ekr.20050920084036.259">def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':            self.hideFindTab,
        'open-find-tab':            self.openFindTab,
        'find-tab-find':            self.findTabFindNext,
        'find-tab-find-prev':       self.findTabFindPrev,
        'find-tab-change':          self.findTabChange,
        'find-tab-change-then-find':self.findTabChangeThenFind,

        'isearch-forward':          self.isearchForward,
        'isearch-backward':         self.isearchBackward,
        'isearch-forward-regexp':   self.isearchForwardRegexp,
        'isearch-backward-regexp':  self.isearchBackwardRegexp,
        
        're-search-forward':        self.reSearchForward,
        're-search-backward':       self.reSearchBackward,
        
        'search-forward':           self.searchForward,
        'search-backward':          self.searchBackward,
        'word-search-forward':      self.wordSearchForward,
        'word-search-backward':     self.wordSearchBackward,
    }</t>
<t tx="ekr.20050920084036.261">def isearchForward (self,event):
    self.startIncremental(event,forward=True,regexp=False)
    
def isearchBackward (self,event):
    self.startIncremental(event,forward=False,regexp=False)
    
def isearchForwardRegexp (self,event):
    self.startIncremental(event,forward=True,regexp=True)
    
def isearchBackwardRegexp (self,event):
    self.startIncremental(event,forward=False,regexp=True)</t>
<t tx="ekr.20050920084036.262">def startIncremental (self,event,forward,regexp):

    k = self.k
    
    self.forward = forward
    self.regexp = regexp
    k.setLabelBlue('isearch: ',protect=True)
    k.setState('isearch',1,handler=self.iSearchStateHandler)</t>
<t tx="ekr.20050920084036.263">def iSearchHelper (self,event,forward,regexp):

    '''This method moves the insert spot to position that matches the pattern in the miniBuffer'''
    
    k = self.k ; w = event.widget
    s = k.getLabel(ignorePrompt=True)
    g.trace(forward,repr(s))
    if s:
        try:
            if forward:
                i = w.search(s,"insert + 1c",stopindex='end',regexp=regexp)
                if not i:
                    # Start again at the top of the buffer.
                    i = w.search(s,'1.0',stopindex='insert',regexp=regexp)
            else:
                i = w.search(s,'insert',backwards=True,stopindex='1.0',regexp=regexp)
                if not i:
                    # Start again at the bottom of the buffer.
                    i = w.search(s,'end',backwards=True,stopindex='insert',regexp=regexp)
            
        except: pass

        if i and not i.isspace():
            w.mark_set('insert',i)
            w.see('insert')</t>
<t tx="ekr.20050920084036.264"># Called when from the state manager when the state is 'isearch'

def iSearchStateHandler (self,event):

    k = self.k ; w = event.widget ; keysym = event.keysym
    if keysym == 'Control_L': return
    
    # g.trace('keysym',keysym,'stroke',k.stroke)
    
    if 0: # Useful, but presently conflicts with other bindings.
        if k.stroke == '&lt;Control-s&gt;':
            self.startIncremental(event,forward=True,regexp=False)
        elif k.stroke == '&lt;Control-r&gt;':
            self.startIncremental(event,forward=False,regexp=False)

    if keysym == 'Return':
        if 0: # Doesn't do anything at present.
            &lt;&lt; do a non-incremental search &gt;&gt;
        k.resetLabel()
        k.clearState()
        return

    if event.char == '\b':
        g.trace('backspace not handled yet')
        return
    
    if event.char:
        k.updateLabel(event)
        s = k.getLabel(ignorePrompt=True)
        z = w.search(s,'insert',stopindex='insert +%sc' % len(s))
        if not z:
           self.iSearchHelper(event,self.forward,self.regexp)
        self.scolorizer(event)</t>
<t tx="ekr.20050920084036.265">def scolorizer (self,event):

    k = self.k ; w = event.widget

    stext = k.getLabel(ignorePrompt=True)
    w.tag_delete('color')
    w.tag_delete('color1')
    if stext == '': return
    ind = '1.0'
    while ind:
        try:
            ind = w.search(stext,ind,stopindex='end',regexp=self.regexp)
        except:
            break
        if ind:
            i, d = ind.split('.')
            d = str(int(d)+len(stext))
            index = w.index('insert')
            if ind == index:
                w.tag_add('color1',ind,'%s.%s' % (i,d))
            w.tag_add('color',ind,'%s.%s' % (i,d))
            ind = i + '.' + d
    w.tag_config('color',foreground='red')
    w.tag_config('color1',background='lightblue')</t>
<t tx="ekr.20050920084036.267"></t>
<t tx="ekr.20050920084036.268">def plainSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget ; i = w.index('insert')

    try:
        if forward:
            s = w.search(pattern,i,stopindex='end')
            if s: s = w.index('%s +%sc' % (s,len(pattern)))
        else:
            s = w.search(pattern,i,stopindex='1.0',backwards=True)
    except Exception:
        return

    if s:
        w.mark_set('insert',s)</t>
<t tx="ekr.20050920084036.269">def searchBackward (self,event):

    k = self.k ; state = k.getState('search-backward')
    if state == 0:
        k.setLabelBlue('Search Backward: ',protect=True)
        k.getArg(event,'search-backward',1,self.searchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=False)

def searchForward (self,event):

    k = self.k ; state = k.getState('search-forward')
    if state == 0:
        k.setLabelBlue('Search: ',protect=True)
        k.getArg(event,'search-forward',1,self.searchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.plainSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.272">def wordSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget ; i = w.index('insert')
    words = pattern.split()
    sep = '[%s%s]+' % (string.punctuation,string.whitespace)
    pattern = sep.join(words)
    cpattern = re.compile(pattern)
    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        if not match: return
        end = match.end()
    else:
        txt = w.get('1.0','insert') #initially the reverse words formula for Python Cookbook was going to be used.
        a = re.split(pattern,txt) #that didnt quite work right.  This one apparently does.
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return
        
    s = g.choose(forward,'insert +%sc','insert -%sc')
    w.mark_set('insert',s % end)
    w.see('insert')
</t>
<t tx="ekr.20050920084036.274">def reSearchBackward (self,event):

    k = self.k ; state = k.getState('re-search-backward')
    if state == 0:
        k.setLabelBlue('Regexp Search backward:',protect=True)
        k.getArg(event,'re-search-backward',1,self.reSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=False)

def reSearchForward (self,event):

    k = self.k ; state = k.getState('re-search-forward')
    if state == 0:
        k.setLabelBlue('Regexp Search:',protect=True)
        k.getArg(event,'re-search-forward',1,self.reSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.reSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20050920084036.275">def reSearchHelper (self,event,pattern,forward):

    k = self.k ; w = event.widget
    cpattern = re.compile(pattern)

    if forward:
        txt = w.get('insert','end')
        match = cpattern.search(txt)
        end = match.end()
    else:
        # The reverse words formula for Python Cookbook didn't quite work.
        txt = w.get('1.0','insert') 
        a = re.split(pattern,txt)
        if len(a) &gt; 1:
            b = re.findall(pattern,txt)
            end = len(a[-1]) + len(b[-1])
        else: return

    if end:
        s = g.choose(forward,'insert +%sc','insert -%sc')
        w.mark_set('insert',s % end)
        w.see('insert')</t>
<t tx="ekr.20050920085536.2">def __init__ (self,c,useGlobalKillbuffer=False,useGlobalRegisters=False):
    
    '''Create a key handler for c.
    c.frame.miniBufferWidget is a Tk.Label.
    
    useGlobalRegisters and useGlobalKillbuffer indicate whether to use
    global (class vars) or per-instance (ivars) for kill buffers and registers.'''
    
    self.c = c
    self.widget = c.frame.miniBufferWidget
    self.useTextWidget = c.useTextMinibuffer
        # A Tk Label or Text widget.
        # Exists even if c.showMinibuffer is False.
    self.useGlobalKillbuffer = useGlobalKillbuffer
    self.useGlobalRegisters = useGlobalRegisters

    # Generalize...
    self.x_hasNumeric = ['sort-lines','sort-fields']

    self.altX_prompt = 'full-command: '
    &lt;&lt; define Tk ivars &gt;&gt;
    &lt;&lt; define externally visible ivars &gt;&gt;
    &lt;&lt; define internal ivars &gt;&gt;</t>
<t tx="ekr.20050920085536.16">def bindKey (self,pane,shortcut,callback,commandName):

    '''Bind the indicated shortcut (a Tk keystroke) to the callback.
    callback calls commandName (for error messages).'''
    
    k = self ; c = k.c 

    if not shortcut: g.trace('No shortcut for %s' % commandName)
    bunch = k.bindingsDict.get(shortcut)
    if bunch and bunch.pane == pane:
        # g.trace('Not bound',shortcut)
        if commandName != bunch.commandName:
            g.es_print('Ignoring redefinition of %s from %s to %s in %s' % (
                shortcut,bunch.commandName,commandName,pane),color='blue')
        return
        
    # g.trace(pane,shortcut,commandName)

    try:
        &lt;&lt; bind callback to shortcut in pane &gt;&gt;

        k.bindingsDict [shortcut] = g.bunch(
            pane=pane,func=callback,commandName=commandName)

        return True

    except Exception: # Could be a user error.
        if not g.app.menuWarningsGiven:
            g.es_print('Exception binding %s to %s' % (shortcut,commandName))
            # g.es_exception()
            # g.printStack()
            g.app.menuWarningsGiven = True

        return False</t>
<t tx="ekr.20050920085536.35">def setLabelGrey (self,label=None):

    k = self
    k.widget.configure(background='lightgrey')
    if label is not None:
        k.setLabel(label)
        
setLabelGray = setLabelGrey</t>
<t tx="ekr.20050920085536.36">def setLabelBlue (self,label=None,protect=False):
    
    k = self

    k.widget.configure(background='lightblue')

    if label is not None:
        k.setLabel(label,protect)</t>
<t tx="ekr.20050920085536.37">def resetLabel (self):
    
    k = self
    k.setLabelGrey('')
    k.mb_prefix = ''</t>
<t tx="ekr.20050920085536.38">def updateLabel (self,event,suppressControlChars=True):

    '''Mimic what would happen with the keyboard and a Text editor
    instead of plain accumalation.'''
    
    k = self ; s = k.getLabel()
    ch = (event and event.char) or ''
    keysym = (event and event.keysym) or ''
    
    # g.trace(repr(s),ch,keysym,k.stroke)
    
    if ch == '\b': # Handle backspace.
        # Don't backspace over the prompt.
        if len(s) &lt;= k.mb_prefix:
            return 
        elif len(s) == 1: s = ''
        else: s = s [0:-1]
    elif suppressControlChars and ch not in string.printable:
        return
    elif ch and ch not in ('\n','\r'):
        s = s + ch # Add the character.
    
    k.setLabel(s)</t>
<t tx="ekr.20050920085536.64">def manufactureKeyPressForCommandName (self,w,commandName):
    
    '''Implement a command by passing a keypress to Tkinter.'''

    k = self
    
    shortcut = k.getShortcutForCommandName(commandName)
    
    if shortcut and w:
    
        w.event_generate(shortcut)</t>
<t tx="ekr.20050920085536.65">def masterCommand (self,event,func,stroke):

    '''This is the central dispatching method.
    All commands and keystrokes pass through here.'''

    k = self ; c = k.c
    k.stroke = stroke # Set this global for general use.
    keysym = event and event.keysym
    ch = event and event.char
    k.func = func
    commandName = k.ultimateFuncName(func)
    special = keysym in (
        'Control_L','Alt_L','Shift_L','Control_R','Alt_R','Shift_R')
    interesting = func or stroke != '&lt;Key&gt;'
    
    #g.trace('stroke',stroke,'ch',repr(ch),'keysym',repr(keysym))
        # stroke,k.inState(),k.getStateKind())

    # if interesting: g.trace(stroke,commandName,k.getStateKind())

    inserted = not special or (
        stroke != '&lt;Key&gt;' and (len(k.keysymHistory)==0 or k.keysymHistory[0]!=event.keysym))

    if inserted:
        # g.trace(stroke,event.keysym)
        &lt;&lt; add character to history &gt;&gt;
        
    # We *must not* interfere with the global state in the macro class.
    if c.macroCommands.recordingMacro:
        done = c.macroCommands.startKbdMacro(event)
        if done: return 'break'
        
    # g.trace(stroke,k.abortAllModesKey)

    if stroke == k.abortAllModesKey: # 'Control-g'
        k.clearState()
        k.keyboardQuit(event)
        k.endCommand(event,commandName)
        return 'break'

    if k.inState():
        if not special: # Don't pass these on.
            k.callStateFunction(event) # Calls end-command.
        return 'break'

    # if k.keystrokeFunctionDict.has_key(stroke):
        # if k.callKeystrokeFunction(event): # Calls end-command
            # return 'break'

    if k.regx.iter:
        try:
            k.regXKey = event.keysym
            k.regx.iter.next() # EKR: next() may throw StopIteration.
        finally:
            return 'break'

    if k.abbrevOn:
        expanded = c.abbrevCommands.expandAbbrev(event)
        if expanded: return 'break'

    if func: # Func is an argument.
        # g.trace('executing func',commandName)
        forceFocus = func.__name__ != 'leoCallback'
        if forceFocus: k.forceFocusToBody()
        func(event)
        k.endCommand(event,commandName)
        return 'break'
        
    # New logic in 4.4:
    if stroke == '&lt;Key&gt;' and not ch:
        # Let Tk handle the char.  Example: default bindings for arrow keys.
        # g.trace('to tk:','stroke',stroke,'ch',repr(ch))
        val = None
    else:
        # Pass the stroke to one of Leo's event handlers.
        val = self.handleDefaultChar(event)
        
    if g.app.newWorldOrder:
        k.redraw()
        k.setFocus()
        
    return val</t>
<t tx="ekr.20050920085536.67"># Don't add multiple special characters to history.

k.keysymHistory.insert(0,event.keysym)

if len(event.char) &gt; 0:
    if len(keyHandlerClass.lossage) &gt; 99:
        keyHandlerClass.lossage.pop()
    keyHandlerClass.lossage.insert(0,event.char)

if 0: # traces
    g.trace(event.keysym,stroke)
    g.trace(k.keysymHistory)
    g.trace(keyHandlerClass.lossage)</t>
<t tx="ekr.20050920093543">def finishCreate (self):  # New in 4.4.
    
    '''Finish creating the commander after frame.finishCreate.'''
    
    c = self ; p = c.currentPosition()
    c.miniBufferWidget = c.frame.miniBufferWidget
    # g.trace('Commands')
    
    # Create a keyHandler even if there is no miniBuffer.
    c.keyHandler = leoKeys.keyHandlerClass(c,
        useGlobalKillbuffer=True,
        useGlobalRegisters=True)

    # There is no miniBufferWidget created for leoSettings.leo files.
    if c.miniBufferWidget:
        c.commandsDict = leoEditCommands.finishCreateEditCommanders(c)
        # c.printCommandsDict()
    else:
        c.commandsDict = {}

    c.keyHandler.finishCreate()

    # Create the menu last so that we can use the key handler for shortcuts.
    if not g.doHook("menu1",c=c,p=p,v=p):
        c.frame.menu.createMenuBar(c.frame)</t>
<t tx="ekr.20050920094212">def createMiniBufferWidget (self):
    
    '''Create the minbuffer below the status line.'''
    
    frame = self ; c = frame.c

    frame.minibufferFrame = f = Tk.Frame(frame.outerFrame,relief='flat',borderwidth=0)
    if c.showMinibuffer:
        f.pack(side='bottom',fill='x')

    lab = Tk.Label(f,text='mini-buffer',justify='left',anchor='nw',foreground='blue')
    lab.pack(side='left')
    
    if c.useTextMinibuffer:
        label = Tk.Text(f,height=1,relief='groove',background='lightgrey',name='minibuffer')
        label.pack(side='left',fill='x',expand=1,padx=2,pady=1)
    else:
        label = Tk.Label(f,relief='groove',justify='left',anchor='w',name='minibuffer')
        label.pack(side='left',fill='both',expand=1,padx=2,pady=1)
    
    frame.minibufferVisible = c.showMinibuffer

    return label</t>
<t tx="ekr.20050920094633">def finishCreate (self):
    
    '''Complete the construction of the keyHandler class.
    c.commandsDict has been created when this is called.'''
    
    k = self ; c = k.c
   
    k.createInverseCommandsDict()
    
    if not c.miniBufferWidget:
        # Does not exist for leoSettings.leo files.
        return
        
    # g.trace('keyHandler')

    # Important: bindings exist even if c.showMiniBuffer is False.
    k.makeAllBindings()
    
    c.frame.log.setTabBindings('Log')
    c.frame.tree.setBindings()
    if not g.app.newWorldOrder:
        # Hurray.  This was a massive kludge.
        g.enableIdleTimeHook(250)
    
    if 0:
        addTemacsExtensions(k)
        addTemacsAbbreviations(k)
        changeKeyStrokes(k,f.bodyCtrl)</t>
<t tx="ekr.20050921094025">@nocolor

**** Create a robust strategy for redrawing the screen.
    - It should be insensitive to premature idle time.
    - It should happen once per event.
    ?? Create masterEventHandler ??
        - Executes events, ** then ** redraws the screen and updates focus.

**** Create a robust strategy for updating focus.
    ?? Can it use OnActivateLeoEvent ??
        - This might be the only time focus could go into limbo!

- Resize headline widget after pastes.

- Remove most calls to update_idletasks ?
    - update_idletasks should be benign.
    - Warning: log code calls update_idletasks.

Before a3:
- Create a convenience method to execute minibuffer commands by name.
- Fix all bugs: update plugins and fix problems applying settings.
- Disable minibuffer when not in use.</t>
<t tx="ekr.20050921094025.254">@killcolor
</t>
<t tx="ekr.20050921094025.255">Buffer-menu-1-window
Buffer-menu-2-window
Buffer-menu-backup-unmark
Buffer-menu-delete
Buffer-menu-delete-backwards
Buffer-menu-execute
Buffer-menu-igrep
Buffer-menu-mark
Buffer-menu-maybe-mouse-select
Buffer-menu-mouse-select
Buffer-menu-not-modified
Buffer-menu-other-window
Buffer-menu-popup-menu
Buffer-menu-quit
Buffer-menu-save
Buffer-menu-select
Buffer-menu-switch-other-window
Buffer-menu-this-window
Buffer-menu-toggle-read-only
Buffer-menu-unmark
Buffer-menu-visit-tags-table</t>
<t tx="ekr.20050921094025.256">Custom-buffer-done
Custom-goto-parent
Custom-make-dependencies
Custom-mode-menu
Custom-reset-current
Custom-reset-saved
Custom-reset-standard
Custom-save
Custom-set

Electric-command-history-redo-expression

Footnote-add-footnote

Helper-describe-bindings
Helper-help

</t>
<t tx="ekr.20050921094025.257">Info-elisp-ref
Info-emacs-command
Info-emacs-key
Info-goto-emacs-command-node
Info-goto-emacs-key-command-node
Info-goto-node
Info-query
Info-search
Info-speedbar-browser
Info-split
Info-tagify
Info-validate
Info-visit-file</t>
<t tx="ekr.20050921094025.258">LaTeX-install-toolbar
LaTeX-mode

Manual-nuke-nroff-bs

Rd-mode

TeX-auto-generate
TeX-auto-generate-global
TeX-insert-quote
TeX-mode
TeX-submit-bug-report

View-process-status</t>
<t tx="ekr.20050921094025.259">abbrev-mode
abbrev-prefix-mark

abort-recursive-edit
about-xemacs
activate-region
ada-make-filename-from-adaname
ada-mode

add-change-log-entry
add-change-log-entry-other-window
add-global-abbrev
add-log-convert
add-mode-abbrev
add-name-to-file

advertised-switch-to-completions
advertised-undo

align
align-current
align-entire
align-highlight-rule
align-newline-and-indent
align-regexp
align-unhighlight-rule

all-hail-emacs
all-hail-xemacs
ams-tex-mode
ansi-color-for-comint-mode-on
apache-mode

append-next-kill
append-to-buffer
append-to-file
append-to-register

apply-macro-to-region-lines
appt-add
appt-delete
apropos
apropos-command
apropos-documentation
apropos-value
apropos-zippy
arp
asm-mode
assign-last-kbd-macro-to-key

auto-compression-mode
auto-fill-mode
auto-insert
auto-revert-mode
auto-save-mode
auto-show-make-point-visible
auto-show-mode

autoconf-mode
awk-mode</t>
<t tx="ekr.20050921094025.260">back-to-indentation
background
backtrace

backward-block-of-lines
backward-char
backward-char-command
backward-delete-char
backward-delete-char-untabify
backward-kill-line
backward-kill-paragraph
backward-kill-sentence
backward-kill-sexp
backward-kill-word
backward-list
backward-or-forward-delete-char
backward-or-forward-kill-sentence
backward-or-forward-kill-sexp
backward-or-forward-kill-word
backward-other-window
backward-page
backward-paragraph
backward-sentence
backward-sexp
backward-to-indentation
backward-up-list
backward-word

balance-windows
balloon-help-minor-mode
balloon-help-mode
base64-decode-region
base64-encode-region
basic-save-buffer

bbdb
bbdb-add-or-remove-mail-alias
bbdb-apply-next-command-to-all-records
bbdb-changed
bbdb-company
bbdb-complete-name
bbdb-create
bbdb-create-ftp-site
bbdb-creation-newer
bbdb-creation-no-change
bbdb-creation-older
bbdb-delete-current-field-or-record
bbdb-delete-current-record
bbdb-dial
bbdb-display-all-records-completely
bbdb-display-record-completely
bbdb-edit-current-field
bbdb-finger
bbdb-fontify-buffer
bbdb-force-record-create
bbdb-ftp
bbdb-help
bbdb-info
bbdb-insert-new-field
bbdb-load-touchtones
bbdb-menu
bbdb-merge-file
bbdb-name
bbdb-net
bbdb-notes
bbdb-omit-record
bbdb-print
bbdb-record-edit-notes
bbdb-record-edit-property
bbdb-refile-record
bbdb-send-mail
bbdb-show-all-recipients
bbdb-snarf
bbdb-snarf-region
bbdb-submit-bug-report
bbdb-timestamp-newer
bbdb-timestamp-older
bbdb-toggle-all-records-display-layout
bbdb-toggle-records-display-layout
bbdb-transpose-fields
bbdb-whois
bbdb-www
bbdb-www-grab-homepage
bbdb-yank
bbdb/gnus-annotate-sender
bbdb/gnus-show-all-recipients
bbdb/gnus-show-records
bbdb/gnus-snarf-signature
bbdb/mh-annotate-sender
bbdb/mh-show-sender
bbdb/rmail-annotate-sender
bbdb/rmail-show-sender
bbdb/vm-annotate-sender
bbdb/vm-set-auto-folder-alist
bbdb/vm-show-all-recipients
bbdb/vm-show-records
bbdb/vm-show-sender

beginning-of-buffer
beginning-of-buffer-other-window
beginning-of-defun
beginning-of-defun-raw
beginning-of-line
beginning-of-line-text

bib-cite-minor-mode
bib-mode
bibtex-mode
binary-overwrite-mode
blackbox
blink-cursor-mode
blink-matching-open
blink-paren
bnf-mode

bookmark-bmenu-list
bookmark-delete
bookmark-insert
bookmark-insert-location
bookmark-jump
bookmark-load
bookmark-locate
bookmark-menu-delete
bookmark-menu-insert
bookmark-menu-jump
bookmark-menu-locate
bookmark-menu-rename
bookmark-relocate
bookmark-rename
bookmark-save
bookmark-set
bookmark-write

br-complete-symbol
br-env-browse
br-env-load
br-three-button-mouse
br-to-from-viewer
br-two-button-mouse

browse-url
browse-url-at-mouse
browse-url-at-point
browse-url-cci
browse-url-firefox
browse-url-galeon
browse-url-generic
browse-url-gnome-moz
browse-url-grail
browse-url-iximosaic
browse-url-kde
browse-url-lynx-emacs
browse-url-lynx-xterm
browse-url-mail
browse-url-mmm
browse-url-mosaic
browse-url-mozilla
browse-url-netscape
browse-url-of-buffer
browse-url-of-dired-file
browse-url-of-file
browse-url-of-region
browse-url-opera
browse-url-w3
browse-url-w3-gnudoit
browse-url-w3m
browse-url-w3m-gnudoit

bsh-script-help

buffer-disable-undo
buffer-enable-undo
buffer-flush-undo
buffer-menu
buffer-menu-other-window

build
build-report
build-version

bury-buffer

byte-compile-and-load-file
byte-compile-buffer
byte-compile-file
byte-force-recompile
byte-recompile-directory
byte-recompile-file</t>
<t tx="ekr.20050921094025.261">c++-browse
c++-mode

c-add-style
c-comment-edit
c-macro-expand
c-mode
c-set-offset
c-set-style

calc
calc-dispatch
calc-embedded
calc-embedded-activate
calc-grab-rectangle
calc-grab-region
calc-keypad
calc-tutorial

calendar
call-last-kbd-macro
call-tree
caml-mode
camldebug
cancel-debug-on-entry
canonically-space-region

capitalize-region
capitalize-region-as-title
capitalize-region-or-word
capitalize-word

cd
cde-start-drag
cde-start-drag-region

center-line
center-paragraph
center-region
center-to-window-line

change-log-merge
change-log-mode
change-log-redate

check-ispell-version

checkdoc
checkdoc-continue
checkdoc-current-buffer
checkdoc-defun
checkdoc-eval-current-buffer
checkdoc-eval-defun
checkdoc-interactive
checkdoc-ispell
checkdoc-ispell-comments
checkdoc-ispell-continue
checkdoc-ispell-current-buffer
checkdoc-ispell-defun
checkdoc-ispell-interactive
checkdoc-ispell-message-interactive
checkdoc-ispell-message-text
checkdoc-ispell-start
checkdoc-message-interactive
checkdoc-message-text
checkdoc-minor-mode
checkdoc-rogue-spaces
checkdoc-start

choose-completion

clear-profiling-info
clear-rectangle
clearcase-install
clearcase-integrate
clearcase-unintegrate

clos-browse
column-number-mode
comint-dynamic-complete
comint-mode
comint-run
command-apropos
command-history-mode
comment-region
compare-windows
compilation-minor-mode
compilation-mode
compilation-shell-minor-mode
compile
compile-defun
complete

completion-do-in-minibuffer
completion-list-mode
completion-list-mode-quit
completion-switch-to-minibuffer

compose-mail
compose-mail-other-frame
compose-mail-other-window

consing-since-gc
context-en-mode
context-nl-mode

conx
conx-buffer
conx-load
conx-region

copy-file
copy-from-above-command
copy-primary-selection
copy-rectangle-to-register
copy-region-as-kill
copy-to-buffer
copy-to-register

count-lines-buffer
count-lines-page
count-lines-region
count-matches
count-words-buffer
count-words-region

cperl-mode
cperl-perldoc
cperl-perldoc-at-point

css-mode

ctypes-all-buffers
ctypes-auto-parse-mode
ctypes-buffer
ctypes-define-type
ctypes-define-type-in-mode
ctypes-dir
ctypes-file
ctypes-read-file
ctypes-tags

customize
customize-apropos
customize-apropos-faces
customize-apropos-groups
customize-apropos-options
customize-browse
customize-changed-options
customize-customized
customize-face
customize-face-other-window
customize-group
customize-group-other-window
customize-option
customize-option-other-window
customize-other-window
customize-save-customized
customize-save-variable
customize-saved
customize-set-value
customize-set-variable
customize-variable
customize-variable-other-window

cvs-checkout
cvs-examine
cvs-log-mode
cvs-quickdir
cvs-status
cvs-status-mode
cvs-update</t>
<t tx="ekr.20050921094025.262">dabbrev-completion
dabbrev-expand

dbx

debug
debug-on-entry

decipher
decipher-mode
decrease-left-margin
decrease-right-margin

define-abbrevs
define-global-abbrev
define-mail-alias
define-mode-abbrev
defining-kbd-macro

delete-backward-char
delete-blank-lines
delete-char
delete-completion-window
delete-directory
delete-file
delete-frame
delete-horizontal-space
delete-indentation
delete-matching-lines
delete-non-matching-lines
delete-other-frames
delete-other-windows
delete-primary-selection
delete-rectangle
delete-region
delete-selection-mode
delete-window
delete-windows-on

deprecated-help-command

describe-beta
describe-bindings
describe-buffer-case-table
describe-class
describe-copying
describe-current-display-table
describe-distribution
describe-function
describe-function-arglist
describe-function-at-point
describe-generic
describe-installation
describe-key
describe-key-briefly
describe-last-error
describe-method
describe-mode
describe-no-warranty
describe-pointer
describe-prefix-bindings
describe-project
describe-stroke
describe-syntax
describe-variable
describe-variable-at-point

desktop-entry-mode
desktop-read

diary
diary-mail-entries

dictionary
dictionary-lookup-definition
dictionary-match-words
dictionary-mouse-popup-matching-words
dictionary-popup-matching-words
dictionary-search

diff
diff-backup
diff-minor-mode
diff-mode

digit-argument
directory-tree-thing

dired
dired-apropos
dired-backup-diff
dired-cleanup
dired-compress-subdir-files
dired-describe-mode
dired-diff
dired-do-background-shell-command
dired-do-compress
dired-do-copy-regexp
dired-do-grep
dired-do-hardlink-regexp
dired-do-igrep
dired-do-igrep-find
dired-do-print
dired-do-relsymlink-regexp
dired-do-rename-regexp
dired-do-shell-command
dired-do-symlink-regexp
dired-do-uucode
dired-downcase
dired-ediff
dired-emerge
dired-emerge-with-ancestor
dired-epatch
dired-flag-extension
dired-flag-files-regexp
dired-jump-back
dired-jump-back-other-frame
dired-jump-back-other-window
dired-mark-extension
dired-mark-files-compilation-buffer
dired-mark-files-from-other-dired-buffer
dired-mark-files-regexp
dired-mark-sexp
dired-other-frame
dired-other-window
dired-read-mail
dired-report-bug
dired-rmail
dired-summary
dired-upcase
dired-virtual
dired-vm

disable-command
disassemble

display-buffer
display-call-tree
display-column-mode
display-time

dissociated-press
dns-mode
dns-mode-soa-increment-serial
do-auto-save
docbook-grep
docbook-mode
docref-setup
doctor
down-list

downcase-region
downcase-region-or-word
downcase-word

drag-window-divider
dsssl-mode
dunnet</t>
<t tx="ekr.20050921094025.263">ebuffers
ebuffers3

ecb-activate
ecb-byte-compile
ecb-minor-mode
ecb-show-help
edebug-defun
edebug-eval-top-level-form

ediff
ediff-backup
ediff-buffers
ediff-buffers3
ediff-customize
ediff-directories
ediff-directories3
ediff-directory-revisions
ediff-documentation
ediff-files
ediff-files3
ediff-merge
ediff-merge-buffers
ediff-merge-buffers-with-ancestor
ediff-merge-directories
ediff-merge-directories-with-ancestor
ediff-merge-directory-revisions
ediff-merge-directory-revisions-with-ancestor
ediff-merge-files
ediff-merge-files-with-ancestor
ediff-merge-revisions
ediff-merge-revisions-with-ancestor
ediff-merge-with-ancestor
ediff-patch-buffer
ediff-patch-file
ediff-regions-linewise
ediff-regions-wordwise
ediff-revision
ediff-show-registry
ediff-toggle-multiframe
ediff-toggle-use-toolbar
ediff-version
ediff-windows-linewise
ediff-windows-wordwise
ediff3

edir-merge-revisions
edir-merge-revisions-with-ancestor
edir-revisions
edirs
edirs-merge
edirs-merge-with-ancestor
edirs3

edit-abbrevs
edit-abbrevs-mode
edit-abbrevs-redefine
edit-bookmarks
edit-faces
edit-itimers
edit-kbd-macro
edit-last-kbd-macro
edit-mime
edit-named-kbd-macro
edit-picture
edit-pr
edit-tab-stops
edit-tab-stops-note-changes
edit-toolbar

edt-emulation-on
edt-set-scroll-margins

efs-display-ftp-activity
efs-nslookup-host
efs-report-bug
efs-set-passwd
efs-set-user

eieio-class-tree
eieio-describe-class
eieio-describe-generic
eieio-describe-method

eif-browse
eiffel-mode
eldoc-mode

electric-buffer-list
electric-command-history
electric-nroff-mode

elp-instrument-function
elp-instrument-list
elp-instrument-package
elp-results

emacs-lisp-byte-compile
emacs-lisp-byte-compile-and-load
emacs-lisp-mode
emacs-version

emerge
emerge-buffers
emerge-buffers-with-ancestor
emerge-files
emerge-files-with-ancestor
emerge-merge-directories
emerge-revisions
emerge-revisions-with-ancestor

enable-command
enable-flow-control

encrypt-insert-file-contents

end-kbd-macro
end-of-buffer
end-of-buffer-other-window
end-of-defun
end-of-line

enlarge-window
enlarge-window-horizontally
enlarge-window-pixels

enriched-mode
epatch

epatch-buffer
erase-buffer

erc-add-dangerous-host
erc-add-fool
erc-add-keyword
erc-add-pal
erc-autojoin-mode
erc-button-mode
erc-chanlist
erc-cmd-LIST
erc-complete
erc-completion-mode
erc-delete-dangerous-host
erc-delete-fool
erc-delete-keyword
erc-delete-pal
erc-fill-mode
erc-log-mode
erc-nickserv-identify
erc-nickserv-identify-mode
erc-notify-mode
erc-ring-mode
erc-save-buffer-in-logs
erc-select
erc-server-select
erc-services-mode
erc-spelling-mode
erc-timestamp-mode
erc-track-mode
erc-track-when-inactive-mode
erc-truncate-buffer
erc-truncate-mode
erc-xdcc-add-file

eregistry
erevision
escreen-install

eshell
eshell-command
eshell-report-bug
eshell-test
eshell-toggle
eshell-toggle-cd

eudc-edit-hotlist
eudc-expand-inline
eudc-get-email
eudc-get-phone
eudc-insert-record-at-point-into-bbdb
eudc-load-eudc
eudc-query-form
eudc-set-server
eudc-try-bbdb-insert

eval-buffer
eval-current-buffer
eval-defun
eval-expr
eval-expr-install
eval-expression
eval-last-sexp
eval-print-last-sexp
eval-region

exchange-dot-and-mark
exchange-point-and-mark

executable-self-display
executable-set-magic

execute-extended-command

exit-minibuffer
exit-recursive-edit

expand-abbrev
expand-region-abbrevs</t>
<t tx="ekr.20050921094025.264">f90-mode

facemenu-make-larger
facemenu-make-much-larger
facemenu-make-much-smaller
facemenu-make-smaller
facemenu-remove-props
facemenu-remove-special
facemenu-set-background
facemenu-set-face
facemenu-set-face-from-menu
facemenu-set-foreground
facemenu-set-intangible
facemenu-set-invisible
facemenu-set-read-only
facemenu-set-size-default

fast-lock-mode

feedmail-queue-reminder
feedmail-run-the-queue
feedmail-run-the-queue-global-prompt
feedmail-run-the-queue-no-prompts

ffap
ffap-at-mouse
ffap-menu
ffap-next

fill-individual-paragraphs
fill-nonuniform-paragraphs
fill-paragraph
fill-paragraph-or-region
fill-region
fill-region-as-paragraph

find-alternate-file
find-alternate-file-other-window
find-file
find-file-at-point
find-file-other-frame
find-file-other-window
find-file-read-only
find-file-read-only-other-frame
find-file-read-only-other-window
find-function
find-function-at-point
find-function-on-key
find-function-other-frame
find-function-other-window
find-library
find-library-other-frame
find-library-other-window
find-tag
find-tag-at-point
find-tag-other-window
find-variable
find-variable-at-point
find-variable-other-frame
find-variable-other-window

finder-by-keyword
finder-commentary
finger
first-error
fixup-whitespace
flame

floating-toolbar
floating-toolbar-from-extent-or-popup-mode-menu
floating-toolbar-or-popup-mode-menu

flush-lines

flyspell-buffer
flyspell-mode
flyspell-prog-mode
flyspell-region
flyspell-version

folding-mode
folding-mode-add-find-file-hook

font-lock-fontify-buffer
font-lock-mode

footnote-mode

format-decode-buffer
format-decode-region
format-encode-buffer
format-encode-region
format-find-file
format-insert-file
format-write-file

forms-find-file
forms-find-file-other-window
forms-mode

fortran-mode

forward-block-of-lines
forward-char
forward-char-command
forward-line
forward-list
forward-page
forward-paragraph
forward-sentence
forward-sexp
forward-to-indentation
forward-word

frame-configuration-to-register
ftelnet
ftp
full-calc
full-calc-keypad
fume-mode
fume-setup-buffer
function-menu
fundamental-mode
fusion-mode</t>
<t tx="ekr.20050921094025.265">garbage-collect
gdb
gdb-with-core
gdbsrc
generate-file-autoloads
generic-page-setup
generic-print-buffer
getenv

global-auto-revert-mode
global-semantic-auto-parse-mode
global-semantic-show-dirty-mode
global-semantic-show-unmatched-syntax-mode
global-semantic-summary-mode
global-semanticdb-minor-mode
global-senator-minor-mode
global-set-key
global-set-stroke
global-unset-key

gnats:edit-pr
gnats:query-pr
gnats:summ-pr
gnats:view-pr

gnuserv-start
gomoku

google-query
google-query-region

goto-address
goto-address-at-mouse
goto-address-at-point
goto-char
goto-line

grep
grep-all-files-in-current-directory
grep-all-files-in-current-directory-and-below
grep-find

gtk-start-drag
gtk-start-drag-region</t>
<t tx="ekr.20050921094025.266">hanoi
haskell-doc-mode
haskell-doc-show-type
haskell-mode

help
help-for-help
help-mode
help-mode-bury
help-mode-quit
help-next-section
help-next-symbol
help-prev-section
help-prev-symbol
help-quit
help-with-tutorial

hexl-find-file
hexl-mode
hexlify-buffer

hide-copyleft-region
hide-ifdef-mode

highlight-headers-follow-url
highlight-headers-follow-url-kfm
highlight-headers-follow-url-mosaic
highlight-headers-follow-url-netscape

highline-customize
highline-local-mode
highline-mode
highline-mode-off
highline-mode-on
highline-off
highline-on
highline-view-mode
highline-view-off
highline-view-on

hippie-expand
hm--html-minor-mode
hm--html-mode
hmail:compose
holidays
how-many
hs-minor-mode

html-mode
html-quote-region
html-view-get-display
html-view-goto-url
html-view-start-mosaic
html-view-view-buffer
html-view-view-file
htmlize-buffer
htmlize-file
htmlize-many-files
htmlize-many-files-dired
htmlize-region

hyper-apropos
hyper-apropos-popup-menu
hyper-apropos-set-variable
hyper-describe-face
hyper-describe-function
hyper-describe-key
hyper-describe-key-briefly
hyper-describe-variable
hyper-set-variable
hyper-where-is

hyperb:customize
hyperb:find-file-urls-mode
hyperb:init-menubar
hyperbole

hypropos-popup-menu
hypropos-set-variable</t>
<t tx="ekr.20050921094025.267">ibuffer
ibuffer-add-saved-filters
ibuffer-add-to-tmp-hide
ibuffer-add-to-tmp-show
ibuffer-auto-mode
ibuffer-backward-filter-group
ibuffer-backwards-next-marked
ibuffer-bs-show
ibuffer-clear-filter-groups
ibuffer-copy-filename-as-kill
ibuffer-customize
ibuffer-decompose-filter
ibuffer-delete-saved-filter-groups
ibuffer-delete-saved-filters
ibuffer-diff-with-file
ibuffer-do-kill-lines
ibuffer-do-occur
ibuffer-exchange-filters
ibuffer-filter-disable
ibuffer-filters-to-filter-group
ibuffer-forward-next-marked
ibuffer-invert-sorting
ibuffer-jump-to-buffer
ibuffer-jump-to-filter-group
ibuffer-kill-filter-group
ibuffer-kill-line
ibuffer-list-buffers
ibuffer-mark-by-file-name-regexp
ibuffer-mark-by-mode
ibuffer-mark-by-mode-regexp
ibuffer-mark-by-name-regexp
ibuffer-mark-dired-buffers
ibuffer-mark-dissociated-buffers
ibuffer-mark-help-buffers
ibuffer-mark-modified-buffers
ibuffer-mark-old-buffers
ibuffer-mark-read-only-buffers
ibuffer-mark-special-buffers
ibuffer-mark-unsaved-buffers
ibuffer-negate-filter
ibuffer-or-filter
ibuffer-other-window
ibuffer-pop-filter
ibuffer-pop-filter-group
ibuffer-save-filter-groups
ibuffer-save-filters
ibuffer-set-filter-groups-by-mode
ibuffer-switch-to-saved-filter-groups
ibuffer-switch-to-saved-filters
ibuffer-toggle-sorting-mode
ibuffer-yank

icomplete-mode
icon-mode
iconify-emacs
iconify-frame

id-select-and-copy-thing
id-select-and-kill-thing
id-select-goto-matching-tag
id-select-install
id-select-thing
id-select-thing-with-mouse

idl-mode
idlwave-mode
idlwave-shell
ielm
ifconfig

ignore

igrep
igrep-find
igrep-insinuate
igrep-visited-files

ilisp-imenu-add-menubar-index
image-mode

imenu
imenu-add-menubar-index
imenu-add-to-menubar

increase-left-margin
increase-right-margin

increment-register

indent-according-to-mode
indent-code-rigidly
indent-for-comment
indent-for-tab-command
indent-new-comment-line
indent-region
indent-relative
indent-relative-maybe
indent-rigidly
indent-sexp
indent-to
indent-to-column

indented-text-mode
inferior-prolog-mode
inferior-tcl

info
info-browse
info-complete-file
info-complete-symbol
info-lookup-file
info-lookup-reset
info-lookup-symbol

insert-abbrevs
insert-buffer
insert-file
insert-kbd-macro
insert-key-binding
insert-parentheses
insert-register
insert-selection
insert-zippyism

install-where-was-i
inverse-add-global-abbrev
inverse-add-mode-abbrev
invert-face
ipconfig

isearch-*-char
isearch-abort
isearch-backward
isearch-backward-regexp
isearch-cancel
isearch-complete
isearch-complete-edit
isearch-delete-char
isearch-edit-string
isearch-exit
isearch-forward
isearch-forward-exit-minibuffer
isearch-forward-regexp
isearch-help-or-delete-char
isearch-mode-help
isearch-nonincremental-exit-minibuffer
isearch-printing-char
isearch-quote-char
isearch-repeat-backward
isearch-repeat-forward
isearch-return-char
isearch-reverse-exit-minibuffer
isearch-ring-advance
isearch-ring-advance-edit
isearch-ring-retreat
isearch-ring-retreat-edit
isearch-toggle-case-fold
isearch-toggle-regexp
isearch-whitespace-chars
isearch-yank-clipboard
isearch-yank-kill
isearch-yank-line
isearch-yank-selection
isearch-yank-sexp
isearch-yank-word
isearch-yank-x-clipboard
isearch-yank-x-selection
isearch-|-char

iso-accents-mode

ispell
ispell-buffer
ispell-change-dictionary
ispell-comments-and-strings
ispell-complete-word
ispell-complete-word-interior-frag
ispell-continue
ispell-kill-ispell
ispell-message
ispell-minor-mode
ispell-pdict-save
ispell-region
ispell-word

iswitchb-buffer
iswitchb-buffer-other-frame
iswitchb-buffer-other-window
iswitchb-default-keybindings
iswitchb-display-buffer

itimer-edit-delete-itimer
itimer-edit-help
itimer-edit-next-field
itimer-edit-previous-field
itimer-edit-quit
itimer-edit-set-field</t>
<t tx="ekr.20050921094025.268">japanese-latex-mode
japanese-plain-tex-mode

java-browse
java-mode

javascript-mode
javascript-shell

jde-ant-build
jde-ant-projecthelp
jde-ant-show-options
jde-bug-debug-app
jde-build
jde-checkstyle
jde-checkstyle-customize
jde-compile
jde-compile-jde
jde-create-new-project
jde-db-set-app-args
jde-db-set-args
jde-db-set-debugger
jde-ejb-entity-bean-buffer
jde-ejb-session-bean-buffer
jde-gen-buffer
jde-gen-class-buffer
jde-gen-console-buffer
jde-gen-interface-buffer
jde-gen-jfc-app-buffer
jde-gen-junit-test-class-buffer
jde-help-browse-jdk-doc
jde-import-organize
jde-java-font-lock-setup-keywords
jde-javadoc-autodoc-at-line
jde-javadoc-checkdoc
jde-javadoc-checkdoc-at-line
jde-javadoc-checker-fix
jde-javadoc-checker-next
jde-javadoc-checker-previous
jde-javadoc-checker-quit
jde-javadoc-customize
jde-javadoc-make
jde-jdb
jde-jdb-applet
jde-make
jde-make-show-options
jde-mode
jde-open-project-file
jde-package-update
jde-run
jde-run-applet
jde-run-set-app
jde-run-set-app-args
jde-run-set-applet-doc
jde-run-set-applet-viewer
jde-run-set-args
jde-save-project
jde-set-compile-options
jde-set-global-classpath
jde-show-help
jde-stat-loc-report
jde-stat-loc-report-directory
jde-stat-loc-report-project
jde-xref-customize
jde-xref-display-call-tree
jde-xref-first-caller
jde-xref-list-uncalled-functions
jde-xref-make-xref-db
jde-xref-next-caller
jde-xref-update

join-line
jump-to-register
just-one-space
justify-current-line</t>
<t tx="ekr.20050921094025.269">kbd-macro-query
keep-lines

keyboard-escape-quit
keyboard-quit

kfile:find
kfile:view

kill-all-abbrevs
kill-buffer
kill-buffer-and-window
kill-comment
kill-console-local-variable
kill-emacs
kill-entire-line
kill-line
kill-local-variable
kill-paragraph
kill-primary-selection
kill-rectangle
kill-region
kill-ring-save
kill-sentence
kill-sexp
kill-some-buffers
kill-this-buffer
kill-word

kimport:aug-post-outline
kimport:file
kimport:star-outline
kimport:text

klink:create
kotl-mode
kotl-mode:example
ksh-mode</t>
<t tx="ekr.20050921094025.270">latex-mode
lazy-lock-mode
lazy-shot-mode
ledit-mode
liece
life
line-number-mode
linuxdoc-sgml-mode

lisp-complete-symbol
lisp-fill-paragraph
lisp-indent-for-comment
lisp-indent-line
lisp-interaction-mode
lisp-mode
lisp-send-defun

list-abbrevs
list-bookmarks
list-buffers
list-colors-display
list-command-history
list-directory
list-faces-display
list-holidays
list-itimers
list-load-path-shadows
list-matches-in-buffers
list-matching-lines
list-mode
list-mode-item-keyboard-selected
list-mode-item-mouse-selected
list-packages
list-processes
list-strokes
list-tags
list-text-properties-at
list-yahrzeit-dates

literate-haskell-mode

load-default-sounds
load-file
load-library
load-sound-file
load-user-strokes

local-set-key
local-unset-key

locate-library
lock-buffer
lower-frame
lpr-buffer
lpr-region
lua-mode</t>
<t tx="ekr.20050921094025.271">m4-mode

macroexpand-all-sexp
macroexpand-sexp

mail
mail-mode
mail-other-frame
mail-other-window

make-command-summary
make-compatible
make-compatible-variable
make-directory
make-directory-path
make-face-bold
make-face-bold-italic
make-face-italic
make-face-larger
make-face-smaller
make-face-unbold
make-face-unitalic
make-file-part
make-frame
make-indirect-buffer
make-local-variable
make-obsolete
make-obsolete-variable
make-search-dialog
make-symbolic-link
make-variable-buffer-local
makefile-mode

manual-entry
map-query-replace-regexp
mark-beginning-of-buffer

mark-bob
mark-defun
mark-end-of-buffer
mark-end-of-line
mark-end-of-sentence
mark-eob
mark-page
mark-paragraph
mark-sexp
mark-whole-buffer
mark-word

maybe-unmigrate-user-init-file
mchat
mchat-other-frame

metamail-buffer
metamail-interpret-body
metamail-interpret-header
metamail-region

mew
mew-send
mh-letter-mode
mh-nmail
mh-rmail
mh-smail
mh-smail-other-window
mh-version
migrate-user-init-file
mime-decode-region
mime-encode-region
mime-insert-encoded-file
mime/editor-mode

minibuffer-complete
minibuffer-complete-and-exit
minibuffer-complete-word
minibuffer-completion-help
minibuffer-electric-separator
minibuffer-electric-tilde
minibuffer-keyboard-quit
minibuffer-smart-maybe-select-highlighted-completion
minibuffer-smart-select-highlighted-completion

mode-compile
mode-compile-kill
mode-compile-submit-bug-report

modeline-buffers-menu
modeline-menu
modeline-minor-mode-menu
modeline-toggle-read-only

modify-syntax-entry
modula-2-mode
morse-region

mouse-avoidance-mode
mouse-bury-buffer
mouse-choose-completion
mouse-consolidated-yank
mouse-del-char
mouse-delete-window
mouse-drag-modeline
mouse-eval-last-sexpr
mouse-eval-sexp
mouse-ignore
mouse-keep-one-window
mouse-kill-line
mouse-line-length
mouse-me
mouse-scroll
mouse-select
mouse-select-and-split
mouse-set-mark
mouse-set-point
mouse-track
mouse-track-adjust
mouse-track-adjust-default
mouse-track-default
mouse-track-delete-and-insert
mouse-track-do-rectangle
mouse-track-insert
mouse-unbury-buffer
mouse-window-to-region
mouse-yank

move-past-close-and-reindent
move-to-left-margin
move-to-tab-stop
move-to-window-line

mpuz
mswindows-paste-clipboard
mwheel-install</t>
<t tx="ekr.20050921094025.272">name-last-kbd-macro

narrow-stack-mode
narrow-to-defun
narrow-to-page
narrow-to-region
narrow-window-to-region

negative-argument
netstat
network-connection
network-connection-to-service
new-frame

newline
newline-and-indent

next-complete-history-element
next-error
next-file
next-history-element
next-line
next-list-mode-item
next-matching-history-element
next-multiframe-window

normal-mode
not-modified
nroff-mode
nslookup
nslookup-host
nuke-nroff-bs
nuke-selective-display
number-to-register</t>
<t tx="ekr.20050921094025.273">objc-browse
objc-mode

occur
occur-mode-goto-occurrence
occur-mode-mouse-goto

offix-start-drag
offix-start-drag-region

old-whitespace-incremental-mode
old-whitespace-mode

oo-browser

open-dribble-file
open-line
open-rectangle
open-termscript

other-frame
other-window

outl-mouse-minor-mode
outl-mouse-mode

outline-minor-mode
outline-mode

overstrike-region
overwrite-mode
own-selection</t>
<t tx="ekr.20050921094025.274">package-admin-add-binary-package
package-admin-add-single-file-package
package-get
package-get-all
package-get-custom
package-get-delete-package
package-get-package-provider
package-get-save-base
package-get-update-all
package-get-update-base
package-get-update-base-from-buffer

paragraph-indent-text-mode
paren-activate
paren-backward-sexp
paren-deactivate
paren-forward-sexp
paren-set-mode
paren-toggle-matching-paired-delimiter
paren-toggle-matching-quoted-paren
paren-toggle-open-paren-context

pascal-mode
patch-to-change-log

patcher-mail
patcher-mail-subproject
patcher-version

pcomplete
pcomplete-continue
pcomplete-expand
pcomplete-expand-and-complete
pcomplete-help
pcomplete-list
pcomplete-reverse

pdb

pending-delete
pending-delete-mode
pending-delete-off
pending-delete-on

perl-mode
perldb
permanent-buffers-mode

pgg-decrypt
pgg-decrypt-region
pgg-encrypt
pgg-encrypt-region
pgg-insert-key
pgg-sign
pgg-sign-region
pgg-snarf-keys
pgg-snarf-keys-region
pgg-verify
pgg-verify-region

phases-of-moon
php-mode
picture-mode
pike-mode
ping

plain-TeX-mode
plain-tex-mode

play-sound-file
point-to-register

pop-global-mark
pop-tag-mark
pop-window-configuration

popper-install

popup-buffer-menu
popup-menubar-menu
popup-mode-menu

posix-search-backward
posix-search-forward

postscript-mode

pp-eval-expression
pp-eval-last-sexp
pp-function
pp-plist
pp-variable

praise-be-unto-emacs
praise-be-unto-xemacs

prefer-coding-system
prefix-region

prepend-to-buffer
prepend-to-register

press-toolbar-button

prettyexpand-all-sexp
prettyexpand-sexp

previous-complete-history-element
previous-error
previous-history-element
previous-line
previous-list-mode-item
previous-matching-history-element
previous-multiframe-window

print-buffer
print-region

profile-command
profile-expression
profile-key-sequence
profile-results

prolog-mode

ps
ps-despool
ps-line-lengths
ps-nb-pages-buffer
ps-nb-pages-region
ps-print-buffer
ps-print-buffer-with-faces
ps-print-customize
ps-print-region
ps-print-region-with-faces
ps-spool-buffer
ps-spool-buffer-with-faces
ps-spool-region
ps-spool-region-with-faces

psychoanalyze-pinhead
pui-add-install-directory
pui-list-packages
push-window-configuration
pwd

py-shell
pydoc-apropos
pydoc-commands
pydoc-help
pydoc-keywords
pydoc-modules
pydoc-packages
pydoc-topics
pydoc-xrefs

pymacs-eval
pymacs-load

python-browse
python-mode</t>
<t tx="ekr.20050921094025.275">query-pr
query-replace
query-replace-regexp
quick-calc
quoted-insert</t>
<t tx="ekr.20050921094025.276">raise-frame

re-builder
re-search-backward
re-search-forward

read-abbrev-file
read-kbd-macro
read-library-name

recent-files-initialize
recent-files-visit-file

recenter

recentf-cancel-dialog
recentf-cleanup
recentf-dialog-mode
recentf-edit-list
recentf-mode
recentf-open-files
recentf-open-more-files
recentf-rebuild-virtual-pathes
recentf-save-list

recover-all-files
recover-file
recover-session
recover-session-finish

recursive-edit

reftex-citation
reftex-index-phrases-mode
reftex-mode

regexp-builder
register-to-point
reindent-then-newline-and-indent
release-and-activate-toolbar-button
release-toolbar-button
remote-compile
remove-directory

rename-buffer
rename-file
rename-uniquely

repeat-complex-command
repeat-matching-complex-command

replace-buffer-in-windows
replace-rectangle
replace-regexp
replace-string

report-emacs-bug
report-xemacs-bug

reposition-window
resize-minibuffer-mode
restore-initial-toolbar
resume-console
reverse-region
revert-buffer
rexx-mode
riece
rlogin

rmail
rmail-input
rmail-mode

rolo-add
rolo-display-matches
rolo-edit
rolo-fgrep
rolo-fgrep-logical
rolo-grep
rolo-kill
rolo-sort
rolo-toggle-datestamps
rolo-yank

rot13-other-window
rotate-yank-pointer
route

rpm
rpm-spec-mode

rsh

rtf-clip-buffer
rtf-clip-region
rtf-export
rtf-export-region
rtf-spool-buffer
rtf-spool-region

ruby-mode
rubydb

run-at-time
run-caml
run-ediff-from-cvs-buffer
run-prolog
run-ruby
run-scheme
run-scsh
run-sml
run-with-idle-timer
run-with-timer</t>
<t tx="ekr.20050921094025.277">s-region-bind
s-region-bind-cua

save-buffer
save-buffers-kill-emacs
save-some-buffers

savehist-load
savehist-save

scheme-mode
scribe-mode

scroll-down
scroll-down-command
scroll-down-one
scroll-left
scroll-other-window
scroll-other-window-down
scroll-right
scroll-up
scroll-up-command
scroll-up-one

sdb

search-backward
search-backward-regexp
search-forward
search-forward-regexp

self-insert-and-exit
self-insert-command

semantic-analyze-current-context
semantic-auto-parse-mode
semantic-bnf-mode
semantic-cb-speedbar-mode
semantic-chart-database-size
semantic-chart-nonterminal-complexity-token
semantic-chart-nonterminals-by-token
semantic-show-dirty-mode
semantic-show-unmatched-syntax-mode
semantic-summary-mode

senator-complete-symbol
senator-completion-menu-popup
senator-jump
senator-jump-regexp
senator-minor-mode
senator-next-token
senator-previous-token
senator-re-search-backward
senator-re-search-forward
senator-search-backward
senator-search-forward
senator-word-search-backward
senator-word-search-forward

send-pr
send-pr-mode
send-pr:send-pr
send-pr:send-pr-mode

set-buffer-file-coding-system
set-buffer-file-coding-system-for-read
set-buffer-process-coding-system
set-comment-column
set-default-buffer-file-coding-system
set-default-file-coding-system
set-face-background
set-face-background-pixmap
set-face-blinking-p
set-face-dim-p
set-face-display-table
set-face-doc-string
set-face-font
set-face-foreground
set-face-highlight-p
set-face-reverse-p
set-face-strikethru-p
set-face-underline-p
set-file-coding-system
set-file-coding-system-for-read
set-fill-column
set-fill-prefix
set-goal-column
set-justification
set-justification-center
set-justification-full
set-justification-left
set-justification-none
set-justification-right
set-keyboard-coding-system
set-left-margin
set-mark-command
set-pathname-coding-system
set-right-margin
set-selective-display
set-terminal-coding-system
set-variable
set-visited-file-name

setenv
setnu-mode
sgml-mode
sh-mode

shell
shell-command
shell-command-on-region
shell-script-mode

show-message-log

shrink-window
shrink-window-horizontally
shrink-window-if-larger-than-buffer
shrink-window-pixels

sieve-manage
sieve-mode
sieve-upload
sieve-upload-and-bury

signal-process
simula-mode

skeleton-pair-insert-maybe
skeleton-proxy
skeleton-proxy-new

smart-c++
smart-info
smart-info-assist
smart-java
smart-objc

smerge
sml-mode
smt-browse
snake
sokoban

sort-columns
sort-fields
sort-float-fields
sort-lines
sort-numeric-fields
sort-pages
sort-paragraphs
sort-regexp-fields
sort-regexp-fields-numerically

speedbar
speedbar-frame-mode
speedbar-get-focus

spell-buffer
spell-region
spell-string
spell-word

split-line
split-window
split-window-horizontally
split-window-vertically

spook

sql-db2
sql-help
sql-informix
sql-ingres
sql-interbase
sql-linter
sql-mode
sql-ms
sql-mysql
sql-oracle
sql-postgres
sql-product-interactive
sql-solid
sql-sqlite
sql-sybase

ssh
standard-display-european
start-itimer
start-kbd-macro
startup-presentation-hack
string-rectangle

strokes-compose-complex-stroke
strokes-decode-buffer
strokes-describe-stroke
strokes-do-complex-stroke
strokes-do-stroke
strokes-global-set-stroke
strokes-help
strokes-list-strokes
strokes-load-user-strokes
strokes-mode

style-format
summ-pr
sunrise-sunset

suspend-console
suspend-emacs
suspend-emacs-or-iconify-frame
suspend-or-iconify-emacs

switch-to-buffer
switch-to-buffer-other-frame
switch-to-buffer-other-window
switch-to-completions
switch-to-other-buffer

symbol-file
symbol-near-point</t>
<t tx="ekr.20050921094025.278">tab-to-tab-stop
tabify

tag-complete-symbol
tags-apropos
tags-loop-continue
tags-query-replace
tags-search

tcl-help-on-word
tcl-mode

tdbx
teco-command
telnet
term
terminal-emulator
tetris

tex-mode
texi2info
texinfo-format-buffer
texinfo-format-region
texinfo-mode
texmathp

text-mode
tgdb
time-stamp
time-stamp-toggle-active

tmpl-expand-templates-in-buffer
tmpl-expand-templates-in-region
tmpl-insert-template-file
tmpl-insert-template-file-from-fixed-dirs
tmpl-minor-mode

toggle-auto-compression
toggle-buffer-file-coding-system
toggle-debug-on-error
toggle-debug-on-quit
toggle-debug-on-signal
toggle-profiling
toggle-read-only
toggle-rot13-mode
toggle-text-mode-auto-fill
toggle-truncate-lines
toggle-viper-mode
toggle-where-was-i

toolbar-add-button-on-the-fly
toolbar-add-execute-macro-button
toolbar-add-kbd-macro
toolbar-compile
toolbar-copy
toolbar-cut
toolbar-debug
toolbar-dired
toolbar-external
toolbar-gnus
toolbar-info
toolbar-ispell
toolbar-ispell-internal
toolbar-mail
toolbar-news
toolbar-not-configured
toolbar-open
toolbar-paste
toolbar-print
toolbar-redo
toolbar-replace
toolbar-save
toolbar-search
toolbar-undo

top-level
tperldb
tpu-edt
tpu-edt-mode
tpu-edt-on
tpu-set-cursor-bound
tpu-set-cursor-free
tpu-set-scroll-margins

tpum-global-mode
tpum-minor-mode

trace-function
trace-function-background
traceroute

transpose-chars
transpose-line-down
transpose-line-up
transpose-lines
transpose-paragraphs
transpose-preceding-chars
transpose-sentences
transpose-sexps
transpose-words

tree-test-it-all
tsdb
tshell

turn-off-font-lock
turn-off-haskell-doc-mode
turn-off-pending-delete
turn-on-auto-fill
turn-on-eldoc-mode
turn-on-font-lock
turn-on-fume-mode
turn-on-haskell-doc-mode
turn-on-pending-delete
turn-on-permanent-buffers

txdb</t>
<t tx="ekr.20050921094025.279">uil-mode
undefined
underline-region
undo
unexpand-abbrev
unhide-copyleft-region

universal-argument
universal-argument-minus
universal-argument-more
universal-argument-other-key
universal-coding-system-argument

unix-sync
unload-feature
unlock-buffer
unmigrate-user-init-file
unmorse-region
unoverstrike-region
unpop-window-configuration
unrmail
untabify
ununderline-and-unoverstrike-region
ununderline-region
up-list

upcase-initials-region
upcase-region
upcase-region-or-word
upcase-word

update-autoloads-from-directory
update-autoloads-here
update-file-autoloads

url-gateway-nslookup-host
url-mail
url-setup-save-timer

use-hard-newlines
user-mail-address</t>
<t tx="ekr.20050921094025.280">vc-annotate
vc-cancel-version
vc-create-snapshot
vc-diff
vc-directory
vc-insert-headers
vc-load-vc-hooks
vc-merge
vc-next-action
vc-print-log
vc-register
vc-rename-file
vc-resolve-conflicts
vc-retrieve-snapshot
vc-revert-buffer
vc-update-change-log
vc-version-diff
vc-version-other-window

verilog-customize
verilog-mode
verilog-version

version
vertical-mode
vhdl-mode

view-buffer
view-buffer-other-window
view-emacs-news
view-file
view-file-other-window
view-lossage
view-major-mode
view-minor-mode
view-mode
view-pr
view-register
view-sample-init-el

viper-mode
visit-tags-table

vm
vm-compose-mail
vm-folders-summarize
vm-mail
vm-mail-other-frame
vm-mail-other-window
vm-mode
vm-other-frame
vm-other-window
vm-submit-bug-report
vm-visit-folder
vm-visit-folder-other-frame
vm-visit-folder-other-window
vm-visit-imap-folder
vm-visit-imap-folder-other-frame
vm-visit-imap-folder-other-window
vm-visit-pop-folder
vm-visit-pop-folder-other-frame
vm-visit-pop-folder-other-window
vm-visit-virtual-folder
vm-visit-virtual-folder-other-frame
vm-visit-virtual-folder-other-window

vrml-mode</t>
<t tx="ekr.20050921094025.281">w3
w3-display-stylesheet
w3-fetch
w3-fetch-other-frame
w3-find-file
w3-follow-link
w3-follow-url-at-point
w3-follow-url-at-point-other-frame
w3-hotindex-add-key
w3-hotindex-query
w3-hotindex-rm-key
w3-hotlist-add-document
w3-hotlist-add-document-at-point
w3-hotlist-append
w3-hotlist-apropos
w3-hotlist-delete
w3-hotlist-refresh
w3-hotlist-rename-entry
w3-maybe-follow-link
w3-maybe-follow-link-mouse
w3-next-document
w3-open-local
w3-prev-document
w3-preview-this-buffer
w3-print-this-url
w3-print-url-under-point
w3-read-html-bookmarks
w3-region
w3-show-dvi
w3-table-speak-current-table-column
w3-use-hotlist
w3-version

wconfig-add-by-name
wconfig-delete-by-name
wconfig-delete-pop
wconfig-restore-by-name
wconfig-ring-save
wconfig-yank-pop

webjump

what-coding-system
what-cursor-position
what-domain
what-line
what-page

where-is

whitespace-buffer
whitespace-cleanup
whitespace-cleanup-region
whitespace-global-mode
whitespace-region
whitespace-toggle-ateol-check
whitespace-toggle-indent-check
whitespace-toggle-leading-check
whitespace-toggle-spacetab-check
whitespace-toggle-trailing-check
whitespace-visual-incremental-mode
whitespace-visual-mode
whitespace-write-file-hook

whois
whois-reverse-lookup
widen

widget-backward
widget-beginning-of-line
widget-browse
widget-browse-at
widget-browse-other-window
widget-button-click
widget-button-press
widget-button1-click
widget-complete
widget-end-of-line
widget-field-activate
widget-file-complete
widget-forward
widget-kill-line
widget-minor-mode
widget-transpose-chars

win32-get-current-locale-id
win32-get-default-locale-id
win32-get-locale-info
win32-get-valid-locale-ids
win32-long-file-name
win32-set-current-locale
win32-set-process-priority
win32-short-file-name

window-configuration-to-register
winmgr-mode

winring-delete-configuration
winring-duplicate-configuration
winring-jump-to-configuration
winring-new-configuration
winring-next-configuration
winring-prev-configuration
winring-rename-configuration

word-search-backward
word-search-forward

wordstar-mode

write-abbrev-file
write-file
write-region
write-region-internal

wrolo-popup-menu</t>
<t tx="ekr.20050921094025.282">x-symbol-decode
x-symbol-decode-recode
x-symbol-encode
x-symbol-encode-recode
x-symbol-fontify
x-symbol-grid
x-symbol-image-editor
x-symbol-image-parse-buffer
x-symbol-init-language-interactive
x-symbol-initialize
x-symbol-key-autoload
x-symbol-map-autoload
x-symbol-mode
x-symbol-modify-key
x-symbol-package-bug
x-symbol-package-info
x-symbol-package-reply-to-report
x-symbol-package-web
x-symbol-rotate-key
x-symbol-unalias

xdb

xemacs-local-faq
xemacs-splash-buffer
xemacs-www-faq
xemacs-www-page

xetla
xetla-add-log-entry
xetla-apply-changeset
xetla-archives
xetla-bookmarks
xetla-browse
xetla-changelog
xetla-changes
xetla-changes-against
xetla-changes-last-revision
xetla-commit
xetla-conflicts-finish
xetla-delta
xetla-ediff-add-log-entry
xetla-edit-log
xetla-file-diff
xetla-file-ediff
xetla-file-ediff-revisions
xetla-file-view-original
xetla-get-changeset
xetla-help
xetla-id-tagging-method
xetla-inventory
xetla-inventory-file-mode
xetla-log-edit-mode
xetla-logs
xetla-make-archive
xetla-missing
xetla-my-id
xetla-my-revision-library
xetla-prepare-patch-submission
xetla-revisions
xetla-rm
xetla-start-project
xetla-submit-bug-report
xetla-tag-insert
xetla-tag-regenerate
xetla-tree-lint
xetla-tree-version
xetla-version
xetla-view-conflicts

xmine
xmine-mode
xml-mode
xpm-mode
xrdb-mode
xsl-grep
xsl-mode
xslt-process-mode
xt-check-xlib

xwem-attach-client
xwem-backward-application
xwem-balance-windows
xwem-battery
xwem-battery-popup-menu
xwem-battery-status
xwem-cl-pop-to-client
xwem-cl-set-title
xwem-cl-switch-other-frame
xwem-cl-switch-other-win
xwem-cl-switch-to-other
xwem-cl-switch-to-other-in-other-win
xwem-cl-transpose
xwem-clgen-toggle-other-on-split
xwem-clgen-turn-off-other-on-split
xwem-clgen-turn-on-other-on-split
xwem-client-demanage-others
xwem-client-exchange-selected-and-mark
xwem-client-iconify
xwem-client-idestroy
xwem-client-imove
xwem-client-info
xwem-client-iresize
xwem-client-kill
xwem-client-query-kill
xwem-client-run-copy
xwem-client-run-copy-other-frame
xwem-client-run-copy-other-win
xwem-client-set-mark
xwem-client-unset-mark
xwem-clswi-next
xwem-clswi-next-other-window
xwem-clswi-prev
xwem-clswi-prev-other-window
xwem-copy-cutbuffer
xwem-copy-region-as-cutbuffer
xwem-describe-prefix-bindings
xwem-desktop-load
xwem-desktop-load-onetime
xwem-desktop-save
xwem-desktop-save-onetime
xwem-edit-client-properties
xwem-edmacro-edit-kbd-macro
xwem-eval-expression
xwem-execute-extended-command
xwem-fini
xwem-focus-click-on
xwem-forward-application
xwem-frame-destroy
xwem-frame-fit-screen
xwem-frame-goto-next
xwem-frame-goto-next-hor
xwem-frame-goto-next-vert
xwem-frame-goto-prev
xwem-frame-goto-prev-hor
xwem-frame-goto-prev-vert
xwem-frame-hide
xwem-frame-imove
xwem-frame-iresize
xwem-frame-lower
xwem-frame-next
xwem-frame-on-delim-menu
xwem-frame-on-delim-resize
xwem-frame-previous
xwem-frame-raise
xwem-frame-sbs-hor-split
xwem-frame-sbs-vert-split
xwem-frame-set-name
xwem-frame-showroot
xwem-frame-split-sbs
xwem-frame-switch
xwem-frame-switch-nth
xwem-frame-switch-nth-linkage
xwem-frame-transparency
xwem-frame-transpose
xwem-framei-dockapp-popup-alt-menu
xwem-framei-dockapp-popup-menu
xwem-fullscreen-mode
xwem-help
xwem-help-clients
xwem-help-cutbuffers
xwem-help-describe-bindings
xwem-help-describe-key
xwem-help-describe-key1
xwem-help-for-help
xwem-help-frames
xwem-help-mode
xwem-help-where-is
xwem-help-wins
xwem-ignore-command
xwem-kbd-quit
xwem-kbd-quote-command
xwem-keyboard-quit
xwem-keymacro-begin
xwem-keymacro-end
xwem-keymacro-exit-recursive-edit
xwem-keymacro-recursive-edit
xwem-keymacro-undefined
xwem-keytt-minor-mode
xwem-kill-cl-and-window
xwem-launch-dock-down
xwem-launch-dock-launch
xwem-launch-dock-menu
xwem-launch-lupe
xwem-launch-lupe-other-frame
xwem-launch-lupe-other-win
xwem-launch-program
xwem-launch-program-other-frame
xwem-launch-program-other-win
xwem-launch-xlock
xwem-launch-xterm
xwem-launch-xterm-other-frame
xwem-launch-xterm-other-win
xwem-launcher-toggle-frame-type
xwem-launcher-toggle-split-type
xwem-launcher-turn-on-embedded-frame-type
xwem-launcher-turn-on-horizontal-split-type
xwem-launcher-turn-on-normal-frame-type
xwem-launcher-turn-on-vertical-split-type
xwem-make-frame
xwem-mini-calc
xwem-minib-resize-mode
xwem-minibuffer-activate
xwem-misc-make-screenshot
xwem-misc-pause
xwem-misc-profiling-results
xwem-misc-start-profiling
xwem-modeline-disable
xwem-modeline-enable
xwem-open-file
xwem-other-window
xwem-pager
xwem-pager-move-down
xwem-pager-move-left
xwem-pager-move-right
xwem-pager-move-up
xwem-paste-cutbuffer
xwem-popup-auto-menu
xwem-popup-clients-menu
xwem-recover-do-recover
xwem-recover-toggle
xwem-recover-turn-off
xwem-recover-turn-on
xwem-register-client
xwem-register-frame-config
xwem-register-jump
xwem-register-win-config
xwem-report-bug
xwem-rooter-lower
xwem-rooter-raise
xwem-run-program
xwem-self-insert-or-undefined
xwem-shell-command
xwem-show-message-log
xwem-sm-global-mode
xwem-sm-mode
xwem-strokes-begin
xwem-strokes-cmplx-begin
xwem-strokes-define
xwem-strokes-ibutton1
xwem-strokes-ibutton1up
xwem-strokes-ibutton3
xwem-strokes-idescribe
xwem-strokes-list
xwem-strokes-nocmd
xwem-strokes-unset-last-stroke
xwem-switch-client
xwem-switch-other-client
xwem-switch-to-fullscreen-cl
xwem-tabber-popup-cl-menu
xwem-tabber-switch-cl
xwem-theme-set
xwem-time
xwem-toggle-fullscreen
xwem-transpose-frames
xwem-turn-off-keytt
xwem-turn-off-vline
xwem-turn-on-keytt
xwem-turn-on-vline
xwem-undefined-command
xwem-universal-argument
xwem-universal-command
xwem-universal-digit
xwem-universal-minus
xwem-universal-more
xwem-vline-minor-mode
xwem-weather-popup-menu
xwem-weather-popup-remove
xwem-weather-show-details
xwem-weather-update
xwem-window-delete
xwem-window-delete-others
xwem-window-enlarge-horizontally
xwem-window-enlarge-vertically
xwem-window-split-horizontally
xwem-window-split-vertically
xwem-winmove-down
xwem-winmove-left
xwem-winmove-right
xwem-winmove-up
xwem-worklog-login
xwem-worklog-logout</t>
<t tx="ekr.20050921094025.283">yank
yank-clipboard-selection
yank-pop
yank-rectangle
yow
</t>
<t tx="ekr.20050921094025.284">zap-to-char
zap-up-to-char
zenirc</t>
<t tx="ekr.20050923172809.1">def callStateFunction (self,event):
    
    k = self ; val = None
    
    # g.trace(k.stateKind,k.state)
    
    if k.state.kind:
        if k.state.handler:
            val = k.state.handler(event)
            if val != 'continue':
                k.endCommand(event,k.commandName)
        else:
            g.es_print('no state function for %s' % (k.state.kind),color='red')
            
    return val</t>
<t tx="ekr.20050923174229.3">def callKeystrokeFunction (self,event):
    
    '''Handle a quick keystroke function.
    Return the function or None.'''
    
    k = self
    numberOfArgs, func = k.keystrokeFunctionDict [k.stroke]

    if func:
        func(event)
        commandName = k.inverseCommandsDict.get(func) # Get the emacs command name.
        # forceFocus = func.__name__ != 'leoCallback'
        k.endCommand(event,commandName)
    
    return func</t>
<t tx="ekr.20050923213858"># Previously defined bindings.
self.bindingsDict = {}
    # Keys are Tk key names, values are g.bunch(pane,func,commandName)

# Special bindings for k.fullCommand.
self.mb_copyKey = None
self.mb_pasteKey = None
self.mb_cutKey = None

# Keepting track of the characters in the mini-buffer.
self.mb_history = []
self.mb_prefix = ''
self.mb_tabListPrefix = ''
self.mb_tabList = []
self.mb_tabListIndex = -1
self.mb_prompt = ''

self.func = None
self.keysymHistory = []
self.previous = []

# For getArg...
self.afterGetArgState = None
self.argTabList = []

# For onIdleTime
self.idleCount = 0</t>
<t tx="ekr.20050924064254">@ There is something dubious about tracking states separately for separate commands.
In fact, there is only one mini-buffer, and it has only one state.
OTOH, maintaining separate states makes it impossible for one command to influence another.</t>
<t tx="ekr.20050924073836"></t>
<t tx="ekr.20050925105522">- (1-2 days) Complete generalization of code.
    - Allow state-oriented shortcuts (C-x C-x, for example)
    - Create new kinds of commands dispatchers: vim, tree, etc.
        - Single-key mode == vim mode??

- (1-2 hours) Tab completion for file commands.

- (1-2 days) Emacs-style help: appropos, etc.
    - printLongCommandName (like Emacs Ctrl-H Ctrl-K) command prints long name of any keystroke command.

* @link-unl/url/etc.

- Open .leo file in new process: alternative to test.leo!</t>
<t tx="ekr.20050928144501">* Traditional Emacs commands must be generalized to handle the more complex
envirnoment Leo offers. For example, search commands must be told whether to
limit the search a single node, or a node or and its descendents, or the entire
outline.

    - Expand 'point' so it indicates node as well as text location.
    - Allow Leo options (e.g. search options) in Emacs commands.
    - (Maybe) a default-search-command.
    - Implement set-variable command that sets a (Python) variable using an emacs-style variable name.
    
* At present, there are two versions of some operations, the traditional Leo way and the Emacs way.  Some simplification is needed.

* Many more commands are needed to support 'mouseless-Leo'.
    - The user must be able to set Emacs and Leo options from the keyboard.
    - The user must be able to drive all dialogs from the keyboard,
      **or to get the same effect without using a dialog at all**.

- Expand names for some Leo commands  new -&gt; new-outline, etc.

- Emacs search commands are limited to a single node.

- There should be a method for the 'check-spelling' command. (use button code)

- cycle-active-pane and cycle-active-widget (in a single pane) commands.

- create-tab, clear-tab commands, etc.
    These might get the tab name from the minibuffer...</t>
<t tx="ekr.20050928144501.1">Control all Leo commands &amp; widgets using only key commands.

- emacs commands for buttons, dialogs, etc.
    - dismiss-top-dialog command.
    - Scroll outline pane up/down

- emacs commands to change focus, etc.
    - focus-in-body/tree/log/dialog.

- emacs commands for menus.
    - activate-xxx-menu commands.  (alternative to XP Alt-f, Alt-E, etc.)



</t>
<t tx="ekr.20050930083044">@killcolor

Invoking:
    emacs file1 file2 file3 .... 

Help
    CTRL-h enters the Help facility.
    Help Tutorial  (CTRL-h t)
    Help Apropos   (CTRL-h a) find a command given its functionality,
    Help Character (CTRL-h c) describes a given character's effect,
    Help Function ( CTRL-h f) describes a given Lisp function specified by name.

Reading, writing files
    C-x C-f Find file (to read into buffer) 
    C-x C-s Save current buffer (ie. file in the buffer) 

Moving the cursor
    C-f forward character 
    C-b backward character 
    C-n next line 
    C-p previous line 
    C-e move cursor to end of line 
    C-a move cursor to beginning of line 
    Esc-&lt; move cursor to top of document 
    Esc-&gt; move cursor to bottom of document 
    Esc-f forward word 
    Esc-b backward word 
    Esc-a backward sentence 
    Esc-e forward sentence 
    Esc-] forward paragraph 
    Esc-[ backward paragraph 
    C-v forward page 
    Esc-v backward page 
    Esc-x goto-linen 
    Esc-x goto-char 
    C-l recenter and redraw page 

Repeating Commands
    ESC-5 C-f       move forward 5 chars 
    C-u (the universal argument command)
        Just like Esc-n, but does not need an argument -&gt; in which case the default of 4 is used. eg: 
    C-u C-u -&gt; repeat 16 times 

Deleting Stuff (Killing)
    C-d delete char 
    E-d kill word 
    C-k kill line (but not newline after it) 
    C-u C-k delete 4 lines (not 2 lines! - newlines go too!) 
    E-4 C-k same 

Yanking back things from the Kill ring
    C-y yank 
    C-w kill region 
    E-w copy region into kill ring 
    C-@ or C-SPC set-mark 
    
Paragraph Reformatting
    E-q fill-paragraph 
    E-g fill-region

Searching and replacing
    C-s isearch-forward 
    C-r isearch-backward 
    Esc exit a successful search 
    C-g quit 
    C-s Esc non incremental search forward 
    C-r Esc backward " 
    E-x  replace-string RET bad RET good RET 
    E-% query replace 

By default, searches are case insensitive. You can change this by setting the
variable: case-fold-search --&gt; set it to: nil (Use Esc-x set-variable) 
    E-x re-search-forward simple 
    E-x re-search-backward 
    E-x isearch-forward-regexp incremental 
    E-x isearch-backward-regexp 
    E-x query-replace-regexp 
    E-x replace-regexp 
    replace unconditionally 

Undo
    E-x revert-buffer restore file from disk 
    C-s u undo

Transpose
    C-t transpose characters 
    E-t transpose words 
    C-x C-t transpose lines 

Buffer Manipulation
    C-x b move to other buffer 
    C-x s save some buffers 
    E-x kill-buffer kill buffer 
    E-x kill-some-buffers kill some buffers 
    E-x rename-buffer rename buffer 
    C-x C-q toggle read only status of buffer 
    C-x C-b list buffers 

Window Manipulation
    C-x 2 split current window into 2 horizontals 
    C-x 5 vertically 
    C-x o move to other window 
    E-C v scroll next window 
    Attach '4' to C-x to have the operation go to the other window, eg: C-x 4 f find-file-other window 
    C-x 4 b change buffer other window 
    E-x compare-windows (must have 2 buffers in split windows) 

Spelling Checker
    E-$ (spell check the word the cursor is on)
    E-x spell-string
    E-x spell-buffer
    E-x spell-region

Shell commands in Emacs
    E-! run UNIX command 
    E-| run command on marked region (shell-command-on-region) 
    C-u E-! run UNIX command, but in the current window! 
    E-x shell invoke shell buffer 

Fix echo'ing and ^M ing at the end of lines: 
    stty -echo nl 

Dired: Directory Editor commands
    E-x dired or emacs  
    SPC move 
    n next 
    p prev 
    v view (via recursive edit) 
    C-c (or q) to return to directory list 
    d mark for deletion 
    e edit file 
    f edit file 
    x DELETE those marked 
    c copy file 
    r rename file 
    M change file permissions 

Text Formatting
    E-x fill-paragraph
    E-x fill-individual-paragraphs
    E-x edit-tab-stops
    E-x untabify (converts tabs to spaces)
    E-x tabify
    E-x mark-whole-buffer
    C-x h variable: indent-tabs-mode
    (if set to nil, Emacs always uses spaces to make tabs)
    C-x fill-prefix: this string automatically gets inserted at begin of each line
    C-x . set-fill-prefix
    E-x indented-text-mode

Centering Text
    E-s center-line
    E-x center-paragraph
    C-l form feed - used for pagination

Macros
    C-x ( start macro definition
    C-x ) end macro definition
    C-x e call-last-kbd-macro

Customizing Emacs
    (define-key keymap "keystroke" 'command-name)
    (global-set-key "keystroke" 'command-name)
    (local-set-key "keystroke" 'command-name)
    (global-unset-key "\C-s") 
    Example:
        (define-key global-map "\C-xl" 'goto-line)
            (global-set-key "\C-xl" 'goto-line) 
    Maps: global-map, ctl-x-map, esc-map 

Indentation
    E-C-\ indent-region 
    E-m back-to-indentation 
    E-^ delete-indentation join this line to previous 
    E-; indent-for-comment 

C-Mode
    E-C-a beginning-of-defun 
    E-C-e end-of-defun 
    E-C-h mark-c-function 

Variables Default 
    c-indent-level 2 
    c-auto-new-line nil 
    c-continued-statement-offset 2 
    c-argdecl-indent 5 
    c-brace-offset 0 
    c-continued-brace-offset 0 
    c-brace-imaginary-offset 0 
    c-label-offset -2 

ETAGS
    etags *.[ch] creates a TAGS file E-.
    find-tag C-x 4 find-tag-other-window E-,
    tags-loop-continue (find next tag)
    E-x tags-search prompts for an RE and finds it.
    find next by E-,
    E-x tags-query-replace
    C-u E-x tags-query-replace (only replace for full words) E-x list-tags 

Lisp Mode
    3: emacs-lisp-mode, lisp-mode, lisp-interaction-mode 
    S-expression: any syntactically correct LISP expression: atom or parenthesized list. 
    E C-a beginning-of-defun 
    E C-e end-of-defun 
    E C-h mark-defun 

Lisp Interaction Mode
    E-x lisp-interaction-mode
    LINEFEED C-j is bound to eval-print-last-sexp

Compiling Programs withing Emacs
    E-x compile
    default: make -k (controlled by compile-command variable)
    C-c ` next-error
    C-u C-x ` start at first error again
    E-x grep</t>
<t tx="ekr.20051001050607">def endCommand (self,event,commandName):

    '''Make sure Leo updates the widget following a command.
    
    Never changes the minibuffer label: individual commands must do that.
    '''

    k = self ; c = k.c
    if g.app.quitting: return
    
    # The command may have closed the window, so this may fail.
    try:
        p = c.currentPosition()
    except AttributeError:
        return

    # Set the best possible undoType: prefer explicit commandName to k.commandName.
    commandName = commandName or k.commandName or ''
    k.commandName = k.commandName or commandName or ''
    if commandName:
        bodyCtrl = c.frame.body.bodyCtrl
        if not k.inState():
            __pychecker__ = '--no-classattr --no-objattrs'
                # initAllEditCommanders *does* exist.
            k.commandName = None
            leoEditCommands.initAllEditCommanders(c)
            try:
                bodyCtrl.tag_delete('color')
                bodyCtrl.tag_delete('color1')
            except Exception:
                pass
        bodyCtrl.update_idletasks()
        c.frame.body.onBodyChanged(p,undoType='Typing')

    if g.app.newWorldOrder:
        k.redraw()
        k.setFocus()</t>
<t tx="ekr.20051002111614">def wordSearchBackward (self,event):

    k = self.k ; state = k.getState('word-search-backward')
    if state == 0:
        k.setLabelBlue('Word Search Backward: ',protect=True)
        k.getArg(event,'word-search-backward',1,self.wordSearchBackward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=False)

def wordSearchForward (self,event):

    k = self.k ; state = k.getState('word-search-forward')
    if state == 0:
        k.setLabelBlue('Word Search: ',protect=True)
        k.getArg(event,'word-search-forward',1,self.wordSearchForward)
    else:
        k.clearState()
        k.resetLabel()
        self.wordSearchHelper(event,k.arg,forward=True)</t>
<t tx="ekr.20051002120125">s = k.getLabel(ignorePrompt=True)

if s:
    if self.forward:
        if self.regexp: self.reSearchForward(event)
        else:           self.searchForward(event)
    else:
        if self.regexp: self.reSearchBackward(event)
        else:           self.searchBackward(event)</t>
<t tx="ekr.20051004093536"></t>
<t tx="ekr.20051005094144"></t>
<t tx="ekr.20051005155611">try:
    regex = re.compile(self.qQ)
except:
    self.quitSearch(event,'Illegal regular expression')
    return False

txt = w.get('insert','end')
match = regex.search(txt)

if match:
    start = match.start()
    end = match.end()
    length = end - start
    w.mark_set('insert','insert +%sc' % start)
    ### w.update_idletasks()
    w.tag_add('qR','insert','insert +%sc' % length)
    w.tag_config('qR',background='lightblue')
    txt = w.get('insert','insert +%sc' % length)
    return True
else:
    self.quitSearch(event)
    return False</t>
<t tx="ekr.20051005160923">i = w.search(self.qQ,'insert',stopindex='end')
if i:
    w.mark_set('insert',i)
    ###w.update_idletasks()
    w.tag_add('qR','insert','insert +%sc' % len(self.qQ))
    w.tag_config('qR',background='lightblue')
    return True
else:
    self.quitSearch(event)
    return False</t>
<t tx="ekr.20051006092617">if self.useTextWidget:
    self.svar = None
else:
    if self.widget:
        self.svar = Tk.StringVar()
        self.widget.configure(textvariable=self.svar)
        
    else:
        self.svar = None</t>
<t tx="ekr.20051006092617.1">self.abbrevOn = False # True: abbreviations are on.
self.arg = '' # The value returned by k.getArg.
self.commandName = None
self.inverseCommandsDict = {}
    # Completed in k.finishCreate, but leoCommands.getPublicCommands adds entries first.
self.leoCallbackDict = {}
    # Completed in leoCommands.getPublicCommands.
    # Keys are *raw* functions wrapped by the leoCallback, values are emacs command names.
self.negativeArg = False
self.regx = g.bunch(iter=None,key=None)
self.repeatCount = None
self.state = g.bunch(kind=None,n=None,handler=None)

</t>
<t tx="ekr.20051006125633.1">def bindShortcut (self,pane,shortcut,command,commandName):
    
    '''Bind one shortcut from a menu table.'''
    
    k = self ; shortcut = str(shortcut)

    if command.__name__ == 'leoCallback':
        # Get the function wrapped by *this* leoCallback function.
        func = k.leoCallbackDict.get(command)
        commandName = k.inverseCommandsDict.get(func.__name__)
        
        # No need for a second layer of callback.
        def keyCallback (event,func=command,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
    else:
        def menuFuncCallback (event,command=command):
            return command(event)

        def keyCallback (event,func=menuFuncCallback,stroke=shortcut):
            return k.masterCommand(event,func,stroke)
        
    return k.bindKey(pane,shortcut,keyCallback,commandName)</t>
<t tx="ekr.20051007143620">def printCommandsDict (self):
    
    c = self
    
    print 'Commands...'
    keys = c.commandsDict.keys()
    keys.sort()
    for key in keys:
        command = c.commandsDict.get(key)
        print '%30s = %s' % (key,g.choose(command,command.__name__,'&lt;None&gt;'))
    print</t>
<t tx="ekr.20051008082929">def createInverseCommandsDict (self):
    
    '''Add entries to k.inverseCommandsDict using c.commandDict,
    except when c.commandDict.get(key) refers to the leoCallback function.
    leoCommands.getPublicCommands has already added an entry in this case.
    
    In c.commandsDict        keys are command names, values are funcions f.
    In k.inverseCommandsDict keys are f.__name__, values are emacs-style command names.
    '''

    k = self ; c = k.c

    for name in c.commandsDict.keys():
        f = c.commandsDict.get(name)
        
        # 'leoCallback' callback created by leoCommands.getPublicCommands.
        if f.__name__ != 'leoCallback':
            k.inverseCommandsDict [f.__name__] = name
            # g.trace('%24s = %s' % (f.__name__,name))</t>
<t tx="ekr.20051008131807">- we need k.shortcutForCommand
</t>
<t tx="ekr.20051009044751">def createOuterFrames (self):

    f = self ; c = f.c
    f.top = top = Tk.Toplevel()
    g.app.gui.attachLeoIcon(top)
    top.title(f.title)
    top.minsize(30,10) # In grid units.
    
    if g.os_path_exists(g.app.user_xresources_path):
        f.top.option_readfile(g.app.user_xresources_path)
    
    f.top.protocol("WM_DELETE_WINDOW", f.OnCloseLeoEvent)
    f.top.bind("&lt;Button-1&gt;", f.OnActivateLeoEvent)
    
    # These don't work on Windows. Because of bugs in window managers,
    # there is NO WAY to know which window is on top!
    f.top.bind("&lt;Activate&gt;",f.OnActivateLeoEvent)
    f.top.bind("&lt;Deactivate&gt;",f.OnDeactivateLeoEvent)
    f.top.bind("&lt;Control-KeyPress&gt;",f.OnControlKeyDown)
    f.top.bind("&lt;Control-KeyRelease&gt;",f.OnControlKeyUp)
    
    # Create the outer frame, the 'hull' component.
    f.outerFrame = Tk.Frame(top)
    f.outerFrame.pack(expand=1,fill="both")
    f.componentClass(c,'hull',f.outerFrame)
</t>
<t tx="ekr.20051009044920"># Warning: there is also a method called createIconBar.

def createIconBarComponents (self):

    f = self ; c = f.c

    iconBar = f.iconBarClass(c,f.outerFrame)
    f.iconFrame = iconBar.iconFrame
    f.iconBar = f.componentClass(c,
        f.iconBarComponentName,iconBar.iconFrame,
        iconBar,iconBar.pack,iconBar.unpack)
    f.iconBar.show()</t>
<t tx="ekr.20051009045208">def createSplitterComponents (self):

    f = self ; c = f.c

    f.createLeoSplitters(f.outerFrame)
    
    # Create the canvas, tree, log and body.
    f.canvas = f.createCanvas(f.split2Pane1)
    f.tree   = leoTkinterTree.leoTkinterTree(c,f,f.canvas)
    f.log    = leoTkinterLog(f,f.split2Pane2)
    f.body   = leoTkinterBody(f,f.split1Pane2)
    
    f.componentClass(c,'tree',f.split2Pane1, f.tree, f.packTree, f.unpackTree)
    f.componentClass(c,'log', f.split2Pane2, f.log,  f.packLog,  f.unpackLog)
    f.componentClass(c,'body',f.split1Pane2, f.body, f.packBody, f.unpackBody)
    
    # Yes, this an "official" ivar: this is a kludge.
    f.bodyCtrl = f.body.bodyCtrl
    
    # Configure.
    f.setTabWidth(c.tab_width)
    f.tree.setColorFromConfig()
    f.reconfigurePanes()
    f.body.setFontFromConfig()
    f.body.setColorFromConfig()</t>
<t tx="ekr.20051009045300"># Warning: there is also a method called createStatusLine.

def createStatusLineComponents (self):
    
    f = self ; c = f.c
    statusLine = f.statusLineClass(c,f.outerFrame)
    
    # Create offical ivars in the frame class.
    f.statusFrame = statusLine.statusFrame
    f.statusLabel = statusLine.labelWidget
    f.statusText  = statusLine.textWidget
    
    f.statusLine = f.componentClass(c,
        f.statusLineComponentName,
        statusLine.statusFrame,statusLine,statusLine.pack,statusLine.unpack)
    f.statusLine.show() # Show status line by default.</t>
<t tx="ekr.20051009045404">def createFirstTreeNode (self):
    
    f = self ; c = f.c

    t = leoNodes.tnode()
    v = leoNodes.vnode(c,t)
    p = leoNodes.position(v,[])
    v.initHeadString("NewHeadline")
    p.moveToRoot()

    c.beginUpdate()
    try:
        c.selectVnode(p)
        c.redraw()
        c.frame.getFocus()
        c.editPosition(p)
    finally:
        c.endUpdate(False)</t>
<t tx="ekr.20051009120608"></t>
<t tx="ekr.20051010062551.1">@

c.commandsDict:
    keys are emacs command names, values are functions f.

k.inverseCommandsDict:
    keys are f.__name__, values are emacs command names.
    
inverseBindingsDict (computed by computeInverseBindingDict)
    keys are emacs command names, values are shortcuts.

k.leoCallbackDict:
    keys are leoCallback functions, values are called functions.

k.bindingsDict:
    keys are shortcuts, values are g.bunch(func,name,warningGiven)
</t>
<t tx="ekr.20051011072049.1">def OnCutFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''

    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        # Necessary
        w.event_generate(g.virtual_event_name("Cut"))
        f.tree.onHeadChanged(c.currentPosition(),'Cut')</t>
<t tx="ekr.20051011072049.2">def cutText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl
    
    # g.trace(w,w._name) # _name and widgetName are tkinter additions to Tk.

    if isBody:
        w.event_generate(g.virtual_event_name("Cut"))
    else:
        # Old: Do **not** call w.event_generate.
        # New: Do call w.event_generate.
        w.event_generate(g.virtual_event_name("Cut"))
        if not fromMinibuffer:
            f.tree.onHeadChanged(c.currentPosition(),'Cut')</t>
<t tx="ekr.20051011072903.1">def OnCopyFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    #g.trace()
    
    f = self ; c = f.c ; w = f.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Copy"))
    else:
        # Necessary when not using shortcut keys.
        w.event_generate(g.virtual_event_name("Copy"))</t>
<t tx="ekr.20051011072903.2">def copyText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    
    if not fromMinibuffer:
        w.event_generate(g.virtual_event_name("Copy"))</t>
<t tx="ekr.20051011072903.4">def OnPasteFromMenu (self):
    
    ''' Called **only** when invoked using the menu instead of a shortcut.'''
    
    f = self ; c = f.c ; w = f.getFocus()
    w = self.getFocus()
    isBody = w == f.body.bodyCtrl

    if isBody:
        w.event_generate(g.virtual_event_name("Paste"))
    else:
        w.event_generate(g.virtual_event_name("Paste"))
        f.tree.onHeadChanged(c.currentPosition(),'Paste')</t>
<t tx="ekr.20051011072903.5">def pasteText (self,fromMinibuffer=False):
    
    '''Invoked from the mini-buffer and from shortcuts.'''
    
    f = self ; c = f.c
    w = f.getFocus()
    name = hasattr(w,'_name') and w._name or ''
    
    if fromMinibuffer:
        w.event_generate(g.virtual_event_name("Paste"))
    elif name.startswith('body'):
        w.event_generate(g.virtual_event_name("Paste"))
    elif name.startswith('head'):
        if 0:
            &lt;&lt; paste the text into w &gt;&gt;
    else: pass
</t>
<t tx="ekr.20051012053017.4">** Important: search headline option.
    
[iqr] incremental,query,regex
[fb] forward,back
[w] word
[c] case-sensitive
[hat] headline,all,body
[osn] outline,subtree,node

*Set defaults for all the above using commands.
set-word-search-on/off
set-search-case-on/off
set-regexp-search-on/off
set-wrap-search-on/off
set-search-scope-to-outline/subtree/node

** Search mode: Control keys could change these options *after* starting the search command.

- Script-search commands
script-search  (can we abort the search somehow?)
set-find-script
set-change-script

Apply incremental search commands to headlines.  This might be fast, but is it useful if nodes aren't visible?</t>
<t tx="ekr.20051012054228">- k.vimMode controls whether full-command keeps mini-buffer open after a command complete.

- k.fullCommand sets k.sets k.vimMode = c.config.getBool('vim-mode') on entry.

- Commands (like vim-insert-mode) clear k.vimMode to return to the body pane.

- control-g does not alter k.vimMode.

- Shift-control-g clears k.vimMode.
</t>
<t tx="ekr.20051012062458.1">- the cycle-focus command should cycle through all log tabs.

- Something cool that can be bound to alt-tab.

- Strip quotes from color, font settings.

-  Allow multiple selectors:  ! all,find =

- Specify &amp; for most menu items.

</t>
<t tx="ekr.20051014104337.1">exception executing command
Traceback (most recent call last):

  File "c:\prog\leoCVS\leo\src\leoCommands.py", line 213, in doCommand
    command()

  File "leoUndo.py", line 1571, in undo
    u.undoHelper()

  File "leoUndo.py", line 1720, in undoMove
    u.p.moveToNthChildOf(u.oldParent,u.oldN)

  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 2764, in moveToNthChildOf
    p.unlink()

  File "c:\prog\leoCVS\leo\src\leoNodes.py", line 3307, in unlink
    assert(parent.v in p.v.directParents())

AssertionError</t>
<t tx="ekr.20051014122218">&lt;Delete&gt;     delete the character just before the cursor
C-d   	     delete the next character after the cursor

M-&lt;Delete&gt;   kill the word immediately before the cursor
M-d	     kill the next word after the cursor

C-k	     kill from the cursor position to end of line
M-k	     kill to the end of the current sentence

** (I changed this: I should change it back)
Note that a single C-k kills the contents of the line, and a second
C-k kills the line itself...

C-k treats a numeric argument specially: it kills that many lines AND
their contents.  This is not mere repetition.  C-u 2 C-k kills two
lines and their newlines; typing C-k twice would not do that.

The set-mark-command command sets the mark to the point.
Bound to Alt-@, Ctrl--, Ctrl-space</t>
<t tx="ekr.20051014152256">Improve import code so it handles stufff like this from Ipyton/iplib

### This should *not* terminate the function!

    self.LOGHEAD = Itpl(
"""#log# Automatic Logger file. *** THIS MUST BE THE FIRST LINE ***
#log# DO NOT CHANGE THIS LINE OR THE TWO BELOW
#log# opts = $self.rc.opts
#log# args = $self.rc.args
#log# It is safe to make manual edits below here.
#log#-----------------------------------------------------------------------
""")

- Handle blanks better in imports:
    - Add tab_width keyword arg to import command.
    - Convert tabs to blanks if tab width &lt; 0.
- Ignore position of blank lines wrt sentinels.
- Ignore (optionally?) underindented blank lines.
- Use pyclbr to parse Python imports?</t>
<t tx="ekr.20051014161015"></t>
<t tx="ekr.20051014170754.1">def getShortcutForCommandName (self,commandName):
    
    k = self ; c = k.c

    command = c.commandsDict.get(commandName)

    if command:
        for key in k.bindingsDict:
            b = k.bindingsDict.get(key)
            if b.commandName == commandName:
                return key
    
    return ''
    
def getShortcutForCommand (self,command):
    
    k = self ; c = k.c
    
    if command:
        for key in k.bindingsDict:
            b = k.bindingsDict.get(key)
            if b.commandName == command.__name__:
                return key
    
    return ''</t>
<t tx="ekr.20051015113252"># None of the following are correct.

leoGlobals.py:1417: Setting aList to itself has no effect

leoGlobals.py:1433: Setting aList to itself has no effect

leoKeys.py:803: Redefining attribute (keyCallback) original line (792)

leoKeys.py:1315: No module attribute (initAllEditCommanders) found</t>
<t tx="ekr.20051015123432"># None of the following warnings are correct.</t>
<t tx="ekr.20051016095907.2"></t>
<t tx="ekr.20051016155819">Any plugin could be considered an options file such as Emacs loads on startup.
Indeed, any plugin can specify options and change any part of Leo's operation.
Still, I am wondering whether Leo might treat one plugin, say options.py, just a
bit differently from other options, say by loading it first (or last) or
possibly looking somewhere besides the leo/plugins folder, or maybe having it
always be enabled.</t>
<t tx="ekr.20051016162724">- Use focus-in event in minibuffer?

- More clever way to analyze modules in autocomplete.
    Use inspect module to import the text and get what is wanted.

- Improve emacs-search commands

- Improve handling of the mark.  The selection should be visible.

- Improve kill/yank.

- Improve spell tab:
    - Try default fonts for spell buttons.
    - Select the first entry.
    - Support up/down arrows.

- Complete Editor menu.

- Put About dialog (all? dialogs) in tab.</t>
<t tx="ekr.20051017111216">- Removed update_idletasks and event_generate from minibuffer commands...

It is unlikely that any of the following commands work:

    removeBlankLines,backToIndentation,indentRelative,
    moveWordHelper,findNextMatch.

- If possibly, eliminate update_idletasks and w.event_generate('&lt;Key&gt;') in the following:
    removeBlankLines,backToIndentation,indentRelative,
    moveWordHelper,findNextMatch.

- baseEditCommandsClass helpers:
    These would be similar to g.app.gui methods, but maybe simpler to use.
    head,sel,tail = getSelectedLines()
    hasSelection, setSelection, etc.</t>
<t tx="ekr.20051017140811">Buffer Keyboard Commands:
----------------------------------------

&lt;Control-p&gt;: move up one line
&lt;Control-n&gt;: move down one line
&lt;Control-f&gt;: move forward one char
&lt;Conftol-b&gt;: move backward one char
&lt;Control-o&gt;: insert newline
&lt;Control-Alt-o&gt; : insert newline and indent
&lt;Control-j&gt;: insert newline and tab
&lt;Alt-&lt;&gt; : move to start of Buffer
&lt;Alt- &gt; &gt;: move to end of Buffer
&lt;Control a&gt;: move to start of line
&lt;Control e&gt; :move to end of line
&lt;Alt-Up&gt;: move to start of line
&lt;Alt-Down&gt;: move to end of line
&lt;Alt b&gt;: move one word backward
&lt;Alt f&gt; : move one word forward
&lt;Control - Right Arrow&gt;: move one word forward
&lt;Control - Left Arrow&gt;: move one word backwards
&lt;Alt-m&gt; : move to beginning of indentation
&lt;Alt-g&gt; : goto line number
&lt;Control-v&gt;: scroll forward one screen
&lt;Alt-v&gt;: scroll up one screen
&lt;Alt-a&gt;: move back one sentence
&lt;Alt-e&gt;: move forward one sentence
&lt;Alt-}&gt;: move forward one paragraph
&lt;Alt-{&gt;: move backwards one paragraph
&lt;Alt-:&gt; evaluate a Python expression in the minibuffer and insert the value in the current buffer
Esc Esc : evaluate a Python expression in the minibuffer and insert the value in the current buffer
&lt;Control-x . &gt;: set fill prefix
&lt;Alt-q&gt;: fill paragraph
&lt;Alt-h&gt;: select current or next paragraph
&lt;Control-x Control-@&gt;: pop global mark
&lt;Control-u&gt;: universal command, repeats the next command n times.
&lt;Alt -n &gt; : n is a number.  Processes the next command n times.
&lt;Control-x (&gt;: start definition of kbd macro
&lt;Control-x ) &gt; : stop definition of kbd macro
&lt;Control-x e : execute last macro defined
&lt;Control-u Control-x ( &gt;: execute last macro and edit
&lt;Control-x Esc Esc &gt;: execute last complex command( last Alt-x command
&lt;Control-x Control-c &gt;: save buffers kill Emacs
&lt;Control-x u &gt; : advertised undo.   This function utilizes the environments.
        If the buffer is not configure explicitly, there is no operation.
&lt;Control-_&gt;: advertised undo.  See above
&lt;Control-z&gt;: iconfify frame
----------------------------------------

&lt;Delete&gt; : delete previous character
&lt;Control d&gt;: delete next character
&lt;Control k&gt; : delete from cursor to end of line. Text goes to kill buffer
&lt;Alt d&gt;: delete word. Word goes to kill buffer
&lt;Alt Delete&gt;: delete previous word. Word goes to kill buffer
&lt;Alt k &gt;: delete current sentence. Sentence goes to kill buffer
&lt;Control x Delete&gt;: delete previous sentence. Sentence goes to kill buffer
&lt;Control y &gt;: yank last deleted text segment from
 kill buffer and inserts it.
&lt;Alt y &gt;: cycle and yank through kill buffer.

&lt;Alt z &gt;: zap to typed letter. Text goes to kill buffer
&lt;Alt-^ &gt;: join this line to the previous one
&lt;Alt-\ &gt;: delete surrounding spaces
&lt;Alt-s&gt; &gt;: center line in current fill column
&lt;Control-Alt-w&gt;: next kill is appended to kill buffer
----------------------------------------

&lt;Alt c&gt;: Capitalize the word the cursor is under.
&lt;Alt u&gt;: Uppercase the characters in the word.
&lt;Alt l&gt;: Lowercase the characters in the word.
----------------------------------------

&lt;Alt t&gt;: Mark word for word swapping.  Marking a second
 word will swap this word with the first
&lt;Control-t&gt;: Swap characters
&lt;Ctrl-@&gt;: Begin marking region.
&lt;Ctrl-W&gt;: Kill marked region
&lt;Alt-W&gt;: Copy marked region
&lt;Ctrl-x Ctrl-u&gt;: uppercase a marked region
&lt;Ctrl-x Ctrl-l&gt;: lowercase a marked region
&lt;Ctrl-x h&gt;: mark entire buffer
&lt;Alt-Ctrl-backslash&gt;: indent region to indentation of line 1 of the region.
&lt;Ctrl-x tab&gt; : indent region by 1 tab
&lt;Control-x Control-x&gt; : swap point and mark
&lt;Control-x semicolon&gt;: set comment column
&lt;Alt-semicolon&gt;: indent to comment column
----------------------------------------

M-! cmd -- Run the shell command line cmd and display the output
M-| cmd -- Run the shell command line cmd with region contents as input
----------------------------------------

&lt;Control-x a e&gt;: Expand the abbrev before point (expand-abbrev). This is effective even when Abbrev mode is not enabled
&lt;Control-x a g&gt;: Define an abbreviation for previous word
&lt;Control-x a i g&gt;: Define a word as abbreviation for word before point, or in point
----------------------------------------

&lt;Control s&gt;: forward search, using pattern in Mini buffer.

&lt;Control r&gt;: backward search, using pattern in Mini buffer.

&lt;Control s Enter&gt;: search forward for a word, nonincremental

&lt;Control r Enter&gt;: search backward for a word, nonincremental

&lt;Control s Enter Control w&gt;: Search for words, ignoring details of punctuation
&lt;Control r Enter Control w&gt;: Search backward for words, ignoring details of punctuation
&lt;Control-Alt s&gt;: forward regular expression search, using pattern in Mini buffer

&lt;Control-Alt r&gt;: backward regular expression search, using pattern in Mini buffer

&lt;Alt-%&gt;: begin query search/replace. n skips to next match. y changes current match.  
        q or Return exits. ! to replace all remaining matches with no more questions
&lt;Control Alt %&gt; begin regex search replace, like Alt-%
&lt;Alt-=&gt;: count lines and characters in regions
&lt;Alt-( &gt;: insert parentheses()
&lt;Alt-) &gt;:  move past close
&lt;Control-x Control-t&gt;: transpose lines.
&lt;Control-x Control-o&gt;: delete blank lines
&lt;Control-x r s&gt;: save region to register
&lt;Control-x r i&gt;: insert to buffer from register
&lt;Control-x r +&gt;: increment register
&lt;Control-x r n&gt;: insert number 0 to register
&lt;Control-x r space &gt; : point insert point to register
&lt;Control-x r j &gt; : jump to register
&lt;Control-x x&gt;: save region to register
&lt;Control-x r r&gt; : save rectangle to register
&lt;Control-x r o&gt;: open up rectangle
&lt;Control-x r c&gt; : clear rectangle
&lt;Control-x r d&gt; : delete rectangle
&lt;Control-x r t&gt; : replace rectangle with string
&lt;Control-x r k&gt; : kill rectangle
&lt;Control-x r y&gt; : yank rectangle
&lt;Control-g&gt; : keyboard quit

&lt;Control-x = &gt; : position of cursor
&lt;Control-x . &gt; : set fill prefix
&lt;Control-x f &gt; : set the fill column
&lt;Control-x Control-b &gt; : display the buffer list
&lt;Control-x b &gt; : switch to buffer
&lt;Control-x k &gt; : kill the specified buffer
----------------------------------------

&lt;Alt - - Alt-l &gt;: lowercase previous word
&lt;Alt - - Alt-u&gt;: uppercase previous word
&lt;Alt - - Alt-c&gt;: capitalise previous word
----------------------------------------

&lt;Alt-/ &gt;: dynamic expansion
&lt;Control-Alt-/&gt;: dynamic expansion.  Expands to common prefix in buffer
----------------------------------------

Alt-x commands:

(Pressing Tab will result in auto completion of the options if an appropriate match is found</t>
<t tx="ekr.20051017140811.1"></t>
<t tx="ekr.20051018104223"></t>
<t tx="ekr.20051020120306">def openFindTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Find'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.findTabHandler = findTab(c,f)
        
    self.findTabHandler.bringToFront()</t>
<t tx="ekr.20051020120306.1">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020120306.2">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020120306.3">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020120306.4">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20051020120306.5"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020120306.6">class findTab (leoFind.leoFind):

    """A class that implements Leo's tkinter find tab."""

    @others</t>
<t tx="ekr.20051020120306.10"></t>
<t tx="ekr.20051020120306.11">def __init__(self,c,parentFrame):

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    self.c = c
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 

    self.createFrame(parentFrame)
    self.createBindings()
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020120306.12">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020120306.13">def createFrame (self,parentFrame):
    
    c = self.c
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two columns of buttons &gt;&gt;
    
    for w in buttons:
        w.bindHotKey(ftxt)
        w.bindHotKey(ctxt)</t>
<t tx="ekr.20051020120306.14">configName = 'log_pane_Find_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.frame = Tk.Frame(self.top,background=bg)
self.outerFrame = outer = Tk.Frame(self.frame,background=bg)

self.top.pack   (side='top',expand=0,fill='x',pady=5)
    # Don't expand, so the frame goes to the top.

self.frame.pack (side="top",expand=1,fill='x')
outer.pack      (side='top',expand=1,fill='x',padx=2,pady=2,)</t>
<t tx="ekr.20051020120306.15">fc = Tk.Frame(outer, bd="1m",background=bg)
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1,background=bg)
cpane = Tk.Frame(fc, bd=1,background=bg)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:",background=bg)
clab = Tk.Label(cpane, width=8, text="Change:",background=bg)

# Use bigger boxes for scripts.
self.find_ctrl = ftxt = Tk.Text(
    fpane,bd=1,relief="groove",height=3,width=15,name='find-text')
self.change_ctrl = ctxt = Tk.Text(
    cpane,bd=1,relief="groove",height=3,width=15,name='change-text')
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0: # Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") 
ftxt.pack(side="right", expand=1, fill="x")</t>
<t tx="ekr.20051020120306.16">def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020120306.17">columnsFrame = Tk.Frame(outer,relief="groove",bd=2,background=bg)

columnsFrame.pack(expand=0,padx="7p",pady="2p")

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&amp;Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &amp;Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ("&amp;Mark Finds",           self.dict["mark_finds"]),
    ("Mark &amp;Changes",         self.dict["mark_changes"]),
    ('Show Context',          self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = self.underlinedTkButton(
            "radio",columns[i],anchor="w",text=name,variable=var,value=val,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = self.underlinedTkButton(
            "check",columns[i],anchor="w",text=name,variable=var,background=bg)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020120306.18"># Create the alignment panes.
buttons  = Tk.Frame(outer,background=bg)
buttons1 = Tk.Frame(buttons,bd=1,background=bg)
buttons2 = Tk.Frame(buttons,bd=1,background=bg)
buttons.pack(side='top',expand=1)
buttons1.pack(side='left')
buttons2.pack(side='right')

width = 15 ; defaultText = 'Find' ; buttons = []

for text,boxKind,frame,callback in (
    # Column 1...
    ('Find','button',buttons1,self.findButtonCallback),
    ('Incremental','check', buttons1,None),
        ## variable=self.dict['incremental'])
        ## May affect the file format.
    ('Find All','button',buttons1,self.findAllButton),
    # Column 2...
    ('Change','button',buttons2,self.changeButton),
    ('Change, Then Find','button',buttons2,self.changeThenFindButton),
    ('Change All','button',buttons2,self.changeAllButton),
):
    w = self.underlinedTkButton(boxKind,frame,
        text=text,command=callback)
    buttons.append(w)
    if text == defaultText:
        w.button.configure(width=width-1,bd=4)
    elif boxKind != 'check':
        w.button.configure(width=width)
    w.button.pack(side='top',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051020120306.19">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020120306.20">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020120306.21">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20051020120306.22">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020120306.25">def hideTab (self,event=None):
    
    c = self.c
    
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051020120306.26">def bringToFront (self):

    """Bring the Find Tab to the front and select the entire find text."""

    c = self.c ; t = self.find_ctrl
        
    # The widget must have focus before we can adjust the text.
    c.frame.widgetWantsFocus(t,later=False)
    
    # Delete one trailing newline.
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # Don't highlight the added trailing newline!
    g.app.gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    # This is also needed.
    c.frame.widgetWantsFocus(t,later=True)</t>
<t tx="ekr.20051020120306.27">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.</t>
<t tx="ekr.20051020120306.28">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl	
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051021074728"></t>
<t tx="ekr.20051022094136"># Binding to 'menu' causes problems with multiple pastes in the Find Tab.
# There should only be one binding for the minibuffer: the &lt;Key&gt;+ binding.
body = c.frame.body.bodyCtrl
log  = c.frame.log.logCtrl
menu = c.frame.menu
minibuffer = c.miniBufferWidget
tree = c.frame.tree.canvas

d = {
    'all':  [body,log,tree], # Probably not wise: menu
    'body': [body],
    'log':  [log],
    'menu': [menu], # Not used, and probably dubious.
    'mini': [minibuffer], # Needed so ctrl-g will work in the minibuffer!
    'text': [body,log],
    'tree': [tree],
}

if 0: # A useful trace.
    if pane and pane != 'all':
        g.trace('%4s %20s %s' % (pane, shortcut,commandName))

widgets = d.get((pane or '').lower(),[])

if shortcut == '&lt;Key&gt;':
    # Important.  We must make this binding if the minibuffer can ever get focus.
    if self.useTextWidget:
        widgets.append(minibuffer)
    for w in widgets:
        w.bind(shortcut,callback,'+')
else:
    for w in widgets:
        w.bind(shortcut,callback)
    # Get rid of the default binding in the menu. (E.g., Alt-f)
    menu.bind(shortcut,lambda e: 'break')</t>
<t tx="ekr.20051022132934"></t>
<t tx="ekr.20051022141020">def onTreeClick (self,event=None):
    
    self.frame.treeWantsFocus()
    
    return 'break'</t>
<t tx="ekr.20051022142249"></t>
<t tx="ekr.20051022144825">def focusToBody (self,event):
    
    self.c.frame.bodyWantsFocus(later=True)

def focusToLog (self,event):

    self.c.frame.logWantsFocus(later=True)
    
def focusToMinibuffer (self,event):
    
    self.c.frame.minibufferWantsFocus(later=True)

def focusToTree (self,event):
    
    self.c.frame.treeWantsFocus(later=True)</t>
<t tx="ekr.20051022144825.1">def cycleFocus (self,event):

    c = self.c ; frame = c.frame
    
    body = c.frame.body.bodyCtrl
    log  = c.frame.log.logCtrl
    tree = c.frame.tree.canvas

    panes = [body,log,tree]

    for w in panes:
        if w == event.widget:
            i = panes.index(w)
            if i &gt;= len(panes) - 1:
                i = 0
            else:
                i += 1
            pane = panes[i] ; break
    else:
        # Assume we were somewhere in the tree.
        pane = body
        
    # g.trace(pane)
    frame.set_focus(pane,later=True)</t>
<t tx="ekr.20051022152427"></t>
<t tx="ekr.20051022211617"></t>
<t tx="ekr.20051022212004"># Just open the Find tab if it has never been opened.
# For minibuffer commands, it would be good to force the Find tab to be visible.
# However, this leads to unfortunate confusion when executed from a shortcut.

def findTabChange(self,event=None):

    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.changeCommand()
    else:
        self.openFindTab()

def findTabChangeThenFind(self,event=None):

    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.changeThenFindCommand()
    else:
        self.openFindTab()

def findTabFindNext (self,event=None):
    
    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.findNextCommand()
    else:
        self.openFindTab()

def findTabFindPrev (self,event=None):
    
    if self.findTabHandler:
        #self.openFindTab()
        self.findTabHandler.findPrevCommand()
    else:
        self.openFindTab()
        
def hideFindTab (self,event=None):
    if self.findTabHandler:
        self.c.frame.log.selectTab('Log')</t>
<t tx="ekr.20051023094009"></t>
<t tx="ekr.20051023132350">def getLabel (self,ignorePrompt=False):
    
    k = self ; w = self.widget
    
    if self.useTextWidget:
        w.update_idletasks()
        s = w and w.get('1.0','end')
        # Remove the cursed Tk newline.
        if s.endswith('\n') or s.endswith('\r'): s = s[:-1]
        # g.trace(repr(s))
    else:
        s = k.svar and k.svar.get()

    if ignorePrompt:
        return s[len(k.mb_prefix):]
    else:
        return s or ''

</t>
<t tx="ekr.20051023132350.1">def setLabel (self,s,protect=False):

    k = self ; w = self.widget

    # g.trace(repr(s))

    if self.useTextWidget:
        if w:
            k.c.frame.minibufferWantsFocus(later=False)
            w.update_idletasks()
            w.delete('1.0','end') ; w.insert('1.0',s)
    else:
        if k.svar: k.svar.set(s)

    if protect:
        k.mb_prefix = s</t>
<t tx="ekr.20051023132350.2">def protectLabel (self):
    
    k = self ; w = self.widget

    if self.useTextWidget:
        if w:
            w.update_idletasks()
            k.mb_prefix = w.get('1.0','end')
    else:
        if k.svar:
            k.mb_prefix = k.svar.get()</t>
<t tx="ekr.20051023181449">def createBindings (self):
    
    c = self.c ; k = c.keyHandler

    for w in (self.find_ctrl, self.change_ctrl):
        k.copyBindingsToWidget(['text','mini'],w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('find-tab-find',       self.findNextCommand),
            ('find-tab-find-prev',  self.findPrevCommand),
            ('find-tab-change',     self.changeCommand),
            ('find-tab-change-find',self.changeThenFindCommand),
        ):
            junk, bunch = c.config.getShortcut(commandName)
            accel = bunch and bunch.val
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            if shortcut:
                # g.trace(shortcut,commandName)
                w.bind(shortcut,func)
        w.bind ("&lt;1&gt;",  self.resetWrap,'+')
        w.bind("&lt;Key&gt;", self.resetWrap,'+')

    for w in (self.outerFrame, self.find_ctrl, self.change_ctrl):
        w.bind("&lt;Key-Return&gt;", self.findButtonCallback)
        w.bind("&lt;Key-Escape&gt;", self.hideTab)</t>
<t tx="ekr.20051023183028">def findButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'

    self.findButton()
    return 'break'</t>
<t tx="ekr.20051023192433">- Convert Emacs-Style Names to Menu Style Names when creating undo name.

- Examine scheme for duplicate shortcuts.
        - At present, a single command can be bound only once.
        - It's not a horrible restriction...
    
- The colerer is calling c.config too much?</t>
<t tx="ekr.20051024192602"></t>
<t tx="ekr.20051024192642.2">def findNextCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.findNext()
    
def findPrevCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.reverse = not self.reverse
    self.findNext()
    self.reverse = not self.reverse</t>
<t tx="ekr.20051024192642.3">def changeCommand (self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.change()
    
def changeThenFindCommand(self,event=None):
    
    c = self.c
    self.setup_command(c)
    self.changeThenFind()</t>
<t tx="ekr.20051025071455">&lt;&lt; specify aspell directories &gt;&gt;

@others</t>
<t tx="ekr.20051025071455.1">class spellCommandsClass (baseEditCommandsClass):
    
    '''Commands to support the Spell Tab.'''

    @others</t>
<t tx="ekr.20051025071455.3">if sys.platform == 'darwin':
    aspell_dir = '/sw/lib'
        # The top-level directory.
    aspell_bin_dir = '/sw/lib/bin'
        # NOT TESTED YET.
else:
    aspell_dir = r'c:\Aspell'
        # The top-level directory.
    aspell_bin_dir = r'c:\Aspell\bin'
        # The directory continaing apell.pyd and aspell-15.dll</t>
<t tx="ekr.20051025071455.6">class Aspell:
    
    """A wrapper class for Aspell spell checker"""
    
    @others

</t>
<t tx="ekr.20051025071455.7"></t>
<t tx="ekr.20051025071455.8">def __init__(self,c,local_dictionary_file,local_language_code):
    
    """Ctor for the Aspell class."""
    
    self.c = c
    
    try:
        import aspell
    except ImportError:
        # Specify the path to the top-level Aspell directory.
        if sys.platform == 'darwin':
            aspell = g.importFromPath ("aspell",aspell_dir,pluginName=__name__,verbose=True)
        else:
            aspell = g.importFromPath(
                "aspell",aspell_bin_dir,pluginName=__name__,verbose=True)
            
    self.aspell = aspell

    self.sc = aspell.spell_checker(prefix=aspell_dir,lang=local_language_code)
    # g.trace(self.sc)
    
    self.aspell_exe_loc = (c.config.getString('aspell_bin_dir') or aspell_bin_dir)
    # g.trace(self.aspell_exe_loc)

    self.local_language_code = local_language_code
    self.local_dictionary_file = local_dictionary_file
    self.local_dictionary = "%s.wl" % os.path.splitext(local_dictionary_file)[0]
    # g.trace(self.local_dictionary)</t>
<t tx="ekr.20051025071455.10">def processWord(self, word):
    """Pass a word to aspell and return the list of alternatives.
    OK: 
    * 
    Suggestions: 
    &amp; original count offset: miss, miss, ... 
    None: 
    # original offset 
    simplifyed to not create the string then make a list from it    
    """

    if self.sc.check(word):
        return None
    else:
        return self.sc.suggest(word)</t>
<t tx="ekr.20051025071455.11">def updateDictionary(self):

    """Update the aspell dictionary from a list of words.
    
    Return True if the dictionary was updated correctly."""

    try:
        # Create master list
        basename = os.path.splitext(self.local_dictionary)[0]
        cmd = (
            "%s --lang=%s create master %s.wl &lt; %s.txt" %
            (self.aspell_exe_loc, self.local_language_code, basename,basename))
        os.popen(cmd)
        return True

    except Exception, err:
        g.es_print("Unable to update local aspell dictionary: %s" % err)
        return False</t>
<t tx="ekr.20051025071455.16">def readDictionary (self,fileName):

    """Read the dictionary of words which we use as a local dictionary
    
    Although Aspell itself has the functionality to handle this kind of things
    we duplicate it here so that we can also use it for the "ignore" functionality
    and so that in future a Python only solution could be developed."""
    
    d = {}

    try:
        f = open(fileName,"r")
    except IOError:
        g.es("Unable to open local dictionary '%s' - using a blank one instead" % fileName)
        return d

    try:
        # Create the dictionary - there are better ways to do this
        # in later Python's but we stick with this method for compatibility
        for word in f.readlines():
            d [word.strip().lower()] = 0
    finally:
        f.close()

    return d</t>
<t tx="ekr.20051025071455.18">class spellTab(leoFind.leoFind):

    """A class to create and manage Leo's Spell Check dialog."""
    
    @others</t>
<t tx="ekr.20051025071455.19"></t>
<t tx="ekr.20051025071455.20">def __init__(self,c,parentFrame):
    
    """Ctor for the Leo Spelling dialog."""

    leoFind.leoFind.__init__(self,c) # Call the base ctor.

    self.c = c
    self.body = c.frame.body
    self.currentWord = None
    self.suggestions = []
    self.messages = [] # List of message to be displayed when hiding the tab.
    self.workCtrl = Tk.Text(None) # A text widget for scanning.
    
    self.loaded = self.init_aspell(c)
    if self.loaded:
        self.createSpellTab(parentFrame)
        self.createBindings()</t>
<t tx="ekr.20051025071455.22">def createSpellTab(self,parentFrame):

    """Create the Spell tab."""
    
    c = self.c
    
    # Set the common background color.
    bg = c.config.getColor('log_pane_Spell_tab_background_color') or 'LightSteelBlue2'
    
    # Create the outer frame.
    self.outerFrame = outer = Tk.Frame(parentFrame,bd=2,bg=bg)
    outer.pack(expand=1,fill='both',padx=2,pady=2)
    
    &lt;&lt; Create the text and suggestion panes &gt;&gt;
    &lt;&lt; Create the spelling buttons &gt;&gt;
    
    self.fillbox([])
    self.listBox.bind("&lt;Double-Button-1&gt;",self.onChangeThenFindButton)
    self.listBox.bind("&lt;Button-1&gt;",self.onSelectListBox)
    self.listBox.bind("&lt;Map&gt;",self.onMap)</t>
<t tx="ekr.20051025071455.23">f2 = Tk.Frame(outer,bg=bg)
f2.pack(side='top',expand=0,fill='x')

self.wordLabel = Tk.Label(f2,text="Suggestions for:")
self.wordLabel.pack(side='left')
self.wordLabel.configure(font=('verdana',10,'bold'))

fpane = Tk.Frame(outer,bg=bg,bd=2)
fpane.pack(side='top',expand=1,fill='both')

self.listBox = Tk.Listbox(fpane,height=10,width=10,selectmode="single")
self.listBox.pack(side='left',expand=1,fill='both')
self.listBox.configure(font=('verdana',11,'normal'))

listBoxBar = Tk.Scrollbar(fpane,name='listBoxBar')

bar, txt = listBoxBar, self.listBox
txt ['yscrollcommand'] = bar.set
bar ['command'] = txt.yview
bar.pack(side='right',fill='y')</t>
<t tx="ekr.20051025071455.24"># Create the alignment panes
buttons1 = Tk.Frame(outer,bd=1,bg=bg)
buttons2 = Tk.Frame(outer,bd=1,bg=bg)
buttons3 = Tk.Frame(outer,bd=1,bg=bg)
for w in (buttons1,buttons2,buttons3):
    w.pack(side='top',expand=0,fill='x')

buttonList = [] ; font = ('verdana',9,'normal') ; width = 12
for frame, text, command in (
    (buttons1,"Find",self.onFindButton),
    (buttons1,"Add",self.onAddButton),
    (buttons2,"Change",self.onChangeButton),
    (buttons2,"Change, Find",self.onChangeThenFindButton),
    (buttons3,"Ignore",self.onIgnoreButton),
    (buttons3,"Hide",self.onHideButton),
):
    b = Tk.Button(frame,font=font,width=width,text=text,command=command)
    b.pack(side='left',expand=0,fill='none')
    buttonList.append(b)

# Used to enable or disable buttons.
(self.findButton,self.addButton,
 self.changeButton, self.changeFindButton,
 self.ignoreButton, self.hideButton) = buttonList</t>
<t tx="ekr.20051025071455.29"></t>
<t tx="ekr.20051025071455.30">def onAddButton(self):
    """Handle a click in the Add button in the Check Spelling dialog."""

    self.add()</t>
<t tx="ekr.20051025071455.31">def onIgnoreButton(self,event=None):

    """Handle a click in the Ignore button in the Check Spelling dialog."""

    self.ignore()</t>
<t tx="ekr.20051025071455.32">def onChangeButton(self,event=None):

    """Handle a click in the Change button in the Spell tab."""

    self.change()
    self.updateButtons()
    

def onChangeThenFindButton(self,event=None):
    
    """Handle a click in the "Change, Find" button in the Spell tab."""

    if self.change():
        self.find()
    self.updateButtons()
</t>
<t tx="ekr.20051025071455.33">def onFindButton(self):

    """Handle a click in the Find button in the Spell tab."""

    self.find()
    self.updateButtons()
    self.c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025071455.34">def onHideButton(self):
    
    """Handle a click in the Hide button in the Spell tab."""
    
    self.hide()</t>
<t tx="ekr.20051025071455.36"></t>
<t tx="ekr.20051025071455.37">def add(self,event=None):
    """Add the selected suggestion to the dictionary."""
    
    try:
        f = None
        try:
            # Rewrite the dictionary in alphabetical order.
            f = open(self.dictionaryFileName, "r")
            words = f.readlines()
            f.close()
            words = [word.strip() for word in words]
            words.append(self.currentWord)
            words.sort()
            f = open(self.dictionaryFileName, "w")
            for word in words:
                f.write("%s\n" % word)
            f.flush()
            f.close()
            if 1:
                s = 'Spell: added %s' % self.currentWord
                self.messages.append(s)
            else: # Too distracting.
                g.es("Adding ", color= "blue", newline= False) 
                g.es('%s' % self.currentWord)
        except IOError:
            g.es("Can not add %s to dictionary" % self.currentWord, color="red")
    finally:
        if f: f.close()
        
    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.38">def change(self,event=None):
    """Make the selected change to the text"""

    __pychecker__ = '--no-override --no-argsused'
         # event param is not used, required, and different from base class.

    c = self.c ; current = c.currentPosition()
    body = self.body ; t = body.bodyCtrl
    
    selection = self.getSuggestion()
    if selection:
        start,end = oldSel = g.app.gui.getTextSelection(t)
        if start:
            if t.compare(start, "&gt;", end):
                start,end = end,start
            t.delete(start,end)
            t.insert(start,selection)
            g.app.gui.setTextSelection(t,start,start + "+%dc" % (len(selection)))
            newSel = g.app.gui.getTextSelection(t)

            # update node, undo status, dirty flag, changed mark &amp; recolor
            c.beginUpdate()
            c.frame.body.onBodyChanged(current,"Change",oldSel=oldSel,newSel=newSel)
            c.endUpdate(True)
            t.focus_set()
            return True

    # The focus must never leave the body pane.
    t.focus_set()
    return False</t>
<t tx="ekr.20051025071455.40">def find (self,event=None):
    """Find the next unknown word."""

    c = self.c ; body = c.frame.body ; bodyCtrl = body.bodyCtrl

    # Reload the work pane from the present node.
    s = bodyCtrl.get("1.0","end").rstrip()
    self.workCtrl.delete("1.0","end")
    self.workCtrl.insert("end",s)

    # Reset the insertion point of the work widget.
    ins = bodyCtrl.index("insert")
    self.workCtrl.mark_set("insert",ins)

    alts, word = self.findNextMisspelledWord()
    self.currentWord = word # Need to remember this for 'add' and 'ignore'

    if alts:
        self.fillbox(alts,word)
        c.frame.bodyWantsFocus(later=False)
        # Copy the working selection range to the body pane
        start, end = g.app.gui.getTextSelection(self.workCtrl)
        g.app.gui.setTextSelection(bodyCtrl,start,end)
        bodyCtrl.see(start)
    else:
        g.es("no more misspellings")
        self.fillbox([])</t>
<t tx="ekr.20051025071455.41">def ignore(self,event=None):

    """Ignore the incorrect word for the duration of this spell check session."""
    
    if 1: # Somewhat helpful: applies until the tab is destroyed.
        s = 'Spell: ignore %s' % self.currentWord
        self.messages.append(s)

    if 0: # Too distracting
        g.es("Ignoring ", color= "blue", newline= False)
        g.es('%s' % self.currentWord)

    self.dictionary[self.currentWord.lower()] = 0
    self.onFindButton()</t>
<t tx="ekr.20051025071455.42"></t>
<t tx="ekr.20051025071455.43">def bringToFront (self):
    
    self.c.frame.log.selectTab('Spell')</t>
<t tx="ekr.20051025071455.44">def fillbox(self, alts, word=None):
    """Update the suggestions listbox in the Check Spelling dialog."""
    
    self.suggestions = alts
    
    if not word:
        word = ""

    self.wordLabel.configure(text= "Suggestions for: " + word)
    self.listBox.delete(0, "end")

    for i in xrange(len(self.suggestions)):
        self.listBox.insert(i, self.suggestions[i])
    
    # This doesn't show up because we don't have focus.
    if len(self.suggestions):
        self.listBox.select_set(1) 

</t>
<t tx="ekr.20051025071455.45">def findNextMisspelledWord(self):
    """Find the next unknown word."""
    
    c = self.c ; p = c.currentPosition()
    aspell = self.aspell ; alts = None ; word = None
   
    try:
        while 1:
            p, word = self.findNextWord(p) 
            if not p or not word:
                alts = None
                break
            &lt;&lt; Skip word if ignored or in local dictionary &gt;&gt;
            alts = aspell.processWord(word)
            if alts:
                c.beginUpdate()
                c.frame.tree.expandAllAncestors(p)
                c.selectPosition(p)
                c.endUpdate()
                break
    except:
        g.es_exception()
    return alts, word</t>
<t tx="ekr.20051025071455.46">@ We don't bother to call apell if the word is in our dictionary. The dictionary contains both locally 'allowed' words and 'ignored' words. We put the test before aspell rather than after aspell because the cost of checking aspell is higher than the cost of checking our local dictionary. For small local dictionaries this is probably not True and this code could easily be located after the aspell call
@c

if self.dictionary.has_key(word.lower()):
    continue</t>
<t tx="ekr.20051025071455.47"># Unicode characters may cause index problems.

def findNextWord(self,p):

    """Scan for the next word, leaving the result in the work widget"""

    t = self.workCtrl

    # Allow quotes and underscores in the middle of words, but not at the beginning or end.
    # This breaks words at non-ascii 'letters' such as .  I don't know what the solution is.
    word_start = string.letters
    word_end   = string.letters + string.digits
    word_chars = string.letters + string.digits + "`" + "'" + "_"
    while 1:
        line = t.get('insert wordstart','insert lineend')
        # g.trace('insert',t.index('insert'),'insert wordstart',t.index('insert wordstart'))
        # g.trace(repr(line))
        # Start the word at the first letter.
        i = 0
        while i &lt; len(line) and line[i] not in word_start:
            i += 1
        if i &lt; len(line):
            # A non-empty word has been found.
            line = t.get('insert wordstart','insert lineend')
            j = i
            while j &lt; len(line) and line[j] in word_chars:
                j += 1
            word = line[i:j]
            while word and word[-1] not in word_end:
                word = word[:-1]
            # This trace is important: it verifies that all words have actually been checked.
            # g.trace(repr(word))
            x1 = t.index('insert + %dc' % (i))
            x2 = t.index('insert + %dc' % (i+len(word)))
            g.app.gui.setTextSelection(t,x1,x2)
            return p, word
        else:
            # End of the line. Bug fix: 9/8/05.
            t.mark_set('insert','insert lineend + 1c')
            if t.compare("insert","&gt;=", "end - 1c"):
                p.moveToThreadNext()
                if not p: return None,None
                t.delete("1.0", "end")
                t.insert("end", p.bodyString())
                t.mark_set("insert", "1.0")
                
    __pychecker__ = '--no-implicitreturns' # This is not really an implicit return.</t>
<t tx="ekr.20051025071455.48">def getSuggestion(self):
    """Return the selected suggestion from the listBox."""
    
    # Work around an old Python bug.  Convert strings to ints.
    items = self.listBox.curselection()
    try:
        items = map(int, items)
    except ValueError: pass

    if items:
        n = items[0]
        suggestion = self.suggestions[n]
        return suggestion
    else:
        return None</t>
<t tx="ekr.20051025071455.49">def onMap (self, event=None):
    """Respond to a Tk &lt;Map&gt; event."""
    
    self.update(show= False, fill= False)</t>
<t tx="ekr.20051025071455.50">def onSelectListBox(self, event=None):
    """Respond to a click in the selection listBox."""
    
    self.updateButtons()
    self.body.bodyCtrl.focus_set()
</t>
<t tx="ekr.20051025071455.51">def update(self,show=True,fill=False):
    
    """Update the Spell Check dialog."""
    
    c = self.c
    
    if fill:
        self.fillbox([])

    self.updateButtons()

    if show:
        self.bringToFront()
        c.frame.body.bodyCtrl.focus_set()</t>
<t tx="ekr.20051025071455.52">def updateButtons (self):

    """Enable or disable buttons in the Check Spelling dialog."""

    c = self.c

    start, end = g.app.gui.getTextSelection(c.frame.body.bodyCtrl)
    state = g.choose(self.suggestions and start,"normal","disabled")

    self.changeButton.configure(state=state)
    self.changeFindButton.configure(state=state)

    # state = g.choose(self.c.undoer.canRedo(),"normal","disabled")
    # self.redoButton.configure(state=state)
    # state = g.choose(self.c.undoer.canUndo(),"normal","disabled")
    # self.undoButton.configure(state=state)

    self.addButton.configure(state='normal')
    self.ignoreButton.configure(state='normal')</t>
<t tx="ekr.20051025080056">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.handler = None
    
    # All the work happens when we first open the frame.</t>
<t tx="ekr.20051025080420">def getPublicCommands (self):
    
    return {
        'open-spell-tab':           self.openSpellTab,
        'spell-find':               self.find,
        'spell-change':             self.change,
        'spell-change-then-find':   self.changeThenFind,
        'spell-ignore':             self.ignore,
        'hide-spell-tab':           self.hide,
    }</t>
<t tx="ekr.20051025080420.1"># Just open the Spell tab if it has never been opened.
# For minibuffer commands, we must also force the Spell tab to be visible.

def find (self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.find()
    else:
        self.openSpellTab()

def change(self,event=None):

    if self.handler:
        self.openSpellTab()
        self.handler.change()
    else:
        self.openSpellTab()

def changeThenFind (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.changeThenFind()
    else:
        self.openSpellTab()
        
def hide (self,event=None):
    
    if self.handler:
        self.c.frame.log.selectTab('Log')
        self.c.frame.bodyWantsFocus()

def ignore (self,event=None):
    
    if self.handler:
        self.openSpellTab()
        self.handler.ignore()
    else:
        self.openSpellTab()</t>
<t tx="ekr.20051025080633">def openSpellTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Spell'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    elif self.handler:
        if self.handler.loaded:
            self.handler.bringToFront()
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.handler = spellTab(c,f)
        
    self.handler.bringToFront()</t>
<t tx="ekr.20051025094004">def init_aspell (self,c):

    '''Init aspell and related ivars.  Return True if all went well.'''

    self.local_language_code = c.config.getString('spell_local_language_code') or 'en'

    self.dictionaryFileName = dictionaryFileName = (
        c.config.getString('spell_local_dictionary') or
        os.path.join(g.app.loadDir,"../","plugins",'spellpyx.txt'))
    
    if not dictionaryFileName or not g.os_path_exists(dictionaryFileName):
        g.es_print('Can not open dictionary file: %s' % (
            dictionaryFileName), color='red')
        return False

    self.aspell = Aspell(c,dictionaryFileName,self.local_language_code)
    if not self.aspell.aspell:
        g.es_print('Can not open Aspell',color='red')
        return False
        
    self.dictionary = self.readDictionary(dictionaryFileName)
    return True</t>
<t tx="ekr.20051025120920">def createBindings (self):
    
    c = self.c ; k = c.keyHandler
    widgets = (self.listBox, self.outerFrame)

    for w in widgets:
        k.copyBindingsToWidget('text',w)
        # Bind shortcuts for the following commands...
        for commandName,func in (
            ('full-command',            k.fullCommand),
            ('hide-spell-tab',          self.hide),
            ('spell-add',               self.add),
            ('spell-find',              self.find),
            ('spell-ignore',            self.ignore),
            ('spell-change-then-find',  self.changeThenFind),
        ):
            junk, bunch = c.config.getShortcut(commandName)
            accel = bunch and bunch.val
            shortcut, junk = c.frame.menu.canonicalizeShortcut(accel)
            if shortcut:
                # g.trace(shortcut,commandName)
                w.bind(shortcut,func)</t>
<t tx="ekr.20051025121408">def hide (self,event=None):
    
    self.c.frame.log.selectTab('Log')
    
    for message in self.messages:
        g.es(message,color='blue')
        
    self.messages = []</t>
<t tx="ekr.20051025144611"></t>
<t tx="ekr.20051025144611.1">@nocolor</t>
<t tx="ekr.20051025144611.2">The plugin looks in the plugins folder for a file called autocompleter.ini.

This follows the windows .ini file format as used in ConfigParser, see: http://docs.python.org/lib/module-ConfigParser.html

1. Specify options in autocompleter.ini as follows:

[ autocompleter ]

useauto = 0 # turns off autocompletion
usecalltips = 0 # turns of calltips
autopattern = pattern #pattern is a regular expression

The autopattern changes the pattern by which autocompletion options are recognized.
I wouldnt use it unless you understood how the code works though.

2. You can add a language by putting this in autocompleter.ini:

[ yourlanguage ]

pat = put regular expression here

Then the plugin will recognize your language for the calltip system. This only works if Leo currently recognizes your language, since we are getting our info from the colorizer as to what language is in use.</t>
<t tx="ekr.20051025144611.3">The plugin uses specific pattern matching based on the language you are using.

For example, if you are in a node and the language is python, it will only recognize def word(     ) as the calltip.

Support for Python, C, C++, Perl and Java is built-in, other languages may be supported as follows:

You can supply a library of prebuilt calltip definitions and autocompleter info by putting a directory called autocompleter in the plugins directory. It will look for a file(s) of the languages used in the Leo project. The file name must be language.ato.

For java it would be java.ato, which might contain:

dog.eat
burt.you
public static void main( String[] args )

and dog.eat, burt.you would be added to autocompletion and the 3rd line would be added to the calltips section.</t>
<t tx="ekr.20051025144611.4">&lt;&lt; docstring &gt;&gt;
&lt;&lt;imports&gt;&gt;
&lt;&lt;version history&gt;&gt;
&lt;&lt;a note on newCreateControl&gt;&gt;
&lt;&lt;coding conventions&gt;&gt;
&lt;&lt; configuration &gt;&gt;

#These two global determine if the autocompleter and calltip systems are used.  Default is on.
useauto = 1
usecall = 1

&lt;&lt;globals&gt;&gt;
&lt;&lt;patterns&gt;&gt;

@others</t>
<t tx="ekr.20051025144611.5">'''Autocompletion and calltips plugin.

- ``.`` summons the autocompletion.
- ``(`` summons the calltips
- ``Escape`` closes either box.
- ``Ctrl`` selects an item.
- ``alt-up_arrow``, ``alt-down_arrow`` move up or down in the list.
  The mouse will work for this as well.

This plugin scans the complete outline at startup.
You many enable or disable features in autocomplete.ini.
This file contains two options under the [ autocompleter ] section::

    useauto
    usecalltips

Setting either to 1 will turn on the feature. 0 means off. If there is a section
called [ newlanguages ] it will read each option as a new language for
autocompleter to recognize, and compile its value as a regex pattern for the
autocompleter system to recognize as a calltip. This has relevance for the .ato
system described below.  Languages that currently have patterns::

    python, java, c++, c, perl

Autocompleter looks in the plugin directory for a directory called
autocompleter. If it doesnt find one it will attempt to create this directory.
This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a
languages name. For example: python.ato autocompleter recognizes python, and
will scan this file. The contents are read with the same mechanism that reads
the information in the nodes, so calltip and autocompleter information is added
to autocompleters runtime database. If a new language has been added in the
autocompleter.ini file then an .ato file that starts with the new languages name
will be recognized and read in. Note, this language needs to be recognizable to
Leo. Used correctly an .ato file is a mechanism by which a user can carry
autocompletion and calltip information between .leo files/sessions.
'''</t>
<t tx="ekr.20051025144611.6">## import leoTkinterFrame 

import sets 
import threading
import weakref</t>
<t tx="ekr.20051025144611.7">@
.425:
    -The initial scan thread is now a daemon thread.
    -Creates autocompleter box and Calltip box once.
    -Broke long functions apart.
    -'Esc'now closes autobox and calltip.

.500 EKR:
    - Made minor changes based on .425:
    -Improved docstring.
    -Converted to 4.2style.
.501 EKR:
    - Changed select method following patch by original author.
    - Added event.keysym=='Up' case to
.55 Lu:
     - Made the watcher def more greedy.  See def for rationale
     - Made the calltip identification regex more liberal.
     - streamlined some code.
     - added DictSet class, experimental in the sense that I haven't had a bug with it yet.  see &lt;&lt;DictSet&gt;&gt; node, under &lt;&lt; globals&gt;&gt;
     - discovered dependency between this and Chapters, auto needs to be loaded first
.60 Lu
    - Changed some method names to more acuaretely reflect what they do.  Added more comments.
    - processKeyStroke cleaned up.
    - added Functionality where any mouse button press, anywhere in Leo will turn off autobox and calltip label.
    - waiting for Chapters( or chapters ) to have its walkChapters def fixed up, so we can walk the chapters on startup.
 .7 Lu( The placer revolution!)
   -migrated to the placer!  This got rid of Canvas based drawing.  The placer may be a good tool to know in the future.  This seemed to
   be about an even replacement codewise, but I think it gives us an efficiency boost.
   -changed some lambdas to defs, more for clarities sake then anything.
   -made global changes to how objects are referred to
   -got rid of factory defs, autobox and calltip label are created at Editor creation time
   -dependency between this and Chapters eliminated.
   -added code to automatically create the .ini file and the autocompleter directory if they do not exist.
   -added a section about how to configure autocompleter
   -switched the patterns from using '+' to add pieces together to using '%s'.
.71 investigated and hopefully fixed startup bug on Windows. Changes that appear to have fixed it:
1. We synchronize with an threading Event object.  IO acting screw on windows in a thread.
2. There is a global flag indicating whether the config file needs to be read again.
3. Explicitly set the file type to 't'.  This could all be attributed to a bug in ConfigParser.  I looked at the source and it doesnt write its data with a 't'.  This indicates trouble with windows.
4. Make the 'aini' path composed of os.sep instead of the char '/'.  Im uncertain if the config file ever got read on Windows at this point because of the explicit '/' , instead of using os.path.
5. Moved createConfig part out of thread. problems seems centered on Windows/IO/Threading.

 .72 The thesis and experiments to confirm the problem identified in .71 appear
completely wrong. I could not recreate threading+writeIO staling on XP at all.
Windows 98 didnt even work. But after commenting out g.es calls it did work. My
new target for the problem is now focused on keeping g.es calls out of the
initialScan thread. This will just entail moving all the reading and writing of
the config and language files out of the thread.

.73 EKR:
    - Changed 'new_c' logic to 'c' logic in initialScan.
    - Added init function.
.74 EKR:
    - Changed 'start2' hook to 'new' hook.
.75 EKR:
    - Disable scan during unit testing.</t>
<t tx="ekr.20051025144611.8">@

the function newCreateControl decorates the leoTkinterFrame.leoTkinterBody.createControl method.
It does so to intercept the point where the editor is created.  By doing so, autocompleter is able
to ensure that the placer is used instead of the packer.  By using the placer autocompleter is able
to put the autobox and calltip label over the editor when the appropiate time is reached.  In versions
prior to .7, this was achieved by using a Tk Canvas as the background of the Editor.  The placer is simpler
and from what I see more efficient.

</t>
<t tx="ekr.20051025144611.10">@

context - means the widget that backs the editor.  In versions before .7 it was called c and was a canvas.  context is the new name, and it is no longer a canvas. c, now means commander.

context.autobox - means the Pmw.ScrolledListBox that offers the autocompletion options.

The autobox contains other widgets that can be accessed by autobox.component( 'widgetname' )

context.calltip - means the Tk.Label that offers calltip information

context.which = 0 indicates its in autocompleter mode
context.which = 1 indicates its in calltip mode</t>
<t tx="ekr.20051025144611.11">@
Autocompleter looks in the plugin directory for a file called autocompleter.ini

This file contains two options under the [ autocompleter ] section:
    useauto
    usecalltips
    setting either to 1 will turn on the feature. 0 means off.
If there is a section called [ newlanguages ] it will read each option as a new language for autocompleter to recognize,
and compile its value as a regex pattern for the autocompleter system to recognize as a calltip.  This has relevance for the .ato
system described below.

languages that currently have patterns:
    python, java, c++, c and perl
This file will automatically be generated for the user if it does not exist at startup time.


Autocompleter looks in the plugin directory for a directory called autocompleter.  If it doesnt find one
it will attempt to create this directory.  This directory should contain what are called .ato files ( pronounced auto ).
Autocompleter will scan each .ato file that has a first part that matches a languages name.  For example:
    python.ato
    autocompleter recognizes python, and will scan this file.  The contents are read with the same mechanism that
    reads the information in the nodes, so calltip and autocompleter information is added to autocompleters runtime database.
If a new language has been added in the autocompleter.ini file then an .ato file that starts with the new languages name will be recognized and read in.  Note, this language needs to be recognizable to Leo.
Used correctly an .ato file is a mechanism by which a user can carry autocompletion and calltip information between .leo files/sessions.</t>
<t tx="ekr.20051025144611.12">orig_CreateControl = leoTkinterFrame.leoTkinterBody.createControl 

&lt;&lt;DictSet&gt;&gt;
#watchwords ={} switched to DictSet
watchwords = DictSet() # a DictSet that is the autocompleter database.
#calltips ={} switched to DictSet
calltips = DictSet( factory = DictSet) # a DictSet that is the calltip database
pats ={} #used to hold regex patterns to find defintions for calltips
lang = None #determines what language is in effect.  Though its global, only one autobox or calltip label should be visible for the entire leo instance.
configfilesread = False #Determines if the config files need to be read
haveseen = weakref.WeakKeyDictionary()# a dict that tracks the commanders that have been seen without stopping garbage collection of that commander.
</t>
<t tx="ekr.20051025144611.13">class DictSet( dict ):
    '''A dictionary that always returns either a fresh sets.Set or one that has been stored from a previous call.
    a different datatype can be used by setting the factory keyword in __init__ to a different class.'''
    
    def __init__( self , factory = sets.Set ):
        dict.__init__( self )
        self.factory = factory
        
    def __getitem__( self, key ):
        try:
            return dict.__getitem__( self, key ) # EAFTP
        except:
            dict.__setitem__( self, key, self.factory() )
            return dict.__getitem__( self, key )
</t>
<t tx="ekr.20051025144611.14"># This section defines patterns for calltips.
space = r'[ \t\r\f\v ]+'
end = r'\w+\s*\([^)]*\)'

pats ['python'] = re.compile(r'def\s+%s' % end)

pats ['java'] = re.compile(
    r'((public\s+|private\s+|protected\s+)?(static%s|\w+%s){1,2}%s)' % (
        space, space, end))

pats ['perl'] = re.compile(r'sub\s+%s' % end)

pats ['c++'] = re.compile(r'((virtual\s+)?\w+%s%s)' % (space,end))

pats ['c'] = re.compile(r'\w+%s%s' % (space,end))

r = string.punctuation.replace('(','').replace('.','')
pt = string.digits + string.letters + r

ripout = string.punctuation + string.whitespace + '\n'
ripout = ripout.replace('_','')

okchars = {}
for z in string.ascii_letters:
    okchars [z] = z
okchars ['_'] = '_'</t>
<t tx="ekr.20051025144611.15">def init ():
    
    ok = Pmw and Tk and not g.app.unitTesting # Not for unit tests: modifies core classes.
    
    if ok:
        leoTkinterFrame.leoTkinterBody.createControl = newCreateControl 
        leoPlugins.registerHandler(('new','open2'),initialScan)   
        g.plugin_signon(__name__)
        
    return ok</t>
<t tx="ekr.20051025144611.16">watchitems = ('.',')')
txt_template = '%s%s%s'

def watcher (event):
    '''A function that tracks what chars are typed in the Text Editor.
    Certain chars activate the text scanning code.'''
    global lang
    if not (event.char.isspace() or event.char in watchitems):
        return
        
@
This if statement ensures that attributes set in another node are put in the
database.Of course the user has to type a whitespace to make sure it happens.
We try to be selective so that we dont burn through the scanText def for  every
whitespace char entered.This will help when the nodes become big.
@c
    bCtrl = event.widget
    if event.char.isspace():
        # Do nothing if the previous char was a whitespace
        if bCtrl.get('insert -1c').isspace(): return
        if bCtrl.get('insert -1c wordstart -1c') != '.': return
    c = bCtrl.commander
    lang = c.frame.body.getColorizer().language
    txt = txt_template % (
        bCtrl.get("1.0",'insert'),
        event.char, bCtrl.get('insert',"end"))
        # Add the newest char; its not in the bCtrl yet
    scanText(txt)</t>
<t tx="ekr.20051025144611.17">def scanText (txt):

    '''This function guides what gets scanned.'''

    if useauto:
        scanForAutoCompleter(txt)
    if usecall:
        scanForCallTip(txt)</t>
<t tx="ekr.20051025144611.18">def scanForAutoCompleter (txt):
    
    '''This function scans text for the autocompleter database.'''

    t1 = txt.split('.')
    g =[]
    reduce(lambda a,b:makeAutocompletionList(a,b,g),t1)
    if g:
        for a, b in g:
            #if watchwords.has_key(a):
            #    watchwords[a].add(b)
            #else:
            #    watchwords[a] = sets.Set([b])
            watchwords[ a ].add( b )
            # we are using the experimental DictSet class here.
            # usage removed the above statements
            # notice we have cut it down to one line of code here!</t>
<t tx="ekr.20051025144611.19">def scanForCallTip (txt):

    '''this function scans text for calltip info'''

    # pat2 = pats['python']
    # if lang:
        # if pats.has_key(lang):
            # pat2 = pats[lang]

    pat2 = pats.get(lang or 'python')
    g2 = pat2.findall(txt) or []

    for z in g2:
        if isinstance(z,tuple):
            z = z [0]
        pieces2 = z.split('(')
        pieces2 [0] = pieces2 [0].split() [ -1]
        a, b = pieces2 [0], pieces2 [1]
        calltips [lang][a].add(z)</t>
<t tx="ekr.20051025144611.20">def makeAutocompletionList (a,b,glist):
    
    '''A helper function for autocompletion'''
    a1 = _reverseFindWhitespace(a)
    if a1:
        b2 = _getCleanString(b)
        if b2!='':
            glist.append((a1,b2))
    return b 

</t>
<t tx="ekr.20051025144611.21">def _getCleanString (s):
    '''a helper for autocompletion scanning'''
    if s.isalpha():return s 

    for n, l in enumerate(s):
        if l in okchars:pass 
        else:return s[:n]
    return s 
</t>
<t tx="ekr.20051025144611.22">def _reverseFindWhitespace (s):
    '''A helper for autocompletion scan'''
    for n, l in enumerate(s):
        n =(n+1)*-1
        if s[n].isspace()or s[n]=='.':return s[n+1:]
    return s 
</t>
<t tx="ekr.20051025144611.23">def initialScan (tag,keywords):
    '''This method walks the node structure to build the in memory database.'''
    c = keywords.get("c")
    if not c or haveseen.has_key(c):
        return 

    haveseen[c] = None 
    
    #This part used to be in its own thread until problems were encountered on Windows 98 and XP with g.es
    pth = os.path.split(g.app.loadDir)  
    aini = pth[0]+r"%splugins%sautocompleter.ini" % ( os.sep, os.sep )    
    if not os.path.exists(aini):
        createConfigFile( aini )
    try:
        if not hasReadConfig():
            if os.path.exists(aini):
                readConfigFile(aini) 

            bankpath = pth[0]+r"%splugins%sautocompleter%s" % ( os.sep, os.sep, os.sep )
            readLanguageFiles(bankpath)#This could be too expensive to do here if the user has many and large language files.
    finally:
        setReadConfig()
    
    # Use a thread to do the initial scan so as not to interfere with the user.            
    def scan():
        #g.es( "This is for testing if g.es blocks in a thread", color = 'pink' )
        # During unit testing c gets destroyed before the scan finishes.
        if not g.app.unitTesting:
            readOutline( c )
        
    t = threading.Thread( target = scan )
    t.setDaemon(True)
    t.start()
</t>
<t tx="ekr.20051025144611.24">#These functions determine if the config and language files have been read or not.
# No need to read it more than once.

def hasReadConfig():
    return configfilesread

def setReadConfig():
    global configfilesread
    configfilesread = True</t>
<t tx="ekr.20051025144611.25">def readConfigFile (aini):
    '''reads the autocompleter config file in.'''
    global usecall, useauto 
    
    try:
        cp = ConfigParser.ConfigParser()
        fp = open( aini, 'rt' )
        cp.readfp( fp )
        fp.close()
    except Exception, x:
        g.es( "Could not open %s because of %s" % ( aini, x ), color = 'red' )
    ac = None 
    
    for z in cp.sections():
        if z.strip()=='autocompleter':
            ac = z 
        else:
            continue
        if cp.has_section(ac):
            if cp.has_option(ac,'useauto'):
                useauto = int(cp.get(ac,'useauto'))
                if useauto:
                    g.es( "autocompleter enabled", color = 'blue' )
            if cp.has_option(ac,'usecalltips'):
                usecall = int(cp.get(ac,'usecalltips'))
                if usecall:
                    g.es( "calltips enabled" , color = 'blue' )
        break

    nl = None
    for z in cp.sections():
        if z.strip()=='newlanguages':
            nl = z 
        else:
            continue
        if nl and cp.has_section( nl ):
            for z in cp.options( nl ):
                try:
                    pats[ z ] = re.compile( cp.get( nl, z ) )
                    g.es( 'added %s to autocompleter languages' % z , color = 'blue' )
                except Exception, x:
                    g.es( "Could not add %s pattern, because of %s " %( z, x ) , color = 'red')
                    
        break
</t>
<t tx="ekr.20051025144611.26">def createConfigFile( aini ):
    '''This function creates a config file identified by the parameter aini'''
    cp = ConfigParser.ConfigParser()
    cp.add_section( 'autocompleter' )
    cp.set( 'autocompleter', 'useauto', '1' )
    cp.set( 'autocompleter', 'usecalltips', '1' )
    cp.add_section( 'newlanguages' )
    try:
        ini = open( aini, 'wt' )
        cp.write( ini )
        ini.close()
        g.es( "autocompleter .ini file created in %s" % aini, color = 'blue' )
    except Exception, x:
        g.es( "Error in creating %s, caused by %s" % ( aini, x ) , color = 'red' )


</t>
<t tx="ekr.20051025144611.27">def readLanguageFiles (bankpath):
    '''reads language files in directory specified by the bankpath parameter'''
    global lang
    if not os.path.exists( bankpath ):
        try:
            os.mkdir( bankpath )
        except Exception, x:
            g.es( "Could not make %s because of %s" %( bankpath, x ) )
    for z in pats:
        bpath = bankpath+z+'.ato'
        if os.path.exists(bpath):
            f = open(bpath)
            lang = z 
            map( scanText, f )
            #for x in f:
            #    scanText(x)
            f.close()</t>
<t tx="ekr.20051025144611.28">def readOutline (c):
    '''This method walks the Outline(s) and builds the database from which
    autocompleter draws its autocompletion options
    c is a commander in this case'''
    global lang
    if 'Chapters'in g.app.loadedPlugins: #Chapters or chapters needs work for this function properly again.
        import chapters 
        it = chapters.walkChapters()
        for x in it:
            lang = None 
            setLanguage(x)
            scanText(x.bodyString())
    else:
        for z in c.rootPosition().allNodes_iter():
            setLanguage( z )
            scanText( z.bodyString() )</t>
<t tx="ekr.20051025144611.29">def reducer (lis,pat):
    '''This def cuts a list down to only those items that start with the parameter pat, pure utility.'''
    return[x for x in lis if x.startswith(pat)]
</t>
<t tx="ekr.20051025144611.30">def unbind (context):

    '''This method turns everything off and removes the calltip and autobox from the canvas.'''

    if context.on: #no need to do this stuff, if were not 'on'
        context.on = False
        context.clean_editor()
        map(context.unbind,(
            "&lt;Control_L&gt;", "&lt;Control_R&gt;", "&lt;Alt-Up&gt;", "&lt;Alt-Down&gt;", "&lt;Alt_L&gt;", "&lt;Alt_R&gt;"))
        context.unbind_all('&lt;Button&gt;')
        context.update_idletasks()</t>
<t tx="ekr.20051025144611.31">def moveSelItem (event, context ):

    '''Move the selection in the autobox up or down.'''

    autobox = context.autobox
    i = autobox.curselection()
    if len(i)==0:
        return None 
    i = int(i[0])
    # g.trace(event.keysym,i)
    try:
        if event.keysym=='Down':
            if autobox.size() - 1 &gt; autobox.index( i ):
                i += 1
            elif i!=0:
                i -1  ## Can't be correct.
        elif event.keysym=='Up': # EKR.
            if i &gt; 0:
                i -= 1
    finally:
        autobox.select_clear( 0, 'end' )
        autobox.select_set( i )
        autobox.see( i )
        context.update_idletasks()
        return "break"
</t>
<t tx="ekr.20051025144611.32">def processKeyStroke (event,context,body):

    '''Take action based on the state of context (a Tk.Canvas) and the event'''
    
    autobox = context.autobox

    if not context.on or event.keysym in ("??","Shift_L","Shift_R"):
        return None
    elif testForUnbind(event,context):
        unbind(context)
        return None
    elif context.which == 1:
        return None # It is calltip time.
        
    index = body.index('insert-1c wordstart')
    pat = body.get(index,'insert') + event.char
    pat = pat.lstrip('.')
    ww = list(autobox.get(0,'end'))
    aList = reducer(ww,pat)
    if not aList: return None
    # Select which item to select based on what the user has typed.
    i = ww.index(aList[0])
    # Set the current selection to match what the user has typed.
    autobox.select_clear(0,'end') 
    autobox.select_set(i)
    autobox.see(i)
    return 'break'</t>
<t tx="ekr.20051025144611.33">def testForUnbind( event, context ):
    '''c in this case is a Tkinter Canvas.
      This def checks if the autobox or calltip label needs to be turned off'''

    if event.keysym in ('parenright','Control_L','Control_R', 'Escape' ):
        return True
    elif not context.which and event.char in ripout:
        return True
    return False
</t>
<t tx="ekr.20051025144611.34">def processAutoBox(event, context , body ):
    '''This method processes the selection from the autobox.'''
    if event.keysym in("Alt_L","Alt_R"):
        return None 

    a = context.autobox.getvalue()
    if len(a)==0:return None 
    try:
        a = a[0]
        ind = body.index('insert-1c wordstart')
        pat = body.get(ind,'insert')
        pat = pat.lstrip('.')

        if a.startswith(pat):a = a[len(pat):]
        body.insert('insert',a)
        body.event_generate("&lt;Key&gt;")
        body.update_idletasks()
    finally:
        unbind( context )
</t>
<t tx="ekr.20051025144611.35">def add_item (event, context ,body,colorizer):
    '''This function will add the autobox or the calltip label.'''
    if not event.char in('.','(')or context.on:return None 
    txt = body.get('insert linestart','insert')
    txt = _reverseFindWhitespace(txt)
    if event.char!='('and not watchwords.has_key(txt):
         return None 

    if event.char=='.' and useauto:

        ww = list(watchwords[txt])
        ww.sort()
        autobox = context.autobox
        configureAutoBox( autobox, ww )
        autolist = autobox.component( 'listbox' )
        #We have to hand the listbox in, its the only thing providing accuracy of size and position.
        calculatePlace( body, autolist, context, autobox )
        autobox.select_set( 0 )
        context.which = 0 #indicates it's in autocompletion mode
        add_bindings( context, body )
    
    elif event.char=='(' and usecall:
        language = colorizer.language 
        if calltips.has_key(language):
            if calltips[language].has_key(txt):

                s = list(calltips[language][txt])
                t = '\n'.join(s)
                calltip = context.calltip 
                calltip.configure(text=t)
                #The calltip provides sufficient size information to calculate its place on top of the context. 
                calculatePlace(body, calltip ,context, calltip  )
                context.which = 1 #indicates it's in calltip mode
        
        else:
            context.on = False 
            return None 

</t>
<t tx="ekr.20051025144611.36">def add_bindings( context, body ):
    
    '''This def adds bindings to the Canvas so it can work with the autobox properly.'''
            
    event = Tk.Event()
    event.keysym = ''
    
    def processAutoBoxHandler( event = event , context = context, body = body  ): 
        processAutoBox( event, context , body  )
        
    context.autobox.configure( selectioncommand = processAutoBoxHandler )
    
    def moveSelItemHandler( event, context = context ): 
        moveSelItem( event, context )
    
    bindings = ( ( "&lt;Control_L&gt;", processAutoBoxHandler ), ( "&lt;Control_R&gt;", processAutoBoxHandler ),
                 ( "&lt;Alt-Up&gt;", moveSelItemHandler, '+' ), ( "&lt;Alt-Down&gt;", moveSelItemHandler , '+'),
                 ( "&lt;Alt_L&gt;", processAutoBoxHandler ), ( "&lt;Alt_R&gt;", processAutoBoxHandler ) )
         
    def bind2( args ): context.bind( *args )
    map( bind2, bindings )
</t>
<t tx="ekr.20051025144611.37">def configureAutoBox ( autobox ,ww):
    '''sets data and size of autobox.'''
    autobox.setlist(ww)
    lb = autobox.component('listbox')
    height = len(ww)
    if height&gt;5:height = 5
    lb.configure(height=height)
</t>
<t tx="ekr.20051025144611.38">def calculatePlace (body,cwidg, context ,toBePlaced):
     '''This def determines where the autobox or calltip label goes on the canvas.
       And then it puts it on the canvas.
       body is the Tk Text instance.
       cwidg is the widget from which we derive the calculations.
       context is the parent of the cwidg, we bind the context in this function.
       toBePlaced is the widget that is placed with the calculatsions performed.'''
     try:
        x, y, lww, lwh = body.bbox('insert -1c')
        x, y = x+lww, y+lwh 
     except:
         x = 1
         y = 1
     rwidth = cwidg.winfo_reqwidth()
     rheight = cwidg.winfo_reqheight()
     if body.winfo_width()&lt;x+rwidth:  
        x = x-rwidth 
     if y&gt;body.winfo_height()/2:
        h2 = rheight 
        h3 = h2+lwh 
        y = y-h3 

     toBePlaced.place( x = x, y = y )
     context.on = True
     context.bind_all( '&lt;Button&gt;', context.do_unbind )
</t>
<t tx="ekr.20051025144611.39">def setLanguage ( pos ):
    '''This method checks a node for the current language in effect
       and accends the parent line until it finds a language.'''
    global lang 
    while pos:
        xs1 = pos.bodyString()
        dict = g.get_directives_dict(xs1)
        if dict.has_key('language'):
            lang = g.set_language(xs1,dict['language'])[0]
            break 
        pos = pos.parent()
</t>
<t tx="ekr.20051025144611.40">def newCreateControl (self,frame,parentFrame):
    '''A decoration of the createControl def.
    We set up the ancestory of the control so we can draw
    widgets over the Text editor without disturbing the text.'''

@
Creating the background:
- We now use a placer: simpler to use and more efficient.
- We have to decorate the Tk.Text widget with a constructor that creates an
  intermediate Frame for the Text to be placed instead of packed.
  Had no idea that the placer could do this so nicely.
  With a couple changes in 3 places, we are using the placer !
@c
    orig_init = Tk.Text.__init__ #We stash the original init of Tk.Text
    def pre_init (self,master,*args,**kwords):

        context = Tk.Frame(master)
            #This is what we need to put in before the text to make place work.
        orig_init(self,context,*args,**kwords)

    Tk.Text.__init__ = pre_init #We restore the original init of Tk.Text
    body = orig_CreateControl(self,frame,parentFrame) #orig_CreatControl is the method this def decorates
    Tk.Text.__init__ = orig_init

    context = body.master #This is the Frame we created to intercept the passed in master.
    context.pack(expand=1,fill='both',after=frame.bodyBar) #We have to add it to the environment, since we pass on it in the __init__
    body.place(relwidth=1.0,relheight=1.0)
    body.commander = self.c #used in watcher
    context.on = False #determines if the system is autocompleting or calltiping
    addAutoboxAndCalltipWidgets(context)
    #These used to be lambdas, but I think this is clearer.
    def processKeyStrokeHandler (event,context=context,body=body):
        processKeyStroke(event,context,body)
    def addItemHandler (event,context=context,body=body,colorizer=frame.body):
        add_item(event,context,body,colorizer.getColorizer())

    for z in (watcher,processKeyStrokeHandler,addItemHandler):
        context.bind("&lt;Key&gt;",z,'+')

    ignore = [] #ignore items added to this list when a Button event occurs.
    if hasattr(context,'autobox'):
        ignore.append(context.autobox.component('listbox'))
        ignore.append(context.autobox.component('vertscrollbar'))
    def do_unbind (event):
        '''This def is for doing the unbind on any &lt;Button&gt; events.
           It only is in effect when the autobox or calltip label are showing.'''
        if event.widget not in ignore: #This ensures a click or scroll in the autobox takes effect.
                unbind(context)

    context.do_unbind = do_unbind

    # This part protects this plugin from others that use Alt-Up, Alt-Down.
    # The frame didnt seem to work.  Im assuming it was not appropiate enought in the bindtag order for the event.
    context.block_alt = Tk.Entry()
    def block_alt (event):
        '''This def blocks specific keyboard commands from reaching the Text editor.  'breaking' in
           the context does not occur before the event reaches the Text editor, so it has no effect'''
        if context.on: return 'break'
    for z in ('&lt;Alt-Up&gt;','&lt;Alt-Down&gt;'): context.block_alt.bind(z,block_alt)

    #set the bindtags for the body, protects the autocompleter from other plugins unbinding this plugins bindings.
    ctags = []
    ctags.append(context.bindtags()[0])
    ctags.append(context.block_alt.bindtags()[0])
    ctags.extend(body.bindtags())
    body.bindtags(tuple(ctags))

    return body

</t>
<t tx="ekr.20051025144611.41">def addAutoboxAndCalltipWidgets( context ):
    '''This builds the autobox and the calltip label for the editor.
      It should be called once for every editor created.'''
    
    call_pack_forget = []

    if useauto:
        context.autobox = Pmw.ScrolledListBox(
            context ,hscrollmode='none',
            listbox_selectbackground='#FFE7C6',
            listbox_selectforeground='blue',
            listbox_background='white',
            listbox_foreground='blue',
            vertscrollbar_background='#FFE7C6',
            vertscrollbar_width=10)
        call_pack_forget.append( context.autobox.component( 'hull' ) )
    
    if usecall:            
        context.calltip = Tk.Label(context,background='lightyellow',foreground='black')
        call_pack_forget.append( context.calltip )
    
    def clean_editor( ca = call_pack_forget ):
        #This def makes removing the autobox or calltip label easy.
        # No need for an intermediate variable like 'current'.
        for z in ca: z.place_forget()

    context.clean_editor = clean_editor</t>
<t tx="ekr.20051025144611.42">def onOpenWindow ():

    #what does this do?
    c = keywords.get("c")
    if haveseen.has_key(c):
        return 
        
    autocompleter = autocomplet(c)</t>
<t tx="ekr.20051025150224">def onIdleTime (self):
    
    '''Set the focus to the body pane if the focus is in limbo.
    
    We must allow dialogs and the outer window frame to retain focus.'''
    
    k = self ; c = k.c
    if g.app.quitting: return # Essential.
    
    w = g.app.gui.get_focus(c.frame)
    if w:
        # Allow clicks in enclosing window frame or in dialogs.
        name = hasattr(w,'_name') and w._name or ''
        ok = (
            name and name[0] in string.letters # A known Leo frame.
            or w == c.frame.top # The top of the Leo window
            or g.app.dialogs &gt; 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
            # or isinstance(w,Tk.Button)
        )
        if not ok:
            # Not a name created by Leo.
             g.trace(self.idleCount,name,w)
             c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051025170832"></t>
<t tx="ekr.20051025170832.1"></t>
<t tx="ekr.20051026083544">def handleDefaultChar(self,event):
    
    c = self.c
    ch = event and event.char
    w = event and event.widget
    name = w and hasattr(w,'_name') and w._name or ''

    if name.startswith('body'):
        c.frame.body.updateBody(event,w,undoType='Typing')
        return 'break'
    elif name.startswith('head'):
        g.trace("can't happen: %s" % (name),color='red')
        c.frame.tree.updateHead(event,w)
        return 'break'
    else:
        # Let tkinter handle the event.
        # g.trace('to tk:',name,repr(ch))
        return None</t>
<t tx="ekr.20051026083544.2">def updateHead (self,event,w):
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    i,j = g.app.gui.getTextSelection(w)

    if ch == '\b':
        if i != j:
            w.delete(i,j)
        else:
            w.delete('insert-1c')
    elif ch and ch not in ('\n','\r'):
        if i != j:
            w.delete(i,j)
        i = w.index('insert')
        w.insert(i,ch)

    s = w.get('1.0','end')
    
    if s.endswith('\n'):
        if len(s) &gt; 1: s = s[:-1]
        else:          s = ''

    if 0: # p does not *officially* change until onHeadChanged is called.
        p.initHeadString(s)
    w.configure(width=self.headWidth(s=s))
    
    # The granularity is the entire editing session,
    # starting at the revert point.
    if ch in ('\n','\r'):
        g.trace(repr(s))
        self.endEditLabel()
        self.onHeadChanged(p)
        </t>
<t tx="ekr.20051026083733"># This replaces idle_body_key.  It is never called at idle time.
# Called only from k.handleDefaultChar and tkBody.onBodyChanged.

def updateBody (self,event,w,undoType,
    oldSel=None,oldYview=None,newSel=None,oldText=None):

    '''Update Leo after the body have been changed.'''
    
    c = self.c ; p = c.currentPosition()
    ch = event and event.char or ''
    orignalText = oldText # for use by undo.
    removeTrailing = None # A signal to compute it later.
    # g.trace(repr(ch))
    oldSel = g.app.gui.getTextSelection(w)
    oldText = p.bodyString()
    if ch == '\t':
        self.updateTab(p,w)
    elif ch == '\b': ## chr(8):
        # Not strictly correct: we should test for present delete binding...
        self.updateBackspace(p,w)
    elif ch in ('\r','\n'):
        ch = '\n'
        &lt;&lt; handle newline &gt;&gt;
    elif ch in ('(',')','[',']','{','}') and c.config.getBool('autocomplete-brackets'):
        self.updateAutomatchBracket(p,w,ch,oldSel)
    elif ch: # Null chars must not delete the selection.
        i,j = oldSel
        if i != j: w.delete(i,j)
        w.insert(i,ch)
    if g.doHook("bodykey1",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType):
        return # The hook claims to have handled the event.
    # Update the text and handle undo.
    if not newSel: newSel = g.app.gui.getTextSelection(w)
    newText = w.get('1.0','end')
    &lt;&lt; remove extra Trailing newlines &gt;&gt; # Same logic as always.
    w.see(w.index('insert'))
    if newText == oldText: return
    c.undoer.setUndoTypingParams(p,undoType,
        orignalText or oldText,newText,oldSel,newSel,oldYview)
    p.v.setTnodeText(newText)
    p.v.t.insertSpot = c.frame.body.getInsertionPoint()
    &lt;&lt; recolor the body &gt;&gt;
    if not c.changed: c.setChanged(True)
    &lt;&lt; redraw the screen if necessary &gt;&gt;
    g.doHook("bodykey2",c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)</t>
<t tx="ekr.20051026083733.6">self.frame.scanForTabWidth(p)

# incremental = undoType not in ("Cut","Paste") and not self.forceFullRecolorFlag

incremental = not self.forceFullRecolorFlag
self.frame.body.recolor_now(p,incremental=incremental)
self.forceFullRecolorFlag = False</t>
<t tx="ekr.20051026083733.7">redraw_flag = False
c.beginUpdate()
try:
    # Update dirty bits.
    # p.setDirty() sets all cloned and @file dirty bits.
    if not p.isDirty() and p.setDirty():
        redraw_flag = True
        
    # Update icons.  p.v.iconVal may not exist during unit tests.
    val = p.computeIcon()
    if not hasattr(p.v,"iconVal") or val != p.v.iconVal:
        p.v.iconVal = val
        redraw_flag = True
finally:
    # Redraw only if necessary.
    c.endUpdate(redraw_flag) </t>
<t tx="ekr.20051026092433">def updateTab (self,p,w):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    if tab_width &gt; 0:
        w.insert("insert",'\t')
    else:
        # Get the preceeding characters.
        s = w.get("insert linestart","insert")
    
        # Compute n, the number of spaces to insert.
        width = g.computeWidth(s,tab_width)
        n = abs(tab_width) - (width % abs(tab_width))
        w.insert("insert",' ' * n)</t>
<t tx="ekr.20051026092433.1">def updateBackspace (self,p,w):
    
    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width)
    
    i,j = g.app.gui.getTextSelection(w)
    if i != j:
        w.delete(i,j)
    elif tab_width &gt; 0:
        w.delete('insert-1c')
    else:
        &lt;&lt; backspace with negative tab_width &gt;&gt;</t>
<t tx="ekr.20051026092746">s = prev = w.get("insert linestart","insert")
n = len(prev)
abs_width = abs(tab_width)

# Delete up to this many spaces.
n2 = (n % abs_width) or abs_width
n2 = min(n,n2) ; count = 0

while n2 &gt; 0:
    n2 -= 1
    ch = prev[n-count-1]
    if ch != ' ': break
    else: count += 1

# Make sure we actually delete something.
w.delete("insert -%dc" % (max(1,count)),"insert")</t>
<t tx="ekr.20051026143009">@ Tk will add a newline only if:
1. A real change has been made to the Tk.Text widget, and
2. the change did _not_ result in the widget already containing a newline.

It's not possible to tell, given the information available, what Tk has actually done. We need only make a reasonable guess here.   setUndoTypingParams stores the number of trailing newlines in each undo bead, so whatever we do here can be faithfully undone and redone.
@c
new = newText ; old = oldText

if removeTrailing != None:
    pass # Use the value returned from updateAutoIndent.
elif len(new) == 0 or new[-1] != '\n':
    # There is no newline to remove.  Probably will never happen.
    removeTrailing = False
elif len(old) == 0:
    # Ambigous case.  Formerly always returned False.
    if new == "\n\n":
        removeTrailing = True # Handle a very strange special case.
    else:
        removeTrailing = ch not in ('\r','\n')
elif old == new[:-1]:
    # A single trailing character has been added.
    removeTrailing = ch not in ('\r','\n') # 6/12/04: Was false.
else:
    # The text didn't have a newline, and now it does.
    # Moveover, some other change has been made to the text,
    # So at worst we have misrepresented the user's intentions slightly.
    removeTrailing = True
    
if removeTrailing:
    if len(newText) &gt; 1: newText = newText[:-1]
    else: newText = ''
    
if 0:
    if removeTrailing:
        g.trace('removeTrailing')
        # g.trace(repr(oldText))
    # g.trace(repr(newText))</t>
<t tx="ekr.20051026171121">i,j = oldSel

if i != j:
    # No auto-indent if there is selected text.
    w.delete(i,j)
    w.insert(i,ch)
else:
    w.insert(i,ch)
    if self.frame.body.colorizer.useSyntaxColoring(p) and undoType != "Change":
        # No auto-indent if in @nocolor mode or after a Change command.
        removeTrailing = self.updateAutoIndent(p)</t>
<t tx="ekr.20051026171121.1"># By David McNab:
def updateAutoIndent (self,p):

    c = self.c
    d = g.scanDirectives(c,p)
    tab_width = d.get("tabwidth",c.tab_width) # Get the previous line.
    s = c.frame.bodyCtrl.get("insert linestart - 1 lines","insert linestart -1c")
    # Add the leading whitespace to the present line.
    junk, width = g.skip_leading_ws_with_indent(s,0,tab_width)
    if s and len(s) &gt; 0 and s [ -1] == ':':
        # For Python: increase auto-indent after colons.
        if self.colorizer.scanColorDirectives(p) == "python":
            width += abs(tab_width)
    if c.config.getBool("smart_auto_indent"):
        # Determine if prev line has unclosed parens/brackets/braces
        brackets = [width] ; tabex = 0
        for i in range(0,len(s)):
            if s [i] == '\t':
                tabex += tab_width-1
            if s [i] in '([{':
                brackets.append(i+tabex+1)
            elif s [i] in '}])' and len(brackets) &gt; 1:
                brackets.pop()
        width = brackets.pop()
    ws = g.computeLeadingWhitespace(width,tab_width)
    if ws:
        c.frame.bodyCtrl.insert("insert",ws)
        removeTrailing = False
    else:
        removeTrailing = None
    return removeTrailing</t>
<t tx="ekr.20051027105304">- Review the posting about making positions permanent, or recording vnode
indicies. It's probably time to do this.

- Make sure there is some way of executing script find/changes.</t>
<t tx="ekr.20051027135712">@nocolor

1. Removed the requirement that you have to type &lt;return&gt; to make the headline
stick, yet I have retained the larger undo granularity in headlines.

I had to use a real hack to make this work. I finally remembered that
g.app.gui.getTextSelection(w) will return the contents of the clipboard. This
allowed me to get around the fact that w.get does not provide (even after idle
time!) the proper contents of a Tk canvas text widget after a paste.

The workaround: tree.updateHead computes what the widget *already* contains,
then stuffs that value back into the widget. So later calls (especially in
tree.onHeadChanged) get the correct value.

The final piece of the puzzle: tree.select now calls onHeadChanged when
unselecting a node. This allows us to dispense with return characters.

2. Fixed an long-standing bug involving revertHeadline. This must be set in
tree.select for *all* headlines, whether or not they are ever edited. This ivar
is now defined in tkTree, where it belongs.

3. Fixed bug: Clicking in the body pane could loose the latest headline edit.

4. Fixed bug: tree.updateHead was being called twice for pastes, which resulted
in the 'truncating headline' message.</t>
<t tx="ekr.20051027172949">def updateAutomatchBracket (self,p,w,ch,oldSel):
    
    # assert ch in ('(',')','[',']','{','}')
    
    c = self.c ; d = g.scanDirectives(c,p) ; i,j = oldSel
    language = d.get('language')
    
    if ch in ('(','[','{',):
        automatch = language not in ('plain',)
        if automatch:
            ch = ch + {'(':')','[':']','{':'}'}.get(ch)
        if i != j:
            w.delete(i,j)
        w.insert(i,ch)
        if automatch:
            w.mark_set('insert','insert-1c')
    else:
        ch2 = w.get('insert')
        if ch2 in (')',']','}'):
            w.mark_set('insert','insert+1c')
        else:
            if i != j:
                w.delete(i,j)
            w.insert(i,ch)</t>
<t tx="ekr.20051028061546">@nocolor

- open the minibuffer to get suggestions.
- Per-pane key bindings. (arrows, etc.)

@color</t>
<t tx="ekr.20051028061611.1"></t>
<t tx="ekr.20051028061802">- Use typing completion to select desired word.
- No auto-scan: use database instead.
- Scan button does manual scan.
- Use import or inspect instead of text scan.
- @strings autocompleter-info
list of names for which classes are known: c,frame,g,k,p,t,tree,v etc.
  (Autocompleter may already do this)
</t>
<t tx="ekr.20051028165515"></t>
<t tx="ekr.20051029065806"></t>
<t tx="ekr.20051029070945"># Bugs fixed
    
leoEditCommands.py:5912: No global (local_dictionary) found [changed to fileName].
leoKeys.py:1369: Parameter (forceFocus) not used [added call to bodyWantsFocus as end of k.endCommand.]

# Can't suppress
leoEditCommands.py:5996: Overridden method (change) doesn't match signature in class (leoFind.leoFind)</t>
<t tx="ekr.20051031040240"></t>
<t tx="ekr.20051101161545">The standard Emacs bindings assigns several keys to the same command. The syntax
of entries in @shortcuts nodes will be expanded to allow entries like this:

    next-line = (body) [DnArrow,Ctrl-N]
</t>
<t tx="ekr.20051102122405">@nocolor

** New utils for unit testing
    - The idea is to avoid subclassing TestCase,
      and to avoid the kind of helper code that is in leoTest.leo.
    - data = g.saveSubtree()
    - g.restoreSubtree(data)

- g.simulateKeystrokes (keystrokes,p=None)
    - keystrokes is a list of bindings to be 'executed' as if typed.
        - This is an easy way of simulating user interaction.

- unit calls k.simulateKeystrokes and then makes assertions about
    - state
    - Contents of label.
    - ivars
    - Contents of body text.
    - what widget has focus.
    - what the point, mark and selection are.
    - etc.</t>
<t tx="ekr.20051103091115"></t>
<t tx="ekr.20051103091115.1">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3411067
By: rogererens

I forgot to mention that I seem to be unable to scroll in the Find Tab, so I
need to resize the pane to press the Find button.

Also, in the settings of Find/Change, I would choose for grouping the settings
node_only, search_body, search_headline, wrap (and possibly the whole_word option
also) together under search extent radio buttons. Although this organizational
mode mentions radio buttons, check boxes are used for selection_only and
suboutline_only, which I can enable both at the same time.
It's also not (yet?) very clear to me how selection_only, suboutline_only, node_only
(should) interact...

Finally, the comment on the batch settings tells me it's really the "Show Context"
option. However, the meaning of "Show Context" is not explained by the comment.

Regards,
Roger
</t>
<t tx="ekr.20051103091115.2"></t>
<t tx="ekr.20051103091115.3">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3411030
By: rogererens

I found some glitches on my system:
Leo Log Window...
Leo 4.4 alpha 2, build  1.317 , November 2, 2005
Python 2.4.1, Tk 8.4.7, win32

leoID = rogererens (in C:\Documents and Settings\re1705)
global config dir: C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo-4-4-a2\config
home dir: C:\Documents and Settings\re1705
reading settings in C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo-4-4-a2\config\leoSettings.leo
rst3 plugin not loaded: can not load docutils
can not load enabled rst3 plugin
11 plugins loaded

1)
When Choosing the Menu File --&gt; Open... and then cancelling in the file selection
dialog, I get this Tk error pane:
Error: 1
AttributeError Exception in Tk callback
  Function: &lt;function callit at 0x01389D30&gt; (type: &lt;type 'function'&gt;)
  Args: ()
Traceback (innermost last):
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo-4-4-a2\extensions\Pmw\Pmw_1_2\lib\PmwBase.py", line
1747, in __call__
    return apply(self.func, args)
  File "C:\Python24\lib\lib-tk\Tkinter.py", line 456, in callit
    func(*args)
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo-4-4-a2\src\leoGlobals.py", line 2328, in
idleTimeHookHandler
    c and c.keyHandler and c == top and c.keyHandler.onIdleTime()
  File "C:\Documents and Settings\re1705\My
Documents\PythonStuff\leo-4-4-a2\src\leoKeys.py", line 1910, in onIdleTime
    name = w._name
  File "C:\Python24\lib\lib-tk\Tkinter.py", line 1654, in __getattr__
    return getattr(self.tk, attr)
AttributeError: _name

This seems only to occur once. Selecting File --&gt; Open... again and cancelling
shows no error dialog.

2)
Opening up the plugin manager, then enabling a plugin brings Leo unexpected
to the foreground

3)
In the plugin manager: enabling a plugin that places buttons in the buttonbar
(eg hoist), disabling it, and re-enabling it shows its buttons twice in the
button bar.
Easily worked around by restarting Leo.</t>
<t tx="ekr.20051103092502"></t>
<t tx="ekr.20051103092502.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3408579
By: e

the fix for rClick.py is
change 'body' to 'body-pane'
where it builds the menu

and 1 or 2 places
change onBodyWillChange to onBodyChanged

in dynacommon.py 2 places
change onBodyWillChange to onBodyChanged

people who download updates of plugins 
from cvs on less than Leo4.4 from plugin-manager
will have to be aware to get earlier versions.</t>
<t tx="ekr.20051103093034"></t>
<t tx="ekr.20051103093034.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3389810
By: vpe

There is still a problem with applying in-file settings when opening outline
with a @settings from another outline.
These file specific settings are not applied when the outline is opened from
another outline for the first time. They are now applied when the file is opened
2nd time from the same outline.

The settings I tested are:
@language target_language = plain
@color body_text_background_color = pink

Leo 4.4 alpha 1, build  1.303 , October 15, 2005
Python 2.4.2, Tk 8.4.7, win32</t>
<t tx="ekr.20051103094005"></t>
<t tx="ekr.20051103100302"></t>
<t tx="ekr.20051103100302.1">Leo will support both vim and xemacs by implementing @input-mode nodes in @settings trees.  For example, the xemacs &lt;ctrl-c&gt; mode will be implemented entirely as an input mode, with no special support from Leo.

The headline of  @input-mode nodes will be:

@input-mode mode-name

This creates a new minibuffer command called enter-mode-mode-name. The body text of the @input-mode node will contain key bindings for that input mode.  *Only* those key bindings will be in effect in the input mode.

To define standard emacs control-c mode we simply do the following:

1. Put the following in the main @shortcuts node:

enter-mode-quick-command = ctrl-c

2. Create the @input-mode quick-command node with the desired bindings in its body text.

That's all!

Some details:

- We'll probably want a way to copy bindings from one input mode to another.

- I don't plan to implement a stack of input modes, but it would be easy to do so: just have an input mode define a minibuffer command called push-mode-mode-name as well as enter-mode-mode-name.  You can fill in the details...

- It will probably be a good idea not to allow rebinding of ctrl-g (keyboard-quit) in an input mode.  That way there is always at least one way out :-)

I like this scheme.  It is simple, powerful, general and easy to use.  It will eliminate all the hard binding presently in the code.  It will support vim (plain-key) bindings and all the similar plain-key modes in emacs.  It will allow for unlimited experimentation with key bindings.</t>
<t tx="ekr.20051103112558"></t>
<t tx="ekr.20051103114520">def redraw (self):
    
    k = self ; c = k.c ; frame = c.frame

    if frame.requestRedraw:
        g.trace(frame.requestRedraw)
        frame.tree.redraw_now()</t>
<t tx="ekr.20051103114520.1">def setFocus (self):
    
    k = self ; c = k.c ; frame = c.frame
    
    if frame.wantedWidget:
        w = frame.wantedWidget
        g.trace(hasattr(w,'_name') and w._name or '')
        g.app.gui.set_focus(c,w)
        frame.wantedWidget = None
    else:
        # Force the widget to some standard place.
        w = g.app.gui.get_focus(c.frame)
        if not w: return
        # Allow clicks in enclosing window frame or in dialogs.
        name = hasattr(w,'_name') and w._name or ''
        if (
            name and name[0] in string.letters # A known Leo frame.
            or w == c.frame.top # The top of the Leo window
            or g.app.dialogs &gt; 0 # A dialog.
            or isinstance(w,Tk.Text)
            or isinstance(w,Tk.Entry)
            # or isinstance(w,Tk.Button)
        ):
            g.trace('ok',hasattr(w,'_name') and w._name or '')
            return
        # Not a name created by Leo.
        g.trace('setting default focus',name)
        c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051103114520.2"></t>
<t tx="ekr.20051103144316"></t>
<t tx="ekr.20051103160025">ch  = g.app.gui.getTextFromClipboard()
i,j = g.app.gui.getTextSelection(w)

i = int(i.split('.')[1])
j = int(j.split('.')[1])
s = w.get('1.0','end')

if s.endswith('\n'):
    if len(s) &gt; 1: s = s[:-1]
    else:          s = ''

g.trace(i,j,repr(s),repr(ch))

if i != j:
    s = s[:i] + ch + s[j:]
else:
    i = w.index('insert')
    i = int(i.split('.')[1])
    s = s[:i] + ch + s[i:]

w.delete('1.0','end')
w.insert('1.0',s)
w.configure(width=f.tree.headWidth(s=s))</t>
<t tx="ekr.20051103161147"></t>
<t tx="ekr.20051104051733">@nocolor
http://sourceforge.net/forum/message.php?msg_id=3412640
By: btheado

Currently clicking on the minibuffer and typing text has no effect.  Kinda confusing
until the Alt-x binding I discovered that Alt-x is the way to access the minibuffer
command mode.

It would be nice if the &lt;FocusIn&gt; binding on the minibuffer widget were equivilent
to Alt-x.</t>
<t tx="ekr.20051104053655">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3412644
By: btheado

Executing the script

    g.printList(dir(c))

I can see that many of the minibuffer commands are available by using a simple
transformation on the name.  For example, if I want to execute the 'expand-node'
minibuffer command, then I can call c.expandNode().  However, the 'full-buffer'
command doesn't seem to have a corresponding method in c.  Is there a centralized
way to execute minibuffer commands in scripts?</t>
<t tx="ekr.20051104094952">This makes leoProjects.txt much smaller and greatly speeds the Save command.</t>
<t tx="ekr.20051104094952.1"></t>
<t tx="ekr.20051104100657"></t>
<t tx="ekr.20051104100739"></t>
<t tx="ekr.20051104101307">@nocolor

The New World Order originally means that Leo will redrawing and shifting of focus at end of k.masterCommand.

1. We *do* need to have an idle-time handler that checks for redraws and focus,
because not all processing happens in the call to k.masterCommand.

Unit tests needed:

1.  Type in headline, hit return.
2.  Type in headline, click on another headline.
3. Paste in headline, hit return.
4. Paste in headline, clcik on another headline.
5. Choose Paste from Menu, hit return.
6. Choose Paste from Menu, click on another headline.

For all tests, we must check that:

a) p.headString() set properly.
b) headline set properly.
c) headline width is set properly.</t>
<t tx="ekr.20051104105403"></t>
<t tx="ekr.20051104111040"></t>
<t tx="ekr.20051104131527">@nocolor

cvs after a2

not just paste to headline, 
but paste from the
edit menu to body doesn't stick.
and rClick calls a few of those commands
so pastes from there don't stick unless you also
hit a space or some other key.

editing under settings is a little whacky too.
you can replace a whole line in a string dialog
but try to just replace the last char and it won't stick.
can't select headline text at all.</t>
<t tx="ekr.20051104152338"></t>
<t tx="ekr.20051104152338.1">@nocolor

http://sourceforge.net/forum/message.php?msg_id=3413805
By: nobody

I thought this might be for 4.4a2, but I see the same effect w/ 
Leo 4.3.3, build  1.282 , September 17, 2005
Python 2.3.5, Tk 8.4.7, win32

I haven't used Leo for code, but just started to try to re-organize some Perl
I inherited.

Leo apears to remove sentinels, AND preceding newlines, so the effect is something
like this:

.... some code....

   next line;
}
#@ leo sentinel here...
#

    If  ( something ) {
      more code;
......

becomes:

.... some code....

   next line;
} If  ( something ) {
      more code;
......

Now, that may be annoying, but mildly so - it still runs.
When this:

#
#@ sentinel
if () {

turns to this:

# if() {

code just breaks.</t>
</tnodes>
</leo_file>
