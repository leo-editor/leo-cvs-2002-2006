<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="7801" clone_windows="0"/>
<globals body_outline_ratio="0.540216086435">
	<global_window_position top="65" left="224" height="833" width="871"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20041001211817" a="E" annotate="7d71002e"><vh>Buttons</vh>
<v t="ekr.20051020124457"><vh>Disabled buttons</vh>
<v t="ekr.20041230121429"><vh>@@ button pydoc</vh></v>
<v t="ekr.20050210180937"><vh>@@ button jython</vh></v>
<v t="ekr.20050704170739"><vh>@@button Ipython</vh></v>
<v t="ekr.20050821072028"><vh>@@button Lines Up</vh>
<v t="ekr.20050821072028.1"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20050821081021"><vh>@@button Lines Down</vh>
<v t="ekr.20050821081021.1" a="M"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20050930124917"><vh>@@button outlineToClipboard</vh></v>
<v t="ekr.20051023104813"><vh>@@button check-dirty</vh></v>
</v>
<v t="ekr.20050805150320"><vh>@button rst3</vh></v>
<v t="ekr.20041001194357"><vh>@button unit test</vh></v>
<v t="ekr.20051025070722"><vh>@button Beautify</vh></v>
<v t="ekr.20051025091355"><vh>@button Spell</vh></v>
<v t="ekr.20050911112310" a="TV"><vh>@button Save</vh></v>
</v>
<v t="ekr.20041126132604" annotate="7d71002e"><vh>Prototypes</vh>
<v t="ekr.20051011211253"><vh>Debugger canvas</vh>
<v t="ekr.20051011213138"><vh>getImage</vh></v>
<v t="ekr.20051011215038"><vh>getLineHeight</vh></v>
</v>
<v t="ekr.20050707183613"><vh>Ipython Shell</vh>
<v t="ekr.20050708110336"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050708091220.78"><vh>&lt;&lt; use IPShellEmbed &gt;&gt;</vh></v>
<v t="ekr.20050708095104"><vh>class dummyCache</vh>
<v t="ekr.20050708142137"><vh>ctor</vh></v>
<v t="ekr.20050708142137.2"><vh>All others</vh></v>
</v>
<v t="ekr.20050708143008"><vh>class dummyPrompt</vh>
<v t="ekr.20050708143008.2"><vh>__init__</vh></v>
<v t="ekr.20050708143008.3"><vh>set_p_str</vh></v>
<v t="ekr.20050708143008.4"><vh>write</vh></v>
<v t="ekr.20050708143008.5"><vh>__str__</vh></v>
<v t="ekr.20050708144144.1"><vh>Unchanged</vh>
<v t="ekr.20050708143008.6"><vh>cwd_filt</vh></v>
<v t="ekr.20050708143008.7"><vh>cwd_filt2</vh></v>
</v>
<v t="ekr.20050708144144.2"><vh>auto_rewrite</vh></v>
</v>
<v t="ekr.20050708091220.76"><vh>class LeoShell</vh>
<v t="ekr.20050708091220.77"><vh>ctor</vh>
<v t="ekr.20050708110239"><vh>&lt;&lt; directory stuff &gt;&gt;</vh></v>
<v t="ekr.20050708105742"><vh>&lt;&lt; set sensible command line defaults for self.rc &gt;&gt;</vh></v>
<v t="ekr.20050708093114"><vh>&lt;&lt; define regexp's &gt;&gt;</vh></v>
<v t="ekr.20050708093224"><vh>&lt;&lt; define escape stuff &gt;&gt;</vh></v>
<v t="ekr.20050708093433"><vh>&lt;&lt; define namespaces &gt;&gt;</vh></v>
<v t="ekr.20050708094606.1"><vh>&lt;&lt; create alias table &gt;&gt;</vh></v>
<v t="ekr.20050708150223"><vh>&lt;&lt; define inpsector &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708105323.2"><vh>usage</vh></v>
<v t="ekr.20050708095104.1"><vh>log</vh></v>
<v t="ekr.20050708113006.2"><vh>system</vh></v>
<v t="ekr.20050708152111" a="M"><vh>_prefilter</vh>
<v t="ekr.20050708152111.1"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708152111.2"><vh>&lt;&lt; handle empty line &gt;&gt;</vh></v>
<v t="ekr.20050708152111.3"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708152111.4"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708152111.5"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708152111.6"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708152111.7"><vh>prefilter &amp; helpers</vh>
<v t="ekr.20050708152111.9" a="M"><vh>_prefilter</vh>
<v t="ekr.20050708152111.10"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708152111.12"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708152111.13"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708152111.14"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708152111.15"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708165401.1"><vh>handle_normal ( no longer used)</vh></v>
<v t="ekr.20050708152111.17"><vh>handle_alias (done)</vh></v>
<v t="ekr.20050708152111.18"><vh>handle_shell_escape (needs work)</vh></v>
<v t="ekr.20050708152111.19"><vh>handle_magic (done)</vh></v>
<v t="ekr.20050708152111.20"><vh>handle_auto (may need work)</vh></v>
<v t="ekr.20050708152111.21"><vh>handle_help (may need work) (and it's stupid anyway)</vh></v>
<v t="ekr.20050708152111.22"><vh>handle_emacs</vh></v>
<v t="ekr.20050708152111.23"><vh>safe_execfile (not used)</vh></v>
<v t="ekr.20050708152111.24"><vh>split_user_input</vh></v>
<v t="ekr.20050708152111.25"><vh>update_cache</vh></v>
</v>
</v>
<v t="ekr.20050708105323.3"><vh>ipmagic &amp; palias</vh></v>
<v t="ekr.20050708165531.1"><vh>esc_quotes</vh></v>
</v>
<v t="ekr.20050726101926"><vh>keyPressed</vh>
<v t="ekr.20050726101926.1"><vh>&lt;&lt; create the command &gt;&gt;</vh></v>
<v t="ekr.20050726101926.2"><vh>&lt;&lt; handle auto completion &gt;&gt;</vh></v>
<v t="ekr.20050726101926.3"><vh>&lt;&lt; handle auto-tabbing &gt;&gt;</vh></v>
</v>
<v t="ekr.20040918093738"><vh>Prototypes for Python-to-Tk indices</vh>
<v t="ekr.20040918093738.1"><vh>py2tkIndex</vh>
<v t="ekr.20040918093738.2"><vh>test</vh></v>
</v>
<v t="ekr.20040918093738.3"><vh>pyRowColToTkIndex</vh>
<v t="ekr.20040918093738.4"><vh>test</vh></v>
</v>
<v t="ekr.20050314104217"><vh>Develop g.convertPythonIndexToRowCol</vh>
<v t="ekr.20050314103747"><vh>g.convertPythonIndexToRowCol  &amp; tests</vh>
<v t="ekr.20050314103747.1"><vh>bruteForceConvertPythonIndexToRowCol</vh></v>
<v t="ekr.20050314103747.2"><vh>test_g_convertPythonIndexToRowCol</vh></v>
</v>
</v>
<v t="ekr.20050315072359"><vh>Develop g.convertRowColToPythonIndex</vh>
<v t="ekr.20050315072359.1"><vh>g.convertRowColToPythonIndex &amp; test</vh>
<v t="ekr.20050315072359.2"><vh>test_g_convertRowColToPythonIndex</vh></v>
</v>
</v>
</v>
<v t="ekr.20041126055818.2"><vh>pyclbr module (parses python)</vh></v>
<v t="ekr.20050715132524"><vh>Pymacs (hangs)</vh></v>
<v t="ekr.20050103092214"><vh>Python parser (abandoned)</vh>
<v t="ekr.20050103092214.5"><vh>class pythonParser</vh>
<v t="ekr.20050103092214.6"><vh>To be deleted</vh>
<v t="ekr.20050103092214.7"><vh>clear</vh></v>
<v t="ekr.20050103092214.8"><vh>endUndo</vh></v>
<v t="ekr.20050103092214.9"><vh>get</vh></v>
<v t="ekr.20050103092214.10"><vh>put</vh></v>
<v t="ekr.20050103092214.11"><vh>putArray</vh></v>
<v t="ekr.20050103092214.12"><vh>replaceBody</vh></v>
<v t="ekr.20050103092214.13"><vh>prettyPrintNode</vh></v>
<v t="ekr.20050103092214.14"><vh>putToken</vh></v>
<v t="ekr.20050103092214.18"><vh>dumpLines (not used)</vh></v>
</v>
<v t="ekr.20050103092214.15"><vh>__init__</vh>
<v t="ekr.20050103092214.16"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050103092214.17"><vh>parseNode(top level)</vh></v>
<v t="ekr.20050103092214.19"><vh>dumpToken</vh></v>
<v t="ekr.20050103092214.21"><vh>oops</vh></v>
<v t="ekr.20050103092214.22"><vh>trace</vh></v>
<v t="ekr.20050103092214.23"><vh>doToken &amp; allies</vh>
<v t="ekr.20050103095602"><vh>handleAtPart</vh></v>
<v t="ekr.20050103092214.24"><vh>doEndMarker</vh></v>
<v t="ekr.20050103092214.25"><vh>doErrorToken</vh></v>
<v t="ekr.20050103092214.26"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20050103092214.27"><vh>doMultiLine</vh></v>
<v t="ekr.20050103092214.28"><vh>doName</vh></v>
<v t="ekr.20050103092214.29"><vh>doNewline</vh></v>
<v t="ekr.20050103092214.30"><vh>doNumber</vh></v>
<v t="ekr.20050103092214.31"><vh>doOp</vh></v>
<v t="ekr.20050103092214.32"><vh>doStartLine</vh></v>
</v>
</v>
<v t="ekr.20050103092214.3"><vh>class dumper (pythonParser)</vh>
<v t="ekr.20050103092214.4"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20041220172118"><vh>Resolve CVS Conflicts command</vh>
<v t="ekr.20041220172118.1"><vh>Cvs markers &amp; file names</vh></v>
<v t="ekr.20041220172118.2"><vh>Conflicts not involving sentinels</vh></v>
<v t="ekr.20041220173231"><vh>Conflicts involving sentinels</vh></v>
<v t="ekr.20041220173748"><vh>Design notes</vh></v>
</v>
<v t="ekr.20041220080654"><vh>Setting Tk config values safely</vh>
<v t="ekr.20041220091350"><vh>&lt;&lt; documentation about how to set general options &gt;&gt;</vh></v>
</v>
<v t="ekr.20050618061950"><vh>Tests for new colorizer</vh>
<v t="ekr.20050601072505"><vh>Large coloring test</vh></v>
<v t="ekr.20050602213517"><vh>Doc part test</vh></v>
<v t="ekr.20050603134109"><vh>C language test</vh></v>
<v t="ekr.20050607084934"><vh>Plain test</vh></v>
<v t="ekr.20050608082208"><vh>Leading @sign tests</vh>
<v t="ekr.20050608081744" tnodeList="ekr.20050608081744"><vh>@file leadingAtTest.py</vh></v>
<v t="ekr.20050608081942"><vh>@thin leadingAtTest2.py</vh></v>
<v t="ekr.20050608082702" tnodeList="ekr.20050608082702"><vh>@file leadingAtTest3.py</vh></v>
<v t="ekr.20050608082702.1"><vh>@thin leadingAtTest4.py</vh></v>
</v>
</v>
<v t="ekr.20050427101736"><vh>Zip files experiments</vh>
<v t="ekr.20050427102426"><vh>@url http://docs.python.org/lib/module-zipfile.html</vh></v>
<v t="ekr.20050427101736.1"><vh>write zip</vh></v>
<v t="ekr.20050427101736.2"><vh>read zip</vh></v>
</v>
<v t="ekr.20050824190822"><vh>Zope test</vh></v>
</v>
<v t="ekr.20051103074730"><vh>Scripts</vh>
<v t="ekr.20040715105834"><vh>Fun...</vh>
<v t="EKR.20040626212434"><vh>Drawing experiments</vh>
<v t="EKR.20040626212434.1"><vh>Rectangles &amp; ovals</vh></v>
<v t="EKR.20040626212434.2"><vh>Lines &amp; arcs</vh></v>
<v t="EKR.20040626213007"><vh>Paul Klee</vh></v>
<v t="EKR.20040627150213"><vh>Complex functions</vh></v>
</v>
<v t="ekr.20040714055306"><vh>elispToPy</vh>
<v t="ekr.20050220091046.5"><vh>Old e2py Stuff</vh>
<v t="ekr.20050220091236"><vh>Old outer code</vh></v>
<v t="ekr.20040713150037"><vh>class tok</vh>
<v t="ekr.20040713150037.1"><vh>tok.__init__</vh></v>
<v t="ekr.20040714170021"><vh>tok.isParseTok</vh></v>
<v t="ekr.20040713150712"><vh>tok.copy</vh></v>
<v t="ekr.20040713173923"><vh>tok.match</vh></v>
<v t="ekr.20040713174349"><vh>tok.dump</vh></v>
<v t="ekr.20040713180208"><vh>tok.toString &amp; allies</vh>
<v t="ekr.20040713164604"><vh>tok.wsToString</vh></v>
</v>
</v>
<v t="ekr.20040715093804"><vh>Utility functions</vh>
<v t="ekr.20040715073230"><vh>isList &amp; isToken</vh></v>
<v t="ekr.20040715082059"><vh>printHeading</vh></v>
<v t="ekr.20040714095247"><vh>parseTreeToString</vh></v>
</v>
<v t="ekr.20040715080216"><vh>class lineClass</vh>
<v t="ekr.20040715080738"><vh>line.__init__</vh></v>
<v t="ekr.20040715081031"><vh>line.add</vh></v>
<v t="ekr.20040715080738.1"><vh>line.toString</vh></v>
</v>
<v t="ekr.20040713144036"><vh>class elisp2pyClass</vh>
<v t="ekr.20040713144036.1"><vh>e.__init__</vh>
<v t="ekr.20040714061625"><vh>&lt;&lt; define elisp constants &gt;&gt;</vh></v>
<v t="ekr.20040714061625.2"><vh>&lt;&lt; define elisp functions &gt;&gt;</vh></v>
<v t="ekr.20040714061625.1"><vh>&lt;&lt; define elisp statements &gt;&gt;</vh></v>
<v t="ekr.20040715090957"><vh>&lt;&lt; define code gen dispatch table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040713152809"><vh>Utils</vh>
<v t="ekr.20040713193437"><vh>deleteTokens</vh></v>
<v t="ekr.20040713161629.1"><vh>dump</vh></v>
<v t="ekr.20040713152318"><vh>error &amp; warning</vh></v>
<v t="ekr.20040713151556.1"><vh>findMatchingBracket</vh></v>
<v t="ekr.20040713160302"><vh>findTokens</vh></v>
<v t="ekr.20040714060941"><vh>isMatchingBracket</vh></v>
<v t="ekr.20040714053807.1"><vh>isStatement</vh></v>
<v t="ekr.20040714054620.1"><vh>matchTokens</vh></v>
<v t="ekr.20040713150314.1"><vh>replaceAll (not used yet)</vh></v>
<v t="ekr.20040713144926"><vh>tokenize &amp; allies</vh>
<v t="ekr.20040713154118"><vh>skipString</vh></v>
</v>
</v>
<v t="ekr.20040713211010"><vh>convert (main line)</vh></v>
<v t="ekr.20040714082939"><vh>Parser &amp; allies</vh>
<v t="ekr.20040714155341"><vh>parse</vh>
<v t="ekr.20040714154314"><vh>&lt;&lt; give error message about mismatched parens &gt;&gt;</vh></v>
</v>
<v t="ekr.20040714091940.1"><vh>block</vh></v>
</v>
<v t="ekr.20040714222507"><vh>Code gen</vh>
<v t="ekr.20040715081425"><vh>dumpCodeList</vh></v>
<v t="ekr.20040715075914"><vh>newCodeLine</vh></v>
<v t="ekr.20040714072448"><vh>removeBlankLines</vh></v>
</v>
<v t="ekr.20040715090957.2"><vh>gen_xxx</vh>
<v t="ekr.20040715071350"><vh>gen</vh></v>
<v t="ekr.20040715125453"><vh>gen_computed_function</vh></v>
<v t="ekr.20040715120001"><vh>gen_cond</vh></v>
<v t="ekr.20040715120001.1"><vh>gen_defconst</vh></v>
<v t="ekr.20040715120001.2"><vh>gen_defsubst</vh></v>
<v t="ekr.20040715093122"><vh>gen_defun</vh></v>
<v t="ekr.20040715120001.3"><vh>gen_defvar</vh></v>
<v t="ekr.20040715121456"><vh>gen_expression</vh></v>
<v t="ekr.20040715091409"><vh>gen_function</vh></v>
<v t="ekr.20040715120001.4"><vh>gen_if</vh></v>
<v t="ekr.20040715120001.5"><vh>gen_let, gen_let_star</vh></v>
<v t="ekr.20040715084435"><vh>gen_list</vh></v>
<v t="ekr.20040715120001.7"><vh>gen_prog, gen_prog1, gen_progn</vh></v>
<v t="ekr.20040715120001.8"><vh>gen_set &amp; gen_setq</vh></v>
<v t="ekr.20040715090957.1"><vh>gen_statement</vh></v>
<v t="ekr.20040715075845"><vh>gen_token</vh></v>
<v t="ekr.20040715120001.9"><vh>gen_unless, gen_when, gen_while</vh></v>
</v>
</v>
</v>
<v t="ekr.20050220085042.2"><vh>Data</vh>
<v t="ekr.20040713200238"><vh>Ref</vh>
<v t="ekr.20040713131315"><vh>To do</vh>
<v t="ekr.20040713133131"><vh>Tokens</vh></v>
<v t="ekr.20040713133131.1"><vh>Statements</vh></v>
<v t="ekr.20040713133131.2"><vh>Expressions</vh></v>
</v>
<v t="ekr.20040713130853"><vh>Docs</vh>
<v t="ekr.20040713130853.1"><vh>What elisp2py does</vh></v>
<v t="ekr.20040713130853.2"><vh>Theory of operation</vh></v>
<v t="ekr.20040713130853.3"><vh>&lt;&lt; specify user types &gt;&gt;</vh></v>
<v t="ekr.20040713130853.4"><vh>&lt;&lt; define testData &gt;&gt;</vh></v>
</v>
<v t="ekr.20040713144336"><vh>from c2py</vh>
<v t="ekr.20040713130853.15"><vh>Top-level scripts</vh>
<v t="ekr.20040713130853.16"><vh>convertCurrentTree</vh></v>
<v t="ekr.20040713130853.17"><vh>convertLeoTree</vh></v>
<v t="ekr.20040713130853.18"><vh>convertCFileToPython</vh></v>
<v t="ekr.20040713130853.7"><vh>speedTest</vh></v>
</v>
<v t="ekr.20040713130853.19"><vh>Top Level</vh>
<v t="ekr.20040713130853.20"><vh>convertCStringToPython</vh></v>
<v t="ekr.20040713130853.21"><vh>OLDconvertCodeList</vh></v>
<v t="ekr.20040713130853.22"><vh>convertDocList</vh></v>
<v t="ekr.20040713130853.23"><vh>skipDocPart</vh></v>
<v t="ekr.20040713130853.24"><vh>skipCodePart</vh></v>
</v>
<v t="ekr.20040713144926.1"><vh>Utils</vh>
<v t="ekr.20040713130853.61"><vh>safeReplace</vh></v>
<v t="ekr.20040713130853.43"><vh>match</vh></v>
<v t="ekr.20040713130853.44"><vh>matchWord</vh></v>
</v>
<v t="ekr.20040713130853.27"><vh>convertLeadingBlanks</vh></v>
<v t="ekr.20040713130853.28"><vh>findInList</vh></v>
<v t="ekr.20040713130853.29"><vh>findInCode</vh></v>
<v t="ekr.20040713130853.30"><vh>mungeAllFunctions</vh>
<v t="ekr.20040713130853.31"><vh>handlePossibleFunctionHeader</vh></v>
<v t="ekr.20040713130853.32"><vh>massageFunctionArgs</vh></v>
<v t="ekr.20040713130853.33"><vh>massageFunctionHead (sets gClassName)</vh></v>
<v t="ekr.20040713130853.34"><vh>massageFunctionBody</vh>
<v t="ekr.20040713130853.35"><vh>massageIvars</vh></v>
<v t="ekr.20040713130853.36"><vh>removeCasts</vh></v>
<v t="ekr.20040713130853.37"><vh>removeTypeNames</vh></v>
</v>
</v>
<v t="ekr.20040713130853.38"><vh>handleAllKeywords</vh>
<v t="ekr.20040713130853.39"><vh>handleKeyword</vh></v>
</v>
<v t="ekr.20040713130853.40"><vh>isWs and isWOrNl</vh></v>
<v t="ekr.20040713130853.41"><vh>isSectionDef</vh></v>
<v t="ekr.20040713130853.42"><vh>isStringOrComment</vh></v>
<v t="ekr.20040713130853.45"><vh>prevNonWsChar and prevNonWsOrNlChar</vh></v>
<v t="ekr.20040713144926.2"><vh>remove</vh>
<v t="ekr.20040713130853.46"><vh>removeAllCComments</vh></v>
<v t="ekr.20040713130853.47"><vh>removeAllCSentinels</vh></v>
<v t="ekr.20040713130853.48"><vh>removeAllPythonComments</vh></v>
<v t="ekr.20040713130853.49"><vh>removeAllPythonSentinels</vh></v>
<v t="ekr.20040713130853.50"><vh>removeAtRoot</vh></v>
<v t="ekr.20040713130853.51"><vh>removeBlankLines</vh></v>
<v t="ekr.20040713130853.52"><vh>removeExcessWs</vh>
<v t="ekr.20040713130853.53"><vh>removeExessWsFromLine</vh></v>
</v>
<v t="ekr.20040713130853.54"><vh>removeLeadingAtCode</vh></v>
<v t="ekr.20040713130853.55"><vh>removeMatchingBrackets</vh></v>
<v t="ekr.20040713130853.56"><vh>removeSemicolonsAtEndOfLines</vh></v>
<v t="ekr.20040713130853.57"><vh>removeTrailingWs</vh></v>
</v>
<v t="ekr.20040713144926.3"><vh>replace...</vh>
<v t="ekr.20040713130853.58"><vh>replace</vh></v>
<v t="ekr.20040713130853.59"><vh>replaceComments</vh></v>
<v t="ekr.20040713130853.60"><vh>replaceSectionDefs</vh></v>
</v>
<v t="ekr.20040713144926.4"><vh>skip...</vh>
<v t="ekr.20040713130853.62"><vh>skipCBlockComment</vh></v>
<v t="ekr.20040713130853.63"><vh>skipPastLine</vh></v>
<v t="ekr.20040713130853.64"><vh>skipPastWord</vh></v>
<v t="ekr.20040713130853.65"><vh>skipString</vh></v>
<v t="ekr.20040713130853.66"><vh>skipStringOrComment</vh></v>
<v t="ekr.20040713130853.68"><vh>skipWs and skipWsAndNl</vh></v>
</v>
</v>
<v t="ekr.20040713150856.1"><vh>g.scanning...</vh>
<v t="ekr.20040713150856.8"><vh>Scanners: calling scanError</vh>
<v t="ekr.20040713150856.9"><vh>skip_block_comment</vh></v>
<v t="ekr.20040713150856.10"><vh>skip_braces</vh></v>
<v t="ekr.20040713150856.12"><vh>skip_parens</vh></v>
<v t="ekr.20040713150856.13"><vh>skip_pascal_begin_end</vh></v>
<v t="ekr.20040713150856.14"><vh>skip_pascal_block_comment</vh></v>
<v t="ekr.20040713150856.15"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="ekr.20040713150856.20"><vh>skip_python_string</vh></v>
<v t="ekr.20040713150856.21"><vh>skip_string : called by tangle</vh></v>
<v t="ekr.20040713150856.22"><vh>skip_to_semicolon</vh></v>
</v>
<v t="ekr.20040713150856.24"><vh>Scanners: no error messages</vh>
<v t="ekr.20040713150856.25"><vh>escaped</vh></v>
<v t="ekr.20040713150856.26"><vh>find_line_start</vh></v>
<v t="ekr.20040713150856.27"><vh>find_on_line</vh></v>
<v t="ekr.20040713150856.28"><vh>is_c_id</vh></v>
<v t="ekr.20040713150856.29"><vh>is_nl</vh></v>
<v t="ekr.20040713150856.30"><vh>is_special</vh></v>
<v t="ekr.20040713150856.31"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="ekr.20040713150856.32"><vh>match</vh></v>
<v t="ekr.20040713150856.33"><vh>match_c_word</vh></v>
<v t="ekr.20040713150856.34"><vh>match_ignoring_case</vh></v>
<v t="ekr.20040713150856.35"><vh>match_word</vh></v>
<v t="ekr.20040713150856.36"><vh>skip_blank_lines</vh></v>
<v t="ekr.20040713150856.37"><vh>skip_c_id</vh></v>
<v t="ekr.20040713150856.38"><vh>skip_id</vh></v>
<v t="ekr.20040713150856.39"><vh>skip_line, skip_to_end_of_line</vh></v>
<v t="ekr.20040713150856.40"><vh>skip_long</vh></v>
<v t="ekr.20040713150856.41"><vh>skip_matching_delims</vh></v>
<v t="ekr.20040713150856.42"><vh>skip_nl</vh></v>
<v t="ekr.20040713150856.43"><vh>skip_non_ws</vh></v>
<v t="ekr.20040713150856.44"><vh>skip_pascal_braces</vh></v>
<v t="ekr.20040713150856.45"><vh>skip_to_char</vh></v>
<v t="ekr.20040713150856.46"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="ekr.20040713150856.47"><vh>splitLines &amp; joinLines</vh></v>
</v>
<v t="ekr.20040713205718"><vh>createIndentedBlock NOT USED</vh>
<v t="ekr.20040714074445"><vh>&lt;&lt; insert nl and ws tokens &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040713131350"><vh>-elisp2py-input-</vh>
<v t="ekr.20040715071555"><vh>igrep-read-file-name</vh></v>
</v>
<v t="ekr.20050220091046.4"><vh>-elisp2py-output-</vh></v>
<v t="ekr.20040713132127.1"><vh>igrep.el</vh>
<v t="ekr.20040713132127.2"><vh>provide</vh></v>
<v t="ekr.20040713132127.3"><vh>const igrep-version</vh></v>
<v t="ekr.20040713132127.4"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.5"><vh>var igrep-options</vh></v>
<v t="ekr.20040713132127.6"><vh>put</vh></v>
<v t="ekr.20040713132127.7"><vh>var igrep-read-options</vh></v>
<v t="ekr.20040713132127.8"><vh>put</vh></v>
<v t="ekr.20040713132127.9"><vh>var igrep-read-multiple-files</vh></v>
<v t="ekr.20040713132127.10"><vh>put</vh></v>
<v t="ekr.20040713132127.11"><vh>var igrep-expression-default</vh></v>
<v t="ekr.20040713132127.12"><vh>put</vh></v>
<v t="ekr.20040713132127.13"><vh>var igrep-files-default</vh></v>
<v t="ekr.20040713132127.14"><vh>put</vh></v>
<v t="ekr.20040713132127.15"><vh>var igrep-verbose-prompts</vh></v>
<v t="ekr.20040713132127.16"><vh>put</vh></v>
<v t="ekr.20040713132127.17"><vh>var igrep-insert-default-key</vh></v>
<v t="ekr.20040713132127.18"><vh>put</vh></v>
<v t="ekr.20040713132127.19"><vh>var igrep-save-buffers</vh></v>
<v t="ekr.20040713132127.20"><vh>put</vh></v>
<v t="ekr.20040713132127.21"><vh>var igrep-null-device</vh></v>
<v t="ekr.20040713132127.22"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.23"><vh>var igrep-program</vh></v>
<v t="ekr.20040713132127.24"><vh>var igrep-expression-option</vh></v>
<v t="ekr.20040713132127.25"><vh>var igrep-program-table</vh></v>
<v t="ekr.20040713132127.26"><vh>var igrep-use-zgrep</vh></v>
<v t="ekr.20040713132127.27"><vh>var igrep-find</vh></v>
<v t="ekr.20040713132127.28"><vh>var igrep-find-program</vh></v>
<v t="ekr.20040713132127.29"><vh>var igrep-find-prune-clause</vh></v>
<v t="ekr.20040713132127.30"><vh>var igrep-find-file-clause</vh></v>
<v t="ekr.20040713132127.31"><vh>var igrep-find-use-xargs</vh></v>
<v t="ekr.20040713132127.32"><vh>var igrep-program-default</vh></v>
<v t="ekr.20040713132127.33"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.34"><vh>var igrep-expression-history</vh></v>
<v t="ekr.20040713132127.35"><vh>var igrep-files-history</vh></v>
<v t="ekr.20040713132127.36"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.37"><vh>igrep-insinuate</vh></v>
<v t="ekr.20040713132127.38"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.39"><vh>igrep</vh></v>
<v t="ekr.20040713132127.40"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.41"><vh>igrep-find</vh></v>
<v t="ekr.20040713132127.42"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.43"><vh>igrep-visited-files</vh></v>
<v t="ekr.20040713132127.44"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.45"><vh>dired-do-igrep</vh></v>
<v t="ekr.20040713132127.46"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.47"><vh>dired-do-igrep-find</vh></v>
<v t="ekr.20040713132127.48"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.49"><vh>Buffer-menu-igrep</vh></v>
<v t="ekr.20040713132127.50"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.51"><vh>igrep-dired-file-current-word</vh></v>
<v t="ekr.20040713132127.52"><vh>igrep-buffer-file-name-pattern</vh></v>
<v t="ekr.20040713132127.53"><vh>igrep-dired-directory-file-pattern</vh></v>
<v t="ekr.20040713132127.54"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.55"><vh>igrep-format-find-command</vh></v>
<v t="ekr.20040713132127.56"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.57"><vh>igrep-default-expression</vh></v>
<v t="ekr.20040713132127.58"><vh>igrep-default-files</vh></v>
<v t="ekr.20040713132127.59"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.60"><vh>igrep-read-args</vh></v>
<v t="ekr.20040713132127.61"><vh>igrep-read-program</vh></v>
<v t="ekr.20040713132127.62"><vh>igrep-read-options</vh></v>
<v t="ekr.20040713132127.63"><vh>igrep-read-expression</vh></v>
<v t="ekr.20040713132127.64"><vh>igrep-insert-default-expression</vh></v>
<v t="ekr.20040713132127.65"><vh>igrep-insert-default-files</vh></v>
<v t="ekr.20040713132127.66"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.67"><vh>igrep-read-files</vh></v>
<v t="ekr.20040713132127.68"><vh>igrep-read-file-name</vh></v>
<v t="ekr.20040713132127.69"><vh>unnamed data</vh></v>
</v>
</v>
<v t="ekr.20040713123617.1"><vh>e2pyScript</vh>
<v t="ekr.20050220085042.1"><vh>run</vh></v>
<v t="ekr.20050220091046"><vh>class e2py</vh>
<v t="ekr.20050220091046.1"><vh>ctor</vh></v>
<v t="ekr.20050220111049"><vh>doBlock</vh></v>
<v t="ekr.20050220091046.3"><vh>doParenBlock</vh></v>
<v t="ekr.20050220105058"><vh>doDef</vh></v>
<v t="ekr.20050220124658"><vh>doDoubleParen</vh></v>
<v t="ekr.20050220111114"><vh>doId</vh></v>
<v t="ekr.20050220105058.1"><vh>doIf</vh></v>
<v t="ekr.20050220105058.2"><vh>doLet</vh></v>
<v t="ekr.20050220091046.2"><vh>doOuterBlock</vh></v>
<v t="ekr.20050220105058.3"><vh>doProg</vh></v>
<v t="ekr.20050220111923"><vh>dump</vh></v>
<v t="ekr.20050220092732"><vh>findMatchingBracket</vh></v>
<v t="ekr.20050220114616"><vh>getToken</vh></v>
<v t="ekr.20050220105726"><vh>indent</vh></v>
<v t="ekr.20050220093752"><vh>matchingBracket</vh></v>
<v t="ekr.20050220103808"><vh>skip_id</vh></v>
<v t="ekr.20050220105058.4"><vh>skipString</vh></v>
<v t="ekr.20050220122447"><vh>removeBlankLines</vh></v>
<v t="ekr.20050220100049"><vh>stripLws</vh></v>
</v>
</v>
</v>
<v t="ekr.20050803075926"><vh>sudoku puzzle</vh>
<v t="ekr.20050804073824"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
<v t="ekr.20050911123109"><vh>&lt;&lt; 5-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050911145104"><vh>&lt;&lt; 4-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050811075608"><vh>&lt;&lt; 3-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050929065040"><vh>&lt;&lt; 2-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050927122648"><vh>&lt;&lt; 1-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050803075926.1"><vh>class sudokuClass</vh>
<v t="ekr.20050803075926.2"><vh> ctor (main) &amp; helpers</vh>
<v t="ekr.20050803202932"><vh>initFromData</vh></v>
<v t="ekr.20050803075926.4"><vh>finishInit</vh></v>
<v t="ekr.20050803121102"><vh>checkData</vh></v>
<v t="ekr.20050804070733"><vh>check &amp; helper</vh>
<v t="ekr.20050804071049"><vh>checkGroup</vh></v>
</v>
</v>
<v t="ekr.20050804071242"><vh>printing &amp; dumping</vh>
<v t="ekr.20050803080858"><vh>dump</vh></v>
<v t="ekr.20050803121730"><vh>printData</vh></v>
<v t="ekr.20050803200132"><vh>printCells</vh></v>
</v>
<v t="ekr.20050911112043.1"><vh>Utils</vh>
<v t="ekr.20050803095202"><vh>groupNumber</vh></v>
<v t="ekr.20050803075926.3"><vh>error</vh></v>
<v t="ekr.20050803215553"><vh>trace</vh></v>
<v t="ekr.20050803202932.1"><vh>isFinished</vh></v>
</v>
<v t="ekr.20050911094859"><vh>Guesses</vh>
<v t="ekr.20050803203001"><vh>findBestGroup</vh></v>
<v t="ekr.20050803210939"><vh>findGuesses</vh></v>
<v t="ekr.20050804060706"><vh>isValidGuess</vh></v>
</v>
<v t="ekr.20050803075926.5"><vh>solve (main)</vh>
<v t="ekr.20050911085945"><vh>&lt;&lt; guess an answer &gt;&gt;</vh></v>
</v>
<v t="ekr.20050911135016"><vh>group classes</vh>
<v t="ekr.20050911101819"><vh>class squareGroupClass</vh>
<v t="ekr.20050803121102.2"><vh> ctor</vh></v>
<v t="ekr.20050911101819.1"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050803130829"><vh>finishCreate</vh></v>
<v t="ekr.20050803161504"><vh>computeRelatedGroups</vh></v>
</v>
<v t="ekr.20050910194752"><vh>class colGroupClass</vh>
<v t="ekr.20050910194752.1"><vh>ctor</vh></v>
<v t="ekr.20050911102800"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050910195107"><vh>finishCreate</vh></v>
</v>
<v t="ekr.20050910194752.2"><vh>class rowGroupClass</vh>
<v t="ekr.20050910194752.3"><vh>ctor</vh></v>
<v t="ekr.20050911102800.1"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050910195107.1"><vh>finishCreate</vh></v>
</v>
</v>
<v t="ekr.20050803075926.7"><vh>class cellClass</vh>
<v t="ekr.20050911144450"><vh> birth</vh>
<v t="ekr.20050803081438"><vh> ctor (cell)</vh></v>
<v t="ekr.20050803200724"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050911113403"><vh>finishCreate</vh></v>
</v>
<v t="ekr.20050911112043.2"><vh>error &amp; trace</vh></v>
<v t="ekr.20050911092707"><vh>reduce</vh></v>
<v t="ekr.20050911111404"><vh>removeConflicts</vh></v>
<v t="ekr.20050911094544"><vh>setValue</vh></v>
<v t="ekr.20050911092707.1"><vh>unique</vh></v>
<v t="ekr.20050803134436.1"><vh>valIsPossible</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20051104082026"><vh>Important</vh>
<v t="ekr.20040721153143" annotate="7d71002e"><vh>Gc/Profile/Timeit/Tracing scripts</vh>
<v t="ekr.20040721113934"><vh>runProfile</vh></v>
<v t="ekr.20040901065642.2"><vh>runTimeit</vh>
<v t="ekr.20040901072339"><vh>&lt;&lt; scan for #@count &gt;&gt;</vh></v>
<v t="ekr.20040901071028"><vh>&lt;&lt; put setup code in s1 and everything else in s2 &gt;&gt;</vh></v>
</v>
<v t="ekr.20040721145258.1"><vh>Run gc</vh></v>
<v t="ekr.20040804052804"><vh>Set tracing</vh></v>
<v t="ekr.20040901065642"><vh>test of new timit script</vh></v>
</v>
<v t="ekr.20040318091620"><vh>Clear all uAs (unknown attributes)</vh></v>
<v t="ekr.20040915080419"><vh>Print all uAs (unknown attributes)</vh></v>
<v t="ekr.20050108110751"><vh>HTMLize scripts</vh>
<v t="ekr.20041229163210"><vh>dyna htmlize</vh>
<v t="ekr.20041229164609"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20041229163210.2"><vh>&lt;&lt; init globals &gt;&gt;</vh></v>
<v t="ekr.20041229170824"><vh>stripSentinels</vh></v>
<v t="ekr.20041229165956"><vh>sanitize</vh></v>
<v t="ekr.20041229163210.3"><vh>class Parser</vh>
<v t="ekr.20041229163210.4"><vh>__init__</vh></v>
<v t="ekr.20041229163210.5"><vh>format</vh></v>
<v t="ekr.20041229163210.6"><vh>__call__</vh></v>
</v>
<v t="ekr.20041229164609.2"><vh>htmlize</vh>
<v t="ekr.20041229163210.7"><vh>&lt;&lt; colorize with silvercity &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041228135008"><vh>HTML to Browser</vh>
<v t="ekr.20041228140714"><vh>&lt;&lt; alternate code doesn't work well for me &gt;&gt;</vh></v>
</v>
<v t="ekr.20050108110751.1"><vh>Code from Bill P</vh>
<v t="ekr.20050108110751.2"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="ekr.20040723065021"><vh>stripBlankLines</vh>
<v t="ekr.20040723065047"><vh>Test</vh></v>
</v>
<v t="ekr.20050219075759"><vh>Scripts demonstrating how to do anything with Leo menus</vh>
<v t="ekr.20050219071503"><vh>Test of createMenuItemsFromTable</vh></v>
<v t="ekr.20050219073752.1"><vh>Add a menu item after Open With</vh></v>
</v>
<v t="ekr.20041126035448"><vh>Script to import a file</vh></v>
<v t="ekr.20040312021734.1"><vh>Script to clean unused tnodeLists</vh></v>
<v t="ekr.20051103072643"><vh>Export to treepad</vh></v>
<v t="ekr.20051025070722.1"><vh>Runniung tcl scripts from the body pane</vh>
<v t="ekr.20051024223801"><vh>run tcl </vh></v>
<v t="ekr.20051024223801.1"><vh>My first tcl script</vh></v>
<v t="ekr.20051025115413"><vh>My second tcl scrip, organized with noweb markup</vh>
<v t="ekr.20051025115413.1"><vh>the actual script</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104082151"><vh>Reports</vh>
<v t="EKR.20040517074600.8"><vh>Count pages</vh></v>
<v t="ekr.20040311090054"><vh>Dump fileIndex</vh></v>
<v t="ekr.20050704172623"><vh>Print all headlines, properly indented</vh></v>
<v t="ekr.20041124144944"><vh>Print sys.path</vh></v>
<v t="ekr.20041019080125"><vh>Report loaded plugins</vh></v>
<v t="EKR.20040613162717"><vh>Report newlines</vh></v>
<v t="ekr.20040322120331"><vh>Print tnodeList's</vh></v>
</v>
<v t="ekr.20051104082103"><vh>Tests</vh>
<v t="ekr.20040706071823"><vh>test of Python's parser module</vh></v>
<v t="ekr.20040804104924"><vh>Test of p.__hash__</vh>
<v t="ekr.20040804105026"><vh>a</vh>
<v t="ekr.20040804104328"><vh>Script</vh></v>
<v t="ekr.20040804104328"><vh>Script</vh></v>
</v>
<v t="ekr.20040804105026"><vh>a</vh>
<v t="ekr.20040804104328"><vh>Script</vh></v>
<v t="ekr.20040804104328"><vh>Script</vh></v>
</v>
</v>
<v t="ekr.20050801070538"><vh>PrettyPrintTest</vh></v>
<v t="ekr.20050801075332"><vh>PrettyPrintTest (copy)</vh></v>
</v>
<v t="ekr.20051104082605" a="E"><vh>Others</vh>
<v t="EKR.20040424065452"><vh>Compare files</vh></v>
<v t="EKR.20040424091411"><vh>Compare ignoring newlines</vh></v>
<v t="ekr.20040319111213" a="E"><vh>FilterHoist script</vh>
<v t="ekr.20040319111213.1"><vh>description</vh></v>
<v t="ekr.20040319142708"><vh>filter</vh></v>
<v t="ekr.20040319142202" a="E"><vh>old code</vh>
<v t="ekr.20040319111213.2"><vh>filter</vh></v>
<v t="ekr.20040319111213.3"><vh>search</vh></v>
</v>
<v t="ekr.20040319111213.4"><vh>filterHoist</vh></v>
<v t="ekr.20040319111213.5"><vh>addMenu</vh></v>
</v>
<v t="ekr.20040330095252"><vh>script to clear log frame</vh></v>
<v t="EKR.20040517074600.9"><vh>Scripts to debug font problem</vh>
<v t="EKR.20040517074600.10"><vh>Show font</vh></v>
<v t="EKR.20040517074600.11"><vh>Show settings</vh>
<v t="EKR.20040517074600.12"><vh>getFontSettings</vh></v>
</v>
<v t="EKR.20040517074600.13"><vh>Print default font</vh></v>
</v>
<v t="ekr.20040717121014"><vh>tellGnxScript</vh></v>
<v t="ekr.20041013101029"><vh>headfind</vh>
<v t="ekr.20041013101029.1"><vh>&lt;&lt; about this script &gt;&gt;</vh></v>
</v>
<v t="ekr.20050210180034"><vh>jython script</vh></v>
<v t="ekr.20050219054039"><vh>Scripts to convert ChoiceMail .ini file to .csv file</vh>
<v t="ekr.20050218174326.1"><vh>Scipt to remove rejected entries</vh>
<v t="ekr.20050218170806.1"><vh>@killcolor</vh>
<v t="ekr.20050218170806.2"><vh>address</vh></v>
</v>
</v>
<v t="ekr.20050218170806"><vh>Script to clean address</vh>
<v t="ekr.20050219054351"><vh>@killcolor</vh>
<v t="ekr.20050219054351.1"><vh>address</vh></v>
</v>
</v>
<v t="ekr.20050218184044.10"><vh>Script to create comma delimited lists</vh>
<v t="ekr.20050219054039.1"><vh>address</vh></v>
<v t="ekr.20050218184044.11"><vh>result</vh></v>
</v>
</v>
<v t="ekr.20050310082013"><vh>AutoIt script from e</vh></v>
<v t="ekr.20050225161940" annotate="7d71002e"><vh>Script to execute @test, @suite or file</vh>
<v t="ekr.20050225161940.1" annotate="7d71002e"><vh>@test __name__</vh></v>
<v t="ekr.20050225162123" annotate="55ea37643731303032383535303837303732363936663732363937343739373130313238363336333663363536663061353436623530363936333662366336353536363137323061373130323666373130333464306632373632353530343665366636343635373130353238363830323666373130363535303037313037363235353032363236373731303832383638303236663731303936383037363235353039363137323633363836353734373937303635373130613238363830323666373130623638303736323535303236363637373130633238363830323666373130643638303736323735326571002e"><vh>@@thin executeFileTest.py</vh></v>
<v t="ekr.20050225161940.2" annotate="7d71002e"><vh>Exec File</vh>
<v t="ekr.20050225161940.3" annotate="7d71002e"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050225171553" annotate="7d71002e"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050225161940.5" annotate="7d71002e"><vh>getAtFileName</vh></v>
<v t="ekr.20050225161940.6" annotate="7d71002e"><vh>doatest</vh></v>
</v>
</v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040424065452">p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
lines1 = f1.readlines()
lines2 = f2.readlines()
f1.close() ; f2.close()

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
text1 = f1.read()
text2 = f2.read()
f1.close() ; f2.close()

cr1 = text1.count('\r')
cr2 = text2.count('\r')

print '-'*20
print "lines ",len(lines1),len(lines2)
print "chars ",len(text1),len(text2)
print "non-cr",len(text1)-cr1,len(text2)-cr2
print "cr    ",cr1,cr2</t>
<t tx="EKR.20040424091411">p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
g.es("equal (raw mode)",f1.read()==f2.read())
f1.close() ; f2.close()

f1 = open(p1) ; f2 = open(p2)
g.es("equal (text mode)",f1.read()==f2.read())
f1.close() ; f2.close()</t>
<t tx="EKR.20040517074600.8">nodes = 0 ; lines = 0

c.clearAllVisited()
for p in c.allNodes_iter():
    if not p.v.t.isVisited():
        p.v.t.setVisited()
        nodes += 1
        lines += len(g.splitLines(p.bodyString()))
    
pages = ((nodes * 10) + lines) / 50
s = "%d nodes,  %d lines, %d pages" % (nodes,lines,pages)
print s ; g.es(s)</t>
<t tx="EKR.20040517074600.9"></t>
<t tx="EKR.20040517074600.10">config = g.app.config
body = c.frame.body.bodyCtrl

font = config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        tag = "body")
        
print font
print body

# body.configure(font=font)</t>
<t tx="EKR.20040517074600.11">import tkFont

@others

# Body pane.
fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
print "body:",fn,name,size,slant,weight

if 0:

    # Log pane.
    fn = c.frame.log.getFontConfig()
    font = tkFont.Font(font=fn)
    name,size,slant,weight = getFontSettings(font)
    g.es("log:" + name + "," + `size` + "," + slant + "," + weight)
    
    # Tree pane.
    font = c.frame.tree.getFont()
    name,size,slant,weight = getFontSettings(font)
    g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="EKR.20040517074600.12">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="EKR.20040517074600.13">font = g.app.config.defaultFont

print font.cget("family"), font.cget("weight")</t>
<t tx="EKR.20040613162717">path = g.os_path_join(g.app.loadDir,"leo.py")

try:
    f = open(path,"rb")
    s = f.read()
    f.close()
    
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
        
    m = "cr %d, nl %d %s" % (cr,nl,path)
    print m ; g.es(m)

except IOError:
    print "can not open",path</t>
<t tx="EKR.20040626212434"></t>
<t tx="EKR.20040626212434.1">import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

mincolor,maxcolor=125,225

for n in xrange(5000):
    x,y = rand(0,900),rand(0,500)
    w = rand(1,10) ; h = w * r.uniform(0.5,1.5)
    color = "#%02x%02x%02x" % (rand(0,maxcolor/2),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    kind = rand(1,3)
    sign = rand(-1,1) # rand(0,2)-1
    if kind == 1:
        canvas.create_rectangle(x,y,x+w,y+h,fill=color,width=0)
    elif kind == 2:
        canvas.create_oval(x,y,x+w,y+h,fill=color,width=0)
    else:
        canvas.create_line(x,y,x+sign*5*w,y+5*h,fill=color)
    if 0: # Redrawing slows things down a lot.
        if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626212434.2">import Tkinter as Tk
import random as r

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top, height = "5i", width = "9i")
canvas.pack() ; top.update()
rand = r.randint

x,y = 10,10
mincolor,maxcolor=125,225

for n in xrange(2000):
    x2,y2 = rand(0,900),rand(0,500)
    color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    width = "%fm" % r.uniform(0.1,0.6)
    canvas.create_line(x,y,x2,y2,fill=color,width=width)
    extent = rand(180,270)
    canvas.create_arc(x,y,x2,y2,outline=color,width=width,style="arc",extent=extent)
    x,y = x2,y2
    # if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626213007">import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Paul Klee")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

# Paul Klee
mincolor,maxcolor=125,225
xmax,ymax = 800,400
stipples = [None,"gray75"] # "gray12","gray25","gray50",]
h=w=90
for x in xrange(10,xmax,w):
    for y in xrange(10,ymax,h):
        color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
        range = h/6
        stipple = stipples[rand(0,len(stipples)-1)]
        dx = r.uniform(0.0,range) - range/2
        dy = r.uniform(0.0,range) - range/2
        canvas.create_rectangle(x+dx,y+dy,x+dx+w,y+dy+h,fill=color,width=0,stipple=stipple)</t>
<t tx="EKR.20040627150213">import Tkinter as Tk
import random as r ; rand = r.randint

mincolor,maxcolor=125,225
xmax,ymax = 300,300
h=w=1
i = r.uniform(2.0,4.0)
j = r.uniform(-5.0,5.0)
power = r.uniform(1.1,1.2)
    #(1.5,1.7)

top = Tk.Toplevel(None)
top.title("Complex function: (%f,%f)*(x,y)**%f" % (i,j,power))
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

@others

for n in xrange(1):
    i += 0.5
    j += 0.5
    power += 0.01
    # print "i,j,power:",i,j,power
    c = complex(i,j)
    for format,m in (
        #("#%02x%02x%02x",256),
        #("#%03x%03x%03x",256*8),
        ("#%04x%04x%04x",256*256),
    ):
        for x in xrange(0,xmax,1):
            for y in xrange(0,ymax,1):
                n = complex(x,y)
                z = pow(c*n,power)
                n1 = int(z.real*m) ; n2 = int(z.imag*m)
                color = format % (n1%m,n2%m,abs(n1-n2)%m)
                # canvas.create_rectangle(w*x,h*y,w*x+w,h*y+h,fill=color,width=0)
                canvas.create_line(x,y,x+1,y+1,fill=color,width=1)
        top.update()
print "done"</t>
<t tx="ekr.20040311090054">for p in c.allNodes_iter():
    print p.v.t.fileIndex</t>
<t tx="ekr.20040312021734.1">count = 0
for p in c.rootPosition().allNodes_iter():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20040318091620">for p in c.allNodes_iter():
    if hasattr(p.v.t,"unknownAttributes"):
        print "deleting unknownAttributes:",p
        delattr(p.v.t,"unknownAttributes")
            
c.redraw()
</t>
<t tx="ekr.20040319111213">from leoPlugins import *
from leoGlobals import *
from leoNodes import *
import Tkinter
import re
import sys

@others

fhp = None
fhp_entry = None
    
if 1:
    addMenu("none",None)
else:
    hooks = choose(sys.platform == 'win32',
        ('open2',"new"),
        ('start2','open2',"new"))
        
    print "hi"
        
    registerHandler(hooks,addMenu)

    __version__ = ".1"
    plugin_signon(__name__)
</t>
<t tx="ekr.20040319111213.1">@nocolor

@ This is what it does:

1. Under Outline it puts an Option called 'FilterHoist'
2. Selecting the option pops up an ugly little window.  On it is a section where
you can type in text.  You can close the window with the close button.  You
can activate the functionality with the Filter Button.
3. Filtering will walk the Leo tree, looking for a text match from the Text
field with the Nodes bodyString.
4. After finding some nodes it creates a new node at the root.  Then it clones
the matching nodes under that new node.  A Hoist operation is performed on the
new node.  This gives a view of all matching nodes.

I put this together because I wanted a find that was based in terms of Leo's
nodes.  Find as it is bounces you around the Tree(it bothers me).  This brings
the nodes to you and presents them.  As it is I may work further on this if
people like the idea.  It's possible I might migrate it to the NodeRoundup plugin
to.

You need 2.3 python; it uses generators in it's find method.

That was one motivation for writing this thing, using a generator vs. Recursive
approach to tree walking.</t>
<t tx="ekr.20040319111213.2">def OLDfilter(c,e):

    v = c.rootVnode()
    
    nodes = []
    while v:
        nodes.append(v)
        v = v.next()
    
    regex = re.compile(e.get())
    c.beginUpdate()
    try: # update...
        t = tnode('','A Filtered Hoist')
        ticker = c.rootVnode().insertAfter(t)
        for z in nodes:
            for x in search(z,regex):
                clone = x.clone( x )
                clone.moveToNthChildOf(ticker,0)
        c.setCurrentVnode(ticker)
        ticker.moveToRoot(c.rootVnode())
    finally:
        c.endUpdate()
    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040319111213.3">from __future__ import generators # To make the code work in Python 2.2.

def OLDsearch(vn,regex):

    sn = vn 
    while vn != None:
        if regex.search( vn.t.bodyString ) : yield vn
        nc = vn.numberOfChildren()
        if nc == 0:
            i = vn.childIndex()
            p = vn.parent()
            if p == None: 
                vn = None
                continue
            if i == 0:
                while 1:
                    if p == sn :
                        vn = None
                        break
                    vn = p.back() 
                    if vn == None:
                        p = p.parent()
                        continue
                    break
                continue                                                        
            vn = p.nthChild( i - 1)
            continue
        vn = vn.nthChild( nc - 1 )
</t>
<t tx="ekr.20040319111213.4">def filterHoist(c):

    global fhp
    global e
    
    if fhp is None:

        fhp = Tkinter.Toplevel()
        fhp.title('FilterHoist')

        fhp_entry = e = Tkinter.Entry(fhp)
        e.pack(side="top",fill="both")

        def closeCallback(fhp=fhp):
            fhp.withdraw()
            
        def filterCallback(c=c,entry=e):
            filter(c,entry)

        b1 = Tkinter.Button(fhp,text='Close',command=closeCallback)
        b2 = Tkinter.Button(fhp,text='Filter',command=filterCallback)
        b1.pack(side="left")
        b2.pack(side="right")

    fhp.geometry('200x200+250+250') 
    fhp.deiconify()
    fhp_entry.focus_set()
</t>
<t tx="ekr.20040319111213.5">def addMenu(tag,keywords):
    
    c = top()
    
    trace()
    
    def callback(c=c):
        filterHoist(c)
    
    table = ("FilterHoist",None,callback),

    c.frame.menu.createMenuItemsFromTable("Outline",table)</t>
<t tx="ekr.20040319142202"></t>
<t tx="ekr.20040319142708">def filter(c,e):
    
    pat = re.compile(e.get())

    c.beginUpdate()
    try: # update...
        t = tnode('','A Filtered Hoist')
        newRoot = c.rootVnode().insertAfter(t)
        p = c.rootVnode()
        while p:
            if pat.search(p.bodyString()):
                clone = p.clone(p)
                clone.moveToLastChildOf(newRoot)
            p = p.threadNext()
        newRoot.moveToRoot(c.rootVnode())
        c.setCurrentVnode(newRoot)
    finally:
        c.endUpdate()

    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040322120331">print '-'*20
for p in c.allNodes_iter():
    if hasattr(p.v.t,"tnodeList"):
        print p,p.v.t.tnodeList</t>
<t tx="ekr.20040330095252">t = c.frame.log.logCtrl
print t
t.delete("1.0","end")</t>
<t tx="ekr.20040706071823"># This works, and doesn't seem convenient for Leo's importers.
try:
    import parser
    import pprint
    path = r"c:\prog\test\importIndentTest.py"
    f = open(path)
    s = f.read()
    f.close()
    ast = parser.suite(s)
    tup = ast.totuple()
    print `ast`
    pprint.pprint(tup)
except:
    import traceback
    traceback.print_exc()</t>
<t tx="ekr.20040713123617.1">@language python
@tabwidth -4

import string

tabWidth = 4 # how many blanks in a tab.
printFlag = False
doLeoTranslations,dontDoLeoTranslations = True,False

gClassName = "" # The class name for the present function.  Used to modify ivars.
gIvars = [] # List of ivars to be converted to self.ivar

@others

run(c)</t>
<t tx="ekr.20040713130853"></t>
<t tx="ekr.20040713130853.1">@ elisp2py converts elisp text into python text.  The conversion is not complete.  Nevertheless, elisp2py eliminates much of the tedious text manipulation that would otherwise be required.

The following is a list of the translations performed by c2py.  These transformations are controlled by convertCodeList().

I.  Prepass

These translations happen before removing all curly braces.

Suppose we are translating:

    aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
    {
        body
    }

1. Translates the function prototype, i.e., translates:

    aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
to:
    def aMethod(v1,...vn):

As a special case, c2py translates:

    aTypeSpec aClass::aClass(t1 v1,...,tn vn)
to:
    aClass.__init__(t1 v1,...,tn vn)

Yes, I know, aClass.__init__ isn't proper Python, but retaining the class name is useful.

2. Let t denote any member of typeList or classList.

    a) Removes all casts of the form (t) or (t*) or (t**), etc.
    b) Converts t x, t *x, t **x, etc. to x.
    c) Converts x = new t(...) to x = t(...)
    d) For all i in ivarsDict[aClass] converts this -&gt; i to self.i
    e) For all i in ivarsDict[aClass] converts i to self.i

3. Converts &lt; &lt; x &gt; &gt; = to @c.  This Leo-specific translation is not done when translating files.

II.  Main Pass

This pass does the following simple translations everywhere except in comments and strings.

Changes all -&gt; to .
Changes all this.self to self (This corrects problems during the prepass.)
Removes all curly braces
Changes all #if to if
Changes all else if to elif
Changes all #else to else:
Changes all else to else:
Removes all #endif
Changes all &amp;&amp; to and
Changes all || to or
Changes all TRUE to True
Changes all FALSE to False
Changes all NULL to None
Changes all this to self
Changes all @code to @c.  This Leo-specific translation is not done when translating files.

III.  Complex Pass

This pass attempts more complex translations.

Converts if ( x ) to if x:
Converts elif ( x ) to elif x:
Converts while ( x ) to while x:
Converts for ( x ; y ; z ) to for x SEMI y SEMI z:

remove all semicolons.

IV.  Final Pass

This pass completes the translation.

Removes all semicolons.
Removes @c if it starts the text.  This Leo-specific translation is not done when translating files.
Removes all blank lines.
Removes excess whitespace from all lines, leaving leading whitespace unchanged.
Replaces C/C++ comments by Python comments.
Removes trailing whitespace from all lines.
</t>
<t tx="ekr.20040713130853.2">@ Strategy and Performance

The speed of elisp2py is unimportant.  We don't care about the memory used because we translate only small pieces of text at a time.

We can do body[i:j] = x, regardless of len(x).  We can also do del body[i:j] to delete characters.

We scan repeatedly through the text.  Using many passes greatly simplifies the code and does not slow down elisp2py significantly.

The script does not scan within strings or comments.  The idiom to handle such scans is the following:

def someScan(body):
    i = 0
    while i &lt; body(len):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif &lt;&lt; found what we are looking for ? &gt;&gt; :
            &lt;&lt; convert what we are looking for, setting i &gt;&gt;
        else: i += 1

That's about all there is to it.
</t>
<t tx="ekr.20040713130853.3">@ Please change the following lists so they contain the types and classes used by your program.

c2py removes all type definitions correctly; it converts
    new aType(...)
to
    aType(...)
@c

classList = [
    "vnode", "tnode", "Commands",
    "wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]
    
typeList = ["char", "void", "short", "long", "int", "double", "float"]

@ Please change ivarsDict so it represents the instance variables (ivars) used by your program's classes.

ivarsDict is a dictionary used to translate ivar i of class c to self.i.  It also translates this-&gt;i to self.i.
@c
    
ivarsDict = {
    "atFile": [ "mCommands", "mErrors", "mStructureErrors",
        "mTargetFileName", "mOutputFileName", "mOutputStream",
        "mStartSentinelComment", "mEndSentinelComment", "mRoot"],

    "vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

    "tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
        "mSelectionStart", "mSelectionLength", "mCloneIndex"],
        
    "LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

    "Commands": [
        # public
        "mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
        "mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
        #private
        "mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
        "mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
        "mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
        "mMaxVnodeTag",
        "mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
        "mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}</t>
<t tx="ekr.20040713130853.4">testData = [ "\n@doc\n\
This is a doc part: format, whilest, {};-&gt;.\n\
&lt;&lt;\
section def&gt;&gt;=\n\
LeoFrame::LeoFrame(vnode *v, char *s, int i)\n\
{\n\
    // test ; {} /* */.\n\
    #if 0 //comment\n\
        if(gLeoFrameList)gLeoFrameList -&gt; mPrevFrame = this ;\n\
        else\n\
            this -&gt; mNextFrame = gLeoFrameList ;\n\
    #else\n\
        \n\
        vnode *v = new vnode(a,b);\n\
        Commands *commander = (Commands) NULL ; // after cast\n\
        this -&gt; mPrevFrame = NULL ;\n\
    #endif\n\
    if (a==b)\n\
        a = 2;\n\
    else if (a ==c)\n\
        a = 3;\n\
    else return; \n\
    /* Block comment test:\n\
        if(2):while(1): end.*/\n\
    for(int i = 1; i &lt; limit; ++i){\n\
        mVisible = FALSE ;\n\
        mOnTop = TRUE ;\n\
    }\n\
    // trailing ws.	 \n\
    mCommands = new Commands(this, mTreeCtrl, mTextCtrl) ;\n\
    gActiveFrame = this ;\n\
}\n\
    ", "&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
\n\
void vnode::OnCopyNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
    mCommands -&gt; copyOutline();\n\
}\n\
\n@doc\n\
another doc part if, then, else, -&gt; \n&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
void vnode::OnPasteNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
    mCommands -&gt; pasteOutline();\n\
}\n" ]</t>
<t tx="ekr.20040713130853.7">def speedTest(passes):

    import time
    file = r"c:\prog\LeoPy\LeoPy.leo"
    f=open(file)
    if not f:
        print "not found: ", file
        return
    s=f.read()
    f.close()
    print "file:", file, " size:", len(s), " passes:", passes
    print "speedTest start"
    time1 = time.clock()
    p = passes
    while p &gt; 0:
        n = len(s) ; i = 0 ; lines = 0
        while -1 &lt; i &lt; n:
            if s[i] == '\n':
                lines += 1 ; i += 1
            else:
                i = s.find('\n',i) # _much_ faster than list-based-find.
            continue
            # match is about 9 times slower than simple test.
            if s[i]=='\n': # match(s,i,'\n'): # 
                i += 1
            else:
                i += 1
        p -= 1
    time2 = time.clock()
    print "lines:", lines
    print "speedTest done:"
    print "elapsed time:", time2-time1
    print "time/pass:", (time2-time1)/passes</t>
<t tx="ekr.20040713130853.15">@ We separate the processing into two parts, 1) a leo-aware driver that iterates over @file trees and 2) a text-based part that processes one or more files or strings.
</t>
<t tx="ekr.20040713130853.16">def convertCurrentTree():

    import c2py
    import leo
    import leoGlobals
    c=leoGlobals.top()
    v = c.currentVnode()
    c2py.convertLeoTree(v,c)</t>
<t tx="ekr.20040713130853.17">def convertLeoTree(v,c):

    after=v.nodeAfterTree()
    while v and v != after:
        s=v.bodyString()
        print "converting:", v.headString()
        s=convertCStringToPython(s, doLeoTranslations )
        v.setBodyStringOrPane(s)
        v=v.threadNext()
    c.Repaint() # for backward compatibility.
    print "end of c2py"</t>
<t tx="ekr.20040713130853.18">def convertCFileToPython(file):

    f=open(file, 'r')
    if not f: return
    s = f.read()
    f.close();
    f=open(file + ".py", 'w')
    if not f: return
    s = convertCStringToPython(s, dontDoLeoTranslations )
    f.write(s)
    f.close()</t>
<t tx="ekr.20040713130853.19"></t>
<t tx="ekr.20040713130853.20">def convertCStringToPython(s, leoFlag):

    # print "convertCStringToPython:start\n", s
    firstPart = True
    codeList = stringToList(s)
    
    if not leoFlag:
        convertCodeList(codeList, firstPart, dontDoLeoTranslations)
        return listToString(codeList)

    outputList = []
    i = 0
    while i &lt; len(codeList):
        j = skipCodePart(codeList,i)
        if j &gt; i:
            code = codeList[i:j]
            convertCodeList(code, firstPart, doLeoTranslations)
            i = j
            #print "-----code:", listToString(code)
            for item in code:
                outputList.append(item)
        firstPart = False # don't remove @c from here on.
        j = skipDocPart(codeList,i)
        if j &gt; i:
            doc = codeList[i:j]
            convertDocList(doc)
            #print "-----doc:", listToString(doc)
            i = j
            for item in doc:
                outputList.append(item)
    
    result = listToString(outputList)
    global printFlag
    if printFlag: print "-----:\n", result
    return result</t>
<t tx="ekr.20040713130853.21">def OLDconvert(self,list, firstPart, leoFlag):
    #first
    convertLeadingBlanks(list)
    if leoFlag:
        replaceSectionDefs(list)
    mungeAllFunctions(list)
    #next
    safeReplace(list, " -&gt; ", '.')
    safeReplace(list, "-&gt;", '.')
    safeReplace(list, " . ", '.')
    safeReplace(list, "this.self", "self")
    safeReplace(list, "{", None)
    safeReplace(list, "}", None)
    safeReplace(list, "#if", "if")
    safeReplace(list, "#else", "else")
    safeReplace(list, "#endif", None)
    safeReplace(list, "else if", "elif")
    safeReplace(list, "else", "else:")
    safeReplace(list, "&amp;&amp;", "and")
    safeReplace(list, "||", "or")
    safeReplace(list, "TRUE", "True")
    safeReplace(list, "FALSE", "False")
    safeReplace(list, "NULL", "None")
    safeReplace(list, "this", "self")
    safeReplace(list, "try", "try:")
    safeReplace(list, "catch", "except:")
    if leoFlag:
        safeReplace(list, "@code", "@c")
    #next
    handleAllKeywords(list)
    # after processing for keywords
    removeSemicolonsAtEndOfLines(list)
    #last
    if firstPart and leoFlag: removeLeadingAtCode(list)
    removeBlankLines(list)
    removeExcessWs(list)
    # your taste may vary: in Python I don't like extra whitespace
    safeReplace(list, " :", ":") 
    safeReplace(list, ", ", ",")
    safeReplace(list, " ,", ",")
    safeReplace(list, " (", "(")
    safeReplace(list, "( ", "(")
    safeReplace(list, " )", ")")
    safeReplace(list, ") ", ")")
    replaceComments(list) # should follow all calls to safeReplace
    removeTrailingWs(list)
    safeReplace(list, "\t ", "\t") # happens when deleting declarations.</t>
<t tx="ekr.20040713130853.22">def convertDocList(docList):

    # print "convertDocList:", docList
    if matchWord(docList, 0, "@doc"):
        i = skipWs(docList, 4)
        if match(docList, i, "\n"):
            i += 1
        docList[0:i] = list("@ ")</t>
<t tx="ekr.20040713130853.23">def skipDocPart(list, i):
    
    # print "skipDocPart", i
    while i &lt; len(list):
        if matchWord(list, i, "@code") or matchWord(list, i, "@c"):
            break
        elif isSectionDef(list,i):
            break
        else: i = skipPastLine(list, i)
    return i</t>
<t tx="ekr.20040713130853.24">def skipCodePart(codeList, i):
    
    # print "skipCodePart", i
    if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
        return i
    while i &lt; len(codeList):
        if match(codeList, i, "//"):
            i = skipPastLine(codeList,i)
        elif match(codeList, i, "/*"):
            i = skipCBlockComment(codeList,i)
        elif match(codeList, i, '"') or match(codeList, i, "'"):
            i = skipString(codeList,i)
        elif match(codeList, i, "\n"):
            i += 1
            if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
                break
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.27">def convertLeadingBlanks(list):

    global tabWidth
    if tabWidth &lt; 2: return
    i = 0
    while i &lt; len(list):
        n = 0
        while i &lt; len(list) and list[i] == ' ':
            n += 1 ; i += 1
            if n == tabWidth:
                list[i-tabWidth:i] = ['\t']
                i = i - tabWidth + 1
                n = 0
        i = skipPastLine(list, i)</t>
<t tx="ekr.20040713130853.28">def findInList(list, i, findStringOrList):

    findList = stringToList(findStringOrList)
    
    while i &lt; len(list):
        if match(list, i, findList): return i
        else: i += 1
    return -1</t>
<t tx="ekr.20040713130853.29">def findInCode(codeList, i, findStringOrList):

    findList = stringToList(findStringOrList)
    
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList, i, findList):
            return i
        else: i += 1
    return -1</t>
<t tx="ekr.20040713130853.30"># We scan for a '{' at the top level that is preceded by ')'
# @code and &lt; &lt; x &gt; &gt; = have been replaced by @c
def mungeAllFunctions(codeList):

    prevSemi = 0 # Previous semicolon: header contains all previous text
    i = 0
    firstOpen = None
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
            prevSemi = i
        elif match(codeList, i, '('):
            if not firstOpen:
                firstOpen = i
            i += 1
        elif match(codeList, i, '#'):
            i = skipPastLine(codeList, i)
            prevSemi = i
        elif match(codeList, i, ';'):
            i += 1
            prevSemi = i
        elif matchWord(codeList, i, "@code"):
            i += 5
            prevSemi = i # restart the scan
        elif matchWord(codeList, i, "@c"):
            i += 2 ; prevSemi = i # restart the scan
        elif match(codeList, i, "{"):
            i = handlePossibleFunctionHeader(codeList,i,prevSemi,firstOpen)
            prevSemi = i ; firstOpen = None # restart the scan
        else: i += 1</t>
<t tx="ekr.20040713130853.31"># converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader(codeList, i, prevSemi, firstOpen):

    assert(match(codeList,i,"{"))
    prevSemi = skipWsAndNl(codeList, prevSemi)
    close = prevNonWsOrNlChar(codeList, i)
    if close &lt; 0 or codeList[close] != ')':
        return 1 + skipToMatchingBracket(codeList, i)
    if not firstOpen:
        return 1 + skipToMatchingBracket(codeList, i)
    close2 = skipToMatchingBracket(codeList, firstOpen)
    if close2 != close:
        return 1 + skipToMatchingBracket(codeList, i)
    open = firstOpen
    assert(codeList[open]=='(')
    head = codeList[prevSemi:open]
    # do nothing if the head starts with "if", "for" or "while"
    k = skipWs(head,0)
    if k &gt;= len(head) or not head[k] in string.letters:
        return 1 + skipToMatchingBracket(codeList, i)
    kk = skipPastWord(head,k)
    if kk &gt; k:
        headString = listToString(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + skipToMatchingBracket(codeList, i)
    args = codeList[open:close+1]
    k = 1 + skipToMatchingBracket(codeList,i)
    body = codeList[i:k]
    #print "head:", listToString(head)
    #print "args:", listToString(args)
    #print "body:", listToString(body)
    #print "tot: ", listToString(codeList[prevSemi:k])
    head = massageFunctionHead(head)
    args = massageFunctionArgs(args)
    body = massageFunctionBody(body)
    #print "head2:", listToString(head)
    #print "args2:", listToString(args)
    #print "body2:", listToString(body)
    #print "tot2: ", listToString(codeList[prevSemi:k])
    result = []
    for item in head:
        result.append(item)
    for item in args:
        result.append(item)
    for item in body:
        result.append(item)
    codeList[prevSemi:k] = result
    return k</t>
<t tx="ekr.20040713130853.32">def massageFunctionArgs(args):
    global gClassName
    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if gClassName:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i &lt; len(args):
        i = skipWsAndNl(args, i)
        c = args[i]
        if c in string.letters:
            j = skipPastWord(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", listToString(result)
    return result</t>
<t tx="ekr.20040713130853.33">def massageFunctionHead(head):

    # print "head:", listToString(head)
    result = []
    prevWord = []
    global gClassName ; gClassName = []
    i = 0
    while i &lt; len(head):
        i = skipWsAndNl(head, i)
        if i &lt; len(head) and head[i] in string.letters:
            result = []
            j = skipPastWord(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = skipWs(head,i)
            if match(head,i,"::"):
                # Set the global to the class name.
                gClassName = listToString(prevWord)
                # print "class name:", gClassName
                i = skipWs(head, i+2)
                if i &lt; len(head) and (head[i]=='~' or head[i] in string.letters):
                    j = skipPastWord(head,i)
                    if head[i:j] == prevWord:
                        for item in list("__init__"): result.append(item)
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        for item in list("__del__"): result.append(item)
                    else:
                        # for item in "::": result.append(item)
                        for item in head[i:j]: result.append(item)
                    i = j
            else:
                for item in prevWord:result.append(item)
        else: i += 1
        
    finalResult = list("def ")
    for item in result: finalResult.append(item)
    # print "new head:", listToString(finalResult)
    return finalResult</t>
<t tx="ekr.20040713130853.34">def massageFunctionBody(body):

    body = massageIvars(body)
    body = removeCasts(body)
    body = removeTypeNames(body)
    return body</t>
<t tx="ekr.20040713130853.35">def massageIvars(body):

    if gClassName and ivarsDict.has_key(gClassName):
        ivars = ivarsDict [ gClassName ]
    else:
        ivars = []
    # print "key:ivars=", gClassName, ':', `ivars`

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif body[i] in string.letters:
            j = skipPastWord(body,i)
            word = listToString(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.36">def removeCasts(body):

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif match(body, i, '('):
            start = i
            i = skipWs(body, i+1)
            if body[i] in string.letters:
                j = skipPastWord(body,i)
                word = listToString(body[i:j])
                i = j
                if word in classList or word in typeList:
                    i = skipWs(body, i)
                    while match(body,i,'*'):
                        i += 1
                    i = skipWs(body, i)
                    if match(body,i,')'):
                        i += 1
                        # print "removing cast:", listToString(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.37"># Do _not_ remove type names when preceded by new.

def removeTypeNames(body):

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif matchWord(body, i, "new"):
            i = skipPastWord(body,i)
            i = skipWs(body,i)
            # don't remove what follows new.
            if body[i] in string.letters:
                i = skipPastWord(body,i)
        elif body[i] in string.letters:
            j = skipPastWord(body,i)
            word = listToString(body[i:j])
            if word in classList or word in typeList:
                k = skipWs(body, j)
                while match(body,k,'*'):
                    k += 1 ; j = k
                # print "Deleting type name:", listToString(body[i:j])
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.38"># converts if ( x ) to if x:
# converts while ( x ) to while x:
def handleAllKeywords(codeList):

    # print "handAllKeywords:", listToString(codeList)
    i = 0
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif ( matchWord(codeList,i,"if") or
            matchWord(codeList,i,"while") or
            matchWord(codeList,i,"for") or
            matchWord(codeList,i,"elif") ):
            i = handleKeyword(codeList,i)
        else:
            i += 1
    # print "handAllKeywords2:", listToString(codeList)</t>
<t tx="ekr.20040713130853.39">def handleKeyword(codeList,i):

    isFor = False
    if (matchWord(codeList,i,"if")):
        i += 2
    elif (matchWord(codeList,i,"elif")):
        i += 4
    elif (matchWord(codeList,i,"while")):
        i += 5
    elif (matchWord(codeList,i,"for")):
        i += 3
        isFor = True
    else: assert(0)
    # Make sure one space follows the keyword
    k = i
    i = skipWs(codeList,i)
    if k == i:
        c = codeList[i]
        codeList[i:i+1] = [ ' ', c ]
        i += 1
    # Remove '(' and matching ')' and add a ':'
    if codeList[i] == "(":
        j = removeMatchingBrackets(codeList,i)
        if j &gt; i and j &lt; len(codeList):
            c = codeList[j]
            codeList[j:j+1] = [":", " ", c]
            j = j + 2
        return j
    return i</t>
<t tx="ekr.20040713130853.40">def isWs(c):
    return c == ' ' or c == '\t'
    
def isWsOrNl(c):
    return c == ' ' or c == '\t' or c == '\n'</t>
<t tx="ekr.20040713130853.41"># returns the ending index if i points to &lt; &lt; x &gt; &gt; =
def isSectionDef(list, i):

    i = skipWs(list,i)
    if not match(list,i,"&lt;&lt;"): return False
    while i &lt; len(list) and list[i] != '\n':
        if match(list,i,"&gt;&gt;="): return i+3
        else: i += 1
    return False</t>
<t tx="ekr.20040713130853.42">def isStringOrComment(list, i):

    return match(list,i,"'") or match(list,i,'"') or match(list,i,"//") or match(list,i,"/*")</t>
<t tx="ekr.20040713130853.43"># returns True if findList matches starting at codeList[i]

def match (codeList, i, findStringOrList):

    findList = stringToList(findStringOrList)
    n = len(findList)
    j = 0
    while i+j &lt; len(codeList) and j &lt; len(findList):
        if codeList[i+j] != findList[j]:
            return False
        else:
            j += 1
            if j == n:
                return i+j
    return False</t>
<t tx="ekr.20040713130853.44">def matchWord (codeList, i, findStringOrList):

    j = match(codeList,i,findStringOrList)
    if not j:
        return False
    elif j &gt;= len(codeList):
        return True
    else:
        c = codeList[j]
        return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="ekr.20040713130853.45">def prevNonWsChar(list, i):

    i -= 1
    while i &gt;= 0 and isWs(list[i]):
        i -= 1
    return i

def prevNonWsOrNlChar(list, i):

    i -= 1
    while i &gt;= 0 and isWsOrNl(list[i]):
        i -= 1
    return i</t>
<t tx="ekr.20040713130853.46">def removeAllCComments(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            i = skipString(list,i)
        elif match(list,i,"//"):
            j = skipPastLine(list,i)
            print "deleting single line comment:", listToString(list[i:j])
            del list[i:j]
        elif match(list,i,"/*"):
            j = skipCBlockComment(list,i)
            print "deleting block comment:", listToString(list[i:j])
            del list[i:j]
        else:
            i += 1</t>
<t tx="ekr.20040713130853.47">def removeAllCSentinels(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            # string starts a line.
            i = skipString(list,i)
            i = skipPastLine(list,i)
        elif match(list,i,"/*"):
            # block comment starts a line
            i = skipCBlockComment(list,i)
            i = skipPastLine(line,i)
        elif match(list,i,"//@"):
            j = skipPastLine(list,i)
            print "deleting sentinel:", listToString(list[i:j])
            del list[i:j]
        else:
            i = skipPastLine(list,i)</t>
<t tx="ekr.20040713130853.48">def removeAllPythonComments(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            i = skipString(list,i)
        elif match(list,i,"#"):
            j = skipPastLine(list,i)
            print "deleting comment:", listToString(list[i:j])
            del list[i:j]
        else:
            i += 1</t>
<t tx="ekr.20040713130853.49">def removeAllPythonSentinels(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            # string starts a line.
            i = skipString(list,i)
            i = skipPastLine(list,i)
        elif match(list,i,"#@"):
            j = skipPastLine(list,i)
            print "deleting sentinel:", listToString(list[i:j])
            del list[i:j]
        else:
            i = skipPastLine(list,i)</t>
<t tx="ekr.20040713130853.50">def removeAtRoot (codeList):

    i = skipWs(codeList, 0)
    if matchWord(codeList,i,"@root"):
        j = skipPastLine(codeList,i)
        del codeList[i:j]

    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,"\n"):
            i = skipWs(codeList, i+1)
            if matchWord (codeList,i,"@root"):
                j = skipPastLine(codeList,i)
                del codeList[i:j]
        else: i += 1
</t>
<t tx="ekr.20040713130853.51">def removeBlankLines(codeList):

    i = 0
    while i &lt; len(codeList):
        j = i
        while j &lt; len(codeList) and (codeList[j]==" " or codeList[j]=="\t"):
            j += 1
        if j== len(codeList) or codeList[j] == '\n':
            del codeList[i:j+1]
        else:
            oldi = i
            i = skipPastLine(codeList,i)</t>
<t tx="ekr.20040713130853.52">def removeExcessWs(codeList):

    i = 0
    i = removeExcessWsFromLine(codeList,i)
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,'\n'):
            i += 1
            i = removeExcessWsFromLine(codeList,i)
        else: i += 1</t>
<t tx="ekr.20040713130853.53">def removeExcessWsFromLine(codeList,i):

    assert(i==0 or codeList[i-1] == '\n')
    i = skipWs(codeList,i)
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i): break # safe
        elif match(codeList, i, '\n'): break
        elif match(codeList, i, ' ') or match(codeList, i, '\t'):
            # Replace all whitespace by one blank.
            k = i
            i = skipWs(codeList,i)
            codeList[k:i] = [' ']
            i = k + 1 # make sure we don't go past a newline!
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.54">def removeLeadingAtCode(codeList):

    i = skipWsAndNl(codeList,0)
    if matchWord(codeList,i,"@code"):
        i = skipWsAndNl(codeList,5)
        del codeList[0:i]
    elif matchWord(codeList,i,"@c"):
        i = skipWsAndNl(codeList,2)
        del codeList[0:i]</t>
<t tx="ekr.20040713130853.55">def removeMatchingBrackets(codeList, i):

    j = skipToMatchingBracket(codeList, i)
    if j &gt; i and j &lt; len(codeList):
        # print "del brackets:", listToString(codeList[i:j+1])
        c = codeList[j]
        if c == ')' or c == ']' or c == '}':
            del codeList[j:j+1]
            del codeList[i:i+1]
            # print "returning:", listToString(codeList[i:j])
            return j - 1
        else: return j + 1
    else: return j</t>
<t tx="ekr.20040713130853.56">def removeSemicolonsAtEndOfLines(list):

    i = 0
    while i &lt; len(list):
        if isStringOrComment(list,i):
            i = skipStringOrComment(list,i)
        elif list[i] == ';':
            j = skipWs(list,i+1)
            if j &gt;= len(list) or match(list,j,'\n') or match(list,j,'#') or match(list,j,"//"):
                del list[i]
            else: i += 1
        else: i += 1</t>
<t tx="ekr.20040713130853.57">def removeTrailingWs(list):

    i = 0
    while i &lt; len(list):
        if isWs(list[i]):
            j = i
            i = skipWs(list,i)
            assert(j &lt; i)
            if i &gt;= len(list) or list[i] == '\n':
                # print "removing trailing ws:", `i-j`
                del list[j:i]
                i = j
        else: i += 1</t>
<t tx="ekr.20040713130853.58"># Replaces all occurances of findString by changeString.
# Deletes all occurances if change is None
def replace(codeList, findString, changeString):

    if len(findString)==0: return
    findList = stringToList(findString)
    changeList = stringToList(changeString)

    i = 0
    while i &lt; len(codeList):
        if match(codeList, i, findList):
            codeList[i:i+len(findList)] = changeList
            i += len(changeList)
        else: i += 1</t>
<t tx="ekr.20040713130853.59"># For Leo we expect few block comments; doc parts are much more common.

def replaceComments(codeList):

    i = 0
    if match(codeList, i, "//"):
        codeList[0:2] = ['#']
    while i &lt; len(codeList):
        if match(codeList, i, "//"):
            codeList[i:i+2] = ['#']
            i = skipPastLine(codeList,i)
        elif match(codeList, i, "/*"):
            j = skipCBlockComment(codeList,i)
            del codeList[j-2:j]
            codeList[i:i+2] = ['#']
            j -= 2 ; k = i ; delta = -1
            while k &lt; j + delta :
                if codeList[k]=='\n':
                    codeList[k:k+1] = ['\n', '#', ' ']
                    delta += 2 ; k += 3 # progress!
                else: k += 1
            i = j + delta
        elif match(codeList, i, '"') or match(codeList, i, "'"):
            i = skipString(codeList,i)
        else: i += 1</t>
<t tx="ekr.20040713130853.60"># Replaces &lt; &lt; x &gt; &gt; = by @c (at the start of lines).
def replaceSectionDefs(codeList):

    i = 0
    j = isSectionDef(codeList,i)
    if j &gt; 0: codeList[i:j] = list("@c ")

    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,"\n"):
            i += 1
            j = isSectionDef(codeList,i)
            if j &gt; i: codeList[i:j] = list("@c ")
        else: i += 1</t>
<t tx="ekr.20040713130853.61"># Replaces occurances of findString by changeString outside of C comments and strings.
# Deletes all occurances if change is None.
def safeReplace(codeList, findString, changeString):

    if len(findString)==0: return
    findList = stringToList(findString)
    changeList = stringToList(changeString)
    i = 0
    if findList[0] in string.letters: #use matchWord
        while i &lt; len(codeList):
            if isStringOrComment(codeList,i):
                i = skipStringOrComment(codeList,i)
            elif matchWord(codeList, i, findList):
                codeList[i:i+len(findList)] = changeList
                i += len(changeList)
            else: i += 1
    else: #use match
        while i &lt; len(codeList):
            if match(codeList, i, findList):
                codeList[i:i+len(findList)] = changeList
                i += len(changeList)
            else: i += 1</t>
<t tx="ekr.20040713130853.62">def skipCBlockComment(codeList, i):

    assert(match(codeList, i, "/*"))
    i += 2

    while i &lt; len(codeList):
        if match(codeList, i, "*/"): return i + 2
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.63">def skipPastLine(codeList, i):

    while i &lt; len(codeList) and codeList[i] != '\n':
        i += 1
    if i &lt; len(codeList) and codeList[i] == '\n':
        i += 1
    return i</t>
<t tx="ekr.20040713130853.64">def skipPastWord(list, i):

    assert(list[i] in string.letters or list[i]=='~')
    
    # Kludge: this helps recognize dtors.
    if list[i]=='~':
        i += 1
    
    while i &lt; len(list) and (
        list[i] in string.letters or
        list[i] in string.digits or
        list[i]=='_'):
        i += 1
    return i</t>
<t tx="ekr.20040713130853.65">def skipString(codeList, i):

    delim = codeList[i] # handle either single or double-quoted strings
    assert(delim == '"' or delim == "'")
    i += 1

    while i &lt; len(codeList):
        if codeList[i] == delim: return i + 1
        elif codeList[i] == '\\': i += 2
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.66">def skipStringOrComment(list,i):

    if match(list,i,"'") or match(list,i,'"'):
        return skipString(list,i)
    if match(list, i, "//"):
        return skipPastLine(list,i)
    elif match(list, i, "/*"):
        return skipCBlockComment(list,i)
    else: assert(0)</t>
<t tx="ekr.20040713130853.68">def skipWs(list, i):

    while i &lt; len(list):
        c = list[i]
        if c == ' ' or c == '\t':
            i += 1
        else: break
    return i
    
def skipWsAndNl(list, i):

    while i &lt; len(list):
        c = list[i]
        if c == ' ' or c == '\t' or c == '\n':
            i += 1
        else: break
    return i</t>
<t tx="ekr.20040713131315">@killcolor


indentation level depends on def, if, while, etc., not on parens.

</t>
<t tx="ekr.20040713131350">@language elisp</t>
<t tx="ekr.20040713132127.1">@ignore
@language elisp
</t>
<t tx="ekr.20040713132127.2">;;; -*-unibyte: t;-*-

;;;; igrep.el --- An improved interface to `grep` and `find`.

;;; SCCS @(#)igrep.el	2.95

;;; Description:
;;; 
;;; The `igrep' command is like `grep' except that it takes three
;;; required arguments (PROGRAM, EXPRESSION, and FILES) and an optional
;;; argument (OPTIONS) instead of just one argument (COMMAND).  The
;;; analogous `egrep' and `fgrep' commands are also defined for
;;; convenience.
;;; 
;;; The `igrep-find' command is like `igrep' except that it uses `find`
;;; to recursively `grep` a directory.  The analogous `egrep-find' and
;;; `fgrep-find' commands are also defined for convenience.
;;; 
;;; When called interactively, `igrep' and `igrep-find' (and their
;;; analogues) provide defaults for the EXPRESSION and FILES arguments
;;; based on the current word and the visited file name (if the
;;; `igrep-expression-default' and `igrep-files-default' options are
;;; set, respectively).  The `igrep-insert-default-key' option allows
;;; the default value to be inserted into the minibuffer for editing;
;;; since Emacs 20 provides that via the minibuffer history, it's only
;;; enabled for older versions by default. Other options that control
;;; the user interface are `igrep-read-options', `igrep-read-multiple-files',
;;; `igrep-verbose-prompts', and `igrep-save-buffers'.
;;; 
;;; Besides the basic `igrep-program' and `igrep-find-program' global
;;; variables, other variables control the syntax of the `grep` and
;;; `find` shell commands that are executed: `igrep-options',
;;; `igrep-expression-option', `igrep-find-prune-clause',
;;; `igrep-find-file-clause', and `igrep-find-use-xargs'.
;;; 
;;; The `igrep-use-zgrep' user option controls whether the corresponding
;;; GNU (gzip) "zPROGRAM" script is used, to `grep` compressed files.
;;; Special minibuffer history lists are maintained for the EXPRESSION
;;; and FILES arguments.
;;; 
;;; The `agrep' and `agrep-find' commands are interfaces to the
;;; approximate `grep` utility, which is distributed with the `glimpse'
;;; indexing and query tool (available from
;;; &lt;URL:http://glimpse.cs.arizona.edu:1994/&gt;).
;;; 
;;; `grep' itself can be advised to provide the `igrep' interface when
;;; it is invoked interactively (so that when it's called
;;; programmatically, it still uses the original argument list), via the
;;; `igrep-insinuate' command.  `igrep-insinuate' also defines
;;; `grep-find' as an alias for `igrep-find', `dired-do-grep' and
;;; `dired-do-grep-find' as aliases for `dired-do-igrep' and
;;; `dired-do-igrep-find', and `Buffer-menu-grep' as an alias for
;;; `Buffer-menu-igrep'.
;;; 
;;; When run interactively from Dired mode, the various `igrep' commands
;;; provide defaults for the EXPRESSION and FILES arguments that are
;;; based on the visited directory (including any inserted
;;; subdirectories) and the current file.  The alternative
;;; `dired-do-igrep' and `dired-do-igrep-find' commands respect the
;;; `dired-do-*' command conventions: a prefix argument is interpreted
;;; as the number of succeeding files to `grep`, otherwise all the
;;; marked files are `grep`ed.
;;; 
;;; The `igrep-visited-files' command provides a simple way to `grep`
;;; just those files that are being visited in buffers.  The
;;; `Buffer-menu-igrep' command does the same thing, for buffers marked
;;; for selection in Buffer Menu mode.

;;; Copyright:
;;; 
;;; Copyright  1994-1998,2000-2002 Kevin Rodgers
;;; 
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; at your option) any later version.
;;; 
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;;; 
;;; Neither my former nor current employer (Martin Marietta and
;;; Information Handling Services, respectively) has disclaimed any
;;; copyright interest in igrep.el.
;;; 
;;; Kevin Rodgers &lt;kevinr@ihs.com&gt;          Lead Software Engineer
;;; Information Handling Services           Electronic Systems Development
;;; 15 Inverness Way East, M/S A201         GO BUFFS!
;;; Englewood CO 80112-5776 USA             1+ (303) 397-2807[voice]/-2244[fax]

;;; Installation:
;;; 
;;; 1. Put this file in a directory that is a member of load-path, and
;;;    byte-compile it (e.g. with `M-x byte-compile-file') for better
;;;    performance.  You can ignore any warnings about references to free
;;;    variables and "not known to be defined" functions.
;;; 2. Put these forms in default.el or ~/.emacs:
;;;    (autoload 'igrep "igrep"
;;;       "*Run `grep` PROGRAM to match EXPRESSION in FILES..." t)
;;;    (autoload 'igrep-find "igrep"
;;;       "*Run `grep` via `find`..." t)
;;;    (autoload 'igrep-visited-files "igrep"
;;;       "*Run `grep` ... on all visited files." t)
;;;    (autoload 'dired-do-igrep "igrep"
;;;       "*Run `grep` on the marked (or next prefix ARG) files." t)
;;;    (autoload 'dired-do-igrep-find "igrep"
;;;       "*Run `grep` via `find` on the marked (or next prefix ARG) directories." t)
;;;    (autoload 'Buffer-menu-igrep "igrep"
;;;      "*Run `grep` on the files visited in buffers marked with '&gt;'." t)
;;;    (autoload 'igrep-insinuate "igrep"
;;;      "Define `grep' aliases for the corresponding `igrep' commands." t)
;;; 2. a. For completeness, you can add these forms as well:
;;;    (autoload 'grep "igrep"
;;;       "*Run `grep` PROGRAM to match EXPRESSION in FILES..." t)
;;;    (autoload 'egrep "igrep"
;;;       "*Run `egrep`..." t)
;;;    (autoload 'fgrep "igrep"
;;;       "*Run `fgrep`..." t)
;;;    (autoload 'agrep "igrep"
;;;       "*Run `agrep`..." t)
;;;    (autoload 'grep-find "igrep"
;;;       "*Run `grep` via `find`..." t)
;;;    (autoload 'egrep-find "igrep"
;;;       "*Run `egrep` via `find`..." t)
;;;    (autoload 'fgrep-find "igrep"
;;;       "*Run `fgrep` via `find`..." t)
;;;    (autoload 'agrep-find "igrep"
;;;       "*Run `agrep` via `find`..." t)
;;; 3. If you are running Windows 95/NT, you should install findutils
;;;    and grep from release 17.1 (or higher) of the Cygnus GNU-Win32
;;;    distribution.  See &lt;URL:http://www.cygnus.com/misc/gnu-win32/&gt;.

;;; Usage:
;;; 
;;; These igrep commands accept 1, 2, or 3 `C-u' prefix arguments:
;;; 	M-x igrep		M-x igrep-find
;;; 	M-x  grep		M-x  grep-find	[after `M-x igrep-insinuate']
;;; 	M-x egrep		M-x egrep-find
;;; 	M-x fgrep		M-x fgrep-find
;;; 	M-x agrep		M-x agrep-find
;;; 
;;; These igrep commands accept a single `C-u' prefix argument:
;;; 	M-x igrep-visited-files
;;; 	M-x Buffer-menu-igrep	[in the *Buffer List* buffer]
;;; 
;;; These igrep commands interpret a prefix argument like the Emacs
;;; `dired-do-*' commands:
;;; 	M-x dired-do-igrep	M-x dired-do-igrep-find
;;; 	M-x  dired-do-grep	M-x  dired-do-grep-find	[after `M-x
;;; 							 igrep-insinuate']
;;; 
;;; These Emacs commands can be used after any igrep command:
;;; 	C-x ` (M-x next-error)
;;; 	C-c C-c (M-x compile-goto-error)	[in the *igrep* buffer]

;;; Customization examples:
;;; 
;;; To ignore case by default:
;;; 	(setq igrep-options "-i")
;;; To search subdirectories by default:
;;; 	(setq igrep-find t)
;;; To search files with the GNU (gzip) zgrep script:
;;; 	(setq igrep-use-zgrep t)
;;; or define new igrep commands (this works for zegrep and zfgrep as well):
;;; 	(igrep-define zgrep)		; M-x zgrep
;;; 	(igrep-find-define zgrep)	; M-x zgrep-find
;;; To search "*.[ch]" files by default in C mode:
;;; 	(put 'igrep-files-default 'c-mode
;;; 	     (lambda () "*.[ch]"))
;;; To disable the default search expression and/or files pattern,
;;; except for specific modes:
;;; 	(setq igrep-expression-default 'ignore)
;;; 	(setq igrep-files-default 'ignore)
;;; To avoid exceeding some shells' limit on command argument length
;;; (this only searches files in the current directory):
;;; 	(setq igrep-find t
;;; 	      igrep-find-prune-clause "-type d \\! -name .")

;;; To do:
;;; 
;;; 1. Replace igrep-options with a table that maps igrep-program
;;;    to the appropriate options.
;;; 2. Generalize support for the -prune find clause (e.g. -fstype nfs).
;;; 3. Provide support for `glimpse`.
;;; 4. Add a menu interface.
;;; 5. Port to Emacs 20 (custom).

;;; Emacs Lisp Archive Entry:
;;; Filename: igrep.el
;;; Author: Kevin Rodgers &lt;kevinr@ihs.com&gt;
;;; Version: 2.95
;;; Description: An improved interface to `grep` and `find`.
;;; Keywords: search
;;; Last-Updated: 02/04/22


;;; Package interface:

(provide 'igrep)

(require 'compile)			; compile-internal, grep-regexp-alist,
					; grep-null-device

(eval-when-compile
  (require 'dired)			; dired-directory,
					; dired-get-filename,
					; dired-current-directory,
					; dired-get-marked-files,
					; dired-mark-get-files
  (or (featurep 'ange-ftp)
      (featurep 'efs)
      (condition-case nil
	  (load-library "ange-ftp")	; ange-ftp-ftp-name
	(error nil))
      (condition-case nil
	  (load-library "efs")		; efs-ftp-path
	(error nil)))
  )

</t>
<t tx="ekr.20040713132127.3">(defconst igrep-version "2.95"
  "Version of igrep.el")</t>
<t tx="ekr.20040713132127.4">


;;; User options:

</t>
<t tx="ekr.20040713132127.5">(defvar igrep-options nil

  "*The options passed by `\\[igrep]' to `igrep-program', or nil.

`-n' will automatically be passed to `igrep-program', to generate the
output expected by `\\[next-error]' and `\\[compile-goto-error]'.
`-e' will automatically be passed to `igrep-program', if it supports
that option.")</t>
<t tx="ekr.20040713132127.6">
(put 'igrep-options 'variable-interactive
     "xOptions (\"-xyz\" or nil): ")

</t>
<t tx="ekr.20040713132127.7">(defvar igrep-read-options nil
  "*If non-nil, `\\[igrep]' always prompts for options;
otherwise, it only prompts when 1 or 3 `C-u's are given as a prefix arg.")</t>
<t tx="ekr.20040713132127.8">
(put 'igrep-read-options 'variable-interactive
     "XAlways prompt for options? (t or nil): ")

</t>
<t tx="ekr.20040713132127.9">(defvar igrep-read-multiple-files nil
  "*If non-nil, `\\[igrep]' always prompts for multiple-files;
otherwise, it only prompts when 2 or 3 `C-u's are given as a prefix arg.")</t>
<t tx="ekr.20040713132127.10">
(put 'igrep-read-multiple-files 'variable-interactive
     "XAlways prompt for multiple files? (t or nil): ")

</t>
<t tx="ekr.20040713132127.11">(defvar igrep-expression-default 'current-word
  "*If non-nil, a function that returns a default EXPRESSION for `\\[igrep]'.
The function is called with no arguments and should return a string (or nil).

A different function can be specified for any particular mode by specifying
a value for that `major-mode' property; for example:
	(put 'igrep-expression-default 'dired-mode
	     'igrep-dired-file-current-word)")</t>
<t tx="ekr.20040713132127.12">
(put 'igrep-expression-default 'variable-interactive
     "SProvide a default expression? (function or nil): ")
(put 'igrep-expression-default 'dired-mode
     'igrep-dired-file-current-word)

</t>
<t tx="ekr.20040713132127.13">(defvar igrep-files-default 'igrep-buffer-file-name-pattern
  "*If non-nil, a function that returns the default FILES for `\\[igrep]'.
The function is called with no arguments and should return a string,
or a list of strings (or nil).

A different function can be specified for any particular mode by specifying
a value for that `major-mode' property; for example:
	(put 'igrep-files-default 'dired-mode
	     'igrep-dired-directory-file-pattern)")</t>
<t tx="ekr.20040713132127.14">
(put 'igrep-files-default 'variable-interactive
     "SProvide a default file pattern? (function or nil): ")
(put 'igrep-files-default 'dired-mode
     'igrep-dired-directory-file-pattern)

</t>
<t tx="ekr.20040713132127.15">(defvar igrep-verbose-prompts t
  "*If t, `\\[igrep]' prompts for arguments verbosely;
if not t but non-nil, `\\[igrep]' prompts for arguments semi-verbosely;
if nil, `\\[igrep]' prompts for arguments tersely.")</t>
<t tx="ekr.20040713132127.16">
(put 'igrep-verbose-prompts 'variable-interactive
     "XPrompt verbosely? (t, 'semi, or nil): ")

</t>
<t tx="ekr.20040713132127.17">(defvar igrep-insert-default-key
  (if (&lt; emacs-major-version 20) "\C-c\C-e")
  "*The key used to insert the default argument in the minibuffer.
In Emacs 20, the default is available via the minibuffer history \
(\\&lt;minibuffer-local-map&gt;\\[next-history-element]).")</t>
<t tx="ekr.20040713132127.18">
(put 'igrep-insert-default-key 'variable-interactive
     "kSet key to insert the default `\\[igrep]' argument in the minibuffer: ")

</t>
<t tx="ekr.20040713132127.19">(defvar igrep-save-buffers 'query
  "*If t, `\\[igrep]' first saves each modified file buffer;
if not t but non-nil, `\\[igrep]' offers to save each modified file buffer.")</t>
<t tx="ekr.20040713132127.20">
(put 'igrep-save-buffers 'variable-interactive
     "XSave modified buffers? (t, 'query, or nil): ")


;;; User variables:

</t>
<t tx="ekr.20040713132127.21">(defvar igrep-null-device
  (cond ((boundp 'grep-null-device) grep-null-device) ; Emacs 19
	((boundp 'null-device) null-device)))</t>
<t tx="ekr.20040713132127.22"> ; Emacs 20

</t>
<t tx="ekr.20040713132127.23">(defvar igrep-program "grep"
  "The default program run by `\\[igrep]' and `\\[igrep-find]'.
It must accept a `grep` expression argument and one or more file names, plus
the \"-n\" option.
If nil, `\\[igrep]' prompts for the program to run.")</t>
<t tx="ekr.20040713132127.24">(defvar igrep-expression-option
  (if (equal (call-process igrep-program nil nil nil
			   "-e" "foo" igrep-null-device)
	     1)
      "-e")
  "If non-nil, the option used to specify the EXPRESSION argument to `\\[igrep]',
to protect an initial `-' from option processing.")</t>
<t tx="ekr.20040713132127.25">(defvar igrep-program-table		; referenced by igrep-use-zgrep
  (let ((exec-directories exec-path)
	(program-obarray (make-vector 11 0)))
    (while exec-directories
      (if (and (car exec-directories)
	       (file-directory-p (car exec-directories))
	       (file-readable-p (car exec-directories)))
	  (let ((grep-programs
		 (directory-files (car exec-directories)
				  nil "grep\\(\\.exe\\)?\\'")))
	    (while grep-programs
	      ;; Check `(file-executable-p (car grep-programs))'?
	      (if (save-match-data
		    (string-match "\\.exe\\'" (car grep-programs)))
		  (intern (substring (car grep-programs) 0 -4) program-obarray)
		(intern (car grep-programs) program-obarray))
	      (setq grep-programs (cdr grep-programs)))))
      (setq exec-directories (cdr exec-directories)))
    program-obarray)
  "An obarray of available `grep` programs, passed by `igrep-read-program'
to `completing-read' when `igrep-program' is nil.")</t>
<t tx="ekr.20040713132127.26">(defvar igrep-use-zgrep
  (if (intern-soft "zgrep" igrep-program-table)
      'files)
  "If t, `\\[igrep]' searches files using the GNU (gzip) `zPROGRAM` script;
If not t but non-nil, `\\[igrep]' searches compressed FILES using `zPROGRAM`;
if nil, `\\[igrep]' searches files with `PROGRAM`.")</t>
<t tx="ekr.20040713132127.27">(defvar igrep-find nil
  "If non-nil, `\\[igrep]' searches directories using `find`.
See `igrep-find'.")</t>
<t tx="ekr.20040713132127.28">(defvar igrep-find-program "find"
  "The program run by `\\[igrep-find]'.")</t>
<t tx="ekr.20040713132127.29">(defvar igrep-find-prune-clause
  (if (equal (call-process igrep-find-program nil nil nil
			   igrep-null-device "-prune")
	     0)
      (format "-type d %s -name RCS -o -name CVS -o -name SCCS %s"
	      (shell-quote-argument "(")
	      (shell-quote-argument ")")))
  "The `find` clause used to prune directories, or nil;
see `igrep-find'.")</t>
<t tx="ekr.20040713132127.30">(defvar igrep-find-file-clause
  (format "-type f %s -name %s %s -name %s %s -name %s" ; -type l
	  (shell-quote-argument "!")
	  (shell-quote-argument "*~")	; Emacs backup
	  (shell-quote-argument "!")
	  (shell-quote-argument "*,v")	; RCS file
	  (shell-quote-argument "!")
	  (shell-quote-argument "s.*"))	; SCCS file
  "The `find` clause used to filter files passed to `grep`, or nil;
see `igrep-find'.")</t>
<t tx="ekr.20040713132127.31">(defvar igrep-find-use-xargs
  (if (equal (call-process igrep-find-program nil nil nil
			   igrep-null-device "-print0")
	     0)
      'gnu)
  "If `gnu', `\\[igrep-find]' executes
	`find ... -print0 | xargs -0 -e grep ...`;
if not `gnu' but non-nil, `\\[igrep-find]' executes
	`find ... -print | xargs -e grep ...`;
if nil, `\\[igrep-find]' executes
	`find ... -exec grep ...`.")</t>
<t tx="ekr.20040713132127.32">(defvar igrep-program-default "grep"
  "The default `grep` program, passed by `igrep-read-program'
to `completing-read' when `igrep-program' is nil.")</t>
<t tx="ekr.20040713132127.33">


;;; Internal variables:

</t>
<t tx="ekr.20040713132127.34">(defvar igrep-expression-history '()
  "The minibuffer history list for `\\[igrep]'s EXPRESSION argument.")</t>
<t tx="ekr.20040713132127.35">(defvar igrep-files-history '()
  "The minibuffer history list for `\\[igrep]'s FILES argument.")</t>
<t tx="ekr.20040713132127.36">


;;; Commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.37">(defun igrep-insinuate (&amp;optional override)
  "Define `grep' aliases for the corresponding `igrep' commands.
With a prefix arg, override the current `grep` command definitions."
  (interactive "P")
  (if override
      (defalias 'grep 'igrep)
    (defadvice grep (around igrep-interactive first (&amp;rest command-args)
			    activate)
      "If called interactively, use the `\\[igrep]' interface instead,
where COMMAND-ARGS is (PROGRAM EXPRESSION FILES [OPTIONS]);
if called programmatically, COMMAND-ARGS is still (COMMAND)."
      (interactive (igrep-read-args))
      (if (interactive-p)
	  (apply 'igrep command-args)
	ad-do-it)))
  (if (or (not (fboundp 'grep-find))
	  override)
      (defalias 'grep-find 'igrep-find))
  (if (or (not (fboundp 'dired-do-grep))
	  override)
      (defalias 'dired-do-grep 'dired-do-igrep))
  (if (or (not (fboundp 'dired-do-grep-find))
	  override)
      (defalias 'dired-do-grep-find 'dired-do-igrep-find))
  (if (or (not (fboundp 'Buffer-menu-grep))
	  override)
      (defalias 'Buffer-menu-grep 'Buffer-menu-igrep)))</t>
<t tx="ekr.20040713132127.38">

;;;###autoload
</t>
<t tx="ekr.20040713132127.39">(defun igrep (program expression files &amp;optional options)
  "*Run `grep` PROGRAM to match EXPRESSION in FILES.
The output is displayed in the *igrep* buffer, which `\\[next-error]' and
`\\[compile-goto-error]' parse to find each line of matched text.

PROGRAM may be nil, in which case it defaults to `igrep-program'.

EXPRESSION is automatically quoted by `shell-quote-argument'.

FILES is either a file name pattern (expanded by the shell named by
`shell-file-name') or a list of file name patterns.

Optional OPTIONS is also passed to PROGRAM; it defaults to `igrep-options'.

If a prefix argument \
\(`\\[universal-argument]') \
is given when called interactively,
or if `igrep-read-options' is set, OPTIONS is read from the minibuffer.

If two prefix arguments \
\(`\\[universal-argument] \\[universal-argument]') \
are given when called interactively,
or if `igrep-read-multiple-files' is set, FILES is read from the minibuffer
multiple times.

If three prefix arguments \
\(`\\[universal-argument] \\[universal-argument] \\[universal-argument]') \
are given when called interactively,
or if `igrep-read-options' and `igrep-read-multiple-files' are set,
OPTIONS is read and FILES is read multiple times.

If `igrep-find' is non-nil, the directory or directories
containing FILES is recursively searched for files whose name matches
the file name component of FILES (and whose contents match EXPRESSION)."
  (interactive
   (igrep-read-args))
  (if (null program)
      (setq program (or igrep-program "grep")))
  (if (null options)
      (setq options igrep-options))
  (if (not (listp files))		; (stringp files)
      (setq files (list files)))
  (if (and (member ?~ (mapcar 'string-to-char files))
	   (save-match-data
	     (string-match "\\`[rj]?sh\\(\\.exe\\)?\\'"
			   (file-name-nondirectory shell-file-name))))
      ;; (restricted, job-control, or standard) Bourne shell doesn't expand ~:
      (setq files
	    (mapcar 'expand-file-name files)))
  (let* ((use-zgrep (cond ((eq igrep-use-zgrep t))
			  (igrep-use-zgrep
			   (let ((files files)
				 (compressed-p nil))
			     (while (and files (not compressed-p))
			       (if (save-match-data
				     (string-match "\\.g?[zZ]\\'" (car files)))
				   (setq compressed-p t))
			       (setq files (cdr files)))
			     compressed-p))
			  (t nil)))
	 (command (format "%s -n %s %s %s %s %s"
			  (if (and use-zgrep
				   (save-match-data
				     (not (string-match "\\`z" program))))
			      (setq program (concat "z" program))
			    program)
			  (or options "")
			  (or igrep-expression-option
			      (progn
				(if (save-match-data
				      (string-match "\\`-" expression))
				    (setq expression (concat "\\" expression)))
				""))
			  (shell-quote-argument expression)
			  (if igrep-find
			      (if igrep-find-use-xargs
				  ""
				(shell-quote-argument "{}"))
			    (mapconcat (lambda (file)
					 (let ((dir (file-name-directory file)))
					   (if dir
					       (expand-file-name
						(file-name-nondirectory file)
						(shell-quote-argument dir))
					     file)))
				       files " "))
			  igrep-null-device)))
    (if igrep-find
	(setq command
	      (igrep-format-find-command command files)))
    (cond ((eq igrep-save-buffers t) (save-some-buffers t))
	  (igrep-save-buffers (save-some-buffers)))
    (compile-internal command (format "No more %s matches" program)
		      "igrep" nil grep-regexp-alist)))</t>
<t tx="ekr.20040713132127.40">

;; Analogue commands:

(defmacro igrep-define (analogue-command &amp;rest igrep-bindings)
  "Define ANALOGUE-COMMAND as an `igrep' analogue command.
Optional (VARIABLE VALUE) arguments specify temporary bindings for the command."
;;;  (interactive "SCommand: ") ; C-u =&gt; read bindings?
  (let ((analogue-program (symbol-name analogue-command)))
    `(defun ,analogue-command (&amp;rest igrep-args)
       ,(format "*Run `%s` via `\\[igrep]'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
		analogue-program)
       (interactive
	(let ((igrep-program (if igrep-program ,analogue-program))
	      (igrep-program-default ,analogue-program))
	  (igrep-read-args)))
       (let (,@ igrep-bindings)
	 (apply 'igrep
		(cond ((interactive-p) (car igrep-args))
		      ((car igrep-args))
		      (t ,analogue-program))
		(cdr igrep-args))))))

(igrep-define egrep)
(igrep-define fgrep)
(igrep-define agrep
  (igrep-use-zgrep nil)
  (igrep-expression-option "-e"))


;; Recursive (`find`) commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.41">(defun igrep-find (&amp;rest igrep-args)
  "*Run `grep` via `find`; see `igrep' and `igrep-find'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
  (interactive
   (let ((igrep-find t))
     (igrep-read-args)))
  (let ((igrep-find t))
    (apply 'igrep igrep-args)))</t>
<t tx="ekr.20040713132127.42">

;; Analogue recursive (`find`) commands:

(defmacro igrep-find-define (analogue-command &amp;rest igrep-bindings)
  "Define ANALOGUE-COMMAND-find as an `igrep' analogue `find` command.
Optional (VARIABLE VALUE) arguments specify temporary bindings for the command."
;;;  (interactive "SCommand: ") ; C-u =&gt; read bindings?
  (let ((analogue-program (symbol-name analogue-command)))
    (setq analogue-command
	  (intern (format "%s-find" analogue-command)))
    `(defun ,analogue-command (&amp;rest igrep-args)
       ,(format "*Run `%s` via `\\[igrep-find]'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
		analogue-program)
       (interactive
	(let ((igrep-program (if igrep-program ,analogue-program))
	      (igrep-program-default ,analogue-program)
	      (igrep-find t))
	  (igrep-read-args)))
       (let (,@ igrep-bindings)
	 (apply 'igrep-find
		(cond ((interactive-p) (car igrep-args))
		      ((car igrep-args))
		      (t ,analogue-program))
		(cdr igrep-args))))))

(igrep-find-define egrep)
(igrep-find-define fgrep)
(igrep-find-define agrep
  (igrep-use-zgrep nil)
  (igrep-expression-option "-e"))

;;;###autoload
</t>
<t tx="ekr.20040713132127.43">(defun igrep-visited-files (program expression &amp;optional options)
  "*Run `grep` PROGRAM to match EXPRESSION (with optional OPTIONS) \
on all visited files.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args (igrep-read-args 'no-files)))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     igrep-args))
  (igrep program expression
	 (let ((directory-abbrev-alist
		(cons (cons (regexp-quote (expand-file-name default-directory))
			    "./")	; or even ""
		      directory-abbrev-alist)))
	   (mapcar 'abbreviate-file-name
		   (apply 'nconc
			  (mapcar (lambda (buffer)
				    (let ((file (buffer-file-name buffer)))
				      (if (and file
					       (cond ((featurep 'ange-ftp)
						      (not (ange-ftp-ftp-name file)))
						     ((featurep 'efs)
						      (not (efs-ftp-path file)))
						     (t t))
					       ;; (file-exists-p file)
					       )
					  (list file))))
				  (buffer-list)))))
	 options))</t>
<t tx="ekr.20040713132127.44">


;; Dired commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.45">(defun dired-do-igrep (program expression &amp;optional options arg)
  "*Run `grep` on the marked (or next prefix ARG) files.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args
	  (let ((current-prefix-arg nil))
	    (igrep-read-args t))))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     ;; Append ARG:
     (nconc igrep-args (list current-prefix-arg))))
  (igrep program
	 expression
	 (funcall (cond ((fboundp 'dired-get-marked-files) ; GNU Emacs
			 'dired-get-marked-files)
			((fboundp 'dired-mark-get-files) ; XEmacs
			 'dired-mark-get-files))
		  t arg)
	 options))</t>
<t tx="ekr.20040713132127.46">



;; Dired recursive (`find`) commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.47">(defun dired-do-igrep-find (program expression &amp;optional options arg)
  "*Run `grep` on the marked (or next prefix ARG) directories.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args
	  (let ((current-prefix-arg nil)
		(igrep-find t))
	    (igrep-read-args t))))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     ;; Append ARG:
     (nconc igrep-args (list current-prefix-arg))))
  (let ((igrep-find t))
    (dired-do-igrep program expression options arg)))</t>
<t tx="ekr.20040713132127.48">



;; Buffer menu commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.49">(defun Buffer-menu-igrep (program expression &amp;optional options)
  "*Run `grep` on the files visited in buffers marked with '&gt;'.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args (igrep-read-args 'no-files)))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     igrep-args))
  ;; See Buffer-menu-select:
  (let ((marked-files '())
	marked-buffer
	file)
    (goto-char (point-min))
    (while (search-forward "\n&gt;" nil t)
      (setq marked-buffer (Buffer-menu-buffer t)
	    file (buffer-file-name marked-buffer))
      (if (and file
	       ;; local:
	       (cond ((featurep 'ange-ftp)
		      (not (ange-ftp-ftp-name file)))
		     ((featurep 'efs)
		      (not (efs-ftp-path file)))
		     (t t)))
	  (setq marked-files (cons file marked-files)))
;;;    (let ((buffer-read-only nil))
;;;      (delete-char -1)
;;;      (insert ?\ ))
      )
    (setq marked-files (nreverse marked-files))
    (igrep program expression
	   (let ((directory-abbrev-alist
		  (cons (cons (regexp-quote (expand-file-name default-directory))
			      "./")	; or even ""
			directory-abbrev-alist)))
	     (mapcar 'abbreviate-file-name marked-files))
	   options)))</t>
<t tx="ekr.20040713132127.50">


;;; User functions:

</t>
<t tx="ekr.20040713132127.51">(defun igrep-dired-file-current-word ()
  "Return the current word in the file on this line, if it is visible;
else, return the file name on this line, if there is one;
otherwise, return the current word."
  (let* ((dired-file
	  (dired-get-filename t t))
	 (dired-file-buffer
	  (if dired-file
	      (get-file-buffer (expand-file-name dired-file))))
	 (dired-file-buffer-window
	  (if dired-file-buffer
	      (get-buffer-window dired-file-buffer))))
    (cond (dired-file-buffer-window (save-excursion
				      (set-buffer dired-file-buffer)
				      (current-word)))
	  (dired-file)
	  (t (current-word)))))</t>
<t tx="ekr.20040713132127.52">(defun igrep-buffer-file-name-pattern ()
  "Return a shell file name pattern based on `buffer-file-name', or \"*\"."
  ;; (Based on other-possibly-interesting-files in ~/as-is/unix.el, by
  ;; Wolfgang Rupprecht &lt;wolfgang@mgm.mit.edu&gt;.)
  (if buffer-file-name
      (let ((file-name (file-name-nondirectory buffer-file-name)))
	(concat "*"
		(save-match-data
		  (if (string-match "\\.[^.]+\\(\\.g?[zZ]\\)?\\'"
				    file-name)
		      (substring file-name (match-beginning 0)
				 (match-end 0))))))
    "*"))</t>
<t tx="ekr.20040713132127.53">(defun igrep-dired-directory-file-pattern ()
"Return a shell file name pattern based on `dired-directory', or \"*\"."
  (cond ((stringp dired-directory)
	 (if (file-directory-p dired-directory)
	     "*"
	   (file-name-nondirectory dired-directory))) ; wildcard
	((consp dired-directory)	; (DIR FILE ...)
	 (mapconcat 'identity (cdr dired-directory) " "))))</t>
<t tx="ekr.20040713132127.54">


;;; Utilities:

(defsubst igrep-file-directory (name)
  "Return the directory component of NAME, or \".\" if it has no
directory component."
  (directory-file-name (or (file-name-directory name)
			   (file-name-as-directory "."))))

(defsubst igrep-file-pattern (name)
  "Return the file component of NAME, or \"*\" if it has no file component."
  (let ((pattern (file-name-nondirectory name)))
       (if (string= pattern "")
	   "*"
	 pattern)))

</t>
<t tx="ekr.20040713132127.55">(defun igrep-format-find-command (command files)
  "Format `grep` COMMAND to be invoked via `find` on FILES."
  (let ((directories '())
	(patterns '()))
    (while files
      (let ((dir (igrep-file-directory (car files)))
	    (pat (igrep-file-pattern (car files))))
	(if (and (not (string= dir "."))
		 (file-symlink-p dir))
	    (setq dir (concat dir "/.")))
	(if (not (member dir directories))
	    (setq directories (cons dir directories)))
	(cond ((equal pat "*")
	       (setq patterns t))
	      ((and (listp patterns)
		    (not (member pat patterns)))
	       (setq patterns (cons pat patterns)))))
      (setq files (cdr files)))
    (format (cond ((eq igrep-find-use-xargs 'gnu)
		   ;; | \\\n
		   "%s %s %s %s %s -print0 | xargs -0 -e %s")
		  (igrep-find-use-xargs
		   ;; | \\\n
		   "%s %s %s %s %s -print | xargs -e %s")
		  (t
		   "%s %s %s %s %s -exec %s %s"))
	    igrep-find-program
	    (mapconcat 'shell-quote-argument (nreverse directories)
		       " ")
	    (if igrep-find-prune-clause
		(format "%s -prune -o" igrep-find-prune-clause)
	      "")
	    (or igrep-find-file-clause "")
	    (if (listp patterns)
		(if (cdr patterns)	; (&gt; (length patterns) 1)
		    (format "%s %s %s"
			    (shell-quote-argument "(")
			    (mapconcat (lambda (pat)
					 (format "-name %s"
						 (shell-quote-argument pat)))
				       (nreverse patterns)
				       " -o ")
			    (shell-quote-argument ")"))
		  (format "-name %s" (shell-quote-argument (car patterns))))
	      "")
	    command
	    (shell-quote-argument ";")
	    )))</t>
<t tx="ekr.20040713132127.56">

(defmacro igrep-default-arg (variable)
  "Return the default arg based on VARIABLE."
  `(if ,variable
       (cond ((get (quote ,variable) major-mode)
	      (funcall (get (quote ,variable) major-mode)))
	     (t (funcall ,variable)))))

</t>
<t tx="ekr.20040713132127.57">(defun igrep-default-expression ()
  (igrep-default-arg igrep-expression-default))</t>
<t tx="ekr.20040713132127.58">(defun igrep-default-files ()
  (let* ((dired-subdirectory (if (eq major-mode 'dired-mode)
				 (dired-current-directory t)))
	 (default-files (igrep-default-arg igrep-files-default)))
    (if (not (listp default-files))	; stringp
	(setq default-files (list default-files)))
    (if dired-subdirectory
	(mapcar (lambda (file)
		  (concat dired-subdirectory file))
		default-files)
      default-files)))</t>
<t tx="ekr.20040713132127.59">

(defsubst igrep-prefix (prefix string &amp;rest strings)
  "If PREFIX is non-nil or any STRINGS are specified, concatenate them
before and after STRING; otherwise, return the STRING."
  (if (or prefix strings)
      (apply 'concat prefix string strings)
    string))

</t>
<t tx="ekr.20040713132127.60">(defun igrep-read-args (&amp;optional no-files)
  "Read and return a list: (PROGRAM EXPRESSION FILES OPTIONS).
If NO-FILES is non-nil, then FILES is not read and nil is returned
in its place."
  (let* ((pre-prefix (if (and igrep-find (eq igrep-verbose-prompts t))
			 "[find] "))
	 (program
	  (igrep-read-program pre-prefix))
	 (prefix (if (and program (eq igrep-verbose-prompts t))
		     (igrep-prefix pre-prefix program " ")
		   pre-prefix))
	 (options
	  (igrep-read-options prefix))
	 (post-prefix (if (and options (eq igrep-verbose-prompts t))
			    (igrep-prefix prefix options " ")
			  prefix)))
    (list program
	  (igrep-read-expression post-prefix)
	  (if (not no-files)
	      (igrep-read-files post-prefix))
	  options)))</t>
<t tx="ekr.20040713132127.61">(defun igrep-read-program (&amp;optional prompt-prefix)
  "If `igrep-program' is nil, read and return a program name from the
minibuffer; otherwise, return `igrep-program'.
Optional PROMPT-PREFIX is prepended to the \"Program: \" prompt."
  (or igrep-program
      (let ((prompt "Program: "))
	(completing-read (igrep-prefix prompt-prefix prompt) igrep-program-table
			 nil t igrep-program-default))))</t>
<t tx="ekr.20040713132127.62">(defun igrep-read-options (&amp;optional prompt-prefix)
  "If `current-prefix-arg' is '(4) or '(64), read and return an options
string from the minibuffer; otherwise, return `igrep-options'.
Optional PROMPT-PREFIX is prepended to the \"Options: \" prompt."
  (if (or igrep-read-options
	  (and (consp current-prefix-arg)
	       (memq (prefix-numeric-value current-prefix-arg)
		     '(4 64))))
      (let ((prompt "Options: "))
	(read-string (igrep-prefix prompt-prefix prompt)
		     (or igrep-options "-")))
    igrep-options))</t>
<t tx="ekr.20040713132127.63">(defun igrep-read-expression (&amp;optional prompt-prefix)
  "Read and return a `grep` expression string from the minibuffer.
Optional PROMPT-PREFIX is prepended to the \"Expression: \" prompt."
  (if igrep-insert-default-key
      (define-key minibuffer-local-map igrep-insert-default-key
	'igrep-insert-default-expression))
  (let* ((default-expression (igrep-default-expression))
	 (prompt (igrep-prefix prompt-prefix
			       (if default-expression
				   (format "Expression [default: %s]: "
					   default-expression)
				 "Expression: ")))
	 (expression (cond ((and (featurep 'xemacs) (emacs-version&gt;= 21 4))
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history
						  nil ; ABBREV-TABLE
						  default-expression))
			   ((and (not (featurep 'xemacs))
				 (&gt;= emacs-major-version 20))
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history
						  default-expression))
			   (t
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history)))))
    (if (equal expression "")
	(progn
	  (or (equal default-expression (car igrep-expression-history))
	      (setq igrep-expression-history
		    (cons default-expression igrep-expression-history)))
	  default-expression)
      expression)))</t>
<t tx="ekr.20040713132127.64">(defun igrep-insert-default-expression (&amp;optional clear-minibuffer)
  "*Insert the default expression in the minibuffer.
If a prefix argument is specified, clear the minibuffer contents first."
  (interactive "P")
  (if clear-minibuffer
      (delete-region (if (fboundp 'minibuffer-prompt-end) ; Emacs 21
			 (minibuffer-prompt-end)
		       (point-min))
		     (point-max)))
  (insert (or (save-excursion
		(set-buffer (window-buffer minibuffer-scroll-window))
		(igrep-default-expression))
	      "")))</t>
<t tx="ekr.20040713132127.65">(defun igrep-insert-default-files (&amp;optional clear-minibuffer)
  "*Insert the default files in the minibuffer.
If a prefix argument is specified, clear the minibuffer contents first."
  (interactive "P")
  (if clear-minibuffer
      (delete-region (if (fboundp 'minibuffer-prompt-end) ; Emacs 21
			 (minibuffer-prompt-end)
		       (point-min))
		     (point-max)))
  (insert (mapconcat 'identity
		     (save-excursion
		       (set-buffer (window-buffer minibuffer-scroll-window))
		       (igrep-default-files))
		     " ")))</t>
<t tx="ekr.20040713132127.66">

(defsubst igrep-default-key (command &amp;optional keymap key)
  "Return the key bound to COMMAND in KEYMAP, preferably KEY."
  (if (null keymap)
      (setq keymap (current-global-map)))
  (if (and key
	   (eq (lookup-key keymap key) command))
      key
    (where-is-internal command keymap t)))

</t>
<t tx="ekr.20040713132127.67">(defun igrep-read-files (&amp;optional prompt-prefix)
  "Read and return a file name pattern from the minibuffer.
If `current-prefix-arg' is '(16) or '(64), read multiple file name
patterns and return them in a list.  Optional PROMPT-PREFIX is
prepended to the \"File(s): \" prompt."
  (let* ((default-files (igrep-default-files))
	 (default-files-string (mapconcat 'identity default-files " "))
	 (insert-default-directory nil)	; use relative path names
	 (file (igrep-read-file-name
		(igrep-prefix prompt-prefix
			      (if default-files
				  (format "File(s) [default: %s]: "
					  default-files-string)
				"File(s): "))
		nil default-files-string nil nil
		'igrep-files-history))
	 (files (cond ((equal file default-files-string)
		       (setq file default-files))
		      ((not (listp file))
		       (setq file (list file))))))
    (if (or igrep-read-multiple-files
	    (and (consp current-prefix-arg)
		 (memq (prefix-numeric-value current-prefix-arg)
		       '(16 64))))
	(let ((prompt
	       (igrep-prefix prompt-prefix
			     (if igrep-verbose-prompts
				 (format "File(s): [Type `%s' when done] "
					 (key-description
					  (igrep-default-key 'exit-minibuffer
							     minibuffer-local-completion-map
							     "\r")))
			       "File(s): "))))
	  (while (not (string= (setq file
				     (igrep-read-file-name prompt
							   nil "" nil nil
							   'igrep-files-history))
			       ""))
	    (setq files (cons file files)))
	  (nreverse files))
      files)))</t>
<t tx="ekr.20040713132127.68">(defun igrep-read-file-name (prompt
  &amp;optional directory default existing initial history)
  "Just like `read-file-name', but with optional HISTORY.
Also: convert DIRECTORY to DIRECTORY/* file name pattern."
  (if igrep-insert-default-key
      (define-key minibuffer-local-completion-map igrep-insert-default-key
	'igrep-insert-default-files))
  (let ((file-name
	 (if history
	     (let ((file-name-history (symbol-value history)))
	       (prog1 (read-file-name prompt directory default existing initial)
		 (set history file-name-history)))
	   (read-file-name prompt directory default existing initial))))
    (if (and (not (string-equal file-name ""))
	     (file-directory-p file-name))
	(expand-file-name "*" file-name)
      file-name)))</t>
<t tx="ekr.20040713132127.69">
;;; Local Variables:
;;; eval: (put 'igrep-define 'lisp-indent-hook 1)
;;; eval: (put 'igrep-find-define 'lisp-indent-hook 1)
;;; End:

;;;; igrep.el ends here
</t>
<t tx="ekr.20040713133131">; -&gt; #

'x --&gt; x (??)

"multilline comment" --&gt; """multilline comment"""

strip parens from cond, etc.</t>
<t tx="ekr.20040713133131.1">defFun -&gt; def

lambda -&gt; ?

cond -&gt; if, elif, ... else

prog, progn -&gt; while

defvar x y --&gt; x = y  (or self.x = y) ??</t>
<t tx="ekr.20040713133131.2">(if (equal (call-process igrep-program nil nil nil
			   "-e" "foo" igrep-null-device)
	     1)
      "-e")

if (&lt; emacs-major-version 20) "\C-c\C-e")  -&gt; if &lt;cond&gt;: &lt;val&gt;

(&lt; a b) --&gt; a &lt; b

(x args) --&gt; x(args)</t>
<t tx="ekr.20040713144036">class elisp2pyClass:
    
    """A class to convert elisp programs into Python syntax."""
    
    @others</t>
<t tx="ekr.20040713144036.1">def __init__ (self,c,p,*args,**keys):
    
    self.c = c
    self.p = p
    self.tabwidth = 4

    &lt;&lt; define elisp constants &gt;&gt;
    &lt;&lt; define elisp statements &gt;&gt;
    &lt;&lt; define elisp functions &gt;&gt;
    
    self.allStatements = list(self.statements)
    self.allStatements.extend(self.functions)
    
    &lt;&lt; define code gen dispatch table &gt;&gt;</t>
<t tx="ekr.20040713144336"></t>
<t tx="ekr.20040713144926">def tokenize (self,s):
    
    e = self
    name1 = string.letters + '_'
    result = []
    if not s.strip():
        return result

    i = 0 ; n = len(s) ; progress = -1
    while i &lt; n:
        assert(i &gt; progress)
        progress = i
        ch = s[i]
        if ch == '\r':
            i += 1
        elif ch in "@'()[]{}&lt;&gt;\n": # Handle single-quote here?
            result.append(tok(ch,ch))
            i += 1
        elif ch in "\ \t":
            j = g.skip_ws(s,i) # Doesn't handle ff, so ff loops.
            ws = s[i:j]
            result.append(tok("ws",ws))
            i = j
        elif ch == '\f':
            result.append(tok("form-feed",'\f'))
            i += 1
        elif ch == '"':
            j = e.skipString(s,i)
            val = s[i:j]
            result.append(tok("string",val))
            i = j
        elif ch in name1:
            j = g.skip_id(s,i,chars='-*') # '-*' valid in elisp.
            val = s[i:j]
            result.append(tok("id",val))
            i = j
        elif ch in string.digits:
            j,value = g.skip_long(s,i)
            val = s[i:j]
            result.append(tok("number",val))
            i = j
        elif ch == ';':
            j = g.skip_to_end_of_line(s,i)
            val = s[i:j]
            result.append(tok("comment",val))
            i = j
        else:
            result.append(tok("misc",ch))
            i += 1
            
    return result</t>
<t tx="ekr.20040713144926.1"></t>
<t tx="ekr.20040713144926.2"></t>
<t tx="ekr.20040713144926.3"></t>
<t tx="ekr.20040713144926.4"></t>
<t tx="ekr.20040713150037">class tok:
    
    """ A class representing an elisp or python token"""
    
    @others</t>
<t tx="ekr.20040713150037.1">def __init__ (self,kind,val="",parseTree=None):
    
    self.kind = kind
    self.val = val
    self.parseTree = parseTree</t>
<t tx="ekr.20040713150314.1">def replaceAll (self,tokens,findKind,changeTok):
    
    self = e

    result = []
    for token in tokens:
        if token.kind == findKind:
            result.append(changeTok.copy())
        else:
            result.append(token)</t>
<t tx="ekr.20040713150712">def copy (self,token):
    
    return tok(self.kind,self.val)</t>
<t tx="ekr.20040713150856.1"></t>
<t tx="ekr.20040713150856.8">@ These scanners all call g.scanError() directly or indirectly, so they will call g.es() if they find an error.  g.scanError() also bumps c.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="ekr.20040713150856.9"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

    assert(g.match(s,i,"/*"))
    j = i ; i += 2 ; n = len(s)
    
    k = string.find(s,"*/",i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    else: return k + 2</t>
<t tx="ekr.20040713150856.10">@ This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

    """Skips from the opening to the matching brace.
    
    If no matching is found i is set to len(s)"""

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,'//'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        # 7/29/02: be more careful handling conditional code.
        elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta = g.skip_pp_if(s,i)
            level += delta
        else: i += 1
    return i
</t>
<t tx="ekr.20040713150856.12">def skip_parens(s,i):

    """Skips from the opening ( to the matching ).
    
    If no matching is found i is set to len(s)"""

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))
    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:  return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i</t>
<t tx="ekr.20040713150856.13">def skip_pascal_begin_end(s,i):

    """Skips from begin to matching end.
    If found, i points to the end. Otherwise, i &gt;= len(s)
    The end keyword matches begin, case, class, record, and try."""

    assert(g.match_c_word(s,i,"begin"))
    level = 1 ; i = g.skip_c_id(s,i) # Skip the opening begin.
    while i &lt; len(s):
        ch = s[i]
        if ch =='{' : i = g.skip_pascal_braces(s,i)
        elif ch =='"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.match_c_word(s,i,"end"):
            level -= 1 ;
            if level == 0:
                # lines = s[i1:i+3] ; g.trace('\n' + lines + '\n')
                return i
            else: i = g.skip_c_id(s,i)
        elif g.is_c_id(ch):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else: i += 1
    return i
</t>
<t tx="ekr.20040713150856.14"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):
    
    j = i
    assert(g.match(s,i,"(*"))
    i = string.find(s,"*)",i)
    if i &gt; -1: return i + 2
    else:
        g.scanError("Run on comment" + s[j:i])
        return len(s)</t>
<t tx="ekr.20040713150856.15">def skip_pascal_string(s,i):

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    while i &lt; len(s):
        if s[i] == delim:
            return i + 1
        else: i += 1

    g.scanError("Run on string: " + s[j:i])
    return i</t>
<t tx="ekr.20040713150856.20">def skip_python_string(s,i):

    if g.match(s,i,"'''") or g.match(s,i,'"""'):
        j = i ; delim = s[i]*3 ; i += 3
        k = string.find(s,delim,i)
        if k &gt; -1: return k+3
        g.scanError("Run on triple quoted string: " + s[j:i])
        return len(s)
    else:
        return g.skip_string(s,i)</t>
<t tx="ekr.20040713150856.21">def skip_string(s,i):
    
    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')
    
    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20040713150856.22"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c == ';': return i
        elif c == '\'' or c == '"' : i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i</t>
<t tx="ekr.20040713150856.24"></t>
<t tx="ekr.20040713150856.25"># Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 &gt;= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1</t>
<t tx="ekr.20040713150856.26">def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1</t>
<t tx="ekr.20040713150856.27">def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k &gt; -1: return k
    else: return None</t>
<t tx="ekr.20040713150856.28">def is_c_id(ch):

    return ch and (ch in string.ascii_letters or ch in string.digits or ch == '_')
</t>
<t tx="ekr.20040713150856.29">def is_nl(s,i):

    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')</t>
<t tx="ekr.20040713150856.30"># We no longer require that the directive appear before any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i &lt; len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1</t>
<t tx="ekr.20040713150856.31">def is_ws(c):

    return c == '\t' or c == ' '
    
def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i &lt; len(s) and g.is_ws(s[i]))</t>
<t tx="ekr.20040713150856.32"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i</t>
<t tx="ekr.20040713150856.33">def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))</t>
<t tx="ekr.20040713150856.34">def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)</t>
<t tx="ekr.20040713150856.35">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if string.find(s,pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    c = s[i+j]
    return not (c in string.ascii_letters or c in string.digits or c == '_')</t>
<t tx="ekr.20040713150856.36">def skip_blank_lines(s,i):

    while i &lt; len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i</t>
<t tx="ekr.20040713150856.37">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i</t>
<t tx="ekr.20040713150856.38">def skip_id(s,i,chars=None):

    n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
</t>
<t tx="ekr.20040713150856.39">@ These methods skip to the next newline, regardless of whether the newline may be preceded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i</t>
<t tx="ekr.20040713150856.40">def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i &lt; n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20040713150856.41">def skip_matching_delims(s,i,delim1,delim2):
    
    assert(g.match(s,i,delim1))

    i += len(delim1)
    k = string.find(s,delim2,i)
    if k == -1:
        return len(s)
    else:
        return k + len(delim2)</t>
<t tx="ekr.20040713150856.42"># We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i</t>
<t tx="ekr.20040713150856.43">def skip_non_ws (s,i):

    n = len(s)
    while i &lt; n and not g.is_ws(s[i]):
        i += 1
    return i</t>
<t tx="ekr.20040713150856.44"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k</t>
<t tx="ekr.20040713150856.45">def skip_to_char(s,i,ch):
    
    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
</t>
<t tx="ekr.20040713150856.46">def skip_ws(s,i):

    n = len(s)
    while i &lt; n and g.is_ws(s[i]):
        i += 1
    return i
    
def skip_ws_and_nl(s,i):

    n = len(s)
    while i &lt; n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i</t>
<t tx="ekr.20040713150856.47">def splitLines (s):
    
    """Split s into lines, preserving the number of lines and the ending of the last line."""
    
    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

def joinLines (aList):
    
    return ''.join(aList)</t>
<t tx="ekr.20040713151556.1">def findMatchingBracket(self,tokens,i):

    tok1 = tokens[i] ; i += 1
    assert tok1.kind in "({["
   
    if   tok1.kind == '(': delim = ')'
    elif tok1.kind == '{': delim = '}'
    else:                  delim = ']'

    level = 1
    while i &lt; len(tokens):
        tok = tokens[i]
        # g.trace(level,delim,tok.kind)
        i += 1
        if tok.kind == tok1.kind:
            level += 1
        elif tok.kind == delim:
            level -= 1
            if level == 0: return i-1

    self.warning("%s not matched by %s" % (tok1.kind,delim))
    return None</t>
<t tx="ekr.20040713152318">def warning (self,message):
    
    print "Error:", message

def warning (self,message):
    
    print "Warning:", message
</t>
<t tx="ekr.20040713152809"></t>
<t tx="ekr.20040713154118">def skipString(self,s,i):

    # Skip the opening double quote.
    i1 = i
    ch = s[i]
    i += 1
    assert(ch == '"')

    while i &lt; len(s):
        ch = s[i]
        i += 1
        if ch == '"': return i
        elif ch == '\\': i += 1

    self.warning("run-on elisp string:", g.get_line(s[i1:]))
    return i</t>
<t tx="ekr.20040713160302">def findTokens(self,tokens,i,findTokens):
    
    """Search for a match with findTokens.
    Return i,i+len(findTokens) if found, or None,None otherwise."""

    e = self
    
    while i &lt; len(tokens):
        
        if e.matchTokens(tokens,i,findTokens):
            return i,i+len(findTokens)
        else:
            i += 1

    return None,None # Not found</t>
<t tx="ekr.20040713161629.1">def dump (self,tokens,verbose=2,heading=""):
    
    e = self ; p = e.p ; v2 = verbose &gt;= 2
    
    if verbose == 0:
        return
    
    if heading: printHeading(heading,char='=',len=60)
    else:       printHeading(p.headString())
    
    if verbose == 1:
        vals = [tok.val for tok in tokens]
        s = ''.join(vals)
        s = g.toEncodedString(s,g.app.tkEncoding)
        print s
    elif verbose in (2,3):
       
        if verbose == 2:
            for tok in tokens:
                print tok.toString(verbose=verbose),
        else:
            for tok in tokens:
                print tok.toString(verbose=verbose)</t>
<t tx="ekr.20040713164604">def wsToString (self,ws):
    
    allBlanks = True
    for ch in ws:
        if ch != ' ':
            allBlanks = False
            
    if allBlanks:
       return "&lt;' '*%d&gt;" % len(ws)
    else:
        result = ["&lt;"]
        for ch in ws:
            if ch == ' ':
                result.append(" ")
            elif ch == '\t':
                result.append("tab")
            elif ch == '\f':
                result.append("feed")
            else:
                result.append("&lt;%s&gt;" % repr(ch)) # should never happen.
        
        result.append("&gt;")
        return ''.join(result)</t>
<t tx="ekr.20040713173923">def match (self,tok2):
    
    tok1 = self
    
    val = (
        tok2 is not None and
        tok1.kind == tok2.kind and
        (not tok1.val or not tok2.val or (tok1.val == tok2.val)))
        
    if 0:
        if tok1.kind==tok2.kind:
            g.trace(val,tok1.kind,repr(tok1.val),tok2.kind)
        
    return val</t>
<t tx="ekr.20040713174349">def dump (self,verbose=2):
    
    tok = self

    if verbose == 2:
        print tok.toString(verbose=verbose)
    else:
        print tok.toString(verbose=verbose),</t>
<t tx="ekr.20040713180208">def toString (self,verbose=2):
    
    tok = self
    
    if verbose &lt; 2: return
    val = tok.val or ""
    val = g.toEncodedString(val,g.app.tkEncoding)
    
    if tok.isParseTok():
        parseTree = parseTreeToString(tok.parseTree)
        if tok.val == "TREE":
            return "%s"% (parseTree)
        else:
            return "%s: %s"% (tok.val,parseTree)
    
    elif verbose == 2:
        if len(tok.kind) == 1:    return tok.kind
        elif tok.kind=="form-feed": return "\nform-feed\n"
        elif tok.kind=="comment":   return "&lt;comment&gt;\n"
        elif tok.kind=="string":    return "&lt;string&gt;"
        else:                       return val
    
    elif verbose == 3:
        if tok.kind == '\n':      return "%9s:" % "newline"
        elif tok.kind=="form-feed": return "%9s:" % "form-feed"
        elif len(tok.kind)==1:      return "%9s:" % tok.kind
        elif tok.kind == "ws":
                return "%9s: %s" % (tok.kind,tok.wsToString(val))
        else:   return "%9s: &lt;%s&gt;" % (tok.kind,val)</t>
<t tx="ekr.20040713193437">def deleteTokens (self,tokens,delToken):
            
    return [tok for tok in tokens if not tok.match(delToken)]</t>
<t tx="ekr.20040713200238">@language elisp</t>
<t tx="ekr.20040713205718">def createIndentedBlock (self,tokens,level):
    
    e = self ; p = e.p ; level1 = level
    
    i = 0
    while i &lt; len(tokens):
        t = tokens[i]
        if t.kind == '(':
            &lt;&lt; insert nl and ws tokens &gt;&gt;
            level += 1
            i += 3
        elif t.kind == ')':
            level -= 1 ; i += 1
        elif t.kind == "string" and level == level1:
            &lt;&lt; insert nl and ws tokens &gt;&gt;
            i += 3
        else:
            i += 1

    return tokens</t>
<t tx="ekr.20040713211010">def convert (self):
    
    e = self ; p = e.p

    e.tokens = e.tokenize(p.bodyString())
    e.tokens = e.deleteTokens(e.tokens,tok("ws"))
    e.tokens = e.deleteTokens(e.tokens,tok('\n'))
    disposableTokens = e.tokens[:]
    e.parseTree = e.parse(disposableTokens)

    e.codeList = [] ; e.indent = 0
    e.codeLine = lineClass(0) # The line being accumulated.
    e.gen(e.parseTree)

    if 0: # Old code
        e.tokens = e.removeBlankLines(e.tokens)</t>
<t tx="ekr.20040714053807.1">def isStatement (self,tokens,i):
    
    """Returns the statement or function f if (f is at tokens[i]."""
    
    e = self
    
    for s in e.allStatements:
        toks = [tok('('),tok('id',s)]
        if e.matchTokens(tokens,i,toks):
            return s

    return False
      
    
</t>
<t tx="ekr.20040714054620.1">def matchTokens (self,tokens,i,findTokens):
    
    """Return True if tokens match findTokens at position i."""

    j = 0
    while j &lt; len(findTokens):
        tok = tokens[i+j]
        ftok = findTokens[j]
        if not tok.match(ftok):
            return False
        j += 1
    return True</t>
<t tx="ekr.20040714055306"></t>
<t tx="ekr.20040714060941">def isMatchingBracket(self,tokens,i,j):
    
    toki = tokens[i]
    tokj = tokens[j]

    f1 = "({[".find(toki.kind)
    f2 = ")}]".find(tokj.kind)
    
    # g.trace(f1,f2,repr(toki.kind),repr(tokj.kind))
    
    return f1 == f2 and f1 != -1</t>
<t tx="ekr.20040714061625">self.constants = ("t","nil")</t>
<t tx="ekr.20040714061625.1">self.statements = (
    "defconst","defun","defsubst","defvar",
    "cond",
    "if",
    "let","let*",
    "prog","prog1","progn",
    "set","setq",
    "unless","when","while",
)

</t>
<t tx="ekr.20040714061625.2">self.functions = (
    "and","or","not",
    "apply","eval",
    "cons","car","cdr",
    "error","princ",
    "eq","ne","equal","gt","ge","lt","le",
    "mapcar","type-of",
)</t>
<t tx="ekr.20040714072448">def removeBlankLines (self,tokens):
    
    e = self
    
    i = 0
    while i &lt; len(tokens):
        
        if tokens[i].kind == '\n':
            j = i ; i += 1
            while i &lt; len(tokens) and tokens[i].kind == "ws":
                i += 1
            if i &gt;= len(tokens) or tokens[i].kind == '\n':
                del tokens[j:i]
                i = j
            else: i += 1
        else: i += 1
            
    return tokens</t>
<t tx="ekr.20040714074445">ws = tok("ws",' '*e.tabwidth*level)
nl = tok('\n','\n')
tokens.insert(i,nl)
tokens.insert(i+1,ws)</t>
<t tx="ekr.20040714082939"></t>
<t tx="ekr.20040714091940.1">def block (self,tokens):
    
    """Parse a block of tokens."""
    
    e = self

    i = 0 ; result = []
    while i &lt; len(tokens):
        if tokens[i].kind == '(':
            j = e.findMatchingBracket(tokens,i)
            if j is None:
                # To do: print error message.
                i += 1
            else:
                # Strip off the matching parens.
                block = tokens[i+1:j]
                # Recursively parse this block.
                result.append(e.parse(block,topLevel=False))
                i = j + 1
        else:
            result.append(tokens[i])
            i += 1

    return result</t>
<t tx="ekr.20040714095247">def parseTreeToString (parseTree,level=0,verbose=2):

    result = [] ; levelSpaces = ' '*2*level
    indent = False

    if parseTree is None:
        result.append("None")

    if isToken(parseTree):
        s = parseTree.toString(verbose=2)
        if s: result.append(s + ' ')

    elif isList(parseTree):
        if verbose &gt;= 2:
            result.append('\n%s[' % levelSpaces)
        else:
            result.append('[')
        for item in parseTree:
            s = parseTreeToString(item,level+1,verbose=verbose)
            if s: result.append(s)
        result.append(']')

    else:
        result.append("unknown type in parseTreeToString")
        
    return ''.join(result)</t>
<t tx="ekr.20040714154314">if fTok:
    e.error("No (%s has no matching ')'" % fTok.kind)
else:
    e.error("Mismatched parens")</t>
<t tx="ekr.20040714155341">def parse (self,tokens,topLevel=True):
    
    """A recursive-descent parser for elisp."""
    
    e = self
    i = 0
    while i &lt; len(tokens):
        # g.trace(tokens[i].kind)
        if tokens[i].kind != '(':
            i += 1 ; continue
        j = e.findMatchingBracket(tokens,i)
        fTok = i+1 &lt; len(tokens) and tokens[i+1]
        if j is None:
            &lt;&lt; give error message about mismatched parens &gt;&gt;
            i += 1 ; continue
        # Strip off the matching parens.
        block = tokens[i+1:j]
        parseTree = e.block(block)
        # A top-level token is helpful for dumping, etc.
        if topLevel: token = tok('TREE','TREE',parseTree)
        else:        token = parseTree
        tokens[i:j+1] = [token]
        # We are replacing everything by a _single_ token.
        i = i + 1 
            
    return tokens</t>
<t tx="ekr.20040714170021">def isParseTok (self):
    
    tok = self
    
    return type(tok.parseTree) == type([])</t>
<t tx="ekr.20040714222507"></t>
<t tx="ekr.20040715071350">def gen(self,object):
    
    """The top-level code generator.
    
    May be called recursively to generate inner parts of the tree."""
    
    e = self

    if isToken(object):
        t = object
        if t.kind == "TREE":
            e.gen(t.parseTree)
        else:
            e.gen_token(t,outerList=None)
        
    elif isList(object):
        e.gen_list(object)
            
    else:
        print "unknown object in parse tree:", repr(object)</t>
<t tx="ekr.20040715071555">(defun igrep-read-file-name (prompt
  &amp;optional directory default existing initial history)
  "Just like `read-file-name', but with optional HISTORY.
Also: convert DIRECTORY to DIRECTORY/* file name pattern."
  (if igrep-insert-default-key
      (define-key minibuffer-local-completion-map igrep-insert-default-key
	'igrep-insert-default-files))
  (let ((file-name
	 (if history
	     (let ((file-name-history (symbol-value history)))
	       (prog1 (read-file-name prompt directory default existing initial)
		 (set history file-name-history)))
	   (read-file-name prompt directory default existing initial))))
    (if (and (not (string-equal file-name ""))
	     (file-directory-p file-name))
	(expand-file-name "*" file-name)
      file-name)))</t>
<t tx="ekr.20040715073230">def isList (object):
    
    return type(object) == type([])

def isToken (object):
    
    return isinstance(object,tok)</t>
<t tx="ekr.20040715075845">def gen_token (self,t,outerList=None):
    
    e = self
    
    g.trace(t.kind,t.val)
    
    if 0: # Not yet.

        if t.kind == 'id' and t.val in e.allStatements:
            
            g.trace(t.toString())
            
            line = e.newCodeLine()
            line.add(t.val)
            
            # Only TREE tokens have parse trees.
            # We are _inside_ a parse tree.</t>
<t tx="ekr.20040715075914">def newCodeLine (self):
    
    e = self
    
    if e.codeLine:
        e.codeList.append(e.codeLine)
        
    e.codeLine = line = lineClass(e.indent) # Create a new line object.
    
    return line</t>
<t tx="ekr.20040715080216">class lineClass:
    
    """Represents a code line being accumulated."""
    
    @others</t>
<t tx="ekr.20040715080738">def __init__ (self,indent):
        
        self.parts = []
        self.indent = indent</t>
<t tx="ekr.20040715080738.1">def toString (self):
    
    line = self
    
    theList = [str(part) + ' ' for part in self.parts]
    
    return ' ' * 2 * self.indent + ''.join(theList)</t>
<t tx="ekr.20040715081031">def add (self,s):
    
    self.parts.append(s)</t>
<t tx="ekr.20040715081425">def dumpCodeList (self,codeList,heading=""):
    
    printHeading(heading,char='=',len=60)
    
    for line in codeList:
        
        print line.toString()</t>
<t tx="ekr.20040715082059">def printHeading (s,char='-',len=20):
    
    banner = char * len

    print
    print banner
    print s
    print banner
    print</t>
<t tx="ekr.20040715084435">def gen_list (self,theList):
    
    e = self
    
    assert(isList(theList))
    if not theList:
        return
        
    item1 = theList[0]

    if isToken(item1):
        # The normal case looks like a function call: "(id args)"
        # Handle all args here.
        t = item1
        if t.kind == "TREE":
            e.gen(t.parseTree)
        elif t.kind == 'id':
            e.gen_statement(t,theList[1:])
        else:
            g.trace("unexpected token",t.kind,t.val)
            name = None
            e.gen_function(name,theList)
    elif isList(item1):
        # The first item is a list.
        for arg in theList:
            e.gen(arg)
                
    else: g.trace("unknown item",item1)</t>
<t tx="ekr.20040715090957">self.code_gen_dispatch_dict = {

    "cond"      : self.gen_cond,     
    "defconst"  : self.gen_defconst,
    "defun"     : self.gen_defun,
    "defsubst"  : self.gen_defsubst, 
    "defvar"    : self.gen_defvar, 
    "if"        : self.gen_if,
    "let"       : self.gen_let, 
    "let*"      : self.gen_let_star, 
    "prog"      : self.gen_prog, 
    "prog1"     : self.gen_prog1, 
    "progn"     : self.gen_progn, 
    "set"       : self.gen_set, 
    "setq"      : self.gen_setq, 
    "unless"    : self.gen_unless, 
    "when"      : self.gen_when, 
    "while"     : self.gen_while,
}
</t>
<t tx="ekr.20040715090957.1">def gen_statement (self,t,args):
    
    e = self
    
    expr_names = (
        "and","or","not",
        "eq","ne","equal","gt","ge","lt","le",)
    
    assert(t.kind=='id')
    
    name = t.val # The name of the statement.
    f = e.code_gen_dispatch_dict.get(name)

    if f:
        # Syntax-specific code generators.
        f(args)
    elif name in expr_names:
        # We will try to simply expression.
        e.gen_expression(args)
    else:
        # Generic code generator.
        e.gen_function(name,args)</t>
<t tx="ekr.20040715090957.2"></t>
<t tx="ekr.20040715091409">def gen_function (self,name,args):
    
    e = self
    g.trace(len(args),name)
    for arg in args:
        e.gen(arg)</t>
<t tx="ekr.20040715093122">def gen_defun(self,args):
    
    e = self
    
    g.trace()
    
    if len(args) == 1:
        print "def %s ():" % parseTreeToString(args[0])
        
    elif len(args) &gt;= 2:
        
        print "def %s (%s):" % (
            parseTreeToString(args[0]),
            parseTreeToString(args[1]).strip())
            
    e.indent += 1

    for arg in args[2:]:
        e.gen(arg)
        
    e.indent -= 1</t>
<t tx="ekr.20040715093804"></t>
<t tx="ekr.20040715105834"></t>
<t tx="ekr.20040715120001">def gen_cond (self,t,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.1">def gen_defconst(self,t,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.2">def gen_defsubst(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.3">def gen_defvar(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.4">def gen_if(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.5">def gen_let(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

def gen_let_star(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

</t>
<t tx="ekr.20040715120001.7">def gen_prog(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_prog1(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_progn(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)</t>
<t tx="ekr.20040715120001.8">def gen_set(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_setq(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)</t>
<t tx="ekr.20040715120001.9">def gen_unless(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_when(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_while(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

</t>
<t tx="ekr.20040715121456">def gen_expression(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    
    if isList(args):
        for arg in args:
            e.gen_expression(arg)
    elif args:
        e.gen(args)
</t>
<t tx="ekr.20040715125453">def gen_computed_function (self,args):
    
    e = self

    g.trace()

    for arg in args:
        e.gen(arg)</t>
<t tx="ekr.20040717121014">print "gnx", p.v.t.fileIndex, p.headString()</t>
<t tx="ekr.20040721113934">import leoGlobals as g
import profile
import pstats

# Note: the profiled code should do all needed imports.
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','leoProfile.txt'))
path = str(path)

c = g.top() ; p = c.currentPosition()

if p.bodyString().rstrip():
    s = p.bodyString().rstrip() + '\n'
    profile.run(s,path)
    print '-' * 40
    print "Profiling info sent to %s" % path
    stats = pstats.Stats(path)
    stats.strip_dirs()
    stats.sort_stats('cum','file','name')
    stats.print_stats()
</t>
<t tx="ekr.20040721145258.1">import leoTest

leoTest.runGc(disable=True)</t>
<t tx="ekr.20040721153143">@language python</t>
<t tx="ekr.20040723065021">print '-' * 60

# Tag the start of the command.
c.undoer.setUndoParams("Change All",c.currentPosition())

n = 0 ; total = 0
for p in c.currentPosition().self_and_subtree_iter():
    total += 1
    body = p.bodyString()
    s = g.stripBlankLines(body)
    if s != body:
        n += 1
        p.setBodyStringOrPane(s,g.app.tkEncoding)
        c.undoer.setUndoParams("Change",p,
            oldText=body,newText=s,oldSel=None, newSel=None)

# Tag the end of the command.
c.undoer.setUndoParams("Change All",c.currentPosition()) 

print "%d nodes changed (%d total)" % (n,total)
</t>
<t tx="ekr.20040723065047">@ignore
a
  b
  
c  
  
last
  </t>
<t tx="ekr.20040804052804">import leoGlobals as g

c = g.top()

tracePositions = False
traceDrawing = True

# This trace catches leaks of positions.
g.app.tracePositions = tracePositions
    
# This trace shows overall position statistics.
c.frame.tree.trace = traceDrawing
c.frame.tree.verbose = True</t>
<t tx="ekr.20040804104328"></t>
<t tx="ekr.20040804104924">def vhash(self):  # v.__hash__
    v = self
    return "%s,%d" % (str(id(v)),v.childIndex())

def __hash__ (self):  # p.__hash__

    p = self
    if p.stack:
        vids = [vhash(v) for v in p.stack]
        return vhash(p.v) + ':' + ':'.join(vids)
    else:
        return vhash(p.v)
        
for p in c.currentPosition().self_and_subtree_iter():

    hash = __hash__(p)
    hash2 = __hash__(p.copy())
    assert hash==hash2, "hash for equivalent nodes are different: %s, %s" % (hash,hash2)
    print hash</t>
<t tx="ekr.20040804105026"></t>
<t tx="ekr.20040901065642">import string

#@count 10000
#@setup

s = ''
for i in range(0, 50):
    s += '%d'%i
s = string.replace(s, '2', '1')</t>
<t tx="ekr.20040901065642.2">@ Improved timeit script after an idea by 'e'.

Comments of the form #@count nnn set the repeat count.
Comments of the form #@setup comment delimits the end of setup code.
@c

try: import timeit # Exists only in Python 2.3 and above.
except ImportError: 
    timeit = None
    print "Can not import timeit"
import leoGlobals as g

c = g.top() ; p = c.currentPosition()

if timeit and p.bodyString().strip():
    s = p.bodyString().rstrip() + '\n'
    &lt;&lt; scan for #@count &gt;&gt;
    &lt;&lt; put setup code in s1 and everything else in s2 &gt;&gt;
    t = timeit.Timer(stmt=s2,setup=s1)
    try:
        if 1: # faster.
            result = t.timeit(count)
        else: # better results.
            result = min(t.repeat(3, count))  
        print "count: %d : %f %s" % (
            count, result, p.headString().strip())
    except:
        t.print_exc()</t>
<t tx="ekr.20040901071028">lines = s.split('\n')

for i in xrange(len(lines)):
    if lines[i].strip() == "#@setup":
        break
        
if i &lt; len(lines):
    # Split at the #@setup line and delete the #@setup line
    s1 = '\n'.join(lines[:i])
    s2 = '\n'.join(lines[i:])
    #print "setup",repr(s1)
    #print "code",repr(s2)
else:
    # There is no setup.
    s1 = None
    s2 = s
    
if not s1: s1 = 'pass'
if not s2: s2 = 'pass'</t>
<t tx="ekr.20040901072339">lines = s.split('\n')

count = 1000000 # default count
tag = "#@count"

for line in lines:
    i = g.skip_ws(line,0)
    if g.match(line,0,tag):
        i += len(tag)
        i = g.skip_ws(line,i)
        junk,val = g.skip_long(line,i)
        if val is not None:
            count = abs(val)
            # print "Setting count to",count
            break</t>
<t tx="ekr.20040915080419">for p in c.allNodes_iter():
    h = p.headString()
    if hasattr(p.v,'unknownAttributes'):   print 'v',h,p.v.unknownAttributes
    if hasattr(p.v.t,'unknownAttributes'): print 't',h,p.v.t.unknownAttributes</t>
<t tx="ekr.20040918093738">@ignore # To suppress syntax checking.</t>
<t tx="ekr.20040918093738.1">def py2tkIndex (s,n):
    """Convert n, a Python index into s, into a Tk index.
    This must be as fast as possible and must not allocate any memory."""
    if n &gt;= len(s): return "end"
    if n &lt;= -len(s): return "1.0"
    if n &lt; 0: n += len(s)
    n1 = s.count('\n',0,n)
    if n1 == 0:
        return "%d.%d" % (n1+1,n)
    else:
        n2 = s.rfind('\n',0,n)
        return "%d.%d" % (n1+1,n-n2-1)

# Test script.
s = p.firstChild().bodyString()
print '=' * 20
for i in xrange(len(s)):
    print "%3d" % (i),repr(str(s[i])),py2tkIndex(s,i)
i = len(s)
print "%3d" % (i),py2tkIndex(s,i)
print '-' * 20
for i in xrange(-1,-len(s)-1,-1):
    print "%3d" % (i),repr(str(s[i])),py2tkIndex(s,i)
i = -len(s)-1
print "%3d" % (i),py2tkIndex(s,i)</t>
<t tx="ekr.20040918093738.2">line 1
two
three
</t>
<t tx="ekr.20040918093738.3">def pyRowColToTkIndex (s,n1,n2):
    """Convert n, a Python index into s, into a Tk index.
    This must be as fast as possible and must not allocate any memory.
    """
    assert(n1 &gt;= 0)
    
    if 0: # Let Tk complain about bad indices.
        if n1 &gt; s.count('\n'):
            return "end"
        else:
            return "%d.%d" % (n1+1,n2)
    else: # Check both indices.
        line = 0 ; index = 0 ; limit = len(s)
        while index &lt; limit and line != n1:
            i = s.find('\n',index,limit)
            if i == -1:
                return "end"
            else:
                line += 1
                index = i + 1
        if index + n2 &gt; limit:
            return "end"
        else:
            i = s.find('\n',index,limit)
            if -1 &lt; i &lt; index + n2:
                return "bad" # n2 out of range.
            else:
                return "%d.%d" % (line+1,n2)
    
# Test script.
s = p.firstChild().bodyString()
print '-' * 20
lines = s.split('\n')
for n1 in xrange(len(lines)):
    line = lines[n1] + '\n'
    for n2 in xrange(len(line)):
        ch = line[n2]
        print "%3d.%-3d %-4s" % (n1,n2,repr(str(ch))),pyRowColToTkIndex(s,n1,n2)
        
n1,n2 = len(lines),0
print "%3d.%-3d %4s" % (n1,n2,' '),pyRowColToTkIndex(s,n1,n2)</t>
<t tx="ekr.20040918093738.4">line 1
two
three
</t>
<t tx="ekr.20041001194357"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(all=False)</t>
<t tx="ekr.20041001211817"></t>
<t tx="ekr.20041013101029"># Run this script from a scriptButton.
&lt;&lt; about this script &gt;&gt;
import re

def headfind():
    """Search with re and 
    - GO to found headline beginning with the selected text or clipboard buffer
    or also GO when line begins with @ and word or string in variable sMyOwnPrefix
    - EXCEPT when found search string is '-info' node
    (BOTH  1.followed by ' -info'
    AND  2.appears anywhere in headline(preceding space or start) 
    THEN  just SHOW found info node's body text in cleared Log pane.
    """
    s = c.frame.body.getSelectedText() or g.app.gui.getTextFromClipboard()
    if s:
        if len(s) == 1: s = "index -info" #if select is one char try to goto this named index node
        s = re.escape(s.lower())
        sUseLogTrigger = re.escape(" -info")
        sMyOwnPrefix = re.escape("FOLLOWING FILE IS: ").lower()
        sAllowablePrefixRe = "\@([A-Za-z][A-Za-z0-9\-]+) "
            # @ char, followed by alpha,some alphanum or dash chars, then space ...matches Leo special nodes
        for p in c.allNodes_iter():
            srch="(^%s%s|^%s%s|^%s| %s%s)" % (sMyOwnPrefix,s,sAllowablePrefixRe,s,s,s,sUseLogTrigger) #all re
            if re.findall(srch,p.headString().lower()):
                g.es("found " + s)
                sUseLogTrigger_srch="(^| )%s%s" % (s,sUseLogTrigger) #first just Log trigger re
                if re.findall(sUseLogTrigger_srch,p.headString().lower()):
                    body2=p.bodyString()
                    g.top().frame.log.logCtrl.delete("1.0","end"); # clear Log pane before message
                    # g.es(body2,color="orange")
                    return
                else:
                    c.beginUpdate()
                    try:
                        c.frame.tree.expandAllAncestors(p)
                        c.selectVnode(p)
                    finally:
                        c.endUpdate()
                    return
					
        g.es("no headline matches '%s'" % (s),color="blue")
    else:
        g.es("no selected text &amp; clipboard empty",color="blue")

headfind()</t>
<t tx="ekr.20041013101029.1">@ PREFIXES: Now will jump to any headline where search is preceded by an @+chars+space
and alternatively a fixed prefix string+space.

CLEAR LOG: Now also clears Log for display of -info nodes. 

NOTE:I already had a file with a bunch of text files each preceded by "THE FOLLOWING
FILE IS: " and a list of these files at the top of everything. After global
changing these lines with "- " (and at first line), I imported flattened outline...
and "there you go" a index-driven Leo version. :)

bill p</t>
<t tx="ekr.20041019080125">print "Loaded plugins..."

for s in g.app.loadedPlugins:
    print s</t>
<t tx="ekr.20041124144944">import os
import sys
for s in sys.path:
    exists = os.path.exists(s)
    print "%5s %s" % (exists,s)</t>
<t tx="ekr.20041126035448"># Note: the source files contain mixed tabs/blanks, and that's very hard for Leo's imports to handle.

@tabwidth 8
@language python

path = r"c:\Python23\Lib\site-packages\Pmw\Pmw_1_1\lib\PmwPanedWidget.py"

path = r"c:\prog\PmwPanedWidget.py" # The same file with tabs converted to 8 blanks.

path = r"c:\Python23\Lib\site-packages\Pmw\Pmw_1_1\demos\All.py"

assert g.os_path_exists(path)

c.importCommands.importFilesCommand([path],"@file")</t>
<t tx="ekr.20041126055818.2">@ This is probably a better way of parsing Python text.
It does not import the module, so it is safe for untrusted code.
@c
import pyclbr # Python Command Line Browser support.
import sys
print '*' * 40 ; print
fileNames = ("leoCommands.py","leo.py","leoAtFile.py")
fileNames = (r"c:\Python23\Lib\site-packages\Pmw\Pmw_1_1\lib\PmwPanedWidget.py"),

for fileName in fileNames:
    dir,file = g.os_path_split(fileName)
    moduleName,ext = g.os_path_splitext(file)
    moduleDict = pyclbr.readmodule_ex(moduleName,[dir] + sys.path)
    print "module", moduleName,'-' * 40
    items = []
    for funcOrClass in moduleDict.keys():
        o = moduleDict.get(funcOrClass) # o is a descriptor.
        try:
            mdict = o.methods # Fails for functions.
            items.append((int(o.lineno),"*class",o.name),)
            mkeys = mdict.keys()
            for method in mkeys:
                lineno = mdict.get(method)
                items.append((int(lineno),"method",method),)
        except AttributeError:
            # funcOrClass is a function descriptor
            items.append((int(o.lineno),"function",o.name),)
    items.sort()
    for line,kind,name in items:
        print "%4d %8s %s" % (line,kind,name)</t>
<t tx="ekr.20041126132604"></t>
<t tx="ekr.20041220080654">import Tkinter as Tk

&lt;&lt; documentation about how to set general options &gt;&gt;
t = Tk.Text()

print '-' * 20

settings = (
    ('height','xyz'),
    ('width',30),
    ('xyzzy',2),
)

widget_keys = t.keys() # List of all valid settings for this widget.
widget_keys.sort()

# Make a list of valid settings, and warn about invalid settings.
valid_settings = []
for key,val in settings:
    if key in widget_keys:
        setting = key,val
        valid_settings.append(setting)
    else:
        s = "'%s' is not a valid Tk option for this widget" % key
        print s ; g.es(s,color='blue')
valid_settings.sort()

print 'before changes...'
for key,val in valid_settings:
    print '%s = %s' % (key,str(t.cget(key)))

for key,val in valid_settings:
    d = {key:val}
    try:
        if 1: # The preferred way, using the 'extended call syntax'.
            # This was introduced in Python 2.0.
            t.configure(**d)
        else: # The Python 1.x way.  Deprecated since Python 2.3.
            apply(t.configure,[],d)
    except Tk.TclError:
        s = "Tk exception setting '%s' to %s" % (key,repr(val))
        print s ; g.es(s,color='blue')

print 'after changes...'
for key,val in valid_settings:
    print '%s = %s' % (key, str(t.cget(key)))

if 0:
    print ; print 'all keys...'
    for key in widget_keys:
        print '%s = %s' % (key, str(t.cget(key)))</t>
<t tx="ekr.20041220091350">@nocolor
@
The keyword argument syntax is of course much more elegant, and less error prone. However, for compatibility with existing code, Tkinter still supports the older syntax. You shouldn't use this syntax in new programs, even if it might be tempting in some cases. For example, if you create a custom widget which needs to pass configuration options along to its parent class, you may come up with something like:

@color

    def __init__(self, master, **kw):
        Canvas.__init__(self, master, kw) # kw is a dictionary

@nocolor
This works just fine with the current version of Tkinter, but it may not work with future versions. A more general approach is to use the apply function:
@color

    def __init__(self, master, **kw):
        apply(Canvas.__init__, (self, master), kw)
        
@nocolor
The apply function takes a function (an unbound method, in this case), a tuple with arguments (which must include self since we're calling an unbound method), and optionally, a dictionary which provides the keyword arguments.

--------- Apply is deprecated ---------

apply( function, args[, keywords]) 

The function argument must be a callable object (a user-defined or built-in function or method, or a class object) and the args argument must be a sequence. The function is called with args as the argument list; the number of arguments is the length of the tuple. If the optional keywords argument is present, it must be a dictionary whose keys are strings. It specifies keyword arguments to be added to the end of the argument list.

Calling apply() is different from just calling function(args), since in that case there is always exactly one argument. The use of apply() is equivalent to function(*args, **keywords). Use of apply() is not necessary since the ``extended call syntax,'' as used in the last example, is completely equivalent. 

Deprecated since release 2.3. Use the extended call syntax instead, as described above.
</t>
<t tx="ekr.20041220172118">@ignore</t>
<t tx="ekr.20041220172118.1">@nocolor

** The orginal file is .#localFileName.1.nnn
** The file modified by CVS is localFileName

'&lt;' * 7 localFileName
...
'=' * 7
...
'&gt;' * 7 1.nnn

&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
def spam-cvs1():
    pass # changed 1
=======
def spam2():
    pass
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.2</t>
<t tx="ekr.20041220172118.2">@ These do not affect outline structure.  

&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
def spam-cvs1():
    pass # changed 1
=======
def spam2():
    pass
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.2</t>
<t tx="ekr.20041220173231"># ------- These do affect outline structure. ------
# Leo does pretty well reading these, all things considered.

&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
#@+node:ekr.20041220170413.1:spam-1b
def spam():
=======
#@+node:ekr.20041220170413.1:spam-2b
def spam2():
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.3 # ------------------------------ duplicate sentinels above and below.
    pass
#@nonl
&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
#@-node:ekr.20041220170413.1:spam-1b
#@+node:ekr.20041220170413.2:eggs-1b
=======
#@-node:ekr.20041220170413.1:spam-2b
#@+node:ekr.20041220170413.2:eggs-2b
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.3
def eggs():
    pass
#@nonl
&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
#@-node:ekr.20041220170413.2:eggs-1b
=======
#@-node:ekr.20041220170413.2:eggs-2b
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.3</t>
<t tx="ekr.20041220173748">@killcolor

- There are no real problems unless sentinels are involved.

- cvs does _not_ show a clean version of the new file on cvs.

- A script could create the new version from the old and "conflict" versions.
    - This might be a useful starting point.
        - old:  fileName.1.nnn
        - conflict: fileName
        - new: created by script
    
- How can Leo know that a conflict exists???
    - Look for '&lt;' * 7 and '&gt;' * 7.  What if these exist in an unconflicted file?
    - No.  Look for fileName.1.nnn files.

- Maybe the atFile read logic could detect a conflict?
    - Only after detecting a fileName.1.nnn file.
    - Only if 'repair_cvs_conflict' option is set.</t>
<t tx="ekr.20041228135008">@language python
@tabwidth -4

import webbrowser

if 0:
    &lt;&lt; alternate code doesn't work well for me &gt;&gt;

def showHtml(html):
    '''Display html in a web browser'''
    fileName = g.os_path_join(g.app.loadDir,'..','test','leoTemp.html')
    f = file(fileName,'w')
    f.write(html)
    f.close()
    webbrowser.open(fileName)
    
# Display the selected node in the browser.
showHtml('&lt;pre&gt;%s&lt;/pre&gt;' % c.currentPosition().bodyString())

# To do: use a stylesheet to colorize the code.</t>
<t tx="ekr.20041228140714"># http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/347810
import BaseHTTPServer

def showHtml(html):
    """Display html in the default web browser without creating a temp file.

    Instantiates a trivial http server and calls webbrowser.open with a URL
    to retrieve html from that server.
    """

    class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
        def do_GET(self):
            g.trace(html)
            bufferSize = 1024*1024
            for i in xrange(0, len(html), bufferSize):
                self.wfile.write(html[i:i+bufferSize])

    server = BaseHTTPServer.HTTPServer(('127.0.0.1',0), RequestHandler)
    webbrowser.open('http://127.0.0.1:%s' % server.server_port)
    server.handle_request()</t>
<t tx="ekr.20041229163210">'''A script to send the colorized text of a script to the default web browser.

Based on a dynascript by 'e'.'''

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

hopts = {
  'stripcomments':  False,
  'stripsentinals': True,
  'stripnodesents': False, # False: leave node sentinels.
  'stripdirectives':False,
  'noNUMBER':       False,
  'noOP':           False,
  'noNAME':         True,  
  'timestring':     '' # time.strftime('%m/%d/%Y %H:%M.%S'),
}

&lt;&lt; init globals &gt;&gt;

filename = g.os_path_join(g.app.loadDir,'..','test','leoTemp.html')

@others

htmlize(c,p)</t>
<t tx="ekr.20041229163210.2">_KEYWORD = token.NT_OFFSET + 1
_TEXT    = token.NT_OFFSET + 2

_colors = {
    token.NUMBER:     '#483D8B', #black/darkslateblue
    token.OP:         '#000080', #black/navy
    token.STRING:     '#00AA00', #green 00cc66
    tokenize.COMMENT: '#DD0000', #red cc0033
    token.NAME:       '#4B0082', #black/indigo
    token.ERRORTOKEN: '#FF8080', #redred bare null does it
    _KEYWORD:         '#0066ff', #blue
    _TEXT:            '#000000', #black /is text fg color too
    '_LeoDir':        '#228B22', #directive, forest comment
    '_LeoSen':        '#BC8F8F', #sentinal, tan fade comment
    'bg':             '#FFFAFA', #snow
}

if hopts['noNUMBER']: del _colors[token.NUMBER]
if hopts['noOP']:     del _colors[token.OP]
if hopts['noNAME']:   del _colors[token.NAME]</t>
<t tx="ekr.20041229163210.3">class Parser(object):
    """ prep the source for any language
        parse and Send colored python source.
    """
    @others</t>
<t tx="ekr.20041229163210.4">def __init__(self,lang,raw,title):
    """ Store the source text."""

    self.title = title
    self.raw = raw.strip().expandtabs(4)

    if lang == 'python':
        cmtdelim = '#'
    else:
        d = g.scanDirectives(c, p) 
        cmtdelim = d.get('delims',['#'])
        cmtdelim = cmtdelim[0] or cmtdelim[1]
    
    self.fnd = re.compile(r"%s@\s*@+."%(cmtdelim,) )

    if hopts['stripsentinals']: 
        # have to add option to strip all comments as well
        self.raw = stripSentinels(self.raw)</t>
<t tx="ekr.20041229163210.5">def format(self,formatter,form):
    """ Parse and send the colored source."""

    # store line offsets in self.lines
    self.lines = [0,0]
    pos = 0
    while 1:
        pos = self.raw.find('\n',pos) + 1
        if not pos: break
        self.lines.append(pos)
    self.lines.append(len(self.raw))
    self.pos = 0
    text = cStringIO.StringIO(self.raw)
    sys.stdout.write('&lt;html&gt;&lt;head&gt;&lt;title&gt;')
    sys.stdout.write('%s &lt;/title&gt;\n'%(sanitize(self.title), ))

    #here would be a good spot for @noindent directive but skip a line
    s = """&lt;STYLE TYPE="text/css"&gt;&lt;!--
pre, H1 {color:%s; FONT-SIZE: 80%%; FONT-WEIGHT: bold; }
Text {background:%s;}
--&gt;&lt;/STYLE&gt;
&lt;SCRIPT LANGUAGE="JavaScript"&gt;
&lt;!-- //
//--&gt;
&lt;/SCRIPT&gt;""" % (_colors[_TEXT],_colors['bg'])

    sys.stdout.write(s)
    sys.stdout.write('&lt;/head&gt;&lt;body text="%s" bgColor="%s"&gt;' % (_colors[_TEXT],_colors['bg']))
    sys.stdout.write('&lt;H3&gt;# %s&lt;/H3&gt;\n'%self.title)
    sys.stdout.write('&lt;pre&gt;')  # style
    sys.stdout.write('&lt;font face="Lucida,Courier New"&gt;')
    # parse the source and write it
    try:
        tokenize.tokenize(text.readline,self)
    except tokenize.TokenError, ex:
        msg = ex[0]
        line = ex[1][0]
        print "&lt;h3&gt;ERROR: %s&lt;/h3&gt;%s" % (msg, self.raw[self.lines[line]:])
    sys.stdout.write('&lt;/font&gt;&lt;/pre&gt;')
    sys.stdout.write('&lt;/body"&gt;&lt;/html&gt;')</t>
<t tx="ekr.20041229163210.6">def __call__(self, toktype, toktext, (srow,scol), (erow,ecol), line):

    """ Token handler."""

    if 0: print "type", toktype, token.tok_name[toktype], "text",\
            toktext, "start", srow,scol, "end", erow,ecol, "&lt;br&gt;"

    # calculate new positions
    oldpos = self.pos
    newpos = self.lines[srow] + scol
    self.pos = newpos + len(toktext)

    # handle newlines
    if toktype in [token.NEWLINE, tokenize.NL]:
        print
        return

    style = ''
    if toktype == tokenize.COMMENT:
        if toktext.lstrip().startswith('#@'):
            if self.fnd.findall(toktext):
                toktype = '_LeoDir'
            else:
                toktype = '_LeoSen'

    # Send the original whitespace.
    if newpos &gt; oldpos:
        sys.stdout.write(self.raw[oldpos:newpos])

    # Skip indenting tokens.
    if toktype in [token.INDENT,token.DEDENT]:
        self.pos = newpos
        return

    # Map token type to a color group
    if token.LPAR &lt;= toktype and toktype &lt;= token.OP:
        toktype = token.OP
    elif toktype == token.NAME and keyword.iskeyword(toktext):
        toktype = _KEYWORD
    if toktype == token.ERRORTOKEN:
        style = ' style="border: solid 1.5pt #FF0000;"'

    dofont = True
    try:
        color = _colors[toktype]
    except Exception:
        dofont = False

    if dofont: sys.stdout.write('&lt;font color="%s"%s&gt;' % (color, style))
    sys.stdout.write(cgi.escape(toktext))
    if dofont: sys.stdout.write('&lt;/font&gt;')</t>
<t tx="ekr.20041229163210.7">if lang in [ # Leo may not have all of these yet
    'csharp', 'c', 'c++', 'cpp', # (C and C++)
    'css', # (Cascading Style Sheets)
    'htm', 'html', # HTML/PHP w/ JavaScript, VBScript, Python
    'plain', #null (No styling)
    'perlpod', 'perl', # (Perl)
    #'python', # (Python)
    'ruby', # (Ruby)
    'smart_python', # (Python with styled strings)
    'sql', # (SQL)
    'xml', # (XML)
    'xslt', # (XSLT)
    'yaml', # (YAML)
    # basic &amp; java? missing. might send java as c?
    'elisp', 'php', 'java', 'rapidq', 'actionscript', 'css',
]:
    if lang in ('htm','html','php','java','rapidq','actionscript', 'css'):
        lang = 'html'
    elif lang in ['c','c++','cpp']: lang = 'cpp'
    elif lang in ['perlpod','perl']: lang = 'perl'
    elif lang in ['elisp',]: lang = 'perl'
    if lang in ('plain',None): lang = 'null'

    g.es('writing tmpname', tmpfile )
    fo = file(tmpfile, 'w')
    fo.writelines(pars.raw + "\n")
    fo.close()
    
    cmd = g.os_path_join(pypath, 'Scripts', 'source2html.py')

    # Send the output to stdout
    #" --view %N  %N.html"
    # --css=file copy silver_city.css where the filename will be
    # source2html.py --list-generators
    params = ' --generator=%s --title=%s --css=silver_city.css %s'%(
       lang, sanitize_(title), tmpfile,)  

    if not g.os_path_exists(cmd):
        g.es('cant find source2html install silvercity')
        print 'cant find source2html from silvercity'
    else:
        g.es('running silvercity \n', py + cmd + params )
        out, err = runcmd(py + cmd + params )
        for x in (out + err).splitlines():
            print x
else:
    print '&lt;i&gt;not a known htmlize supported language&lt;/i&gt;'
    #might have to do a sequential dump of nodes, or @rst?
    #is title and first headline set the same for all options?
    print '&lt;Pre&gt;'    
    print pars.raw
    print '&lt;/Pre&gt;'</t>
<t tx="ekr.20041229164609">import cgi
import cStringIO
import keyword
import os
import re
import sys
import time
import token
import tokenize
import webbrowser</t>
<t tx="ekr.20041229164609.2">def htmlize(c,p):
    lang = g.scanForAtLanguage(c,p)
    lang = str(lang).lower()
    source = g.getScript(c,p)
    timestring = hopts['timestring']
    # title = "%s Leo %s script %s" % (p.headString()[:75],lang,timestring)
    title = "%s %s" % (p.headString()[:75],timestring)
    try:
        if not source: raise ValueError
        g.es('output', lang, p.headString())
        theParser = Parser(lang,source,title)
        sys.stdout = open(filename,'wb') 
        if lang == 'python':
            theParser.format(None,None)
        else:
            &lt;&lt; colorize with silvercity &gt;&gt;
        sys.stdout.close()
        sys.stdout = sys.__stdout__
        webbrowser.open(filename, new= 1)
    except ValueError:
        g.es('no @path set, unsupported lang or empty script',color='tomato')
        g.es(lang, p.headString())
    except Exception:
        g.es('htmlize malfunction?', color='tomato')
        g.es_exception(full= True)</t>
<t tx="ekr.20041229165956">def sanitize(s):
    
    """Leo's sanitize_filename is too aggressive and too lax."""

    if not s: return

    res = re.compile(
        r"""[|\\ /!@=\#\$%,\x5E&amp;\x3F:;.\x22\x27&lt;&gt;`~\*\+\t\n\f\r\b\a]""",
        re.IGNORECASE | re.VERBOSE)

    # should test for unicode before str()
    return res.sub('_', str(s.strip())).replace('__','_')[:128]</t>
<t tx="ekr.20041229170824">def stripSentinels(s):

    '''Strip sentinal lines from s.'''
    
    lines = s.splitlines()
    result = [] ; verbatim = False
    tag1 = '#@+node:'
    tag2 = '#@-node:'
    n = len(tag1)

    for line in lines:
        s = line.strip()
        if verbatim:
            result.append(line)
            verbatim = False
        elif s.startswith('#@verbatim'):
            verbatim = True
        elif s.startswith('#@@'):
            if not hopts['stripdirectives']:
                result.append(line)
        elif s.startswith(tag1):
            if not hopts['stripnodesents']:
                i = line.find(tag1)
                result.append(line[:i] + '#@+' + line[i+n:].strip())
        elif s.startswith(tag2):
            if not hopts['stripnodesents']:
                i = line.find(tag2)
                result.append(line[:i] + '#@-' + line[i+n:].strip())
        elif not s.startswith('#@'):
            result.append(line)

    return '\n'.join(result)</t>
<t tx="ekr.20041230121429">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20050103092214">import token
import tokenize

@others

print '*' * 40

if 1:
    parser = pythonParser(c,p)
    parser.parseNode(p)
else:
    parser = dumper(c,p)
    parser.parseNode(p)</t>
<t tx="ekr.20050103092214.3">class dumper (pythonParser):
    
    @others</t>
<t tx="ekr.20050103092214.4">def __init__ (self,c,p):

    # Init the base class.
    pythonParser.__init__ (self,c,p,dumping=True)</t>
<t tx="ekr.20050103092214.5">class pythonParser:
    
    @others</t>
<t tx="ekr.20050103092214.6">if 0:
    @others</t>
<t tx="ekr.20050103092214.7">def clear (self):
    self.lines = []</t>
<t tx="ekr.20050103092214.8">def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)</t>
<t tx="ekr.20050103092214.9">def get (self):
    
    return self.lines</t>
<t tx="ekr.20050103092214.10">def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20050103092214.11">def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []</t>
<t tx="ekr.20050103092214.12">def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)</t>
<t tx="ekr.20050103092214.13">def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)</t>
<t tx="ekr.20050103092214.14">def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)</t>
<t tx="ekr.20050103092214.15">def __init__ (self,c,p,dumping=False):
    
    self.c = c
    self.p = p
    
    # Debugging ivars...
    self.dumping = dumping
    self.tracing = False
    
    # State ivars...
    self.bracketLevel = 0
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.inDocPart = False
    self.line = 0 # Same as self.srow
    self.name = None
    self.parenLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.val = None
    
    if 0: # old ivars
        self.array = [] # List of strings comprising the line being accumulated.
        self.changed = False
        self.lines = [] # List of lines.
        self.prevName = None
        self.s = None # The string containing the line.

    &lt;&lt; define dispatch dict &gt;&gt;</t>
<t tx="ekr.20050103092214.16">self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}</t>
<t tx="ekr.20050103092214.17">def parseNode(self,p):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        if self.dumping:
            for token5tuple in tokenize.generate_tokens(readlines):
                self.dumpToken(token5tuple)
        else:
            for token5tuple in tokenize.generate_tokens(readlines):
                self.doToken(token5tuple)

    except tokenize.TokenError:
        g.es("Error parseing %s" % h, color="blue")
        return</t>
<t tx="ekr.20050103092214.18">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20050103092214.19">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    name = token.tok_name[t1].lower()
    val  = str(t2) # can fail
    srow,scol = t3
    erow,ecol = t4
    line = str(t5) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20050103092214.21">def oops(self):
    
    print "unknown tokenize code: %s" % (self.name)</t>
<t tx="ekr.20050103092214.22">def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))</t>
<t tx="ekr.20050103092214.23">def doToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow
    
    try: t2 = str(t2)
    except: pass
    try: t5 = str(t5)
    except: pass
    
    if 1: # Dump...
        if self.startLine: print 'Line %s' % self.line
        # print '%3d %20s %10s %10s %s' % (t1,repr(t2),t3,t4,repr(t5))
        print '%20s %s' % (repr(str(self.s[self.scol:self.ecol])),repr(t5))
        
    
    if self.startLine:
        self.doStartLine()
    
    f = self.dispatchDict.get(self.name,self.oops)
    f()</t>
<t tx="ekr.20050103092214.24">def doEndMarker (self):
    
    # End of text marker.
    pass</t>
<t tx="ekr.20050103092214.25">def doErrorToken (self):
    
    if 0:
        self.array.append(self.val)
    
        if self.val == '@':
            # Preserve whitespace after @.
            i = g.skip_ws(self.s,self.scol+1)
            ws = self.s[self.scol+1:i]
            if ws:
                self.array.append(ws)</t>
<t tx="ekr.20050103092214.26">def doDedent (self):
    
    pass
    
def doIndent (self):
    
    if 0:
        self.array.append(self.val)
</t>
<t tx="ekr.20050103092214.27">def doMultiLine (self):
    
    '''Handle a multiline token: i.e., a string or comment.'''
    
    if 0:
        # These may span lines, so duplicate the end-of-line logic.
        lines = g.splitLines(self.val)
        for line in lines:
            self.array.append(line)
            if line and line[-1] == '\n':
                self.putArray()
                
        # Suppress start-of-line logic.
        self.line = self.erow</t>
<t tx="ekr.20050103092214.28">def doName(self):

    if 0:
        self.array.append("%s " % self.val)
        if self.prevName == "def": # A personal idiosyncracy.
            self.array.append(' ') # Retain the blank before '('.
        self.prevName = self.val</t>
<t tx="ekr.20050103092214.29">def doNewline (self):
    
    if 0:
        self.array.append('\n')
        self.putArray()</t>
<t tx="ekr.20050103092214.30">def doNumber (self):

    if 0:
        self.array.append(self.val)
</t>
<t tx="ekr.20050103092214.31">def doOp (self):
    
    # New in Python 2.4: '@' is an op token.
    val = self.val
    
    if 0:
        if val == '(':
            self.parenLevel += 1
            self.put(val)
        elif val == ')':
            self.parenLevel -= 1
            self.put(val)
        elif val == '=':
            if self.parenLevel &gt; 0: self.put('=')
            else:                   self.put(' = ')
        elif val == ',':
            if self.parenLevel &gt; 0: self.put(',')
            else:                   self.put(', ')
        elif val == ';':
            self.put(" ; ")
        else:
            self.put(val)</t>
<t tx="ekr.20050103092214.32">def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
    
    # g.trace(repr(before),repr(self.ws))
         
    if 0:
        if self.ws:
            self.array.append(self.ws)</t>
<t tx="ekr.20050103095602">def handleAtPart (self):
    
    s = self.s

    #self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    #self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
</t>
<t tx="ekr.20050108110751"></t>
<t tx="ekr.20050108110751.1">@ Here is a function to convert the font tags to equivalent span tags. Note use
of font-size:x-large to show how styling can be used for emphasis.

Uses a regular expression to insert style CSS classes before &lt;/STYLE&gt; closing
tag ...so &lt;STYLE&gt;&lt;/STYLE&gt; is expected to exist in input html.
@c

def font2span(colorizedusingFONT):
    aa=colorizedusingFONT
    styleClasses="""    .token_STRING    {color:#00AA00;} 
    .token_NUMBER    {color:#483D8B;}
    .token_OP        {color:#000080;} 
    .tokenize_COMMENT{color:#DD0000;} 
    .token_NAME      {color:#4B0082;} 
    .token_ERRORTOKEN{color:#FF8080;} 
    .KEYWORD        {color:#0066ff;} 
    .TEXT           {color:#000000;} 
    .LeoDir       {color:#228B22;} 
    .LeoSen       {color:#BC8F8F;font-size:x-large;} 
    .bg            {color:#FFFAFA;} 
    """
    myRE=re.compile(r"&lt;/STYLE&gt;")              ;aa=myRE.sub(styleClasses+"\n&lt;/STYLE&gt;",aa)
    myRE=re.compile(r'&lt;font color="#00AA00"&gt;');aa=myRE.sub('&lt;span class="token_STRING"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#483D8B"&gt;');aa=myRE.sub('&lt;span class="token_NUMBER"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#000080"&gt;');aa=myRE.sub('&lt;span class="token_OP"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#DD0000"&gt;');aa=myRE.sub('&lt;span class="tokenize_COMMENT"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#4B0082"&gt;');aa=myRE.sub('&lt;span class="token_NAME"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#FF8080"&gt;');aa=myRE.sub('&lt;span class="token_ERRORTOKEN"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#0066ff"&gt;');aa=myRE.sub('&lt;span class="KEYWORD"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#000000"&gt;');aa=myRE.sub('&lt;span class="TEXT"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#228B22"&gt;');aa=myRE.sub('&lt;span class="LeoDir"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#BC8F8F"&gt;');aa=myRE.sub('&lt;span class="LeoSen"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#FFFAFA"&gt;');aa=myRE.sub('&lt;span class="bg"&gt;',aa)
    myRE=re.compile(r'&lt;/font&gt;')               ;aa=myRE.sub('&lt;/span&gt;',aa)
    
    basefontSize="12pt"
    basefontFamily="Lucida,Courier New"
    myRE=re.compile(r'&lt;font face="Lucida,Courier New"&gt;');
    aa=myRE.sub('&lt;span style="font:'+basefontSize+' '+basefontFamily+';"&gt;',aa)

    return aa</t>
<t tx="ekr.20050108110751.2">@ To adjust this script internally to use span tags and CSS style classes make
the following changes to  three nodes as follows:
@c

# I. in "init globals" node change the _colors dictionary to use lists 
# (with 3 values representing color, CSS class, extra styling) as follows:

_colors = {
    token.NUMBER:     ['#483D8B','token_NUMBER',' '], #black/darkslateblue
    token.OP:         ['#000080','token_OP',' '], #black/navy
    token.STRING:     ['#00AA00','token_STRING',' '], #green 00cc66
    tokenize.COMMENT: ['#DD0000','tokenize_COMMENT',' '], #red cc0033
    token.NAME:       ['#4B0082','token_NAME',' '], #black/indigo
    token.ERRORTOKEN: ['#FF8080','token_ERRORTOKEN',' '], #redred bare null does it
    _KEYWORD:         ['#0066ff','KEYWORD',' '], #blue
    _TEXT:            ['#000000','TEXT',' '], #black /is text fg color too
    '_LeoDir':        ['#228B22','LeoDir',' '], #directive, forest comment
    '_LeoSen':        ['#BC8F8F','LeoSen','font-size:x-large;'], #sentinal, tan fade comment
    'bg':             ['#FFFAFA','bg',' '], #snow
}</t>
<t tx="ekr.20050210180034"># The first script in Jython Essentials, by Pedroni &amp; Rappin.
import javax.swing as swing
import java.awt as awt
import java.lang as lang

def exit(event):
    lang.System.exit(0)
    
def onButtonPressed(event):
    field.text=quotes[event.source.text]
    
def createButton(name):
    return swing.JButton(name,preferredSize=(100,20),
        actionPerformed=onButtonPressed)
        
names = [ 'Groucho','Chico','Harpo']
quotes = {'Groucho':'Say the secret word','Chico':'Viaduct?','Harpo':'Honk!'}

w = swing.JFrame('Welcome to jython!',size=(200,200),windowClosing=exit)
w.contentPane.layout = awt.FlowLayout()

field = swing.JTextField(preferredSize=(200,20))
w.contentPane.add(field)

buttons = [createButton(name) for name in names]
for button in buttons:
    w.contentPane.add(button)

w.pack()
w.show()</t>
<t tx="ekr.20050210180937"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.headString()
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20050218170806">p = p.firstChild().firstChild()
s = p.bodyString()
lines = g.splitLines(s)
prefixes = (
    'access=',
    'bccsender=',
    'filtered=',
    'registered=',
    'messagetocount=',
    'messagecount=',
    'lastmessagedate=',
    'lastsource=',
    'replyToAddresses=',
    'creationdate=',
    'reason=Approved before registration',
    'reason=Address Book Contact',
    'registrationDate=',
    'registrationRequestSent=',
    'reason=Pre-approved sender',
    'preaccepted=1',
)
result = []
for line in lines:
    for prefix in prefixes:
        if line.startswith(prefix):
            # print 'removing',line
            break
    else:
        if line.startswith('name='):
            result.append(line[5:])
        else:
            result.append(line)

result = ''.join(result)
p.setBodyStringOrPane(result)
print 'done!'</t>
<t tx="ekr.20050218170806.1">@killcolor
</t>
<t tx="ekr.20050218170806.2"></t>
<t tx="ekr.20050218174326.1">p = p.firstChild().firstChild()
s = p.bodyString()
lines = g.splitLines(s)
reject = 'reason=Rejected before registration'
result = []
entries = []
for line in lines:
    if line.startswith('['):
        # Add all previous entries
        for entry in entries:
            result.append(entry)
        entries = []
        entries.append(line)
    elif line.startswith(reject):
        # Kill all previous entries.
        entries = []
    else:
        entries.append(line)

result = ''.join(result)
p.setBodyStringOrPane(result)
print 'done!'</t>
<t tx="ekr.20050218184044.10">address_p = p.firstChild()
result_p = p.firstChild().next()

result = []
entries = []
for child in address_p.children_iter():
    s = child.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        if line.startswith('['):
            # Add all previous entries
            if entries:
                if len(entries) &gt; 1:
                    # entries2 = [entries[0],entries[1]]
                    # entries2.extend(entries[2:])
                    result.append(','.join(entries[:2]))
                else:
                    result.append(entries[0])
            entries = [] ; entries2 = []
            entries.append(line.rstrip()[1:-1])
        elif line.strip():
            entries.append(line.rstrip())

result.sort()
result = '\n'.join(result)
result_p.setBodyStringOrPane(result)
print 'done!'</t>
<t tx="ekr.20050218184044.11"></t>
<t tx="ekr.20050219054039">@ These scripts work on the child nodes as shown.

The address children contained the actual data (removed for privacy)</t>
<t tx="ekr.20050219054039.1"></t>
<t tx="ekr.20050219054351">@killcolor
</t>
<t tx="ekr.20050219054351.1"></t>
<t tx="ekr.20050219071503">def callback(*args,**keys): g.trace()

table = (("Test",None,callback),)

c.frame.menu.createMenuItemsFromTable('File',table)</t>
<t tx="ekr.20050219073752.1">def callback(*args,**keys):
    g.trace('after Open With')

# Get the actual Tkinter menu.
fileMenu = c.frame.menu.getMenu('File')

# Now use raw Tkinter calls to insert the menu.
fileMenu.insert(3,'command',label='Test',command=callback) </t>
<t tx="ekr.20050219075759"></t>
<t tx="ekr.20050220085042.1">def run (c):
    
    import leoTest
    u = leoTest.testUtils() 
    input  = u.findNodeAnywhere(c,'-elisp2py-input-')
    output = u.findNodeAnywhere(c,'-elisp2py-output-')
    assert input and output

    print ; print '*' * 60
    e = e2py(dumping=False)
    for p in input.children_iter():
        print ; print '-' * 10, p.headString()
        print p.bodyString()
        result = e.doOuterBlock(p.bodyString())
        print '-' * 20
        print result</t>
<t tx="ekr.20050220085042.2"></t>
<t tx="ekr.20050220091046">class e2py:
    
    '''A text-based (not token-based) approach to parsing.'''
    
    @others</t>
<t tx="ekr.20050220091046.1">def __init__ (self,dumping=False):
    
    self.dumping = dumping</t>
<t tx="ekr.20050220091046.2">def doOuterBlock (self,s):
    
    '''Handle outermost code.  Return a string, not a list.'''
    
    s = self.stripLws(s)
    result = self.doBlock(s)
    result = self.removeBlankLines(result)
    return '\n'.join(result)</t>
<t tx="ekr.20050220091046.3">def doParenBlock (self,s):
    
    ''' - Strip outer parens.
        - Call doBlock recursively for all inner parens.
        - Add one level of indentation to each line.'''
    n,ok = self.findMatchingBracket(s)
    assert n == len(s) and ok
    s = s[1:-1] # Strip the brackets
    i = 0
    i = g.skip_ws(s,i)
    j,id = self.skip_id(s,i)
    if id:
        s = s[j:].lstrip()
        if id == 'defun': result = self.doDef(s,id)
        elif id == 'let': result = self.doLet(s)
        elif id == 'if': result = self.doIf(s)
        elif id in ('prog1','progn'): result = self.doProg(s,id)
        else: result = self.doId(s,id)
    elif s[i] == '(':
        s = s[i:].lstrip()
        result = self.doDoubleParen(s)
    else: result = self.doBlock(s)
        
    self.dump(result)
    return result</t>
<t tx="ekr.20050220091046.4"></t>
<t tx="ekr.20050220091046.5"></t>
<t tx="ekr.20050220091236">    for p in before.subtree_iter():
        e = elisp2py.elisp2pyClass(c,p)
        e.convert()
        if 0:
            e.dump(e.tokens,heading="Tokens",verbose=2)
        if 1:
            e.dump(e.parseTree,heading="Parse Tree",verbose=2)
        if 0:
            e.dumpCodeList(e.codeList,heading="Code List")</t>
<t tx="ekr.20050220092732">def findMatchingBracket(self,s,i=0):

    ch1 = s[i]
    assert ch1 in "({["
    delim = self.matchingBracket(ch1)
    level = 1
    for ch in s[i+1:]:
        i += 1
        # g.trace(level,ch)
        if ch == ch1:
            level += 1
        elif ch == delim:
            level -= 1
            if level == 0: return i+1,True
    print "%s not matched by %s in %s" % (ch1,delim,s)
    return len(s),False</t>
<t tx="ekr.20050220093752">def matchingBracket (self,ch):
    
    assert ch in "({["
    
    if   ch == '(': return ')'
    elif ch == '{': return '}'
    else:           return ']'</t>
<t tx="ekr.20050220100049">def stripLws(self,s):
    
    lines = g.splitLines(s)
    result = [line.lstrip() for line in lines]
    return ''.join(result)</t>
<t tx="ekr.20050220103808">def skip_id(self,s,i=0):
    
    j = g.skip_id(s,i,chars='-')
    id = s[i:j]
    return j,id</t>
<t tx="ekr.20050220105058">def doDef(self,s,id):
    # g.trace(id)
    if id == 'defun':
        kind,i,j,name = self.getToken(s,0)
        if kind == 'id':
            kind,i,j,params = self.getToken(s,j)
            if kind == '()':
                s = s[j:]
                result = ['def %s %s:' % (name,params)]
                result.extend(self.indent(self.doBlock(s)))
                self.dump(result)
                return result
                
    # Fall through if error.
    result = [id]
    result.extend(self.indent(self.doBlock(s)))
    self.dump(result)
    return result</t>
<t tx="ekr.20050220105058.1">def doIf(self,s):
    
    # g.trace()
    
    if 1:
        result = ['if:']
        result.extend(self.indent(self.doBlock(s)))
        result.extend([':if'])

    else: # not yet.  Don't suck everything into the 'if' statement!
        block = self.doBlock(s)
        result = ['if (%s):' % ' '.join(block)]
    
    self.dump(result)
    return result</t>
<t tx="ekr.20050220105058.2">def doLet(self,s):
    
    # g.trace()
    
    result = ['let:']
    result.extend(self.indent(self.doBlock(s)))
    result.extend([':let'])
    
    self.dump(result)
    return result
</t>
<t tx="ekr.20050220105058.3">def doProg(self,s,id):
    
    # g.trace(id)
    
    result = [id]
    result.extend(self.indent(self.doBlock(s)))
    
    self.dump(result)
    return result</t>
<t tx="ekr.20050220105058.4">def skipString(self,s,i):

    # Skip the opening double quote.
    i1 = i
    ch = s[i]
    i += 1
    assert(ch == '"')

    while i &lt; len(s):
        ch = s[i]
        i += 1
        if ch == '"': return i
        elif ch == '\\': i += 1

    print "run-on elisp string: %s" % g.get_line(s[i1:])
    return i</t>
<t tx="ekr.20050220105726">def indent (self,lines,strip=True):
    
    '''Add a tab to each element of a list.'''
    
    return ['    ' + line for line in lines if not strip or line.strip()]</t>
<t tx="ekr.20050220111049">def doBlock (self,s,strip=True):
    
    '''Handle an outer block or a formerly parenthesized block.'''

    i = 0 ; result = []
    while i &lt; len(s):
        j = s.find('(',i)
        if j == -1:
            tail = s[i:]
            if tail:
                # g.trace(repr(tail))
                result.extend(g.splitLines(tail))
            break
        else:
            prev = s[i:j]
            if prev: result.extend(g.splitLines(prev))
            i = j
            n,ok = self.findMatchingBracket(s[i:])
            if ok:
                block = s[i:i+n]
                block = self.stripLws(block)
                block_result = self.doParenBlock(block)
                if block_result:
                    result.extend(block_result)
            i += n
    
    result = self.removeBlankLines(result)
    self.dump(result)
    return result</t>
<t tx="ekr.20050220111114">def doId(self,s,id):
    
    # g.trace(id)
    if 1:
        result = ['(%s:' % id]
        result.extend(self.indent(self.doBlock(s)))
        result.extend([':%s)' % id])
    else:
        result = [id]
        result.extend(self.doBlock(s))
    
    self.dump(result)
    return result</t>
<t tx="ekr.20050220111923">def dump(self,lines):
    
    if self.dumping:
        print '%s returns...' % g.callerName(2)
        lines = [str(line) for line in lines]
        print g.listToString(lines)</t>
<t tx="ekr.20050220114616">def getToken (self,s,i=0):

    i = g.skip_ws(s,i)
    if i &lt; len(s):
        ch = s[i]
        if ch == '"':
            j = self.skipString(s,i)
            val = '"',i,j,s[i:j]
        elif ch in string.ascii_letters or ch in string.digits or ch in '-_':
            j,name = self.skip_id(s,i)
            val = 'id',i,j,name
        elif ch == '(':
            j,ok = self.findMatchingBracket(s,i)
            if ok:
                val = '()',i,j,s[i:j]
            else:
                val = '(',i,i,'('
        else:
            val = ch,i,i,ch
    else:
        val = None,i,i,None
        
    # g.trace(repr(s[i]),val)
    return val</t>
<t tx="ekr.20050220122447">def removeBlankLines (self,lines):
    
    return [line for line in lines if line.strip()]</t>
<t tx="ekr.20050220124658">def doDoubleParen (self,s):

    n,ok = self.findMatchingBracket(s)
    if ok:
        s2 = s[:n] ; s3 = s[n:]
        result = ['(:']
        result.extend(self.indent(self.doParenBlock(s2)))
        result.extend([':)'])
        result.extend(self.doBlock(s3))
    else:
        result = self.doBlock(s)
        
    self.dump(result)
    return result
</t>
<t tx="ekr.20050225161940">@

To run the script:
    
1. Make the 'Exec File' node a script button.

2. Select either the @test node or the @thin node.

(You must change @@thin to @thin for this to work.)

3. Hit the Exec File button.</t>
<t tx="ekr.20050225161940.1">assert __name__ == '__builtin__', '__name__ is %s' % __name__</t>
<t tx="ekr.20050225161940.2">&lt;&lt; docstring &gt;&gt;
&lt;&lt; imports &gt;&gt;

@others

doatest()</t>
<t tx="ekr.20050225161940.3">"""this script will run python from Leo with @file somefile.py
using the py2.4 (2.3 compatible) subprocess module
to verify and code correct in the quickest possible manner.
unittests or other w/stdout stderr redirected to log.
wimped out for the moment on making it virtual.

If the presently selected node is an @test or @suite node this script runs them,
otherwise the script expects the node to a valid @file node that has been
written to disk and updated.

less complicated and thus more advanced unittesting:
py.test, similar to unittest as far as adding support.
and @test and @suite, many examples in test.leo
and my own dutest in dyna_menu with redirection to log
which calls leoTest.py on @test and @suite nodes 
otherwise for doctesting w/o needing an @file written.

good overview, see Recent Posts:
http://agiletesting.blogspot.com
http://agiletesting.blogspot.com/2005/01/
Python unit testing part 3: the py.test tool and library 
python-unit-testing-part-2-doctest part-1 unittest

tested win9x Leo4.3a2 py2.4 2.3
tested but little and probably not completely.
if it works once its done, right?
make an @button or add to a menu or plugin

Note: 
you may see some extraneous traceback 
vrs run outside Leo, can't be helped.

Warning: this may run arbitrary code.
no warranty expressed or implied!
"""
</t>
<t tx="ekr.20050225161940.5">def getAtFileName():
    
    '''Return the full path from any kind of @file node and applicable @path directives.'''
    
    # should return cwd, cd to files path
    # script should return cwd after run

    fname = p.anyAtFileNodeName()
    if fname:
        d = g.scanDirectives(c)
        path = d.get("path")
        fname = g.os_path_abspath(g.os_path_normpath(g.os_path_join(path, fname)))

    return fname</t>
<t tx="ekr.20050225161940.6">def doatest():

    _sosav = sys.__stdout__
    _sesav = sys.__stderr__
    sys.stdout = sys.__stdout__ = g.fileLikeObject()
    sys.stderr = sys.__stderr__ = g.fileLikeObject()

    h = p.headString()
    if h.startswith('@suite') or h.startswith('@test'):
        leoTest.doTests(all= False,verbosity=2)
    else: # Try to run an @file unittest.
        name = getAtFileName()
        if name:
            g.executeFile(name,'-v')
        else:
            g.es('Expecting @test, @suite or any @file node',color='blue')

    oo = sys.stdout.get()
    oe = sys.stderr.get()
    sys.stdout.close()
    sys.stderr.close()
    sys.stdout = sys.__stdout__ = _sosav
    sys.stderr = sys.__stderr__ = _sesav
    lines = g.splitLines(oo + oe)
    empty = True
    for line in lines:
        if line.rstrip():
            empty = False
    if lines and not empty:
        g.es('Output from test...',color='blue')
        for line in lines:
            g.es(line.rstrip())
    g.es('Test done',color='blue')

    c.frame.putStatusLine(' fini ', color= 'DodgerBlue')</t>
<t tx="ekr.20050225162123">@language python
@tabwidth -4

print __name__
#print 'hi'

assert __name__ == '__main__', '__name__ is %s' % __name__</t>
<t tx="ekr.20050225171553">import leoTest

try:
    import subprocess # Exists only in Python 2.4.
except ImportError:
    subprocess = None

import os
import StringIO
import sys
import unittest</t>
<t tx="ekr.20050310082013">@ http://sourceforge.net/forum/message.php?msg_id=3039793

heres a short script to open a leo, then a New leo from that one, pause then exit.

still have to work out how to collect error output, especially if Leo doesn't start at all
can't then depend on Leo error reporting!

make a node
@url ./leoopen1.au3

make another
@nosent leoopen1.au3
@c

@language elisp

; AutoIt Version: 3.0 a BASIC like language
; http://www.hiddensoft.com/AutoIt/

; Opens Leo with no filename, then opens a new, closes it
; Preliminary, will eventually programatically create
; leoPlugins.txt and various leoSettings.leo
; and run commands in all permutations looking for failures.

; Paths are hardwired but later scripts will be created on the fly
; maybe Leo can have a -trace mode to output to file a log of activities?

; exit when CTRL+ALT+x is pressed
HotKeySet("^!x", "MyExit")

Func MyExit()
    Exit 
EndFunc 

Opt("SendKeyDelay", 1)
Opt("WinWaitDelay", 80)

;fix path to leo.py
Run("python c:\c\leo\V43leos\leo\src\leo.py")
Sleep(2700) 

WinWaitActive("untitled")   

Sleep(700) 
Send("!Fn")  ; how to tell if there are errors?
Sleep(2700) 

WinWaitActive("untitled1")
Send("!Fx")
Sleep(2700) 

;careful you don't close the leo you are working from
Send("!Fx")</t>
<t tx="ekr.20050314103747">def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl &gt; -1
            return row,i-prevNl-1</t>
<t tx="ekr.20050314103747.1">def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i &lt; total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total</t>
<t tx="ekr.20050314103747.2">def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'
    
    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = convertPythonIndexToRowCol(s,i)
        rowCol_2 = bruteForceConvertPythonIndexToRowCol(s,i)
        print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
        print rowCol_1,rowCol_2</t>
<t tx="ekr.20050314104217">@others

print '-' * 20
test_g_convertPythonIndexToRowCol()</t>
<t tx="ekr.20050315072359">@others

print '-' * 20
test_g_convertRowColToPythonIndex()</t>
<t tx="ekr.20050315072359.1">def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row &gt; len(lines) or col &gt; len(lines[row]):
        raise IndexError
    
    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col</t>
<t tx="ekr.20050315072359.2">def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1</t>
<t tx="ekr.20050427101736">class ZipFile(  	file[, mode[, compression]])
    Open a ZIP file, where file can be either a path to a file (a string) or a file-like object. The mode parameter should be 'r' to read an existing file, 'w' to truncate and write a new file, or 'a' to append to an existing file. For mode is 'a' and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file, such as python.exe. Using

cat myzip.zip &gt;&gt; python.exe

    also works, and at least WinZip can read such files. compression is the ZIP compression method to use when writing the archive, and should be ZIP_STORED or ZIP_DEFLATED; unrecognized values will cause RuntimeError to be raised. If ZIP_DEFLATED is specified but the zlib module is not available, RuntimeError is also raised. The default is ZIP_STORED. </t>
<t tx="ekr.20050427101736.1">import zipfile

path = r'c:\prog\leoCVS\leo\test\ziptest.zip'

zf = zipfile.ZipFile(path,'w',zipfile.ZIP_DEFLATED)
zf.writestr('This is a test: EKR','ziptest')
zf.close()</t>
<t tx="ekr.20050427101736.2">import zipfile

path = r'c:\prog\leoCVS\leo\src\leoPy.leo'
path = r'c:\prog\leoCVS\leo\test\ziptest.zip'

if zipfile.is_zipfile(path):
    try:
        zf = zipfile.ZipFile(path)
        names = zf.namelist()
        for name in names:
            print 'name',repr(name),'contents',zf.read(name)
        zf.close()
    except Exception:
        g.es_exception()
        zf = None</t>
<t tx="ekr.20050427102426"></t>
<t tx="ekr.20050601072505">athis skkdfkjdkfjakdjf;akjf;akljf;asdjf;ajf;
a;ljf;

;alkjf;a
;alkjf;akljf;lds;kfja;sdkfj;adskfjads;kfjads;kfljaa;ljf;ladskjf;dsalkjf;asdkf
def this akjd;flk
This is a test of coloring.  It works if we use a thread.
lakjdf;kjadf
alkjdf;kaljdf;kdkdkkdkd;what is going ondkjf;akf;ak
for while do if const
This is a test of something.
I wonder what it could be.
This could be the start of something wonderful.

This is a test.
#dddddddddddddddddddddddddddddddddddddddThis
this is a t
I have no idea.
;alkd;fkajd;fkjd
this is a test for to from is a test of something
kdkjf;akf;klja;dfkj
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from and still this is good.

# Wow.  It is so cool to get beter performance.
adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf




</t>
<t tx="ekr.20050602213517">@color
@doc test
line 2
@c
int
@color
@ doc
line 2
@c</t>
<t tx="ekr.20050603134109">@language c // c delegates to cpp rule within c.xml

int enum

assert(True)

&lt;&lt; xyzzy &gt;&gt;

/** Doxygen comment */</t>
<t tx="ekr.20050607084934">@language plain
</t>
<t tx="ekr.20050608081744">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@="&amp;Notepad"

Test of @ at end of text.
@</t>
<t tx="ekr.20050608081942">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@="&amp;Notepad"</t>
<t tx="ekr.20050608082208">@ignore

@language plain
@nocolor
</t>
<t tx="ekr.20050608082702">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad</t>
<t tx="ekr.20050608082702.1">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad
</t>
<t tx="ekr.20050618061950"></t>
<t tx="ekr.20050704170739">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20050704172623">for p in c.allNodes_iter():
    print p.level()*' ',p.headString()
</t>
<t tx="ekr.20050707183613">&lt;&lt; imports &gt;&gt;

@others

if 1:
    &lt;&lt; use IPShellEmbed &gt;&gt;
else:
    shell = LeoShell('shell')
    # g.redirectStdout()
    g.es_print('-'*40)
    body = p.bodyString()
    for line in g.splitLines(body):
        g.es(str(shell.prefilter(line,None)))
    #g.restoreStdout()</t>
<t tx="ekr.20050708091220.76">class LeoShell (IPython.iplib.InteractiveShell):
    
    @others
    
    # Set the default prefilter() function (this can be user-overridden)
    prefilter = _prefilter</t>
<t tx="ekr.20050708091220.77">def __init__ (self,name):
        
    self.shell = self
    self.name = name
    
    &lt;&lt; directory stuff &gt;&gt;
    &lt;&lt; set sensible command line defaults for self.rc &gt;&gt;
    &lt;&lt; define regexp's &gt;&gt;
    &lt;&lt; define escape stuff &gt;&gt;
    &lt;&lt; define namespaces &gt;&gt;
    &lt;&lt; create alias table &gt;&gt;
    &lt;&lt; define inpsector &gt;&gt;
    
    self.inputcache = dummyCache(self.user_ns)
    self.outputcache = dummyCache(self.user_ns)
    self.CACHELENGTH = 0</t>
<t tx="ekr.20050708091220.78">shell = IPython.Shell.IPShellEmbed (
    argv=[],
    banner='Welcome to IPython in Leo',
    exit_msg='Bye',
    rc_override={
        'confirm_exit':0,
        #'readline':0, # Crashes the interactive interp.
    },
)
shell()</t>
<t tx="ekr.20050708093114"># Don't get carried away with trying to make the autocalling catch too
# much:  it's better to be conservative rather than to trigger hidden
# evals() somewhere and end up causing side effects.

self.line_split = re.compile(
    r'^([\s*,;/])'
    r'([\?\w\.]+\w*\s*)'
    r'(\(?.*$)'
)

# RegExp to identify potential function names
self.re_fun_name = re.compile(r'[a-zA-Z_]([a-zA-Z0-9_.]*) *$')

# RegExp to exclude strings with this start from autocalling
self.re_exclude_auto = re.compile('^[!=()&lt;&gt;,\*/\+-]|^is ')

# try to catch also methods for stuff in lists/tuples/dicts: off
# (experimental). For this to work, the line_split regexp would need
# to be modified so it wouldn't break things at '['. That line is
# nasty enough that I shouldn't change it until I can test it _well_.
#self.re_fun_name = re.compile (r'[a-zA-Z_]([a-zA-Z0-9_.\[\]]*) ?$')</t>
<t tx="ekr.20050708093224"># escapes for automatic behavior on the command line
self.ESC_SHELL = '!'
self.ESC_HELP  = '?'
self.ESC_MAGIC = '%'
self.ESC_QUOTE = ','
self.ESC_QUOTE2 = ';'
self.ESC_PAREN = '/'

# And their associated handlers
self.esc_handlers = {
    self.ESC_PAREN: self.handle_auto,
    self.ESC_QUOTE: self.handle_auto,
    self.ESC_QUOTE2:self.handle_auto,
    self.ESC_MAGIC: self.handle_magic,
    self.ESC_HELP:  self.handle_help,
    self.ESC_SHELL: self.handle_shell_escape,
}</t>
<t tx="ekr.20050708093433"># Set __name__ to __main__ to better match the behavior of the normal interpreter.

self.user_ns = {
    '__name__'     :'__main__',
    '__builtins__' : __builtin__,
}

self.internal_ns = __main__.__dict__.copy()</t>
<t tx="ekr.20050708094606.1"># dict of names to be treated as system aliases.  Each entry in the
# alias table must be a 2-tuple of the form (N,name), where N is the
# number of positional arguments of the alias.
self.alias_table = {}</t>
<t tx="ekr.20050708095104">class dummyCache:
    
    @others</t>
<t tx="ekr.20050708095104.1">def log(self,line,continuation=None):
    
    # Called by the logger (not sure how).
    if 0:
        g.trace(line)</t>
<t tx="ekr.20050708105323.2">def usage(self):
    
    return 'A usage message'</t>
<t tx="ekr.20050708105323.3">def ipmagic(s):
    g.trace()
    return IPython.iplib.ipmagic(s)
    
def ipalias(s):
    g.trace()
    return IPython.iplib.ipalias(s)</t>
<t tx="ekr.20050708105742"># EKR: take from make_IPython

# This should have everything from  cmdline_opts and cmdline_only
self.rc = Struct(
    autocall = 1,
    autoindent=0,
    automagic = 1,
    banner = 1,
    cache_size = 1000,
    c = '',
    classic = 0,
    colors = 'NoColor',
    color_info = 0,
    confirm_exit = 1,
    debug = 0,
    deep_reload = 0,
    editor = '0',
    help = 0,
    ignore = 0,
    ipythondir = ipythondir,
    log = 0,
    logfile = '',
    logplay = '',
    multi_line_specials = 1,
    messages = 1,
    nosep = 0,
    pdb = 0,
    pprint = 0,
    profile = '',
    prompt_in1 = 'In [\\#]:',
    prompt_in2 = '   .\\D.:',
    prompt_out = 'Out[\\#]:',
    prompts_pad_left = 1,
    quick = 0,
    readline = 1,
    readline_merge_completions = 1,
    readline_omit__names = 0,
    rcfile = 'ipythonrc' + rc_suffix,
    screen_length = 0,
    separate_in = '\n',
    separate_out = '\n',
    separate_out2 = '',
    system_verbose = 0,
    gthread = 0,
    qthread = 0,
    wthread = 0,
    pylab = 0,
    tk = 0,
    upgrade = 0,
    Version = 0,
    xmode = 'Verbose',
    magic_docstrings = 0,  # undocumented, for doc generation
)</t>
<t tx="ekr.20050708110239"># EKR: take from make_IPython.

# Platform-dependent suffix and directory names
if os.name == 'posix':
    rc_suffix = ''
    ipdir_def = '.ipython'
else:
    rc_suffix = '.ini'
    ipdir_def = '_ipython'

# default directory for configuration
if 1: ### Leo
    ipythondir = g.app.loadDir
else:
    ipythondir = os.path.abspath(
        os.environ.get('IPYTHONDIR',
        os.path.join(IP.home_dir,ipdir_def)))</t>
<t tx="ekr.20050708110336">import IPython
import IPython.genutils
from IPython.Struct import Struct

import __builtin__
import __main__
import os
import re
import sys

# we need the directory where IPython itself is installed
IPython_dir = os.path.dirname(IPython.__file__)</t>
<t tx="ekr.20050708113006.2">def system(self,s):
    
    g.trace(s)
    pass</t>
<t tx="ekr.20050708142137">def __init__ (self,user_ns):
    
    self.last_prompt = None
    self.prompt_count = 0
    self.user_ns = user_ns
    
    if 1:
        self.prompt1 = dummyPrompt('name=prompt1')
        self.prompt2 = dummyPrompt('name=prompt2')
        self.prompt_out = dummyPrompt('name=prompt_out')
    else:
        input_sep='\n'
        self.ps1_str = '&gt;&gt;&gt; '   ### self._set_prompt_str(ps1,'In [\\#]: ','&gt;&gt;&gt; ')
        self.ps2_str = '... '   ### self._set_prompt_str(ps2,'   .\\D.: ','... ')
        self.ps_out_str = ','   ### self._set_prompt_str(ps_out,'Out[\\#]: ','')
        pad_left=True
            
        self.prompt1 = IPython.Prompts.Prompt1(self,
            sep=input_sep,prompt=self.ps1_str,pad_left=pad_left)
        self.prompt2 = IPython.Prompts.Prompt2(self,
            prompt=self.ps2_str,pad_left=pad_left)
        self.prompt_out = IPython.Prompts.PromptOut(self,
            sep='',prompt=self.ps_out_str,pad_left=pad_left)
        
    self.last_prompt = self.prompt1 # Total kludge.</t>
<t tx="ekr.20050708142137.2">def __len__ (self):
    return 0
    
def insert(self,n,line):
    pass
    
def pop(self):
    return ''</t>
<t tx="ekr.20050708143008">class dummyPrompt (IPython.Prompts.BasePrompt):

    """Interactive prompt similar to Mathematica's."""

	@others</t>
<t tx="ekr.20050708143008.2">def __init__(self,cache=None,sep=None,prompt=None,pad_left=False,name='prompt'):
    
    self.name = name</t>
<t tx="ekr.20050708143008.3">def set_p_str(self):
    """ Set the interpolating prompt strings.

    This must be called every time the color settings change, because the
    prompt_specials global may have changed."""
    
    return ###

    import os,time  # needed in locals for prompt string handling
    loc = locals()
    self.p_str = ItplNS('%s%s%s' %
                        ('${self.sep}${self.col_p}',
                         multiple_replace(prompt_specials, self.p_template),
                         '${self.col_norm}'),self.cache.user_ns,loc)
    
    self.p_str_nocolor = ItplNS(multiple_replace(prompt_specials_nocolor,
                                                 self.p_template),
                                self.cache.user_ns,loc)
</t>
<t tx="ekr.20050708143008.4">def write(self,msg):  # dbg

    return '' ###

    sys.stdout.write(msg)
    return ''
</t>
<t tx="ekr.20050708143008.5">def __str__(self):
    """Return a string form of the prompt.

    This for is useful for continuation and output prompts, since it is
    left-padded to match lengths with the primary one (if the
    self.pad_left attribute is set)."""
    
    return self.name ###

    out_str = str_safe(self.p_str)
    if self.pad_left:
        # We must find the amount of padding required to match lengths,
        # taking the color escapes (which are invisible on-screen) into
        # account.
        esc_pad = len(out_str) - len(str_safe(self.p_str_nocolor))
        format = '%%%ss' % (len(str(self.cache.last_prompt))+esc_pad)
        return format % out_str
    else:
        return out_str
</t>
<t tx="ekr.20050708143008.6"># these path filters are put in as methods so that we can control the
# namespace where the prompt strings get evaluated.

def cwd_filt(self,depth):

    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""
    
    cwd = os.getcwd().replace(HOME,"~")
    out = os.sep.join(cwd.split(os.sep)[-depth:])
    if out:
        return out
    else:
        return os.sep
</t>
<t tx="ekr.20050708143008.7">def cwd_filt2(self,depth):
    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""

    cwd = os.getcwd().replace(HOME,"~").split(os.sep)
    if '~' in cwd and len(cwd) == depth+1:
        depth += 1
    out = os.sep.join(cwd[-depth:])
    if out:
        return out
    else:
        return os.sep
</t>
<t tx="ekr.20050708144144.1">if 0:
    @others</t>
<t tx="ekr.20050708144144.2">def auto_rewrite(self,*args,**keys):
    return ''</t>
<t tx="ekr.20050708150223">ins_colors = IPython.OInspect.InspectColors
code_colors = IPython.PyColorize.ANSICodeColors

self.inspector = IPython.OInspect.Inspector(ins_colors,code_colors,'NoColor')</t>
<t tx="ekr.20050708152111">def _prefilter(self, line, continue_prompt):
    """Calls different preprocessors, depending on the form of line."""
    
    &lt;&lt; about this function &gt;&gt;

    # save the line away in case we crash, so the post-mortem handler can record it
    self._last_input_line = line

    #print '***line: &lt;%s&gt;' % line # dbg
    if not line.strip():
        &lt;&lt; handle empty line &gt;&gt;

    # print '***cont',continue_prompt  # dbg
    # special handlers are only allowed for single line statements
    if continue_prompt and not self.rc.multi_line_specials:
        return self.handle_normal(line,continue_prompt)

    # Get the structure of the input
    pre,iFun,theRest = self.split_user_input(line)
    #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg
    
    &lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;
    &lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;
    &lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;
    &lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;

    # If we get here, we have a normal Python line. Log and return.
    return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708152111.1"># All handlers *must* return a value, even if it's blank ('').

# Lines are NOT logged here. Handlers should process the line as
# needed, update the cache AND log it (so that the input cache array
# stays synced).

# This function is _very_ delicate, and since it's also the one which
# determines IPython's response to user input, it must be as efficient
# as possible.  For this reason it has _many_ returns in it, trying
# always to exit as quickly as it can figure out what it needs to do.

# This function is the main responsible for maintaining IPython's
# behavior respectful of Python's semantics.  So be _very_ careful if
# making changes to anything here.</t>
<t tx="ekr.20050708152111.2"># the input history needs to track even empty lines

if not continue_prompt:
    self.outputcache.prompt_count -= 1

return self.handle_normal('',continue_prompt)</t>
<t tx="ekr.20050708152111.3">handler = None
if line[-1] == self.ESC_HELP:
    handler = self.esc_handlers.get(line[-1])  # the ? can be at the end
    
if handler is None:
    # look at the first character of iFun, NOT of line, so we skip
    # leading whitespace in multiline input
    handler = self.esc_handlers.get(iFun[0:1])

if handler is not None:
    return handler(line,continue_prompt,pre,iFun,theRest)

# Emacs ipython-mode tags certain input lines
if line.endswith('# PYTHON-MODE'):
    return self.handle_emacs(line,continue_prompt)</t>
<t tx="ekr.20050708152111.4"># Allow ! in multi-line statements if multi_line_specials is on:
if (
    continue_prompt and self.rc.multi_line_specials and iFun.startswith(self.ESC_SHELL)
):
    return self.handle_shell_escape(line,continue_prompt,
            pre=pre,iFun=iFun,theRest=theRest)</t>
<t tx="ekr.20050708152111.5">oinfo = None

if hasattr(self,'magic_'+iFun):
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic
    if oinfo['ismagic']:
        # Be careful not to call magics when a variable assignment is
        # being made (ls='hi', for example)
        if (
            self.rc.automagic and
            (len(theRest)==0 or theRest[0] not in '!=()&lt;&gt;,') and 
            (self.rc.multi_line_specials or not continue_prompt)
        ):
            return self.handle_magic(line,continue_prompt,pre,iFun,theRest)
        else:
            return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708152111.6"># If the rest of the line begins with an (in)equality, assginment or
# function call, we should not call _ofind but simply execute it.
# This avoids spurious geattr() accesses on objects upon assignment.
#
# It also allows users to assign to either alias or magic names true
# python variables (the magic/alias systems always take second seat to
# true python code).
if theRest and theRest[0] in '!=()':
    return self.handle_normal(line,continue_prompt)

if oinfo is None:
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic

if not oinfo['found']:
    return self.handle_normal(line,continue_prompt)
else:
    #print 'iFun &lt;%s&gt; rest &lt;%s&gt;' % (iFun,theRest) # dbg
    if oinfo['isalias']:
        return self.handle_alias(line,continue_prompt,
                                     pre,iFun,theRest)

    if self.rc.autocall and \
           not self.re_exclude_auto.match(theRest) and \
           self.re_fun_name.match(iFun) and \
           callable(oinfo['obj']) :
        #print 'going auto'  # dbg
        return self.handle_auto(line,continue_prompt,pre,iFun,theRest)
    else:
        #print 'was callable?', callable(oinfo['obj'])  # dbg
        return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708152111.7"></t>
<t tx="ekr.20050708152111.9">def _prefilter(self, line, continue_prompt):
    """Calls different preprocessors, depending on the form of line."""
    
    &lt;&lt; about this function &gt;&gt;

    #if line.startswith('%crash'): raise RuntimeError,'Crash now!'  # dbg

    # save the line away in case we crash, so the post-mortem handler can record it
    self._last_input_line = line

    if not line.strip():
        return ''

    # special handlers are only allowed for single line statements
    if continue_prompt and not self.rc.multi_line_specials:
        return line

    # Get the structure of the input
    pre,iFun,theRest = self.split_user_input(line)
    #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg
    
    &lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;
    &lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;
    &lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;
    &lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;

    # A normal Python line.
    return line</t>
<t tx="ekr.20050708152111.10"># All handlers *must* return a value, even if it's blank ('').

# Lines are NOT logged here. Handlers should process the line as
# needed, update the cache AND log it (so that the input cache array
# stays synced).

# This function is the main responsible for maintaining IPython's
# behavior respectful of Python's semantics.  So be _very_ careful if
# making changes to anything here.</t>
<t tx="ekr.20050708152111.12">handler = None
if line[-1] == self.ESC_HELP:
    handler = self.esc_handlers.get(line[-1])  # the ? can be at the end
    
if handler is None:
    # look at the first character of iFun, NOT of line, so we skip
    # leading whitespace in multiline input
    handler = self.esc_handlers.get(iFun[0:1])

if handler is not None:
    return handler(line,continue_prompt,pre,iFun,theRest)

# Emacs ipython-mode tags certain input lines
if line.endswith('# PYTHON-MODE'):
    return self.handle_emacs(line,continue_prompt)</t>
<t tx="ekr.20050708152111.13"># Allow ! in multi-line statements if multi_line_specials is on:
if (
    continue_prompt and self.rc.multi_line_specials and iFun.startswith(self.ESC_SHELL)
):
    return self.handle_shell_escape(line,continue_prompt,pre=pre,iFun=iFun,theRest=theRest)</t>
<t tx="ekr.20050708152111.14">oinfo = None

if hasattr(self,'magic_'+iFun):
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic
    if oinfo['ismagic']:
        # Be careful not to call magics when a variable assignment is
        # being made (ls='hi', for example)
        if (
            self.rc.automagic and
            (len(theRest)==0 or theRest[0] not in '!=()&lt;&gt;,') and 
            (self.rc.multi_line_specials or not continue_prompt)
        ):
            return self.handle_magic(line,continue_prompt,pre,iFun,theRest)
        else:
            return line</t>
<t tx="ekr.20050708152111.15"># If the rest of the line begins with an (in)equality, assginment or
# function call, we should not call _ofind but simply execute it.
# This avoids spurious geattr() accesses on objects upon assignment.
#
# It also allows users to assign to either alias or magic names true
# python variables (the magic/alias systems always take second seat to
# true python code).
if theRest and theRest[0] in '!=()':
    return line

if oinfo is None:
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic

if not oinfo['found']:
    return line

if oinfo['isalias']:
    return self.handle_alias(line,continue_prompt,pre,iFun,theRest)

if (self.rc.autocall and not self.re_exclude_auto.match(theRest) and 
    self.re_fun_name.match(iFun) and callable(oinfo['obj'])
):
    return self.handle_auto(line,continue_prompt,pre,iFun,theRest)
else:
    return line</t>
<t tx="ekr.20050708152111.17">def handle_alias(self,line,continue_prompt=None,pre=None,iFun=None,theRest=None):

    """Handle alias input lines. """

    theRest = esc_quotes(theRest)

    line_out = "%s%s.call_alias('%s','%s')" % (pre,self.name,iFun,theRest)

    return line_out</t>
<t tx="ekr.20050708152111.18">def handle_shell_escape(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):

    """Execute the line in a shell, empty return value"""

    # Example of a special handler. Others follow a similar pattern.
    if continue_prompt:  # multi-line statements
        if iFun.startswith('!!'):
            print 'SyntaxError: !! is not allowed in multiline statements'
            return pre
        else:
            cmd = ("%s %s" % (iFun[1:],theRest)).replace('"','\\"')
            line_out = '%s%s.system("%s")' % (pre,self.name,cmd)
    else: # single-line input
        if line.startswith('!!'):
            # rewrite iFun/theRest to properly hold the call to %sx and
            # the actual command to be executed, so handle_magic can work
            # correctly
            theRest = '%s %s' % (iFun[2:],theRest)
            iFun = 'sx'
            return self.handle_magic('%ssx %s' % (
                self.ESC_MAGIC,line[2:]),continue_prompt,pre,iFun,theRest)
        else:
            cmd = esc_quotes(line[1:])
            line_out = '%s.system("%s")' % (self.name,cmd)

    return line_out
</t>
<t tx="ekr.20050708152111.19">def handle_magic(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):
    
    """Execute magic functions.

    Also log them with a prepended # so the log is clean Python."""

    return '%sipmagic("%s")' % (pre,esc_quotes('%s %s' % (iFun,theRest)))</t>
<t tx="ekr.20050708152111.20">def handle_auto(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):

    """Hande lines which can be auto-executed, quoting if requested."""
    
    # This should only be active for single-line input!
    if continue_prompt:
        return line
    elif pre == self.ESC_QUOTE: # Auto-quote splitting on whitespace
        return '%s("%s")\n' % (iFun,'", "'.join(theRest.split()) )
    elif pre == self.ESC_QUOTE2: # Auto-quote whole string
        return '%s("%s")\n' % (iFun,theRest)
    else: # Auto-paren
        if theRest[0:1] in ('=','['):
            # Don't autocall in these cases.  They can be rebindings of an existing callable's name,
            # or item access for an object which is BOTH callable and implements __getitem__.
            return '%s %s\n' % (iFun,theRest)
        if theRest.endswith(';'):
            return '%s(%s);\n' % (iFun.rstrip(),theRest[:-1])
        else:
            return '%s(%s)\n' % (iFun.rstrip(),theRest)</t>
<t tx="ekr.20050708152111.21">def handle_help(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Try to get some help for the object.

    obj? or ?obj   -&gt; basic information.
    obj?? or ??obj -&gt; more details.
    """

    # Don't process lines which would be otherwise valid python, such as "x=1 # what?"
    try:
        code.compile_command(line)
    except SyntaxError: # Only handle stuff which is NOT valid syntax
        if line[0]==self.ESC_HELP:
            line = line[1:]
        elif line[-1]==self.ESC_HELP:
            line = line[:-1]
        if line:
            self.magic_pinfo(line)
        else:
            page(self.usage,screen_lines=self.rc.screen_length)
        return '' # Empty string is needed here!
    except: pass

    return line</t>
<t tx="ekr.20050708152111.22">def handle_emacs(self,line,continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Handle input lines marked by python-mode."""

    # Currently, nothing is done.
    # The input cache shouldn't be updated
    return line</t>
<t tx="ekr.20050708152111.23"></t>
<t tx="ekr.20050708152111.24">if 0: # ref
    self.line_split = re.compile(
        r'^([\s*,;/])'          # Groups[0]: s, followed by special chars: , ; or /
        r'([\?\w\.]+\w*\s*)'    # Groups[1]: one char,
        r'(\(?.*$)' )           # Groups[2]: arg list

def split_user_input(self,line):

    """Split user input into pre-char, function part and rest."""

    lsplit = self.line_split.match(line)

    if lsplit is None:  # no regexp match returns None
        try:
            iFun,theRest = line.split(None,1)
        except ValueError:
            iFun,theRest = line,''
        pre = re.match('^(\s*)(.*)',line).groups()[0]
    else:
        pre,iFun,theRest = lsplit.groups()

    print 'line:&lt;%s&gt;' % line # dbg
    print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun.strip(),theRest) # dbg

    return pre,iFun.strip(),theRest</t>
<t tx="ekr.20050708152111.25">def update_cache(self, line):
    
    """puts line into cache"""
    
    pass</t>
<t tx="ekr.20050708165401.1">def handle_normal(self,line,continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Handle normal input lines. Use as a template for handlers."""
    
    g.trace(line)

    if 0:
        self.log(line,continue_prompt)
        self.update_cache(line)

    return line</t>
<t tx="ekr.20050708165531.1">def esc_quotes(s):

    return IPython.iplib.esc_quotes(s)</t>
<t tx="ekr.20050715132524">from Pymacs import lisp
print lisp

lisp('2')</t>
<t tx="ekr.20050726101926">def keyPressed( self, event ):

    &lt;&lt; create the command &gt;&gt;
    self.kTconsume = self.kRconsume = consume = self.emacs.masterCommand(event,command)
    if consume:
        # Block the event from going elsewhere, like the DocumentModel.
        event.consume()
        return

    kc = event.getKeyChar()
    if self.tab_for_colon and kc == '\n':
        event.consume()
        self.insertPreviousLeadAndNewline()
    if self.completers.has_key(kc):
        &lt;&lt; handle auto completion &gt;&gt;
    elif kc == '\t' and self.tab_width == -4:
        &lt;&lt; handle auto-tabbing &gt;&gt;
</t>
<t tx="ekr.20050726101926.1">modifiers = event.getModifiers()
mtxt = event.getKeyModifiersText(modifiers)
ktxt = event.getKeyText(event.getKeyCode())

if mtxt == ktxt:
    command = mtxt
else:
    command = '%s %s' % (mtxt,ktxt).strip()
</t>
<t tx="ekr.20050726101926.2">editor = self.emacs.editor
doc = editor.getDocument()
pos = editor.getCaretPosition()
try:
    pc = doc.getText( pos -1, 1 )
    if pc in ( '"', "'" ): return
except: pass

event.consume()
self.kTconsume = True
self.kRconsume = True
ac = self.completers[ kc ]
doc.insertString( pos, '%s%s' %( kc, ac ), None )
editor.setCaretPosition( pos + 1 )
if hasattr(self.emacs.c.frame.body.editor, "autocompleter"):
    self.emacs.c.frame.body.editor.autocompleter.hideAutoBox() </t>
<t tx="ekr.20050726101926.3">self.kTconsume = True
self.kRconsume = True
event.consume()
editor = self.emacs.editor
doc = editor.getDocument()
pos = editor.getCaretPosition()
try:
    doc.insertString( pos, " " * 4, None )
except: pass</t>
<t tx="ekr.20050801070538">def compressed(a,b):
    if(a==b):
        a=b+c*d
    if a==b:
        return 1
    return(a,b,c)
        
def loose ( a , b ) :
    if a  ==  b:
        return 1
    while a != 2 :
        a = b + c * d
</t>
<t tx="ekr.20050801075332">def compressed(a,b):
    if(a==b):
        a=b+c*d
    if a==b:
        return 1
    return(a,b,c)
        
def loose ( a , b ) :
    if a  ==  b:
        return 1
    while a != 2 :
        a = b + c * d
</t>
<t tx="ekr.20050803075926">@tabwidth -4

# Solves the sudoku puzzle.

import copy

digits = '123456789' # valid digits.

if 0:
    &lt;&lt; 1-star puzzles &gt;&gt;
    &lt;&lt; 2-star puzzles &gt;&gt;
    &lt;&lt; 3-star puzzles &gt;&gt;
    &lt;&lt; 4-star puzzles &gt;&gt;
    &lt;&lt; 5-star puzzles &gt;&gt;

&lt;&lt; define data &gt;&gt;

@others

print '-' * 40

solver = sudokuClass(data=data)
if not solver.errors:
    solver.solve()
</t>
<t tx="ekr.20050803075926.1">class sudokuClass:
    
    '''A class to solve the sudoku puzzle.'''
    
    @others</t>
<t tx="ekr.20050803075926.2">def __init__ (self,data):
    
    # g.trace('main')
    self.cells = []
    self.cols = []
    self.colGroups = []
    self.data = data
    self.errors = 0
    self.excludedGroupNumbers = []
    self.level = 0
    self.rowGroups = []
    self.rows = []
    self.squareGroups = []
    self.tracing = True
    self.valid = True
    self.verbose = False

    # Check the data and finish the init process.
    self.checkData()
    self.initFromData()
    self.printData()
    self.finishInit()
    # self.dump()</t>
<t tx="ekr.20050803075926.3">def error (self,s):
    
    print 'oops',s
    self.errors += 1</t>
<t tx="ekr.20050803075926.4">def finishInit (self):

    for i in xrange(9):
        self.squareGroups.append(self.squareGroupClass(self,i))
        self.rowGroups.append(self.colGroupClass(self,i))
        self.colGroups.append(self.rowGroupClass(self,i))
    
    for z in self.squareGroups:
        z.finishCreate()
    for z in self.rowGroups:
        z.finishCreate()
    for z in self.colGroups:
        z.finishCreate()

    # Must be done last!
    for z in self.squareGroups:
        z.computeRelatedGroups()
    for z in self.cells:
        z.finishCreate()</t>
<t tx="ekr.20050803075926.5">def solve (self):
    
    n = 0 ; self.valid = True
    while not self.errors and self.valid:
        n += 1
        self.progress = 0
        if self.tracing:
            print '*' * 40
            print 'solve: iteration %d at level %d' % (n,self.level)
        if not self.check(): return False
        if self.tracing: self.printCells()
        for cell in self.cells:
            # Reduce the possible values for the cell.
            cell.reduce()
        if not self.valid: break
        for cell in self.cells:
            # Find any values that appear only in one place in a group.
            cell.unique()
        if self.isFinished():
            self.printCells('success!') ; return True
        if self.tracing: self.printCells()
        for cell in self.cells:
            # Remove any possible values that would make other groups impossible.
            cell.removeConflicts()
        if not self.valid: break
        if self.isFinished():
            if self.level == 0: self.printCells('success!')
            return True
        if self.progress == 0:
            &lt;&lt; guess an answer &gt;&gt;

    if self.tracing:
        if not self.valid:
            print ; print 'reached invalid state'
        if self.progress == 0:
            print ; print 'no progress'
        self.printCells()
    return False</t>
<t tx="ekr.20050803075926.7">class cellClass:
    
    '''A class representing what is known about a particular cell.'''
    
    @others</t>
<t tx="ekr.20050803080858">def dump (self):
    
    if 0:
        print ; print 'groups...'
        for group in self.groups:
            print 'group %d, rowsNumbers: %s colNumbers: %s' % (
                group.groupNumber,group.rowNumbers,group.colNumbers)
            
    if 0:
        print ; print 'row groups...'
        for group in self.rowGroups:
            print '%d %s' % (group.rowNumber, group.rowcol)
            
    if 0:
        print ; print 'related groups...'
        for group in self.groups:     
            print 'Groups related to group %d: %s' % (
                group.groupNumber,[g.groupNumber for g in group.relatedGroups])</t>
<t tx="ekr.20050803081438">def __init__ (self,sudoku,val,i,j):
    
    # g.trace('cell',i,j,val)
    self.i = i
    self.j = j
    self.groupNumber = sudoku.groupNumber(i,j)
    self.main = sudoku
    if val is None:     self.values = [digit for digit in digits]
    else:               self.values = [str(val)]
    self.verbose = self.main.verbose

    # Set by group ctors...
    self.colGroup = None
    self.rowGroup = None
    self.squareGroup = None</t>
<t tx="ekr.20050803095202">def groupNumber (self,row,col):
    
    return (3 * (row // 3)) + (col // 3)</t>
<t tx="ekr.20050803121102">def checkData (self):
    
    rows = len(self.data)
    
    if rows != 9:
        return self.error('wrong number of rows: %d' % rows)
        
    for row in self.data:
        cols = len(row)
        if cols != 9:
            return self.error('wrong number of columns in row %d: %d' % (i,cols))</t>
<t tx="ekr.20050803121102.2">def __init__ (self,sudoku,n):
    
    # g.trace('square',n)
    self.groupNumber = n
    self.main = sudoku
    
    # Set later...
    self.cells = []
    self.colNumbers = []
    self.rowNumbers = []
    self.relatedGroups = []</t>
<t tx="ekr.20050803121730">def printData (self,tag='initial data'):
    
    print ; print tag ; print

    i = 0
    for row in self.rows:
        i += 1
        print
        for ch in row:
            if ch:
                print ('  %s  ') % ch,
            else:
                print ' ___ ',
        if i % 3 == 0 and i &lt; 9:
            print ; print ; print '_' * 53
        print
    print</t>
<t tx="ekr.20050803130829">def finishCreate (self):
    
    main = self.main

    self.cells = [cell for cell in main.cells if cell.groupNumber == self.groupNumber]
    
    for cell in self.cells:
        cell.squareGroup = self

    self.rowNumbers = []
    for cell in self.cells:
        if cell.i not in self.rowNumbers:
            self.rowNumbers.append(cell.i)
    self.rowNumbers.sort()
            
    self.colNumbers = []
    for cell in self.cells:
        if cell.j not in self.colNumbers:
            self.colNumbers.append(cell.j)
    self.colNumbers.sort()</t>
<t tx="ekr.20050803134436.1">def valIsPossible (self,val):

    # g.trace(self,val)
    assert(val is not None)

    for cell in self.rowGroup.cells:
        if cell is not self:
            if len(cell.values) == 1 and cell.values[0] == val:
                if self.main.tracing:
                    g.trace('invalid guess: %s in row %d: %s' % (val,self.i,self.rowGroup.cells))
                return False
            
    for cell in self.colGroup.cells:
        if cell is not self:
            if len(cell.values) == 1 and cell.values[0] == val:
                if self.main.tracing:
                    g.trace('invalid guess: %s in col %d: %s' % (val,self.j,self.colGroup.cells))
                return False

    return True</t>
<t tx="ekr.20050803161504">def computeRelatedGroups (self):
    
    self.relatedGroups = []
    for group in self.main.squareGroups:
        if group is not self:
            related = False
            for n in group.colNumbers:
                if n in self.colNumbers:
                    related = True
            for n in group.rowNumbers:
                if n in self.rowNumbers:
                    related = True
            if related and group not in self.relatedGroups:
                self.relatedGroups.append(group)</t>
<t tx="ekr.20050803200132">def printCells (self,tag=''):
    
    print
    if tag: print tag ; print
    
    i = 0
    for cell in self.cells:
        if len(cell.values) == 9:
            print '%7s' % '1..9',
        else:
            print '%7s' % ''.join(cell.values),
        i += 1
        if i % 9 == 0:
            print</t>
<t tx="ekr.20050803200724">def __repr__ (self):
    
    return 'cell[%d,%d]' % (self.i, self.j)
    
__str__ = __repr__</t>
<t tx="ekr.20050803202932">def initFromData (self):
    
    i = 0
    for row in self.data:
        thisRow = []
        j = 0
        for ch in row:
            if ch in digits:    val = ch
            else:               val = None
            self.cells.append(self.cellClass(self,val,i,j))
            thisRow.append(val)
            j += 1
        self.rows.append(thisRow)
        i += 1

    for j in xrange(9):
        col = [row[j] for row in self.rows]
        self.cols.append(col)</t>
<t tx="ekr.20050803202932.1">def isFinished (self):
    
    for cell in self.cells:
        n = len(cell.values)
        assert(n &gt; 0) # We should have check for self.valid previously.
        if n &gt; 1:
            return False
    return True</t>
<t tx="ekr.20050803203001">def findBestGroup (self,excludedGroupNumbers):
    
    bestGroup = None
    bestKnown = 0
    for group in self.squareGroups:
        n = 0 # Number of known cells
        for cell in group.cells:
            if len(cell.values) == 1:
                n += 1
        if 9 &gt; n &gt; bestKnown:
            if group.groupNumber not in excludedGroupNumbers:
                bestGroup = group
                bestKnown = n

    if bestGroup:
        if self.tracing:
            print ; print 'best group %d' % bestGroup.groupNumber
            if 0:
                if self.verbose:
                    print 'unknown cells',
                    for cell in bestGroup.unknownCells():
                        print cell,
                    print 'unknown vals',
                    for val in bestGroup.unknownVals():
                        print val,
                    print

    return bestGroup</t>
<t tx="ekr.20050803210939">def findGuesses (self):
    
    guesses = []
    group = self.findBestGroup(self.excludedGroupNumbers)
    self.excludedGroupNumbers.append(group.groupNumber)
    if not group:
        g.trace('No groups left to guess: %s' % excludedGroupNumbers)
        self.valid = False
        return []

    # Generate all combinations of cells and unkown vals.
    cells = [cell for cell in group.cells if len(cell.values) &gt; 1]
    vals = []
    for cell in cells:
        for val in cell.values:
            if val not in vals: vals.append(val)
    n = len(vals)
    for i in xrange(n):
        guess = [] ; j = 0
        for cell in cells:
            bunch = g.bunch(cell=cell,val=vals[(i+j)%n])
            j += 1
            guess.append(bunch)
        if self.isValidGuess(guess):
            guesses.append(guess)
    
    if not guesses:
        g.trace('No valid guess for group %d' % group.groupNumber)
        self.valid = False
        return []

    if 0: # Another trace is in initFromGuess
        print 'level %d guesses...' % self.level
        for guess in guesses:
            for bunch in guess:
                print bunch.cell,bunch.val

    return guesses</t>
<t tx="ekr.20050803215553">def trace (self,s):
    
    if self.tracing:
        print s</t>
<t tx="ekr.20050804060706">def isValidGuess (self,guess):
    
    return True ##
    
    for bunch in guess:
        if not bunch.cell.valIsPossible(bunch.val):
            return False

    return True</t>
<t tx="ekr.20050804070733">def check (self):
    
    for groups in (self.colGroups,self.rowGroups,self.squareGroups):
        for group in groups:
            if not self.checkGroup(group):
                return False
    return True
</t>
<t tx="ekr.20050804071049">def checkGroup (self,group):

    vals = []
    for cell in group.cells:
        n = len(cell.values)
        if n == 1:
            val = cell.values[0]
            if val in vals:
                g.trace('%s appears twice in group %s' % (val,repr(group)))
                return False
            vals.append(val)
    return True</t>
<t tx="ekr.20050804071242"></t>
<t tx="ekr.20050804073824">data = (
    '',
) 

data = (
    '4xxxxxxxx',
    '96xxx85xx',
    'x374x6xx1',
    '3x48xxx6x',
    'xxxx1xxxx',
    'x5xxx92x7',
    '5xx1x267x',
    'xx95xxx82',
    'xxxxxxxx9',
)
</t>
<t tx="ekr.20050805150320">import leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    rst3.controller.processTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050811075608">data = (
    '8xxx9x21x',
    'x9x4xxxxx',
    'xx58x7xx9',
    '7xx1xx9xx',
    'xxxx5xxxx',
    'xx6xx3x28',
    '6xx5x93xx',
    'xxxxx6x7x',
    'x48x1xxx6',
)

data = ( # 8/3: solvable.
    'x5xx9xxxx',
    'xx48xxxx9',
    'xxx1x728x',
    '56xxxx137',
    'xxxxxxxxx',
    '173xxxx42',
    'x215x8xxx',
    '6xxxx38xx',
    'xxxx1xx6x')
    
data = ( # 1 stars
    'x4xxxx179',
    'xx2xx8x54',
    'xx6xx5xx8',
    'x8xx7x91x',
    'x5xx9xx3x',
    'x1xx6xx4x',
    '3xx4xx7xx',
    '57x1xx2xx',
    '928xxxx6x')
    
data = (
    '6xx75x1xx',
    '8xxxx34xx',
    'x3x96xx25',
    'xxx4xx3x2',
    '7xxxxxxx6',
    '2x1xx5xxx',
    '31xx89x4x',
    'xx65xxxx1',
    'xx5x42xx3') # solvable.
    
data = (
    'xxxxx6xx5',
    'xx41xx8xx',
    'x5xx78x42',
    '58xxxx9xx',
    '3xxxxxxx7',
    'xx6xxxx18',
    '24x39xx7x',
    'xx7xx52xx',
    '9xx7xxxxx') # solvable

data = (
    'xxxxx6xx5',
    'xx41xx8xx',
    'x5xx78x42',
    '58xxxx9xx',
    '3xxxxxxx7',
    'xx6xxxx18',
    '24x39xx7x',
    'xx7xx52xx',
    '9xx7xxxxx') # 9/8/05 3 stars

data = (
    'xxxx64x15',
    'x549xx6x2',
    'xxxxxxx7x',
    'xxxx8x2xx',
    '1x8xxx5x7',
    'xx7x4xxxx',
    'x3xxxxxxx',
    '8x2xx319x',
    '94x87xxxx') # 9/9/05 3 stars
        
data = (
    '8xxxxxxxx',
    'x915x36xx',
    'x62xxxx8x',
    'xx9xx8xxx',
    'x752x984x',
    'xxx4xx9xx',
    'x1xxxx42x',
    'xx49x276x',
    'xxx7xxxx5',
)</t>
<t tx="ekr.20050821072028"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20050821072028.1">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050821081021"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20050821081021.1">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050824190822">@color

import ZODB
import ZODB.FileStorage

storage = ZODB.FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs")
# g.trace(storage)
db = ZODB.DB(storage)
try:
    try:
        print '-' * 20
        print 'opening ZODB'
        connection = db.open()
        g.trace(connection)
        root = connection.root()
        if 1:
            t = get_transaction()
            t.begin()
            # root.clear()
            root ['count'] = root.get('count',0) + 1
            t.commit()
        g.trace(root)
        connection.close()
    except Exception:
        g.es_exception()
finally:
    print 'closing ZODB'
    db.close()
    </t>
<t tx="ekr.20050910194752">class colGroupClass:
    
    @others</t>
<t tx="ekr.20050910194752.1">def __init__ (self,sudoku,j):
    
    # g.trace('col',j)
    self.j = j
    self.main = sudoku
    
    # Set later...
    self.cells = []
    self.col = None
   </t>
<t tx="ekr.20050910194752.2">class rowGroupClass:
    
    @others</t>
<t tx="ekr.20050910194752.3">def __init__ (self,sudoku,i):
    
    # g.trace('row',i)
    self.i = i
    self.main = sudoku
    
    # Set later...
    self.cells = []
    self.row = None</t>
<t tx="ekr.20050910195107">def finishCreate(self):
    
    j = self.j ; main = self.main

    self.col = self.main.cols[j]
    
    self.cells = [cell for cell in main.cells if cell.j == j]

    for cell in self.cells:
        cell.colGroup = self</t>
<t tx="ekr.20050910195107.1">def finishCreate(self):

    i = self.i ; main = self.main

    self.row = self.main.rows[i]

    self.cells = [cell for cell in main.cells if cell.i == i]

    for cell in self.cells:
        cell.rowGroup = self</t>
<t tx="ekr.20050911085945">if self.level &lt; 2:
    # Save the previous data.
    save = [g.bunch(cell=cell,values=cell.values[:]) for cell in self.cells]
    guesses = self.findGuesses()
    if self.tracing:
        print '-'*20,'%d valid guesses' % len(guesses)
    if not guesses:
        return False
    n = 0
    for guess in guesses:
        # Restore the previous state.
        for b in save:
            b.cell.values = b.values[:]
        # Make the guess.
        self.level += 1 ; n += 1
        if self.tracing:
            print ; print '-'*40,'making guess %d at level %d' % (n,self.level)
        for b in guess:
            b.cell.values = str(b.val)
            if self.tracing: g.trace(b.cell,b.val)
        if self.tracing:
            self.printCells()
        # Call ourselves recursively.
        ok = self.solve()
        self.level -= 1
        if ok: return True
    if self.tracing or self.level == 0:
        print 'no solution is possible at level %d' % self.level
    # Restore the previous state.
    for b in save:
        b.cell.values = b.values[:]
    return False
else:
    if self.tracing:
        print 'maximum depth exceeded'
return False</t>
<t tx="ekr.20050911092707">def reduce (self):
    
    '''Reduce the possible values in self.values: remove an item from
    self.values if any cell in this cell's groups contains only that value.

    Increments self.main.progress or set self.main.valid = False to indicate status.
    '''
    
    if not self.main.valid: return
    n = len(self.values)
    if n == 0: self.main.valid = False
    if n &lt; 2:  return
        
    for group in (
        self.colGroup,
        self.rowGroup,
        self.squareGroup,
    ):
        for cell in group.cells:
            if (
                cell is not self and
                len(cell.values) == 1 and 
                cell.values[0] in self.values
            ):
                self.values.remove(cell.values[0])
                n -= 1 
                if n == 0:
                    self.main.valid = False
                    return
                if n == 1:
                    self.setValue(self.values[0])
                else:
                    self.main.progress += 1</t>
<t tx="ekr.20050911092707.1">def unique (self):
    
    '''Set self.values to [val] if val appears in only one place in any of this cells groups.
    
    Increments self.main.progress or set self.main.valid = False to indicate status.
    '''
    
    if not self.main.valid: return
    n = len(self.values)
    if n == 0: self.main.valid = False
    if n &lt; 2:  return
        
    for group in (
        self.colGroup,
        self.rowGroup,
        self.squareGroup,
    ):
        for val in self.values:
            spots = 0
            for cell in group.cells:
                if val in cell.values:
                    spots += 1
            # val is in self.values, and self is in each of its groups.
            assert(spots&gt;0)
            if spots == 1:
                # We have found the only possible place for this value.
                self.setValue(val) # Increments self.main.progress.
                return</t>
<t tx="ekr.20050911094544">def setValue (self,val):
    
    '''We have discovered the proper value for this cell.
    Set self.values=[val] and remove val from self.values from all *other* cells of this groups.'''
    
    values = self.values
    if self.main.tracing:
        g.trace(self,val,values)
    assert(val in values)
    values.remove(val)
    self.main.progress += 1
    self.values = [str(val)]
    
    for group in (
        self.colGroup,
        self.rowGroup,
        self.squareGroup,
    ):
        for cell in group.cells:
            if cell is not self:
                if val in cell.values:
                    cell.values.remove(str(val))
                    self.main.progress += 1
                    if len(cell.values) == 0:
                        self.main.valid = False</t>
<t tx="ekr.20050911094859"></t>
<t tx="ekr.20050911101819">class squareGroupClass:
    
    @others</t>
<t tx="ekr.20050911101819.1">def __repr__ (self):
    
    return '&lt;square group %d&gt;' % self.groupNumber
    
__str__ = __repr__</t>
<t tx="ekr.20050911102800">def __repr__ (self):
    
    return '&lt;col group %d&gt;' % self.j
    
__str__ = __repr__</t>
<t tx="ekr.20050911102800.1">def __repr__ (self):
    
    return '&lt;row group %d&gt;' % self.i
    
__str__ = __repr__</t>
<t tx="ekr.20050911111404"># This is about the most sophisticated deduction that a human could make.

def removeConflicts (self):
    
    '''Remove a possible value if assigning to this value would make it
    impossible to satisfy a related group.
    
    Increments self.main.progress or set self.main.valid = False to indicate status. '''
    
    if not self.main.valid: return
    n = len(self.values)
    if n == 0: self.main.valid = False
    if n &lt; 2:  return
    
    i,j = self.i,self.j
    
    colGroups = [group for group in self.colGroups if group != self.squareGroup]
    rowGroups = [group for group in self.rowGroups if group != self.squareGroup]
    
    # Check for row conflicts.
    for val in self.values:
        for group in rowGroups:
            spots = 0
            for cell in group.cells:
                if i != cell.i and val in cell.values:
                    spots += 1
            if spots == 0:
                self.trace('row conflict: cell: %s, val: %s, group %s' % (self,val,group))
                self.values.remove(val)
                n -= 1 ; self.main.progress += 1
                if n == 0:
                    self.main.valid = False
                return

    # Check for col conflicts.
    for val in self.values:
        for group in colGroups:
            spots = 0
            for cell in group.cells:
                if j != cell.j and val in cell.values:
                    spots += 1
            if spots == 0:
                self.trace('col conflict: cell: %s, val: %s, group %s' % (self,val,group))
                self.values.remove(val)
                n -= 1
                if n == 0:
                    self.main.valid = False
                if n == 1:
                    self.setValue(self.values[0])
                else:
                    self.main.progress += 1
                return</t>
<t tx="ekr.20050911112043.1"></t>
<t tx="ekr.20050911112043.2">def error (self,s):
    
    self.main.error(s)
    
def trace (self,s):
    
    self.main.trace(s)</t>
<t tx="ekr.20050911112310">c.save()</t>
<t tx="ekr.20050911113403">def finishCreate(self):
    
    # g.trace(self)
    assert(self.colGroup)
    assert(self.rowGroup)
    assert(self.squareGroup)

    self.colGroups = [group for group in self.main.squareGroups if self.j in group.colNumbers]
    self.rowGroups = [group for group in self.main.squareGroups if self.i in group.rowNumbers]</t>
<t tx="ekr.20050911123109"># Neither of these are solvable without guessing.

data = ( 
    '1x5xxx37x',
    'xxxxxx2xx',
    'x973xxx1x',
    'xxxx531x2',
    '3xx8x1xx4',
    '2x147xxxx',
    'x7xxx864x',
    'xx8xxxxxx',
    'x12xxx8x7') # 8/4 5 stars

data = ( 
    '2xxxx1834',
    'xxxx9xxxx',
    'x1x3xxx5x',
    'xx75xxxxx',
    '16xxxxx72',
    'xxxxx93xx',
    'x7xxx4x1x',
    'xxxx8xxxx',
    '8549xxxx3') # 8/9 5 stars (may be invalid)</t>
<t tx="ekr.20050911135016">@ A group is essentially just a collection of cells.</t>
<t tx="ekr.20050911144450"></t>
<t tx="ekr.20050911145104">data = (
    'x13xxxxx2',
    '6x2xx4xx8',
    '4xx3xxx6x',
    '2xx8xxxx7',
    'xxx715xxx',
    '9xxxx3xx4',
    'x2xxx1xx3',
    '1xx5xx4x9',
    '8xxxxx62x') # 9/10/05 4 stars</t>
<t tx="ekr.20050927122648">data = (
    'x4735xxx9',
    'x5x8x93xx',
    'xx84xx12x',
    '12x57xxx8',
    '7x5xxx2x6',
    '3xxx82x17',
    'x12xx59xx',
    'xx92x6x4x',
    '4xxx1875x',
)

data = (
    '19xxx84xx',
    '7xxx9xxxx',
    'x5xxxx986',
    'x19xxxx6x',
    '8xxxxxxx5',
    'x6xxxx72x',
    '684xxxx3x',
    'xxxx2xxx7',
    'xx26xxx14',
)

data = (
    'xx2xx7xx9',
    'x8x249x3x',
    'x31xx572x',
    'xx9xx8xx1',
    'x65xxx847',
    '4xx7xx2xx',
    'x931xx65x',
    'x5x862x73',
    '8xx5xx4xx') # 1 star
        
data = ( # 8/10 1 star
    'x6xxx5x19',
    'x9x34xxxx',
    'x8x96x5xx',
    'xxx8x93x1',
    '8x9xxx4x7',
    '2x17x4xxx',
    'xx3x86x4x',
    'xxxx27x6x',
    '47x5xxx8x')</t>
<t tx="ekr.20050929065040">data = (
    '4xxxxxxxx',
    '96xxx85xx',
    'x374x6xx1',
    '3x48xxx6x',
    'xxxx1xxxx',
    'x5xxx92x7',
    '5xx1x267x',
    'xx95xxx82',
    'xxxxxxxx9',
)

data = (
    'xxx395xxx',
    'xx5xx89x2',
    'xxxx2xxx5',
    '6x2xxxxx7',
    'x84xxx53x',
    '7xxxxx1x6',
    '3xxx6xxxx',
    '5x62xx7xx',
    'xxx831xxx',
)

data = ( # 8/6 2 stars
    '2x6xxxx49',
    'x37xx9xxx',
    '1xx7xxxx6',
    'xxx58x9xx',
    '7x5xxx8x4',
    'xx9x62xxx',
    '9xxxx4xx1',
    'xxx3xx49x',
    '41xxxx2x8')
        
data = (
    '9xx7x3xx6',
    'x87xx2xxx',
    '15xxxxx9x',
    'xxx6xx82x',
    'xx8xxx1xx',
    'x26xx8xxx',
    'x6xxxxx31',
    'xxx4xx97x',
    '4xx2x1xx8') # 8/30 2 stars
        
data = (
    '8xx3xxx7x',
    'xx57xxxxx',
    '9xx165x3x',
    '34xxxxxx9',
    'xxx5x4xxx',
    '7xxxxxx83',
    'x8x253xx4',
    'xxxxx65xx',
    'x2xxx1xx6',
) # 9/6/ 2 stars

data = ( 
    'x6x29xx8x',
    'xx8xxxx3x',
    'x1xx78xxx',
    'x217x9xx8',
    '6xxxxxxx3',
    '7xx6x492x',
    'xxx12xx4x',
    'x7xxxx3xx',
    'x5xx86x7x') # 2 stars</t>
<t tx="ekr.20050930124917">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20051011211253">import Tkinter as Tk
import tkFont

images = {}

@others

h = 500 ; w = 900

top = Tk.Toplevel(None) ; top.title("Debugger")

outer = Tk.Frame(top,height=h,width=w)
outer.pack(expand=1,fill='both')

canvas = Tk.Canvas(outer,background='LightSteelBlue1',width=14)
canvas.pack(side='left',fill='y',expand=0)

text = Tk.Text(outer)
text.pack(side='left',fill='both',expand=1,pady=0,padx=0)

line_h = getLineHeight(text)
# print line_h
image = getImage('minusnode.gif',canvas)

y = line_h / 2 - 2
while y &lt; h:
    id = canvas.create_image(4,y,image=image,anchor="nw")
    y += line_h
</t>
<t tx="ekr.20051011213138">def getImage(name,canvas):
    
    icon = images.get(name)
    if icon: return icon
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=canvas,file=fullname)
        images [name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20051011215038">def getLineHeight (text):

    try:
        fontName = text.cget('font')
        font = tkFont.Font(font=fontName)
        metrics = font.metrics()
        return metrics ["linespace"]
    except Exception:
        g.es("exception setting outline line height")
        g.es_exception()
        return 20 # default</t>
<t tx="ekr.20051020124457"></t>
<t tx="ekr.20051023104813"># This works, but is too slow to be really useful.

count = 0 ; tnodes = []
for p in c.all_positions_iter():
    if p.isDirty() and p.v.t not in tnodes:
        c.checkPythonNode (p,suppressErrors=False)
        tnodes.append(p.v.t)
        count += 1
        
g.es('%s nodes checked' % count)</t>
<t tx="ekr.20051024223801"># To use this script, you must make this a script button, either with the
# 'Script Button' button or by making this an @button node.

# Executes body text of selected node as a tcl script.
# For more information, see http://wiki.tcl.tk/6878

# This statement allows you to organize your scripts using noweb markup.
s = g.getScript(c,p,forcePythonSentinels=False)
g.es(g.app.root.tk.eval(s))</t>
<t tx="ekr.20051024223801.1"># This is a comment
set x 50
return [expr $x*10]</t>
<t tx="ekr.20051025070722">c.prettyPrintPythonNode()</t>
<t tx="ekr.20051025070722.1">@language tcltk</t>
<t tx="ekr.20051025091355">c.spellCommands.openSpellTab()
</t>
<t tx="ekr.20051025115413">@others</t>
<t tx="ekr.20051025115413.1"># This is a comment
set x 50 +
return [expr $x*10]</t>
<t tx="ekr.20051103072643"># simple script to export current node and children as a treepad document
# the file format for treepad 2.x is simple.
# See: "TreePad 2.x File format" at http://www.treepad.com/docs/

#need to start the levels at 0
topLevel = p.level()
fileName = "exported.hjt"
nl = "\n"
mode = g.choose(c.config.output_newline=="platform",'w','wb')
try:
    theFile = open(fileName,mode)
    theFile.write("&lt;hj-Treepad version 2.7&gt;" + nl)
    for p in p.copy().self_and_subtree_iter():
        theFile.write("dt=text" + nl)
        theFile.write("&lt;node&gt;" + nl)
        theFile.write(p.headString() + nl)
        theFile.write(repr(p.level() - topLevel) + nl)
        theFile.write(p.bodyString() + nl)
        theFile.write("&lt;end node&gt; 5P9i0s8y19Z" + nl)
    theFile.close()
    g.es("Wrote to file " + fileName,color="blue")
except IOError:
    g.es("Can not open " + fileName,color="blue")</t>
<t tx="ekr.20051103074730"></t>
<t tx="ekr.20051104082026"></t>
<t tx="ekr.20051104082103"></t>
<t tx="ekr.20051104082151"></t>
<t tx="ekr.20051104082605"></t>
</tnodes>
</leo_file>
