<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="7745" clone_windows="0"/>
<globals body_outline_ratio="0.637454981993">
	<global_window_position top="74" left="134" height="833" width="872"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20050415070840" annotate="7d71002e"
marks="ekr.20050415070840.12,"><vh>@thin ../src/leoTest.py</vh></v>
<v t="ekr.20040721153143" annotate="7d71002e"><vh>Gc/Profile/Timeit/Tracing scripts</vh>
<v t="ekr.20040721113934"><vh>runProfile</vh></v>
<v t="ekr.20040901065642.2"><vh>runTimeit</vh>
<v t="ekr.20040901072339"><vh>&lt;&lt; scan for #@count &gt;&gt;</vh></v>
<v t="ekr.20040901071028"><vh>&lt;&lt; put setup code in s1 and everything else in s2 &gt;&gt;</vh></v>
</v>
<v t="ekr.20040721145258.1"><vh>Run gc</vh></v>
<v t="ekr.20040804052804"><vh>Set tracing</vh></v>
<v t="ekr.20040901065642"><vh>test of new timit script</vh></v>
</v>
<v t="ekr.20040708205841" annotate="7d71002e"><vh>Other tests...</vh>
<v t="ekr.20051015100336"><vh>Older...</vh>
<v t="ekr.20040414082806"><vh>Clone test</vh>
<v t="ekr.20040409140301"><vh>clone test</vh>
<v t="ekr.20040409140301.1"><vh>b</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028"><vh>sibling</vh></v>
</v>
<v t="ekr.20040409140301.3"><vh>a</vh></v>
</v>
<v t="ekr.20040409140343"><vh>d</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028.1"><vh>sibling 2</vh></v>
</v>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409140343.1"><vh>last</vh></v>
</v>
<v t="EKR.20040523112430"><vh>Cloning headlines</vh>
<v t="EKR.20040523112430.1"><vh>read me</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.8"><vh>f</vh></v>
</v>
<v t="ekr.20040312101720"><vh>Experiments</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
<v t="ekr.20040323075614"><vh>Test of using an iterator inside a list comprehension</vh></v>
<v t="ekr.20040323080317"><vh>Test of using c.allNodes_iter to create a list of all positions</vh></v>
<v t="ekr.20040323082119"><vh>Creating a list of distinct vnodes</vh></v>
<v t="ekr.20040325082811"><vh>Test that back quotes are not needed in es</vh></v>
<v t="ekr.20040325130503"><vh>test of list comparisons</vh></v>
<v t="ekr.20040325140133"><vh>test that childIndex doesn't mess with p</vh></v>
<v t="ekr.20040325155043"><vh>Test of __cmp__ vrs equal</vh></v>
<v t="EKR.20040615070332"><vh>Test print</vh></v>
<v t="ekr.20040711140206"><vh>String-based imports...</vh>
<v t="ekr.20040710125250"><vh>import from string</vh>
<v t="ekr.20040710125250.2"><vh>@test import from string</vh></v>
</v>
<v t="ekr.20040711093916"><vh>Subclass the file type for use with imp module</vh></v>
<v t="ekr.20040711085843"><vh>Use parser module to simulate import from string</vh>
<v t="ekr.20040711092603"><vh>test1</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707110818"><vh>File Tests...</vh>
<v t="EKR.20040430162649.23"><vh>(double @root bug)</vh>
<v t="EKR.20040430162649.24"><vh>Assert fails</vh></v>
<v t="EKR.20040430162649.25"><vh>double at-root test (assert fails)</vh></v>
</v>
<v t="EKR.20040427092657"><vh>@ thin at-file-thin-test.txt</vh>
<v t="EKR.20040427092657.1"><vh>node 1</vh>
<v t="EKR.20040428145741"><vh>&lt;&lt; node 1 ref &gt;&gt;</vh>
<v t="EKR.20040428145741.1"><vh>child node 1</vh></v>
<v t="EKR.20040428145741.2"><vh>child node 2</vh></v>
</v>
</v>
<v t="EKR.20040427092657.2"><vh>&lt;&lt; ref &gt;&gt;</vh>
<v t="EKR.20040428150018"><vh>organizer node</vh>
<v t="EKR.20040428145826"><vh>ref child 1</vh></v>
<v t="EKR.20040428145826.1"><vh>ref child 2</vh></v>
</v>
</v>
</v>
<v t="EKR.20040625110032"><vh>@ thin mixedCommentDelims.txt</vh>
<v t="EKR.20040625110032.1"><vh>node 1</vh></v>
<v t="EKR.20040625110032.2"><vh>node 2</vh>
<v t="EKR.20040625110032.3"><vh>Node 3</vh></v>
</v>
</v>
<v t="ekr.20040419105536"><vh>@file perlLineNumbersTest.txt</vh>
<v t="ekr.20040419105536.1"><vh>one</vh></v>
<v t="ekr.20040419105536.2"><vh>two</vh></v>
</v>
<v t="ekr.20040330103006"><vh>@file testSectionDelims.txt</vh></v>
<v t="EKR.20040608095146.1"><vh>@file login_process.cfm</vh></v>
<v t="EKR.20040531110157"><vh>at-file thin tests</vh>
<v t="EKR.20040520104329"><vh>@thin thinCloneTest.txt</vh></v>
<v t="EKR.20040524050419"><vh>@file fatGrandChildTest.txt</vh>
<v t="EKR.20040524050419.1"><vh>Organizer node</vh>
<v t="EKR.20040524050419.2"><vh>&lt;&lt; defined in grandchild &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040524050438"><vh>@thin grandChildTest.txt</vh></v>
<v t="EKR.20040525083635"><vh>@file orphanMessageTest.txt</vh>
<v t="EKR.20040525083635.1"><vh>orphan</vh></v>
</v>
</v>
<v t="EKR.20040430162649.12"><vh>REM_ hack and perlpod hacks</vh>
<v t="EKR.20040430162649.13"><vh>perlpod test</vh>
<v t="EKR.20040430162649.14"><vh>perlpod test</vh>
<v t="EKR.20040430162649.15"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040430162649.16"><vh>REM test</vh>
<v t="EKR.20040430162649.17"><vh>@file remTest.txt</vh></v>
</v>
</v>
<v t="EKR.20040430162649.20"><vh>Suppress @@ sentinel unless leading @ starts a directive</vh>
<v t="EKR.20040430162649.21"><vh>@file perltest.txt</vh></v>
</v>
<v t="ekr.20040704104554"><vh>Test mixed @language directives in a single node</vh>
<v t="ekr.20040704104554.1"><vh>Mixed script</vh></v>
<v t="ekr.20040704104554.2"><vh>@thin mixedLanguages.txt</vh></v>
</v>
<v t="EKR.20040606204316"><vh>Test of @first</vh>
<v t="EKR.20040606204316.1"><vh>@thin atFirstTest.txt</vh></v>
</v>
<v t="EKR.20040622074004"><vh>Test of conflicting node defs</vh>
<v t="EKR.20040622074004.1"><vh>a</vh>
<v t="EKR.20040622074004.2"><vh>b</vh></v>
<v t="EKR.20040622074004.3"><vh>c</vh></v>
</v>
<v t="EKR.20040622102618"><vh>@thin cloneConflicts.txt</vh></v>
</v>
<v t="ekr.20040701081330"><vh>Test of decendent attributes</vh>
<v t="ekr.20040701065412"><vh>@ thin attribTest.txt</vh>
<v t="ekr.20040701065412.1"><vh>Marked</vh></v>
<v t="ekr.20040701065412.2"><vh>Expanded</vh>
<v t="ekr.20040701065412.3"><vh>child</vh></v>
</v>
<v t="ekr.20040701065412.4"><vh>Marked and expanded</vh>
<v t="ekr.20040701065412.5"><vh>child2</vh></v>
</v>
<v t="ekr.20040701065424"><vh>Neither Expanded or marked</vh>
<v t="ekr.20040701065424.1"><vh>child</vh></v>
</v>
</v>
</v>
<v t="EKR.20040627103732"><vh>Test of writing descendent uA's</vh>
<v t="EKR.20040627121836"><vh>print all tnode attributes</vh></v>
<v t="EKR.20040627103902"><vh>Test of user icons</vh></v>
<v t="EKR.20040627103801"><vh>@thin uaTest.txt</vh></v>
</v>
</v>
<v t="ekr.20040708210442"><vh>Manual tests...</vh>
<v t="EKR.20040605200750"><vh>autocompleter test</vh></v>
<v t="EKR.20040430162649.22"><vh>Other Reformat Paragraph tests</vh></v>
<v t="EKR.20040604082113"><vh>Test of @tabwidth</vh></v>
<v t="EKR.20040610092248"><vh>Test of pasting into big node</vh></v>
<v t="EKR.20040604170105"><vh>Test of Remove sentinels</vh></v>
<v t="ekr.20040711044029.1"><vh>Test new docutils stull</vh></v>
</v>
<v t="ekr.20040722051235"><vh>Mini tests of script buttons</vh>
<v t="ekr.20040712101754.273"><vh>Redundant: @suite run all doctests in @file nodes</vh></v>
<v t="ekr.20040721094335"><vh>runProfile button mini-test </vh></v>
<v t="ekr.20040721115141"><vh>runTimeit mini-test </vh></v>
<v t="ekr.20040721173532"><vh>profile redraws</vh></v>
</v>
<v t="EKR.20040608095146"><vh>Perfect import stuff...</vh>
<v t="EKR.20040504083716"><vh>Mulder Update script</vh>
<v t="EKR.20040504083716.39"><vh>sync</vh>
<v t="EKR.20040504153320"><vh>&lt;&lt; compute sourcetime and targettime &gt;&gt;</vh></v>
<v t="EKR.20040504153320.1"><vh>&lt;&lt; compute operation &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040716062608"><vh>Perfect Import Script</vh></v>
</v>
<v t="ekr.20040707104245"><vh>Printing tests...</vh>
<v t="ekr.20040323085933"><vh>Print findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040309111054"><vh>Print iterations: do not delete</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102"><vh>Clone test data</vh>
<v t="ekr.20040309111102.1"><vh>aa</vh></v>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.8"><vh>d</vh>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.9"><vh>e</vh></v>
<v t="ekr.20040309111102.10"><vh>z</vh></v>
</v>
<v t="ekr.20040309111232"><vh>last node</vh></v>
</v>
<v t="ekr.20040705191805"><vh>Print abbreviations</vh>
<v t="ekr.20040705212227"><vh>@file file</vh></v>
<v t="ekr.20040705192522"><vh>@silentfile silentfile</vh></v>
<v t="ekr.20040705192522.1"><vh>@file-asis file-asis</vh></v>
<v t="ekr.20040705192522.2"><vh>@asis asis</vh></v>
<v t="ekr.20040705192522.3"><vh>@nosentinelsfile nosentinelsfile</vh></v>
<v t="ekr.20040705191805.1"><vh>@file-nosent file-nosent</vh></v>
<v t="ekr.20040705191805.2"><vh>@nosent nosent</vh></v>
<v t="ekr.20040705192610"><vh>@rawfile rawfile</vh></v>
<v t="ekr.20040705192522.4"><vh>@file-noref file-noref</vh></v>
<v t="ekr.20040705192522.5"><vh>@noref noref</vh></v>
<v t="ekr.20040705192522.6"><vh>@file-thin file-thin</vh></v>
<v t="ekr.20040705192610.1"><vh>@thin thin</vh></v>
</v>
<v t="ekr.20040323085406"><vh>Print isAnyAtFileNode</vh></v>
<v t="ekr.20040708135624"><vh>Print fundChildrenOf and </vh></v>
<v t="EKR.20040526193608"><vh>Tests of pickle &amp; hexlify</vh></v>
<v t="EKR.20040526094831"><vh>Test of undo registration</vh></v>
<v t="EKR.20040526200017" myPlugin="7d710055016171014930310a732e"><vh>Test of unknownAttributes</vh></v>
<v t="EKR.20040602101648"><vh>Test of "end1" hook</vh></v>
<v t="EKR.20040603064545"><vh>Print timestamps of all nodes</vh></v>
<v t="EKR.20040603174633"><vh>test of focus</vh></v>
<v t="EKR.20040611083703"><vh>Using a generator instead of readLinesClass</vh></v>
<v t="EKR.20040612150543"><vh>Test of better error messages in Execute Script command</vh>
<v t="EKR.20040612215136"><vh>Contains error</vh></v>
</v>
<v t="EKR.20040627100615"><vh>Test of error messages when redirecting output</vh></v>
<v t="ekr.20040710141351"><vh>print all docstrings from a module</vh>
<v t="ekr.20040710145459"><vh>&lt;&lt; print names sorted by type &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040724171040"><vh>Tk bindtags test</vh></v>
<v t="ekr.20040708210636" a="M"><vh>User Icon tests</vh>
<v t="ekr.20040317173327"><vh>Delete user icons</vh></v>
<v t="ekr.20040317101155"><vh>Test of user icons</vh>
<v t="ekr.20040317185041"><vh>&lt;&lt; define event callbacks &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050419033955"><vh>test of 4.3 str_ attributes</vh>
<v t="ekr.20050419034527"><vh>set</vh></v>
<v t="ekr.20050419034527.1"><vh>get</vh></v>
</v>
<v t="ekr.20040909103024"><vh>Test of linenumbers plugin</vh>
<v t="ekr.20040909103024.1"><vh>@file perlLineNumbers.txt</vh>
<v t="ekr.20040909103024.2"><vh>TestNode</vh></v>
</v>
</v>
<v t="ekr.20040914072438"><vh>Tests of @root</vh>
<v t="ekr.20040914072438.1"><vh>atRootTest1.txt</vh></v>
<v t="ekr.20040914072438.2"><vh>atRootTest2.txt</vh></v>
</v>
<v t="ekr.20040910094343"><vh>Tests of @run</vh>
<v t="ekr.20040910094343.1"><vh>Note:  windows cd does not affect value of os.getcwd</vh></v>
<v t="ekr.20040910092950"><vh>@run # open leoDocs.leo</vh>
<v t="ekr.20040910092950.3"><vh>@run c:\python23\python c:\prog\leoCVS\leo\src\leo.py c:\prog\leoCVS\leo\doc\LeoDocs.leo</vh></v>
</v>
<v t="ekr.20040910094546"><vh>@run c:\python23\python #open leoDocs.leo using args</vh>
<v t="ekr.20040910094546.1"><vh>leo.py</vh></v>
<v t="ekr.20040910094546.2"><vh>@arg ..\doc\LeoDocs.leo</vh></v>
</v>
</v>
<v t="ekr.20040915045847"><vh>Test of spelling contraction</vh></v>
<v t="ekr.20040915111739"><vh>FileActions</vh>
<v t="ekr.20040915111853"><vh>leo*.py</vh></v>
</v>
<v t="ekr.20040922064156"><vh>Test of reportBadChars</vh></v>
<v t="ekr.20041011160953"><vh>Test of xsltWithNodes plugin</vh>
<v t="ekr.20041011160953.1"><vh>stylesheet</vh>
<v t="ekr.20041012123331"><vh>Joe Orr's stylesheet</vh></v>
<v t="ekr.20041011161235"><vh>The actual stylesheet</vh></v>
</v>
<v t="ekr.20041011160953.2"><vh>From xsltWithNodes.py</vh>
<v t="ekr.20041011160953.3"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20041011160953.4"><vh>&lt;&lt; version history &gt;&gt;</vh></v>
<v t="ekr.20041011160953.5"><vh>NewHeadline</vh></v>
<v t="ekr.20041011160953.6"><vh>setStyleNode</vh></v>
<v t="ekr.20041011160953.7"><vh>processDocumentNode</vh></v>
<v t="ekr.20041011160953.8"><vh>addXSLTNode</vh></v>
<v t="ekr.20041011160953.9"><vh>addXSLTemplate</vh></v>
<v t="ekr.20041011160953.10"><vh>getStream</vh></v>
<v t="ekr.20041011160953.11"><vh>jumpToStyleNode</vh></v>
<v t="ekr.20041011160953.12"><vh>styleNodeSelected</vh></v>
<v t="ekr.20041011160953.13"><vh>addMenu</vh></v>
<v t="ekr.20041011160953.14"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="ekr.20041013062906.1"><vh>Tests of error reporting in scripts</vh>
<v t="ekr.20041012101530"><vh>Test reporting of SyntaxError</vh>
<v t="ekr.20041012101634"><vh>syntax error</vh></v>
</v>
<v t="ekr.20041012101720"><vh>Test reporting of IndexError</vh>
<v t="ekr.20041012101720.1"><vh>index error</vh></v>
</v>
<v t="ekr.20041012101836"><vh>Test reporting of SyntaxError</vh>
<v t="ekr.20041012101836.1"><vh>syntax error</vh></v>
</v>
<v t="ekr.20041012102030"><vh>Test reporting of IndexError in another file</vh></v>
</v>
<v t="ekr.20041018193142"><vh>Make sure openWith changes are benign</vh></v>
<v t="ekr.20041017100700"><vh>Test of autocompleter</vh></v>
<v t="ekr.20041109164251"><vh>Test of template plugin</vh>
<v t="ekr.20041109174338"><vh>The template</vh></v>
<v t="ekr.20041109174338.1"><vh>A node that uses the template</vh></v>
</v>
<v t="ekr.20041111084431"><vh>test of using changes to Go To Line number to handle scripts</vh>
<v t="ekr.20041111084431.1"><vh>node that throws exception</vh></v>
</v>
<v t="ekr.20041111130231"><vh>Registering &amp; unregistering the "new" drawing hooks</vh>
<v t="ekr.20041111124032"><vh>Register all new hooks</vh></v>
<v t="ekr.20041111124353"><vh>Unregister all new hooks</vh></v>
<v t="ekr.20041111130231.1"><vh>Print all new hooks</vh></v>
</v>
<v t="ekr.20041112094406.2"><vh>Mini test arguments to hooks</vh>
<v t="ekr.20041112103504"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20041112094406.3"><vh>&lt;&lt; define hookData &gt;&gt;</vh></v>
<v t="ekr.20041112100255"><vh>&lt;&lt; define typeData &gt;&gt;</vh></v>
<v t="ekr.20041112102151"><vh>&lt;&lt; defineCheckHook &gt;&gt;</vh></v>
<v t="ekr.20041112155634"><vh>checkOneHook</vh></v>
</v>
<v t="ekr.20041220165048"><vh>Tests of leoGlobals</vh>
<v t="ekr.20041012091500"><vh>@test g.rawPrint</vh></v>
<v t="ekr.20041219074843"><vh>Tests of g.importExtension</vh>
<v t="ekr.20041219074843.1"><vh>@thin ../extensions/testExtension.py</vh></v>
<v t="ekr.20041219074454"><vh>test of using exec to do imports</vh></v>
<v t="ekr.20041219075144"><vh>test of g.importExtension</vh></v>
</v>
<v t="ekr.20041105091229"><vh>test of g.pdb</vh></v>
<v t="ekr.20041029111650"><vh>Test of g.app.debugSwitch</vh></v>
</v>
<v t="ekr.20041227081159"><vh>test of tab_width &amp; tab_width ivars</vh></v>
<v t="ekr.20041222060224"><vh>Tests of components</vh>
<v t="ekr.20041224104337"><vh>packing &amp; unpacking...</vh>
<v t="ekr.20041224082127"><vh>iconBar...</vh>
<v t="ekr.20041224082127.1"><vh>unpack iconBar</vh></v>
<v t="ekr.20041224082127.2"><vh>pack iconBar</vh></v>
</v>
<v t="ekr.20041224081744"><vh>statusLine...</vh>
<v t="ekr.20041224081744.1"><vh>unpack statusLine</vh></v>
<v t="ekr.20041224081744.2"><vh>pack statusLine</vh></v>
</v>
<v t="ekr.20041224081744.3"><vh>splitter1...</vh>
<v t="ekr.20041222060224.1"><vh>unpack splitter1</vh></v>
<v t="ekr.20041222060224.2"><vh>pack splitter1</vh></v>
</v>
<v t="ekr.20041224081744.4"><vh>body...</vh>
<v t="ekr.20041223154332"><vh>unpack body</vh></v>
<v t="ekr.20041223154332.1"><vh>pack body</vh></v>
</v>
<v t="ekr.20041224081829"><vh>log...</vh>
<v t="ekr.20041223162846"><vh>unpack log</vh></v>
<v t="ekr.20041223162754"><vh>pack log</vh></v>
</v>
<v t="ekr.20041224081829.1"><vh>tree...</vh>
<v t="ekr.20041223162846.1"><vh>unpack tree</vh></v>
<v t="ekr.20041223162754.1"><vh>pack tree</vh></v>
</v>
<v t="ekr.20041224081833"><vh>hull...</vh>
<v t="ekr.20041224081833.1"><vh>unpack hull (wipes out icon area!)</vh></v>
<v t="ekr.20041224081833.2"><vh>pack hull</vh></v>
</v>
</v>
<v t="ekr.20041224095444"><vh>Replacing &amp; restoring</vh>
<v t="ekr.20041224104031"><vh>Body...</vh>
<v t="ekr.20041224104031.1"><vh>Replace body</vh></v>
<v t="ekr.20041224104031.2"><vh>Restore body</vh></v>
</v>
<v t="ekr.20041225092227"><vh>Tree...</vh>
<v t="ekr.20041225092227.1"><vh>Replace tree</vh></v>
<v t="ekr.20041225092227.2"><vh>Restore  tree</vh></v>
</v>
<v t="ekr.20041225102217"><vh>Log...</vh>
<v t="ekr.20041225102217.1"><vh>Replace log</vh></v>
<v t="ekr.20041225102217.2"><vh>Restore log</vh></v>
</v>
<v t="ekr.20041224115905"><vh>Icon bar</vh>
<v t="ekr.20041224104416"><vh>Replace icon bar</vh></v>
<v t="ekr.20041224115905.1"><vh>Restore icon bar</vh></v>
</v>
</v>
<v t="ekr.20041223124541"><vh>Trace components</vh></v>
</v>
<v t="ekr.20041231092350"><vh>Standalone imports</vh>
<v t="ekr.20041230085841"><vh>test that of standalone imports of leo files</vh></v>
<v t="ekr.20041230090756"><vh>Script to run in Idle</vh></v>
</v>
<v t="ekr.20041231083027"><vh>Test of double @doc parts</vh>
<v t="ekr.20041231083651"><vh>@ file doubleAtDoc.py</vh>
<v t="ekr.20041231083651.1"><vh>foo</vh></v>
<v t="ekr.20041231083651.2"><vh>bar</vh></v>
<v t="ekr.20041231083651.3"><vh>spam</vh></v>
</v>
<v t="ekr.20041231083027.1"><vh>@ file doubleAtDoc.py</vh>
<v t="ekr.20041231083027.2"><vh>foo</vh></v>
<v t="ekr.20041231083027.3"><vh>bar (double doc parts)</vh></v>
<v t="ekr.20041231083027.4"><vh>spam</vh></v>
</v>
</v>
<v t="ekr.20041225051328"><vh>Tests of at_view plugin</vh>
<v t="ekr.20041225051328.1"><vh>@clip</vh></v>
<v t="ekr.20041231105348"><vh>Test of @strip</vh>
<v t="ekr.20041225051328.2"><vh>@file atStripTest.txt</vh>
<v t="ekr.20041231105200"><vh>Node 1</vh></v>
<v t="ekr.20041231105200.1"><vh>Node 2</vh></v>
<v t="ekr.20041231105200.2"><vh>@strip</vh></v>
</v>
</v>
<v t="ekr.20041225051445"><vh>@view ..\config\leoConfig.txt</vh></v>
</v>
<v t="ekr.20040909122141" tnodeList="ekr.20040909122141,ekr.20040909122141.1"><vh>@nosent niceNosentTest.txt</vh>
<v t="ekr.20040909122141.1"><vh>spam</vh></v>
</v>
<v t="ekr.20050114101014"><vh>Test of writing 'middle' sentinels</vh>
<v t="ekr.20050115103442"><vh>Copy of middleSentinelsTest.txt tree</vh>
<v t="ekr.20050115103442.1"><vh>&lt;&lt; level 1 &gt;&gt;</vh>
<v t="ekr.20050115103442.2"><vh>&lt;&lt; level 2&gt;&gt;</vh>
<v t="ekr.20050115103442.3"><vh>&lt;&lt; level 3 &gt;&gt;</vh>
<v t="ekr.20050115103442.4"><vh>&lt;&lt; level 4 &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050115100918"><vh>@ thin middleSentinelsTest.txt</vh>
<v t="ekr.20050115100918.1"><vh>&lt;&lt; level 1 &gt;&gt;</vh>
<v t="ekr.20050115100918.2"><vh>&lt;&lt; level 2&gt;&gt;</vh>
<v t="ekr.20050115100918.3"><vh>&lt;&lt; level 3 &gt;&gt;</vh>
<v t="ekr.20050115103123"><vh>&lt;&lt; level 4 &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20050113094943"><vh>Unicode stuff</vh></v>
<v t="ekr.20050119220832"><vh>@url '..\doc\LeoDocs.leo#Users Guide--&gt;Chapter 8: Customizing Leo'</vh></v>
<v t="ekr.20050203085849"><vh>test local settings (c.redirect_execute_script_output_to_log_pane)</vh></v>
<v t="ekr.20050211121701"><vh>Develop &amp; test g.removeExtraLws</vh>
<v t="ekr.20050211121701.1"><vh>g.removeExtraLws</vh></v>
<v t="ekr.20050211121701.2"><vh>test_g_removeExtraLws</vh></v>
</v>
<v t="ekr.20050220024614"><vh>Mini test of g.pdb</vh></v>
<v t="ekr.20050220034025"><vh>Mini test of g.es_exception</vh></v>
<v t="ekr.20050406082407"><vh>xml test</vh>
<v t="ekr.20050406082407.1"><vh>@thin xmltest.xml</vh></v>
</v>
<v t="ekr.20050316063336"><vh>test of NameError traceback</vh></v>
<v t="ekr.20050316074630.1"><vh>test of an exception in another module</vh></v>
<v t="ekr.20050428085106"><vh>linda's node</vh></v>
<v t="ekr.20050503095605"><vh>Test of os.spawnv calls to c.openWith</vh></v>
<v t="ekr.20050505053411"><vh>@url 'c:\Program Files\jEdit\doc\README.txt'</vh></v>
<v t="ekr.20050508195711"><vh>@nowrap tests</vh></v>
<v t="ekr.20050505104328"><vh>Test of redirected scipt with error</vh></v>
<v t="ekr.20050509072745"><vh>Test of g.getScript with forcePythonSentinels = False</vh>
<v t="ekr.20050509072745.1"><vh>g.getScript</vh></v>
<v t="ekr.20050509072745.2"><vh>html stuff</vh>
<v t="ekr.20050509072745.3"><vh>body</vh></v>
</v>
</v>
<v t="ekr.20050805165407"><vh>Tests of rst3 plugin</vh>
<v t="ekr.20050811141217"><vh>@rst ../doc/ListManagerDocs.html</vh>
<v t="ekr.20050811141217.1"><vh>wxListManager.py</vh>
<v t="ekr.20050811141217.2"><vh>Initial stuff</vh>
<v t="ekr.20050811141217.4"><vh>Module Imports</vh>
<v t="ekr.20050811141217.5"><vh>@rst-no-head About imports</vh></v>
</v>
<v t="ekr.20050811141217.6"><vh>Constants</vh></v>
<v t="ekr.20050811141217.8"><vh>Menu IDs</vh></v>
<v t="ekr.20050811141217.10"><vh>Read Config File</vh>
<v t="ekr.20050811141217.11"><vh>@rst-no-head About configuration files</vh></v>
</v>
</v>
<v t="ekr.20050811141217.12"><vh>class ListManager</vh>
<v t="ekr.20050811141217.14"><vh>Instantiation</vh>
<v t="ekr.20050811141217.16"><vh>def __init__</vh>
<v t="ekr.20050811141217.17"><vh>@rst-no-head About the ctor</vh></v>
<v t="ekr.20050811141217.18"><vh>&lt;&lt; List Manager Attributes &gt;&gt;</vh>
<v t="ekr.20050811141217.19"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.20"><vh>&lt;&lt; Menu Setup &gt;&gt;</vh>
<v t="ekr.20050811141217.21"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.22"><vh>&lt;&lt; Toolbar Setup &gt;&gt;</vh>
<v t="ekr.20050811141217.23"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.24"><vh>&lt;&lt; Menu/Toolbar Events &gt;&gt;</vh>
<v t="ekr.20050811141217.25"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.26"><vh>&lt;&lt; Create Controls&gt;&gt;</vh>
<v t="ekr.20050811141217.27"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.28"><vh>&lt;&lt; Other Events &gt;&gt;</vh>
<v t="ekr.20050811141217.29"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.30"><vh>&lt;&lt; Layout Stuff &gt;&gt;</vh>
<v t="ekr.20050811141217.31"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.32"><vh>&lt;&lt; GUI Instance Objects &gt;&gt;</vh>
<v t="ekr.20050811141217.33"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.34"><vh>&lt;&lt; Create Socket &gt;&gt;</vh>
<v t="ekr.20050811141217.35"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.36"><vh>&lt;&lt; Load Recent Files &gt;&gt;</vh>
<v t="ekr.20050811141217.37"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.38"><vh>&lt;&lt; Idle Timer &gt;&gt;</vh>
<v t="ekr.20050811141217.39"><vh>@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20050811141217.40"><vh>Ownerlist creation methods (used by thread)</vh>
<v t="ekr.20050811141217.41"><vh>@rst</vh></v>
<v t="ekr.20050811141217.42"><vh>def createownerlist</vh>
<v t="ekr.20050811141217.43"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.44"><vh>def createownerdialog</vh>
<v t="ekr.20050811141217.45"><vh>@rst</vh></v>
</v>
</v>
<v t="ekr.20050811141217.46"><vh>Notebook methods</vh>
<v t="ekr.20050811141217.47"><vh>@rst</vh></v>
<v t="ekr.20050811141217.48"><vh>def CreateNewNotebookPage</vh>
<v t="ekr.20050811141217.49"><vh>@rst</vh></v>
<v t="ekr.20050811141217.50"><vh>&lt;&lt; Fill OwnerListBox &gt;&gt;</vh>
<v t="ekr.20050811141217.51"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.52"><vh>&lt;&lt; ListControl Events &gt;&gt;</vh>
<v t="ekr.20050811141217.53"><vh>@rst</vh></v>
</v>
</v>
<v t="ekr.20050811141217.54"><vh>def OnPageChange</vh>
<v t="ekr.20050811141217.55"><vh>@rst</vh></v>
<v t="ekr.20050811141217.56"><vh>&lt;&lt; Find Highlighted Row &gt;&gt;</vh>
<v t="ekr.20050811141217.57"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.58"><vh>&lt;&lt; Update Title &gt;&gt;</vh>
<v t="ekr.20050811141217.59"><vh>@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20050811141217.60"><vh>Tickler methods</vh>
<v t="ekr.20050811141217.61"><vh>def OnShowTickler</vh></v>
<v t="ekr.20050811141217.62"><vh>def OnActivateTickler</vh></v>
</v>
<v t="ekr.20050811141217.63"><vh>Email methods</vh>
<v t="ekr.20050811141217.64"><vh>OnMailItem</vh></v>
<v t="ekr.20050811141217.65"><vh>OnMailView</vh></v>
</v>
<v t="ekr.20050811141217.66"><vh>Cut/Copy/Paste methods</vh>
<v t="ekr.20050811141217.67"><vh>OnCopyItems</vh>
<v t="ekr.20050811141217.68"><vh>&lt;&lt; Find Highlighted Items &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811141217.69"><vh>OnPasteItems</vh></v>
<v t="ekr.20050811141217.70"><vh>OnDeleteItems</vh></v>
</v>
<v t="ekr.20050811141217.71"><vh>MouseDown methods</vh>
<v t="ekr.20050811141217.72"><vh>OnLeftDown (Action depends on x coordinate)</vh></v>
<v t="ekr.20050811141217.73"><vh>OnRightDown (Display popup sendto menu)</vh></v>
</v>
<v t="ekr.20050811141217.74"><vh>Move/Combine items methods</vh>
<v t="ekr.20050811141217.75"><vh>OnCombineItems</vh></v>
<v t="ekr.20050811141217.76"><vh>OnMoveToList</vh></v>
<v t="ekr.20050811141217.77"><vh>OnMoveToSpecificList</vh></v>
</v>
<v t="ekr.20050811141217.78"><vh>Change/update items methods</vh>
<v t="ekr.20050811141217.79"><vh>OnToggleFinished</vh>
<v t="ekr.20050811141217.80"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811141217.81"><vh>OnPriority</vh>
<v t="ekr.20050811141217.82"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811141217.83"><vh>Inplace Edit Methods</vh>
<v t="ekr.20050811141217.84"><vh>OnDisplayInPlaceEditor</vh></v>
<v t="ekr.20050811141217.85"><vh>OnCloseInPlaceEditor</vh></v>
</v>
<v t="ekr.20050811141217.86"><vh>OnDueDate</vh></v>
<v t="ekr.20050811141217.87"><vh>OnEditOwner</vh>
<v t="ekr.20050811141217.88"><vh>&lt;&lt; Common Owner Code &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811141217.89"><vh>OnUpdate</vh>
<v t="ekr.20050811141217.90"><vh>&lt;&lt; Common Owner Code &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811141217.91"><vh>OnNewItem</vh>
<v t="ekr.20050811141217.92"><vh>&lt;&lt; Clear data fields &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811141217.93"><vh>Conflict (not in use)</vh></v>
<v t="ekr.20050811141217.94"><vh>OnEditNote</vh></v>
</v>
<v t="ekr.20050811141217.95"><vh>File menu methods</vh>
<v t="ekr.20050811141217.96"><vh>OnNewList</vh></v>
<v t="ekr.20050811141217.97"><vh>OnFileList</vh></v>
<v t="ekr.20050811141217.98"><vh>OnOpenList</vh></v>
<v t="ekr.20050811141217.99"><vh>OnDeleteList</vh></v>
<v t="ekr.20050811141217.100"><vh>OnCloseList</vh></v>
<v t="ekr.20050811141217.101"><vh>OnCloseAll</vh></v>
<v t="ekr.20050811141217.102"><vh>OnSaveAsText</vh></v>
<v t="ekr.20050811141217.103"><vh>OnArchive</vh></v>
<v t="ekr.20050811141217.104"><vh>OnWorkOffline</vh>
<v t="ekr.20050811141217.105"><vh>@rst</vh></v>
</v>
</v>
<v t="ekr.20050811141217.106"><vh>Display methods</vh>
<v t="ekr.20050811141217.107"><vh>OnItemSelected</vh></v>
<v t="ekr.20050811141217.108"><vh>OnItemActivated</vh></v>
<v t="ekr.20050811141217.109"><vh>OnShowAll</vh></v>
<v t="ekr.20050811141217.110"><vh>OnRefresh</vh></v>
<v t="ekr.20050811141217.111"><vh>OnFilterOwners</vh></v>
<v t="ekr.20050811141217.112"><vh>OnColumnClick (to sort columns)</vh></v>
<v t="ekr.20050811141217.113"><vh>OnShowFinished</vh></v>
<v t="ekr.20050811141217.114"><vh>OnColumnRightClick (popup to change date displayed)</vh></v>
<v t="ekr.20050811141217.115"><vh>OnDisplayDateCategory</vh></v>
<v t="ekr.20050811141217.116"><vh>ChangeDateDisplayed</vh></v>
<v t="ekr.20050811141217.117"><vh>DisplayList</vh>
<v t="ekr.20050811141217.118"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050811141217.119"><vh>Printing methods</vh>
<v t="ekr.20050811141217.120"><vh>OnPageSetup</vh></v>
<v t="ekr.20050811141217.121"><vh>OnPrint</vh></v>
</v>
<v t="ekr.20050811141217.122"><vh>Exiting methods</vh>
<v t="ekr.20050811141217.123"><vh>OnWindowExit</vh></v>
<v t="ekr.20050811141217.124"><vh>OnExit</vh>
<v t="ekr.20050811141217.125"><vh>&lt;&lt;save configuration file&gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050811141217.126"><vh>Find methods</vh>
<v t="ekr.20050811141217.127"><vh>OnFind</vh></v>
<v t="ekr.20050811141217.128"><vh>FindString</vh></v>
<v t="ekr.20050811141217.129"><vh>FindNode</vh></v>
</v>
<v t="ekr.20050811141217.130"><vh>Database-related methods</vh>
<v t="ekr.20050811141217.131"><vh>GetCursor</vh></v>
<v t="ekr.20050811141217.132"><vh>GetNote</vh></v>
<v t="ekr.20050811141217.133"><vh>CreateTable</vh></v>
<v t="ekr.20050811141217.134"><vh>ReadFromDB (returns db results)</vh></v>
<v t="ekr.20050811141217.135"><vh>CreateAndDisplayList (returns Item List)</vh>
<v t="ekr.20050811141217.136"><vh>&lt;&lt; assign item attributes &gt;&gt;</vh></v>
<v t="ekr.20050811141217.137"><vh>&lt;&lt; draw item &gt;&gt;</vh></v>
</v>
<v t="ekr.20050811141217.138"><vh>OnSync</vh></v>
<v t="ekr.20050811141217.139"><vh>TimeStamper</vh></v>
</v>
<v t="ekr.20050811141217.140"><vh>Evaluate methods</vh>
<v t="ekr.20050811141217.141"><vh>OnShowEvaluate</vh></v>
<v t="ekr.20050811141217.142"><vh>OnEvaluate</vh></v>
</v>
<v t="ekr.20050811141217.143"><vh>Help menu methods</vh>
<v t="ekr.20050811141217.144"><vh>OnShowAbout</vh></v>
<v t="ekr.20050811141217.145"><vh>OnShowHelp</vh></v>
</v>
<v t="ekr.20050811141217.146"><vh>GetUID</vh></v>
<v t="ekr.20050811141217.147"><vh>OnIdle</vh>
<v t="ekr.20050811141217.148"><vh>@rst</vh></v>
<v t="ekr.20050811141217.149"><vh>&lt;&lt; Check for Transfers From Outlook &gt;&gt;</vh>
<v t="ekr.20050811141217.150"><vh>@rst</vh></v>
</v>
<v t="ekr.20050811141217.151"><vh>&lt;&lt; Check if Edited File has Changed &gt;&gt;</vh>
<v t="ekr.20050811141217.152"><vh>@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20050811141217.153"><vh>class ListCtrl</vh>
<v t="ekr.20050811141217.154"><vh>__init__</vh></v>
<v t="ekr.20050811141217.155"><vh>SetUpColumns</vh></v>
<v t="ekr.20050811141217.156"><vh>OnColBeginDrag</vh></v>
</v>
<v t="ekr.20050811141217.157"><vh>class MyApp</vh>
<v t="ekr.20050811141217.158"><vh>OnInit</vh></v>
</v>
<v t="ekr.20050811141217.159"><vh>class Logger</vh></v>
<v t="ekr.20050811141217.160"><vh>run</vh></v>
</v>
<v t="ekr.20050811141217.161"><vh>LMDialogs.py</vh>
<v t="ekr.20050811141217.162"><vh>class PopDialog</vh>
<v t="ekr.20050811141217.163"><vh>__init__</vh></v>
<v t="ekr.20050811141217.164"><vh>OnLeftDown</vh></v>
<v t="ekr.20050811141217.165"><vh>OnForward</vh></v>
<v t="ekr.20050811141217.166"><vh>OnMail</vh></v>
</v>
<v t="ekr.20050811141217.167"><vh>class StartupDialog</vh>
<v t="ekr.20050811141217.168"><vh>__init__</vh></v>
<v t="ekr.20050811141217.169"><vh>OnSelection</vh></v>
</v>
<v t="ekr.20050811141217.170"><vh>class ModifierDialog</vh>
<v t="ekr.20050811141217.171"><vh>__init__</vh></v>
<v t="ekr.20050811141217.172"><vh>GetUserInput</vh></v>
<v t="ekr.20050811141217.173"><vh>SelectCurrent</vh></v>
<v t="ekr.20050811141217.174"><vh>ClearSelections</vh></v>
</v>
<v t="ekr.20050811141217.175"><vh>class MailDialog</vh>
<v t="ekr.20050811141217.176"><vh>__init__</vh></v>
</v>
<v t="ekr.20050811141217.177"><vh>class CalendarDialog</vh>
<v t="ekr.20050811141217.178"><vh>__init__</vh></v>
<v t="ekr.20050811141217.179"><vh>OnCalSelected</vh></v>
<v t="ekr.20050811141217.180"><vh>OnChangeMonth</vh></v>
<v t="ekr.20050811141217.181"><vh>OnCloseWindow</vh></v>
<v t="ekr.20050811141217.182"><vh>GetDate</vh></v>
</v>
<v t="ekr.20050811141217.183"><vh>class FindDialog</vh>
<v t="ekr.20050811141217.184"><vh>__init__</vh></v>
</v>
<v t="ekr.20050811141217.185"><vh>class EvalDialog</vh>
<v t="ekr.20050811141217.186"><vh>__init__</vh></v>
<v t="ekr.20050811141217.187"><vh>PostOKEvent</vh></v>
</v>
<v t="ekr.20050811141217.188"><vh>class LoggerDialog</vh>
<v t="ekr.20050811141217.189"><vh>__init__</vh></v>
<v t="ekr.20050811141217.190"><vh>OnSave</vh></v>
</v>
<v t="ekr.20050811141217.191"><vh>class FinishedDialog</vh>
<v t="ekr.20050811141217.192"><vh>__init__</vh></v>
<v t="ekr.20050811141217.193"><vh>OnSpin</vh></v>
<v t="ekr.20050811141217.194"><vh>OnCheck</vh></v>
</v>
<v t="ekr.20050811141217.195"><vh>class TreeDialog</vh>
<v t="ekr.20050811141217.196"><vh>__init__</vh></v>
<v t="ekr.20050811141217.197"><vh>OnLeftDClick:</vh></v>
</v>
</v>
<v t="ekr.20050811141217.198"><vh>outlookAddin.py</vh>
<v t="ekr.20050811141217.199"><vh>&lt;&lt; outlookAddin declarations &gt;&gt;</vh></v>
<v t="ekr.20050811141217.200"><vh>class ButtonEvent</vh>
<v t="ekr.20050811141217.201"><vh>OnClick</vh></v>
</v>
<v t="ekr.20050811141217.202"><vh>class FolderEvent</vh>
<v t="ekr.20050811141217.203"><vh>OnItemAdd</vh></v>
</v>
<v t="ekr.20050811141217.204"><vh>class OutlookAddin</vh>
<v t="ekr.20050811141217.205"><vh>&lt;&lt; class OutlookAddin declarations &gt;&gt;</vh></v>
<v t="ekr.20050811141217.206"><vh>OnConnection</vh></v>
<v t="ekr.20050811141217.207"><vh>OnDisconnection</vh></v>
<v t="ekr.20050811141217.208"><vh>OnAddInsUpdate</vh></v>
<v t="ekr.20050811141217.209"><vh>OnStartupComplete</vh></v>
<v t="ekr.20050811141217.210"><vh>OnBeginShutdown</vh></v>
</v>
<v t="ekr.20050811141217.211"><vh>RegisterAddin</vh></v>
<v t="ekr.20050811141217.212"><vh>UnregisterAddin</vh></v>
</v>
</v>
<v t="ekr.20050817110133"><vh>@rst ../doc/pdfTest.pdf</vh>
<v t="ekr.20050817110133.1"><vh>child node</vh>
<v t="ekr.20050817110133.2"><vh>@rst</vh></v>
</v>
</v>
</v>
<v t="ekr.20050816172657"><vh>ReportLab sample scripts</vh>
<v t="ekr.20050816181619"><vh>text</vh></v>
<v t="ekr.20050816181619.1"><vh>pencil</vh></v>
<v t="ekr.20050816181813"><vh>penciltip</vh></v>
</v>
<v t="ekr.20050917082428"><vh>@@nosent test-niceNosent</vh>
<v t="ekr.20050917082428.1"><vh>part 1</vh></v>
<v t="ekr.20050917082428.2"><vh>part 2</vh></v>
<v t="ekr.20050917082428.3"><vh>part 3</vh></v>
</v>
</v>
<v t="ekr.20051013160521"><vh>Tests of settings when opened from another .leo file</vh></v>
<v t="ekr.20051015065018"><vh>Test of warnings of conflicting shortcuts</vh></v>
<v t="ekr.20051016110449"><vh>Write to test tab</vh></v>
<v t="ekr.20051016113248"><vh>Write to log tab</vh></v>
<v t="ekr.20051017104401"><vh>Tests of @command and @button/@key</vh>
<v t="ekr.20051015103450"><vh>test k.registerCommand</vh></v>
<v t="ekr.20051016174943"><vh>@@command my-command @key = alt-shift-ctrl-z</vh></v>
<v t="ekr.20051016174943.1"><vh>@@command my-command2</vh></v>
<v t="ekr.20051016205407"><vh>@@button test @key=alt-shift-ctrl-y</vh></v>
</v>
</v>
<v t="ekr.20041126132604" annotate="7d71002e"><vh>Prototypes...</vh>
<v t="ekr.20041220080654"><vh>Setting Tk config values safely</vh>
<v t="ekr.20041220091350"><vh>&lt;&lt; documentation about how to set general options &gt;&gt;</vh></v>
</v>
<v t="ekr.20041220172118"><vh>Resolve CVS Conflicts command</vh>
<v t="ekr.20041220172118.1"><vh>Cvs markers &amp; file names</vh></v>
<v t="ekr.20041220172118.2"><vh>Conflicts not involving sentinels</vh></v>
<v t="ekr.20041220173231"><vh>Conflicts involving sentinels</vh></v>
<v t="ekr.20041220173748"><vh>Design notes</vh></v>
</v>
<v t="ekr.20050103092214"><vh>Python parser (abandoned)</vh>
<v t="ekr.20050103092214.5"><vh>class pythonParser</vh>
<v t="ekr.20050103092214.6"><vh>To be deleted</vh>
<v t="ekr.20050103092214.7"><vh>clear</vh></v>
<v t="ekr.20050103092214.8"><vh>endUndo</vh></v>
<v t="ekr.20050103092214.9"><vh>get</vh></v>
<v t="ekr.20050103092214.10"><vh>put</vh></v>
<v t="ekr.20050103092214.11"><vh>putArray</vh></v>
<v t="ekr.20050103092214.12"><vh>replaceBody</vh></v>
<v t="ekr.20050103092214.13"><vh>prettyPrintNode</vh></v>
<v t="ekr.20050103092214.14"><vh>putToken</vh></v>
<v t="ekr.20050103092214.18"><vh>dumpLines (not used)</vh></v>
</v>
<v t="ekr.20050103092214.15"><vh>__init__</vh>
<v t="ekr.20050103092214.16"><vh>&lt;&lt; define dispatch dict &gt;&gt;</vh></v>
</v>
<v t="ekr.20050103092214.17"><vh>parseNode(top level)</vh></v>
<v t="ekr.20050103092214.19"><vh>dumpToken</vh></v>
<v t="ekr.20050103092214.21"><vh>oops</vh></v>
<v t="ekr.20050103092214.22"><vh>trace</vh></v>
<v t="ekr.20050103092214.23"><vh>doToken &amp; allies</vh>
<v t="ekr.20050103095602"><vh>handleAtPart</vh></v>
<v t="ekr.20050103092214.24"><vh>doEndMarker</vh></v>
<v t="ekr.20050103092214.25"><vh>doErrorToken</vh></v>
<v t="ekr.20050103092214.26"><vh>doIndent &amp; doDedent</vh></v>
<v t="ekr.20050103092214.27"><vh>doMultiLine</vh></v>
<v t="ekr.20050103092214.28"><vh>doName</vh></v>
<v t="ekr.20050103092214.29"><vh>doNewline</vh></v>
<v t="ekr.20050103092214.30"><vh>doNumber</vh></v>
<v t="ekr.20050103092214.31"><vh>doOp</vh></v>
<v t="ekr.20050103092214.32"><vh>doStartLine</vh></v>
</v>
</v>
<v t="ekr.20050103092214.3"><vh>class dumper (pythonParser)</vh>
<v t="ekr.20050103092214.4"><vh>__init__</vh></v>
</v>
</v>
<v t="ekr.20041126055818.2"><vh>pyclbr module (parses python)</vh></v>
<v t="ekr.20040918093738"><vh>Prototypes for Python-to-Tk indices</vh>
<v t="ekr.20040918093738.1"><vh>py2tkIndex</vh>
<v t="ekr.20040918093738.2"><vh>test</vh></v>
</v>
<v t="ekr.20040918093738.3"><vh>pyRowColToTkIndex</vh>
<v t="ekr.20040918093738.4"><vh>test</vh></v>
</v>
<v t="ekr.20050314104217"><vh>Develop g.convertPythonIndexToRowCol</vh>
<v t="ekr.20050314103747"><vh>g.convertPythonIndexToRowCol  &amp; tests</vh>
<v t="ekr.20050314103747.1"><vh>bruteForceConvertPythonIndexToRowCol</vh></v>
<v t="ekr.20050314103747.2"><vh>test_g_convertPythonIndexToRowCol</vh></v>
</v>
</v>
<v t="ekr.20050315072359"><vh>Develop g.convertRowColToPythonIndex</vh>
<v t="ekr.20050315072359.1"><vh>g.convertRowColToPythonIndex &amp; test</vh>
<v t="ekr.20050315072359.2"><vh>test_g_convertRowColToPythonIndex</vh></v>
</v>
</v>
</v>
<v t="ekr.20050427101736"><vh>Zip files experiments</vh>
<v t="ekr.20050427102426"><vh>@url http://docs.python.org/lib/module-zipfile.html</vh></v>
<v t="ekr.20050427101736.1"><vh>write zip</vh></v>
<v t="ekr.20050427101736.2"><vh>read zip</vh></v>
</v>
<v t="ekr.20050618061950"><vh>Tests for new colorizer</vh>
<v t="ekr.20050601072505"><vh>Large coloring test</vh></v>
<v t="ekr.20050602213517"><vh>Doc part test</vh></v>
<v t="ekr.20050603134109"><vh>C language test</vh></v>
<v t="ekr.20050607084934"><vh>Plain test</vh></v>
<v t="ekr.20050608082208"><vh>Leading @sign tests</vh>
<v t="ekr.20050608081744" tnodeList="ekr.20050608081744"><vh>@file leadingAtTest.py</vh></v>
<v t="ekr.20050608081942"><vh>@thin leadingAtTest2.py</vh></v>
<v t="ekr.20050608082702" tnodeList="ekr.20050608082702"><vh>@file leadingAtTest3.py</vh></v>
<v t="ekr.20050608082702.1"><vh>@thin leadingAtTest4.py</vh></v>
</v>
</v>
<v t="ekr.20050715132524"><vh>Pymacs (hangs)</vh></v>
<v t="ekr.20050726101926"><vh>keyPressed</vh>
<v t="ekr.20050726101926.1"><vh>&lt;&lt; create the command &gt;&gt;</vh></v>
<v t="ekr.20050726101926.2"><vh>&lt;&lt; handle auto completion &gt;&gt;</vh></v>
<v t="ekr.20050726101926.3"><vh>&lt;&lt; handle auto-tabbing &gt;&gt;</vh></v>
</v>
<v t="ekr.20050824190822"><vh> Zope test</vh></v>
<v t="ekr.20051011211253"><vh>Debugger canvas</vh>
<v t="ekr.20051011213138"><vh>getImage</vh></v>
<v t="ekr.20051011215038"><vh>getLineHeight</vh></v>
</v>
<v t="ekr.20050707183613"><vh>Ipython Shell</vh>
<v t="ekr.20050708110336"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050708091220.78"><vh>&lt;&lt; use IPShellEmbed &gt;&gt;</vh></v>
<v t="ekr.20050708095104"><vh>class dummyCache</vh>
<v t="ekr.20050708142137"><vh>ctor</vh></v>
<v t="ekr.20050708142137.2"><vh>All others</vh></v>
</v>
<v t="ekr.20050708143008"><vh>class dummyPrompt</vh>
<v t="ekr.20050708143008.2"><vh>__init__</vh></v>
<v t="ekr.20050708143008.3"><vh>set_p_str</vh></v>
<v t="ekr.20050708143008.4"><vh>write</vh></v>
<v t="ekr.20050708143008.5"><vh>__str__</vh></v>
<v t="ekr.20050708144144.1"><vh>Unchanged</vh>
<v t="ekr.20050708143008.6"><vh>cwd_filt</vh></v>
<v t="ekr.20050708143008.7"><vh>cwd_filt2</vh></v>
</v>
<v t="ekr.20050708144144.2"><vh>auto_rewrite</vh></v>
</v>
<v t="ekr.20050708091220.76"><vh>class LeoShell</vh>
<v t="ekr.20050708091220.77"><vh>ctor</vh>
<v t="ekr.20050708110239"><vh>&lt;&lt; directory stuff &gt;&gt;</vh></v>
<v t="ekr.20050708105742"><vh>&lt;&lt; set sensible command line defaults for self.rc &gt;&gt;</vh></v>
<v t="ekr.20050708093114"><vh>&lt;&lt; define regexp's &gt;&gt;</vh></v>
<v t="ekr.20050708093224"><vh>&lt;&lt; define escape stuff &gt;&gt;</vh></v>
<v t="ekr.20050708093433"><vh>&lt;&lt; define namespaces &gt;&gt;</vh></v>
<v t="ekr.20050708094606.1"><vh>&lt;&lt; create alias table &gt;&gt;</vh></v>
<v t="ekr.20050708150223"><vh>&lt;&lt; define inpsector &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708105323.2"><vh>usage</vh></v>
<v t="ekr.20050708095104.1"><vh>log</vh></v>
<v t="ekr.20050708113006.2"><vh>system</vh></v>
<v t="ekr.20050708152111" a="M"><vh>_prefilter</vh>
<v t="ekr.20050708152111.1"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708152111.2"><vh>&lt;&lt; handle empty line &gt;&gt;</vh></v>
<v t="ekr.20050708152111.3"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708152111.4"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708152111.5"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708152111.6"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708152111.7"><vh>prefilter &amp; helpers</vh>
<v t="ekr.20050708152111.9" a="M"><vh>_prefilter</vh>
<v t="ekr.20050708152111.10"><vh>&lt;&lt; about this function &gt;&gt;</vh></v>
<v t="ekr.20050708152111.12"><vh>&lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;</vh></v>
<v t="ekr.20050708152111.13"><vh>&lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;</vh></v>
<v t="ekr.20050708152111.14"><vh>&lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;</vh></v>
<v t="ekr.20050708152111.15"><vh>&lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;</vh></v>
</v>
<v t="ekr.20050708165401.1"><vh>handle_normal ( no longer used)</vh></v>
<v t="ekr.20050708152111.17"><vh>handle_alias (done)</vh></v>
<v t="ekr.20050708152111.18"><vh>handle_shell_escape (needs work)</vh></v>
<v t="ekr.20050708152111.19"><vh>handle_magic (done)</vh></v>
<v t="ekr.20050708152111.20"><vh>handle_auto (may need work)</vh></v>
<v t="ekr.20050708152111.21"><vh>handle_help (may need work) (and it's stupid anyway)</vh></v>
<v t="ekr.20050708152111.22"><vh>handle_emacs</vh></v>
<v t="ekr.20050708152111.23"><vh>safe_execfile (not used)</vh></v>
<v t="ekr.20050708152111.24"><vh>split_user_input</vh></v>
<v t="ekr.20050708152111.25"><vh>update_cache</vh></v>
</v>
</v>
<v t="ekr.20050708105323.3"><vh>ipmagic &amp; palias</vh></v>
<v t="ekr.20050708165531.1"><vh>esc_quotes</vh></v>
</v>
<v t="ekr.20051020104412.37"><vh>Functional prototype of open-find-tab</vh>
<v t="ekr.20051020110046"><vh>class underlinedTkButton</vh>
<v t="ekr.20051020110046.1"><vh>__init__</vh>
<v t="ekr.20051020110046.2"><vh>&lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020110046.3"><vh>bindHotKey</vh></v>
<v t="ekr.20051020110046.4"><vh>buttonCallback</vh></v>
</v>
<v t="ekr.20051020104805" a="E"><vh>class leoTkinterFindTab</vh>
<v t="ekr.20051020104805.1" a="E"><vh> Not used</vh>
<v t="ekr.20051020104805.2"><vh>destroySelf</vh></v>
<v t="ekr.20051020104805.9"><vh>&lt;&lt; Create four columns of radio and checkboxes &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020104805.3" a="E"><vh>Birth &amp; death</vh>
<v t="ekr.20051020104805.4" a="E"><vh>__init__</vh>
<v t="ekr.20051020104805.5"><vh>&lt;&lt; create the tkinter intVars &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020104805.6" a="E"><vh>find.createFrame</vh>
<v t="ekr.20051020105921"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051020104805.7"><vh>&lt;&lt; Create the Find and Change panes &gt;&gt;</vh>
<v t="ekr.20051020104805.8"><vh>&lt;&lt; Bind Tab and control-tab &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020111605" a="E"><vh>&lt;&lt; Create two columns of radio and checkboxes &gt;&gt;</vh></v>
<v t="ekr.20051020104805.10"><vh>&lt;&lt; Create two rows of buttons &gt;&gt;</vh></v>
</v>
<v t="ekr.20051020104805.11" a="E"><vh>find.init</vh>
<v t="ekr.20051020104805.12"><vh>&lt;&lt; set find/change widgets &gt;&gt;</vh></v>
<v t="ekr.20051020104805.13"><vh>&lt;&lt; set radio buttons from ivars &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051020104805.14"><vh>find.update_ivars</vh></v>
<v t="ekr.20051020104805.15"><vh>tkFind.adjust_find_text</vh></v>
<v t="ekr.20051020104805.16"><vh>onCloseWindow</vh></v>
<v t="ekr.20051020104805.17"><vh>dismiss</vh></v>
<v t="ekr.20051020104805.18"><vh>bringToFront</vh></v>
<v t="ekr.20051020104805.19"><vh>selectAllFindText</vh></v>
<v t="ekr.20051020104805.20"><vh>Tkinter wrappers (leoTkinterFind)</vh></v>
</v>
</v>
</v>
<v t="ekr.20040312021734" annotate="7d71002e"><vh>Scripts...</vh>
<v t="ekr.20040318091620"><vh>Clear all uAs (unknown attributes)</vh></v>
<v t="ekr.20040915080419"><vh>Print all uAs (unknown attributes)</vh></v>
<v t="EKR.20040424065452"><vh>Compare files</vh></v>
<v t="EKR.20040424091411"><vh>Compare ignoring newlines</vh></v>
<v t="EKR.20040517074600.8"><vh>Count pages</vh></v>
<v t="ekr.20040311090054"><vh>Dump fileIndex</vh></v>
<v t="ekr.20040319111213"><vh>FilterHoist script</vh>
<v t="ekr.20040319111213.1"><vh>description</vh></v>
<v t="ekr.20040319142708"><vh>filter</vh></v>
<v t="ekr.20040319142202"><vh>old code</vh>
<v t="ekr.20040319111213.2"><vh>filter</vh></v>
<v t="ekr.20040319111213.3"><vh>search</vh></v>
</v>
<v t="ekr.20040319111213.4"><vh>filterHoist</vh></v>
<v t="ekr.20040319111213.5"><vh>addMenu</vh></v>
</v>
<v t="ekr.20040715105834"><vh>Fun...</vh>
<v t="EKR.20040626212434"><vh>Drawing experiments</vh>
<v t="EKR.20040626212434.1"><vh>Rectangles &amp; ovals</vh></v>
<v t="EKR.20040626212434.2"><vh>Lines &amp; arcs</vh></v>
<v t="EKR.20040626213007"><vh>Paul Klee</vh></v>
<v t="EKR.20040627150213"><vh>Complex functions</vh></v>
</v>
<v t="ekr.20040714055306"><vh>elispToPy</vh>
<v t="ekr.20050220091046.5"><vh>Old e2py Stuff</vh>
<v t="ekr.20050220091236"><vh>Old outer code</vh></v>
<v t="ekr.20040713150037"><vh>class tok</vh>
<v t="ekr.20040713150037.1"><vh>tok.__init__</vh></v>
<v t="ekr.20040714170021"><vh>tok.isParseTok</vh></v>
<v t="ekr.20040713150712"><vh>tok.copy</vh></v>
<v t="ekr.20040713173923"><vh>tok.match</vh></v>
<v t="ekr.20040713174349"><vh>tok.dump</vh></v>
<v t="ekr.20040713180208"><vh>tok.toString &amp; allies</vh>
<v t="ekr.20040713164604"><vh>tok.wsToString</vh></v>
</v>
</v>
<v t="ekr.20040715093804"><vh>Utility functions</vh>
<v t="ekr.20040715073230"><vh>isList &amp; isToken</vh></v>
<v t="ekr.20040715082059"><vh>printHeading</vh></v>
<v t="ekr.20040714095247"><vh>parseTreeToString</vh></v>
</v>
<v t="ekr.20040715080216"><vh>class lineClass</vh>
<v t="ekr.20040715080738"><vh>line.__init__</vh></v>
<v t="ekr.20040715081031"><vh>line.add</vh></v>
<v t="ekr.20040715080738.1"><vh>line.toString</vh></v>
</v>
<v t="ekr.20040713144036"><vh>class elisp2pyClass</vh>
<v t="ekr.20040713144036.1"><vh>e.__init__</vh>
<v t="ekr.20040714061625"><vh>&lt;&lt; define elisp constants &gt;&gt;</vh></v>
<v t="ekr.20040714061625.2"><vh>&lt;&lt; define elisp functions &gt;&gt;</vh></v>
<v t="ekr.20040714061625.1"><vh>&lt;&lt; define elisp statements &gt;&gt;</vh></v>
<v t="ekr.20040715090957"><vh>&lt;&lt; define code gen dispatch table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040713152809"><vh>Utils</vh>
<v t="ekr.20040713193437"><vh>deleteTokens</vh></v>
<v t="ekr.20040713161629.1"><vh>dump</vh></v>
<v t="ekr.20040713152318"><vh>error &amp; warning</vh></v>
<v t="ekr.20040713151556.1"><vh>findMatchingBracket</vh></v>
<v t="ekr.20040713160302"><vh>findTokens</vh></v>
<v t="ekr.20040714060941"><vh>isMatchingBracket</vh></v>
<v t="ekr.20040714053807.1"><vh>isStatement</vh></v>
<v t="ekr.20040714054620.1"><vh>matchTokens</vh></v>
<v t="ekr.20040713150314.1"><vh>replaceAll (not used yet)</vh></v>
<v t="ekr.20040713144926"><vh>tokenize &amp; allies</vh>
<v t="ekr.20040713154118"><vh>skipString</vh></v>
</v>
</v>
<v t="ekr.20040713211010"><vh>convert (main line)</vh></v>
<v t="ekr.20040714082939"><vh>Parser &amp; allies</vh>
<v t="ekr.20040714155341"><vh>parse</vh>
<v t="ekr.20040714154314"><vh>&lt;&lt; give error message about mismatched parens &gt;&gt;</vh></v>
</v>
<v t="ekr.20040714091940.1"><vh>block</vh></v>
</v>
<v t="ekr.20040714222507"><vh>Code gen</vh>
<v t="ekr.20040715081425"><vh>dumpCodeList</vh></v>
<v t="ekr.20040715075914"><vh>newCodeLine</vh></v>
<v t="ekr.20040714072448"><vh>removeBlankLines</vh></v>
</v>
<v t="ekr.20040715090957.2"><vh>gen_xxx</vh>
<v t="ekr.20040715071350"><vh>gen</vh></v>
<v t="ekr.20040715125453"><vh>gen_computed_function</vh></v>
<v t="ekr.20040715120001"><vh>gen_cond</vh></v>
<v t="ekr.20040715120001.1"><vh>gen_defconst</vh></v>
<v t="ekr.20040715120001.2"><vh>gen_defsubst</vh></v>
<v t="ekr.20040715093122"><vh>gen_defun</vh></v>
<v t="ekr.20040715120001.3"><vh>gen_defvar</vh></v>
<v t="ekr.20040715121456"><vh>gen_expression</vh></v>
<v t="ekr.20040715091409"><vh>gen_function</vh></v>
<v t="ekr.20040715120001.4"><vh>gen_if</vh></v>
<v t="ekr.20040715120001.5"><vh>gen_let, gen_let_star</vh></v>
<v t="ekr.20040715084435"><vh>gen_list</vh></v>
<v t="ekr.20040715120001.7"><vh>gen_prog, gen_prog1, gen_progn</vh></v>
<v t="ekr.20040715120001.8"><vh>gen_set &amp; gen_setq</vh></v>
<v t="ekr.20040715090957.1"><vh>gen_statement</vh></v>
<v t="ekr.20040715075845"><vh>gen_token</vh></v>
<v t="ekr.20040715120001.9"><vh>gen_unless, gen_when, gen_while</vh></v>
</v>
</v>
</v>
<v t="ekr.20050220085042.2"><vh>Data</vh>
<v t="ekr.20040713200238"><vh>Ref</vh>
<v t="ekr.20040713131315"><vh>To do</vh>
<v t="ekr.20040713133131"><vh>Tokens</vh></v>
<v t="ekr.20040713133131.1"><vh>Statements</vh></v>
<v t="ekr.20040713133131.2"><vh>Expressions</vh></v>
</v>
<v t="ekr.20040713130853"><vh>Docs</vh>
<v t="ekr.20040713130853.1"><vh>What elisp2py does</vh></v>
<v t="ekr.20040713130853.2"><vh>Theory of operation</vh></v>
<v t="ekr.20040713130853.3"><vh>&lt;&lt; specify user types &gt;&gt;</vh></v>
<v t="ekr.20040713130853.4"><vh>&lt;&lt; define testData &gt;&gt;</vh></v>
</v>
<v t="ekr.20040713144336"><vh>from c2py</vh>
<v t="ekr.20040713130853.15"><vh>Top-level scripts</vh>
<v t="ekr.20040713130853.16"><vh>convertCurrentTree</vh></v>
<v t="ekr.20040713130853.17"><vh>convertLeoTree</vh></v>
<v t="ekr.20040713130853.18"><vh>convertCFileToPython</vh></v>
<v t="ekr.20040713130853.7"><vh>speedTest</vh></v>
</v>
<v t="ekr.20040713130853.19"><vh>Top Level</vh>
<v t="ekr.20040713130853.20"><vh>convertCStringToPython</vh></v>
<v t="ekr.20040713130853.21"><vh>OLDconvertCodeList</vh></v>
<v t="ekr.20040713130853.22"><vh>convertDocList</vh></v>
<v t="ekr.20040713130853.23"><vh>skipDocPart</vh></v>
<v t="ekr.20040713130853.24"><vh>skipCodePart</vh></v>
</v>
<v t="ekr.20040713144926.1"><vh>Utils</vh>
<v t="ekr.20040713130853.61"><vh>safeReplace</vh></v>
<v t="ekr.20040713130853.43"><vh>match</vh></v>
<v t="ekr.20040713130853.44"><vh>matchWord</vh></v>
</v>
<v t="ekr.20040713130853.27"><vh>convertLeadingBlanks</vh></v>
<v t="ekr.20040713130853.28"><vh>findInList</vh></v>
<v t="ekr.20040713130853.29"><vh>findInCode</vh></v>
<v t="ekr.20040713130853.30"><vh>mungeAllFunctions</vh>
<v t="ekr.20040713130853.31"><vh>handlePossibleFunctionHeader</vh></v>
<v t="ekr.20040713130853.32"><vh>massageFunctionArgs</vh></v>
<v t="ekr.20040713130853.33"><vh>massageFunctionHead (sets gClassName)</vh></v>
<v t="ekr.20040713130853.34"><vh>massageFunctionBody</vh>
<v t="ekr.20040713130853.35"><vh>massageIvars</vh></v>
<v t="ekr.20040713130853.36"><vh>removeCasts</vh></v>
<v t="ekr.20040713130853.37"><vh>removeTypeNames</vh></v>
</v>
</v>
<v t="ekr.20040713130853.38"><vh>handleAllKeywords</vh>
<v t="ekr.20040713130853.39"><vh>handleKeyword</vh></v>
</v>
<v t="ekr.20040713130853.40"><vh>isWs and isWOrNl</vh></v>
<v t="ekr.20040713130853.41"><vh>isSectionDef</vh></v>
<v t="ekr.20040713130853.42"><vh>isStringOrComment</vh></v>
<v t="ekr.20040713130853.45"><vh>prevNonWsChar and prevNonWsOrNlChar</vh></v>
<v t="ekr.20040713144926.2"><vh>remove</vh>
<v t="ekr.20040713130853.46"><vh>removeAllCComments</vh></v>
<v t="ekr.20040713130853.47"><vh>removeAllCSentinels</vh></v>
<v t="ekr.20040713130853.48"><vh>removeAllPythonComments</vh></v>
<v t="ekr.20040713130853.49"><vh>removeAllPythonSentinels</vh></v>
<v t="ekr.20040713130853.50"><vh>removeAtRoot</vh></v>
<v t="ekr.20040713130853.51"><vh>removeBlankLines</vh></v>
<v t="ekr.20040713130853.52"><vh>removeExcessWs</vh>
<v t="ekr.20040713130853.53"><vh>removeExessWsFromLine</vh></v>
</v>
<v t="ekr.20040713130853.54"><vh>removeLeadingAtCode</vh></v>
<v t="ekr.20040713130853.55"><vh>removeMatchingBrackets</vh></v>
<v t="ekr.20040713130853.56"><vh>removeSemicolonsAtEndOfLines</vh></v>
<v t="ekr.20040713130853.57"><vh>removeTrailingWs</vh></v>
</v>
<v t="ekr.20040713144926.3"><vh>replace...</vh>
<v t="ekr.20040713130853.58"><vh>replace</vh></v>
<v t="ekr.20040713130853.59"><vh>replaceComments</vh></v>
<v t="ekr.20040713130853.60"><vh>replaceSectionDefs</vh></v>
</v>
<v t="ekr.20040713144926.4"><vh>skip...</vh>
<v t="ekr.20040713130853.62"><vh>skipCBlockComment</vh></v>
<v t="ekr.20040713130853.63"><vh>skipPastLine</vh></v>
<v t="ekr.20040713130853.64"><vh>skipPastWord</vh></v>
<v t="ekr.20040713130853.65"><vh>skipString</vh></v>
<v t="ekr.20040713130853.66"><vh>skipStringOrComment</vh></v>
<v t="ekr.20040713130853.68"><vh>skipWs and skipWsAndNl</vh></v>
</v>
</v>
<v t="ekr.20040713150856.1"><vh>g.scanning...</vh>
<v t="ekr.20040713150856.8"><vh>Scanners: calling scanError</vh>
<v t="ekr.20040713150856.9"><vh>skip_block_comment</vh></v>
<v t="ekr.20040713150856.10"><vh>skip_braces</vh></v>
<v t="ekr.20040713150856.12"><vh>skip_parens</vh></v>
<v t="ekr.20040713150856.13"><vh>skip_pascal_begin_end</vh></v>
<v t="ekr.20040713150856.14"><vh>skip_pascal_block_comment</vh></v>
<v t="ekr.20040713150856.15"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="ekr.20040713150856.20"><vh>skip_python_string</vh></v>
<v t="ekr.20040713150856.21"><vh>skip_string : called by tangle</vh></v>
<v t="ekr.20040713150856.22"><vh>skip_to_semicolon</vh></v>
</v>
<v t="ekr.20040713150856.24"><vh>Scanners: no error messages</vh>
<v t="ekr.20040713150856.25"><vh>escaped</vh></v>
<v t="ekr.20040713150856.26"><vh>find_line_start</vh></v>
<v t="ekr.20040713150856.27"><vh>find_on_line</vh></v>
<v t="ekr.20040713150856.28"><vh>is_c_id</vh></v>
<v t="ekr.20040713150856.29"><vh>is_nl</vh></v>
<v t="ekr.20040713150856.30"><vh>is_special</vh></v>
<v t="ekr.20040713150856.31"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="ekr.20040713150856.32"><vh>match</vh></v>
<v t="ekr.20040713150856.33"><vh>match_c_word</vh></v>
<v t="ekr.20040713150856.34"><vh>match_ignoring_case</vh></v>
<v t="ekr.20040713150856.35"><vh>match_word</vh></v>
<v t="ekr.20040713150856.36"><vh>skip_blank_lines</vh></v>
<v t="ekr.20040713150856.37"><vh>skip_c_id</vh></v>
<v t="ekr.20040713150856.38"><vh>skip_id</vh></v>
<v t="ekr.20040713150856.39"><vh>skip_line, skip_to_end_of_line</vh></v>
<v t="ekr.20040713150856.40"><vh>skip_long</vh></v>
<v t="ekr.20040713150856.41"><vh>skip_matching_delims</vh></v>
<v t="ekr.20040713150856.42"><vh>skip_nl</vh></v>
<v t="ekr.20040713150856.43"><vh>skip_non_ws</vh></v>
<v t="ekr.20040713150856.44"><vh>skip_pascal_braces</vh></v>
<v t="ekr.20040713150856.45"><vh>skip_to_char</vh></v>
<v t="ekr.20040713150856.46"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="ekr.20040713150856.47"><vh>splitLines &amp; joinLines</vh></v>
</v>
<v t="ekr.20040713205718"><vh>createIndentedBlock NOT USED</vh>
<v t="ekr.20040714074445"><vh>&lt;&lt; insert nl and ws tokens &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040713131350"><vh>-elisp2py-input-</vh>
<v t="ekr.20040715071555"><vh>igrep-read-file-name</vh></v>
</v>
<v t="ekr.20050220091046.4"><vh>-elisp2py-output-</vh></v>
<v t="ekr.20040713132127.1"><vh>igrep.el</vh>
<v t="ekr.20040713132127.2"><vh>provide</vh></v>
<v t="ekr.20040713132127.3"><vh>const igrep-version</vh></v>
<v t="ekr.20040713132127.4"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.5"><vh>var igrep-options</vh></v>
<v t="ekr.20040713132127.6"><vh>put</vh></v>
<v t="ekr.20040713132127.7"><vh>var igrep-read-options</vh></v>
<v t="ekr.20040713132127.8"><vh>put</vh></v>
<v t="ekr.20040713132127.9"><vh>var igrep-read-multiple-files</vh></v>
<v t="ekr.20040713132127.10"><vh>put</vh></v>
<v t="ekr.20040713132127.11"><vh>var igrep-expression-default</vh></v>
<v t="ekr.20040713132127.12"><vh>put</vh></v>
<v t="ekr.20040713132127.13"><vh>var igrep-files-default</vh></v>
<v t="ekr.20040713132127.14"><vh>put</vh></v>
<v t="ekr.20040713132127.15"><vh>var igrep-verbose-prompts</vh></v>
<v t="ekr.20040713132127.16"><vh>put</vh></v>
<v t="ekr.20040713132127.17"><vh>var igrep-insert-default-key</vh></v>
<v t="ekr.20040713132127.18"><vh>put</vh></v>
<v t="ekr.20040713132127.19"><vh>var igrep-save-buffers</vh></v>
<v t="ekr.20040713132127.20"><vh>put</vh></v>
<v t="ekr.20040713132127.21"><vh>var igrep-null-device</vh></v>
<v t="ekr.20040713132127.22"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.23"><vh>var igrep-program</vh></v>
<v t="ekr.20040713132127.24"><vh>var igrep-expression-option</vh></v>
<v t="ekr.20040713132127.25"><vh>var igrep-program-table</vh></v>
<v t="ekr.20040713132127.26"><vh>var igrep-use-zgrep</vh></v>
<v t="ekr.20040713132127.27"><vh>var igrep-find</vh></v>
<v t="ekr.20040713132127.28"><vh>var igrep-find-program</vh></v>
<v t="ekr.20040713132127.29"><vh>var igrep-find-prune-clause</vh></v>
<v t="ekr.20040713132127.30"><vh>var igrep-find-file-clause</vh></v>
<v t="ekr.20040713132127.31"><vh>var igrep-find-use-xargs</vh></v>
<v t="ekr.20040713132127.32"><vh>var igrep-program-default</vh></v>
<v t="ekr.20040713132127.33"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.34"><vh>var igrep-expression-history</vh></v>
<v t="ekr.20040713132127.35"><vh>var igrep-files-history</vh></v>
<v t="ekr.20040713132127.36"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.37"><vh>igrep-insinuate</vh></v>
<v t="ekr.20040713132127.38"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.39"><vh>igrep</vh></v>
<v t="ekr.20040713132127.40"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.41"><vh>igrep-find</vh></v>
<v t="ekr.20040713132127.42"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.43"><vh>igrep-visited-files</vh></v>
<v t="ekr.20040713132127.44"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.45"><vh>dired-do-igrep</vh></v>
<v t="ekr.20040713132127.46"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.47"><vh>dired-do-igrep-find</vh></v>
<v t="ekr.20040713132127.48"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.49"><vh>Buffer-menu-igrep</vh></v>
<v t="ekr.20040713132127.50"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.51"><vh>igrep-dired-file-current-word</vh></v>
<v t="ekr.20040713132127.52"><vh>igrep-buffer-file-name-pattern</vh></v>
<v t="ekr.20040713132127.53"><vh>igrep-dired-directory-file-pattern</vh></v>
<v t="ekr.20040713132127.54"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.55"><vh>igrep-format-find-command</vh></v>
<v t="ekr.20040713132127.56"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.57"><vh>igrep-default-expression</vh></v>
<v t="ekr.20040713132127.58"><vh>igrep-default-files</vh></v>
<v t="ekr.20040713132127.59"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.60"><vh>igrep-read-args</vh></v>
<v t="ekr.20040713132127.61"><vh>igrep-read-program</vh></v>
<v t="ekr.20040713132127.62"><vh>igrep-read-options</vh></v>
<v t="ekr.20040713132127.63"><vh>igrep-read-expression</vh></v>
<v t="ekr.20040713132127.64"><vh>igrep-insert-default-expression</vh></v>
<v t="ekr.20040713132127.65"><vh>igrep-insert-default-files</vh></v>
<v t="ekr.20040713132127.66"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.67"><vh>igrep-read-files</vh></v>
<v t="ekr.20040713132127.68"><vh>igrep-read-file-name</vh></v>
<v t="ekr.20040713132127.69"><vh>unnamed data</vh></v>
</v>
</v>
<v t="ekr.20040713123617.1"><vh>e2pyScript</vh>
<v t="ekr.20050220085042.1"><vh>run</vh></v>
<v t="ekr.20050220091046"><vh>class e2py</vh>
<v t="ekr.20050220091046.1"><vh>ctor</vh></v>
<v t="ekr.20050220111049"><vh>doBlock</vh></v>
<v t="ekr.20050220091046.3"><vh>doParenBlock</vh></v>
<v t="ekr.20050220105058"><vh>doDef</vh></v>
<v t="ekr.20050220124658"><vh>doDoubleParen</vh></v>
<v t="ekr.20050220111114"><vh>doId</vh></v>
<v t="ekr.20050220105058.1"><vh>doIf</vh></v>
<v t="ekr.20050220105058.2"><vh>doLet</vh></v>
<v t="ekr.20050220091046.2"><vh>doOuterBlock</vh></v>
<v t="ekr.20050220105058.3"><vh>doProg</vh></v>
<v t="ekr.20050220111923"><vh>dump</vh></v>
<v t="ekr.20050220092732"><vh>findMatchingBracket</vh></v>
<v t="ekr.20050220114616"><vh>getToken</vh></v>
<v t="ekr.20050220105726"><vh>indent</vh></v>
<v t="ekr.20050220093752"><vh>matchingBracket</vh></v>
<v t="ekr.20050220103808"><vh>skip_id</vh></v>
<v t="ekr.20050220105058.4"><vh>skipString</vh></v>
<v t="ekr.20050220122447"><vh>removeBlankLines</vh></v>
<v t="ekr.20050220100049"><vh>stripLws</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040613162717"><vh>Report newlines</vh></v>
<v t="ekr.20040312021734.1"><vh>Script to clean unused tnodeLists</vh></v>
<v t="ekr.20040330095252"><vh>script to clear log frame</vh></v>
<v t="ekr.20040322120331"><vh>script to print tnodeList's</vh></v>
<v t="EKR.20040517074600.9"><vh>Scripts to debug font problem</vh>
<v t="EKR.20040517074600.10"><vh>Show font</vh></v>
<v t="EKR.20040517074600.11"><vh>Show settings</vh>
<v t="EKR.20040517074600.12"><vh>getFontSettings</vh></v>
</v>
<v t="EKR.20040517074600.13"><vh>Print default font</vh></v>
</v>
<v t="ekr.20040723065021"><vh>stripBlankLines</vh>
<v t="ekr.20040723065047"><vh>Test</vh></v>
</v>
<v t="ekr.20040717121014"><vh>tellGnxScript</vh></v>
<v t="ekr.20040706071823"><vh>test of Python's parser module</vh></v>
<v t="ekr.20040804104924"><vh>Test of p.__hash__</vh>
<v t="ekr.20040804105026"><vh>a</vh>
<v t="ekr.20040804104328"><vh>Script</vh></v>
<v t="ekr.20040804104328"><vh>Script</vh></v>
</v>
<v t="ekr.20040804105026"><vh>a</vh>
<v t="ekr.20040804104328"><vh>Script</vh></v>
<v t="ekr.20040804104328"><vh>Script</vh></v>
</v>
</v>
<v t="ekr.20040805101759"><vh>How to use pdb</vh>
<v t="ekr.20040805102453"><vh>@url http://docs.python.org/lib/debugger-commands.html</vh></v>
</v>
<v t="ekr.20041013101029"><vh>headfind</vh>
<v t="ekr.20041013101029.1"><vh>&lt;&lt; about this script &gt;&gt;</vh></v>
</v>
<v t="ekr.20041001161303"><vh>print all loaded plugins</vh></v>
<v t="ekr.20041019080125"><vh>Report loaded plugins</vh></v>
<v t="ekr.20041124144944"><vh>print sys.path</vh></v>
<v t="ekr.20041126035448"><vh>Script to import a file</vh></v>
<v t="ekr.20041225104159.1"><vh>Create stand-alone settings dialog</vh></v>
<v t="ekr.20050108110751"><vh>HTMLize scripts</vh>
<v t="ekr.20041229163210"><vh>dyna htmlize</vh>
<v t="ekr.20041229164609"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20041229163210.2"><vh>&lt;&lt; init globals &gt;&gt;</vh></v>
<v t="ekr.20041229170824"><vh>stripSentinels</vh></v>
<v t="ekr.20041229165956"><vh>sanitize</vh></v>
<v t="ekr.20041229163210.3"><vh>class Parser</vh>
<v t="ekr.20041229163210.4"><vh>__init__</vh></v>
<v t="ekr.20041229163210.5"><vh>format</vh></v>
<v t="ekr.20041229163210.6"><vh>__call__</vh></v>
</v>
<v t="ekr.20041229164609.2"><vh>htmlize</vh>
<v t="ekr.20041229163210.7"><vh>&lt;&lt; colorize with silvercity &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20041228135008"><vh>HTML to Browser</vh>
<v t="ekr.20041228140714"><vh>&lt;&lt; alternate code doesn't work well for me &gt;&gt;</vh></v>
</v>
<v t="ekr.20050108110751.1"><vh>Code from Bill P</vh>
<v t="ekr.20050108110751.2"><vh>NewHeadline</vh></v>
</v>
</v>
<v t="ekr.20050210180034"><vh>jython script</vh></v>
<v t="ekr.20050219054039"><vh>Scripts to convert ChoiceMail .ini file to .csv file</vh>
<v t="ekr.20050218174326.1"><vh>Scipt to remove rejected entries</vh>
<v t="ekr.20050218170806.1"><vh>@killcolor</vh>
<v t="ekr.20050218170806.2"><vh>address</vh></v>
</v>
</v>
<v t="ekr.20050218170806"><vh>Script to clean address</vh>
<v t="ekr.20050219054351"><vh>@killcolor</vh>
<v t="ekr.20050219054351.1"><vh>address</vh></v>
</v>
</v>
<v t="ekr.20050218184044.10"><vh>Script to create comma delimited lists</vh>
<v t="ekr.20050219054039.1"><vh>address</vh></v>
<v t="ekr.20050218184044.11"><vh>result</vh></v>
</v>
</v>
<v t="ekr.20050219075759"><vh>Scripts demonstrating how to do anything with Leo menus</vh>
<v t="ekr.20050219071503"><vh>Test of createMenuItemsFromTable</vh></v>
<v t="ekr.20050219073752.1"><vh>Add a menu item after Open With</vh></v>
</v>
<v t="ekr.20050310082013"><vh>AutoIt script from e</vh></v>
<v t="ekr.20050225161940" annotate="7d71002e"><vh>Script to execute @test, @suite or file</vh>
<v t="ekr.20050225161940.1" annotate="7d71002e"><vh>@test __name__</vh></v>
<v t="ekr.20050225162123" annotate="55ea37643731303032383535303837303732363936663732363937343739373130313238363336333663363536663061353436623530363936333662366336353536363137323061373130323666373130333464306632373632353530343665366636343635373130353238363830323666373130363535303037313037363235353032363236373731303832383638303236663731303936383037363235353039363137323633363836353734373937303635373130613238363830323666373130623638303736323535303236363637373130633238363830323666373130643638303736323735326571002e"><vh>@@thin executeFileTest.py</vh></v>
<v t="ekr.20050225161940.2" annotate="7d71002e"><vh>Exec File</vh>
<v t="ekr.20050225161940.3" annotate="7d71002e"><vh>&lt;&lt; docstring &gt;&gt;</vh></v>
<v t="ekr.20050225171553" annotate="7d71002e"><vh>&lt;&lt; imports &gt;&gt;</vh></v>
<v t="ekr.20050225161940.5" annotate="7d71002e"><vh>getAtFileName</vh></v>
<v t="ekr.20050225161940.6" annotate="7d71002e"><vh>doatest</vh></v>
</v>
</v>
<v t="ekr.20050704172623"><vh>Print all headlines, properly indented</vh></v>
<v t="ekr.20050726112715"><vh>Multiline test</vh></v>
<v t="ekr.20050801075332"><vh>PrettyPrintTest (copy)</vh></v>
<v t="ekr.20050801070538"><vh>PrettyPrintTest</vh></v>
<v t="ekr.20050803075926"><vh>sudoku puzzle</vh>
<v t="ekr.20050804073824"><vh>&lt;&lt; define data &gt;&gt;</vh></v>
<v t="ekr.20050911123109"><vh>&lt;&lt; 5-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050911145104"><vh>&lt;&lt; 4-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050811075608"><vh>&lt;&lt; 3-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050929065040"><vh>&lt;&lt; 2-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050927122648"><vh>&lt;&lt; 1-star puzzles &gt;&gt;</vh></v>
<v t="ekr.20050803075926.1"><vh>class sudokuClass</vh>
<v t="ekr.20050803075926.2"><vh> ctor (main) &amp; helpers</vh>
<v t="ekr.20050803202932"><vh>initFromData</vh></v>
<v t="ekr.20050803075926.4"><vh>finishInit</vh></v>
<v t="ekr.20050803121102"><vh>checkData</vh></v>
<v t="ekr.20050804070733"><vh>check &amp; helper</vh>
<v t="ekr.20050804071049"><vh>checkGroup</vh></v>
</v>
</v>
<v t="ekr.20050804071242"><vh>printing &amp; dumping</vh>
<v t="ekr.20050803080858"><vh>dump</vh></v>
<v t="ekr.20050803121730"><vh>printData</vh></v>
<v t="ekr.20050803200132"><vh>printCells</vh></v>
</v>
<v t="ekr.20050911112043.1"><vh>Utils</vh>
<v t="ekr.20050803095202"><vh>groupNumber</vh></v>
<v t="ekr.20050803075926.3"><vh>error</vh></v>
<v t="ekr.20050803215553"><vh>trace</vh></v>
<v t="ekr.20050803202932.1"><vh>isFinished</vh></v>
</v>
<v t="ekr.20050911094859"><vh>Guesses</vh>
<v t="ekr.20050803203001"><vh>findBestGroup</vh></v>
<v t="ekr.20050803210939"><vh>findGuesses</vh></v>
<v t="ekr.20050804060706"><vh>isValidGuess</vh></v>
</v>
<v t="ekr.20050803075926.5"><vh>solve (main)</vh>
<v t="ekr.20050911085945"><vh>&lt;&lt; guess an answer &gt;&gt;</vh></v>
</v>
<v t="ekr.20050911135016"><vh>group classes</vh>
<v t="ekr.20050911101819"><vh>class squareGroupClass</vh>
<v t="ekr.20050803121102.2"><vh> ctor</vh></v>
<v t="ekr.20050911101819.1"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050803130829"><vh>finishCreate</vh></v>
<v t="ekr.20050803161504"><vh>computeRelatedGroups</vh></v>
</v>
<v t="ekr.20050910194752"><vh>class colGroupClass</vh>
<v t="ekr.20050910194752.1"><vh>ctor</vh></v>
<v t="ekr.20050911102800"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050910195107"><vh>finishCreate</vh></v>
</v>
<v t="ekr.20050910194752.2"><vh>class rowGroupClass</vh>
<v t="ekr.20050910194752.3"><vh>ctor</vh></v>
<v t="ekr.20050911102800.1"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050910195107.1"><vh>finishCreate</vh></v>
</v>
</v>
<v t="ekr.20050803075926.7"><vh>class cellClass</vh>
<v t="ekr.20050911144450"><vh> birth</vh>
<v t="ekr.20050803081438"><vh> ctor (cell)</vh></v>
<v t="ekr.20050803200724"><vh>__repr__ &amp; __str__</vh></v>
<v t="ekr.20050911113403"><vh>finishCreate</vh></v>
</v>
<v t="ekr.20050911112043.2"><vh>error &amp; trace</vh></v>
<v t="ekr.20050911092707"><vh>reduce</vh></v>
<v t="ekr.20050911111404"><vh>removeConflicts</vh></v>
<v t="ekr.20050911094544"><vh>setValue</vh></v>
<v t="ekr.20050911092707.1"><vh>unique</vh></v>
<v t="ekr.20050803134436.1"><vh>valIsPossible</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20041001211817" a="E" annotate="7d71002e"><vh>Buttons &amp; settings</vh>
<v t="ekr.20051010091827"><vh>Previous settings</vh>
<v t="ekr.20050801071700"><vh>@@string stylesheet = type="text/xsl" href="bpLEOHTM.xsl"</vh></v>
<v t="ekr.20041218110904"><vh>@page local options</vh>
<v t="ekr.20041211044607"><vh>@int page_width = 80</vh></v>
<v t="ekr.20041213075902"><vh>@font log font</vh></v>
<v t="ekr.20041217042849"><vh>@font body font</vh></v>
<v t="ekr.20041217132317"><vh>@strings[a,b,c] stringsTest = c</vh></v>
<v t="ekr.20041217132338"><vh>@ints[1,2,3] intsTest = 3</vh></v>
<v t="ekr.20050620085732"><vh>@language target_language = Python</vh></v>
</v>
<v t="ekr.20041217144914"><vh>@page colors</vh>
<v t="ekr.20041217135841"><vh>@color outline_pane_background_color = None</vh></v>
<v t="ekr.20041217142026"><vh>@color log_pane_background_color = None</vh></v>
<v t="ekr.20041217143421"><vh>@color body_text_background_color = None</vh></v>
<v t="ekr.20041218100259"><vh>@color headline_text_selected_background_color = None</vh></v>
</v>
<v t="ekr.20041218141525"><vh>@page Fonts</vh>
<v t="ekr.20041218141525.1"><vh>@font log font</vh></v>
<v t="ekr.20041218141525.2"><vh>@font body text font</vh></v>
<v t="ekr.20041218141525.3"><vh>@font outline font</vh></v>
</v>
<v t="ekr.20050123143337"><vh>@bool redirect_execute_script_output_to_log_pane = None</vh></v>
<v t="ekr.20050415090637"><vh>@bool allow_clone_drags = True</vh></v>
<v t="ekr.20050419082439"><vh>@if-platform win32</vh>
<v t="ekr.20050419070841"><vh>@string ekrSetting = abc2</vh></v>
</v>
<v t="ekr.20050419084109"><vh>@if-gui gtk</vh>
<v t="ekr.20050419084109.1"><vh>@string gtkSetting = xyz</vh></v>
</v>
<v t="ekr.20050419085933"><vh>@ints[0,1,2] testInts = 1</vh></v>
<v t="ekr.20050505104752"><vh>@bool redirect_execute_script_output_to_log_pane = False</vh></v>
<v t="ekr.20050511085027"><vh>@string undo_granularity = word</vh></v>
<v t="ekr.20050512130051"><vh>@strings[vertical,horizontal] initial_splitter_orientation = vertical</vh></v>
<v t="ekr.20050705142631"><vh>@string unicodeTest = Prsentation.leo</vh></v>
<v t="ekr.20050808191449"><vh>@page rst3 options</vh>
<v t="ekr.20050810095252"><vh>Http options...</vh>
<v t="ekr.20050809091430.1"><vh>@bool rst3_clear_http_attributes = False</vh></v>
<v t="ekr.20050809091430.3"><vh>@string rst3_http_attributename = 'rst_http_attribute'</vh></v>
<v t="ekr.20050809091430.4"><vh>@bool rst3_http_server_support = False</vh></v>
<v t="ekr.20050809091430.6"><vh>@string rst3_node_begin_marker = 'http-node-marker-'</vh></v>
</v>
<v t="ekr.20050809091430.8"><vh>@bool rst3_write_intermediate_file = True</vh></v>
</v>
</v>
<v t="ekr.20041121151002" annotate="7d71002e"><vh>@settings</vh>
<v t="ekr.20050104095950"><vh>@shortcuts</vh></v>
<v t="ekr.20050328101834"><vh>@page http plugin</vh>
<v t="ekr.20050328101834.1"><vh>@bool http_active = False</vh></v>
<v t="ekr.20050328101834.2"><vh>@int  port = 8080</vh></v>
<v t="ekr.20050328101834.3"><vh>@string rst_http_attributename = ''</vh></v>
</v>
<v t="ekr.20051013162226"><vh>@bool test_setting = True</vh></v>
<v t="ekr.20051018071924"><vh>@@color log_pane_Completion_tab_background_color = yellow</vh></v>
</v>
<v t="ekr.20051020124457"><vh>Previous buttons</vh>
<v t="ekr.20041001203411.1"><vh>@@script hi</vh></v>
<v t="ekr.20041113113555"><vh>@@button check spelling...</vh></v>
<v t="ekr.20041125145818.1"><vh>@@button settings...</vh></v>
<v t="ekr.20041230121429"><vh>@@ button pydoc</vh></v>
<v t="ekr.20050210180937"><vh>@@ button jython</vh></v>
<v t="ekr.20050331070207"><vh>@@ button golf</vh></v>
<v t="ekr.20050704170739"><vh>@@button Ipython</vh></v>
<v t="ekr.20050726101758"><vh>@@button Beautify</vh></v>
<v t="ekr.20050722115320"><vh>@@button leoEmacs</vh></v>
<v t="ekr.20050805175217"><vh>@@button rst2</vh></v>
<v t="ekr.20050821072028"><vh>@@button Lines Up</vh>
<v t="ekr.20050821072028.1"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20050821081021"><vh>@@button Lines Down</vh>
<v t="ekr.20050821081021.1" a="M"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20050805150320"><vh>@@button rst3</vh></v>
<v t="ekr.20050930124917"><vh>@@button outlineToClipboard</vh></v>
<v t="ekr.20040707081532.1"><vh>Do @test</vh></v>
</v>
<v t="ekr.20041001194357"><vh>@button unit test</vh></v>
<v t="ekr.20050911112310"><vh>@button save</vh></v>
<v t="ekr.20051020124457.1" a="TV"><vh>@button find tab</vh></v>
</v>
<v t="ekr.20051012104957"><vh>Other unit test stuff...</vh>
<v t="ekr.20050618061835"><vh>How to use the @test directive, by Roger Erens</vh>
<v t="ekr.20050618061835.1"><vh>Intro</vh>
<v t="ekr.20050618061835.2"><vh>@url http://www.onlamp.com/pub/a/python/2005/02/03/tdd_pyunit2.html</vh></v>
</v>
<v t="ekr.20050618061835.3"><vh>Preparations: adding a button</vh>
<v t="ekr.20050618061835.4"><vh>@@button Do @test</vh></v>
</v>
<v t="ekr.20050618061835.5"><vh>Alpha</vh>
<v t="ekr.20050618061835.6"><vh>@test my first Leo test</vh></v>
<v t="ekr.20050618061835.7"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.8"><vh>Bravo</vh>
<v t="ekr.20050618061835.9"><vh>@test my second Leo test</vh></v>
<v t="ekr.20050618061835.10"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.11"><vh>It takes two to tango</vh>
<v t="ekr.20050618061835.6"><vh>@test my first Leo test</vh></v>
<v t="ekr.20050618061835.9"><vh>@test my second Leo test</vh></v>
<v t="ekr.20050618061835.12"><vh>output on the console</vh></v>
</v>
<v t="ekr.20050618061835.13"><vh>Life gets more interesting</vh>
<v t="ekr.20050618061835.14"><vh>@test koekiemonster.wants()</vh>
<v t="ekr.20050618061835.15"><vh>input data</vh></v>
<v t="ekr.20050618061835.16"><vh>expected result</vh></v>
</v>
<v t="ekr.20050618061835.17"><vh>output on the console</vh></v>
<v t="ekr.20050618061835.18"><vh>output on the console using print statements</vh></v>
</v>
<v t="ekr.20050618061835.19"><vh>How about @suite?</vh></v>
<v t="ekr.20050618061835.20"><vh>Final remarks</vh></v>
</v>
<v t="ekr.20040712101754.2"><vh>Unit tests for  .leo files...</vh>
<v t="ekr.20040730181601"><vh>@test minimalLeoFile.leo</vh></v>
<v t="ekr.20040730181610"><vh>@test minimalLeoFile2.leo</vh></v>
<v t="ekr.20040831104758"><vh>@test minimalLeoFile3.leo</vh></v>
<v t="ekr.20040712101754.3"><vh>@test test.leo</vh></v>
<v t="ekr.20040803090901"><vh>@test leoDist.leo</vh></v>
<v t="ekr.20040712101754.4"><vh>@test LeoPy.leo</vh></v>
<v t="ekr.20040712101754.5"><vh>@test leoPlugins.leo</vh></v>
<v t="ekr.20040712101754.6"><vh>@test LeoDocs.leo</vh></v>
<v t="ekr.20040831101747"><vh>@test line endings of Linux scripts</vh></v>
</v>
<v t="bwmulder.20050108100437.1"><vh>How to run unit tests</vh></v>
<v t="ekr.20040723064143.1"><vh>To do...</vh>
<v t="ekr.20040723064143.3"><vh>Test error recovery when reading descendentTnodeUa's</vh></v>
<v t="ekr.20040903102217"><vh>Test multi-line @doc parts with @language html</vh></v>
<v t="ekr.20050119144013"><vh>Remove all file system dependencies</vh></v>
</v>
<v t="ekr.20040712101754.213"><vh>Unfinished tests...</vh>
<v t="ekr.20040712101754.214"><vh>Outline tests (Sometimes fails)</vh>
<v t="ekr.20040712101754.215"><vh>test of p.copyTreeAfter and p.copyTreeFromSelfTo</vh>
<v t="ekr.20040712101754.216"><vh>root1</vh>
<v t="ekr.20040712101754.217"><vh>a</vh>
<v t="ekr.20040712101754.218"><vh>c</vh>
<v t="ekr.20040712101754.219"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20040712101754.220"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.221"><vh>Manual test of testUtils.replaceOutline</vh>
<v t="ekr.20040712101754.222"><vh>outline1</vh>
<v t="ekr.20040712101754.223"><vh>a</vh></v>
</v>
<v t="ekr.20040712101754.224"><vh>outline2</vh>
<v t="ekr.20040712101754.225"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.226"><vh>testUtils.replaceOutline</vh></v>
<v t="ekr.20040712101754.227"><vh>@@ suite Outline/Undo tests</vh>
<v t="ekr.20040712101754.228"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040712101754.229"><vh>class outlineTestCase</vh>
<v t="ekr.20040712101754.230"><vh>__init__</vh></v>
<v t="ekr.20040712101754.231"><vh>outlineCommand</vh></v>
<v t="ekr.20040712101754.232"><vh>runTest</vh></v>
<v t="ekr.20040712101754.233"><vh>setUp</vh></v>
<v t="ekr.20040712101754.234"><vh>tearDown</vh></v>
<v t="ekr.20040712101754.235"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040712101754.236"><vh>outlineTests</vh>
<v t="ekr.20040712101754.237"><vh>moveOutlineDown</vh>
<v t="ekr.20040712101754.238"><vh>before</vh>
<v t="ekr.20040712101754.239"><vh>a</vh></v>
<v t="ekr.20040712101754.240"><vh>move</vh></v>
<v t="ekr.20040712101754.241"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.242"><vh>after</vh>
<v t="ekr.20040712101754.243"><vh>a</vh></v>
<v t="ekr.20040712101754.244"><vh>b</vh></v>
<v t="ekr.20040712101754.245"><vh>move</vh></v>
</v>
<v t="ekr.20040712101754.246"><vh>ref</vh>
<v t="ekr.20040712101754.247"><vh>a</vh></v>
<v t="ekr.20040712101754.248"><vh>move</vh></v>
<v t="ekr.20040712101754.249"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.250"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040712101754.251"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040712101754.252"><vh>moveOutlineUp</vh></v>
</v>
</v>
<v t="ekr.20040712101754.253"><vh>Find Command tests...(Not finished)</vh>
<v t="ekr.20040712101754.254"><vh>@suite Find sommands tests</vh>
<v t="ekr.20040712101754.255"><vh>class findCommandTestCase</vh>
<v t="ekr.20040712101754.256"><vh>setUp</vh></v>
<v t="ekr.20040712101754.257"><vh>testFindCommand</vh></v>
<v t="ekr.20040712101754.258"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040712101754.259"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040712101754.260"><vh>findTests</vh></v>
</v>
</v>
</v>
<v t="EKR.20040619133116" annotate="7d71002e"><vh>Unit tests...</vh>
<v t="ekr.20040712101754.274"><vh>@suite run all doctests</vh></v>
<v t="ekr.20050106080304"><vh>@suite run all test routines (runs some tests twice!)</vh>
<v t="ekr.20050106123646"><vh>unused</vh>
<v t="ekr.20050106094854"><vh>class commanderTestCase</vh>
<v t="ekr.20050106094854.1"><vh>__init__</vh></v>
<v t="ekr.20050106094854.2"><vh> fail</vh></v>
<v t="ekr.20050106094854.3"><vh>setUp</vh></v>
<v t="ekr.20050106094854.4"><vh>tearDown</vh></v>
<v t="ekr.20050106094854.5"><vh>runTest</vh></v>
<v t="ekr.20050106094854.6"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050106094747"><vh>addTestRoutinesInCommanderToSuite</vh>
<v t="ekr.20050106095223"><vh>findTestsInCommander</vh></v>
</v>
</v>
<v t="ekr.20050106080318.1"><vh>&lt;&lt; class testRoutineTestCase &gt;&gt;</vh>
<v t="ekr.20050106080318.2"><vh>__init__</vh></v>
<v t="ekr.20050106080318.3"><vh> fail</vh></v>
<v t="ekr.20050106080318.4"><vh>setUp</vh></v>
<v t="ekr.20050106080318.5"><vh>tearDown</vh></v>
<v t="ekr.20050106080318.6"><vh>runTest</vh></v>
<v t="ekr.20050106080318.7"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050106080318"><vh>addTestRoutinesInModuleToSuite</vh></v>
<v t="ekr.20050106081120.2"><vh>findTestsInModule</vh>
<v t="ekr.20050106124235"><vh>&lt;&lt; print classes, methods &amp; functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20050106124624"><vh>getAllLeoModules</vh></v>
<v t="ekr.20050106133147"><vh>removeLeadingWs</vh></v>
</v>
<v t="ekr.20041012101944"><vh>@thin ../test/unittest/errorTest.py</vh></v>
<v t="ekr.20040712101754"><vh>General Unit Tests...</vh>
<v t="ekr.20041130092210"><vh>Batch mode tests...</vh>
<v t="ekr.20040327114250"><vh>@thin ../test/unittest/batchTest.py</vh></v>
<v t="ekr.20040712101754.186"><vh>@test batch mode</vh>
<v t="ekr.20041012084201"><vh>removeFile</vh></v>
</v>
</v>
<v t="ekr.20050512084850"><vh>Check outline tests...</vh>
<v t="ekr.20040712101754.272"><vh>@test CheckOutline</vh></v>
<v t="ekr.20041019124050"><vh>@test pretty printing a docstring</vh>
<v t="ekr.20041019124050.1"><vh>Original</vh></v>
<v t="ekr.20041019124050.2"><vh>Test</vh></v>
</v>
<v t="ekr.20040713070526"><vh>@test Pretty Print command</vh>
<v t="ekr.20040713123617"><vh>tempNode</vh></v>
<v t="ekr.20050726141158"><vh>before</vh></v>
<v t="ekr.20040713123828.1"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20040712101754.115"><vh>Colorizer tests...</vh>
<v t="ekr.20040712101754.176"><vh>@test python keywords (new colorizer)</vh></v>
<v t="ekr.20040712101754.116"><vh>@test @comment after @language plain</vh>
<v t="ekr.20040712101754.117"><vh>Test</vh></v>
</v>
<v t="ekr.20040712101754.118"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20040712101754.119"><vh>Actionscript</vh></v>
</v>
<v t="ekr.20040712101754.120"><vh>@test colorizer C</vh>
<v t="ekr.20040712101754.121"><vh>C</vh></v>
</v>
<v t="ekr.20040712101754.122"><vh>@test colorizer C#</vh>
<v t="ekr.20040712101754.123"><vh>C#</vh></v>
</v>
<v t="ekr.20040712101754.124"><vh>@test colorizer css</vh>
<v t="ekr.20040712101754.125"><vh>css</vh></v>
</v>
<v t="ekr.20040712101754.126"><vh>@test colorizer CWEB</vh>
<v t="ekr.20040712101754.127"><vh>CWEB</vh>
<v t="ekr.20040712101754.128"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040712101754.129"><vh>@test colorizer elisp</vh>
<v t="ekr.20040712101754.130"><vh>elisp</vh></v>
</v>
<v t="ekr.20041107105213"><vh>@test colorizer forth</vh>
<v t="ekr.20041107105213.1"><vh>forth</vh></v>
</v>
<v t="ekr.20040712101754.131"><vh>@test colorizer HTML string bug</vh>
<v t="ekr.20040712101754.132"><vh>String bug in html</vh></v>
</v>
<v t="ekr.20040712101754.133"><vh>@test colorizer HTML1</vh>
<v t="ekr.20040712101754.134"><vh>HTML1</vh></v>
</v>
<v t="ekr.20040712101754.135"><vh>@test colorizer HTML2</vh>
<v t="ekr.20040712101754.136"><vh>HTML2</vh></v>
</v>
<v t="ekr.20040712101754.137"><vh>@test colorizer LaTex</vh>
<v t="ekr.20040712101754.138"><vh>LaTex</vh></v>
</v>
<v t="ekr.20040712101754.139"><vh>@test colorizer mixed</vh>
<v t="ekr.20040712101754.140"><vh>Mixed</vh></v>
</v>
<v t="ekr.20040712101754.141"><vh>@test colorizer PHP</vh>
<v t="ekr.20040712101754.142"><vh>PHP</vh></v>
</v>
<v t="ekr.20050618053006"><vh>@test colorizer plsql</vh>
<v t="ekr.20050618053006.1"><vh>plsql</vh></v>
</v>
<v t="ekr.20040712101754.143"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="ekr.20040712101754.144"><vh>python.xml</vh>
<v t="ekr.20040712101754.145"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="ekr.20040712101754.146"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="ekr.20040712101754.147"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="ekr.20040712101754.148"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="ekr.20040712101754.149"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="ekr.20040712101754.150"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="ekr.20040712101754.151"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="ekr.20040712101754.152"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="ekr.20040712101754.153"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.154"><vh>@test colorizer Python1</vh>
<v t="ekr.20040712101754.155"><vh>Python1</vh></v>
</v>
<v t="ekr.20040712101754.156"><vh>@test colorizer Python2</vh>
<v t="ekr.20040712101754.157"><vh>Python2</vh></v>
</v>
<v t="ekr.20040712101754.158"><vh>@test colorizer rapidq</vh>
<v t="ekr.20040712101754.159"><vh>rapidq</vh></v>
</v>
<v t="ekr.20040712101754.160"><vh>@test colorizer Rebol</vh>
<v t="ekr.20040712101754.161"><vh>Rebol</vh></v>
</v>
<v t="ekr.20040712101754.162"><vh>@test colorizer shell</vh>
<v t="ekr.20040712101754.163"><vh>shell</vh></v>
</v>
<v t="ekr.20040712101754.164"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="ekr.20040712101754.165"><vh>tex.xml</vh>
<v t="ekr.20040712101754.166"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="ekr.20040712101754.167"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040712101754.168"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20040712101754.169"><vh>wikiTest1</vh></v>
</v>
<v t="ekr.20040712101754.170"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20040712101754.171"><vh>wikiTest2</vh></v>
</v>
<v t="ekr.20040712101754.172"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20040712101754.173"><vh>wikiTest3</vh></v>
</v>
</v>
<v t="ekr.20050210093857"><vh>Dialog tests...</vh>
<v t="ekr.20050210085211"><vh>@test ctors for all dialogs</vh></v>
<v t="ekr.20050210092742"><vh>@test ctors for all panels</vh></v>
</v>
<v t="ekr.20040712101754.7"><vh>Import/Export tests...</vh>
<v t="ekr.20040712101754.8"><vh>@suite Import tests</vh></v>
<v t="ekr.20040712101754.9"><vh>@suite Export tests</vh></v>
<v t="ekr.20040712101754.10"><vh>importTests</vh>
<v t="ekr.20040712101754.11"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.12"><vh>importAtRoot</vh>
<v t="ekr.20040712101754.13"><vh>dialog</vh></v>
</v>
<v t="ekr.20040831095833"><vh>importDerivedFile</vh>
<v t="ekr.20040831095833.1"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.16"><vh>importNowebFiles</vh>
<v t="ekr.20040712101754.17"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.18"><vh>importFlattenedOutline</vh>
<v t="ekr.20040712101754.19"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.20"><vh>importCWEBFiles</vh>
<v t="ekr.20040712101754.21"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.22"><vh>removeSentinels</vh>
<v t="ekr.20040712101754.23"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.14"><vh>importAtFile</vh>
<v t="ekr.20040712101754.15"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040712101754.24"><vh>exportTests</vh>
<v t="ekr.20040712101754.25"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.26"><vh>exportHeadlines</vh>
<v t="ekr.20040712101754.27"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.28"><vh>flattenOutline</vh>
<v t="ekr.20040712101754.29"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.30"><vh>weave</vh>
<v t="ekr.20040712101754.31"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.32"><vh>outlineToNoweb</vh>
<v t="ekr.20040712101754.33"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.34"><vh>outlineToCWEB</vh>
<v t="ekr.20040712101754.35"><vh>dialog</vh></v>
</v>
</v>
</v>
<v t="ekr.20050112095306.1"><vh>leoAtFile.py tests...</vh>
<v t="ekr.20050105093136"><vh>@test atFile.remove</vh></v>
<v t="ekr.20050105093524"><vh>@test atFile.rename</vh></v>
<v t="ekr.20050105094311"><vh>@test atFile.replaceTargetFileIfDifferent (different)</vh></v>
<v t="ekr.20050105095743"><vh>@test atFile.replaceTargetFileIfDifferent (identical)</vh></v>
<v t="ekr.20050105100227"><vh>@test atFile.replaceTargetFileIfDifferent (no target file)</vh></v>
</v>
<v t="ekr.20050512083700"><vh>Marking tests...</vh>
<v t="ekr.20040802065214"><vh>@test changing headline marks descendent @thin nodes dirty</vh>
<v t="ekr.20040802065214.1"><vh>bogus</vh></v>
</v>
<v t="ekr.20050512083700.1"><vh>@test markChangedHeadlines</vh></v>
<v t="ekr.20050512083807"><vh>@test markChangedRoots</vh></v>
<v t="ekr.20050512083807.1"><vh>@test markAllAtFileNodesDirty</vh></v>
<v t="ekr.20050512083807.2"><vh>@test markAtFileNodesDirty</vh></v>
<v t="ekr.20050512083816"><vh>@test markClones</vh></v>
<v t="ekr.20050512083816"><vh>@test markClones</vh></v>
<v t="ekr.20050512083822"><vh>@test markHeadline</vh></v>
<v t="ekr.20050512083822.1"><vh>@test markSubheads</vh>
<v t="ekr.20050512084850.1"><vh>child 1</vh></v>
<v t="ekr.20050512084850.2"><vh>child 2</vh></v>
</v>
<v t="ekr.20050512083822.2"><vh>@test unmarkAll</vh></v>
</v>
<v t="ekr.20040712101754.174"><vh>Mini tests...</vh>
<v t="ekr.20040712101754.175"><vh>@test p.t == p.v.t</vh></v>
<v t="ekr.20040712101754.177"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20040712101754.178"><vh>File Conversion</vh>
<v t="ekr.20040712101754.179"><vh>moreHead</vh></v>
<v t="ekr.20040712101754.180"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20040712101754.181"><vh>inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
</v>
<v t="ekr.20040712101754.184"><vh>@test consistency of p.v.t.vnodeList &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040712101754.185"><vh>@test that cloned nodes actually share subtrees</vh></v>
</v>
<v t="ekr.20040712101754.36"><vh>Misc tests...</vh>
<v t="ekr.20050112095306"><vh>g.utils tests...</vh>
<v t="ekr.20050105084757.1"><vh>@test g.utils_remove</vh></v>
<v t="ekr.20050105091547"><vh>@test g.utils_rename</vh></v>
</v>
<v t="ekr.20050208135429"><vh>@test pre-definition of g in scripts</vh></v>
<v t="ekr.20040803091512"><vh>@test bogus tnodeList doesn't corrupt @thin nodes</vh></v>
<v t="ekr.20040917062206"><vh>@test g.cantImport returns None</vh></v>
</v>
<v t="ekr.20040716144017"><vh>Perfect Import tests</vh>
<v t="ekr.20040716071029.6"><vh>@test inserting a line: no trailing newline</vh>
<v t="ekr.20040716071856.1"><vh>-input</vh></v>
<v t="ekr.20040716081019"><vh>-input-after</vh></v>
<v t="ekr.20040716071856"><vh>-output-sent</vh></v>
<v t="ekr.20040716091245"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716084934"><vh>-i_lines</vh></v>
<v t="ekr.20040716084934.1"><vh>-j_lines</vh></v>
<v t="ekr.20040716081943"><vh>-result</vh></v>
</v>
<v t="ekr.20040716140926"><vh>@test replace one line</vh>
<v t="ekr.20040716140926.1"><vh>-input</vh></v>
<v t="ekr.20040716140926.2"><vh>-input-after</vh></v>
<v t="ekr.20040716140926.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716140926.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716140926.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716140926.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716140926.7"><vh>-result</vh></v>
</v>
<v t="ekr.20040716141621"><vh>@test replace multiple lines</vh>
<v t="ekr.20040716141621.1"><vh>-input</vh></v>
<v t="ekr.20040716141621.2"><vh>-input-after</vh></v>
<v t="ekr.20040716141621.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716141621.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716141621.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716141621.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716141621.7"><vh>-result</vh></v>
</v>
<v t="ekr.20040716142121"><vh>@test replace across sentinel blocks: Succeeds ONLY when ignoring sentinels</vh>
<v t="ekr.20040716142423"><vh>-input</vh>
<v t="ekr.20040716142423.1"><vh>Node 1</vh></v>
<v t="ekr.20040716142423.2"><vh>Node 2</vh></v>
</v>
<v t="ekr.20040716142121.2"><vh>-input-after</vh>
<v t="ekr.20040717071133"><vh>Node 1</vh></v>
<v t="ekr.20040717071133.1"><vh>Node 2</vh></v>
</v>
<v t="ekr.20040716142121.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716142121.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716142121.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716142121.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716142121.7"><vh>-result</vh></v>
</v>
</v>
<v t="ekr.20040712101754.187"><vh>Position tests...</vh>
<v t="ekr.20040712101754.99"><vh>@test c iters</vh>
<v t="ekr.20040712101754.100"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="ekr.20040712101754.101"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20040802071519"><vh>@test p.setBodyStringOrPane</vh>
<v t="ekr.20040802071519.1"><vh>child</vh></v>
</v>
<v t="ekr.20040712101754.188"><vh>@test p.iters and v.iters</vh>
<v t="ekr.20040712101754.189"><vh>child1</vh>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.192"><vh>c</vh></v>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.193"><vh>d</vh>
<v t="ekr.20040712101754.194"><vh>e</vh></v>
</v>
</v>
<v t="ekr.20040712101754.195"><vh>child2</vh></v>
<v t="ekr.20040712101754.196"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="ekr.20040712101754.197"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="ekr.20040712101754.198"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20040712101754.199"><vh>@test p.comparisons</vh></v>
<v t="ekr.20040712101754.200"><vh>@test that clones share subtrees</vh></v>
<v t="ekr.20040712101754.201"><vh>@test consistency of c.allNodes_iter() and p.ThreadNext()</vh></v>
<v t="ekr.20040712101754.202"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20040712101754.203"><vh>@test consistency of level</vh></v>
<v t="ekr.20040712101754.204"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20040712101754.205"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20040712101754.206"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20040712101754.207"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20040712101754.208"><vh>@test consistency of tnodeListAndParents</vh></v>
<v t="ekr.20040712101754.209"><vh>@test hasNextBack</vh></v>
<v t="ekr.20040712101754.210"><vh>@test hasParentChild</vh></v>
<v t="ekr.20040712101754.211"><vh>@test hasThreadNextBack</vh></v>
<v t="ekr.20040712101754.212"><vh>@test vnode list</vh></v>
<v t="ekr.20040722055040"><vh>@test isAncestorOf</vh></v>
<v t="ekr.20041013062906"><vh>@test onHyperLinkControlClick</vh></v>
</v>
<v t="ekr.20040723062819"><vh>Syntax Checks...</vh>
<v t="EKR.20040612095237"><vh>@test checkPythonCode (bad syntax)</vh>
<v t="EKR.20040610192622.1"><vh>Check Syntax data (bad)</vh></v>
</v>
<v t="ekr.20040715154319"><vh>@test checkPythonCode (bad tabnanny)</vh>
<v t="EKR.20040610194209.1"><vh>TabNanny data (bad)</vh></v>
</v>
<v t="ekr.20040712101813"><vh>@xx test checkAllPythonCode</vh></v>
</v>
<v t="ekr.20050216060307"><vh>Tangle/Untangle tests...</vh>
<v t="ekr.20050216060736"><vh>@test tangle command</vh>
<v t="ekr.20050216060736.1"><vh>Tangle Root</vh>
<v t="ekr.20050216060736.2"><vh>&lt;&lt; first child &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20050216062636"><vh>@test untangle command</vh>
<v t="ekr.20050216062636.4"><vh>Tangle Root</vh>
<v t="ekr.20050216062636.5"><vh>&lt;&lt; first child &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20050105080048"><vh>Test ivars...</vh>
<v t="ekr.20050105080048.1"><vh>@test official frame ivars</vh></v>
<v t="ekr.20050105082500"><vh>@test official commander ivars</vh></v>
<v t="ekr.20050105084757"><vh>@test official g.app directories</vh></v>
<v t="ekr.20050105090632"><vh>@test official g.app ivars</vh></v>
</v>
<v t="ekr.20050203084930"><vh>Test settings...</vh>
<v t="ekr.20050203001146"><vh>@test local settings (c.page_width)</vh></v>
<v t="ekr.20050203084930.1"><vh>@test global settings</vh></v>
</v>
<v t="ekr.20040712101754.102"><vh>Tests of @file nodes...</vh>
<v t="ekr.20040712101754.103"><vh>@test @file no newline</vh>
<v t="ekr.20040712101754.104"><vh>#@file</vh></v>
<v t="ekr.20040712101754.105"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.106"><vh>@test @file one newline</vh>
<v t="ekr.20040712101754.107"><vh>#@file</vh></v>
<v t="ekr.20040712101754.108"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.109"><vh>@test @file two newlines</vh>
<v t="ekr.20040712101754.110"><vh>#@file</vh></v>
<v t="ekr.20040712101754.111"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.12"><vh>@test @thin</vh>
<v t="ekr.20040707141957.13"><vh>#@thin</vh></v>
<v t="ekr.20040707141957.14"><vh>Output</vh></v>
</v>
<v t="ekr.20041020100733"><vh>@test @nosent</vh>
<v t="ekr.20041020100733.1"><vh>#@nosent</vh>
<v t="ekr.20041020100918"><vh>&lt;&lt; section &gt;&gt;</vh></v>
<v t="ekr.20041020100918.1"><vh>unnamed node</vh></v>
</v>
<v t="ekr.20041020100733.2"><vh>Output</vh></v>
</v>
<v t="ekr.20041021062800"><vh>@test @noref</vh>
<v t="ekr.20041021063220"><vh>#@noref</vh>
<v t="ekr.20041021063220.1"><vh>&lt;&lt; section &gt;&gt;</vh></v>
<v t="ekr.20041021063220.2"><vh>unnamed node</vh></v>
</v>
<v t="ekr.20041021063220.3"><vh>Output</vh></v>
</v>
<v t="ekr.20041021065844"><vh>@test @asis</vh>
<v t="ekr.20041021065903"><vh>#@asis</vh>
<v t="ekr.20041021065903.1"><vh>&lt;&lt; section &gt;&gt;</vh></v>
<v t="ekr.20041021065903.2"><vh>unnamed node</vh></v>
</v>
<v t="ekr.20041021065844.1"><vh>Output</vh></v>
</v>
<v t="ekr.20041004093917"><vh>@test read from string</vh>
<v t="ekr.20041004093917.1"><vh>Input</vh></v>
<v t="ekr.20041021071036"><vh>Result</vh></v>
<v t="ekr.20041004100940"><vh>Expected</vh>
<v t="ekr.20041001111106"><vh>@thin c:\prog\test\at-file-thin-test2.txt</vh>
<v t="ekr.20041001111106.1"><vh>node 1</vh>
<v t="ekr.20041001111106.2"><vh>&lt;&lt; node 1 ref &gt;&gt;</vh>
<v t="ekr.20041001111106.3"><vh>child node 1</vh></v>
<v t="ekr.20041001111106.4"><vh>child node 2</vh></v>
</v>
</v>
<v t="ekr.20041001111106.5"><vh>&lt;&lt; ref &gt;&gt;</vh>
<v t="ekr.20041001111106.6"><vh>organizer node</vh>
<v t="ekr.20041001111106.7"><vh>ref child 1</vh></v>
<v t="ekr.20041001111106.8"><vh>ref child 2</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20050408084135"><vh>Undo/Redo Tests</vh>
<v t="ekr.20040712101754.37"><vh>@suite Edit body tests</vh>
<v t="ekr.20040712101754.38"><vh>editBodyTests</vh>
<v t="ekr.20050518070540"><vh>extract test2</vh>
<v t="ekr.20050518070540.1"><vh>before</vh></v>
<v t="ekr.20050518070545"><vh>after</vh></v>
<v t="ekr.20050518070540.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518071251"><vh>extractSection test2</vh>
<v t="ekr.20050518071251.1"><vh>before</vh></v>
<v t="ekr.20050518071258"><vh>after</vh></v>
<v t="ekr.20050518071251.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050417202713"><vh>addComments</vh>
<v t="ekr.20050417202713.1"><vh>before</vh></v>
<v t="ekr.20050417202713.2"><vh>after</vh></v>
<v t="ekr.20050417202713.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417204940"><vh>convertAllBlanks</vh>
<v t="ekr.20050417204940.1"><vh>before</vh></v>
<v t="ekr.20050417204940.2"><vh>after</vh></v>
<v t="ekr.20050417204940.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417205012"><vh>convertAllTabs</vh>
<v t="ekr.20050417205012.1"><vh>before</vh></v>
<v t="ekr.20050417205012.2"><vh>after</vh></v>
<v t="ekr.20050417205012.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114"><vh>convertBlanks</vh>
<v t="ekr.20050417203310"><vh>before</vh></v>
<v t="ekr.20050417203310.1"><vh>after</vh></v>
<v t="ekr.20050417203336"><vh>selection</vh></v>
</v>
<v t="ekr.20050417203114.1"><vh>convertTabs</vh>
<v t="ekr.20050417204834"><vh>before</vh></v>
<v t="ekr.20050417204830"><vh>after</vh></v>
<v t="ekr.20050417204901"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.49"><vh>dedentBody</vh>
<v t="ekr.20040712101754.50"><vh>before</vh></v>
<v t="ekr.20040712101754.51"><vh>after</vh></v>
<v t="ekr.20040712101754.52"><vh>selection</vh></v>
</v>
<v t="ekr.20050417202817"><vh>deleteComments</vh>
<v t="ekr.20050417202817.1"><vh>before</vh></v>
<v t="ekr.20050417202817.2"><vh>after</vh></v>
<v t="ekr.20050417202817.3"><vh>selection</vh></v>
</v>
<v t="ekr.20050417201845"><vh>extract test1</vh>
<v t="ekr.20050417201845.1"><vh>before</vh></v>
<v t="ekr.20050417201845.2"><vh>after</vh>
<v t="ekr.20050417201845.3"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20050417201845.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050518070927"><vh>extractSection test1</vh>
<v t="ekr.20050518070927.1"><vh>before</vh></v>
<v t="ekr.20050518070927.2"><vh>after</vh>
<v t="ekr.20050518070927.3"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20050518070927.4"><vh>selection</vh></v>
</v>
<v t="ekr.20050417202052"><vh>extractSectionNames</vh>
<v t="ekr.20050417202052.1"><vh>before</vh></v>
<v t="ekr.20050417202112"><vh>after</vh>
<v t="ekr.20050417202112.1"><vh>&lt;&lt; section 1&gt;&gt;</vh></v>
<v t="ekr.20050417202112.2"><vh>&lt;&lt; section 2&gt;&gt;</vh></v>
<v t="ekr.20050417202112.3"><vh>&lt;&lt; section 3 &gt;&gt;</vh></v>
</v>
<v t="ekr.20050417202243"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.45"><vh>indentBody</vh>
<v t="ekr.20040712101754.46"><vh>before</vh></v>
<v t="ekr.20040712101754.47"><vh>after</vh></v>
<v t="ekr.20040712101754.48"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.39"><vh>tempNode</vh></v>
</v>
</v>
<v t="ekr.20050417102057"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20050417102114"><vh>@test noTrailingNewline</vh>
<v t="ekr.20050417104821"><vh>data</vh>
<v t="ekr.20050417124704"><vh>tempNode</vh></v>
<v t="ekr.20050417102114.1"><vh>before</vh></v>
<v t="ekr.20050417102114.2"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417111144"><vh>@test trailingNewline</vh>
<v t="ekr.20050417111144.1"><vh>data</vh>
<v t="ekr.20050417111240"><vh>tempNode</vh></v>
<v t="ekr.20050417111144.2"><vh>before</vh></v>
<v t="ekr.20050417111144.3"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417113549"><vh>@test mixedLineLengths</vh>
<v t="ekr.20050417113910"><vh>data</vh>
<v t="ekr.20050417113921"><vh>tempNode</vh></v>
<v t="ekr.20050417113910.1"><vh>before</vh></v>
<v t="ekr.20050417113910.2"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417114153"><vh>@test mixedLinesWithLeadingWS</vh>
<v t="ekr.20050417114221"><vh>data</vh>
<v t="ekr.20050417114221.1"><vh>tempNode</vh></v>
<v t="ekr.20050417114221.2"><vh>before</vh></v>
<v t="ekr.20050417114221.3"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417114836"><vh>@test noChangeRequired</vh>
<v t="ekr.20050417095124.16"><vh>data</vh>
<v t="ekr.20050417114914"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.17"><vh>before</vh></v>
<v t="ekr.20050417095124.18"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.11"><vh>@test honorLeadingWS</vh>
<v t="ekr.20050417095124.19"><vh>data</vh>
<v t="ekr.20050417115111"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.20"><vh>before</vh></v>
<v t="ekr.20050417095124.21"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.12"><vh>@test honorLeadingWSVar1</vh>
<v t="ekr.20050417095124.22"><vh>data</vh>
<v t="ekr.20050417115257"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.23"><vh>before</vh></v>
<v t="ekr.20050417095124.24"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.13"><vh>@test simpleHangingIndent</vh>
<v t="ekr.20050417095124.25"><vh>data</vh>
<v t="ekr.20050417115414"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.26"><vh>before</vh></v>
<v t="ekr.20050417095124.27"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.14"><vh>@test testSimpleHangingIndentVar1</vh>
<v t="ekr.20050417095124.28"><vh>data</vh>
<v t="ekr.20050417115559"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.29"><vh>before</vh></v>
<v t="ekr.20050417095124.30"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417095020.15"><vh>@test simpleHangingIndentVar2</vh>
<v t="ekr.20050417095124.31"><vh>data</vh>
<v t="ekr.20050417115709"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.32"><vh>before</vh></v>
<v t="ekr.20050417095124.33"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417120312.1"><vh>@test multiParagraphTest</vh>
<v t="ekr.20050417095124.34"><vh>data</vh>
<v t="ekr.20050417120312.2"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.35"><vh>before</vh></v>
<v t="ekr.20050417095124.36"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417121448"><vh>@test multiParagraphWithListTest</vh>
<v t="ekr.20050417095124.37"><vh>data</vh>
<v t="ekr.20050417121448.1"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.38"><vh>before</vh></v>
<v t="ekr.20050417095124.39"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417121942"><vh>@test leadingWSOnEmptyLinesTest</vh>
<v t="ekr.20050417095124.43"><vh>data</vh>
<v t="ekr.20050417121942.1"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.44"><vh>before</vh></v>
<v t="ekr.20050417095124.45"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20050417122215.1"><vh>@test directiveBreaksParagraphTest</vh>
<v t="ekr.20050417095124.40"><vh>data</vh>
<v t="ekr.20050417122215.2"><vh>tempNode</vh></v>
<v t="ekr.20050417095124.41"><vh>before</vh></v>
<v t="ekr.20050417095124.42"><vh>after</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20050208051418"><vh>Unicode tests...</vh>
<v t="ekr.20050206090416"><vh>@test open non-existent non-ascii directory</vh></v>
<v t="ekr.20050208051418.1"><vh>@test can't open message in g.openWithFileName</vh></v>
<v t="ekr.20050208051854"><vh>@test atFile.printError</vh></v>
<v t="ekr.20050206201145"><vh>@test % operator with unicode</vh></v>
<v t="ekr.20050208073718"><vh>@test open file with chinese characters in path &amp; file</vh></v>
<v t="ekr.20050208111037"><vh>@test failure to convert unicode characters to ascii</vh></v>
<v t="ekr.20050208104202"><vh>@test of round-tripping toUnicode &amp; toEncodedString</vh></v>
</v>
</v>
</v>
<v t="ekr.20050120095423" annotate="7d71002e"><vh>Unit tests for plugins...</vh>
<v t="ekr.20050120095423.21"><vh>print all loaded plugins</vh></v>
<v t="ekr.20050120095423.1"><vh>Notes</vh>
<v t="ekr.20050120095423.2"><vh>spellpyx</vh></v>
<v t="ekr.20050120095423.3"><vh>table</vh></v>
<v t="ekr.20050120095423.4"><vh>xsltWithNodes</vh></v>
<v t="ekr.20050120095423.5"><vh>List of all calls to doHook</vh></v>
</v>
<v t="ekr.20050218015346"><vh>@suite run all plugin test routines</vh>
<v t="ekr.20050218015346.11"><vh>&lt;&lt; class testRoutineTestCase &gt;&gt;</vh>
<v t="ekr.20050218015346.12"><vh>__init__</vh></v>
<v t="ekr.20050218015346.13"><vh> fail</vh></v>
<v t="ekr.20050218015346.14"><vh>setUp</vh></v>
<v t="ekr.20050218015346.15"><vh>tearDown</vh></v>
<v t="ekr.20050218015346.16"><vh>runTest</vh></v>
<v t="ekr.20050218015346.17"><vh>shortDescription</vh></v>
</v>
<v t="ekr.20050218015346.18"><vh>addTestRoutinesInPluginToSuite</vh></v>
<v t="ekr.20050218015346.19"><vh>findTestsInModule</vh>
<v t="ekr.20050218015346.20"><vh>&lt;&lt; print classes, methods &amp; functions &gt;&gt;</vh></v>
</v>
<v t="ekr.20050218015346.21"><vh>getAllPlugins</vh></v>
<v t="ekr.20050218015346.22"><vh>removeLeadingWs</vh></v>
</v>
<v t="ekr.20050120095423.11"><vh>@suite plugins tests</vh>
<v t="ekr.20050120095423.12"><vh>makePluginsTestSuite</vh></v>
<v t="ekr.20050120095423.13"><vh>class pluginTestCase</vh>
<v t="ekr.20050120095423.14"><vh>__init__</vh></v>
<v t="ekr.20050120095423.15"><vh>fail</vh></v>
<v t="ekr.20050120095423.16"><vh>runTest</vh></v>
<v t="ekr.20050120095423.17"><vh>setUp</vh></v>
<v t="ekr.20050120095423.18"><vh>shortDescription</vh></v>
<v t="ekr.20050120095423.19"><vh>tearDown</vh></v>
</v>
<v t="ekr.20050120095423.20"><vh>class lastTestCase</vh></v>
</v>
<v t="ekr.20050120095423.6"><vh>@suite test syntax of all plugins</vh>
<v t="ekr.20050120095423.7"><vh>class parseFileTestCase</vh>
<v t="ekr.20050120095423.8"><vh>__init__</vh></v>
<v t="ekr.20050120095423.9"><vh>runTest</vh></v>
<v t="ekr.20050120095423.10"><vh>shortDescription</vh></v>
</v>
</v>
</v>
<v t="ekr.20051017093427"><vh>Test of remove-blank-lines</vh></v>
</vnodes>
<tnodes>
<t tx="EKR.20040424065452">p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
lines1 = f1.readlines()
lines2 = f2.readlines()
f1.close() ; f2.close()

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
text1 = f1.read()
text2 = f2.read()
f1.close() ; f2.close()

cr1 = text1.count('\r')
cr2 = text2.count('\r')

print '-'*20
print "lines ",len(lines1),len(lines2)
print "chars ",len(text1),len(text2)
print "non-cr",len(text1)-cr1,len(text2)-cr2
print "cr    ",cr1,cr2</t>
<t tx="EKR.20040424091411">p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
g.es("equal (raw mode)",f1.read()==f2.read())
f1.close() ; f2.close()

f1 = open(p1) ; f2 = open(p2)
g.es("equal (text mode)",f1.read()==f2.read())
f1.close() ; f2.close()</t>
<t tx="EKR.20040427092657">@ignore

root line 1

@others

root after at-others

&lt;&lt; ref &gt;&gt;
</t>
<t tx="EKR.20040427092657.1">node 1 line 1

&lt;&lt; node 1 ref &gt;&gt;

node 1 last line</t>
<t tx="EKR.20040427092657.2">ref line 1

@others</t>
<t tx="EKR.20040428145741">node 1 ref line 1

@others</t>
<t tx="EKR.20040428145741.1"></t>
<t tx="EKR.20040428145741.2"></t>
<t tx="EKR.20040428145826"></t>
<t tx="EKR.20040428145826.1"></t>
<t tx="EKR.20040428150018">text of organizer node</t>
<t tx="EKR.20040430162649.12">@ignore</t>
<t tx="EKR.20040430162649.13">@language perlpod
@path c:\prog\test</t>
<t tx="EKR.20040430162649.14">@root perlpod.txt
@ Multi-line
doc part
&lt;&lt;ref&gt;&gt;</t>
<t tx="EKR.20040430162649.15">@ doc part2
@c
code line1
code line2
@ more doc part</t>
<t tx="EKR.20040430162649.16">@comment REM_</t>
<t tx="EKR.20040430162649.17">test 6</t>
<t tx="EKR.20040430162649.20">@ atFile.directiveKind is return miscDirective on _any_ line that starts with @</t>
<t tx="EKR.20040430162649.21">@ignore

line 1
@line 2
    @line 3
line 4</t>
<t tx="EKR.20040430162649.22">@language plain
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
    
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
     a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="EKR.20040430162649.23">@ignore</t>
<t tx="EKR.20040430162649.24">enabling: *
Exception in Tkinter callback
Traceback (most recent call last):
  File "c:\python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "leoFrame.py", line 1368, in OnTangle
    self.commands.tangleCommands.tangle()
  File "leoTangle.py", line 507, in tangle
    self.tangleTree(v,report_errors)
  File "leoTangle.py", line 644, in tangleTree
    self.tanglePass1(v) # sets self.v
  File "leoTangle.py", line 589, in tanglePass1
    self.skip_body(v)
  File "leoTangle.py", line 1062, in skip_body
    self.st_enter_root_name(old_root_name,code,doc)
  File "leoTangle.py", line 2040, in st_enter_root_name
    assert(code)
AssertionError
</t>
<t tx="EKR.20040430162649.25">@root a.txt
@ 

@root a.txt 
some text 
@ </t>
<t tx="EKR.20040504083716"># EKR: I don't remember the status of this.

@language python

import shutil

testing = True
sourcedir=r"c:/prog/test/perfectImport"
targetdir=r"c:/prog/test/perfectImport/leo"
s1 = g.os_path_join(sourcedir,"leoAtFile.py")
t1 = g.os_path_join(targetdir,"leoAtFile.py")
files = [(s1,t1)]

@others

print ; print '-' * 20
sync(files) # push or pull, depending on date.
</t>
<t tx="EKR.20040504083716.39">def sync(files):
    
    """Do a pull or a push, depending on the date of the files."""
    
    none, push, pull = 'None', 'push', 'pull'
    mu = g.mulderUpdateAlgorithm()

    for sourcefilename, targetfilename in files:
        &lt;&lt; compute sourcetime and targettime &gt;&gt;
        &lt;&lt; compute operation &gt;&gt;
        if operation == push:
            if testing: print push, sourcefilename, targetfilename
            strippedLines = mu.removeSentinelsFromFile(sourcefilename)
            mu.write_if_changed(strippedLines,sourcefilename,targetfilename)
            mu.copy_time(sourcefilename,targetfilename)
        elif operation == pull:
            if testing: print pull, sourcefilename, targetfilename
            if sourcetime:
                mu.propagateDiffsToSentinelsFile(sourcefilename,targetfilename)
                mu.copy_time(targetfilename,sourcefilename)
            else:
                shutil.copy2(targetfilename,sourcefilename)</t>
<t tx="EKR.20040504153320">sourcetime = targettime = None

if g.os_path_exists(sourcefilename):
    sourcetime = g.os_path_getmtime(sourcefilename)

if g.os_path_exists(targetfilename):
    targettime = g.os_path_getmtime(targetfilename)</t>
<t tx="EKR.20040504153320.1">operation = None
if sourcetime:
    if targettime:
        if sourcetime &gt; targettime:
            operation = push
        elif sourcetime &lt; targettime:
            operation = pull
    else:
        operation = push
elif targettime:
    operation = pull</t>
<t tx="EKR.20040517074600.8">nodes = 0 ; lines = 0

c.clearAllVisited()
for p in c.allNodes_iter():
    if not p.v.t.isVisited():
        p.v.t.setVisited()
        nodes += 1
        lines += len(g.splitLines(p.bodyString()))
    
pages = ((nodes * 10) + lines) / 50
s = "%d nodes,  %d lines, %d pages" % (nodes,lines,pages)
print s ; g.es(s)</t>
<t tx="EKR.20040517074600.9"></t>
<t tx="EKR.20040517074600.10">config = g.app.config
body = c.frame.body.bodyCtrl

font = config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        tag = "body")
        
print font
print body

# body.configure(font=font)</t>
<t tx="EKR.20040517074600.11">import tkFont

@others

# Body pane.
fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
print "body:",fn,name,size,slant,weight

if 0:

    # Log pane.
    fn = c.frame.log.getFontConfig()
    font = tkFont.Font(font=fn)
    name,size,slant,weight = getFontSettings(font)
    g.es("log:" + name + "," + `size` + "," + slant + "," + weight)
    
    # Tree pane.
    font = c.frame.tree.getFont()
    name,size,slant,weight = getFontSettings(font)
    g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="EKR.20040517074600.12">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="EKR.20040517074600.13">font = g.app.config.defaultFont

print font.cget("family"), font.cget("weight")</t>
<t tx="EKR.20040520104329"></t>
<t tx="EKR.20040523112430"></t>
<t tx="EKR.20040523112430.1"></t>
<t tx="EKR.20040523112430.2"></t>
<t tx="EKR.20040523112430.3"></t>
<t tx="EKR.20040523112430.4"></t>
<t tx="EKR.20040523112430.5"></t>
<t tx="EKR.20040523112430.6"></t>
<t tx="EKR.20040523112430.7"></t>
<t tx="EKR.20040523112430.8"></t>
<t tx="EKR.20040524050419">line 1
@others
&lt;&lt; defined in grandchild &gt;&gt;
last line</t>
<t tx="EKR.20040524050419.1">Organizer line</t>
<t tx="EKR.20040524050419.2">grandChild line</t>
<t tx="EKR.20040524050438"></t>
<t tx="EKR.20040525083635">@others</t>
<t tx="EKR.20040525083635.1"></t>
<t tx="EKR.20040526094831">def redoBletch(self):
    g.trace()
    
def undoBletch(self):
    g.trace()
    
u = c.undoer

if 0:
    # bad functions
    u.registerUndoHandlers("Bletch","abc","xyz")
else:
    u.registerUndoHandlers("Bletch",undoBletch,redoBletch)
    
# "Execute" the Bletch command :-)  The Edit command should contain "Undo Bletch"
u.setUndoParams("Bletch",p)

# Selecting "Undo Bletch" will enable "Redo Bletch", etc.</t>
<t tx="EKR.20040526193608">import binascii
import pickle

d = { "a":True }

print '-' * 40

s = pickle.dumps(d,bin=True)
s2 = binascii.hexlify(s)
print `s`,s2

s3 = binascii.unhexlify(s2)
d2 = cPickle.loads(s3)

print `d2`
print d == d2, d is d2</t>
<t tx="EKR.20040526200017">d = { "a":True }

if 1:
    # Warning: executing this in the a2 code base will cause any save operation to fail.
    p.v.unknownAttributes = { "myPlugin" : d }
    
print repr(p.v.unknownAttributes)</t>
<t tx="EKR.20040531110157">@ignore</t>
<t tx="EKR.20040602101648">import leoPlugins

def onEnd (tag,keys):
    print "onEnd",tag,keys
    
count = 0
    
def onIdle (tag,keys):
    global count ; count += 1
    if count % 10 == 0:
        print "onIdle",count,keys.get("c")

leoPlugins.registerHandler("end1", onEnd)
print "onEnd registered as end1 hook"

leoPlugins.registerHandler("idle", onIdle)
print "onIdle registered as idle hook"</t>
<t tx="EKR.20040603064545">for p in c.all_positions_iter():
    print p.v.t.fileIndex</t>
<t tx="EKR.20040603174633">print c.frame.bodyCtrl.focus()</t>
<t tx="EKR.20040604082113">@tabwidth -4
@language plain

    
    a   b   c
a   b   c   d
aa  b   c   d
aaa b   c   d
end</t>
<t tx="EKR.20040604170105">import os

print os.getcwd()
name = g.os_path_join("test","removeSentTest.txt")
c.importCommands.removeSentinelsCommand(name)</t>
<t tx="EKR.20040605200750">@ignore # Suppress Check Python Code warnings.

string.join

__add__

'a'.__add__


def test(a,b): pass

v.copyTree(self,root)</t>
<t tx="EKR.20040606204316">@ignore</t>
<t tx="EKR.20040606204316.1"></t>
<t tx="EKR.20040608095146">@language python
@tabwidth -4</t>
<t tx="EKR.20040608095146.1">@ignore
@language html

&lt;!--- Get all records from the database that match this users credentials ---&gt;
&lt;cfquery name="qLoginVerify" datasource="xxxx"&gt;
SELECT user_name, user_pass, course_dir
FROM login
WHERE user_name = '#user_name#'
AND user_pass = '#user_pass#'
AND course_dir = '#course_dir#'
&lt;/cfquery&gt;

&lt;cfif qLoginVerify.RecordCount&gt;
&lt;!--- This user has logged in correctly; 
change the value of the session.allowin value ---&gt;
&lt;cfset session.allowin = session.directoryshort&gt;
&lt;/cfif&gt;

&lt;!--- now redirect to "index.cfm", which will go to login if problem ---&gt;

&lt;cflocation url="#session.location#"&gt;
</t>
<t tx="EKR.20040610092248">@killcolor
@language plain

Note: Previously, one could crash Leo by pasting a large text into a headline.  Leo now truncates that text, and furthermore Leo no longer makes all headline text into one gigantic line.  Therefore, we don't have to test Tk's ability to handle super-long lines.

The test:  Copy the following and paste it into a headline.  Leo should give 2 truncation messages:

- Truncating headline to one line.
- Truncating headline to 250 characters.

About a year ago I found the website at www.literateprogamming.com and was immediately convinced that the basic idea of Literate Programming is an important breakthrough. At the time I was working on a contract trying to decipher a true masterpiece of over-engineering, and if at any time during the construction of this masterpiece the perpetrators had been required to explain themselves in English, my client would have saved millions of dollars.

I never did try CWEB or NOWEB though, because on the literate programming site I read about a tool named Leo that combined outlines with Literate Programming techniques. Since Ive always found outlining tools very useful I downloaded and tried this. I found that using this tool completely changed my programming practice and brought out all of the power inherent in the original Literate Programming idea as I understood it.</t>
<t tx="EKR.20040610192622.1">import string

string.join(a,b] # A syntax error</t>
<t tx="EKR.20040610194209.1">@tabwidth 4

# Tabnanny _only_ checks errors involving tabs.
# It does _not_ check other indentation errors.
# It does _not_ check syntax.

if 1: # Essential, so we don't create a syntax error.
    a = 5
	b = 6 #Contains tab.
    c = 3</t>
<t tx="EKR.20040611083703"># This kind of code is used in the prototypes of new commands.

from __future__ import generators

@others

lines = "a\nb\nc\nd"

if 1: # Both work
    readline = g.readLinesGenerator(lines).next
else:
    readline = g.readLinesClass(lines).next

print '-' * 20

if 1: # Both work
    for s in g.readLinesGenerator(lines):
        print s,
else:
    while 1:
        s = readline()
        if s: print s,
        else: break
    
print ; print '-' * 20</t>
<t tx="EKR.20040612095237">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import unittest

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False,suppressErrors=True)

assert result=="error", "checkPythonCode returns: %s" % result
</t>
<t tx="EKR.20040612150543"># Test
@others
# Last</t>
<t tx="EKR.20040612215136">a = 1
print "hello"
c = b
</t>
<t tx="EKR.20040613162717">path = g.os_path_join(g.app.loadDir,"leo.py")

try:
    f = open(path,"rb")
    s = f.read()
    f.close()
    
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
        
    m = "cr %d, nl %d %s" % (cr,nl,path)
    print m ; g.es(m)

except IOError:
    print "can not open",path</t>
<t tx="EKR.20040615070332"># "LPT1:", "PRN:" and "PRN" all freeze

s = 'stuff\n'
port = 'USB002'

try:
    f = file(port,'w')
    f.write(s)
    f.flush()
    f.close()
    print "done"
except IOError:
    print "Can not open",port</t>
<t tx="EKR.20040619133116"></t>
<t tx="EKR.20040622074004">@ignore</t>
<t tx="EKR.20040622074004.1"></t>
<t tx="EKR.20040622074004.2">node b, line 1 (changed 12)</t>
<t tx="EKR.20040622074004.3"></t>
<t tx="EKR.20040622102618"></t>
<t tx="EKR.20040625110032">@ignore

@others</t>
<t tx="EKR.20040625110032.1"></t>
<t tx="EKR.20040625110032.2"># @language html

@comment &lt;!-- --&gt;</t>
<t tx="EKR.20040625110032.3"></t>
<t tx="EKR.20040626212434"></t>
<t tx="EKR.20040626212434.1">import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

mincolor,maxcolor=125,225

for n in xrange(5000):
    x,y = rand(0,900),rand(0,500)
    w = rand(1,10) ; h = w * r.uniform(0.5,1.5)
    color = "#%02x%02x%02x" % (rand(0,maxcolor/2),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    kind = rand(1,3)
    sign = rand(-1,1) # rand(0,2)-1
    if kind == 1:
        canvas.create_rectangle(x,y,x+w,y+h,fill=color,width=0)
    elif kind == 2:
        canvas.create_oval(x,y,x+w,y+h,fill=color,width=0)
    else:
        canvas.create_line(x,y,x+sign*5*w,y+5*h,fill=color)
    if 0: # Redrawing slows things down a lot.
        if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626212434.2">import Tkinter as Tk
import random as r

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top, height = "5i", width = "9i")
canvas.pack() ; top.update()
rand = r.randint

x,y = 10,10
mincolor,maxcolor=125,225

for n in xrange(2000):
    x2,y2 = rand(0,900),rand(0,500)
    color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    width = "%fm" % r.uniform(0.1,0.6)
    canvas.create_line(x,y,x2,y2,fill=color,width=width)
    extent = rand(180,270)
    canvas.create_arc(x,y,x2,y2,outline=color,width=width,style="arc",extent=extent)
    x,y = x2,y2
    # if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626213007">import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Paul Klee")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

# Paul Klee
mincolor,maxcolor=125,225
xmax,ymax = 800,400
stipples = [None,"gray75"] # "gray12","gray25","gray50",]
h=w=90
for x in xrange(10,xmax,w):
    for y in xrange(10,ymax,h):
        color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
        range = h/6
        stipple = stipples[rand(0,len(stipples)-1)]
        dx = r.uniform(0.0,range) - range/2
        dy = r.uniform(0.0,range) - range/2
        canvas.create_rectangle(x+dx,y+dy,x+dx+w,y+dy+h,fill=color,width=0,stipple=stipple)</t>
<t tx="EKR.20040627100615">@ignore # Suppress Check Python Code warnings.

g.app.config.redirect_execute_script_output_to_log_pane = False

# Syntax error
print '
print g.app.config.redirect_execute_script_output_to_log_pane</t>
<t tx="EKR.20040627103732">@ignore</t>
<t tx="EKR.20040627103801"></t>
<t tx="EKR.20040627103902"></t>
<t tx="EKR.20040627121836">next = p.next()
t = next.v.t
v = next.v

for s in t.__dict__:
    print s,getattr(t,s)</t>
<t tx="EKR.20040627150213">import Tkinter as Tk
import random as r ; rand = r.randint

mincolor,maxcolor=125,225
xmax,ymax = 300,300
h=w=1
i = r.uniform(2.0,4.0)
j = r.uniform(-5.0,5.0)
power = r.uniform(1.1,1.2)
    #(1.5,1.7)

top = Tk.Toplevel(None)
top.title("Complex function: (%f,%f)*(x,y)**%f" % (i,j,power))
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

@others

for n in xrange(1):
    i += 0.5
    j += 0.5
    power += 0.01
    # print "i,j,power:",i,j,power
    c = complex(i,j)
    for format,m in (
        #("#%02x%02x%02x",256),
        #("#%03x%03x%03x",256*8),
        ("#%04x%04x%04x",256*256),
    ):
        for x in xrange(0,xmax,1):
            for y in xrange(0,ymax,1):
                n = complex(x,y)
                z = pow(c*n,power)
                n1 = int(z.real*m) ; n2 = int(z.imag*m)
                color = format % (n1%m,n2%m,abs(n1-n2)%m)
                # canvas.create_rectangle(w*x,h*y,w*x+w,h*y+h,fill=color,width=0)
                canvas.create_line(x,y,x+1,y+1,fill=color,width=1)
        top.update()
print "done"</t>
<t tx="bwmulder.20050108100437.1">@killcolor

Running unit tests from test.leo is easy, provided you have enabled the
Scripting plugin. When this plugin is enabled Leo will create a blue 'script
button' in the icon bar called 'unit test'. 
 
- To run all unit tests, select the node in test.leo called 'Unit tests...',
then click the 'unit test' button. 
 
- To run a single test, select an @test node and click the 'unit test' button. 
 
- To run a suite of tests, select an @suite node and click the 'unit test' button. 
 
- To run any other collection of tests, create an outline containing those @test
or @suite nodes, select the root of that tree and click the 'unit test' button.

That's all. See the docstring the Scripting plugin for more details about script
buttons. You can see this docstring using the plugin_manager plugin if you have
it installed. 
 
Several nodes in the tree @thin ../src/leoTest.py (in test.leo) contain support
code for @test, @suite, etc. so if you want all the gory details you can read
the code. It's not complicated: Leo creates UnitTest classes automatically whose
run method is the body of the @suite or @test node.</t>
<t tx="ekr.20040302091705">class position:
    def __init__(self):
        self.v = "a"
    def move(self):
        self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040309111054">import leoNodes

position = leoNodes.position

@others

current = pos = c.currentPosition()
child1 = current.firstChild()
child2 = child1.firstChild()

if 0:
    print '-'*10, "parents"
    for p in child2.parents_iter(): print p
if 0:
    print '-'*10, "subtree"
    for p in pos.subtree_iter(): print p
if 0:
    print '-'*10, "children"
    for p in child1.children_iter(): print p
if 0:
    print '-'*10, "siblings"
    for p in pos.siblings_iter(): print p
if 1:
    print '-'*10, "all nodes"
    for p in pos.allNodes_iter():
        print p.isCloned(),p
</t>
<t tx="ekr.20040309111102"></t>
<t tx="ekr.20040309111102.1"></t>
<t tx="ekr.20040309111102.2"></t>
<t tx="ekr.20040309111102.3"></t>
<t tx="ekr.20040309111102.4"></t>
<t tx="ekr.20040309111102.5"></t>
<t tx="ekr.20040309111102.6"></t>
<t tx="ekr.20040309111102.7"></t>
<t tx="ekr.20040309111102.8"></t>
<t tx="ekr.20040309111102.9"></t>
<t tx="ekr.20040309111102.10"></t>
<t tx="ekr.20040309111232"></t>
<t tx="ekr.20040311090054">for p in c.allNodes_iter():
    print p.v.t.fileIndex</t>
<t tx="ekr.20040312021734"></t>
<t tx="ekr.20040312021734.1">count = 0
for p in c.rootPosition().allNodes_iter():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20040312101720"></t>
<t tx="ekr.20040317101155" lineYOffset="4b032e" icons="5d7100287d7101285504747970657102550466696c65710355047870616471044b02550577686572657105550a6265666f726549636f6e710668035834000000433a5c70726f675c6c656f4356535c6c656f5c7372635c2e2e5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286802680368084afdffffff68035834000000433a5c70726f675c6c656f4356535c6c656f5c7372635c2e2e5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6805550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e">p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

&lt;&lt; define event callbacks &gt;&gt;

path = g.os_path_join(g.app.loadDir,"..","Icons")
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
    "type" : "file", "file" : icon1,
    "where" : "beforeIcon",
    "yoffset" : -3,
    # "yoffset" : 5, "ypad" : -5,
    # "height" : 40, # automatically adjust headline y position.
    "xpad": 2
}

# Classes and functions can only be pickled if they are at the top level of a module.
    #"onClick" : onClick,
    #"onRightClick" : onRightClick,
    #"onDoubleClick" : onDoubleClick }

d2 = {
    "type" : "file", "file" : icon2,
    "where" : "beforeHeadline",
    "yoffset" : -3,
    "xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()
</t>
<t tx="ekr.20040317173327">for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0
            
c.redraw()</t>
<t tx="ekr.20040317185041">def onClick(p=p):
    
    g.trace(p)

def onRightClick(p=p):
    
    g.trace(p)

def onDoubleClick(p=p):
    
    g.trace(p)</t>
<t tx="ekr.20040318091620">for p in c.allNodes_iter():
    if hasattr(p.v.t,"unknownAttributes"):
        print "deleting unknownAttributes:",p
        delattr(p.v.t,"unknownAttributes")
            
c.redraw()
</t>
<t tx="ekr.20040319111213">from leoPlugins import *
from leoGlobals import *
from leoNodes import *
import Tkinter
import re
import sys

@others

fhp = None
fhp_entry = None
    
if 1:
    addMenu("none",None)
else:
    hooks = choose(sys.platform == 'win32',
        ('open2',"new"),
        ('start2','open2',"new"))
        
    print "hi"
        
    registerHandler(hooks,addMenu)

    __version__ = ".1"
    plugin_signon(__name__)
</t>
<t tx="ekr.20040319111213.1">@nocolor

@ This is what it does:

1. Under Outline it puts an Option called 'FilterHoist'
2. Selecting the option pops up an ugly little window.  On it is a section where
you can type in text.  You can close the window with the close button.  You
can activate the functionality with the Filter Button.
3. Filtering will walk the Leo tree, looking for a text match from the Text
field with the Nodes bodyString.
4. After finding some nodes it creates a new node at the root.  Then it clones
the matching nodes under that new node.  A Hoist operation is performed on the
new node.  This gives a view of all matching nodes.

I put this together because I wanted a find that was based in terms of Leo's
nodes.  Find as it is bounces you around the Tree(it bothers me).  This brings
the nodes to you and presents them.  As it is I may work further on this if
people like the idea.  It's possible I might migrate it to the NodeRoundup plugin
to.

You need 2.3 python; it uses generators in it's find method.

That was one motivation for writing this thing, using a generator vs. Recursive
approach to tree walking.</t>
<t tx="ekr.20040319111213.2">def OLDfilter(c,e):

    v = c.rootVnode()
    
    nodes = []
    while v:
        nodes.append(v)
        v = v.next()
    
    regex = re.compile(e.get())
    c.beginUpdate()
    try: # update...
        t = tnode('','A Filtered Hoist')
        ticker = c.rootVnode().insertAfter(t)
        for z in nodes:
            for x in search(z,regex):
                clone = x.clone( x )
                clone.moveToNthChildOf(ticker,0)
        c.setCurrentVnode(ticker)
        ticker.moveToRoot(c.rootVnode())
    finally:
        c.endUpdate()
    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040319111213.3">from __future__ import generators # To make the code work in Python 2.2.

def OLDsearch(vn,regex):

    sn = vn 
    while vn != None:
        if regex.search( vn.t.bodyString ) : yield vn
        nc = vn.numberOfChildren()
        if nc == 0:
            i = vn.childIndex()
            p = vn.parent()
            if p == None: 
                vn = None
                continue
            if i == 0:
                while 1:
                    if p == sn :
                        vn = None
                        break
                    vn = p.back() 
                    if vn == None:
                        p = p.parent()
                        continue
                    break
                continue                                                        
            vn = p.nthChild( i - 1)
            continue
        vn = vn.nthChild( nc - 1 )
</t>
<t tx="ekr.20040319111213.4">def filterHoist(c):

    global fhp
    global e
    
    if fhp is None:

        fhp = Tkinter.Toplevel()
        fhp.title('FilterHoist')

        fhp_entry = e = Tkinter.Entry(fhp)
        e.pack(side="top",fill="both")

        def closeCallback(fhp=fhp):
            fhp.withdraw()
            
        def filterCallback(c=c,entry=e):
            filter(c,entry)

        b1 = Tkinter.Button(fhp,text='Close',command=closeCallback)
        b2 = Tkinter.Button(fhp,text='Filter',command=filterCallback)
        b1.pack(side="left")
        b2.pack(side="right")

    fhp.geometry('200x200+250+250') 
    fhp.deiconify()
    fhp_entry.focus_set()
</t>
<t tx="ekr.20040319111213.5">def addMenu(tag,keywords):
    
    c = top()
    
    trace()
    
    def callback(c=c):
        filterHoist(c)
    
    table = ("FilterHoist",None,callback),

    c.frame.menu.createMenuItemsFromTable("Outline",table)</t>
<t tx="ekr.20040319142202"></t>
<t tx="ekr.20040319142708">def filter(c,e):
    
    pat = re.compile(e.get())

    c.beginUpdate()
    try: # update...
        t = tnode('','A Filtered Hoist')
        newRoot = c.rootVnode().insertAfter(t)
        p = c.rootVnode()
        while p:
            if pat.search(p.bodyString()):
                clone = p.clone(p)
                clone.moveToLastChildOf(newRoot)
            p = p.threadNext()
        newRoot.moveToRoot(c.rootVnode())
        c.setCurrentVnode(newRoot)
    finally:
        c.endUpdate()

    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040322120331">print '-'*20
for p in c.allNodes_iter():
    if hasattr(p.v.t,"tnodeList"):
        print p,p.v.t.tnodeList</t>
<t tx="ekr.20040323075614">class test_iter_class:
    def __init__ (self):
        self.vals = ("a","b","c")
        self.n = 0
    def __iter__(self):
        return self
    def next(self):
        if self.n &lt; len(self.vals):
            val = self.vals[self.n]
            self.n += 1
            return val
        else:
            raise StopIteration
            
def test_iter(): return test_iter_class()
        
vals = [val for val in test_iter()]

print vals</t>
<t tx="ekr.20040323080317">print '-'*20

# These are equivalent.
positions1 = [p for p in c.allNodes_iter(copy=True)]
positions2 = [p.copy() for p in c.allNodes_iter()]

assert(len(positions1) == len(positions2))
for i in xrange(len(positions1)):
    assert(positions1[i] == positions2[i])

if 0:
    for p in positions1:
        print p
print "done"</t>
<t tx="ekr.20040323082119">print '-'*20

positions = [p.copy() for p in c.allNodes_iter()]

tnodes = {} ; vnodes = []
for p in c.allNodes_iter():
    t = p.v.t
    if tnodes.get(t) is None:
        tnodes[t]=t
        vnodes.append(p.v)
        
print len(positions),len(vnodes)

for v in vnodes:
    print v</t>
<t tx="ekr.20040323085406">print '-'*20

for p in c.allNodes_iter():
    if p.isAnyAtFileNode():
        print p
        
print "done"</t>
<t tx="ekr.20040323085933">print '-'*20

for p in c.allNodes_iter():
    if p.isDirty():
        vnodes = p.findAllPotentiallyDirtyNodes()
        print '-'*5, p
        for v in vnodes:
            print v

print "done"</t>
<t tx="ekr.20040325082811">g.es("v",g.top().currentPosition())
g.es(1,2)</t>
<t tx="ekr.20040325130503">stack1 = ["a","b","c"]
stack2 = ["a","b","c"]
stack3 = ["a","b","d"]
stack4 = ["a","b"]
print stack1 == stack2
print stack1 == stack3
print stack1 == stack4</t>
<t tx="ekr.20040325140133">print p.v.headString()
print p.childIndex()
print p.v.headString()</t>
<t tx="ekr.20040325155043">import timeit

s1 = '''\
class test(object):
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s2 = '''\
class test:
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s3 = '''\
import leoNodes
p1 = leoNodes.position(None,[])
p2 = leoNodes.position(None,[])'''

for s in (s1,s2,s3):
    t1 = timeit.Timer(stmt='p1==p2',setup=s).timeit()
    t2 = timeit.Timer(stmt='p1.equal(p2)',setup=s).timeit()
    print "%2.2f,%2.2f,%0.2f" % (t1,t2,t1/t2)
</t>
<t tx="ekr.20040330095252">t = c.frame.log.logCtrl
print t
t.delete("1.0","end")</t>
<t tx="ekr.20040330103006">@ignore
@language c

oblk[1] = b64[((iblk[0] &amp; 0x03) &lt;&lt; 4) |
((iblk[1] &amp; 0xF0) &gt;&gt; 4)];
oblk[2] = b64[((iblk[1] &amp; 0x0F) &lt;&lt; 2) |
((iblk[2] &amp; 0xC0) &gt;&gt; 6)];
</t>
<t tx="ekr.20040409140301"></t>
<t tx="ekr.20040409140301.1"></t>
<t tx="ekr.20040409140301.2"></t>
<t tx="ekr.20040409140301.3"></t>
<t tx="ekr.20040409140343"></t>
<t tx="ekr.20040409140343.1"></t>
<t tx="ekr.20040409142028"></t>
<t tx="ekr.20040409142028.1"></t>
<t tx="ekr.20040409142108"></t>
<t tx="ekr.20040409142108.1"></t>
<t tx="ekr.20040414082806"></t>
<t tx="ekr.20040419105536">@ignore
@language perl

@others</t>
<t tx="ekr.20040419105536.1">line 1</t>
<t tx="ekr.20040419105536.2">line 2</t>
<t tx="ekr.20040701065412">@others</t>
<t tx="ekr.20040701065412.1">marked node</t>
<t tx="ekr.20040701065412.2"></t>
<t tx="ekr.20040701065412.3"></t>
<t tx="ekr.20040701065412.4"></t>
<t tx="ekr.20040701065412.5"></t>
<t tx="ekr.20040701065424"></t>
<t tx="ekr.20040701065424.1"></t>
<t tx="ekr.20040701081330">@ignore</t>
<t tx="ekr.20040704104554">@ignore</t>
<t tx="ekr.20040704104554.1">@language html
@language python
</t>
<t tx="ekr.20040704104554.2"></t>
<t tx="ekr.20040705191805">@ignore

import leoNodes

print '-' * 20
format = "%18s"
for child in p.children_iter():
    print ; print child.headString()
    print format % "isAnyAtFileNode",   child.isAnyAtFileNode()
    print format % "anyAtFileNodeName", child.anyAtFileNodeName()
    print format % "isAtFileNode",      child.isAtFileNode()
    print format % "isAtNoSentFileNode",child.isAtNoSentFileNode()
    print format % "isAtNorefFileNode", child.isAtNorefFileNode()
    print format % "isAtAsisFileNode",  child.isAtAsisFileNode()
    print format % "isAtThinFileNode",  child.isAtThinFileNode()</t>
<t tx="ekr.20040705191805.1"></t>
<t tx="ekr.20040705191805.2"></t>
<t tx="ekr.20040705192522"></t>
<t tx="ekr.20040705192522.1"></t>
<t tx="ekr.20040705192522.2"></t>
<t tx="ekr.20040705192522.3"></t>
<t tx="ekr.20040705192522.4"></t>
<t tx="ekr.20040705192522.5"></t>
<t tx="ekr.20040705192522.6"></t>
<t tx="ekr.20040705192610"></t>
<t tx="ekr.20040705192610.1"></t>
<t tx="ekr.20040705212227"></t>
<t tx="ekr.20040706071823"># This works, and doesn't seem convenient for Leo's importers.
try:
    import parser
    import pprint
    path = r"c:\prog\test\importIndentTest.py"
    f = open(path)
    s = f.read()
    f.close()
    ast = parser.suite(s)
    tup = ast.totuple()
    print `ast`
    pprint.pprint(tup)
except:
    import traceback
    traceback.print_exc()</t>
<t tx="ekr.20040707081532.1"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(all=False)</t>
<t tx="ekr.20040707104245"></t>
<t tx="ekr.20040707110818">@ignore # Suppress @file reads/writes

</t>
<t tx="ekr.20040707141957.12">import leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.13">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.14">#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:#@thin
Line 1

#@@last
#@nonl
#@-node:ekr.20040707141957.13:#@thin
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040708135624">import leoTest

u = leoTest.testUtils()

print "children", '-' * 20
children = u.findChildrenOf(p)
for child in children: print child.headString()

print "subtree", '-' * 20
descendants = u.findSubnodesOf(p)
for descendant in descendants: print descendant.headString()</t>
<t tx="ekr.20040708205841">@language python
@tabwidth -4</t>
<t tx="ekr.20040708210442"></t>
<t tx="ekr.20040708210636"></t>
<t tx="ekr.20040710125250">@language plain

The first idea was to use Python's imp module to simulate an import from a file.  This does not work well because imp expects a file, not a StringIO object.

The second idea was to use Python's parser module.  But this returns an instance type, not a module.

A third idea would be to subclass the file type to fool the imp module.

A fourth idea would be to use the ihooks module.  Apparently this module was designed to do something like what I am trying to do!  However, there doesn't seem to be docs for it, so I have imported the code...

@color</t>
<t tx="ekr.20040710125250.2">import imp
import StringIO

@
load_module( name, file, filename, description) 

Load a module that was previously found by find_module() (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it is equivalent to a reload()! The name argument indicates the full module name (including the package name, if this is a submodule of a package). The file argument is an open file, and filename is the corresponding file name; these can be None and '', respectively, when the module is not being loaded from a file. The description argument is a tuple, as would be returned by get_suffixes(), describing what kind of module must be loaded. 
If the load is successful, the return value is the module object; otherwise, an exception (usually ImportError) is raised. 

Important: the caller is responsible for closing the file argument, if it was not None, even when an exception is raised. This is best done using a try ... finally statement.
@c

s = """

def foobar(): pass

"""

@ get_suffixes( ) 

Return a list of triples, each describing a particular type of module. Each triple has the form (suffix, mode, type), where suffix is a string to be appended to the module name to form the filename to search for, mode is the mode string to pass to the built-in open() function to open the file (this can be 'r' for text files or 'rb' for binary files), and type is the file type, which has one of the values PY_SOURCE, PY_COMPILED, or C_EXTENSION, described below.
@c

print '-' * 20
description = (".py","r",imp.PY_SOURCE)
theFile = StringIO.StringIO(s) # Create a file-like object
print repr(theFile)
try:
    imp.load_module("myModule",theFile,"myFileName",description)
except:
    g.es_exception()



</t>
<t tx="ekr.20040710141351">import leoTest
import types

specialDictNames = ('__builtins__','__doc__','__name__','__file__','__module__')

def printDoc(x,s):
    if hasattr(x,"__doc__") and x.__doc__:
        print "%4d %s" % (len(x.__doc__),s)
    else:
        print "%4s %s" % (' ',s)

print '-' * 60
print "%4d %s" % (len(leoTest.__doc__),"leoTest")

if 1:
    for s in leoTest.__dict__:
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) != types.ModuleType:
                printDoc(x,s)
                if type(x) == types.ClassType:
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print ' '*4,
                            printDoc(x2,s2)
else:
    &lt;&lt; print names sorted by type &gt;&gt;</t>
<t tx="ekr.20040710145459">for theType,typeName in (
    (types.ModuleType,"modules"),
    (types.ClassType,"classes"),
    (types.FunctionType,"functions"),
):

    print ; print "%s..." % typeName
    for s in leoTest.__dict__:
        
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) == theType:
                printDoc(x,s)
                if theType == types.ClassType:
                    print "\tmethods..."
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print "\t",
                            printDoc(x2,s2)</t>
<t tx="ekr.20040711044029.1">import leoTest
import glob

print '-' * 40

if 0:
    print "modules in test.leo..."
    paths = leoTest.findAllAtFileNodes(c)
    modules = leoTest.importAllModulesInPathList(paths)
    for module in modules:
        print module
    
if 1:
    print "modules in leo/src..."
    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    for module in modules:
        print module
        
if 0:
    directory = g.os_path_join(g.app.loadDir,"..","src")
    glob_path = g.os_path_join(directory,"leo*.py")
    files = glob.glob(glob_path)
    modules = leoTest.importAllModulesInPathList(files)
    for module in modules:
        print module</t>
<t tx="ekr.20040711085843">import compiler

for child in p.children_iter():
    h = child.headString()
    body = child.bodyString()
    
    try:
        val = compiler.parse(body)
        print type(val)
        print val
    except SyntaxError:
        g.es("Syntax error: %s" % h,color="blue")</t>
<t tx="ekr.20040711092603">import doctest
print doctest</t>
<t tx="ekr.20040711093916">if 0:
    class myFile(file):
        pass
        
    print myFile
    print issubclass(myFile,file)
    print isinstance(myFile,file)
    print super(myFile)
    print __import__
    
if 0:
    old_import = __import__
        
    def myImport(*args,**keys):
        print "myImport"
        global old_import
        old_import(*args,**keys)
        
    __import__ = myImport
    
mod = __import__("leoApp")
print mod</t>
<t tx="ekr.20040711140206">@ By far the simplest way is just to write the string to a temp file, then import the temp files.

All other approaches quickly get deeply involved with Leo's internals...</t>
<t tx="ekr.20040712101754"></t>
<t tx="ekr.20040712101754.2">@language python
@tabwidth -4</t>
<t tx="ekr.20040712101754.3">import leoTest

path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040712101754.4">import leoTest

path = g.os_path_join(g.app.loadDir,"..","src","LeoPy.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.5">import leoTest

path = g.os_path_join(g.app.loadDir,"..","plugins","leoPlugins.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.6">import leoTest

path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.7">@language python
@tabwidth -4</t>
<t tx="ekr.20040712101754.8"># Create unit tests in g.app.scriptDict["suite"]

import unittest
import leoTest

@others

suite = leoTest.makeImportExportSuite("importTests",doImport=True)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.9"># Create unit tests in g.app.scriptDict["suite"]


import unittest
import leoTest

@others

suite = leoTest.makeImportExportSuite("exportTests",doImport=False)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.10">@language plain</t>
<t tx="ekr.20040712101754.11"></t>
<t tx="ekr.20040712101754.12"></t>
<t tx="ekr.20040712101754.13">openFileDialog
test\\unittest\\perfectImport\\formatter.py</t>
<t tx="ekr.20040712101754.14"></t>
<t tx="ekr.20040712101754.15">openFileDialog
test\\unittest\\perfectImport\\formatter.py</t>
<t tx="ekr.20040712101754.16"></t>
<t tx="ekr.20040712101754.17">openFileDialog
test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040712101754.18"></t>
<t tx="ekr.20040712101754.19">openFileDialog
test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040712101754.20"></t>
<t tx="ekr.20040712101754.21">openFileDialog
test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040712101754.22"></t>
<t tx="ekr.20040712101754.23">openFileDialog
test\\unittest\\input\\testLeoAtFile.py</t>
<t tx="ekr.20040712101754.24">@language plain</t>
<t tx="ekr.20040712101754.25"></t>
<t tx="ekr.20040712101754.26"></t>
<t tx="ekr.20040712101754.27">saveFileDialog
test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040712101754.28"></t>
<t tx="ekr.20040712101754.29">saveFileDialog
test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040712101754.30"></t>
<t tx="ekr.20040712101754.31">saveFileDialog
test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040712101754.32"></t>
<t tx="ekr.20040712101754.33">saveFileDialog
test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040712101754.34"></t>
<t tx="ekr.20040712101754.35">saveFileDialog
test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040712101754.36"></t>
<t tx="ekr.20040712101754.37"># Create unit tests in g.app.scriptDict["suite"]

import leoTest

g.app.enableUnitTest = True

suite = leoTest.makeEditBodySuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.38">@language plain

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.</t>
<t tx="ekr.20040712101754.39"></t>
<t tx="ekr.20040712101754.45"></t>
<t tx="ekr.20040712101754.46">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040712101754.47">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040712101754.48">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040712101754.49"></t>
<t tx="ekr.20040712101754.50">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040712101754.51">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040712101754.52">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040712101754.99">&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
    print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

if 0: # all nodes
    for v in c.all_vnodes_iter(): print v
    for t in c.all_tnodes_iter(): print t
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print v
    for t in c.all_unique_tnodes_iter(): print t</t>
<t tx="ekr.20040712101754.100">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"</t>
<t tx="ekr.20040712101754.101">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20040712101754.102">@color</t>
<t tx="ekr.20040712101754.103">import leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.104">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040712101754.105">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@nonl
#@-node:#@file
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040712101754.106">import leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.107">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20040712101754.108">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20040712101754.109">import leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.110">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.111">#@+leo-ver=4
#@+node:#@file
Line 1

#@@last
#@-node:#@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.115"></t>
<t tx="ekr.20040712101754.116">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.117">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
continues */

More plain text.</t>
<t tx="ekr.20040712101754.118">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.119">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040712101754.120">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.121">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040712101754.122">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.123">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040712101754.124">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.125">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20040712101754.126">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.127">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section references are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040712101754.128">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20040712101754.129">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.130">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040712101754.131">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.132">@language html

b = "cd"
d
</t>
<t tx="ekr.20040712101754.133">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.134">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040712101754.135">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.136">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040712101754.137">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.138">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}

The following should be colored:

\documentclass{report}

The following 2-letter words should be colored, regardless of what follows:

\(\)\{\}\@
\(abc\)abc\{abc\}abc\@abc</t>
<t tx="ekr.20040712101754.139">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.140">@ignore
@ doc
@c
@language c
    @others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040712101754.141">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.142">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20040712101754.143">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.144">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20040712101754.145">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="ekr.20040712101754.146">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="ekr.20040712101754.147">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="ekr.20040712101754.148">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="ekr.20040712101754.149">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="ekr.20040712101754.150">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="ekr.20040712101754.151">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="ekr.20040712101754.152">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20040712101754.153">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20040712101754.154">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.155">@language python

"""python
string""" ; following = a

'this\
is'''</t>
<t tx="ekr.20040712101754.156">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.157">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
    
def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20040712101754.158">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.159">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20040712101754.160">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.161">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040712101754.162">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.163"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20040712101754.164">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.165">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20040712101754.166">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="ekr.20040712101754.167">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="ekr.20040712101754.168">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.169"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

print g.app().loadDir</t>
<t tx="ekr.20040712101754.170">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.171"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

print g.app().loadDir
</t>
<t tx="ekr.20040712101754.172">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.173"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass</t>
<t tx="ekr.20040712101754.174"></t>
<t tx="ekr.20040712101754.175">root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
    assert(p.t == p.v.t)</t>
<t tx="ekr.20040712101754.176">try:
    mode = c.frame.body.colorizer.modes.get('python')
    mode.keywords['as'] = 1 # append the keyword, colorize with 'keyword1' tag.
except AttributeError:
    pass # modes only exists for new colorizer.</t>
<t tx="ekr.20040712101754.177">p = p.firstChild()
assert(p.headString()=="File Conversion")
p.convertTreeToString()</t>
<t tx="ekr.20040712101754.178">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040712101754.179">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040712101754.180">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.bodyString() ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040712101754.181"># The actual test is in a child node.</t>
<t tx="ekr.20040712101754.182"></t>
<t tx="ekr.20040712101754.183">try:
    for p in c.allNodes_iter():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            if p.v._parent: parents1 = p.v._parent.t.vnodeList
            else:           parents1 = []
            parents2 = p.v.directParents()
        
        assert len(parents1) == len(parents2), "length mismatch: %s, %s" % (p,p.v._parent)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print "parents1"
    for parent in parents1: print parent
    print "parents2"
    for parent in parents2: print parent
    raise</t>
<t tx="ekr.20040712101754.184">try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert len(parents) == len(vparents), "length mismatch: %s,%s" % (p,child)
                for parent in parents:
                    assert parent in vparents, "not in vparents: %s,%s" % (p,child)
                for parent in vparents:
                    assert parent in parents, "not in parents: %s,%s" % (p,child)
except AssertionError:
    print "parents..."
    for parent in parents: print parent
    print "vparents..."
    for parent in vparents: print parent
    raise # for unittest.</t>
<t tx="ekr.20040712101754.185">for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040712101754.186">import os
import sys

verbose = False

python_interp = sys.executable
test_path = g.os_path_join(g.app.loadDir,"..","test","unittest")
src_path  = g.os_path_join(g.app.loadDir,"..","src")

leo_file   = g.os_path_join(src_path,"leo.py")
batch_file = g.os_path_join(test_path,"batchTest.py")
test_file  = g.os_path_join(test_path,"createdFile.txt")

# Execute this command: python leo.py -script test\unittest\batchTest.py

command = r"%s %s -script %s" % (python_interp,leo_file,batch_file)

@others

removeFile(test_file,verbose)
os.system(command)

try:
    g.redirectStdout()
    removeFile(test_file,verbose)
    os.system(command)
finally:
    g.restoreStdout()
    
assert(g.os_path_exists(test_file))</t>
<t tx="ekr.20040712101754.187"></t>
<t tx="ekr.20040712101754.188">import leoNodes

current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print v
    for v in vList2: print v

if 0:
    print len(allList),len(vList1),len(vList2)

&lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="ekr.20040712101754.189"></t>
<t tx="ekr.20040712101754.190"></t>
<t tx="ekr.20040712101754.191"></t>
<t tx="ekr.20040712101754.192"></t>
<t tx="ekr.20040712101754.193"></t>
<t tx="ekr.20040712101754.194"></t>
<t tx="ekr.20040712101754.195"></t>
<t tx="ekr.20040712101754.196">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    # print "consistency tests pass"

except AssertionError:
    print tag
    print "list1"
    for v in list1: print v
    print "list2"
    for v in list2: print v
    raise</t>
<t tx="ekr.20040712101754.197">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20040712101754.198">if 0:
    for v in current.vnodes_iter(): print v
    for v in current.unique_vnodes_iter(): print v

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print v
    for t in root.tnodes_iter(): print t

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print v
    for t in child.tnodes_iter(): print t</t>
<t tx="ekr.20040712101754.199">assert(p == p.copy())
assert(p != p.threadNext())</t>
<t tx="ekr.20040712101754.200">for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040712101754.201">for copy in (True,False):
    p2 = c.rootPosition()
    for p in c.allNodes_iter(copy=copy):
        assert p==p2, "%s != %s" % (p,p2)
        p2.moveToThreadNext()
        
    assert not p2, repr(p2)
</t>
<t tx="ekr.20040712101754.202">for copy in (True,False):
    for p in c.allNodes_iter(copy=copy):
        
        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToNext()

    assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.203">for p in c.allNodes_iter():
    
    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)
        
    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())</t>
<t tx="ekr.20040712101754.204">for p in c.allNodes_iter():
    
    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040712101754.205">for copy in (True,False):

    for p in c.allNodes_iter():
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToParent()

        assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.206"># Test consistency of p.parent, p.next, p.back and p.firstChild.
for p in c.allNodes_iter():
    
    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))
        
    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())
        
    if p.hasBack():
        assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040712101754.207">for p in c.allNodes_iter():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040712101754.208">for p in c.allNodes_iter():
    if p.isCloned():
        parents = p.v.t.vnodeList
        for child in p.children_iter():
            vparents = child.v.directParents()
            assert(len(parents) == len(vparents))
            for parent in parents:
                assert(parent in vparents)
            for parent in vparents:
                assert(parent in parents)</t>
<t tx="ekr.20040712101754.209">for p in c.allNodes_iter():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))
            
    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))</t>
<t tx="ekr.20040712101754.210">for p in c.allNodes_iter():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))
            
    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))</t>
<t tx="ekr.20040712101754.211">for p in c.allNodes_iter():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))
            
    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040712101754.212">for p in c.allNodes_iter():

    vnodeList = p.v.t.vnodeList

    for v in vnodeList:

        assert(v.t == p.v.t)
        if p.v.isCloned():
            assert(v.isCloned())
            assert(len(vnodeList) &gt; 1)
        else:
            assert(not v.isCloned())
            assert(len(vnodeList) == 1)</t>
<t tx="ekr.20040712101754.213"></t>
<t tx="ekr.20040712101754.214"></t>
<t tx="ekr.20040712101754.215">import leoNodes

root1 = p.firstChild()

root2 = root1.copyTreeAfter()
root2.initHeadString("root2")
c.checkOutline()
c.redraw()
root2.doDelete(root1)
c.checkOutline()
c.redraw()</t>
<t tx="ekr.20040712101754.216"></t>
<t tx="ekr.20040712101754.217"></t>
<t tx="ekr.20040712101754.218"></t>
<t tx="ekr.20040712101754.219"></t>
<t tx="ekr.20040712101754.220"></t>
<t tx="ekr.20040712101754.221">import leoTest

u = leoTest.testUtils()
outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.headString()=="outline1")
assert(outline2.headString()=="outline2")

u.replaceOutline(outline1,outline2)
c.redraw()
c.checkOutline()</t>
<t tx="ekr.20040712101754.222"></t>
<t tx="ekr.20040712101754.223"></t>
<t tx="ekr.20040712101754.224"></t>
<t tx="ekr.20040712101754.225"></t>
<t tx="ekr.20040712101754.226">def replaceOutline (self,outline1,outline2):
    
    """Replace outline1 by a copy of outline 2,
    
    retaining the headline of outline1."""

    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete(copy)</t>
<t tx="ekr.20040712101754.227"># Create unit tests in g.app.scriptDict["suite"]

import unittest
import leoTest

@others

suite = makeOutlineSuite("outlineTests")

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.228">def makeOutlineSuite(parentHeadline):
    
    """Create an outline test for every descendant of testParentHeadline.."""

    v = c.currentVnode()
    u = leoTest.testUtils()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    parent = u.findNodeAnywhere(c,parentHeadline)
    
    for child in parent.children_iter(copy=True):
        before = u.findNodeInTree(child,"before")
        after  = u.findNodeInTree(child,"after")
        ref    = u.findNodeInTree(child,"ref")
        if before and after and ref:
            test = outlineTestCase(c,child,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040712101754.229">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20040712101754.230">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.u = leoTest.testUtils()

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref</t>
<t tx="ekr.20040712101754.231">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert move, "no move node"
    
    c.selectVnode(move)
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()

    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))</t>
<t tx="ekr.20040712101754.232">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20040712101754.233">def setUp(self):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert self.u.compareOutlines(self.before,self.ref,compareHeadlines=False),\
        "compare failed"
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20040712101754.234">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()</t>
<t tx="ekr.20040712101754.235">def shortDescription (self):
    
    return self.parent.headString()</t>
<t tx="ekr.20040712101754.236"></t>
<t tx="ekr.20040712101754.237"></t>
<t tx="ekr.20040712101754.238"></t>
<t tx="ekr.20040712101754.239"></t>
<t tx="ekr.20040712101754.240"></t>
<t tx="ekr.20040712101754.241"></t>
<t tx="ekr.20040712101754.242"></t>
<t tx="ekr.20040712101754.243"></t>
<t tx="ekr.20040712101754.244"></t>
<t tx="ekr.20040712101754.245"></t>
<t tx="ekr.20040712101754.246"></t>
<t tx="ekr.20040712101754.247"></t>
<t tx="ekr.20040712101754.248"></t>
<t tx="ekr.20040712101754.249"></t>
<t tx="ekr.20040712101754.250"></t>
<t tx="ekr.20040712101754.251"></t>
<t tx="ekr.20040712101754.252"></t>
<t tx="ekr.20040712101754.253"></t>
<t tx="ekr.20040712101754.254"># Create unit tests in g.app.scriptDict["suite"]

import unittest
import leoTest

@others

suite = unittest.makeSuite(findCommandTestCase,'test')

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.255">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20040712101754.256">def setUp(self):
    
    self.u = u = leoTest.testUtils()
    self.c = c # = g.top()
    self.find_p = u.findNodeAnywhere(c,"findTests")
    
    assert(self.find_p)
</t>
<t tx="ekr.20040712101754.257">def testFindCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.258">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.259">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.260">aaa</t>
<t tx="ekr.20040712101754.272">errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.

assert errors == 0, "Check Outline reported %d errors" % errors</t>
<t tx="ekr.20040712101754.273">import doctest
import unittest
import leoTest

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
paths = leoTest.findAllAtFileNodes(c)
modules = leoTest.importAllModulesInPathList(paths)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.274">import unittest
import leoTest

import sys

# DocTestSuite exists in Python 2.3 and above.

if g.CheckVersion(sys.version, "2.3"):

    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    
    suite = leoTest.createUnitTestsFromDoctests(modules)
                                
    if suite:
        g.app.scriptDict['suite'] = suite
        
else:
    # Create an empty suite to suppress a warning.
    g.app.scriptDict['suite'] = unittest.TestSuite()
    print
    print "Can't create unit tests from doctests"
    print "doctest.DocTestSuite requires Python 2.3 or above."
    print</t>
<t tx="ekr.20040712101813">result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20040713070526">@language python 

import leoTest

u = leoTest.testUtils()
dump = False 
all = False 

if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = u.findNodeInTree(p,"tempNode")
    temp.setBodyStringOrPane("")
    before = u.findNodeInTree(p,"before")
    after = u.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.bodyString())
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.bodyString() == after.bodyString(),"Pretty Print Test failed"</t>
<t tx="ekr.20040713123617">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        print "  "

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others</t>
<t tx="ekr.20040713123617.1">@language python
@tabwidth -4

import string

tabWidth = 4 # how many blanks in a tab.
printFlag = False
doLeoTranslations,dontDoLeoTranslations = True,False

gClassName = "" # The class name for the present function.  Used to modify ivars.
gIvars = [] # List of ivars to be converted to self.ivar

@others

run(c)</t>
<t tx="ekr.20040713123828.1">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""

    if a == 3:
        print "  "

    ''' Another ' triple'   quoted string:
        It should remain untouched.'''

    "yet another\
    multi-line string"

class eggs:

    """ A typical doc string """

    @others</t>
<t tx="ekr.20040713130853"></t>
<t tx="ekr.20040713130853.1">@ elisp2py converts elisp text into python text.  The conversion is not complete.  Nevertheless, elisp2py eliminates much of the tedious text manipulation that would otherwise be required.

The following is a list of the translations performed by c2py.  These transformations are controlled by convertCodeList().

I.  Prepass

These translations happen before removing all curly braces.

Suppose we are translating:

    aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
    {
        body
    }

1. Translates the function prototype, i.e., translates:

    aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
to:
    def aMethod(v1,...vn):

As a special case, c2py translates:

    aTypeSpec aClass::aClass(t1 v1,...,tn vn)
to:
    aClass.__init__(t1 v1,...,tn vn)

Yes, I know, aClass.__init__ isn't proper Python, but retaining the class name is useful.

2. Let t denote any member of typeList or classList.

    a) Removes all casts of the form (t) or (t*) or (t**), etc.
    b) Converts t x, t *x, t **x, etc. to x.
    c) Converts x = new t(...) to x = t(...)
    d) For all i in ivarsDict[aClass] converts this -&gt; i to self.i
    e) For all i in ivarsDict[aClass] converts i to self.i

3. Converts &lt; &lt; x &gt; &gt; = to @c.  This Leo-specific translation is not done when translating files.

II.  Main Pass

This pass does the following simple translations everywhere except in comments and strings.

Changes all -&gt; to .
Changes all this.self to self (This corrects problems during the prepass.)
Removes all curly braces
Changes all #if to if
Changes all else if to elif
Changes all #else to else:
Changes all else to else:
Removes all #endif
Changes all &amp;&amp; to and
Changes all || to or
Changes all TRUE to True
Changes all FALSE to False
Changes all NULL to None
Changes all this to self
Changes all @code to @c.  This Leo-specific translation is not done when translating files.

III.  Complex Pass

This pass attempts more complex translations.

Converts if ( x ) to if x:
Converts elif ( x ) to elif x:
Converts while ( x ) to while x:
Converts for ( x ; y ; z ) to for x SEMI y SEMI z:

remove all semicolons.

IV.  Final Pass

This pass completes the translation.

Removes all semicolons.
Removes @c if it starts the text.  This Leo-specific translation is not done when translating files.
Removes all blank lines.
Removes excess whitespace from all lines, leaving leading whitespace unchanged.
Replaces C/C++ comments by Python comments.
Removes trailing whitespace from all lines.
</t>
<t tx="ekr.20040713130853.2">@ Strategy and Performance

The speed of elisp2py is unimportant.  We don't care about the memory used because we translate only small pieces of text at a time.

We can do body[i:j] = x, regardless of len(x).  We can also do del body[i:j] to delete characters.

We scan repeatedly through the text.  Using many passes greatly simplifies the code and does not slow down elisp2py significantly.

The script does not scan within strings or comments.  The idiom to handle such scans is the following:

def someScan(body):
    i = 0
    while i &lt; body(len):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif &lt;&lt; found what we are looking for ? &gt;&gt; :
            &lt;&lt; convert what we are looking for, setting i &gt;&gt;
        else: i += 1

That's about all there is to it.
</t>
<t tx="ekr.20040713130853.3">@ Please change the following lists so they contain the types and classes used by your program.

c2py removes all type definitions correctly; it converts
    new aType(...)
to
    aType(...)
@c

classList = [
    "vnode", "tnode", "Commands",
    "wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]
    
typeList = ["char", "void", "short", "long", "int", "double", "float"]

@ Please change ivarsDict so it represents the instance variables (ivars) used by your program's classes.

ivarsDict is a dictionary used to translate ivar i of class c to self.i.  It also translates this-&gt;i to self.i.
@c
    
ivarsDict = {
    "atFile": [ "mCommands", "mErrors", "mStructureErrors",
        "mTargetFileName", "mOutputFileName", "mOutputStream",
        "mStartSentinelComment", "mEndSentinelComment", "mRoot"],

    "vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

    "tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
        "mSelectionStart", "mSelectionLength", "mCloneIndex"],
        
    "LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

    "Commands": [
        # public
        "mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
        "mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
        #private
        "mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
        "mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
        "mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
        "mMaxVnodeTag",
        "mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
        "mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}</t>
<t tx="ekr.20040713130853.4">testData = [ "\n@doc\n\
This is a doc part: format, whilest, {};-&gt;.\n\
&lt;&lt;\
section def&gt;&gt;=\n\
LeoFrame::LeoFrame(vnode *v, char *s, int i)\n\
{\n\
    // test ; {} /* */.\n\
    #if 0 //comment\n\
        if(gLeoFrameList)gLeoFrameList -&gt; mPrevFrame = this ;\n\
        else\n\
            this -&gt; mNextFrame = gLeoFrameList ;\n\
    #else\n\
        \n\
        vnode *v = new vnode(a,b);\n\
        Commands *commander = (Commands) NULL ; // after cast\n\
        this -&gt; mPrevFrame = NULL ;\n\
    #endif\n\
    if (a==b)\n\
        a = 2;\n\
    else if (a ==c)\n\
        a = 3;\n\
    else return; \n\
    /* Block comment test:\n\
        if(2):while(1): end.*/\n\
    for(int i = 1; i &lt; limit; ++i){\n\
        mVisible = FALSE ;\n\
        mOnTop = TRUE ;\n\
    }\n\
    // trailing ws.	 \n\
    mCommands = new Commands(this, mTreeCtrl, mTextCtrl) ;\n\
    gActiveFrame = this ;\n\
}\n\
    ", "&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
\n\
void vnode::OnCopyNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
    mCommands -&gt; copyOutline();\n\
}\n\
\n@doc\n\
another doc part if, then, else, -&gt; \n&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
void vnode::OnPasteNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
    mCommands -&gt; pasteOutline();\n\
}\n" ]</t>
<t tx="ekr.20040713130853.7">def speedTest(passes):

    import time
    file = r"c:\prog\LeoPy\LeoPy.leo"
    f=open(file)
    if not f:
        print "not found: ", file
        return
    s=f.read()
    f.close()
    print "file:", file, " size:", len(s), " passes:", passes
    print "speedTest start"
    time1 = time.clock()
    p = passes
    while p &gt; 0:
        n = len(s) ; i = 0 ; lines = 0
        while -1 &lt; i &lt; n:
            if s[i] == '\n':
                lines += 1 ; i += 1
            else:
                i = s.find('\n',i) # _much_ faster than list-based-find.
            continue
            # match is about 9 times slower than simple test.
            if s[i]=='\n': # match(s,i,'\n'): # 
                i += 1
            else:
                i += 1
        p -= 1
    time2 = time.clock()
    print "lines:", lines
    print "speedTest done:"
    print "elapsed time:", time2-time1
    print "time/pass:", (time2-time1)/passes</t>
<t tx="ekr.20040713130853.15">@ We separate the processing into two parts, 1) a leo-aware driver that iterates over @file trees and 2) a text-based part that processes one or more files or strings.
</t>
<t tx="ekr.20040713130853.16">def convertCurrentTree():

    import c2py
    import leo
    import leoGlobals
    c=leoGlobals.top()
    v = c.currentVnode()
    c2py.convertLeoTree(v,c)</t>
<t tx="ekr.20040713130853.17">def convertLeoTree(v,c):

    after=v.nodeAfterTree()
    while v and v != after:
        s=v.bodyString()
        print "converting:", v.headString()
        s=convertCStringToPython(s, doLeoTranslations )
        v.setBodyStringOrPane(s)
        v=v.threadNext()
    c.Repaint() # for backward compatibility.
    print "end of c2py"</t>
<t tx="ekr.20040713130853.18">def convertCFileToPython(file):

    f=open(file, 'r')
    if not f: return
    s = f.read()
    f.close();
    f=open(file + ".py", 'w')
    if not f: return
    s = convertCStringToPython(s, dontDoLeoTranslations )
    f.write(s)
    f.close()</t>
<t tx="ekr.20040713130853.19"></t>
<t tx="ekr.20040713130853.20">def convertCStringToPython(s, leoFlag):

    # print "convertCStringToPython:start\n", s
    firstPart = True
    codeList = stringToList(s)
    
    if not leoFlag:
        convertCodeList(codeList, firstPart, dontDoLeoTranslations)
        return listToString(codeList)

    outputList = []
    i = 0
    while i &lt; len(codeList):
        j = skipCodePart(codeList,i)
        if j &gt; i:
            code = codeList[i:j]
            convertCodeList(code, firstPart, doLeoTranslations)
            i = j
            #print "-----code:", listToString(code)
            for item in code:
                outputList.append(item)
        firstPart = False # don't remove @c from here on.
        j = skipDocPart(codeList,i)
        if j &gt; i:
            doc = codeList[i:j]
            convertDocList(doc)
            #print "-----doc:", listToString(doc)
            i = j
            for item in doc:
                outputList.append(item)
    
    result = listToString(outputList)
    global printFlag
    if printFlag: print "-----:\n", result
    return result</t>
<t tx="ekr.20040713130853.21">def OLDconvert(self,list, firstPart, leoFlag):
    #first
    convertLeadingBlanks(list)
    if leoFlag:
        replaceSectionDefs(list)
    mungeAllFunctions(list)
    #next
    safeReplace(list, " -&gt; ", '.')
    safeReplace(list, "-&gt;", '.')
    safeReplace(list, " . ", '.')
    safeReplace(list, "this.self", "self")
    safeReplace(list, "{", None)
    safeReplace(list, "}", None)
    safeReplace(list, "#if", "if")
    safeReplace(list, "#else", "else")
    safeReplace(list, "#endif", None)
    safeReplace(list, "else if", "elif")
    safeReplace(list, "else", "else:")
    safeReplace(list, "&amp;&amp;", "and")
    safeReplace(list, "||", "or")
    safeReplace(list, "TRUE", "True")
    safeReplace(list, "FALSE", "False")
    safeReplace(list, "NULL", "None")
    safeReplace(list, "this", "self")
    safeReplace(list, "try", "try:")
    safeReplace(list, "catch", "except:")
    if leoFlag:
        safeReplace(list, "@code", "@c")
    #next
    handleAllKeywords(list)
    # after processing for keywords
    removeSemicolonsAtEndOfLines(list)
    #last
    if firstPart and leoFlag: removeLeadingAtCode(list)
    removeBlankLines(list)
    removeExcessWs(list)
    # your taste may vary: in Python I don't like extra whitespace
    safeReplace(list, " :", ":") 
    safeReplace(list, ", ", ",")
    safeReplace(list, " ,", ",")
    safeReplace(list, " (", "(")
    safeReplace(list, "( ", "(")
    safeReplace(list, " )", ")")
    safeReplace(list, ") ", ")")
    replaceComments(list) # should follow all calls to safeReplace
    removeTrailingWs(list)
    safeReplace(list, "\t ", "\t") # happens when deleting declarations.</t>
<t tx="ekr.20040713130853.22">def convertDocList(docList):

    # print "convertDocList:", docList
    if matchWord(docList, 0, "@doc"):
        i = skipWs(docList, 4)
        if match(docList, i, "\n"):
            i += 1
        docList[0:i] = list("@ ")</t>
<t tx="ekr.20040713130853.23">def skipDocPart(list, i):
    
    # print "skipDocPart", i
    while i &lt; len(list):
        if matchWord(list, i, "@code") or matchWord(list, i, "@c"):
            break
        elif isSectionDef(list,i):
            break
        else: i = skipPastLine(list, i)
    return i</t>
<t tx="ekr.20040713130853.24">def skipCodePart(codeList, i):
    
    # print "skipCodePart", i
    if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
        return i
    while i &lt; len(codeList):
        if match(codeList, i, "//"):
            i = skipPastLine(codeList,i)
        elif match(codeList, i, "/*"):
            i = skipCBlockComment(codeList,i)
        elif match(codeList, i, '"') or match(codeList, i, "'"):
            i = skipString(codeList,i)
        elif match(codeList, i, "\n"):
            i += 1
            if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
                break
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.27">def convertLeadingBlanks(list):

    global tabWidth
    if tabWidth &lt; 2: return
    i = 0
    while i &lt; len(list):
        n = 0
        while i &lt; len(list) and list[i] == ' ':
            n += 1 ; i += 1
            if n == tabWidth:
                list[i-tabWidth:i] = ['\t']
                i = i - tabWidth + 1
                n = 0
        i = skipPastLine(list, i)</t>
<t tx="ekr.20040713130853.28">def findInList(list, i, findStringOrList):

    findList = stringToList(findStringOrList)
    
    while i &lt; len(list):
        if match(list, i, findList): return i
        else: i += 1
    return -1</t>
<t tx="ekr.20040713130853.29">def findInCode(codeList, i, findStringOrList):

    findList = stringToList(findStringOrList)
    
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList, i, findList):
            return i
        else: i += 1
    return -1</t>
<t tx="ekr.20040713130853.30"># We scan for a '{' at the top level that is preceded by ')'
# @code and &lt; &lt; x &gt; &gt; = have been replaced by @c
def mungeAllFunctions(codeList):

    prevSemi = 0 # Previous semicolon: header contains all previous text
    i = 0
    firstOpen = None
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
            prevSemi = i
        elif match(codeList, i, '('):
            if not firstOpen:
                firstOpen = i
            i += 1
        elif match(codeList, i, '#'):
            i = skipPastLine(codeList, i)
            prevSemi = i
        elif match(codeList, i, ';'):
            i += 1
            prevSemi = i
        elif matchWord(codeList, i, "@code"):
            i += 5
            prevSemi = i # restart the scan
        elif matchWord(codeList, i, "@c"):
            i += 2 ; prevSemi = i # restart the scan
        elif match(codeList, i, "{"):
            i = handlePossibleFunctionHeader(codeList,i,prevSemi,firstOpen)
            prevSemi = i ; firstOpen = None # restart the scan
        else: i += 1</t>
<t tx="ekr.20040713130853.31"># converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader(codeList, i, prevSemi, firstOpen):

    assert(match(codeList,i,"{"))
    prevSemi = skipWsAndNl(codeList, prevSemi)
    close = prevNonWsOrNlChar(codeList, i)
    if close &lt; 0 or codeList[close] != ')':
        return 1 + skipToMatchingBracket(codeList, i)
    if not firstOpen:
        return 1 + skipToMatchingBracket(codeList, i)
    close2 = skipToMatchingBracket(codeList, firstOpen)
    if close2 != close:
        return 1 + skipToMatchingBracket(codeList, i)
    open = firstOpen
    assert(codeList[open]=='(')
    head = codeList[prevSemi:open]
    # do nothing if the head starts with "if", "for" or "while"
    k = skipWs(head,0)
    if k &gt;= len(head) or not head[k] in string.letters:
        return 1 + skipToMatchingBracket(codeList, i)
    kk = skipPastWord(head,k)
    if kk &gt; k:
        headString = listToString(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + skipToMatchingBracket(codeList, i)
    args = codeList[open:close+1]
    k = 1 + skipToMatchingBracket(codeList,i)
    body = codeList[i:k]
    #print "head:", listToString(head)
    #print "args:", listToString(args)
    #print "body:", listToString(body)
    #print "tot: ", listToString(codeList[prevSemi:k])
    head = massageFunctionHead(head)
    args = massageFunctionArgs(args)
    body = massageFunctionBody(body)
    #print "head2:", listToString(head)
    #print "args2:", listToString(args)
    #print "body2:", listToString(body)
    #print "tot2: ", listToString(codeList[prevSemi:k])
    result = []
    for item in head:
        result.append(item)
    for item in args:
        result.append(item)
    for item in body:
        result.append(item)
    codeList[prevSemi:k] = result
    return k</t>
<t tx="ekr.20040713130853.32">def massageFunctionArgs(args):
    global gClassName
    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if gClassName:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i &lt; len(args):
        i = skipWsAndNl(args, i)
        c = args[i]
        if c in string.letters:
            j = skipPastWord(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", listToString(result)
    return result</t>
<t tx="ekr.20040713130853.33">def massageFunctionHead(head):

    # print "head:", listToString(head)
    result = []
    prevWord = []
    global gClassName ; gClassName = []
    i = 0
    while i &lt; len(head):
        i = skipWsAndNl(head, i)
        if i &lt; len(head) and head[i] in string.letters:
            result = []
            j = skipPastWord(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = skipWs(head,i)
            if match(head,i,"::"):
                # Set the global to the class name.
                gClassName = listToString(prevWord)
                # print "class name:", gClassName
                i = skipWs(head, i+2)
                if i &lt; len(head) and (head[i]=='~' or head[i] in string.letters):
                    j = skipPastWord(head,i)
                    if head[i:j] == prevWord:
                        for item in list("__init__"): result.append(item)
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        for item in list("__del__"): result.append(item)
                    else:
                        # for item in "::": result.append(item)
                        for item in head[i:j]: result.append(item)
                    i = j
            else:
                for item in prevWord:result.append(item)
        else: i += 1
        
    finalResult = list("def ")
    for item in result: finalResult.append(item)
    # print "new head:", listToString(finalResult)
    return finalResult</t>
<t tx="ekr.20040713130853.34">def massageFunctionBody(body):

    body = massageIvars(body)
    body = removeCasts(body)
    body = removeTypeNames(body)
    return body</t>
<t tx="ekr.20040713130853.35">def massageIvars(body):

    if gClassName and ivarsDict.has_key(gClassName):
        ivars = ivarsDict [ gClassName ]
    else:
        ivars = []
    # print "key:ivars=", gClassName, ':', `ivars`

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif body[i] in string.letters:
            j = skipPastWord(body,i)
            word = listToString(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.36">def removeCasts(body):

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif match(body, i, '('):
            start = i
            i = skipWs(body, i+1)
            if body[i] in string.letters:
                j = skipPastWord(body,i)
                word = listToString(body[i:j])
                i = j
                if word in classList or word in typeList:
                    i = skipWs(body, i)
                    while match(body,i,'*'):
                        i += 1
                    i = skipWs(body, i)
                    if match(body,i,')'):
                        i += 1
                        # print "removing cast:", listToString(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.37"># Do _not_ remove type names when preceded by new.

def removeTypeNames(body):

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif matchWord(body, i, "new"):
            i = skipPastWord(body,i)
            i = skipWs(body,i)
            # don't remove what follows new.
            if body[i] in string.letters:
                i = skipPastWord(body,i)
        elif body[i] in string.letters:
            j = skipPastWord(body,i)
            word = listToString(body[i:j])
            if word in classList or word in typeList:
                k = skipWs(body, j)
                while match(body,k,'*'):
                    k += 1 ; j = k
                # print "Deleting type name:", listToString(body[i:j])
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.38"># converts if ( x ) to if x:
# converts while ( x ) to while x:
def handleAllKeywords(codeList):

    # print "handAllKeywords:", listToString(codeList)
    i = 0
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif ( matchWord(codeList,i,"if") or
            matchWord(codeList,i,"while") or
            matchWord(codeList,i,"for") or
            matchWord(codeList,i,"elif") ):
            i = handleKeyword(codeList,i)
        else:
            i += 1
    # print "handAllKeywords2:", listToString(codeList)</t>
<t tx="ekr.20040713130853.39">def handleKeyword(codeList,i):

    isFor = False
    if (matchWord(codeList,i,"if")):
        i += 2
    elif (matchWord(codeList,i,"elif")):
        i += 4
    elif (matchWord(codeList,i,"while")):
        i += 5
    elif (matchWord(codeList,i,"for")):
        i += 3
        isFor = True
    else: assert(0)
    # Make sure one space follows the keyword
    k = i
    i = skipWs(codeList,i)
    if k == i:
        c = codeList[i]
        codeList[i:i+1] = [ ' ', c ]
        i += 1
    # Remove '(' and matching ')' and add a ':'
    if codeList[i] == "(":
        j = removeMatchingBrackets(codeList,i)
        if j &gt; i and j &lt; len(codeList):
            c = codeList[j]
            codeList[j:j+1] = [":", " ", c]
            j = j + 2
        return j
    return i</t>
<t tx="ekr.20040713130853.40">def isWs(c):
    return c == ' ' or c == '\t'
    
def isWsOrNl(c):
    return c == ' ' or c == '\t' or c == '\n'</t>
<t tx="ekr.20040713130853.41"># returns the ending index if i points to &lt; &lt; x &gt; &gt; =
def isSectionDef(list, i):

    i = skipWs(list,i)
    if not match(list,i,"&lt;&lt;"): return False
    while i &lt; len(list) and list[i] != '\n':
        if match(list,i,"&gt;&gt;="): return i+3
        else: i += 1
    return False</t>
<t tx="ekr.20040713130853.42">def isStringOrComment(list, i):

    return match(list,i,"'") or match(list,i,'"') or match(list,i,"//") or match(list,i,"/*")</t>
<t tx="ekr.20040713130853.43"># returns True if findList matches starting at codeList[i]

def match (codeList, i, findStringOrList):

    findList = stringToList(findStringOrList)
    n = len(findList)
    j = 0
    while i+j &lt; len(codeList) and j &lt; len(findList):
        if codeList[i+j] != findList[j]:
            return False
        else:
            j += 1
            if j == n:
                return i+j
    return False</t>
<t tx="ekr.20040713130853.44">def matchWord (codeList, i, findStringOrList):

    j = match(codeList,i,findStringOrList)
    if not j:
        return False
    elif j &gt;= len(codeList):
        return True
    else:
        c = codeList[j]
        return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="ekr.20040713130853.45">def prevNonWsChar(list, i):

    i -= 1
    while i &gt;= 0 and isWs(list[i]):
        i -= 1
    return i

def prevNonWsOrNlChar(list, i):

    i -= 1
    while i &gt;= 0 and isWsOrNl(list[i]):
        i -= 1
    return i</t>
<t tx="ekr.20040713130853.46">def removeAllCComments(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            i = skipString(list,i)
        elif match(list,i,"//"):
            j = skipPastLine(list,i)
            print "deleting single line comment:", listToString(list[i:j])
            del list[i:j]
        elif match(list,i,"/*"):
            j = skipCBlockComment(list,i)
            print "deleting block comment:", listToString(list[i:j])
            del list[i:j]
        else:
            i += 1</t>
<t tx="ekr.20040713130853.47">def removeAllCSentinels(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            # string starts a line.
            i = skipString(list,i)
            i = skipPastLine(list,i)
        elif match(list,i,"/*"):
            # block comment starts a line
            i = skipCBlockComment(list,i)
            i = skipPastLine(line,i)
        elif match(list,i,"//@"):
            j = skipPastLine(list,i)
            print "deleting sentinel:", listToString(list[i:j])
            del list[i:j]
        else:
            i = skipPastLine(list,i)</t>
<t tx="ekr.20040713130853.48">def removeAllPythonComments(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            i = skipString(list,i)
        elif match(list,i,"#"):
            j = skipPastLine(list,i)
            print "deleting comment:", listToString(list[i:j])
            del list[i:j]
        else:
            i += 1</t>
<t tx="ekr.20040713130853.49">def removeAllPythonSentinels(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            # string starts a line.
            i = skipString(list,i)
            i = skipPastLine(list,i)
        elif match(list,i,"#@"):
            j = skipPastLine(list,i)
            print "deleting sentinel:", listToString(list[i:j])
            del list[i:j]
        else:
            i = skipPastLine(list,i)</t>
<t tx="ekr.20040713130853.50">def removeAtRoot (codeList):

    i = skipWs(codeList, 0)
    if matchWord(codeList,i,"@root"):
        j = skipPastLine(codeList,i)
        del codeList[i:j]

    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,"\n"):
            i = skipWs(codeList, i+1)
            if matchWord (codeList,i,"@root"):
                j = skipPastLine(codeList,i)
                del codeList[i:j]
        else: i += 1
</t>
<t tx="ekr.20040713130853.51">def removeBlankLines(codeList):

    i = 0
    while i &lt; len(codeList):
        j = i
        while j &lt; len(codeList) and (codeList[j]==" " or codeList[j]=="\t"):
            j += 1
        if j== len(codeList) or codeList[j] == '\n':
            del codeList[i:j+1]
        else:
            oldi = i
            i = skipPastLine(codeList,i)</t>
<t tx="ekr.20040713130853.52">def removeExcessWs(codeList):

    i = 0
    i = removeExcessWsFromLine(codeList,i)
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,'\n'):
            i += 1
            i = removeExcessWsFromLine(codeList,i)
        else: i += 1</t>
<t tx="ekr.20040713130853.53">def removeExcessWsFromLine(codeList,i):

    assert(i==0 or codeList[i-1] == '\n')
    i = skipWs(codeList,i)
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i): break # safe
        elif match(codeList, i, '\n'): break
        elif match(codeList, i, ' ') or match(codeList, i, '\t'):
            # Replace all whitespace by one blank.
            k = i
            i = skipWs(codeList,i)
            codeList[k:i] = [' ']
            i = k + 1 # make sure we don't go past a newline!
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.54">def removeLeadingAtCode(codeList):

    i = skipWsAndNl(codeList,0)
    if matchWord(codeList,i,"@code"):
        i = skipWsAndNl(codeList,5)
        del codeList[0:i]
    elif matchWord(codeList,i,"@c"):
        i = skipWsAndNl(codeList,2)
        del codeList[0:i]</t>
<t tx="ekr.20040713130853.55">def removeMatchingBrackets(codeList, i):

    j = skipToMatchingBracket(codeList, i)
    if j &gt; i and j &lt; len(codeList):
        # print "del brackets:", listToString(codeList[i:j+1])
        c = codeList[j]
        if c == ')' or c == ']' or c == '}':
            del codeList[j:j+1]
            del codeList[i:i+1]
            # print "returning:", listToString(codeList[i:j])
            return j - 1
        else: return j + 1
    else: return j</t>
<t tx="ekr.20040713130853.56">def removeSemicolonsAtEndOfLines(list):

    i = 0
    while i &lt; len(list):
        if isStringOrComment(list,i):
            i = skipStringOrComment(list,i)
        elif list[i] == ';':
            j = skipWs(list,i+1)
            if j &gt;= len(list) or match(list,j,'\n') or match(list,j,'#') or match(list,j,"//"):
                del list[i]
            else: i += 1
        else: i += 1</t>
<t tx="ekr.20040713130853.57">def removeTrailingWs(list):

    i = 0
    while i &lt; len(list):
        if isWs(list[i]):
            j = i
            i = skipWs(list,i)
            assert(j &lt; i)
            if i &gt;= len(list) or list[i] == '\n':
                # print "removing trailing ws:", `i-j`
                del list[j:i]
                i = j
        else: i += 1</t>
<t tx="ekr.20040713130853.58"># Replaces all occurances of findString by changeString.
# Deletes all occurances if change is None
def replace(codeList, findString, changeString):

    if len(findString)==0: return
    findList = stringToList(findString)
    changeList = stringToList(changeString)

    i = 0
    while i &lt; len(codeList):
        if match(codeList, i, findList):
            codeList[i:i+len(findList)] = changeList
            i += len(changeList)
        else: i += 1</t>
<t tx="ekr.20040713130853.59"># For Leo we expect few block comments; doc parts are much more common.

def replaceComments(codeList):

    i = 0
    if match(codeList, i, "//"):
        codeList[0:2] = ['#']
    while i &lt; len(codeList):
        if match(codeList, i, "//"):
            codeList[i:i+2] = ['#']
            i = skipPastLine(codeList,i)
        elif match(codeList, i, "/*"):
            j = skipCBlockComment(codeList,i)
            del codeList[j-2:j]
            codeList[i:i+2] = ['#']
            j -= 2 ; k = i ; delta = -1
            while k &lt; j + delta :
                if codeList[k]=='\n':
                    codeList[k:k+1] = ['\n', '#', ' ']
                    delta += 2 ; k += 3 # progress!
                else: k += 1
            i = j + delta
        elif match(codeList, i, '"') or match(codeList, i, "'"):
            i = skipString(codeList,i)
        else: i += 1</t>
<t tx="ekr.20040713130853.60"># Replaces &lt; &lt; x &gt; &gt; = by @c (at the start of lines).
def replaceSectionDefs(codeList):

    i = 0
    j = isSectionDef(codeList,i)
    if j &gt; 0: codeList[i:j] = list("@c ")

    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,"\n"):
            i += 1
            j = isSectionDef(codeList,i)
            if j &gt; i: codeList[i:j] = list("@c ")
        else: i += 1</t>
<t tx="ekr.20040713130853.61"># Replaces occurances of findString by changeString outside of C comments and strings.
# Deletes all occurances if change is None.
def safeReplace(codeList, findString, changeString):

    if len(findString)==0: return
    findList = stringToList(findString)
    changeList = stringToList(changeString)
    i = 0
    if findList[0] in string.letters: #use matchWord
        while i &lt; len(codeList):
            if isStringOrComment(codeList,i):
                i = skipStringOrComment(codeList,i)
            elif matchWord(codeList, i, findList):
                codeList[i:i+len(findList)] = changeList
                i += len(changeList)
            else: i += 1
    else: #use match
        while i &lt; len(codeList):
            if match(codeList, i, findList):
                codeList[i:i+len(findList)] = changeList
                i += len(changeList)
            else: i += 1</t>
<t tx="ekr.20040713130853.62">def skipCBlockComment(codeList, i):

    assert(match(codeList, i, "/*"))
    i += 2

    while i &lt; len(codeList):
        if match(codeList, i, "*/"): return i + 2
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.63">def skipPastLine(codeList, i):

    while i &lt; len(codeList) and codeList[i] != '\n':
        i += 1
    if i &lt; len(codeList) and codeList[i] == '\n':
        i += 1
    return i</t>
<t tx="ekr.20040713130853.64">def skipPastWord(list, i):

    assert(list[i] in string.letters or list[i]=='~')
    
    # Kludge: this helps recognize dtors.
    if list[i]=='~':
        i += 1
    
    while i &lt; len(list) and (
        list[i] in string.letters or
        list[i] in string.digits or
        list[i]=='_'):
        i += 1
    return i</t>
<t tx="ekr.20040713130853.65">def skipString(codeList, i):

    delim = codeList[i] # handle either single or double-quoted strings
    assert(delim == '"' or delim == "'")
    i += 1

    while i &lt; len(codeList):
        if codeList[i] == delim: return i + 1
        elif codeList[i] == '\\': i += 2
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.66">def skipStringOrComment(list,i):

    if match(list,i,"'") or match(list,i,'"'):
        return skipString(list,i)
    if match(list, i, "//"):
        return skipPastLine(list,i)
    elif match(list, i, "/*"):
        return skipCBlockComment(list,i)
    else: assert(0)</t>
<t tx="ekr.20040713130853.68">def skipWs(list, i):

    while i &lt; len(list):
        c = list[i]
        if c == ' ' or c == '\t':
            i += 1
        else: break
    return i
    
def skipWsAndNl(list, i):

    while i &lt; len(list):
        c = list[i]
        if c == ' ' or c == '\t' or c == '\n':
            i += 1
        else: break
    return i</t>
<t tx="ekr.20040713131315">@killcolor


indentation level depends on def, if, while, etc., not on parens.

</t>
<t tx="ekr.20040713131350">@language elisp</t>
<t tx="ekr.20040713132127.1">@ignore
@language elisp
</t>
<t tx="ekr.20040713132127.2">;;; -*-unibyte: t;-*-

;;;; igrep.el --- An improved interface to `grep` and `find`.

;;; SCCS @(#)igrep.el	2.95

;;; Description:
;;; 
;;; The `igrep' command is like `grep' except that it takes three
;;; required arguments (PROGRAM, EXPRESSION, and FILES) and an optional
;;; argument (OPTIONS) instead of just one argument (COMMAND).  The
;;; analogous `egrep' and `fgrep' commands are also defined for
;;; convenience.
;;; 
;;; The `igrep-find' command is like `igrep' except that it uses `find`
;;; to recursively `grep` a directory.  The analogous `egrep-find' and
;;; `fgrep-find' commands are also defined for convenience.
;;; 
;;; When called interactively, `igrep' and `igrep-find' (and their
;;; analogues) provide defaults for the EXPRESSION and FILES arguments
;;; based on the current word and the visited file name (if the
;;; `igrep-expression-default' and `igrep-files-default' options are
;;; set, respectively).  The `igrep-insert-default-key' option allows
;;; the default value to be inserted into the minibuffer for editing;
;;; since Emacs 20 provides that via the minibuffer history, it's only
;;; enabled for older versions by default. Other options that control
;;; the user interface are `igrep-read-options', `igrep-read-multiple-files',
;;; `igrep-verbose-prompts', and `igrep-save-buffers'.
;;; 
;;; Besides the basic `igrep-program' and `igrep-find-program' global
;;; variables, other variables control the syntax of the `grep` and
;;; `find` shell commands that are executed: `igrep-options',
;;; `igrep-expression-option', `igrep-find-prune-clause',
;;; `igrep-find-file-clause', and `igrep-find-use-xargs'.
;;; 
;;; The `igrep-use-zgrep' user option controls whether the corresponding
;;; GNU (gzip) "zPROGRAM" script is used, to `grep` compressed files.
;;; Special minibuffer history lists are maintained for the EXPRESSION
;;; and FILES arguments.
;;; 
;;; The `agrep' and `agrep-find' commands are interfaces to the
;;; approximate `grep` utility, which is distributed with the `glimpse'
;;; indexing and query tool (available from
;;; &lt;URL:http://glimpse.cs.arizona.edu:1994/&gt;).
;;; 
;;; `grep' itself can be advised to provide the `igrep' interface when
;;; it is invoked interactively (so that when it's called
;;; programmatically, it still uses the original argument list), via the
;;; `igrep-insinuate' command.  `igrep-insinuate' also defines
;;; `grep-find' as an alias for `igrep-find', `dired-do-grep' and
;;; `dired-do-grep-find' as aliases for `dired-do-igrep' and
;;; `dired-do-igrep-find', and `Buffer-menu-grep' as an alias for
;;; `Buffer-menu-igrep'.
;;; 
;;; When run interactively from Dired mode, the various `igrep' commands
;;; provide defaults for the EXPRESSION and FILES arguments that are
;;; based on the visited directory (including any inserted
;;; subdirectories) and the current file.  The alternative
;;; `dired-do-igrep' and `dired-do-igrep-find' commands respect the
;;; `dired-do-*' command conventions: a prefix argument is interpreted
;;; as the number of succeeding files to `grep`, otherwise all the
;;; marked files are `grep`ed.
;;; 
;;; The `igrep-visited-files' command provides a simple way to `grep`
;;; just those files that are being visited in buffers.  The
;;; `Buffer-menu-igrep' command does the same thing, for buffers marked
;;; for selection in Buffer Menu mode.

;;; Copyright:
;;; 
;;; Copyright  1994-1998,2000-2002 Kevin Rodgers
;;; 
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; at your option) any later version.
;;; 
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;;; 
;;; Neither my former nor current employer (Martin Marietta and
;;; Information Handling Services, respectively) has disclaimed any
;;; copyright interest in igrep.el.
;;; 
;;; Kevin Rodgers &lt;kevinr@ihs.com&gt;          Lead Software Engineer
;;; Information Handling Services           Electronic Systems Development
;;; 15 Inverness Way East, M/S A201         GO BUFFS!
;;; Englewood CO 80112-5776 USA             1+ (303) 397-2807[voice]/-2244[fax]

;;; Installation:
;;; 
;;; 1. Put this file in a directory that is a member of load-path, and
;;;    byte-compile it (e.g. with `M-x byte-compile-file') for better
;;;    performance.  You can ignore any warnings about references to free
;;;    variables and "not known to be defined" functions.
;;; 2. Put these forms in default.el or ~/.emacs:
;;;    (autoload 'igrep "igrep"
;;;       "*Run `grep` PROGRAM to match EXPRESSION in FILES..." t)
;;;    (autoload 'igrep-find "igrep"
;;;       "*Run `grep` via `find`..." t)
;;;    (autoload 'igrep-visited-files "igrep"
;;;       "*Run `grep` ... on all visited files." t)
;;;    (autoload 'dired-do-igrep "igrep"
;;;       "*Run `grep` on the marked (or next prefix ARG) files." t)
;;;    (autoload 'dired-do-igrep-find "igrep"
;;;       "*Run `grep` via `find` on the marked (or next prefix ARG) directories." t)
;;;    (autoload 'Buffer-menu-igrep "igrep"
;;;      "*Run `grep` on the files visited in buffers marked with '&gt;'." t)
;;;    (autoload 'igrep-insinuate "igrep"
;;;      "Define `grep' aliases for the corresponding `igrep' commands." t)
;;; 2. a. For completeness, you can add these forms as well:
;;;    (autoload 'grep "igrep"
;;;       "*Run `grep` PROGRAM to match EXPRESSION in FILES..." t)
;;;    (autoload 'egrep "igrep"
;;;       "*Run `egrep`..." t)
;;;    (autoload 'fgrep "igrep"
;;;       "*Run `fgrep`..." t)
;;;    (autoload 'agrep "igrep"
;;;       "*Run `agrep`..." t)
;;;    (autoload 'grep-find "igrep"
;;;       "*Run `grep` via `find`..." t)
;;;    (autoload 'egrep-find "igrep"
;;;       "*Run `egrep` via `find`..." t)
;;;    (autoload 'fgrep-find "igrep"
;;;       "*Run `fgrep` via `find`..." t)
;;;    (autoload 'agrep-find "igrep"
;;;       "*Run `agrep` via `find`..." t)
;;; 3. If you are running Windows 95/NT, you should install findutils
;;;    and grep from release 17.1 (or higher) of the Cygnus GNU-Win32
;;;    distribution.  See &lt;URL:http://www.cygnus.com/misc/gnu-win32/&gt;.

;;; Usage:
;;; 
;;; These igrep commands accept 1, 2, or 3 `C-u' prefix arguments:
;;; 	M-x igrep		M-x igrep-find
;;; 	M-x  grep		M-x  grep-find	[after `M-x igrep-insinuate']
;;; 	M-x egrep		M-x egrep-find
;;; 	M-x fgrep		M-x fgrep-find
;;; 	M-x agrep		M-x agrep-find
;;; 
;;; These igrep commands accept a single `C-u' prefix argument:
;;; 	M-x igrep-visited-files
;;; 	M-x Buffer-menu-igrep	[in the *Buffer List* buffer]
;;; 
;;; These igrep commands interpret a prefix argument like the Emacs
;;; `dired-do-*' commands:
;;; 	M-x dired-do-igrep	M-x dired-do-igrep-find
;;; 	M-x  dired-do-grep	M-x  dired-do-grep-find	[after `M-x
;;; 							 igrep-insinuate']
;;; 
;;; These Emacs commands can be used after any igrep command:
;;; 	C-x ` (M-x next-error)
;;; 	C-c C-c (M-x compile-goto-error)	[in the *igrep* buffer]

;;; Customization examples:
;;; 
;;; To ignore case by default:
;;; 	(setq igrep-options "-i")
;;; To search subdirectories by default:
;;; 	(setq igrep-find t)
;;; To search files with the GNU (gzip) zgrep script:
;;; 	(setq igrep-use-zgrep t)
;;; or define new igrep commands (this works for zegrep and zfgrep as well):
;;; 	(igrep-define zgrep)		; M-x zgrep
;;; 	(igrep-find-define zgrep)	; M-x zgrep-find
;;; To search "*.[ch]" files by default in C mode:
;;; 	(put 'igrep-files-default 'c-mode
;;; 	     (lambda () "*.[ch]"))
;;; To disable the default search expression and/or files pattern,
;;; except for specific modes:
;;; 	(setq igrep-expression-default 'ignore)
;;; 	(setq igrep-files-default 'ignore)
;;; To avoid exceeding some shells' limit on command argument length
;;; (this only searches files in the current directory):
;;; 	(setq igrep-find t
;;; 	      igrep-find-prune-clause "-type d \\! -name .")

;;; To do:
;;; 
;;; 1. Replace igrep-options with a table that maps igrep-program
;;;    to the appropriate options.
;;; 2. Generalize support for the -prune find clause (e.g. -fstype nfs).
;;; 3. Provide support for `glimpse`.
;;; 4. Add a menu interface.
;;; 5. Port to Emacs 20 (custom).

;;; Emacs Lisp Archive Entry:
;;; Filename: igrep.el
;;; Author: Kevin Rodgers &lt;kevinr@ihs.com&gt;
;;; Version: 2.95
;;; Description: An improved interface to `grep` and `find`.
;;; Keywords: search
;;; Last-Updated: 02/04/22


;;; Package interface:

(provide 'igrep)

(require 'compile)			; compile-internal, grep-regexp-alist,
					; grep-null-device

(eval-when-compile
  (require 'dired)			; dired-directory,
					; dired-get-filename,
					; dired-current-directory,
					; dired-get-marked-files,
					; dired-mark-get-files
  (or (featurep 'ange-ftp)
      (featurep 'efs)
      (condition-case nil
	  (load-library "ange-ftp")	; ange-ftp-ftp-name
	(error nil))
      (condition-case nil
	  (load-library "efs")		; efs-ftp-path
	(error nil)))
  )

</t>
<t tx="ekr.20040713132127.3">(defconst igrep-version "2.95"
  "Version of igrep.el")</t>
<t tx="ekr.20040713132127.4">


;;; User options:

</t>
<t tx="ekr.20040713132127.5">(defvar igrep-options nil

  "*The options passed by `\\[igrep]' to `igrep-program', or nil.

`-n' will automatically be passed to `igrep-program', to generate the
output expected by `\\[next-error]' and `\\[compile-goto-error]'.
`-e' will automatically be passed to `igrep-program', if it supports
that option.")</t>
<t tx="ekr.20040713132127.6">
(put 'igrep-options 'variable-interactive
     "xOptions (\"-xyz\" or nil): ")

</t>
<t tx="ekr.20040713132127.7">(defvar igrep-read-options nil
  "*If non-nil, `\\[igrep]' always prompts for options;
otherwise, it only prompts when 1 or 3 `C-u's are given as a prefix arg.")</t>
<t tx="ekr.20040713132127.8">
(put 'igrep-read-options 'variable-interactive
     "XAlways prompt for options? (t or nil): ")

</t>
<t tx="ekr.20040713132127.9">(defvar igrep-read-multiple-files nil
  "*If non-nil, `\\[igrep]' always prompts for multiple-files;
otherwise, it only prompts when 2 or 3 `C-u's are given as a prefix arg.")</t>
<t tx="ekr.20040713132127.10">
(put 'igrep-read-multiple-files 'variable-interactive
     "XAlways prompt for multiple files? (t or nil): ")

</t>
<t tx="ekr.20040713132127.11">(defvar igrep-expression-default 'current-word
  "*If non-nil, a function that returns a default EXPRESSION for `\\[igrep]'.
The function is called with no arguments and should return a string (or nil).

A different function can be specified for any particular mode by specifying
a value for that `major-mode' property; for example:
	(put 'igrep-expression-default 'dired-mode
	     'igrep-dired-file-current-word)")</t>
<t tx="ekr.20040713132127.12">
(put 'igrep-expression-default 'variable-interactive
     "SProvide a default expression? (function or nil): ")
(put 'igrep-expression-default 'dired-mode
     'igrep-dired-file-current-word)

</t>
<t tx="ekr.20040713132127.13">(defvar igrep-files-default 'igrep-buffer-file-name-pattern
  "*If non-nil, a function that returns the default FILES for `\\[igrep]'.
The function is called with no arguments and should return a string,
or a list of strings (or nil).

A different function can be specified for any particular mode by specifying
a value for that `major-mode' property; for example:
	(put 'igrep-files-default 'dired-mode
	     'igrep-dired-directory-file-pattern)")</t>
<t tx="ekr.20040713132127.14">
(put 'igrep-files-default 'variable-interactive
     "SProvide a default file pattern? (function or nil): ")
(put 'igrep-files-default 'dired-mode
     'igrep-dired-directory-file-pattern)

</t>
<t tx="ekr.20040713132127.15">(defvar igrep-verbose-prompts t
  "*If t, `\\[igrep]' prompts for arguments verbosely;
if not t but non-nil, `\\[igrep]' prompts for arguments semi-verbosely;
if nil, `\\[igrep]' prompts for arguments tersely.")</t>
<t tx="ekr.20040713132127.16">
(put 'igrep-verbose-prompts 'variable-interactive
     "XPrompt verbosely? (t, 'semi, or nil): ")

</t>
<t tx="ekr.20040713132127.17">(defvar igrep-insert-default-key
  (if (&lt; emacs-major-version 20) "\C-c\C-e")
  "*The key used to insert the default argument in the minibuffer.
In Emacs 20, the default is available via the minibuffer history \
(\\&lt;minibuffer-local-map&gt;\\[next-history-element]).")</t>
<t tx="ekr.20040713132127.18">
(put 'igrep-insert-default-key 'variable-interactive
     "kSet key to insert the default `\\[igrep]' argument in the minibuffer: ")

</t>
<t tx="ekr.20040713132127.19">(defvar igrep-save-buffers 'query
  "*If t, `\\[igrep]' first saves each modified file buffer;
if not t but non-nil, `\\[igrep]' offers to save each modified file buffer.")</t>
<t tx="ekr.20040713132127.20">
(put 'igrep-save-buffers 'variable-interactive
     "XSave modified buffers? (t, 'query, or nil): ")


;;; User variables:

</t>
<t tx="ekr.20040713132127.21">(defvar igrep-null-device
  (cond ((boundp 'grep-null-device) grep-null-device) ; Emacs 19
	((boundp 'null-device) null-device)))</t>
<t tx="ekr.20040713132127.22"> ; Emacs 20

</t>
<t tx="ekr.20040713132127.23">(defvar igrep-program "grep"
  "The default program run by `\\[igrep]' and `\\[igrep-find]'.
It must accept a `grep` expression argument and one or more file names, plus
the \"-n\" option.
If nil, `\\[igrep]' prompts for the program to run.")</t>
<t tx="ekr.20040713132127.24">(defvar igrep-expression-option
  (if (equal (call-process igrep-program nil nil nil
			   "-e" "foo" igrep-null-device)
	     1)
      "-e")
  "If non-nil, the option used to specify the EXPRESSION argument to `\\[igrep]',
to protect an initial `-' from option processing.")</t>
<t tx="ekr.20040713132127.25">(defvar igrep-program-table		; referenced by igrep-use-zgrep
  (let ((exec-directories exec-path)
	(program-obarray (make-vector 11 0)))
    (while exec-directories
      (if (and (car exec-directories)
	       (file-directory-p (car exec-directories))
	       (file-readable-p (car exec-directories)))
	  (let ((grep-programs
		 (directory-files (car exec-directories)
				  nil "grep\\(\\.exe\\)?\\'")))
	    (while grep-programs
	      ;; Check `(file-executable-p (car grep-programs))'?
	      (if (save-match-data
		    (string-match "\\.exe\\'" (car grep-programs)))
		  (intern (substring (car grep-programs) 0 -4) program-obarray)
		(intern (car grep-programs) program-obarray))
	      (setq grep-programs (cdr grep-programs)))))
      (setq exec-directories (cdr exec-directories)))
    program-obarray)
  "An obarray of available `grep` programs, passed by `igrep-read-program'
to `completing-read' when `igrep-program' is nil.")</t>
<t tx="ekr.20040713132127.26">(defvar igrep-use-zgrep
  (if (intern-soft "zgrep" igrep-program-table)
      'files)
  "If t, `\\[igrep]' searches files using the GNU (gzip) `zPROGRAM` script;
If not t but non-nil, `\\[igrep]' searches compressed FILES using `zPROGRAM`;
if nil, `\\[igrep]' searches files with `PROGRAM`.")</t>
<t tx="ekr.20040713132127.27">(defvar igrep-find nil
  "If non-nil, `\\[igrep]' searches directories using `find`.
See `igrep-find'.")</t>
<t tx="ekr.20040713132127.28">(defvar igrep-find-program "find"
  "The program run by `\\[igrep-find]'.")</t>
<t tx="ekr.20040713132127.29">(defvar igrep-find-prune-clause
  (if (equal (call-process igrep-find-program nil nil nil
			   igrep-null-device "-prune")
	     0)
      (format "-type d %s -name RCS -o -name CVS -o -name SCCS %s"
	      (shell-quote-argument "(")
	      (shell-quote-argument ")")))
  "The `find` clause used to prune directories, or nil;
see `igrep-find'.")</t>
<t tx="ekr.20040713132127.30">(defvar igrep-find-file-clause
  (format "-type f %s -name %s %s -name %s %s -name %s" ; -type l
	  (shell-quote-argument "!")
	  (shell-quote-argument "*~")	; Emacs backup
	  (shell-quote-argument "!")
	  (shell-quote-argument "*,v")	; RCS file
	  (shell-quote-argument "!")
	  (shell-quote-argument "s.*"))	; SCCS file
  "The `find` clause used to filter files passed to `grep`, or nil;
see `igrep-find'.")</t>
<t tx="ekr.20040713132127.31">(defvar igrep-find-use-xargs
  (if (equal (call-process igrep-find-program nil nil nil
			   igrep-null-device "-print0")
	     0)
      'gnu)
  "If `gnu', `\\[igrep-find]' executes
	`find ... -print0 | xargs -0 -e grep ...`;
if not `gnu' but non-nil, `\\[igrep-find]' executes
	`find ... -print | xargs -e grep ...`;
if nil, `\\[igrep-find]' executes
	`find ... -exec grep ...`.")</t>
<t tx="ekr.20040713132127.32">(defvar igrep-program-default "grep"
  "The default `grep` program, passed by `igrep-read-program'
to `completing-read' when `igrep-program' is nil.")</t>
<t tx="ekr.20040713132127.33">


;;; Internal variables:

</t>
<t tx="ekr.20040713132127.34">(defvar igrep-expression-history '()
  "The minibuffer history list for `\\[igrep]'s EXPRESSION argument.")</t>
<t tx="ekr.20040713132127.35">(defvar igrep-files-history '()
  "The minibuffer history list for `\\[igrep]'s FILES argument.")</t>
<t tx="ekr.20040713132127.36">


;;; Commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.37">(defun igrep-insinuate (&amp;optional override)
  "Define `grep' aliases for the corresponding `igrep' commands.
With a prefix arg, override the current `grep` command definitions."
  (interactive "P")
  (if override
      (defalias 'grep 'igrep)
    (defadvice grep (around igrep-interactive first (&amp;rest command-args)
			    activate)
      "If called interactively, use the `\\[igrep]' interface instead,
where COMMAND-ARGS is (PROGRAM EXPRESSION FILES [OPTIONS]);
if called programmatically, COMMAND-ARGS is still (COMMAND)."
      (interactive (igrep-read-args))
      (if (interactive-p)
	  (apply 'igrep command-args)
	ad-do-it)))
  (if (or (not (fboundp 'grep-find))
	  override)
      (defalias 'grep-find 'igrep-find))
  (if (or (not (fboundp 'dired-do-grep))
	  override)
      (defalias 'dired-do-grep 'dired-do-igrep))
  (if (or (not (fboundp 'dired-do-grep-find))
	  override)
      (defalias 'dired-do-grep-find 'dired-do-igrep-find))
  (if (or (not (fboundp 'Buffer-menu-grep))
	  override)
      (defalias 'Buffer-menu-grep 'Buffer-menu-igrep)))</t>
<t tx="ekr.20040713132127.38">

;;;###autoload
</t>
<t tx="ekr.20040713132127.39">(defun igrep (program expression files &amp;optional options)
  "*Run `grep` PROGRAM to match EXPRESSION in FILES.
The output is displayed in the *igrep* buffer, which `\\[next-error]' and
`\\[compile-goto-error]' parse to find each line of matched text.

PROGRAM may be nil, in which case it defaults to `igrep-program'.

EXPRESSION is automatically quoted by `shell-quote-argument'.

FILES is either a file name pattern (expanded by the shell named by
`shell-file-name') or a list of file name patterns.

Optional OPTIONS is also passed to PROGRAM; it defaults to `igrep-options'.

If a prefix argument \
\(`\\[universal-argument]') \
is given when called interactively,
or if `igrep-read-options' is set, OPTIONS is read from the minibuffer.

If two prefix arguments \
\(`\\[universal-argument] \\[universal-argument]') \
are given when called interactively,
or if `igrep-read-multiple-files' is set, FILES is read from the minibuffer
multiple times.

If three prefix arguments \
\(`\\[universal-argument] \\[universal-argument] \\[universal-argument]') \
are given when called interactively,
or if `igrep-read-options' and `igrep-read-multiple-files' are set,
OPTIONS is read and FILES is read multiple times.

If `igrep-find' is non-nil, the directory or directories
containing FILES is recursively searched for files whose name matches
the file name component of FILES (and whose contents match EXPRESSION)."
  (interactive
   (igrep-read-args))
  (if (null program)
      (setq program (or igrep-program "grep")))
  (if (null options)
      (setq options igrep-options))
  (if (not (listp files))		; (stringp files)
      (setq files (list files)))
  (if (and (member ?~ (mapcar 'string-to-char files))
	   (save-match-data
	     (string-match "\\`[rj]?sh\\(\\.exe\\)?\\'"
			   (file-name-nondirectory shell-file-name))))
      ;; (restricted, job-control, or standard) Bourne shell doesn't expand ~:
      (setq files
	    (mapcar 'expand-file-name files)))
  (let* ((use-zgrep (cond ((eq igrep-use-zgrep t))
			  (igrep-use-zgrep
			   (let ((files files)
				 (compressed-p nil))
			     (while (and files (not compressed-p))
			       (if (save-match-data
				     (string-match "\\.g?[zZ]\\'" (car files)))
				   (setq compressed-p t))
			       (setq files (cdr files)))
			     compressed-p))
			  (t nil)))
	 (command (format "%s -n %s %s %s %s %s"
			  (if (and use-zgrep
				   (save-match-data
				     (not (string-match "\\`z" program))))
			      (setq program (concat "z" program))
			    program)
			  (or options "")
			  (or igrep-expression-option
			      (progn
				(if (save-match-data
				      (string-match "\\`-" expression))
				    (setq expression (concat "\\" expression)))
				""))
			  (shell-quote-argument expression)
			  (if igrep-find
			      (if igrep-find-use-xargs
				  ""
				(shell-quote-argument "{}"))
			    (mapconcat (lambda (file)
					 (let ((dir (file-name-directory file)))
					   (if dir
					       (expand-file-name
						(file-name-nondirectory file)
						(shell-quote-argument dir))
					     file)))
				       files " "))
			  igrep-null-device)))
    (if igrep-find
	(setq command
	      (igrep-format-find-command command files)))
    (cond ((eq igrep-save-buffers t) (save-some-buffers t))
	  (igrep-save-buffers (save-some-buffers)))
    (compile-internal command (format "No more %s matches" program)
		      "igrep" nil grep-regexp-alist)))</t>
<t tx="ekr.20040713132127.40">

;; Analogue commands:

(defmacro igrep-define (analogue-command &amp;rest igrep-bindings)
  "Define ANALOGUE-COMMAND as an `igrep' analogue command.
Optional (VARIABLE VALUE) arguments specify temporary bindings for the command."
;;;  (interactive "SCommand: ") ; C-u =&gt; read bindings?
  (let ((analogue-program (symbol-name analogue-command)))
    `(defun ,analogue-command (&amp;rest igrep-args)
       ,(format "*Run `%s` via `\\[igrep]'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
		analogue-program)
       (interactive
	(let ((igrep-program (if igrep-program ,analogue-program))
	      (igrep-program-default ,analogue-program))
	  (igrep-read-args)))
       (let (,@ igrep-bindings)
	 (apply 'igrep
		(cond ((interactive-p) (car igrep-args))
		      ((car igrep-args))
		      (t ,analogue-program))
		(cdr igrep-args))))))

(igrep-define egrep)
(igrep-define fgrep)
(igrep-define agrep
  (igrep-use-zgrep nil)
  (igrep-expression-option "-e"))


;; Recursive (`find`) commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.41">(defun igrep-find (&amp;rest igrep-args)
  "*Run `grep` via `find`; see `igrep' and `igrep-find'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
  (interactive
   (let ((igrep-find t))
     (igrep-read-args)))
  (let ((igrep-find t))
    (apply 'igrep igrep-args)))</t>
<t tx="ekr.20040713132127.42">

;; Analogue recursive (`find`) commands:

(defmacro igrep-find-define (analogue-command &amp;rest igrep-bindings)
  "Define ANALOGUE-COMMAND-find as an `igrep' analogue `find` command.
Optional (VARIABLE VALUE) arguments specify temporary bindings for the command."
;;;  (interactive "SCommand: ") ; C-u =&gt; read bindings?
  (let ((analogue-program (symbol-name analogue-command)))
    (setq analogue-command
	  (intern (format "%s-find" analogue-command)))
    `(defun ,analogue-command (&amp;rest igrep-args)
       ,(format "*Run `%s` via `\\[igrep-find]'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
		analogue-program)
       (interactive
	(let ((igrep-program (if igrep-program ,analogue-program))
	      (igrep-program-default ,analogue-program)
	      (igrep-find t))
	  (igrep-read-args)))
       (let (,@ igrep-bindings)
	 (apply 'igrep-find
		(cond ((interactive-p) (car igrep-args))
		      ((car igrep-args))
		      (t ,analogue-program))
		(cdr igrep-args))))))

(igrep-find-define egrep)
(igrep-find-define fgrep)
(igrep-find-define agrep
  (igrep-use-zgrep nil)
  (igrep-expression-option "-e"))

;;;###autoload
</t>
<t tx="ekr.20040713132127.43">(defun igrep-visited-files (program expression &amp;optional options)
  "*Run `grep` PROGRAM to match EXPRESSION (with optional OPTIONS) \
on all visited files.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args (igrep-read-args 'no-files)))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     igrep-args))
  (igrep program expression
	 (let ((directory-abbrev-alist
		(cons (cons (regexp-quote (expand-file-name default-directory))
			    "./")	; or even ""
		      directory-abbrev-alist)))
	   (mapcar 'abbreviate-file-name
		   (apply 'nconc
			  (mapcar (lambda (buffer)
				    (let ((file (buffer-file-name buffer)))
				      (if (and file
					       (cond ((featurep 'ange-ftp)
						      (not (ange-ftp-ftp-name file)))
						     ((featurep 'efs)
						      (not (efs-ftp-path file)))
						     (t t))
					       ;; (file-exists-p file)
					       )
					  (list file))))
				  (buffer-list)))))
	 options))</t>
<t tx="ekr.20040713132127.44">


;; Dired commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.45">(defun dired-do-igrep (program expression &amp;optional options arg)
  "*Run `grep` on the marked (or next prefix ARG) files.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args
	  (let ((current-prefix-arg nil))
	    (igrep-read-args t))))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     ;; Append ARG:
     (nconc igrep-args (list current-prefix-arg))))
  (igrep program
	 expression
	 (funcall (cond ((fboundp 'dired-get-marked-files) ; GNU Emacs
			 'dired-get-marked-files)
			((fboundp 'dired-mark-get-files) ; XEmacs
			 'dired-mark-get-files))
		  t arg)
	 options))</t>
<t tx="ekr.20040713132127.46">



;; Dired recursive (`find`) commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.47">(defun dired-do-igrep-find (program expression &amp;optional options arg)
  "*Run `grep` on the marked (or next prefix ARG) directories.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args
	  (let ((current-prefix-arg nil)
		(igrep-find t))
	    (igrep-read-args t))))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     ;; Append ARG:
     (nconc igrep-args (list current-prefix-arg))))
  (let ((igrep-find t))
    (dired-do-igrep program expression options arg)))</t>
<t tx="ekr.20040713132127.48">



;; Buffer menu commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.49">(defun Buffer-menu-igrep (program expression &amp;optional options)
  "*Run `grep` on the files visited in buffers marked with '&gt;'.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args (igrep-read-args 'no-files)))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     igrep-args))
  ;; See Buffer-menu-select:
  (let ((marked-files '())
	marked-buffer
	file)
    (goto-char (point-min))
    (while (search-forward "\n&gt;" nil t)
      (setq marked-buffer (Buffer-menu-buffer t)
	    file (buffer-file-name marked-buffer))
      (if (and file
	       ;; local:
	       (cond ((featurep 'ange-ftp)
		      (not (ange-ftp-ftp-name file)))
		     ((featurep 'efs)
		      (not (efs-ftp-path file)))
		     (t t)))
	  (setq marked-files (cons file marked-files)))
;;;    (let ((buffer-read-only nil))
;;;      (delete-char -1)
;;;      (insert ?\ ))
      )
    (setq marked-files (nreverse marked-files))
    (igrep program expression
	   (let ((directory-abbrev-alist
		  (cons (cons (regexp-quote (expand-file-name default-directory))
			      "./")	; or even ""
			directory-abbrev-alist)))
	     (mapcar 'abbreviate-file-name marked-files))
	   options)))</t>
<t tx="ekr.20040713132127.50">


;;; User functions:

</t>
<t tx="ekr.20040713132127.51">(defun igrep-dired-file-current-word ()
  "Return the current word in the file on this line, if it is visible;
else, return the file name on this line, if there is one;
otherwise, return the current word."
  (let* ((dired-file
	  (dired-get-filename t t))
	 (dired-file-buffer
	  (if dired-file
	      (get-file-buffer (expand-file-name dired-file))))
	 (dired-file-buffer-window
	  (if dired-file-buffer
	      (get-buffer-window dired-file-buffer))))
    (cond (dired-file-buffer-window (save-excursion
				      (set-buffer dired-file-buffer)
				      (current-word)))
	  (dired-file)
	  (t (current-word)))))</t>
<t tx="ekr.20040713132127.52">(defun igrep-buffer-file-name-pattern ()
  "Return a shell file name pattern based on `buffer-file-name', or \"*\"."
  ;; (Based on other-possibly-interesting-files in ~/as-is/unix.el, by
  ;; Wolfgang Rupprecht &lt;wolfgang@mgm.mit.edu&gt;.)
  (if buffer-file-name
      (let ((file-name (file-name-nondirectory buffer-file-name)))
	(concat "*"
		(save-match-data
		  (if (string-match "\\.[^.]+\\(\\.g?[zZ]\\)?\\'"
				    file-name)
		      (substring file-name (match-beginning 0)
				 (match-end 0))))))
    "*"))</t>
<t tx="ekr.20040713132127.53">(defun igrep-dired-directory-file-pattern ()
"Return a shell file name pattern based on `dired-directory', or \"*\"."
  (cond ((stringp dired-directory)
	 (if (file-directory-p dired-directory)
	     "*"
	   (file-name-nondirectory dired-directory))) ; wildcard
	((consp dired-directory)	; (DIR FILE ...)
	 (mapconcat 'identity (cdr dired-directory) " "))))</t>
<t tx="ekr.20040713132127.54">


;;; Utilities:

(defsubst igrep-file-directory (name)
  "Return the directory component of NAME, or \".\" if it has no
directory component."
  (directory-file-name (or (file-name-directory name)
			   (file-name-as-directory "."))))

(defsubst igrep-file-pattern (name)
  "Return the file component of NAME, or \"*\" if it has no file component."
  (let ((pattern (file-name-nondirectory name)))
       (if (string= pattern "")
	   "*"
	 pattern)))

</t>
<t tx="ekr.20040713132127.55">(defun igrep-format-find-command (command files)
  "Format `grep` COMMAND to be invoked via `find` on FILES."
  (let ((directories '())
	(patterns '()))
    (while files
      (let ((dir (igrep-file-directory (car files)))
	    (pat (igrep-file-pattern (car files))))
	(if (and (not (string= dir "."))
		 (file-symlink-p dir))
	    (setq dir (concat dir "/.")))
	(if (not (member dir directories))
	    (setq directories (cons dir directories)))
	(cond ((equal pat "*")
	       (setq patterns t))
	      ((and (listp patterns)
		    (not (member pat patterns)))
	       (setq patterns (cons pat patterns)))))
      (setq files (cdr files)))
    (format (cond ((eq igrep-find-use-xargs 'gnu)
		   ;; | \\\n
		   "%s %s %s %s %s -print0 | xargs -0 -e %s")
		  (igrep-find-use-xargs
		   ;; | \\\n
		   "%s %s %s %s %s -print | xargs -e %s")
		  (t
		   "%s %s %s %s %s -exec %s %s"))
	    igrep-find-program
	    (mapconcat 'shell-quote-argument (nreverse directories)
		       " ")
	    (if igrep-find-prune-clause
		(format "%s -prune -o" igrep-find-prune-clause)
	      "")
	    (or igrep-find-file-clause "")
	    (if (listp patterns)
		(if (cdr patterns)	; (&gt; (length patterns) 1)
		    (format "%s %s %s"
			    (shell-quote-argument "(")
			    (mapconcat (lambda (pat)
					 (format "-name %s"
						 (shell-quote-argument pat)))
				       (nreverse patterns)
				       " -o ")
			    (shell-quote-argument ")"))
		  (format "-name %s" (shell-quote-argument (car patterns))))
	      "")
	    command
	    (shell-quote-argument ";")
	    )))</t>
<t tx="ekr.20040713132127.56">

(defmacro igrep-default-arg (variable)
  "Return the default arg based on VARIABLE."
  `(if ,variable
       (cond ((get (quote ,variable) major-mode)
	      (funcall (get (quote ,variable) major-mode)))
	     (t (funcall ,variable)))))

</t>
<t tx="ekr.20040713132127.57">(defun igrep-default-expression ()
  (igrep-default-arg igrep-expression-default))</t>
<t tx="ekr.20040713132127.58">(defun igrep-default-files ()
  (let* ((dired-subdirectory (if (eq major-mode 'dired-mode)
				 (dired-current-directory t)))
	 (default-files (igrep-default-arg igrep-files-default)))
    (if (not (listp default-files))	; stringp
	(setq default-files (list default-files)))
    (if dired-subdirectory
	(mapcar (lambda (file)
		  (concat dired-subdirectory file))
		default-files)
      default-files)))</t>
<t tx="ekr.20040713132127.59">

(defsubst igrep-prefix (prefix string &amp;rest strings)
  "If PREFIX is non-nil or any STRINGS are specified, concatenate them
before and after STRING; otherwise, return the STRING."
  (if (or prefix strings)
      (apply 'concat prefix string strings)
    string))

</t>
<t tx="ekr.20040713132127.60">(defun igrep-read-args (&amp;optional no-files)
  "Read and return a list: (PROGRAM EXPRESSION FILES OPTIONS).
If NO-FILES is non-nil, then FILES is not read and nil is returned
in its place."
  (let* ((pre-prefix (if (and igrep-find (eq igrep-verbose-prompts t))
			 "[find] "))
	 (program
	  (igrep-read-program pre-prefix))
	 (prefix (if (and program (eq igrep-verbose-prompts t))
		     (igrep-prefix pre-prefix program " ")
		   pre-prefix))
	 (options
	  (igrep-read-options prefix))
	 (post-prefix (if (and options (eq igrep-verbose-prompts t))
			    (igrep-prefix prefix options " ")
			  prefix)))
    (list program
	  (igrep-read-expression post-prefix)
	  (if (not no-files)
	      (igrep-read-files post-prefix))
	  options)))</t>
<t tx="ekr.20040713132127.61">(defun igrep-read-program (&amp;optional prompt-prefix)
  "If `igrep-program' is nil, read and return a program name from the
minibuffer; otherwise, return `igrep-program'.
Optional PROMPT-PREFIX is prepended to the \"Program: \" prompt."
  (or igrep-program
      (let ((prompt "Program: "))
	(completing-read (igrep-prefix prompt-prefix prompt) igrep-program-table
			 nil t igrep-program-default))))</t>
<t tx="ekr.20040713132127.62">(defun igrep-read-options (&amp;optional prompt-prefix)
  "If `current-prefix-arg' is '(4) or '(64), read and return an options
string from the minibuffer; otherwise, return `igrep-options'.
Optional PROMPT-PREFIX is prepended to the \"Options: \" prompt."
  (if (or igrep-read-options
	  (and (consp current-prefix-arg)
	       (memq (prefix-numeric-value current-prefix-arg)
		     '(4 64))))
      (let ((prompt "Options: "))
	(read-string (igrep-prefix prompt-prefix prompt)
		     (or igrep-options "-")))
    igrep-options))</t>
<t tx="ekr.20040713132127.63">(defun igrep-read-expression (&amp;optional prompt-prefix)
  "Read and return a `grep` expression string from the minibuffer.
Optional PROMPT-PREFIX is prepended to the \"Expression: \" prompt."
  (if igrep-insert-default-key
      (define-key minibuffer-local-map igrep-insert-default-key
	'igrep-insert-default-expression))
  (let* ((default-expression (igrep-default-expression))
	 (prompt (igrep-prefix prompt-prefix
			       (if default-expression
				   (format "Expression [default: %s]: "
					   default-expression)
				 "Expression: ")))
	 (expression (cond ((and (featurep 'xemacs) (emacs-version&gt;= 21 4))
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history
						  nil ; ABBREV-TABLE
						  default-expression))
			   ((and (not (featurep 'xemacs))
				 (&gt;= emacs-major-version 20))
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history
						  default-expression))
			   (t
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history)))))
    (if (equal expression "")
	(progn
	  (or (equal default-expression (car igrep-expression-history))
	      (setq igrep-expression-history
		    (cons default-expression igrep-expression-history)))
	  default-expression)
      expression)))</t>
<t tx="ekr.20040713132127.64">(defun igrep-insert-default-expression (&amp;optional clear-minibuffer)
  "*Insert the default expression in the minibuffer.
If a prefix argument is specified, clear the minibuffer contents first."
  (interactive "P")
  (if clear-minibuffer
      (delete-region (if (fboundp 'minibuffer-prompt-end) ; Emacs 21
			 (minibuffer-prompt-end)
		       (point-min))
		     (point-max)))
  (insert (or (save-excursion
		(set-buffer (window-buffer minibuffer-scroll-window))
		(igrep-default-expression))
	      "")))</t>
<t tx="ekr.20040713132127.65">(defun igrep-insert-default-files (&amp;optional clear-minibuffer)
  "*Insert the default files in the minibuffer.
If a prefix argument is specified, clear the minibuffer contents first."
  (interactive "P")
  (if clear-minibuffer
      (delete-region (if (fboundp 'minibuffer-prompt-end) ; Emacs 21
			 (minibuffer-prompt-end)
		       (point-min))
		     (point-max)))
  (insert (mapconcat 'identity
		     (save-excursion
		       (set-buffer (window-buffer minibuffer-scroll-window))
		       (igrep-default-files))
		     " ")))</t>
<t tx="ekr.20040713132127.66">

(defsubst igrep-default-key (command &amp;optional keymap key)
  "Return the key bound to COMMAND in KEYMAP, preferably KEY."
  (if (null keymap)
      (setq keymap (current-global-map)))
  (if (and key
	   (eq (lookup-key keymap key) command))
      key
    (where-is-internal command keymap t)))

</t>
<t tx="ekr.20040713132127.67">(defun igrep-read-files (&amp;optional prompt-prefix)
  "Read and return a file name pattern from the minibuffer.
If `current-prefix-arg' is '(16) or '(64), read multiple file name
patterns and return them in a list.  Optional PROMPT-PREFIX is
prepended to the \"File(s): \" prompt."
  (let* ((default-files (igrep-default-files))
	 (default-files-string (mapconcat 'identity default-files " "))
	 (insert-default-directory nil)	; use relative path names
	 (file (igrep-read-file-name
		(igrep-prefix prompt-prefix
			      (if default-files
				  (format "File(s) [default: %s]: "
					  default-files-string)
				"File(s): "))
		nil default-files-string nil nil
		'igrep-files-history))
	 (files (cond ((equal file default-files-string)
		       (setq file default-files))
		      ((not (listp file))
		       (setq file (list file))))))
    (if (or igrep-read-multiple-files
	    (and (consp current-prefix-arg)
		 (memq (prefix-numeric-value current-prefix-arg)
		       '(16 64))))
	(let ((prompt
	       (igrep-prefix prompt-prefix
			     (if igrep-verbose-prompts
				 (format "File(s): [Type `%s' when done] "
					 (key-description
					  (igrep-default-key 'exit-minibuffer
							     minibuffer-local-completion-map
							     "\r")))
			       "File(s): "))))
	  (while (not (string= (setq file
				     (igrep-read-file-name prompt
							   nil "" nil nil
							   'igrep-files-history))
			       ""))
	    (setq files (cons file files)))
	  (nreverse files))
      files)))</t>
<t tx="ekr.20040713132127.68">(defun igrep-read-file-name (prompt
  &amp;optional directory default existing initial history)
  "Just like `read-file-name', but with optional HISTORY.
Also: convert DIRECTORY to DIRECTORY/* file name pattern."
  (if igrep-insert-default-key
      (define-key minibuffer-local-completion-map igrep-insert-default-key
	'igrep-insert-default-files))
  (let ((file-name
	 (if history
	     (let ((file-name-history (symbol-value history)))
	       (prog1 (read-file-name prompt directory default existing initial)
		 (set history file-name-history)))
	   (read-file-name prompt directory default existing initial))))
    (if (and (not (string-equal file-name ""))
	     (file-directory-p file-name))
	(expand-file-name "*" file-name)
      file-name)))</t>
<t tx="ekr.20040713132127.69">
;;; Local Variables:
;;; eval: (put 'igrep-define 'lisp-indent-hook 1)
;;; eval: (put 'igrep-find-define 'lisp-indent-hook 1)
;;; End:

;;;; igrep.el ends here
</t>
<t tx="ekr.20040713133131">; -&gt; #

'x --&gt; x (??)

"multilline comment" --&gt; """multilline comment"""

strip parens from cond, etc.</t>
<t tx="ekr.20040713133131.1">defFun -&gt; def

lambda -&gt; ?

cond -&gt; if, elif, ... else

prog, progn -&gt; while

defvar x y --&gt; x = y  (or self.x = y) ??</t>
<t tx="ekr.20040713133131.2">(if (equal (call-process igrep-program nil nil nil
			   "-e" "foo" igrep-null-device)
	     1)
      "-e")

if (&lt; emacs-major-version 20) "\C-c\C-e")  -&gt; if &lt;cond&gt;: &lt;val&gt;

(&lt; a b) --&gt; a &lt; b

(x args) --&gt; x(args)</t>
<t tx="ekr.20040713144036">class elisp2pyClass:
    
    """A class to convert elisp programs into Python syntax."""
    
    @others</t>
<t tx="ekr.20040713144036.1">def __init__ (self,c,p,*args,**keys):
    
    self.c = c
    self.p = p
    self.tabwidth = 4

    &lt;&lt; define elisp constants &gt;&gt;
    &lt;&lt; define elisp statements &gt;&gt;
    &lt;&lt; define elisp functions &gt;&gt;
    
    self.allStatements = list(self.statements)
    self.allStatements.extend(self.functions)
    
    &lt;&lt; define code gen dispatch table &gt;&gt;</t>
<t tx="ekr.20040713144336"></t>
<t tx="ekr.20040713144926">def tokenize (self,s):
    
    e = self
    name1 = string.letters + '_'
    result = []
    if not s.strip():
        return result

    i = 0 ; n = len(s) ; progress = -1
    while i &lt; n:
        assert(i &gt; progress)
        progress = i
        ch = s[i]
        if ch == '\r':
            i += 1
        elif ch in "@'()[]{}&lt;&gt;\n": # Handle single-quote here?
            result.append(tok(ch,ch))
            i += 1
        elif ch in "\ \t":
            j = g.skip_ws(s,i) # Doesn't handle ff, so ff loops.
            ws = s[i:j]
            result.append(tok("ws",ws))
            i = j
        elif ch == '\f':
            result.append(tok("form-feed",'\f'))
            i += 1
        elif ch == '"':
            j = e.skipString(s,i)
            val = s[i:j]
            result.append(tok("string",val))
            i = j
        elif ch in name1:
            j = g.skip_id(s,i,chars='-*') # '-*' valid in elisp.
            val = s[i:j]
            result.append(tok("id",val))
            i = j
        elif ch in string.digits:
            j,value = g.skip_long(s,i)
            val = s[i:j]
            result.append(tok("number",val))
            i = j
        elif ch == ';':
            j = g.skip_to_end_of_line(s,i)
            val = s[i:j]
            result.append(tok("comment",val))
            i = j
        else:
            result.append(tok("misc",ch))
            i += 1
            
    return result</t>
<t tx="ekr.20040713144926.1"></t>
<t tx="ekr.20040713144926.2"></t>
<t tx="ekr.20040713144926.3"></t>
<t tx="ekr.20040713144926.4"></t>
<t tx="ekr.20040713150037">class tok:
    
    """ A class representing an elisp or python token"""
    
    @others</t>
<t tx="ekr.20040713150037.1">def __init__ (self,kind,val="",parseTree=None):
    
    self.kind = kind
    self.val = val
    self.parseTree = parseTree</t>
<t tx="ekr.20040713150314.1">def replaceAll (self,tokens,findKind,changeTok):
    
    self = e

    result = []
    for token in tokens:
        if token.kind == findKind:
            result.append(changeTok.copy())
        else:
            result.append(token)</t>
<t tx="ekr.20040713150712">def copy (self,token):
    
    return tok(self.kind,self.val)</t>
<t tx="ekr.20040713150856.1"></t>
<t tx="ekr.20040713150856.8">@ These scanners all call g.scanError() directly or indirectly, so they will call g.es() if they find an error.  g.scanError() also bumps c.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="ekr.20040713150856.9"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

    assert(g.match(s,i,"/*"))
    j = i ; i += 2 ; n = len(s)
    
    k = string.find(s,"*/",i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    else: return k + 2</t>
<t tx="ekr.20040713150856.10">@ This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

    """Skips from the opening to the matching brace.
    
    If no matching is found i is set to len(s)"""

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,'//'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        # 7/29/02: be more careful handling conditional code.
        elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta = g.skip_pp_if(s,i)
            level += delta
        else: i += 1
    return i
</t>
<t tx="ekr.20040713150856.12">def skip_parens(s,i):

    """Skips from the opening ( to the matching ).
    
    If no matching is found i is set to len(s)"""

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))
    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:  return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i</t>
<t tx="ekr.20040713150856.13">def skip_pascal_begin_end(s,i):

    """Skips from begin to matching end.
    If found, i points to the end. Otherwise, i &gt;= len(s)
    The end keyword matches begin, case, class, record, and try."""

    assert(g.match_c_word(s,i,"begin"))
    level = 1 ; i = g.skip_c_id(s,i) # Skip the opening begin.
    while i &lt; len(s):
        ch = s[i]
        if ch =='{' : i = g.skip_pascal_braces(s,i)
        elif ch =='"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.match_c_word(s,i,"end"):
            level -= 1 ;
            if level == 0:
                # lines = s[i1:i+3] ; g.trace('\n' + lines + '\n')
                return i
            else: i = g.skip_c_id(s,i)
        elif g.is_c_id(ch):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else: i += 1
    return i
</t>
<t tx="ekr.20040713150856.14"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):
    
    j = i
    assert(g.match(s,i,"(*"))
    i = string.find(s,"*)",i)
    if i &gt; -1: return i + 2
    else:
        g.scanError("Run on comment" + s[j:i])
        return len(s)</t>
<t tx="ekr.20040713150856.15">def skip_pascal_string(s,i):

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    while i &lt; len(s):
        if s[i] == delim:
            return i + 1
        else: i += 1

    g.scanError("Run on string: " + s[j:i])
    return i</t>
<t tx="ekr.20040713150856.20">def skip_python_string(s,i):

    if g.match(s,i,"'''") or g.match(s,i,'"""'):
        j = i ; delim = s[i]*3 ; i += 3
        k = string.find(s,delim,i)
        if k &gt; -1: return k+3
        g.scanError("Run on triple quoted string: " + s[j:i])
        return len(s)
    else:
        return g.skip_string(s,i)</t>
<t tx="ekr.20040713150856.21">def skip_string(s,i):
    
    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')
    
    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20040713150856.22"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c == ';': return i
        elif c == '\'' or c == '"' : i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i</t>
<t tx="ekr.20040713150856.24"></t>
<t tx="ekr.20040713150856.25"># Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 &gt;= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1</t>
<t tx="ekr.20040713150856.26">def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1</t>
<t tx="ekr.20040713150856.27">def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k &gt; -1: return k
    else: return None</t>
<t tx="ekr.20040713150856.28">def is_c_id(ch):

    return ch and (ch in string.ascii_letters or ch in string.digits or ch == '_')
</t>
<t tx="ekr.20040713150856.29">def is_nl(s,i):

    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')</t>
<t tx="ekr.20040713150856.30"># We no longer require that the directive appear before any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i &lt; len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1</t>
<t tx="ekr.20040713150856.31">def is_ws(c):

    return c == '\t' or c == ' '
    
def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i &lt; len(s) and g.is_ws(s[i]))</t>
<t tx="ekr.20040713150856.32"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i</t>
<t tx="ekr.20040713150856.33">def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))</t>
<t tx="ekr.20040713150856.34">def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)</t>
<t tx="ekr.20040713150856.35">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if string.find(s,pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    c = s[i+j]
    return not (c in string.ascii_letters or c in string.digits or c == '_')</t>
<t tx="ekr.20040713150856.36">def skip_blank_lines(s,i):

    while i &lt; len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i</t>
<t tx="ekr.20040713150856.37">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i</t>
<t tx="ekr.20040713150856.38">def skip_id(s,i,chars=None):

    n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
</t>
<t tx="ekr.20040713150856.39">@ These methods skip to the next newline, regardless of whether the newline may be preceded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i</t>
<t tx="ekr.20040713150856.40">def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i &lt; n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20040713150856.41">def skip_matching_delims(s,i,delim1,delim2):
    
    assert(g.match(s,i,delim1))

    i += len(delim1)
    k = string.find(s,delim2,i)
    if k == -1:
        return len(s)
    else:
        return k + len(delim2)</t>
<t tx="ekr.20040713150856.42"># We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i</t>
<t tx="ekr.20040713150856.43">def skip_non_ws (s,i):

    n = len(s)
    while i &lt; n and not g.is_ws(s[i]):
        i += 1
    return i</t>
<t tx="ekr.20040713150856.44"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k</t>
<t tx="ekr.20040713150856.45">def skip_to_char(s,i,ch):
    
    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
</t>
<t tx="ekr.20040713150856.46">def skip_ws(s,i):

    n = len(s)
    while i &lt; n and g.is_ws(s[i]):
        i += 1
    return i
    
def skip_ws_and_nl(s,i):

    n = len(s)
    while i &lt; n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i</t>
<t tx="ekr.20040713150856.47">def splitLines (s):
    
    """Split s into lines, preserving the number of lines and the ending of the last line."""
    
    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

def joinLines (aList):
    
    return ''.join(aList)</t>
<t tx="ekr.20040713151556.1">def findMatchingBracket(self,tokens,i):

    tok1 = tokens[i] ; i += 1
    assert tok1.kind in "({["
   
    if   tok1.kind == '(': delim = ')'
    elif tok1.kind == '{': delim = '}'
    else:                  delim = ']'

    level = 1
    while i &lt; len(tokens):
        tok = tokens[i]
        # g.trace(level,delim,tok.kind)
        i += 1
        if tok.kind == tok1.kind:
            level += 1
        elif tok.kind == delim:
            level -= 1
            if level == 0: return i-1

    self.warning("%s not matched by %s" % (tok1.kind,delim))
    return None</t>
<t tx="ekr.20040713152318">def warning (self,message):
    
    print "Error:", message

def warning (self,message):
    
    print "Warning:", message
</t>
<t tx="ekr.20040713152809"></t>
<t tx="ekr.20040713154118">def skipString(self,s,i):

    # Skip the opening double quote.
    i1 = i
    ch = s[i]
    i += 1
    assert(ch == '"')

    while i &lt; len(s):
        ch = s[i]
        i += 1
        if ch == '"': return i
        elif ch == '\\': i += 1

    self.warning("run-on elisp string:", g.get_line(s[i1:]))
    return i</t>
<t tx="ekr.20040713160302">def findTokens(self,tokens,i,findTokens):
    
    """Search for a match with findTokens.
    Return i,i+len(findTokens) if found, or None,None otherwise."""

    e = self
    
    while i &lt; len(tokens):
        
        if e.matchTokens(tokens,i,findTokens):
            return i,i+len(findTokens)
        else:
            i += 1

    return None,None # Not found</t>
<t tx="ekr.20040713161629.1">def dump (self,tokens,verbose=2,heading=""):
    
    e = self ; p = e.p ; v2 = verbose &gt;= 2
    
    if verbose == 0:
        return
    
    if heading: printHeading(heading,char='=',len=60)
    else:       printHeading(p.headString())
    
    if verbose == 1:
        vals = [tok.val for tok in tokens]
        s = ''.join(vals)
        s = g.toEncodedString(s,g.app.tkEncoding)
        print s
    elif verbose in (2,3):
       
        if verbose == 2:
            for tok in tokens:
                print tok.toString(verbose=verbose),
        else:
            for tok in tokens:
                print tok.toString(verbose=verbose)</t>
<t tx="ekr.20040713164604">def wsToString (self,ws):
    
    allBlanks = True
    for ch in ws:
        if ch != ' ':
            allBlanks = False
            
    if allBlanks:
       return "&lt;' '*%d&gt;" % len(ws)
    else:
        result = ["&lt;"]
        for ch in ws:
            if ch == ' ':
                result.append(" ")
            elif ch == '\t':
                result.append("tab")
            elif ch == '\f':
                result.append("feed")
            else:
                result.append("&lt;%s&gt;" % repr(ch)) # should never happen.
        
        result.append("&gt;")
        return ''.join(result)</t>
<t tx="ekr.20040713173923">def match (self,tok2):
    
    tok1 = self
    
    val = (
        tok2 is not None and
        tok1.kind == tok2.kind and
        (not tok1.val or not tok2.val or (tok1.val == tok2.val)))
        
    if 0:
        if tok1.kind==tok2.kind:
            g.trace(val,tok1.kind,repr(tok1.val),tok2.kind)
        
    return val</t>
<t tx="ekr.20040713174349">def dump (self,verbose=2):
    
    tok = self

    if verbose == 2:
        print tok.toString(verbose=verbose)
    else:
        print tok.toString(verbose=verbose),</t>
<t tx="ekr.20040713180208">def toString (self,verbose=2):
    
    tok = self
    
    if verbose &lt; 2: return
    val = tok.val or ""
    val = g.toEncodedString(val,g.app.tkEncoding)
    
    if tok.isParseTok():
        parseTree = parseTreeToString(tok.parseTree)
        if tok.val == "TREE":
            return "%s"% (parseTree)
        else:
            return "%s: %s"% (tok.val,parseTree)
    
    elif verbose == 2:
        if len(tok.kind) == 1:    return tok.kind
        elif tok.kind=="form-feed": return "\nform-feed\n"
        elif tok.kind=="comment":   return "&lt;comment&gt;\n"
        elif tok.kind=="string":    return "&lt;string&gt;"
        else:                       return val
    
    elif verbose == 3:
        if tok.kind == '\n':      return "%9s:" % "newline"
        elif tok.kind=="form-feed": return "%9s:" % "form-feed"
        elif len(tok.kind)==1:      return "%9s:" % tok.kind
        elif tok.kind == "ws":
                return "%9s: %s" % (tok.kind,tok.wsToString(val))
        else:   return "%9s: &lt;%s&gt;" % (tok.kind,val)</t>
<t tx="ekr.20040713193437">def deleteTokens (self,tokens,delToken):
            
    return [tok for tok in tokens if not tok.match(delToken)]</t>
<t tx="ekr.20040713200238">@language elisp</t>
<t tx="ekr.20040713205718">def createIndentedBlock (self,tokens,level):
    
    e = self ; p = e.p ; level1 = level
    
    i = 0
    while i &lt; len(tokens):
        t = tokens[i]
        if t.kind == '(':
            &lt;&lt; insert nl and ws tokens &gt;&gt;
            level += 1
            i += 3
        elif t.kind == ')':
            level -= 1 ; i += 1
        elif t.kind == "string" and level == level1:
            &lt;&lt; insert nl and ws tokens &gt;&gt;
            i += 3
        else:
            i += 1

    return tokens</t>
<t tx="ekr.20040713211010">def convert (self):
    
    e = self ; p = e.p

    e.tokens = e.tokenize(p.bodyString())
    e.tokens = e.deleteTokens(e.tokens,tok("ws"))
    e.tokens = e.deleteTokens(e.tokens,tok('\n'))
    disposableTokens = e.tokens[:]
    e.parseTree = e.parse(disposableTokens)

    e.codeList = [] ; e.indent = 0
    e.codeLine = lineClass(0) # The line being accumulated.
    e.gen(e.parseTree)

    if 0: # Old code
        e.tokens = e.removeBlankLines(e.tokens)</t>
<t tx="ekr.20040714053807.1">def isStatement (self,tokens,i):
    
    """Returns the statement or function f if (f is at tokens[i]."""
    
    e = self
    
    for s in e.allStatements:
        toks = [tok('('),tok('id',s)]
        if e.matchTokens(tokens,i,toks):
            return s

    return False
      
    
</t>
<t tx="ekr.20040714054620.1">def matchTokens (self,tokens,i,findTokens):
    
    """Return True if tokens match findTokens at position i."""

    j = 0
    while j &lt; len(findTokens):
        tok = tokens[i+j]
        ftok = findTokens[j]
        if not tok.match(ftok):
            return False
        j += 1
    return True</t>
<t tx="ekr.20040714055306"></t>
<t tx="ekr.20040714060941">def isMatchingBracket(self,tokens,i,j):
    
    toki = tokens[i]
    tokj = tokens[j]

    f1 = "({[".find(toki.kind)
    f2 = ")}]".find(tokj.kind)
    
    # g.trace(f1,f2,repr(toki.kind),repr(tokj.kind))
    
    return f1 == f2 and f1 != -1</t>
<t tx="ekr.20040714061625">self.constants = ("t","nil")</t>
<t tx="ekr.20040714061625.1">self.statements = (
    "defconst","defun","defsubst","defvar",
    "cond",
    "if",
    "let","let*",
    "prog","prog1","progn",
    "set","setq",
    "unless","when","while",
)

</t>
<t tx="ekr.20040714061625.2">self.functions = (
    "and","or","not",
    "apply","eval",
    "cons","car","cdr",
    "error","princ",
    "eq","ne","equal","gt","ge","lt","le",
    "mapcar","type-of",
)</t>
<t tx="ekr.20040714072448">def removeBlankLines (self,tokens):
    
    e = self
    
    i = 0
    while i &lt; len(tokens):
        
        if tokens[i].kind == '\n':
            j = i ; i += 1
            while i &lt; len(tokens) and tokens[i].kind == "ws":
                i += 1
            if i &gt;= len(tokens) or tokens[i].kind == '\n':
                del tokens[j:i]
                i = j
            else: i += 1
        else: i += 1
            
    return tokens</t>
<t tx="ekr.20040714074445">ws = tok("ws",' '*e.tabwidth*level)
nl = tok('\n','\n')
tokens.insert(i,nl)
tokens.insert(i+1,ws)</t>
<t tx="ekr.20040714082939"></t>
<t tx="ekr.20040714091940.1">def block (self,tokens):
    
    """Parse a block of tokens."""
    
    e = self

    i = 0 ; result = []
    while i &lt; len(tokens):
        if tokens[i].kind == '(':
            j = e.findMatchingBracket(tokens,i)
            if j is None:
                # To do: print error message.
                i += 1
            else:
                # Strip off the matching parens.
                block = tokens[i+1:j]
                # Recursively parse this block.
                result.append(e.parse(block,topLevel=False))
                i = j + 1
        else:
            result.append(tokens[i])
            i += 1

    return result</t>
<t tx="ekr.20040714095247">def parseTreeToString (parseTree,level=0,verbose=2):

    result = [] ; levelSpaces = ' '*2*level
    indent = False

    if parseTree is None:
        result.append("None")

    if isToken(parseTree):
        s = parseTree.toString(verbose=2)
        if s: result.append(s + ' ')

    elif isList(parseTree):
        if verbose &gt;= 2:
            result.append('\n%s[' % levelSpaces)
        else:
            result.append('[')
        for item in parseTree:
            s = parseTreeToString(item,level+1,verbose=verbose)
            if s: result.append(s)
        result.append(']')

    else:
        result.append("unknown type in parseTreeToString")
        
    return ''.join(result)</t>
<t tx="ekr.20040714154314">if fTok:
    e.error("No (%s has no matching ')'" % fTok.kind)
else:
    e.error("Mismatched parens")</t>
<t tx="ekr.20040714155341">def parse (self,tokens,topLevel=True):
    
    """A recursive-descent parser for elisp."""
    
    e = self
    i = 0
    while i &lt; len(tokens):
        # g.trace(tokens[i].kind)
        if tokens[i].kind != '(':
            i += 1 ; continue
        j = e.findMatchingBracket(tokens,i)
        fTok = i+1 &lt; len(tokens) and tokens[i+1]
        if j is None:
            &lt;&lt; give error message about mismatched parens &gt;&gt;
            i += 1 ; continue
        # Strip off the matching parens.
        block = tokens[i+1:j]
        parseTree = e.block(block)
        # A top-level token is helpful for dumping, etc.
        if topLevel: token = tok('TREE','TREE',parseTree)
        else:        token = parseTree
        tokens[i:j+1] = [token]
        # We are replacing everything by a _single_ token.
        i = i + 1 
            
    return tokens</t>
<t tx="ekr.20040714170021">def isParseTok (self):
    
    tok = self
    
    return type(tok.parseTree) == type([])</t>
<t tx="ekr.20040714222507"></t>
<t tx="ekr.20040715071350">def gen(self,object):
    
    """The top-level code generator.
    
    May be called recursively to generate inner parts of the tree."""
    
    e = self

    if isToken(object):
        t = object
        if t.kind == "TREE":
            e.gen(t.parseTree)
        else:
            e.gen_token(t,outerList=None)
        
    elif isList(object):
        e.gen_list(object)
            
    else:
        print "unknown object in parse tree:", repr(object)</t>
<t tx="ekr.20040715071555">(defun igrep-read-file-name (prompt
  &amp;optional directory default existing initial history)
  "Just like `read-file-name', but with optional HISTORY.
Also: convert DIRECTORY to DIRECTORY/* file name pattern."
  (if igrep-insert-default-key
      (define-key minibuffer-local-completion-map igrep-insert-default-key
	'igrep-insert-default-files))
  (let ((file-name
	 (if history
	     (let ((file-name-history (symbol-value history)))
	       (prog1 (read-file-name prompt directory default existing initial)
		 (set history file-name-history)))
	   (read-file-name prompt directory default existing initial))))
    (if (and (not (string-equal file-name ""))
	     (file-directory-p file-name))
	(expand-file-name "*" file-name)
      file-name)))</t>
<t tx="ekr.20040715073230">def isList (object):
    
    return type(object) == type([])

def isToken (object):
    
    return isinstance(object,tok)</t>
<t tx="ekr.20040715075845">def gen_token (self,t,outerList=None):
    
    e = self
    
    g.trace(t.kind,t.val)
    
    if 0: # Not yet.

        if t.kind == 'id' and t.val in e.allStatements:
            
            g.trace(t.toString())
            
            line = e.newCodeLine()
            line.add(t.val)
            
            # Only TREE tokens have parse trees.
            # We are _inside_ a parse tree.</t>
<t tx="ekr.20040715075914">def newCodeLine (self):
    
    e = self
    
    if e.codeLine:
        e.codeList.append(e.codeLine)
        
    e.codeLine = line = lineClass(e.indent) # Create a new line object.
    
    return line</t>
<t tx="ekr.20040715080216">class lineClass:
    
    """Represents a code line being accumulated."""
    
    @others</t>
<t tx="ekr.20040715080738">def __init__ (self,indent):
        
        self.parts = []
        self.indent = indent</t>
<t tx="ekr.20040715080738.1">def toString (self):
    
    line = self
    
    theList = [str(part) + ' ' for part in self.parts]
    
    return ' ' * 2 * self.indent + ''.join(theList)</t>
<t tx="ekr.20040715081031">def add (self,s):
    
    self.parts.append(s)</t>
<t tx="ekr.20040715081425">def dumpCodeList (self,codeList,heading=""):
    
    printHeading(heading,char='=',len=60)
    
    for line in codeList:
        
        print line.toString()</t>
<t tx="ekr.20040715082059">def printHeading (s,char='-',len=20):
    
    banner = char * len

    print
    print banner
    print s
    print banner
    print</t>
<t tx="ekr.20040715084435">def gen_list (self,theList):
    
    e = self
    
    assert(isList(theList))
    if not theList:
        return
        
    item1 = theList[0]

    if isToken(item1):
        # The normal case looks like a function call: "(id args)"
        # Handle all args here.
        t = item1
        if t.kind == "TREE":
            e.gen(t.parseTree)
        elif t.kind == 'id':
            e.gen_statement(t,theList[1:])
        else:
            g.trace("unexpected token",t.kind,t.val)
            name = None
            e.gen_function(name,theList)
    elif isList(item1):
        # The first item is a list.
        for arg in theList:
            e.gen(arg)
                
    else: g.trace("unknown item",item1)</t>
<t tx="ekr.20040715090957">self.code_gen_dispatch_dict = {

    "cond"      : self.gen_cond,     
    "defconst"  : self.gen_defconst,
    "defun"     : self.gen_defun,
    "defsubst"  : self.gen_defsubst, 
    "defvar"    : self.gen_defvar, 
    "if"        : self.gen_if,
    "let"       : self.gen_let, 
    "let*"      : self.gen_let_star, 
    "prog"      : self.gen_prog, 
    "prog1"     : self.gen_prog1, 
    "progn"     : self.gen_progn, 
    "set"       : self.gen_set, 
    "setq"      : self.gen_setq, 
    "unless"    : self.gen_unless, 
    "when"      : self.gen_when, 
    "while"     : self.gen_while,
}
</t>
<t tx="ekr.20040715090957.1">def gen_statement (self,t,args):
    
    e = self
    
    expr_names = (
        "and","or","not",
        "eq","ne","equal","gt","ge","lt","le",)
    
    assert(t.kind=='id')
    
    name = t.val # The name of the statement.
    f = e.code_gen_dispatch_dict.get(name)

    if f:
        # Syntax-specific code generators.
        f(args)
    elif name in expr_names:
        # We will try to simply expression.
        e.gen_expression(args)
    else:
        # Generic code generator.
        e.gen_function(name,args)</t>
<t tx="ekr.20040715090957.2"></t>
<t tx="ekr.20040715091409">def gen_function (self,name,args):
    
    e = self
    g.trace(len(args),name)
    for arg in args:
        e.gen(arg)</t>
<t tx="ekr.20040715093122">def gen_defun(self,args):
    
    e = self
    
    g.trace()
    
    if len(args) == 1:
        print "def %s ():" % parseTreeToString(args[0])
        
    elif len(args) &gt;= 2:
        
        print "def %s (%s):" % (
            parseTreeToString(args[0]),
            parseTreeToString(args[1]).strip())
            
    e.indent += 1

    for arg in args[2:]:
        e.gen(arg)
        
    e.indent -= 1</t>
<t tx="ekr.20040715093804"></t>
<t tx="ekr.20040715105834"></t>
<t tx="ekr.20040715120001">def gen_cond (self,t,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.1">def gen_defconst(self,t,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.2">def gen_defsubst(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.3">def gen_defvar(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.4">def gen_if(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.5">def gen_let(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

def gen_let_star(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

</t>
<t tx="ekr.20040715120001.7">def gen_prog(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_prog1(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_progn(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)</t>
<t tx="ekr.20040715120001.8">def gen_set(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_setq(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)</t>
<t tx="ekr.20040715120001.9">def gen_unless(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_when(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_while(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

</t>
<t tx="ekr.20040715121456">def gen_expression(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    
    if isList(args):
        for arg in args:
            e.gen_expression(arg)
    elif args:
        e.gen(args)
</t>
<t tx="ekr.20040715125453">def gen_computed_function (self,args):
    
    e = self

    g.trace()

    for arg in args:
        e.gen(arg)</t>
<t tx="ekr.20040715154319">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import unittest

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False,suppressErrors=True)

assert result=="error", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20040716062608"># Run this script to import a file.
# This is undoable because the Import @file command is undoable.

path = r"c:\prog\test\perfectImport"

# Two files from Python23/Lib
name1 = g.os_path_join(path,"formatter.py")
name2 = g.os_path_join(path,"SimpleHTTPServer.py")
names = [name1]

c.importCommands.importFilesCommand (names,"@file",
    perfectImport=True,testing=False,verbose=True)</t>
<t tx="ekr.20040716071029.6"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoTest

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716071856">#@+leo-ver=4-thin
#@+node:ekr.20040716071856.1:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716071856.1:-input
#@-leo
</t>
<t tx="ekr.20040716071856.1">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716081019">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716081943">#@+leo-ver=4-thin
#@+node:ekr.20040716071856.1:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716071856.1:-input
#@-leo
</t>
<t tx="ekr.20040716084934">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716084934.1">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716091245">#@+leo-ver=4-thin
#@+node:ekr.20040716081019:-input-after
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716081019:-input-after
#@-leo
</t>
<t tx="ekr.20040716140926"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoTest

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716140926.1">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.2">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.3">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.1:-input
Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.1:-input
#@-leo
</t>
<t tx="ekr.20040716140926.4">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.2:-input-after
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.2:-input-after
#@-leo
</t>
<t tx="ekr.20040716140926.5">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.6">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.7">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.1:-input
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.1:-input
#@-leo
</t>
<t tx="ekr.20040716141621"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoTest

u = leoTest.testUtils()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716141621.1">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.2">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.3">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.1:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.1:-input
#@-leo
</t>
<t tx="ekr.20040716141621.4">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.2:-input-after
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.2:-input-after
#@-leo
</t>
<t tx="ekr.20040716141621.5">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.6">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.7">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.1:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.1:-input
#@-leo
</t>
<t tx="ekr.20040716142121"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoTest

u = leoTest.testUtils()

ignoreSentinelsInCompare = True # Fails when False

assert leoTest.runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=ignoreSentinelsInCompare)</t>
<t tx="ekr.20040716142121.2">root line 1
root line 2</t>
<t tx="ekr.20040716142121.3">#@+leo-ver=4-thin
#@+node:ekr.20040716142423:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142423:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.1:Node 1
node 1: line 1
node 1: line 2
#@-node:ekr.20040716142423.1:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.2:Node 2
node 2: line 1
node 2: line 2
#@-node:ekr.20040716142423.2:Node 2
#@-leo
</t>
<t tx="ekr.20040716142121.4">#@+leo-ver=4-thin
#@+node:ekr.20040716142121.2:-input-after
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142121.2:-input-after
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040717071133:Node 1
node 1: line 1
These lines should be totally different
#@-node:ekr.20040717071133:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040717071133.1:Node 2
and should span node boundaries
node 2: line 2
#@-node:ekr.20040717071133.1:Node 2
#@-leo
</t>
<t tx="ekr.20040716142121.5">root line 1
root line 2
node 1: line 1
node 1: line 2
node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20040716142121.6">root line 1
root line 2
node 1: line 1
These lines should be totally different
and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20040716142121.7">#@+leo-ver=4-thin
#@+node:ekr.20040716142423:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142423:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.1:Node 1
node 1: line 1
These lines should be totally different
and should span node boundaries
#@-node:ekr.20040716142423.1:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.2:Node 2
node 2: line 2
#@-node:ekr.20040716142423.2:Node 2
#@-leo
</t>
<t tx="ekr.20040716142423">root line 1
root line 2</t>
<t tx="ekr.20040716142423.1">node 1: line 1
node 1: line 2
</t>
<t tx="ekr.20040716142423.2">node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20040716144017"># See the node called "About the Perfect Import tests" in leoTests.py for how to set up these tests.
</t>
<t tx="ekr.20040717071133">node 1: line 1
These lines should be totally different
</t>
<t tx="ekr.20040717071133.1">and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20040717121014">print "gnx", p.v.t.fileIndex, p.headString()</t>
<t tx="ekr.20040721094335">for i in xrange(10000):
    if i % 1000 == 0:
        print i</t>
<t tx="ekr.20040721113934">import leoGlobals as g
import profile
import pstats

# Note: the profiled code should do all needed imports.
path = g.os_path_abspath(g.os_path_join(g.app.loadDir,'..','test','leoProfile.txt'))
path = str(path)

c = g.top() ; p = c.currentPosition()

if p.bodyString().rstrip():
    s = p.bodyString().rstrip() + '\n'
    profile.run(s,path)
    print '-' * 40
    print "Profiling info sent to %s" % path
    stats = pstats.Stats(path)
    stats.strip_dirs()
    stats.sort_stats('cum','file','name')
    stats.print_stats()
</t>
<t tx="ekr.20040721115141"># There will never be an overflow here, no matter how many times timeit executes this.

try:
    i = 0
    i += 1
except OverflowError:
    pass</t>
<t tx="ekr.20040721145258.1">import leoTest

leoTest.runGc(disable=True)</t>
<t tx="ekr.20040721153143">@language python</t>
<t tx="ekr.20040721173532"># c.redraw just schedules the actual drawing.
# We want to profile the actual idle-time drawing.

c.frame.tree.idle_redraw()</t>
<t tx="ekr.20040722051235"></t>
<t tx="ekr.20040722055040">for p in c.allNodes_iter():
    
    child = p.firstChild()
    while child:
        for parent in p.self_and_parents_iter():
            assert parent.isAncestorOf(child)
        child.moveToNext()

    next = p.next()
    assert not p.isAncestorOf(next)</t>
<t tx="ekr.20040723062819"></t>
<t tx="ekr.20040723064143.1">@ignore
@nocolor

- Unit tests for undo/redo.

- Unit tests for tangle/untangle commands.

- Unit tests for Find commands.

- Unit tests for dialogs.

@color</t>
<t tx="ekr.20040723064143.3"></t>
<t tx="ekr.20040723065021">print '-' * 60

# Tag the start of the command.
c.undoer.setUndoParams("Change All",c.currentPosition())

n = 0 ; total = 0
for p in c.currentPosition().self_and_subtree_iter():
    total += 1
    body = p.bodyString()
    s = g.stripBlankLines(body)
    if s != body:
        n += 1
        p.setBodyStringOrPane(s,g.app.tkEncoding)
        c.undoer.setUndoParams("Change",p,
            oldText=body,newText=s,oldSel=None, newSel=None)

# Tag the end of the command.
c.undoer.setUndoParams("Change All",c.currentPosition()) 

print "%d nodes changed (%d total)" % (n,total)
</t>
<t tx="ekr.20040723065047">@ignore
a
  b
  
c  
  
last
  </t>
<t tx="ekr.20040724171040">import Tkinter as Tk

root = Tk.Tk()
c = Tk.Canvas(root,background='white')
print c.bindtags()

if 0:
    c.pack(expand=1,fill='both')
    f = Tk.Frame(c)
    c.create_window(0,0,window=f,anchor='nw')
    f.pack_configure(fill='both',expand=1)
    body = olCreateControl(self,frame,f)
    c.on = False 
    sel = lambda event, c = c, body = body:select(event,c,body)
    ai = lambda event, c = c, body = body, colorizer = frame.body:add_item(event,c,body,colorizer.getColorizer())
    c.bind("&lt;Key&gt;",watcher,'+')
    c.bind("&lt;Key&gt;",sel,'+')
    c.bind("&lt;Key&gt;",ai,'+')
    ctags = c.bindtags()
    btags = body.bindtags()
    btags =(ctags[0],btags[0],btags[1],btags[2],btags[3])
    body.bindtags(btags)</t>
<t tx="ekr.20040730181601">import leoTest

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040730181610">import leoTest

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile2.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040802065214"># Make sure that changing this headline marks descendant @thin nodes dirty.
h = p.headString()

c.beginUpdate()
try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.headString() == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    p.setHeadString("changed")
    assert child.isDirty(), "setting descendant @thin nodes dirty failed."
finally:
    try:
        p.setHeadString(h)
        child.setHeadString("bogus")
        p.clearDirty()
        child.clearDirty()
    finally: pass
    c.endUpdate()
</t>
<t tx="ekr.20040802065214.1">test</t>
<t tx="ekr.20040802071519"># Tests that p.setBodyStringOrPane works immediately.
h = p.headString()

try:
    child = p.firstChild()
    before = child.bodyString()
    after = "after"
    child.setBodyStringOrPane("after")
    c.selectPosition(child)
    t = c.frame.body.bodyCtrl
    s = t.get("1.0","end")
    assert s.rstrip() == after.rstrip(), \
        "setBodyStringOrPane failed: %s, %s" % (repr(s),repr(after))
finally:
    child.setBodyStringOrPane(before)
    c.selectPosition(p)</t>
<t tx="ekr.20040802071519.1">after</t>
<t tx="ekr.20040803090901">import leoTest

path = g.os_path_join(g.app.loadDir,"..","dist","leoDist.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040803091512">import leoTest

u = leoTest.testUtils()
name = "@thin ../src/leoTest.py"
p = u.findNodeAnywhere(c,name)

assert p, "Can't find %s" % name

p.v.t.tnodeList = ["bogus tnodeList"]

if 0: # This causes p to be written, thereby clearing the tnodeList.
    p.setDirty()
    
if 0: # This actually saves this file, so it is a bit dangerous.
    g.app.unitTesting = True
    g.app.unitTestDict = {}
    c.save()
    ok = g.app.unitTestDict.get("warning")
    assert ok, "putVnode failed to give warning"
    g.app.unitTesting = False</t>
<t tx="ekr.20040804052804">import leoGlobals as g

c = g.top()

tracePositions = False
traceDrawing = True

# This trace catches leaks of positions.
g.app.tracePositions = tracePositions
    
# This trace shows overall position statistics.
c.frame.tree.trace = traceDrawing
c.frame.tree.verbose = True</t>
<t tx="ekr.20040804104328"></t>
<t tx="ekr.20040804104924">def vhash(self):  # v.__hash__
    v = self
    return "%s,%d" % (str(id(v)),v.childIndex())

def __hash__ (self):  # p.__hash__

    p = self
    if p.stack:
        vids = [vhash(v) for v in p.stack]
        return vhash(p.v) + ':' + ':'.join(vids)
    else:
        return vhash(p.v)
        
for p in c.currentPosition().self_and_subtree_iter():

    hash = __hash__(p)
    hash2 = __hash__(p.copy())
    assert hash==hash2, "hash for equivalent nodes are different: %s, %s" % (hash,hash2)
    print hash</t>
<t tx="ekr.20040804105026"></t>
<t tx="ekr.20040805101759">print "before"

# This drops you into pdb.  Type command in the console window.
import pdb ; pdb.set_trace()

print "after"</t>
<t tx="ekr.20040805102453"></t>
<t tx="ekr.20040831095833"></t>
<t tx="ekr.20040831095833.1">openFileDialog
src\\leo.py</t>
<t tx="ekr.20040831101747"># Apparently these file are fine when they are written.
# The problem comes later in the distribution process.


def checkLinuxLineEndings(filename):
    
    try:
        s = open(filename,"rb").read()
        cr = 0 ; nl = 0
        for ch in s:
            if ch == '\r': cr += 1
            if ch == '\n': nl += 1
        assert cr == 0, "Bad Linux line ending in %s: cr: %d, nl: %d" % (filename,cr,nl)
    except IOError:
        print "checkLinuxLineEndings: can not open %s" % filename
        raise

for file in ("install","uninstall"):
    checkLinuxLineEndings(g.os_path_join(g.app.loadDir,"..",file))</t>
<t tx="ekr.20040831104758">import leoTest

path = g.os_path_join(g.app.loadDir,"..","test","unittest","minimalLeoFile3.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040901065642">import string

#@count 10000
#@setup

s = ''
for i in range(0, 50):
    s += '%d'%i
s = string.replace(s, '2', '1')</t>
<t tx="ekr.20040901065642.2">@ Improved timeit script after an idea by 'e'.

Comments of the form #@count nnn set the repeat count.
Comments of the form #@setup comment delimits the end of setup code.
@c

try: import timeit # Exists only in Python 2.3 and above.
except ImportError: 
    timeit = None
    print "Can not import timeit"
import leoGlobals as g

c = g.top() ; p = c.currentPosition()

if timeit and p.bodyString().strip():
    s = p.bodyString().rstrip() + '\n'
    &lt;&lt; scan for #@count &gt;&gt;
    &lt;&lt; put setup code in s1 and everything else in s2 &gt;&gt;
    t = timeit.Timer(stmt=s2,setup=s1)
    try:
        if 1: # faster.
            result = t.timeit(count)
        else: # better results.
            result = min(t.repeat(3, count))  
        print "count: %d : %f %s" % (
            count, result, p.headString().strip())
    except:
        t.print_exc()</t>
<t tx="ekr.20040901071028">lines = s.split('\n')

for i in xrange(len(lines)):
    if lines[i].strip() == "#@setup":
        break
        
if i &lt; len(lines):
    # Split at the #@setup line and delete the #@setup line
    s1 = '\n'.join(lines[:i])
    s2 = '\n'.join(lines[i:])
    #print "setup",repr(s1)
    #print "code",repr(s2)
else:
    # There is no setup.
    s1 = None
    s2 = s
    
if not s1: s1 = 'pass'
if not s2: s2 = 'pass'</t>
<t tx="ekr.20040901072339">lines = s.split('\n')

count = 1000000 # default count
tag = "#@count"

for line in lines:
    i = g.skip_ws(line,0)
    if g.match(line,0,tag):
        i += len(tag)
        i = g.skip_ws(line,i)
        junk,val = g.skip_long(line,i)
        if val is not None:
            count = abs(val)
            # print "Setting count to",count
            break</t>
<t tx="ekr.20040903102217"></t>
<t tx="ekr.20040909103024">@ignore</t>
<t tx="ekr.20040909103024.1">@language perl

@others</t>
<t tx="ekr.20040909103024.2">#line 1 "node:ekr.20040909103024.2:TestNode (c:\prog\test\perlLineNumbers.txt)"
test</t>
<t tx="ekr.20040909122141">@ignore

@language python 

@tabwidth -4

@others
</t>
<t tx="ekr.20040909122141.1">def spam():
	Line starts with a tab.
	
# Line doesn't end in newline.
</t>
<t tx="ekr.20040910092950"></t>
<t tx="ekr.20040910092950.3"></t>
<t tx="ekr.20040910094343">@ignore # To suppress syntax checks in @arg nodes</t>
<t tx="ekr.20040910094343.1"></t>
<t tx="ekr.20040910094546"></t>
<t tx="ekr.20040910094546.1">c:\prog\leoCVS\leo\src\leo.py</t>
<t tx="ekr.20040910094546.2"></t>
<t tx="ekr.20040914072438">@path c:\prog\test</t>
<t tx="ekr.20040914072438.1">@root atRootTest1.txt

atRootTest1.txt</t>
<t tx="ekr.20040914072438.2">@root atRootTest2.txt

atRootTest2.txt</t>
<t tx="ekr.20040915045847">@nocolor
@ignore

this is a test of I've aren't arn't can't won't
aren`t arn`t can`t won`t</t>
<t tx="ekr.20040915080419">for p in c.allNodes_iter():
    h = p.headString()
    if hasattr(p.v,'unknownAttributes'):   print 'v',h,p.v.unknownAttributes
    if hasattr(p.v.t,'unknownAttributes'): print 't',h,p.v.t.unknownAttributes</t>
<t tx="ekr.20040915111739">@nocolor
@ignore

The children of this node are expected to contain a file pattern in the headline
and the script to be executed in the body. The file name is matched against the
patterns (which are Unix-style shell patterns), and the first matching node is
selected. If the filename is a path, only the last item is matched.

@color</t>
<t tx="ekr.20040915111853"># This script is written when any diryt leo*.py node is written.

# The following globals are defined: filename, shellScriptInWindow

# print c,c.currentPosition()
print "filename", filename</t>
<t tx="ekr.20040917062206">assert(g.cantImport("xyzzy","during unit testing") is None)</t>
<t tx="ekr.20040918093738">@ignore # To suppress syntax checking.</t>
<t tx="ekr.20040918093738.1">def py2tkIndex (s,n):
    """Convert n, a Python index into s, into a Tk index.
    This must be as fast as possible and must not allocate any memory."""
    if n &gt;= len(s): return "end"
    if n &lt;= -len(s): return "1.0"
    if n &lt; 0: n += len(s)
    n1 = s.count('\n',0,n)
    if n1 == 0:
        return "%d.%d" % (n1+1,n)
    else:
        n2 = s.rfind('\n',0,n)
        return "%d.%d" % (n1+1,n-n2-1)

# Test script.
s = p.firstChild().bodyString()
print '=' * 20
for i in xrange(len(s)):
    print "%3d" % (i),repr(str(s[i])),py2tkIndex(s,i)
i = len(s)
print "%3d" % (i),py2tkIndex(s,i)
print '-' * 20
for i in xrange(-1,-len(s)-1,-1):
    print "%3d" % (i),repr(str(s[i])),py2tkIndex(s,i)
i = -len(s)-1
print "%3d" % (i),py2tkIndex(s,i)</t>
<t tx="ekr.20040918093738.2">line 1
two
three
</t>
<t tx="ekr.20040918093738.3">def pyRowColToTkIndex (s,n1,n2):
    """Convert n, a Python index into s, into a Tk index.
    This must be as fast as possible and must not allocate any memory.
    """
    assert(n1 &gt;= 0)
    
    if 0: # Let Tk complain about bad indices.
        if n1 &gt; s.count('\n'):
            return "end"
        else:
            return "%d.%d" % (n1+1,n2)
    else: # Check both indices.
        line = 0 ; index = 0 ; limit = len(s)
        while index &lt; limit and line != n1:
            i = s.find('\n',index,limit)
            if i == -1:
                return "end"
            else:
                line += 1
                index = i + 1
        if index + n2 &gt; limit:
            return "end"
        else:
            i = s.find('\n',index,limit)
            if -1 &lt; i &lt; index + n2:
                return "bad" # n2 out of range.
            else:
                return "%d.%d" % (line+1,n2)
    
# Test script.
s = p.firstChild().bodyString()
print '-' * 20
lines = s.split('\n')
for n1 in xrange(len(lines)):
    line = lines[n1] + '\n'
    for n2 in xrange(len(line)):
        ch = line[n2]
        print "%3d.%-3d %-4s" % (n1,n2,repr(str(ch))),pyRowColToTkIndex(s,n1,n2)
        
n1,n2 = len(lines),0
print "%3d.%-3d %4s" % (n1,n2,' '),pyRowColToTkIndex(s,n1,n2)</t>
<t tx="ekr.20040918093738.4">line 1
two
three
</t>
<t tx="ekr.20040922064156">s = u""

g.reportBadChars(s,"latin_1")

print g.toEncodedString(s,"latin_1")</t>
<t tx="ekr.20041001111106"># root line 1

@others

# root after at-others

&lt;&lt; ref &gt;&gt;
</t>
<t tx="ekr.20041001111106.1"># node 1 line 1

&lt;&lt; node 1 ref &gt;&gt;

# node 1 last line</t>
<t tx="ekr.20041001111106.2"># node 1 ref line 1

@others</t>
<t tx="ekr.20041001111106.3"></t>
<t tx="ekr.20041001111106.4"></t>
<t tx="ekr.20041001111106.5"># ref line 1

@others</t>
<t tx="ekr.20041001111106.6"># text of organizer node</t>
<t tx="ekr.20041001111106.7"></t>
<t tx="ekr.20041001111106.8"></t>
<t tx="ekr.20041001161303">for s in g.app.loadedPlugins:
    print s</t>
<t tx="ekr.20041001194357"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(all=False)</t>
<t tx="ekr.20041001203411.1">g.es("hi",color="red")</t>
<t tx="ekr.20041001211817"></t>
<t tx="ekr.20041004093917">@color
@language python
@tabwidth -4

input = p.firstChild()
result = input.next()
expected = result.next()
s = input.bodyString()

c.atFileCommands.read(result,thinFile=True,fromString=s)

try:
    p1 = result.firstChild()
    p2 = expected.firstChild()
    for p in p1.self_and_subtree_iter():
        assert p.headString() == p2.headString(),p
        assert p.bodyString() == p2.bodyString(),p
        p2.moveToThreadNext()
    c.selectVnode(result.firstChild(),updateBeadList=False)
    c.deleteOutline()
except AssertionError:
    c.selectVnode(result.firstChild(),updateBeadList=False)
    c.deleteOutline()
    raise</t>
<t tx="ekr.20041004093917.1">#@+leo-ver=4-thin
#@+node:ekr.20041001111106:@thin c:\prog\test\at-file-thin-test2.txt
# root line 1

#@+others
#@+node:ekr.20041001111106.1:node 1
# node 1 line 1

#@&lt;&lt; node 1 ref &gt;&gt;
#@+node:ekr.20041001111106.2:&lt;&lt; node 1 ref &gt;&gt;
# node 1 ref line 1

#@+others
#@+node:ekr.20041001111106.3:child node 1
#@-node:ekr.20041001111106.3:child node 1
#@+node:ekr.20041001111106.4:child node 2
#@-node:ekr.20041001111106.4:child node 2
#@-others
#@nonl
#@-node:ekr.20041001111106.2:&lt;&lt; node 1 ref &gt;&gt;
#@nl

# node 1 last line
#@nonl
#@-node:ekr.20041001111106.1:node 1
#@-others

# root after at-others

#@&lt;&lt; ref &gt;&gt;
#@+node:ekr.20041001111106.5:&lt;&lt; ref &gt;&gt;
# ref line 1

#@+others
#@+node:ekr.20041001111106.6:organizer node
# text of organizer node
#@nonl
#@+node:ekr.20041001111106.7:ref child 1
#@-node:ekr.20041001111106.7:ref child 1
#@+node:ekr.20041001111106.8:ref child 2
#@-node:ekr.20041001111106.8:ref child 2
#@-node:ekr.20041001111106.6:organizer node
#@-others
#@nonl
#@-node:ekr.20041001111106.5:&lt;&lt; ref &gt;&gt;
#@nl
#@-node:ekr.20041001111106:@thin c:\prog\test\at-file-thin-test2.txt
#@-leo
</t>
<t tx="ekr.20041004100940">@ignore</t>
<t tx="ekr.20041011160953">@ignore</t>
<t tx="ekr.20041011160953.1">@language html</t>
<t tx="ekr.20041011160953.2">"""Adds XSLT-Node Command submen item to the Outline menu.

This menu contains the following items:
    
- Set StyleSheet Node:
    - Selects the current node as the xsl stylesheet the plugin will use.

- Process Node with Stylesheet Node:
    - Processes the current node as an xml document,
      resolving section references and Leo directives.
    - Creates a sibling containing the results.

Requires 4Suite 1.0a3 or better, downloadable from http://4Suite.org.
"""

@language python

&lt;&lt; imports &gt;&gt;
__version__ = "0.2"
&lt;&lt; version history &gt;&gt;
new_at_file = True

stylenodes = weakref.WeakKeyDictionary()
haveseen = weakref.WeakKeyDictionary()

@others

if Ft and Tk:
    leoPlugins.registerHandler(('start2','open2',"new"),addMenu)
    g.plugin_signon(__name__)</t>
<t tx="ekr.20041011160953.3">import leoNodes
import leoPlugins

try:
    import Ft
    from Ft.Xml import InputSource 
    from Ft.Xml.Xslt.Processor import Processor
except ImportError:
    Ft = g.cantImport("Ft")

try:
    import Tkinter as Tk
except ImportError:
    Tk = g.cantImport("Tk")

import weakref 
import cStringIO 

</t>
<t tx="ekr.20041011160953.4">@

0.1: Original code.

0.2 EKR: Converted to outline.</t>
<t tx="ekr.20041011160953.5"></t>
<t tx="ekr.20041011160953.6">def setStyleNode (c):

    stylenodes[c] = c.currentPosition()</t>
<t tx="ekr.20041011160953.7">def processDocumentNode (c):
    
    c.beginUpdate()
    try:
        if not styleNodeSelected(c):return
        proc = Processor()
        stylenode = stylenodes[c]
        pos = c.currentPosition()
        c.selectPosition(stylenode)
        sIO = getStream(c)
        hstring = str(stylenode.headString())
        if hstring=="":hstring = "no headline"
        stylesource = InputSource.DefaultFactory.fromStream(sIO,uri=hstring)
        proc.appendStylesheet(stylesource)
        c.selectPosition(pos)
        xmlnode = pos.v.t
        xIO = getStream(c)
        xhead = str(xmlnode.headString)
        if xhead=="":xhead = "no headline"
        xmlsource = InputSource.DefaultFactory.fromStream(xIO,uri=xhead)
        result = proc.run(xmlsource)
        nhline = "xsl:transform of "+str(xmlnode.headString)
        tnode = leoNodes.tnode(result,nhline)
        pos.insertAfter(tnode)
        
    except Exception, x:
        g.es('exception '+str(x))
    c.endUpdate()</t>
<t tx="ekr.20041011160953.8">def addXSLTNode (c):
    
    pos = c.currentPosition()
    
    #body = '''&lt;?xml version="1.0"?&gt;'''
   # body = '''&lt;?xml version="1.0"?&gt;
#&lt;xsl:transform xmlns:xsl="http:///www.w3.org/1999/XSL/Transform" version="1.0"&gt;'''

    body = '''&lt;?xml version="1.0"?&gt;
&lt;xsl:transform xmlns:xsl="http:///www.w3.org/1999/XSL/Transform" version="1.0"&gt;    
&lt;/xsl:transform&gt;'''

    tnode = leoNodes.tnode(body,"xslt stylesheet")
    c.beginUpdate()
    try:
        pos.insertAfter(tnode)
    finally:
        c.endUpdate()
</t>
<t tx="ekr.20041011160953.9">def addXSLTemplate (c):

    bodyCtrl = c.frame.bodyCtrl
    template = '''&lt;xsl:template match=""&gt;'''
    template = '''&lt;xsl:template match=""&gt;
&lt;/xsl:template&gt;'''

    bodyCtrl.insert('insert',template)
    bodyCtrl.event_generate('&lt;Key&gt;')
    bodyCtrl.update_idletasks()</t>
<t tx="ekr.20041011160953.10">def getStream (c):

    at = c.atFileCommands
    pos = c.currentPosition()
    cS = cStringIO.StringIO()
    
    if new_at_file: # 4.3 code base.
        at.toStringFlag = True
        # at.outputFile = cS 
        at.writeOpenFile(pos,nosentinels=True,toString=True)
        # at.outputFile = None 
        # at.toStringFlag = False 

    else: # 4.2 code base
        at.new_df.toStringFlag = True
        at.new_df.outputFile = cS
        at.new_df.writeOpenFile(pos,nosentinels=True,toString=True)
        at.new_df.outputFile = None
        at.new_df.toStringFlag = False

    cS.seek(0)
    return cS</t>
<t tx="ekr.20041011160953.11">def jumpToStyleNode (c):

    if not styleNodeSelected(c):return
    pos = stylenodes[c]

    c.beginUpdate()
    try:
        c.selectPosition(pos)
    finally:
        c.endUpdate()</t>
<t tx="ekr.20041011160953.12">def styleNodeSelected (c):

    if not stylenodes.has_key(c):
        g.es("No Style Node selected")
        return False

    return True</t>
<t tx="ekr.20041011160953.13">def addMenu (tag,keywords):
    c = g.top()
    if haveseen.has_key(c): return
    haveseen[c] = None 
    menu = c.frame.menu 
    menu = menu.getMenu('Outline')
    xmen = Tk.Menu(menu,tearoff=False)
    xmen.add_command(
        label="Set Stylesheet Node",
        command=lambda c=c:setStyleNode(c))
    xmen.add_command(
        label="Jump To Style Node",
        command=lambda c=c:jumpToStyleNode(c))
    xmen.add_command(
        label="Process Node with Stylesheet Node",
        command=lambda c=c:processDocumentNode(c))
    xmen.add_separator()
    xmen.add_command(
        label="Create Stylesheet Node",
        command=lambda c=c:addXSLTNode(c))
    xmen.add_command(
        label="Insert &lt;xsl:template&gt; elements",
        command=lambda c=c:addXSLTemplate(c))
    menu.add_cascade(
        menu=xmen,
        label="XSLT-Node Commands")</t>
<t tx="ekr.20041011160953.14"></t>
<t tx="ekr.20041011161235">&lt;xsl:stylesheet xmlns:xsl="http://www.w3.org/1999/XSL/Transform" version="1.0"&gt;</t>
<t tx="ekr.20041012084201">def removeFile(path,verbose):

    if os.path.exists(test_file):
        if verbose:
            print "@test batch mode: deleting",test_file
        os.remove(test_file)
    else:
        if verbose:
            print "@test batch mode: not found:",test_file
</t>
<t tx="ekr.20041012091500">g.rawPrint("Test of g.rawPrint")
g.redirectStdout()
g.rawPrint("Test of g.rawPrint")
g.restoreStdout()</t>
<t tx="ekr.20041012101530">@others</t>
<t tx="ekr.20041012101634">a = a[)</t>
<t tx="ekr.20041012101720">@others</t>
<t tx="ekr.20041012101720.1">a = []
b = a[2]</t>
<t tx="ekr.20041012101836">@others</t>
<t tx="ekr.20041012101836.1">a = a[)</t>
<t tx="ekr.20041012102030">path = g.os_path_join(g.app.loadDir,"..","test","unittest")

errorTest = g.importFromPath ("errorTest",path,verbose=True)

errorTest.testIndexError()</t>
<t tx="ekr.20041012123331">&lt;?xml version='1.0' encoding="UTF-8"?&gt;
&lt;xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"&gt;
&lt;xsl:output method="xml" indent="yes" encoding="UTF-8" /&gt;

&lt;!-- Main template --&gt;
&lt;xsl:template match="/"&gt;

&lt;leo_file&gt;

&lt;leo_header file_format="1" tnodes="0" max_tnode_index="6" clone_windows="0"/&gt;
&lt;globals body_outline_ratio="0.302"&gt;
	&lt;global_window_position top="-4" left="-4" height="748" width="1032"/&gt;
	&lt;global_log_window_position top="64" left="164" height="586" width="747"/&gt;
&lt;/globals&gt;
&lt;preferences allow_rich_text="0" tab_width="4" page_width="132" 
tangle_bat="0" untangle_bat="0" output_doc_chunks="1" 
defaultTargetLanguage="C" use_header_flag="1"&gt;
	
&lt;/preferences&gt;
&lt;find_panel_settings ignore_case="1" search_body="1"&gt;
	&lt;find_string&gt;cweb&lt;/find_string&gt;
	&lt;change_string&gt;&lt;/change_string&gt;
&lt;/find_panel_settings&gt;

&lt;vnodes&gt;
&lt;xsl:apply-templates/&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;xsl:text&gt;
&lt;/xsl:text&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;

&lt;/xsl:template&gt;

&lt;!-- Template for the top element --&gt;
&lt;xsl:template match="*[not(parent::*)]"&gt;
&lt;v a="ET"&gt;&lt;vh&gt;&lt;xsl:value-of select="name(.)"/&gt;&lt;/vh&gt;
&lt;xsl:apply-templates/&gt;
&lt;/v&gt;
&lt;/xsl:template&gt;

&lt;!-- Template for all but the top element --&gt;
&lt;xsl:template match="*[parent::*]"&gt;
&lt;v&gt;&lt;vh&gt;&lt;xsl:value-of select="name(.)"/&gt;&lt;/vh&gt;
&lt;xsl:apply-templates/&gt;
&lt;/v&gt;
&lt;/xsl:template&gt;

&lt;!-- Template to dump the text --&gt;
&lt;xsl:template match="text()"&gt;
&lt;/xsl:template&gt;

&lt;/xsl:stylesheet&gt;</t>
<t tx="ekr.20041013062906">p.OnHyperLinkControlClick(event=None)</t>
<t tx="ekr.20041013062906.1">@ignore</t>
<t tx="ekr.20041013101029"># Run this script from a scriptButton.
&lt;&lt; about this script &gt;&gt;
import re

def headfind():
    """Search with re and 
    - GO to found headline beginning with the selected text or clipboard buffer
    or also GO when line begins with @ and word or string in variable sMyOwnPrefix
    - EXCEPT when found search string is '-info' node
    (BOTH  1.followed by ' -info'
    AND  2.appears anywhere in headline(preceding space or start) 
    THEN  just SHOW found info node's body text in cleared Log pane.
    """
    s = c.frame.body.getSelectedText() or g.app.gui.getTextFromClipboard()
    if s:
        if len(s) == 1: s = "index -info" #if select is one char try to goto this named index node
        s = re.escape(s.lower())
        sUseLogTrigger = re.escape(" -info")
        sMyOwnPrefix = re.escape("FOLLOWING FILE IS: ").lower()
        sAllowablePrefixRe = "\@([A-Za-z][A-Za-z0-9\-]+) "
            # @ char, followed by alpha,some alphanum or dash chars, then space ...matches Leo special nodes
        for p in c.allNodes_iter():
            srch="(^%s%s|^%s%s|^%s| %s%s)" % (sMyOwnPrefix,s,sAllowablePrefixRe,s,s,s,sUseLogTrigger) #all re
            if re.findall(srch,p.headString().lower()):
                g.es("found " + s)
                sUseLogTrigger_srch="(^| )%s%s" % (s,sUseLogTrigger) #first just Log trigger re
                if re.findall(sUseLogTrigger_srch,p.headString().lower()):
                    body2=p.bodyString()
                    g.top().frame.log.logCtrl.delete("1.0","end"); # clear Log pane before message
                    # g.es(body2,color="orange")
                    return
                else:
                    c.beginUpdate()
                    try:
                        c.frame.tree.expandAllAncestors(p)
                        c.selectVnode(p)
                    finally:
                        c.endUpdate()
                    return
					
        g.es("no headline matches '%s'" % (s),color="blue")
    else:
        g.es("no selected text &amp; clipboard empty",color="blue")

headfind()</t>
<t tx="ekr.20041013101029.1">@ PREFIXES: Now will jump to any headline where search is preceded by an @+chars+space
and alternatively a fixed prefix string+space.

CLEAR LOG: Now also clears Log for display of -info nodes. 

NOTE:I already had a file with a bunch of text files each preceded by "THE FOLLOWING
FILE IS: " and a list of these files at the top of everything. After global
changing these lines with "- " (and at first line), I imported flattened outline...
and "there you go" a index-driven Leo version. :)

bill p</t>
<t tx="ekr.20041017100700">@language python

# Type a period to autocomplete
leoTest

# Type an open paren to bring up calltip.
leoTest.findAllAtFileNodes</t>
<t tx="ekr.20041018193142">arg = "arg" ; filename = "fileName"
path = "path" ; shortPath = "shortPath"
vtuple = "vtuple"

def test(a,b):
    assert(a==b)

test(
    "os.system("+arg+shortPath+")",
    "os.system(%s)" % (arg+shortPath))
test(
    "os.startfile("+arg+shortPath+")",
    "os.startfile(%s)" % (arg+shortPath))
test(
    "exec("+arg+shortPath+")",
    "exec(%s)" % (arg+shortPath))
test(
    "os.spawnl("+arg+","+filename+','+ shortPath+")",
    "os.spawnl(%s,%s,%s)" % (arg,filename,shortPath))
test(
    "os.spawnv("+arg[0]+","+repr(vtuple)+")",
    "os.spawnv(%s,%s)" % (arg[0],repr(vtuple)))</t>
<t tx="ekr.20041019080125">print "Loaded plugins..."

for s in g.app.loadedPlugins:
    print s</t>
<t tx="ekr.20041019124050">test1 = p.firstChild()
test2 = p.firstChild().next()

c.prettyPrintPythonCode(p=test2,dump=False)

assert(test2.bodyString()==test1.bodyString())</t>
<t tx="ekr.20041019124050.1">"""
line 1
line 2
line 3
"""</t>
<t tx="ekr.20041019124050.2">"""
line 1
line 2
line 3
"""</t>
<t tx="ekr.20041020100733">import leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041020100733.1"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last line</t>
<t tx="ekr.20041020100733.2"># Test that @nosent generates no sentinels

section line 1
unnamed node line 1
last line</t>
<t tx="ekr.20041020100918">section line 1</t>
<t tx="ekr.20041020100918.1">unnamed node line 1</t>
<t tx="ekr.20041021062800">import leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041021063220"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last line</t>
<t tx="ekr.20041021063220.1">section line 1</t>
<t tx="ekr.20041021063220.2">unnamed node line 1</t>
<t tx="ekr.20041021063220.3">#@+leo-ver=4
#@+node:#@noref
# Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last line
#@nonl
#@-node:#@noref
#@+node:&lt;&lt; section &gt;&gt;
section line 1
#@nonl
#@-node:&lt;&lt; section &gt;&gt;
#@+node:unnamed node
unnamed node line 1
#@nonl
#@-node:unnamed node
#@-leo
</t>
<t tx="ekr.20041021065844">import leoTest

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20041021065844.1"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last linesection line 1unnamed node line 1</t>
<t tx="ekr.20041021065903"># Test that @nosent generates no sentinels

&lt;&lt; section &gt;&gt;

@others

last line</t>
<t tx="ekr.20041021065903.1">section line 1</t>
<t tx="ekr.20041021065903.2">unnamed node line 1</t>
<t tx="ekr.20041021071036"></t>
<t tx="ekr.20041029111650">print g.app.debugSwitch

g.app.debugSwitch = 0 # 2: drop into pdb

zerodivide = 1 / 0</t>
<t tx="ekr.20041105091229">g.pdb()</t>
<t tx="ekr.20041107105213">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20041107105213.1">@language forth

\ tiny demo of Leo forth syntax colouring
\ 
\ If you've correctly installed the hacked LeoPy.leo, the below you should see:
\  - the ':' 's' and ';' in blue
\  - the paren-comment in red
\  - the string 'some string' in green

: some-forth-word ( x1 x2 -- x3 )
   s" some string" type cr
;</t>
<t tx="ekr.20041109164251"></t>
<t tx="ekr.20041109174338">@ignore

This is a template node.

First substitution: %s

Second sustitution: %s</t>
<t tx="ekr.20041109174338.1"></t>
<t tx="ekr.20041111084431"># Go To Line number now assumes that selected node is
# the root of a script if there is no ancestor @file node.

@others

# last line</t>
<t tx="ekr.20041111084431.1"># We should also be able to use the goto line number command to get to the erroneous line.

a = 1/0 # ZeroDivisionError

b = 2</t>
<t tx="ekr.20041111124032">import leoPlugins as plugins

def traceHook(tag,event):
    g.trace(tag)
    
tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

plugins.registerHandler(tags,traceHook)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    print "-" * 20
    for h in handlers:
        print h</t>
<t tx="ekr.20041111124353">import leoPlugins as plugins

tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

for tag in tags:
    handlers = plugins.getHandlersForTag(tag)
    if handlers:
        print handlers
        for f in handlers:
            plugins.unregisterHandler(tag,f)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    print "-" * 20
    for h in handlers:
        print h</t>
<t tx="ekr.20041111130231"></t>
<t tx="ekr.20041111130231.1">import leoPlugins as plugins

tags = (
    "boxclick1","boxclick2",
    "drag1","drag2",
    "dragging1","dragging2",
    "enddrag1","enddrag2",
    "iconclick1","iconclick2"  , 
    "iconrclick1","iconrclick2",
    "icondclick1","icondclick2",
)

handlers = plugins.getHandlersForTag(tags)
if handlers:
    print "-" * 20
    for h in handlers:
        print h</t>
<t tx="ekr.20041112094406.2">"""Mini test that documentation of hooks in leoDocs.leo is correct.

hookData should match that documentation for this test to be effective.

This is not a complete unit test:  it does not force executions of all hooks.
"""

&lt;&lt; imports &gt;&gt;
&lt;&lt; define hookData &gt;&gt;
&lt;&lt; define typeData &gt;&gt;
checked = [] # List of all hooks that have been checked.

@others

tags = [] 
for name,args in hookData:
    tags.append(name)
    &lt;&lt; define checkHook &gt;&gt;
    leoPlugins.registerHandler(name,checkHook)
    
if 0: # print all hooks.
    handlers = leoPlugins.getHandlersForTag(tags)
    if handlers:
        print "-" * 20
        for h in handlers:
            print h</t>
<t tx="ekr.20041112094406.3">hookData = (
    ("bodyclick1",   ("c","p","v","event")),
    ("bodyclick2",   ("c","p","v","event")),
    ("bodydclick1",  ("c","p","v","event")),
    ("bodydclick2",  ("c","p","v","event")),
    ("bodykey1",     ("c","p","v","ch","oldSel","undoType")),
    ("bodykey2",     ("c","p","v","ch","oldSel","undoType")),
    ("bodyrclick1",  ("c","p","v","event")),
    ("bodyrclick2",  ("c","p","v","event")),
    ("boxclick1",    ("c","p","v","event")),
    ("boxclick2",    ("c","p","v","event")),
    ("command1",     ("c","p","v","label")),
    ("command2",     ("c","p","v","label")),
    ("drag1",        ("c","p","v","event")),
    ("drag2",        ("c","p","v","event")),
    ("dragging1",    ("c","p","v","event")),
    ("dragging2",    ("c","p","v","event")),
    ("end1",         None),
    ("enddrag1",     ("c","p","v","event")),
    ("enddrag2",     ("c","p","v","event")),
    ("headclick1",   ("c","p","v","event")),
    ("headclick2",   ("c","p","v","event")),
    ("headrclick1",  ("c","p","v","event")),
    ("headrclick2",  ("c","p","v","event")),
    ("headkey1",     ("c","p","v","ch")),
    ("headkey2",     ("c","p","v","ch")),
    ("hypercclick1", ("c","p","v","event")),
    ("hypercclick2", ("c","p","v","event")),
    ("hyperenter1",  ("c","p","v","event")),
    ("hyperenter2",  ("c","p","v","event")),
    ("hyperleave1",  ("c","p","v","event")),
    ("hyperleave2",  ("c","p","v","event")),
    ("iconclick1",   ("c","p","v","event")),
    ("iconclick2",   ("c","p","v","event")),
    ("iconrclick1",  ("c","p","v","event")),
    ("iconrclick2",  ("c","p","v","event")),
    ("icondclick1",  ("c","p","v","event")),
    ("icondclick2",  ("c","p","v","event")),
    ("idle",         ("c",)),
    ("menu1",        ("c","p","v")),
    ("menu2",        ("c","p","v")),
    ("open1",        ("old_c","new_c","fileName")),
    ("open2",        ("old_c","new_c","fileName")),
    ("openwith1",    ("c","p","v","openType","arg","ext")),
    ("openwith2",    ("c","p","v","openType","arg,ext" )),
    ("recentfiles1", ("c","p","v","fileName","closeFlag")),
    ("recentfiles2", ("c","p","v","fileName","closeFlag")),
    ("save1",        ("c","p","v","fileName" )),
    ("save2",        ("c","p","v","fileName" )),
    ("select1",      ("c","new_p","old_p","new_v","old_v")),
    ("select2",      ("c","new_p","old_p","new_v","old_v")),
    ("select3",      ("c","new_p","old_p","new_v","old_v")),
    ("set-mark",     ("c","p","v")),
    ("start1",       None),
    ("start2",       ("c","p","v","fileName" )),
    ("unselect1",    ("c","new_p","old_p","new_v","old_v")),
    ("unselect2",    ("c","new_p","old_p","new_v","old_v")),
    ("@url1",        ("c","p","v")),
    ("@url2",        ("c","p","v")),
    # Stub hooks.
    ("after-redraw-outline",         ("c",)),
    ("clear-mark",                   ("c","p","v")),
    ("close-frame",                  ("c",)),
    ("color-optional-markup",        ("colorer","p","v","s","i","j","colortag")),
    ("create-optional-menus",        ("c",)),
    ("destroy-all-global-windows",   None),
    ("draw-outline-box",             ("tree","p","v","x","y")), #
    ("draw-outline-icon",            ("tree","p","v","x","y")), #
    ("draw-outline-node",            ("tree","p","v","x","y")), #
    ("draw-outline-text-box",        ("tree","p","v","x","y")), #
    ("create-popup-menu-items",      ("c","p","v","event")),
    ("enable-popup-menu-items",      ("c","p","v","event")),
    ("init-color-markup",            ("colorer","p","v")),
    ("new",                          ("old_c","new_c")),
    ("redraw-entire-outline",        ("c",)),
    ("scan-directives",              ("c","p","v","s","old_dict","dict","pluginsList")),
    ("set-mark",                     ("c","p","v" )),
    ("show-popup-menu",              ("c","p","v","event")),
)</t>
<t tx="ekr.20041112100255">typeData = {
    "arg":      types.StringType,
    "c":        leoCommands.Commands,
    "ch":       types.StringType,
    "closeFlag":types.StringType,
    "colorer":  leoColor.colorizer,
    "colortag": types.StringType,
    "dict":     types.DictType,
    "event":    Tk.Event,
    "ext":      types.StringType,
    "fileName": types.StringType,
    "i":        types.IntType,
    "j":        types.IntType,
    "label":    types.StringType,
    "new_c":    leoCommands.Commands,
    "new_p":    leoNodes.position,
    "newSel":   types.TupleType,
    "new_v":    leoNodes.position,
    "old_c":    leoCommands.Commands,
    "old_dict": types.DictType,
    "old_p":    leoNodes.position,
    "oldSel":   types.TupleType,
    "old_v":    leoNodes.position,
    "openType": types.StringType,
    "p":        leoNodes.position,
    "pluginsList": types.ListType,
    "s":        types.UnicodeType,
    "tree":     leoTkinterTree.leoTkinterTree,
    "v":        leoNodes.position,
    "undoType": types.StringType,
    "x":        types.IntType,
    "y":        types.IntType,
}
</t>
<t tx="ekr.20041112102151">def checkHook (tag,keywords,args=args):

    """Check to see that the keywords passed to the hook are as described in args.
    Each arg is a list of strings whose type is defined in typeData."""

    global checked, verbose
    if tag in checked: return
    ok = True
    checked.append(tag)
    if args is None: args = []
    args = list(args)
    args.sort()
    keys = list(keywords.keys())
    keys.sort()
    
    if len(args) != len(keys):
        print "%25s expected:" % (tag),args
        print "%25s      got:" % (tag),keys
        ok = False
    else:
        for arg,key in zip(args,keys):
            arg_type = typeData.get(arg)
            val = keywords.get(key)
            if not checkOneHook(arg_type,val):
                print "%25s      arg:" % (tag), arg
                print "%25s expected:" % (tag), arg_type
                print "%25s      got:" % (tag), type(val)
                ok = False
    if ok:
        print tag</t>
<t tx="ekr.20041112103504">import leoColor
import leoCommands
import leoNodes
import leoPlugins
import leoTkinterTree

import types
import Tkinter as Tk</t>
<t tx="ekr.20041112155634">def checkOneHook (arg_type, val):
    
    if 0:
        if arg_type != type(val):
            g.trace(arg,key,arg_type,type(val))
    
    return (
        (arg_type is type(val)) or
        (arg_type == types.StringType and type(val) is types.UnicodeType) or
        (type(arg_type) == types.ClassType and isinstance(val,arg_type)))</t>
<t tx="ekr.20041113113555">import leoPlugins

spellpyx = leoPlugins.getPluginModule("spellpyx")
spellFrame = None
createMenu = spellpyx is None
keys = {'c':c}

if not spellpyx:
    spellpyx = leoPlugins.loadOnePlugin("spellpyx",verbose=True)
    if spellpyx: spellpyx.onCreate('tag',keys)

if spellpyx:
    spellFrame = spellpyx.spellFrames.get(c)
    if spellFrame:
        if createMenu: spellFrame.createSpellMenu('tag',keys)
        spellFrame.checkSpelling()

if not spellpyx or not spellFrame:
    # Ask to be removed.
    g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20041121151002">@nocolor</t>
<t tx="ekr.20041124144944">import os
import sys
for s in sys.path:
    exists = os.path.exists(s)
    print "%5s %s" % (exists,s)</t>
<t tx="ekr.20041125145818.1">''' Replace the outline and body panes by a settings outline and settings widgets respectively'''

import leoConfig

# @button code does not get updated dynamically.
replaceBody=True
leoConfig.settingsController(c,replaceBody)</t>
<t tx="ekr.20041126035448"># Note: the source files contain mixed tabs/blanks, and that's very hard for Leo's imports to handle.

@tabwidth 8
@language python

path = r"c:\Python23\Lib\site-packages\Pmw\Pmw_1_1\lib\PmwPanedWidget.py"

path = r"c:\prog\PmwPanedWidget.py" # The same file with tabs converted to 8 blanks.

path = r"c:\Python23\Lib\site-packages\Pmw\Pmw_1_1\demos\All.py"

assert g.os_path_exists(path)

c.importCommands.importFilesCommand([path],"@file")</t>
<t tx="ekr.20041126055818.2">@ This is probably a better way of parsing Python text.
It does not import the module, so it is safe for untrusted code.
@c
import pyclbr # Python Command Line Browser support.
import sys
print '*' * 40 ; print
fileNames = ("leoCommands.py","leo.py","leoAtFile.py")
fileNames = (r"c:\Python23\Lib\site-packages\Pmw\Pmw_1_1\lib\PmwPanedWidget.py"),

for fileName in fileNames:
    dir,file = g.os_path_split(fileName)
    moduleName,ext = g.os_path_splitext(file)
    moduleDict = pyclbr.readmodule_ex(moduleName,[dir] + sys.path)
    print "module", moduleName,'-' * 40
    items = []
    for funcOrClass in moduleDict.keys():
        o = moduleDict.get(funcOrClass) # o is a descriptor.
        try:
            mdict = o.methods # Fails for functions.
            items.append((int(o.lineno),"*class",o.name),)
            mkeys = mdict.keys()
            for method in mkeys:
                lineno = mdict.get(method)
                items.append((int(lineno),"method",method),)
        except AttributeError:
            # funcOrClass is a function descriptor
            items.append((int(o.lineno),"function",o.name),)
    items.sort()
    for line,kind,name in items:
        print "%4d %8s %s" % (line,kind,name)</t>
<t tx="ekr.20041126132604"></t>
<t tx="ekr.20041130092210"></t>
<t tx="ekr.20041211044607"></t>
<t tx="ekr.20041213075902"># The font for the log pane. Default is default font for Tk.Text widgets.
# Tk translates invalid font names to another font in a system-dependent way.
# 
# Default size is 12 for Linux, 8 otherwise.

log_text_font_family = None
log_text_font_size = None
log_text_font_slant = None
log_text_font_weight = normal
</t>
<t tx="ekr.20041217042849"># The font for the log pane. Default is default font for Tk.Text widgets.
# Tk translates invalid font names to another font in a system-dependent way.
# 
# Default size is 12 for Linux, 8 otherwise.

body_text_font_family = Courier New
body_text_font_size = None
body_text_font_slant = None
body_text_font_weight = None
</t>
<t tx="ekr.20041217132317"></t>
<t tx="ekr.20041217132338"></t>
<t tx="ekr.20041217135841"></t>
<t tx="ekr.20041217142026">LightYellow1
#f2fdff</t>
<t tx="ekr.20041217143421">ivory1
#ffecea</t>
<t tx="ekr.20041217144914"></t>
<t tx="ekr.20041218100259"></t>
<t tx="ekr.20041218110904"></t>
<t tx="ekr.20041218141525"></t>
<t tx="ekr.20041218141525.1"># The font for the log pane. Default is default font for Tk.Text widgets.
# Tk translates invalid font names to another font in a system-dependent way.
# 
# Default size is 12 for Linux, 8 otherwise.

log_text_font_family = None
log_text_font_size = None
log_text_font_slant = roman
log_text_font_weight = normal
</t>
<t tx="ekr.20041218141525.2">body_text_font_family = None
body_text_font_size = None
body_text_font_slant = None
body_text_font_weight = None
</t>
<t tx="ekr.20041218141525.3">headline_text_font_family = None
headline_text_font_size = None
headline_text_font_slant = roman
headline_text_font_weight = normal
</t>
<t tx="ekr.20041219074454">moduleName = 'leoNodes'

exec 'import %s ; module = %s' % (moduleName,moduleName)

print module</t>
<t tx="ekr.20041219074843">@ignore</t>
<t tx="ekr.20041219074843.1"># A dummy file to test g.importExtension</t>
<t tx="ekr.20041219075144">print g.importExtension('testExtension')

print g.importModule('leoNodes')

print g.importExtension('leoNodes')

g.importModule('xyzzy',verbose=True)
g.importExtension('xyzzy',verbose=True)</t>
<t tx="ekr.20041220080654">import Tkinter as Tk

&lt;&lt; documentation about how to set general options &gt;&gt;
t = Tk.Text()

print '-' * 20

settings = (
    ('height','xyz'),
    ('width',30),
    ('xyzzy',2),
)

widget_keys = t.keys() # List of all valid settings for this widget.
widget_keys.sort()

# Make a list of valid settings, and warn about invalid settings.
valid_settings = []
for key,val in settings:
    if key in widget_keys:
        setting = key,val
        valid_settings.append(setting)
    else:
        s = "'%s' is not a valid Tk option for this widget" % key
        print s ; g.es(s,color='blue')
valid_settings.sort()

print 'before changes...'
for key,val in valid_settings:
    print '%s = %s' % (key,str(t.cget(key)))

for key,val in valid_settings:
    d = {key:val}
    try:
        if 1: # The preferred way, using the 'extended call syntax'.
            # This was introduced in Python 2.0.
            t.configure(**d)
        else: # The Python 1.x way.  Deprecated since Python 2.3.
            apply(t.configure,[],d)
    except Tk.TclError:
        s = "Tk exception setting '%s' to %s" % (key,repr(val))
        print s ; g.es(s,color='blue')

print 'after changes...'
for key,val in valid_settings:
    print '%s = %s' % (key, str(t.cget(key)))

if 0:
    print ; print 'all keys...'
    for key in widget_keys:
        print '%s = %s' % (key, str(t.cget(key)))</t>
<t tx="ekr.20041220091350">@nocolor
@
The keyword argument syntax is of course much more elegant, and less error prone. However, for compatibility with existing code, Tkinter still supports the older syntax. You shouldn't use this syntax in new programs, even if it might be tempting in some cases. For example, if you create a custom widget which needs to pass configuration options along to its parent class, you may come up with something like:

@color

    def __init__(self, master, **kw):
        Canvas.__init__(self, master, kw) # kw is a dictionary

@nocolor
This works just fine with the current version of Tkinter, but it may not work with future versions. A more general approach is to use the apply function:
@color

    def __init__(self, master, **kw):
        apply(Canvas.__init__, (self, master), kw)
        
@nocolor
The apply function takes a function (an unbound method, in this case), a tuple with arguments (which must include self since we're calling an unbound method), and optionally, a dictionary which provides the keyword arguments.

--------- Apply is deprecated ---------

apply( function, args[, keywords]) 

The function argument must be a callable object (a user-defined or built-in function or method, or a class object) and the args argument must be a sequence. The function is called with args as the argument list; the number of arguments is the length of the tuple. If the optional keywords argument is present, it must be a dictionary whose keys are strings. It specifies keyword arguments to be added to the end of the argument list.

Calling apply() is different from just calling function(args), since in that case there is always exactly one argument. The use of apply() is equivalent to function(*args, **keywords). Use of apply() is not necessary since the ``extended call syntax,'' as used in the last example, is completely equivalent. 

Deprecated since release 2.3. Use the extended call syntax instead, as described above.
</t>
<t tx="ekr.20041220165048"></t>
<t tx="ekr.20041220172118">@ignore</t>
<t tx="ekr.20041220172118.1">@nocolor

** The orginal file is .#localFileName.1.nnn
** The file modified by CVS is localFileName

'&lt;' * 7 localFileName
...
'=' * 7
...
'&gt;' * 7 1.nnn

&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
def spam-cvs1():
    pass # changed 1
=======
def spam2():
    pass
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.2</t>
<t tx="ekr.20041220172118.2">@ These do not affect outline structure.  

&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
def spam-cvs1():
    pass # changed 1
=======
def spam2():
    pass
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.2</t>
<t tx="ekr.20041220173231"># ------- These do affect outline structure. ------
# Leo does pretty well reading these, all things considered.

&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
#@+node:ekr.20041220170413.1:spam-1b
def spam():
=======
#@+node:ekr.20041220170413.1:spam-2b
def spam2():
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.3 # ------------------------------ duplicate sentinels above and below.
    pass
#@nonl
&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
#@-node:ekr.20041220170413.1:spam-1b
#@+node:ekr.20041220170413.2:eggs-1b
=======
#@-node:ekr.20041220170413.1:spam-2b
#@+node:ekr.20041220170413.2:eggs-2b
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.3
def eggs():
    pass
#@nonl
&lt;&lt;&lt;&lt;&lt;&lt;&lt; cvsConflict.py
#@-node:ekr.20041220170413.2:eggs-1b
=======
#@-node:ekr.20041220170413.2:eggs-2b
&gt;&gt;&gt;&gt;&gt;&gt;&gt; 1.3</t>
<t tx="ekr.20041220173748">@killcolor

- There are no real problems unless sentinels are involved.

- cvs does _not_ show a clean version of the new file on cvs.

- A script could create the new version from the old and "conflict" versions.
    - This might be a useful starting point.
        - old:  fileName.1.nnn
        - conflict: fileName
        - new: created by script
    
- How can Leo know that a conflict exists???
    - Look for '&lt;' * 7 and '&gt;' * 7.  What if these exist in an unconflicted file?
    - No.  Look for fileName.1.nnn files.

- Maybe the atFile read logic could detect a conflict?
    - Only after detecting a fileName.1.nnn file.
    - Only if 'repair_cvs_conflict' option is set.</t>
<t tx="ekr.20041222060224"></t>
<t tx="ekr.20041222060224.1">c.frame.unpackComponent('splitter1')</t>
<t tx="ekr.20041222060224.2">c.frame.unpackComponent('statusLine')
c.frame.packComponent('splitter1')
c.frame.packComponent('statusLine')</t>
<t tx="ekr.20041223124541">print g.dictToString(c.frame.componentsDict,tag='components')</t>
<t tx="ekr.20041223154332">c.frame.unpackComponent('body')</t>
<t tx="ekr.20041223154332.1">c.frame.packComponent('body')</t>
<t tx="ekr.20041223162754">c.frame.packComponent('log')</t>
<t tx="ekr.20041223162754.1">c.frame.packComponent('tree')</t>
<t tx="ekr.20041223162846">c.frame.unpackComponent('log')</t>
<t tx="ekr.20041223162846.1">c.frame.unpackComponent('tree')</t>
<t tx="ekr.20041224081744"></t>
<t tx="ekr.20041224081744.1">c.frame.unpackComponent('statusLine')</t>
<t tx="ekr.20041224081744.2">c.frame.packComponent('statusLine')</t>
<t tx="ekr.20041224081744.3"></t>
<t tx="ekr.20041224081744.4"></t>
<t tx="ekr.20041224081829"></t>
<t tx="ekr.20041224081829.1"></t>
<t tx="ekr.20041224081833"></t>
<t tx="ekr.20041224081833.1">c.frame.unpackComponent('hull')</t>
<t tx="ekr.20041224081833.2">c.frame.packComponent('hull')</t>
<t tx="ekr.20041224082127"></t>
<t tx="ekr.20041224082127.1">c.frame.unpackComponent('iconBar')</t>
<t tx="ekr.20041224082127.2">c.frame.unpackComponent('splitter1')
c.frame.unpackComponent('statusLine')

c.frame.packComponent('iconBar')
c.frame.packComponent('splitter1')
c.frame.packComponent('statusLine')</t>
<t tx="ekr.20041224095444"></t>
<t tx="ekr.20041224104031"></t>
<t tx="ekr.20041224104031.1">import Tkinter as Tk

# The new frame must be a child of splitter1Frame.
parentFrame = c.frame.component('splitter1Frame').getFrame()
f = Tk.Frame(parentFrame,background='red')

c.frame.componentClass(c,'new body',f)
c.frame.replaceBodyPaneWithComponent('new body')</t>
<t tx="ekr.20041224104031.2">c.frame.replaceBodyPaneWithComponent('body')</t>
<t tx="ekr.20041224104337"></t>
<t tx="ekr.20041224104416">c.frame.unpackComponent('iconBar')
c.frame.unpackComponent('splitter1')
c.frame.unpackComponent('statusLine')

class newIconBar (c.frame.iconBarClass):
    def clear(self):
        c.frame.iconBarClass.clear(self)
        g.trace()

hull = c.frame.component('hull').getFrame()
newIconBar = newIconBar(c,hull)

newIconBarComponent = c.frame.componentClass(c,'newIconBar',hull,newIconBar,newIconBar.pack,newIconBar.unpack)
c.frame.iconBarComponentName = 'newIconBar'
c.frame.iconBar = newIconBarComponent
c.frame.clearIconBar()

c.frame.packComponent('newIconBar')
c.frame.packComponent('splitter1')
c.frame.packComponent('statusLine')</t>
<t tx="ekr.20041224115905"></t>
<t tx="ekr.20041224115905.1">c.frame.unpackComponent('newIconBar')
c.frame.unpackComponent('splitter1')
c.frame.unpackComponent('statusLine')

c.frame.iconBarComponentName = 'iconBar'

c.frame.packComponent('iconBar')
c.frame.packComponent('splitter1')
c.frame.packComponent('statusLine')</t>
<t tx="ekr.20041225051328">@language python
@ignore</t>
<t tx="ekr.20041225051328.1">'currentPath: %s' % path
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
zx
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
&gt;
_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-_-
</t>
<t tx="ekr.20041225051328.2">@others</t>
<t tx="ekr.20041225051445">[syntax coloring options]
color_cweb_comments_with_latex = 1
section_name_color = red
doc_part_color = firebrick3
color_cweb_doc_parts_with_latex = 1
directive_color = blue
cweb_section_name_color = red
undefined_section_name_color = red
use_hyperlinks = 1
keyword_color = blue
comment_color = firebrick3
leo_keyword_color = #00aa00
underline_undefined_section_names = 1
show_invisibles_space_background_color = Gray90
string_color = #00aa00
section_name_brackets_color = blue
show_invisibles_tab_background_color = Gray80
color_directives_in_plain_text = 1

[window options]
body_text_background_color = 
body_time_format_string = %m/%d/%Y %H:%M:%S
headline_gmt_time = 0
body_text_font_size = None
body_insertion_cursor_color = 
log_text_foreground_color = 
headline_text_editing_foreground_color = black
headline_text_unselected_background_color = white
headline_text_unselected_foreground_color = black
look_for_control_drag_on_mouse_down = 1
allow_clone_drags = 0
log_text_font_weight = normal
headline_text_selected_background_color = gray80
enable_drag_messages = 0
headline_text_editing_selection_background_color = DarkBlue
headline_text_font_weight = normal
headline_text_selected_foreground_color = black
log_error_color = red
log_pane_wraps = 0
headline_text_font_family = 
initial_window_top = 20
split_bar_relief = groove
initial_window_width = 800
additional_body_text_border = 0
log_text_font_family = 
body_text_font_weight = normal
body_cursor_background_color = 
log_text_font_slant = roman
body_text_font_family = Courier New
initial_vertical_secondary_ratio = 0.7
initial_vertical_ratio = 0.5
log_text_background_color = 
body_text_foreground_color = 
initial_splitter_orientation = v
initial_horizontal_secondary_ratio = 0.5
headline_time_format_string = %m/%d
outline_pane_scrolls_horizontally = 0
smart_auto_indent = 0
log_text_font_size = None
initial_horizontal_ratio = 0.3
headline_text_editing_background_color = white
outline_pane_background_color = 
body_text_font_slant = roman
split_bar_color = LightSteelBlue2
initial_window_left = 20
headline_text_font_size = None
split_bar_width = 6
initial_window_height = 600
body_cursor_foreground_color = 
body_pane_wraps = 1
body_gmt_time = 0
headline_text_font_slant = roman
headline_text_editing_selection_foreground_color = white
expanded_click_area = 1

[prefs panel options]
output_doc_chunks = 1
run_untangle_done.py = 0
page_width = 80
tangle_outputs_header = 1
default_target_language = Python
run_tangle_done.py = 0
default_tangle_directory = 
tab_width = -4

[compare options]
limit_count = 9
ignore_interior_whitespace = 0
append_output_to_output_file = 0
make_whitespace_visible = 0
output_file = 
ignore_first_line_of_file_1 = 0
ignore_leading_whitespace = 0
ignore_first_line_of_file_2 = 0
limit_directory_search_extension = .py
compare_file_1 = 
compare_file_2 = 
ignore_sentinel_lines = 0
print_mismatching_lines = 1
print_both_lines_for_matches = 0
print_trailing_lines = 1
print_matching_lines = 0
ignore_blank_lines = 1

[config options]
read_only = 0
redirect_execute_script_output_to_log_pane = 0
relative_path_base_directory = .
use_psyco = 0
new_leo_file_encoding = UTF-8
output_initial_comment = 
default_derived_file_encoding = UTF-8
config_encoding = utf-8
write_strips_blank_lines = 1
trailing_body_newlines = one
remove_sentinels_extension = .txt
tk_encoding = 
output_newline = nl
stylesheet = 
at_root_bodies_start_in_doc_mode = 1
write_old_format_derived_files = 0
create_nonexistent_directories = 0
use_plugins = 1
save_clears_undo_buffer = 0
use_gnx = 1

[keyboard shortcuts]
writefilenodes = Shift+Ctrl+W
contractnode = Alt+[
markchangeditems = Alt+C
markclones = Alt+K
extractnames = Shift+Ctrl+N
marksubheads = Alt+S
deletenode = Shift+Ctrl+BkSp
promote = Ctrl+{
gotoprevsibling = Alt+Shift+R
aboutleo = None
gotoparent = Alt+Shift+P
expandnode = Alt+]
save = Ctrl+S
gotofirstnode = Alt+Shift+G
gotolastnode = Alt+Shift+H
gotoprevvisible = Alt+UpArrow
markchangedroots = Alt+R
cantredo = Shift+Ctrl+Z
gotonextmarked = Alt+M
sortsiblings = Alt-A
matchbrackets = Ctrl+K
writedirtyatfilenodes = Shift+Ctrl+Q
unmarkall = Alt+U
untangle = Shift+Ctrl+U
reformatparagraph = Shift+Ctrl+P
readoutlineonly = Shift+Ctrl+R
close = Ctrl+W
extract = Shift+Ctrl+D
expandprevlevel = Alt+.
preferences = Ctrl+Y
cantundo = Ctrl+Z
insertheadlinetimedate = Shift+Ctrl+H
gotonextnode = Alt+Shift+DnArrow
exit = Ctrl-Q
new = Ctrl+N
tanglemarked = Shift+Ctrl+M
moveup = Ctrl+U
contractparent = Alt+0
cut = Ctrl+X
contractall = Alt+-
paste = Ctrl+V
expandall = Alt+9
unindent = Ctrl+[
indent = Ctrl+]
executescript = Ctrl+E
clonenode = Ctrl+`
extractsection = Shift+Ctrl+E
editheadline = Ctrl+H
replace = Ctrl+=
toggleactivepane = Ctrl+T
demote = Ctrl+}
tangle = Shift+Ctrl+T
open = Ctrl+O
setcolors = Alt+Shift+C
selectall = Ctrl+A
saveas = Shift+Ctrl+S
mark = Ctrl+M
insertbodytimedate = Shift+Ctrl+G
aborteditheadline = Shift+Esc
gotonextcloned = Alt+N
copy = Ctrl+C
convertblanks = Shift+Ctrl+B
movedown = Ctrl+D
contractorgoleft = Alt+LtArrow
equalsizedpanes = None
moveright = Ctrl+R
replacethenfind = Ctrl+-
pastenode = Shift+Ctrl+V
moveleft = Ctrl+L
importtofile = Shift+Ctrl+F
setfont = Alt+Shift+F
findpanel = Ctrl+F
openpythonwindow = Alt+P
gotonextvisible = Alt+DnArrow
expandtolevel5 = Alt+5
showinvisibles = Alt+V
insertnode = Ctrl+I
findprevious = F2
expandnextlevel = Alt+=
expandorgoright = Alt+RtArrow
copynode = Shift+Ctrl+C
gotolinenumber = Alt+G
checkspelling = Alt+Shift+A
findnext = F3
tangleall = Shift+Ctrl+A
endeditheadline = Esc
gotonextsibling = Alt+Shift+S
cutnode = Shift+Ctrl+X
gotonextchanged = Alt+D
converttabs = Shift+Ctrl+J
expandtolevel7 = Alt+7
expandtolevel6 = Alt+6
gotoprevnode = Alt+Shift+UpArrow
expandtolevel4 = Alt+4
expandtolevel3 = Alt+3
expandtolevel2 = Alt+2
expandtolevel1 = Alt+1
expandtolevel8 = Alt+8

[recent files]
file0 = C:\prog\leoCVS\leo\src\LeoPy.leo

[find/change options]
mark_changes = 0
ignore_case = 0
change_string = 
whole_word = 1
script_search = 0
node_only = 0
selection_only = 0
batch = 0
search_headline = 0
script_change = 0
search_body = 1
find_string = .update
pattern_match = 0
wrap = 0
mark_finds = 0
suboutline_only = 0
reverse = 0

</t>
<t tx="ekr.20041225092227"></t>
<t tx="ekr.20041225092227.1">import Tkinter as Tk

# The new frame must be a child of splitter2Frame.
parentFrame = c.frame.component('splitter2Frame').getFrame()
f = Tk.Frame(parentFrame,background='red')

c.frame.componentClass(c,'newTree',f)
c.frame.replaceTreePaneWithComponent('newTree')</t>
<t tx="ekr.20041225092227.2">c.frame.replaceTreePaneWithComponent('tree')</t>
<t tx="ekr.20041225102217"></t>
<t tx="ekr.20041225102217.1">import Tkinter as Tk

# The new frame must be a child of splitter2Frame.
parentFrame = c.frame.component('splitter2Frame').getFrame()
f = Tk.Frame(parentFrame,background='red')

c.frame.componentClass(c,'newLog',f)
c.frame.replaceLogPaneWithComponent('newLog')</t>
<t tx="ekr.20041225102217.2">c.frame.replaceLogPaneWithComponent('log')</t>
<t tx="ekr.20041225104159.1">''' Replace the outline and body panes by a settings outline and settings widgets respectively'''

import leoConfig

replaceBody=False

leoConfig.settingsController(c,replaceBody)</t>
<t tx="ekr.20041227081159">print c
print 'use_plugins',c.use_plugins
print 'tab_width',c.tab_width
print 'page_width',c.page_width</t>
<t tx="ekr.20041228135008">@language python
@tabwidth -4

import webbrowser

if 0:
    &lt;&lt; alternate code doesn't work well for me &gt;&gt;

def showHtml(html):
    '''Display html in a web browser'''
    fileName = g.os_path_join(g.app.loadDir,'..','test','leoTemp.html')
    f = file(fileName,'w')
    f.write(html)
    f.close()
    webbrowser.open(fileName)
    
# Display the selected node in the browser.
showHtml('&lt;pre&gt;%s&lt;/pre&gt;' % c.currentPosition().bodyString())

# To do: use a stylesheet to colorize the code.</t>
<t tx="ekr.20041228140714"># http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/347810
import BaseHTTPServer

def showHtml(html):
    """Display html in the default web browser without creating a temp file.

    Instantiates a trivial http server and calls webbrowser.open with a URL
    to retrieve html from that server.
    """

    class RequestHandler(BaseHTTPServer.BaseHTTPRequestHandler):
        def do_GET(self):
            g.trace(html)
            bufferSize = 1024*1024
            for i in xrange(0, len(html), bufferSize):
                self.wfile.write(html[i:i+bufferSize])

    server = BaseHTTPServer.HTTPServer(('127.0.0.1',0), RequestHandler)
    webbrowser.open('http://127.0.0.1:%s' % server.server_port)
    server.handle_request()</t>
<t tx="ekr.20041229163210">'''A script to send the colorized text of a script to the default web browser.

Based on a dynascript by 'e'.'''

@language python
@tabwidth -4

&lt;&lt; imports &gt;&gt;

hopts = {
  'stripcomments':  False,
  'stripsentinals': True,
  'stripnodesents': False, # False: leave node sentinels.
  'stripdirectives':False,
  'noNUMBER':       False,
  'noOP':           False,
  'noNAME':         True,  
  'timestring':     '' # time.strftime('%m/%d/%Y %H:%M.%S'),
}

&lt;&lt; init globals &gt;&gt;

filename = g.os_path_join(g.app.loadDir,'..','test','leoTemp.html')

@others

htmlize(c,p)</t>
<t tx="ekr.20041229163210.2">_KEYWORD = token.NT_OFFSET + 1
_TEXT    = token.NT_OFFSET + 2

_colors = {
    token.NUMBER:     '#483D8B', #black/darkslateblue
    token.OP:         '#000080', #black/navy
    token.STRING:     '#00AA00', #green 00cc66
    tokenize.COMMENT: '#DD0000', #red cc0033
    token.NAME:       '#4B0082', #black/indigo
    token.ERRORTOKEN: '#FF8080', #redred bare null does it
    _KEYWORD:         '#0066ff', #blue
    _TEXT:            '#000000', #black /is text fg color too
    '_LeoDir':        '#228B22', #directive, forest comment
    '_LeoSen':        '#BC8F8F', #sentinal, tan fade comment
    'bg':             '#FFFAFA', #snow
}

if hopts['noNUMBER']: del _colors[token.NUMBER]
if hopts['noOP']:     del _colors[token.OP]
if hopts['noNAME']:   del _colors[token.NAME]</t>
<t tx="ekr.20041229163210.3">class Parser(object):
    """ prep the source for any language
        parse and Send colored python source.
    """
    @others</t>
<t tx="ekr.20041229163210.4">def __init__(self,lang,raw,title):
    """ Store the source text."""

    self.title = title
    self.raw = raw.strip().expandtabs(4)

    if lang == 'python':
        cmtdelim = '#'
    else:
        d = g.scanDirectives(c, p) 
        cmtdelim = d.get('delims',['#'])
        cmtdelim = cmtdelim[0] or cmtdelim[1]
    
    self.fnd = re.compile(r"%s@\s*@+."%(cmtdelim,) )

    if hopts['stripsentinals']: 
        # have to add option to strip all comments as well
        self.raw = stripSentinels(self.raw)</t>
<t tx="ekr.20041229163210.5">def format(self,formatter,form):
    """ Parse and send the colored source."""

    # store line offsets in self.lines
    self.lines = [0,0]
    pos = 0
    while 1:
        pos = self.raw.find('\n',pos) + 1
        if not pos: break
        self.lines.append(pos)
    self.lines.append(len(self.raw))
    self.pos = 0
    text = cStringIO.StringIO(self.raw)
    sys.stdout.write('&lt;html&gt;&lt;head&gt;&lt;title&gt;')
    sys.stdout.write('%s &lt;/title&gt;\n'%(sanitize(self.title), ))

    #here would be a good spot for @noindent directive but skip a line
    s = """&lt;STYLE TYPE="text/css"&gt;&lt;!--
pre, H1 {color:%s; FONT-SIZE: 80%%; FONT-WEIGHT: bold; }
Text {background:%s;}
--&gt;&lt;/STYLE&gt;
&lt;SCRIPT LANGUAGE="JavaScript"&gt;
&lt;!-- //
//--&gt;
&lt;/SCRIPT&gt;""" % (_colors[_TEXT],_colors['bg'])

    sys.stdout.write(s)
    sys.stdout.write('&lt;/head&gt;&lt;body text="%s" bgColor="%s"&gt;' % (_colors[_TEXT],_colors['bg']))
    sys.stdout.write('&lt;H3&gt;# %s&lt;/H3&gt;\n'%self.title)
    sys.stdout.write('&lt;pre&gt;')  # style
    sys.stdout.write('&lt;font face="Lucida,Courier New"&gt;')
    # parse the source and write it
    try:
        tokenize.tokenize(text.readline,self)
    except tokenize.TokenError, ex:
        msg = ex[0]
        line = ex[1][0]
        print "&lt;h3&gt;ERROR: %s&lt;/h3&gt;%s" % (msg, self.raw[self.lines[line]:])
    sys.stdout.write('&lt;/font&gt;&lt;/pre&gt;')
    sys.stdout.write('&lt;/body"&gt;&lt;/html&gt;')</t>
<t tx="ekr.20041229163210.6">def __call__(self, toktype, toktext, (srow,scol), (erow,ecol), line):

    """ Token handler."""

    if 0: print "type", toktype, token.tok_name[toktype], "text",\
            toktext, "start", srow,scol, "end", erow,ecol, "&lt;br&gt;"

    # calculate new positions
    oldpos = self.pos
    newpos = self.lines[srow] + scol
    self.pos = newpos + len(toktext)

    # handle newlines
    if toktype in [token.NEWLINE, tokenize.NL]:
        print
        return

    style = ''
    if toktype == tokenize.COMMENT:
        if toktext.lstrip().startswith('#@'):
            if self.fnd.findall(toktext):
                toktype = '_LeoDir'
            else:
                toktype = '_LeoSen'

    # Send the original whitespace.
    if newpos &gt; oldpos:
        sys.stdout.write(self.raw[oldpos:newpos])

    # Skip indenting tokens.
    if toktype in [token.INDENT,token.DEDENT]:
        self.pos = newpos
        return

    # Map token type to a color group
    if token.LPAR &lt;= toktype and toktype &lt;= token.OP:
        toktype = token.OP
    elif toktype == token.NAME and keyword.iskeyword(toktext):
        toktype = _KEYWORD
    if toktype == token.ERRORTOKEN:
        style = ' style="border: solid 1.5pt #FF0000;"'

    dofont = True
    try:
        color = _colors[toktype]
    except Exception:
        dofont = False

    if dofont: sys.stdout.write('&lt;font color="%s"%s&gt;' % (color, style))
    sys.stdout.write(cgi.escape(toktext))
    if dofont: sys.stdout.write('&lt;/font&gt;')</t>
<t tx="ekr.20041229163210.7">if lang in [ # Leo may not have all of these yet
    'csharp', 'c', 'c++', 'cpp', # (C and C++)
    'css', # (Cascading Style Sheets)
    'htm', 'html', # HTML/PHP w/ JavaScript, VBScript, Python
    'plain', #null (No styling)
    'perlpod', 'perl', # (Perl)
    #'python', # (Python)
    'ruby', # (Ruby)
    'smart_python', # (Python with styled strings)
    'sql', # (SQL)
    'xml', # (XML)
    'xslt', # (XSLT)
    'yaml', # (YAML)
    # basic &amp; java? missing. might send java as c?
    'elisp', 'php', 'java', 'rapidq', 'actionscript', 'css',
]:
    if lang in ('htm','html','php','java','rapidq','actionscript', 'css'):
        lang = 'html'
    elif lang in ['c','c++','cpp']: lang = 'cpp'
    elif lang in ['perlpod','perl']: lang = 'perl'
    elif lang in ['elisp',]: lang = 'perl'
    if lang in ('plain',None): lang = 'null'

    g.es('writing tmpname', tmpfile )
    fo = file(tmpfile, 'w')
    fo.writelines(pars.raw + "\n")
    fo.close()
    
    cmd = g.os_path_join(pypath, 'Scripts', 'source2html.py')

    # Send the output to stdout
    #" --view %N  %N.html"
    # --css=file copy silver_city.css where the filename will be
    # source2html.py --list-generators
    params = ' --generator=%s --title=%s --css=silver_city.css %s'%(
       lang, sanitize_(title), tmpfile,)  

    if not g.os_path_exists(cmd):
        g.es('cant find source2html install silvercity')
        print 'cant find source2html from silvercity'
    else:
        g.es('running silvercity \n', py + cmd + params )
        out, err = runcmd(py + cmd + params )
        for x in (out + err).splitlines():
            print x
else:
    print '&lt;i&gt;not a known htmlize supported language&lt;/i&gt;'
    #might have to do a sequential dump of nodes, or @rst?
    #is title and first headline set the same for all options?
    print '&lt;Pre&gt;'    
    print pars.raw
    print '&lt;/Pre&gt;'</t>
<t tx="ekr.20041229164609">import cgi
import cStringIO
import keyword
import os
import re
import sys
import time
import token
import tokenize
import webbrowser</t>
<t tx="ekr.20041229164609.2">def htmlize(c,p):
    lang = g.scanForAtLanguage(c,p)
    lang = str(lang).lower()
    source = g.getScript(c,p)
    timestring = hopts['timestring']
    # title = "%s Leo %s script %s" % (p.headString()[:75],lang,timestring)
    title = "%s %s" % (p.headString()[:75],timestring)
    try:
        if not source: raise ValueError
        g.es('output', lang, p.headString())
        theParser = Parser(lang,source,title)
        sys.stdout = open(filename,'wb') 
        if lang == 'python':
            theParser.format(None,None)
        else:
            &lt;&lt; colorize with silvercity &gt;&gt;
        sys.stdout.close()
        sys.stdout = sys.__stdout__
        webbrowser.open(filename, new= 1)
    except ValueError:
        g.es('no @path set, unsupported lang or empty script',color='tomato')
        g.es(lang, p.headString())
    except Exception:
        g.es('htmlize malfunction?', color='tomato')
        g.es_exception(full= True)</t>
<t tx="ekr.20041229165956">def sanitize(s):
    
    """Leo's sanitize_filename is too aggressive and too lax."""

    if not s: return

    res = re.compile(
        r"""[|\\ /!@=\#\$%,\x5E&amp;\x3F:;.\x22\x27&lt;&gt;`~\*\+\t\n\f\r\b\a]""",
        re.IGNORECASE | re.VERBOSE)

    # should test for unicode before str()
    return res.sub('_', str(s.strip())).replace('__','_')[:128]</t>
<t tx="ekr.20041229170824">def stripSentinels(s):

    '''Strip sentinal lines from s.'''
    
    lines = s.splitlines()
    result = [] ; verbatim = False
    tag1 = '#@+node:'
    tag2 = '#@-node:'
    n = len(tag1)

    for line in lines:
        s = line.strip()
        if verbatim:
            result.append(line)
            verbatim = False
        elif s.startswith('#@verbatim'):
            verbatim = True
        elif s.startswith('#@@'):
            if not hopts['stripdirectives']:
                result.append(line)
        elif s.startswith(tag1):
            if not hopts['stripnodesents']:
                i = line.find(tag1)
                result.append(line[:i] + '#@+' + line[i+n:].strip())
        elif s.startswith(tag2):
            if not hopts['stripnodesents']:
                i = line.find(tag2)
                result.append(line[:i] + '#@-' + line[i+n:].strip())
        elif not s.startswith('#@'):
            result.append(line)

    return '\n'.join(result)</t>
<t tx="ekr.20041230085841">import glob,sys,traceback

def printModules():
    mods = sys.modules.keys()
    mods.sort()
    for mod in mods: print mod

def leoModules():
    files = glob.glob(r'%s\*.py' % g.app.loadDir)
    modules = []
    for file in files:
        path,file = g.os_path_split(file)
        module,ext = g.os_path_splitext(file)
        if g.match(module,0,'leo'):
            modules.append(module)
    return modules
            
def delLeoModules():
    for module in leoModules():
        if module in sys.modules:
            del sys.modules[module]

def test():
    for module in leoModules():
        print module
        exec 'import %s' % module in {},{}
        del sys.modules[module]
    
delLeoModules()        
test()
# printModules()</t>
<t tx="ekr.20041230090756">def test():
    '''Tests whether all files can be imported.'''
    import glob, os, sys, traceback
    dir = r'c:\prog\leoCVS\leo\src'
    files = glob.glob(r'%s\*.py' % dir)
    modules = []
    for file in files:
        path,file = os.path.split(file)
        module,ext = os.path.splitext(file)
        if module[:3] == 'leo':
            modules.append(module)
    for module in modules:
        print module
        try:
            exec 'import %s' % module in {},{}
            del sys.modules[module]
        except:
            traceback.print_exc()
            
def printModules():
    import sys
    mods = sys.modules.keys()
    mods.sort()
    for mod in mods: print mod
    
</t>
<t tx="ekr.20041230121429">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20041231083027">@ignore</t>
<t tx="ekr.20041231083027.1">@others</t>
<t tx="ekr.20041231083027.2">def foo():
    pass</t>
<t tx="ekr.20041231083027.3">def bar():
    pass
    
@ doc part 1
more

@ doc part 2
still more</t>
<t tx="ekr.20041231083027.4">def spam():
    pass</t>
<t tx="ekr.20041231083651">@others</t>
<t tx="ekr.20041231083651.1">def foo():
    pass</t>
<t tx="ekr.20041231083651.2">def bar():
    pass
    
@ doc part 1
more

@ doc part 2
still more</t>
<t tx="ekr.20041231083651.3">def spam():
    pass</t>
<t tx="ekr.20041231092350"></t>
<t tx="ekr.20041231105200">node 1, line 1</t>
<t tx="ekr.20041231105200.1">node 2, line 1</t>
<t tx="ekr.20041231105200.2"></t>
<t tx="ekr.20041231105348">@path c:\prog\test\atStripTest.txt</t>
<t tx="ekr.20050103092214">import token
import tokenize

@others

print '*' * 40

if 1:
    parser = pythonParser(c,p)
    parser.parseNode(p)
else:
    parser = dumper(c,p)
    parser.parseNode(p)</t>
<t tx="ekr.20050103092214.3">class dumper (pythonParser):
    
    @others</t>
<t tx="ekr.20050103092214.4">def __init__ (self,c,p):

    # Init the base class.
    pythonParser.__init__ (self,c,p,dumping=True)</t>
<t tx="ekr.20050103092214.5">class pythonParser:
    
    @others</t>
<t tx="ekr.20050103092214.6">if 0:
    @others</t>
<t tx="ekr.20050103092214.7">def clear (self):
    self.lines = []</t>
<t tx="ekr.20050103092214.8">def endUndo (self):
    
    c = self.c
    
    if self.changed:

        # Tag the end of the command.
        c.undoer.setUndoParams("Pretty Print",self.p)</t>
<t tx="ekr.20050103092214.9">def get (self):
    
    return self.lines</t>
<t tx="ekr.20050103092214.10">def put (self,s,strip=True):
    
    """Put s to self.array, and strip trailing whitespace if strip is True."""
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # Stripping trailing whitespace doesn't strip leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace, so we can strip whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20050103092214.11">def putArray (self):
    
    """Add the next line by joining all the strings is self.array"""
    
    self.lines.append(''.join(self.array))
    self.array = []</t>
<t tx="ekr.20050103092214.12">def replaceBody (self,p,lines):
    
    c = self.c
    
    sel = c.frame.body.getInsertionPoint()
    oldBody = p.bodyString()
    body = string.join(lines,'')
    
    p.setBodyStringOrPane(body)
    
    if not self.changed:

        # Tag the start of the command.
        c.undoer.setUndoParams("Pretty Print",self.p) 
        self.changed = True
    
    self.c.undoer.setUndoParams("Change",p,
        oldText=oldBody,newText=body,oldSel=sel, newSel=sel)</t>
<t tx="ekr.20050103092214.13">def prettyPrintNode(self,p,dump):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        self.clear()
        for token5tuple in tokenize.generate_tokens(readlines):
            self.putToken(token5tuple)
        lines = self.get()

    except tokenize.TokenError:
        g.es("Error pretty-printing %s.  Not changed." % h, color="blue")
        return

    if dump:
        self.dumpLines(p,lines)
    else:
        self.replaceBody(p,lines)</t>
<t tx="ekr.20050103092214.14">def putToken (self,token5tuple):
    
    if self.dumping:
        self.dumpToken(token5tuple)
    else:
        self.putNormalToken(token5tuple)</t>
<t tx="ekr.20050103092214.15">def __init__ (self,c,p,dumping=False):
    
    self.c = c
    self.p = p
    
    # Debugging ivars...
    self.dumping = dumping
    self.tracing = False
    
    # State ivars...
    self.bracketLevel = 0
    self.erow = self.ecol = 0 # The ending row/col of the token.
    self.inDocPart = False
    self.line = 0 # Same as self.srow
    self.name = None
    self.parenLevel = 0
    self.srow = self.scol = 0 # The starting row/col of the token.
    self.startline = True # True: the token starts a line.
    self.val = None
    
    if 0: # old ivars
        self.array = [] # List of strings comprising the line being accumulated.
        self.changed = False
        self.lines = [] # List of lines.
        self.prevName = None
        self.s = None # The string containing the line.

    &lt;&lt; define dispatch dict &gt;&gt;</t>
<t tx="ekr.20050103092214.16">self.dispatchDict = {
    
    "comment":    self.doMultiLine,
    "dedent":     self.doDedent,
    "endmarker":  self.doEndMarker,
    "errortoken": self.doErrorToken,
    "indent":     self.doIndent,
    "name":       self.doName,
    "newline":    self.doNewline,
    "nl" :        self.doNewline,
    "number":     self.doNumber,
    "op":         self.doOp,
    "string":     self.doMultiLine,
}</t>
<t tx="ekr.20050103092214.17">def parseNode(self,p):

    c = self.c
    h = p.headString()
    s = p.bodyString()
    if not s: return
    
    readlines = g.readLinesGenerator(s).next

    try:
        if self.dumping:
            for token5tuple in tokenize.generate_tokens(readlines):
                self.dumpToken(token5tuple)
        else:
            for token5tuple in tokenize.generate_tokens(readlines):
                self.doToken(token5tuple)

    except tokenize.TokenError:
        g.es("Error parseing %s" % h, color="blue")
        return</t>
<t tx="ekr.20050103092214.18">def dumpLines (self,p,lines):

    encoding = g.app.tkEncoding
    
    print ; print '-'*10, p.headString()
    
    if 0:
        for line in lines:
            line2 = g.toEncodedString(line,encoding,reportErrors=True)
            print line2, # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            line = lines[i]
            line = g.toEncodedString(line,encoding,reportErrors=True)
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20050103092214.19">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    name = token.tok_name[t1].lower()
    val  = str(t2) # can fail
    srow,scol = t3
    erow,ecol = t4
    line = str(t5) # can fail

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20050103092214.21">def oops(self):
    
    print "unknown tokenize code: %s" % (self.name)</t>
<t tx="ekr.20050103092214.22">def trace(self):
    
    if self.tracing:

        g.trace("%10s: %s" % (
            self.name,
            repr(g.toEncodedString(self.val,"utf-8"))
        ))</t>
<t tx="ekr.20050103092214.23">def doToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    self.name = token.tok_name[t1].lower() # The token type
    self.val = t2  # the token string
    self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
    self.s = t5 # The line containing the token.
    self.startLine = self.line != self.srow
    self.line = self.srow
    
    try: t2 = str(t2)
    except: pass
    try: t5 = str(t5)
    except: pass
    
    if 1: # Dump...
        if self.startLine: print 'Line %s' % self.line
        # print '%3d %20s %10s %10s %s' % (t1,repr(t2),t3,t4,repr(t5))
        print '%20s %s' % (repr(str(self.s[self.scol:self.ecol])),repr(t5))
        
    
    if self.startLine:
        self.doStartLine()
    
    f = self.dispatchDict.get(self.name,self.oops)
    f()</t>
<t tx="ekr.20050103092214.24">def doEndMarker (self):
    
    # End of text marker.
    pass</t>
<t tx="ekr.20050103092214.25">def doErrorToken (self):
    
    if 0:
        self.array.append(self.val)
    
        if self.val == '@':
            # Preserve whitespace after @.
            i = g.skip_ws(self.s,self.scol+1)
            ws = self.s[self.scol+1:i]
            if ws:
                self.array.append(ws)</t>
<t tx="ekr.20050103092214.26">def doDedent (self):
    
    pass
    
def doIndent (self):
    
    if 0:
        self.array.append(self.val)
</t>
<t tx="ekr.20050103092214.27">def doMultiLine (self):
    
    '''Handle a multiline token: i.e., a string or comment.'''
    
    if 0:
        # These may span lines, so duplicate the end-of-line logic.
        lines = g.splitLines(self.val)
        for line in lines:
            self.array.append(line)
            if line and line[-1] == '\n':
                self.putArray()
                
        # Suppress start-of-line logic.
        self.line = self.erow</t>
<t tx="ekr.20050103092214.28">def doName(self):

    if 0:
        self.array.append("%s " % self.val)
        if self.prevName == "def": # A personal idiosyncracy.
            self.array.append(' ') # Retain the blank before '('.
        self.prevName = self.val</t>
<t tx="ekr.20050103092214.29">def doNewline (self):
    
    if 0:
        self.array.append('\n')
        self.putArray()</t>
<t tx="ekr.20050103092214.30">def doNumber (self):

    if 0:
        self.array.append(self.val)
</t>
<t tx="ekr.20050103092214.31">def doOp (self):
    
    # New in Python 2.4: '@' is an op token.
    val = self.val
    
    if 0:
        if val == '(':
            self.parenLevel += 1
            self.put(val)
        elif val == ')':
            self.parenLevel -= 1
            self.put(val)
        elif val == '=':
            if self.parenLevel &gt; 0: self.put('=')
            else:                   self.put(' = ')
        elif val == ',':
            if self.parenLevel &gt; 0: self.put(',')
            else:                   self.put(', ')
        elif val == ';':
            self.put(" ; ")
        else:
            self.put(val)</t>
<t tx="ekr.20050103092214.32">def doStartLine (self):

    before = self.s[0:self.scol]
    i = g.skip_ws(before,0)
    self.ws = self.s[0:i]
    
    # g.trace(repr(before),repr(self.ws))
         
    if 0:
        if self.ws:
            self.array.append(self.ws)</t>
<t tx="ekr.20050103095602">def handleAtPart (self):
    
    s = self.s

    #self.srow,self.scol = t3 # row &amp; col where the token begins in the source.
    #self.erow,self.ecol = t4 # row &amp; col where the token ends in the source.
</t>
<t tx="ekr.20050104095950"># Switch EqualSizedPanes and ExecuteScript

# EqualSizedPanes = Ctrl+E
# ExecuteScript = Alt+Ctrl+E
# Exit = alt-ctrl-Z</t>
<t tx="ekr.20050105080048"></t>
<t tx="ekr.20050105080048.1">f = c.frame
assert(f.c==c)
assert(c.frame==f)

if g.app.gui.guiName() == 'tkinter':
    ivars = (
        'bar1','bar2',
        'body','bodyBar','bodyCtrl','bodyXBar',
        'canvas',
        'f1','f2',
        'iconBar','iconFrame',
        'log','outerFrame',
        'statusLine','statusFrame','statusLabel','statusText',
        'title','top','tree','treeBar',
    )
else: ivars = ()

for ivar in ivars:
    assert hasattr(f,ivar), 'missing frame ivar: %s' % ivar
    val = getattr(f,ivar)
    assert val is not None,'null frame ivar: %s'% ivar
    
# These do not have to be initied.
for ivar in ('findPanel',):
    assert hasattr(f,ivar), 'missing frame ivar: %s' % ivar</t>
<t tx="ekr.20050105082500">f = c.frame
assert(f.c==c)
assert(c.frame==f)

ivars = (
    # Subcommanders...
    'atFileCommands','fileCommands','importCommands','tangleCommands','undoer',
    # Positions...
    '_currentPosition','_rootPosition','_topPosition',
    # Data structures...
    'beadList','beadPointer','hoistStack','recentFiles','visitedList',
    # Args...
    'output_doc_flag','page_width','tab_width',
    'tangle_directory','tangle_errors','tangle_batch_flag','target_language',
    'untangle_batch_flag','use_header_flag',
    # Others...
    'mFileName',
)

for ivar in ivars:
    assert hasattr(c,ivar), 'missing commander ivar: %s' % ivar
    val = getattr(c,ivar)
    assert val is not None,'null commander ivar: %s'% ivar</t>
<t tx="ekr.20050105084757">ivars = ('extensionsDir','globalConfigDir','loadDir','testDir')

for ivar in ivars:
    assert hasattr(g.app,ivar), 'missing g.app directory: %s' % ivar
    val = getattr(g.app,ivar)
    assert val is not None, 'null g.app directory: %s'% ivar
    assert g.os_path_exists(g.os_path_abspath(val)), 'non-existent g.app directory: %s' % ivar
    
assert hasattr(g.app,'homeDir') # May well be None.</t>
<t tx="ekr.20050105084757.1">import os

exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)
    
assert not exists(path)
assert not g.utils_remove(path,verbose=False)

f = file(path,'w')
f.write('test')
f.close()

assert exists(path)
assert g.utils_remove(path,verbose=True)
assert not exists(path)</t>
<t tx="ekr.20050105090632">
ivars = (
    # These are non-official and might be removed...
        # 'afterHandler','count','positions',
        # 'menuWarningsGiven','unicodeErrorGiven',
    'batchMode','config',
    'debug','debugSwitch','disableSave',
    'gui','hasOpenWithMenu','hookError','hookFunction',
    'idle_imported','idleTimeDelay','idleTimeHook','initing','killed',
    'leoID','loadedPlugins','log','logIsLocked','logWaiting',
    'nodeIndices','numberOfWindows',
    'quitting','realMenuNameDict','searchDict','scriptDict',
    'trace','tracePositions','trace_list','tkEncoding',
    'unitTestDict','unitTesting','use_psyco','windowList',
)

for ivar in ivars:
    assert hasattr(g.app,ivar), 'missing app ivar: %s' % ivar
    val = getattr(g.app,ivar)
    assert val is not None, 'null app ivar: %s'% ivar
    
# These do not have to be initied.
for ivar in (
    'commandName',
    'openWithFiles','openWithFileNum','openWithTable',
    'root',
):
    assert hasattr(g.app,ivar), 'missing app ivar: %s' % ivar</t>
<t tx="ekr.20050105091547">import os

exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)

assert g.utils_rename(path,path2,verbose=True)
assert exists(path2)
f = file(path2)
s = f.read()
f.close()
# print 'Contents of %s: %s' % (path2,s)
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)</t>
<t tx="ekr.20050105093136">import os

at = c.atFileCommands
exists = g.os_path_exists

path = g.os_path_join(g.app.testDir,'xyzzy')
if exists(path):
    os.remove(path)
    
assert not exists(path)
assert not at.remove(path,verbose=False)

f = file(path,'w')
f.write('test')
f.close()

assert exists(path)
assert at.remove(path)
assert not exists(path)</t>
<t tx="ekr.20050105093524">import os

at = c.atFileCommands
exists = g.os_path_exists
path = g.os_path_join(g.app.testDir,'xyzzy')
path2 = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths.
for p in (path,path2):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    f.write('test %s' % p)
    f.close()
    assert exists(p)

assert at.rename(path,path2,verbose=True)
assert exists(path2)
f = file(path2)
s = f.read()
f.close()
# print 'Contents of %s: %s' % (path2,s)
assert s == 'test %s' % path
os.remove(path2)
assert not exists(path)</t>
<t tx="ekr.20050105094311">import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths (different contents)
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    s = 'test %s' % p
    # print repr(p),repr(s)
    f.write(s)
    f.close()
    assert exists(p) # , '%s does not exist' % repr(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
assert at.replaceTargetFileIfDifferent(), 'replaceTargetFileIfDifferent returns False'
if 0:
    print '%s exists %s' % (at.outputFileName,exists(at.outputFileName))
    print '%s exists %s' % (at.targetFileName,exists(at.targetFileName))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = file(at.targetFileName)
s = f.read()
f.close()
# print 'Contents of %s: %s' % (at.targetFileName,s)
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)</t>
<t tx="ekr.20050105095743">import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Create both paths (identical contents)
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
    assert not exists(p)
    f = file(p,'w')
    s = 'test %s' % at.outputFileName
    # print repr(p),repr(s)
    f.write(s)
    f.close()
    assert exists(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
assert not at.replaceTargetFileIfDifferent(), 'replaceTargetFileIfDifferent returns True'
if 0:
    print '%s exists %s' % (at.outputFileName,exists(at.outputFileName))
    print '%s exists %s' % (at.targetFileName,exists(at.targetFileName))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = file(at.targetFileName)
s = f.read()
f.close()
# print 'Contents of %s: %s' % (at.targetFileName,s)
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)</t>
<t tx="ekr.20050105100227">import os

at = c.atFileCommands
exists = g.os_path_exists

at.outputFileName = g.os_path_join(g.app.testDir,'xyzzy1')
at.targetFileName = g.os_path_join(g.app.testDir,'xyzzy2')

# Remove both files, then create only the output file
for p in (at.outputFileName,at.targetFileName):
    if exists(p):
        os.remove(p)
        
for p in (at.outputFileName,):
    assert not exists(p)
    f = file(p,'w')
    s = 'test %s' % at.outputFileName
    # print repr(p),repr(s)
    f.write(s)
    f.close()
    assert exists(p)

at.toString = False # Set by execute script stuff.
at.shortFileName = at.targetFileName
assert not at.replaceTargetFileIfDifferent(), 'replaceTargetFileIfDifferent returns True'
if 0:
    print '%s exists %s' % (at.outputFileName,exists(at.outputFileName))
    print '%s exists %s' % (at.targetFileName,exists(at.targetFileName))
assert not exists(at.outputFileName), 'oops, output file exists'
assert exists(at.targetFileName), 'oops, target file does not exist'
f = file(at.targetFileName)
s = f.read()
f.close()
# print 'Contents of %s: %s' % (at.targetFileName,s)
assert s == 'test %s' % at.outputFileName, 'unexpected contents of target file'
os.remove(at.targetFileName)</t>
<t tx="ekr.20050106080304">import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.currentPosition()
&lt;&lt; class testRoutineTestCase &gt;&gt;
@others

if 1: # Scan all Leo modules _except_ leoTest.py.
    modules = getAllLeoModules()
else: # Scan just leoTest.py.
    modules = ('leoTest',)

g.app.unitTestDict["fail"] = False

suite = unittest.makeSuite(unittest.TestCase)
for module in modules:
    n = addTestRoutinesInModuleToSuite(c,g,module,suite)
    if n:
        plural = g.choose(n==1,'','s')
        s = 'found %2d test routine%s for %s' % (n,plural,module)
        print s ; g.es(s)

if 1: # For @suite nodes.  Better for unit testing.
    g.app.scriptDict['suite'] = suite
else: # For script button nodes.  Good for testing.
    # Verbosity: 1: print just dots.
    unittest.TextTestRunner(verbosity=1).run(suite)
    c.setChanged(changed) # Restore changed state.
    c.selectVnode(p1) # N.B. Restore the selected node.</t>
<t tx="ekr.20050106080318">def addTestRoutinesInModuleToSuite (c,g,moduleName,suite):
    
    module = g.importModule(moduleName)
    assert(module)

    tests = findTestsInModule(module,moduleName)
    
    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,moduleName,theClass,f,code,verbose=False)
        suite.addTest(testCase)
        
    return len(tests)</t>
<t tx="ekr.20050106080318.1">class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20050106080318.2">def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.currentPosition().copy()
    self.verbose = verbose
</t>
<t tx="ekr.20050106080318.3">def fail (self,msg=None):

    """Mark a unit test as having failed."""
    
    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050106080318.4">def setUp (self):

    g.app.unitTesting = True</t>
<t tx="ekr.20050106080318.5">def tearDown (self):

    g.app.unitTesting = False</t>
<t tx="ekr.20050106080318.6">def runTest (self):
    
    f = self.f ; name = f.__name__ ; theClass = self.theClass
    
    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)
            
        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec s in d # Execute s in a environment containing c, g and p.
        
    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)</t>
<t tx="ekr.20050106080318.7">def shortDescription (self):

    return 'test function',repr(self.f)</t>
<t tx="ekr.20050106081120.2">def findTestsInModule (module,moduleName):
    
    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes   = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]
        
    # April 6, 2005: Ignore base classes.
    subClasses = []
    for theClass in classes:
        for theClass2 in classes:
            if theClass != theClass2 and issubclass(theClass2,theClass):
                subClasses.append(theClass2)
        
    # print '%20s' % (moduleName),'subClasses',g.listToString(subClasses)
    
    baseClasses = []
    for theClass in classes:
        for subClass in subClasses:
            if theClass != subClass and issubclass(subClass,theClass):
                baseClasses.append(theClass)
                
    # print '%20s' % (moduleName),'baseClasses',g.listToString(baseClasses)
    
    classes = [theClass for theClass in classes
        if theClass in subClasses or not theClass in baseClasses]
        
    if 0:
        classNames = [theClass.__name__ for theClass in classes]
        print '%20s' % (moduleName),'classes',classNames
    
    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # print '\nmethods of class %s...\n\n%s' % (theClass,toString(methods))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    functions = [(None,f) for name,f in functions if name.startswith('test_')]

    if 0:
        &lt;&lt; print classes, methods &amp; functions &gt;&gt;
    if 0:
        if functions:
            print 'test functions in %s...\n%s' % (moduleName,toString(functions))
    
    result = functions
    result.extend(allMethods)
    return result</t>
<t tx="ekr.20050106094747">def addTestRoutinesInCommanderToSuite(c,suite):
    
    tests = findTestsInCommander(c)
    
    for test in tests:
        testCase = commanderTestCase(c,test)
        suite.addTest(testCase)</t>
<t tx="ekr.20050106094854">class commanderTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20050106094854.1">def __init__ (self,c,test):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.test = test</t>
<t tx="ekr.20050106094854.2">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    
    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050106094854.3">def setUp (self):

    g.app.unitTesting = True</t>
<t tx="ekr.20050106094854.4">def tearDown (self):

    g.app.unitTesting = False</t>
<t tx="ekr.20050106094854.5">def runTest (self):

    # Try to run the function.
    self.test()</t>
<t tx="ekr.20050106094854.6">def shortDescription (self):

    return 'test function',repr(self.test)</t>
<t tx="ekr.20050106095223">def findTestsInCommander (c):
    
    print '=' * 40
    
    toString = g.listToString

    allMethods = []
    for obj in (c,c.frame,c.frame.tree):
        methods = inspect.getmembers(obj,inspect.ismethod)
        # print '\nmethods of %s...\n\n%s' % (obj,toString(methods))
        methods = [f for name,f in methods if name.startswith('test')]
        allMethods.extend(methods)
        print '\ntest methods in %s...\n\n%s'   % (obj,toString(methods))

    return allMethods</t>
<t tx="ekr.20050106123646">if 0:
    @others</t>
<t tx="ekr.20050106124235">print '=' * 40

if classes:
    print 'classes in %s...\n%s' % (moduleName,toString(classes))
else:
    print 'no classes in %s' % (moduleName)
if allMethods:
    print 'test methods in %s...\n%s'   % (moduleName,toString(allMethods))
else:
    print 'no test methods in %s' % (moduleName)
if functions:
    print 'test functions in %s...\n%s' % (moduleName,toString(functions))
else:
    print 'no test functions in %s' % (moduleName)</t>
<t tx="ekr.20050106124624">def getAllLeoModules ():

    path = g.os_path_join(g.app.loadDir,"..","src")

    files = glob.glob(g.os_path_join(path,"leo*.py"))
    files = [g.os_path_abspath(f) for f in files]
    files = [str(g.shortFileName(f)) for f in files]
    files.sort()
    
    # This caused duplicates
    # modules = [g.os_path_splitext(f)[0] for f in files]
    
    modules = []
    for f in files:
        module = g.os_path_splitext(f)[0]
        if module not in modules:
            modules.append(module)
    
    if 'leoTest' in modules:
        modules.remove('leoTest')
    
    # g.trace(g.listToString(modules))
    return modules</t>
<t tx="ekr.20050106133147">def removeLeadingWs (code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        else:
            print 'underindented line:%s' % repr(line)
            result.append(line)
            
    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result</t>
<t tx="ekr.20050108110751"></t>
<t tx="ekr.20050108110751.1">@ Here is a function to convert the font tags to equivalent span tags. Note use
of font-size:x-large to show how styling can be used for emphasis.

Uses a regular expression to insert style CSS classes before &lt;/STYLE&gt; closing
tag ...so &lt;STYLE&gt;&lt;/STYLE&gt; is expected to exist in input html.
@c

def font2span(colorizedusingFONT):
    aa=colorizedusingFONT
    styleClasses="""    .token_STRING    {color:#00AA00;} 
    .token_NUMBER    {color:#483D8B;}
    .token_OP        {color:#000080;} 
    .tokenize_COMMENT{color:#DD0000;} 
    .token_NAME      {color:#4B0082;} 
    .token_ERRORTOKEN{color:#FF8080;} 
    .KEYWORD        {color:#0066ff;} 
    .TEXT           {color:#000000;} 
    .LeoDir       {color:#228B22;} 
    .LeoSen       {color:#BC8F8F;font-size:x-large;} 
    .bg            {color:#FFFAFA;} 
    """
    myRE=re.compile(r"&lt;/STYLE&gt;")              ;aa=myRE.sub(styleClasses+"\n&lt;/STYLE&gt;",aa)
    myRE=re.compile(r'&lt;font color="#00AA00"&gt;');aa=myRE.sub('&lt;span class="token_STRING"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#483D8B"&gt;');aa=myRE.sub('&lt;span class="token_NUMBER"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#000080"&gt;');aa=myRE.sub('&lt;span class="token_OP"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#DD0000"&gt;');aa=myRE.sub('&lt;span class="tokenize_COMMENT"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#4B0082"&gt;');aa=myRE.sub('&lt;span class="token_NAME"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#FF8080"&gt;');aa=myRE.sub('&lt;span class="token_ERRORTOKEN"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#0066ff"&gt;');aa=myRE.sub('&lt;span class="KEYWORD"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#000000"&gt;');aa=myRE.sub('&lt;span class="TEXT"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#228B22"&gt;');aa=myRE.sub('&lt;span class="LeoDir"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#BC8F8F"&gt;');aa=myRE.sub('&lt;span class="LeoSen"&gt;',aa)
    myRE=re.compile(r'&lt;font color="#FFFAFA"&gt;');aa=myRE.sub('&lt;span class="bg"&gt;',aa)
    myRE=re.compile(r'&lt;/font&gt;')               ;aa=myRE.sub('&lt;/span&gt;',aa)
    
    basefontSize="12pt"
    basefontFamily="Lucida,Courier New"
    myRE=re.compile(r'&lt;font face="Lucida,Courier New"&gt;');
    aa=myRE.sub('&lt;span style="font:'+basefontSize+' '+basefontFamily+';"&gt;',aa)

    return aa</t>
<t tx="ekr.20050108110751.2">@ To adjust this script internally to use span tags and CSS style classes make
the following changes to  three nodes as follows:
@c

# I. in "init globals" node change the _colors dictionary to use lists 
# (with 3 values representing color, CSS class, extra styling) as follows:

_colors = {
    token.NUMBER:     ['#483D8B','token_NUMBER',' '], #black/darkslateblue
    token.OP:         ['#000080','token_OP',' '], #black/navy
    token.STRING:     ['#00AA00','token_STRING',' '], #green 00cc66
    tokenize.COMMENT: ['#DD0000','tokenize_COMMENT',' '], #red cc0033
    token.NAME:       ['#4B0082','token_NAME',' '], #black/indigo
    token.ERRORTOKEN: ['#FF8080','token_ERRORTOKEN',' '], #redred bare null does it
    _KEYWORD:         ['#0066ff','KEYWORD',' '], #blue
    _TEXT:            ['#000000','TEXT',' '], #black /is text fg color too
    '_LeoDir':        ['#228B22','LeoDir',' '], #directive, forest comment
    '_LeoSen':        ['#BC8F8F','LeoSen','font-size:x-large;'], #sentinal, tan fade comment
    'bg':             ['#FFFAFA','bg',' '], #snow
}</t>
<t tx="ekr.20050112095306"></t>
<t tx="ekr.20050112095306.1"></t>
<t tx="ekr.20050113094943">stuff = g.toEncodedString(u'','utf-8')
print type(stuff)
print '*' * 10
for ch in stuff:
    print ch, ord(ch),
print</t>
<t tx="ekr.20050114101014">@ignore</t>
<t tx="ekr.20050115100918">root line 1
&lt;&lt; level 1&gt;&gt;
root line 2
&lt;&lt; level 2 &gt;&gt;
root line 3
&lt;&lt; level 3 &gt;&gt;
root line 4
&lt;&lt; level 4 &gt;&gt;
root line 5</t>
<t tx="ekr.20050115100918.1">level 1 line 1
&lt;&lt; level 2 &gt;&gt;
level 1 line 2
&lt;&lt; level 3 &gt;&gt;
level 1 line 3
&lt;&lt; level 4 &gt;&gt;
level 1 line 4</t>
<t tx="ekr.20050115100918.2">level 2 line 1
&lt;&lt; level 4 &gt;&gt;
level 2 line 2
&lt;&lt; level 3 &gt;&gt;
level 2 line 3</t>
<t tx="ekr.20050115100918.3">level 3 line 1
&lt;&lt; level 4 &gt;&gt;
level 3 line 2
</t>
<t tx="ekr.20050115103123">level 4 line 1</t>
<t tx="ekr.20050115103442">root line 1
&lt;&lt; level 1&gt;&gt;
root line 2
&lt;&lt; level 2 &gt;&gt;
root line 3
&lt;&lt; level 3 &gt;&gt;
root line 4
&lt;&lt; level 4 &gt;&gt;
root line 5</t>
<t tx="ekr.20050115103442.1">level 1 line 1
&lt;&lt; level 2 &gt;&gt;
level 1 line 2
&lt;&lt; level 3 &gt;&gt;
level 1 line 3
&lt;&lt; level 4 &gt;&gt;
level 1 line 4</t>
<t tx="ekr.20050115103442.2">level 2 line 1
&lt;&lt; level 4 &gt;&gt;
level 2 line 2
&lt;&lt; level 3 &gt;&gt;
level 2 line 3</t>
<t tx="ekr.20050115103442.3">level 3 line 1
&lt;&lt; level 4 &gt;&gt;
level 3 line 2
</t>
<t tx="ekr.20050115103442.4">level 4 line 1</t>
<t tx="ekr.20050119144013">@killcolor

Most dependencies are already gone.

- Search for c: in headline shows only a few tests for plugins.
- We could change \\ to , in the import tests,  or have the test call g.os_path_join implicitly.

Still to do:

There are a lot of 'quick and dirty' file tests that never became proper unit tests.

    - Changed c:\prog\test\ to x, so all files now refer to Leo's test directory.
    - However, none of those files actually exist in the test directory, and I don't want to commit those files to cvs.
    - Again, the solution would probably be to create proper unit tests.</t>
<t tx="ekr.20050119220832"></t>
<t tx="ekr.20050120095423"># These are now compatible with the other unit tests.
# It may be a bit off-putting to run the two sets together, however...</t>
<t tx="ekr.20050120095423.1">@killcolor
@

What I did:

- chapters.py
    - Added some new keyword argument to several methods corresponding to leoFileCommands methods.
    - This plugin now appears to work.

- lineNumbers.py
    - Changed leoAtFile.newDerivedFile to leoAtFile.atFile in several places.
    - Again, this is required because of changes in 4.3 to Leo's core code.

- dynamenu.py
    - Changed all instances of g.os_path_norm to g.os_path_normpath</t>
<t tx="ekr.20050120095423.2">@

  File "C:\prog\leoCVS\leo\src\leoGlobals.py", line 4285, in importFromPath
    result = imp.load_module(mod_name,theFile,pathname,description)

ImportError: Module use of python23.dll conflicts with this version of Python.</t>
<t tx="ekr.20050120095423.3">@

Can not import Tkinter from plugin table</t>
<t tx="ekr.20050120095423.4">@

Can not import Ft from plugin xsltWithNodes</t>
<t tx="ekr.20050120095423.5">@ignore
# leo.py
g.doHook("start1")
g.doHook("start2",c=c,p=p,v=p,fileName=fileName)
# leoApp.py
g.doHook("close-frame",c=c)
g.doHook("end1")
# leoColor.py
g.doHook("init-color-markup",colorer=self,p=self.p,v=self.p)
g.doHook("color-optional-markup",
    colorer=self,p=self.p,v=self.p,s=s,i=i,j=j,colortag="comment")
# leoCommands.py
g.doHook("command1",        c=c,p=p,v=p,label=label)
g.doHook("command2",        c=c,p=p,v=p,label=label)
g.doHook("new",             old_c=self,new_c=c)
g.doHook("openwith1",       c=c,p=v,v=v,openType=openType,arg=arg,ext=ext)
g.doHook("openwith2",       c=c,p=v,v=v,openType=openType,arg=arg,ext=ext)
g.doHook("recentfiles1",    c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
g.doHook("recentfiles2",    c=c,p=v,v=v,fileName=fileName,closeFlag=closeFlag)
# leoAtFile.py
g.doHook("save1",c=c,p=v,v=v,fileName=fileName)
g.doHook("save2",c=c,p=v,v=v,fileName=fileName)
g.doHook("scan-directives",c=c,p=p,v=p,s=s,old_dict=old,dict=dict,pluginsList=pluginsList)
g.doHook("open1",old_c=old_c,new_c=c,fileName=fileName)
g.doHook("open2",old_c=old_c,new_c=c,fileName=fileName)
# leoGlobals.py
g.doHook("idle",c=c)
# leoMenu.py
g.doHook("create-optional-menus",c=c)
g.doHook("menu2",c=c,p=v,v=v)
# leoNodes.py
g.doHook("clear-mark",c=self.c,p=self,v=self)
g.doHook("set-mark",c=self.c,p=self,v=self)
# leoFrame.py
g.doHook("@url1",c=c,p=v,v=v)
g.doHook("@url2",c=c,p=v,v=v)
# leoGui.py
g.doHook("after-create-leo-frame",c=c)
# leoTkinterFrame.py
g.doHook("menu1",c=c,p=v,v=v)
g.doHook("bodyclick1",  c=c,p=v,v=v,event=event)
g.doHook("bodyclick2",  c=c,p=v,v=v,event=event)
g.doHook("bodyrclick1", c=c,p=v,v=v,event=event)
g.doHook("bodyrclick2", c=c,p=v,v=v,event=event)
g.doHook("bodydclick1", c=c,p=v,v=v,event=event)
g.doHook("bodydclick2", c=c,p=v,v=v,event=event)
g.doHook("bodykey1",    c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
g.doHook("bodykey2",    c=c,p=p,v=p,ch=ch,oldSel=oldSel,undoType=undoType)
g.doHook("hypercclick1",c=c,p=p,v=p,event=event)
g.doHook("hypercclick2",c=c,p=p,v=p,event=event)
g.doHook("hyperenter1", c=c,p=p,v=p,event=event)
g.doHook("hyperenter2", c=c,p=p,v=p,event=event)
g.doHook("hyperleave1", c=c,p=p,v=p,event=event)
g.doHook("hyperleave2", c=c,p=p,v=p,event=event)
# leoTkinterTree.py
g.doHook("draw-outline-box",        tree=tree,c=c,p=p,v=p,x=x,y=y)
g.doHook("draw-outline-icon",       tree=self,c=c,p=p,v=p,x=x,y=y)
g.doHook("draw-outline-node",       tree=self,c=c,p=p,v=p,x=x,y=y)
g.doHook("draw-outline-text-box",   tree=self,c=c,p=p,v=p,x=x,y=y)
g.doHook("draw-sub-outline",        tree=tree,c=c,p=p,v=p,x=x,y=y,h=h,level=level,hoistFlag=hoistFlag)
g.doHook("redraw-entire-outline",   c=c)
g.doHook("after-redraw-outline",    c=c)
g.doHook("boxclick1",               c=c,p=p,v=p,event=event)
g.doHook("boxclick2",               c=c,p=p,v=p,event=event)
g.doHook("iconclick1",              c=c,p=p,v=p,event=event)
g.doHook("iconclick2",              c=c,p=p,v=p,event=event)
g.doHook("iconrclick1",             c=c,p=p,v=p,event=event)
g.doHook("iconrclick2",             c=c,p=p,v=p,event=event)
g.doHook("icondclick1",             c=c,p=p,v=p,event=event)
g.doHook("icondclick2",             c=c,p=p,v=p,event=event)
g.doHook("headclick1",              c=c,p=p,v=p,event=event)
g.doHook("headclick2",              c=c,p=p,v=p,event=event)
g.doHook("headkey1",                c=c,p=p,v=p,ch=ch)
g.doHook("headkey2",                c=c,p=p,v=p,ch=ch)
g.doHook("drag1",                   c=c,p=p,v=p,event=event)
g.doHook("drag2",                   c=c,p=p,v=p,event=event)
g.doHook("dragging1",               c=c,p=p,v=p,event=event)
g.doHook("dragging2",               c=c,p=p,v=p,event=event)
g.doHook("enddrag1",                c=c,p=p,v=p,event=event)
g.doHook("enddrag2",                c=c,p=p,v=p,event=event)
g.doHook("create-popup-menu",       c=c,p=p,v=p,event=event)
g.doHook("enable-popup-menu-items", c=c,p=p,v=p,event=event)
g.doHook("show-popup-menu",         c=c,p=p,v=p,event=event)
g.doHook("unselect1",   c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
g.doHook("unselect2",   c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
g.doHook("select2",     c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)
g.doHook("select3",     c=c,new_p=p,old_p=old_p,new_v=p,old_v=old_p)</t>
<t tx="ekr.20050120095423.6"># N.B.  We don't import the files: multiple imports might cause problems.
import unittest
import leoTest

@others

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():

    f = file(path)
    assert f, "File not found: %s" % path
    s = f.read() ; f.close()
    test = parseFileTestCase(c,path,checkCompile=True,checkTabs=True)
    suite.addTest(test)

if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20050120095423.7">class parseFileTestCase (unittest.TestCase):

    @others</t>
<t tx="ekr.20050120095423.8">def __init__ (self,c,path,checkCompile,checkTabs):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.checkCompile = checkCompile
    self.checkTabs = checkTabs
    assert self.checkCompile or self.checkTabs, "not checking anything"</t>
<t tx="ekr.20050120095423.9">def runTest(self):
    
    c = self.c ; path = self.path

    s = file(path).read()

    if self.checkCompile:
        leoTest.checkFileSyntax(path,s)

    if self.checkTabs:
        leoTest.checkFileTabs(path,s)</t>
<t tx="ekr.20050120095423.10">def shortDescription (self):
    
    fn = str(g.shortFileName(self.path))
    
    if self.checkCompile and self.checkTabs:
        return "Test syntax and tabbing of %s plugin" % fn
    elif self.checkCompile:
        return "Test syntax of %s plugin" % fn
    else:
        return "Test tabbing of %s plugin" % fn</t>
<t tx="ekr.20050120095423.11"># Create unit tests in g.app.scriptDict["suite"]
import leoPlugins
import leoTest
import glob
import sys
import unittest

@others

suite = makePluginsTestSuite(c)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20050120095423.12">def makePluginsTestSuite(c):

    '''Create a plugin test for .py file in the plugins directory'''

    # Create the suite.
    suite = unittest.makeSuite(unittest.TestCase)

    # Add a test case for every plugin.
    plugins = g.os_path_join(g.app.loadDir,'..','plugins','*.py')
    plugins = g.os_path_abspath(plugins)
    files = glob.glob(plugins)
    files = [g.os_path_abspath(f) for f in files]
    files.sort()

    for f in files:
        test = pluginTestCase(c,f)
        # g.trace(test.shortDescription())
        suite.addTest(test)
        
    if 1: # Open a new window after all tests are completed.  Tests many plugins.
        lastTest = lastTestCase(c,openFlag=True)
        suite.addTest(lastTest)

    return suite</t>
<t tx="ekr.20050120095423.13">class pluginTestCase(unittest.TestCase):

    '''A test case to test a single Leo plugin.'''

    @others</t>
<t tx="ekr.20050120095423.14">def __init__ (self,c,path):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path</t>
<t tx="ekr.20050120095423.15">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050120095423.16">def runTest(self):

    c = self.c ; path = self.path
    
    path,file = g.os_path_split(path)
    moduleName,ext  = g.os_path_splitext(file)
    module = sys.modules.get(moduleName)

    if not module:
        module = leoPlugins.loadOnePlugin(moduleName,verbose=False)
        assert module, 'can not import %s' % moduleName</t>
<t tx="ekr.20050120095423.17">def setUp(self):

    g.app.unitTesting = True
    g.app.unitTestDict = {}</t>
<t tx="ekr.20050120095423.18">def shortDescription (self):

    return "pluginTestCase: %s" % g.shortFileName(self.path)</t>
<t tx="ekr.20050120095423.19">def tearDown (self):

    g.app.unitTesting = False</t>
<t tx="ekr.20050120095423.20">class lastTestCase(unittest.TestCase):

    '''A test case to print a message at the end of plugin tests.'''
    
    def __init__ (self,c,openFlag):
        # Init the base class.
        unittest.TestCase.__init__(self)
        self.c = c
        self.openFlag = openFlag

    def runTest(self):
        c = self.c
        print
        print '%s a new window to test more plugin logic' % g.choose(
            self.openFlag,'opening','open')
        print
        if self.openFlag:
            new_c = c.new() # Create the new window.
            new_c.frame.setTitle("unit test for 'new' hook")</t>
<t tx="ekr.20050120095423.21">import leoPlugins

print
print 'loaded plugins...'
for p in g.app.loadedPlugins:
    print p
    
leoPlugins.printHandlers()</t>
<t tx="ekr.20050123143337"></t>
<t tx="ekr.20050203001146"># g.es(c.page_width)

assert c.page_width == 80</t>
<t tx="ekr.20050203084930"></t>
<t tx="ekr.20050203084930.1">w = g.app.config.get(None,'global_setting_for_unit_tests','int')

assert w == 132</t>
<t tx="ekr.20050203085849">g.es(c.redirect_execute_script_output_to_log_pane)
g.es(c.config.redirect_execute_script_output_to_log_pane)
print 'hello'

#assert c.redirect_execute_script_output_to_log_pane is True
#assert c.config.redirect_execute_script_output_to_log_pane is True
</t>
<t tx="ekr.20050206090416">file = u''
path = g.os_path_join('','')
# print g.toEncodedString(file,'utf-8')

ok,frame = g.openWithFileName(path,c)

assert not ok and not frame</t>
<t tx="ekr.20050206201145">
s = "test(U+1FB9: Greek Capital Letter Alpha With Macron)"

s2 = 'test: %s' % s</t>
<t tx="ekr.20050208051418"></t>
<t tx="ekr.20050208051418.1">old_c = c
filename = "test(U+1FB9: Greek Capital Letter Alpha With Macron)"
ok,frame = g.openWithFileName(filename,old_c)
assert(not ok)</t>
<t tx="ekr.20050208051854">at = c.atFileCommands
at.errors = 0
at.printError(
    "test of printError: (U+1FB9: Greek Capital Letter Alpha With Macron)")</t>
<t tx="ekr.20050208073718">import os

# g.es("tkEncoding",g.app.tkEncoding,color='orange')

# These work only with utf-8 encoding.  Fails with g.app.TkEncoding &amp; 'mbcs'
if 1: 
    s = g.os_path_join(
        g.app.loadDir,'..','test','unittest','chinesefolder','chinesetest.leo',
        encoding='utf-8') 
else:
    s = 'c:\\prog\\leoCVS\\leo\\test\\unittest\\chinesefolder\\chinesetest.leo'
    s = g.toUnicode(s,'utf-8')

assert g.os_path_exists(s), 'g.os_path_exists fails'
assert os.path.exists(s),   'os.path.exists fails'
    
ok,frame = g.openWithFileName(s,c)
if frame: frame.c.close()

assert ok and frame, 'did not open'</t>
<t tx="ekr.20050208104202">
for s,encoding in (
    ('a',    'utf-8'),
    ('a',    'ascii'),
    ('',  'utf-8'),
    ('',  'mbcs'),
    ('',    'utf-8'),
    ('',    'mbcs'),
):
    if g.isValidEncoding(encoding):
        s2,ok = g.toUnicodeWithErrorCode(s,encoding)
        assert ok, 'toUnicodeWithErrorCode fails for %s' %s
        s3,ok = g.toEncodedStringWithErrorCode(s2,encoding)
        assert ok, 'toEncodedStringWithErrorCode fails for %s' % s2
        assert s3 == s, 'Round-trip one fails for %s' %s
        
        s2 = g.toUnicode(s,encoding)
        s3 = g.toEncodedString(s2,encoding)
        assert s3 == s, 'Round-trip two fails for %s' %s</t>
<t tx="ekr.20050208111037">
encoding = 'ascii'

s = ''

s2,ok = g.toUnicodeWithErrorCode(s,encoding)
assert not ok, 'toUnicodeWithErrorCode returns True for %s with ascii encoding' % s

s = u''
s3,ok = g.toEncodedStringWithErrorCode(s,encoding)
assert not ok, 'toEncodedStringWithErrorCode returns True for %s with ascii encoding' % s</t>
<t tx="ekr.20050208135429"># print g.listToString(dir())

for ivar in ('c','g','p'):
    assert ivar in dir()

assert hasattr(g.app,'tkEncoding')</t>
<t tx="ekr.20050210085211"># For some reason these don't select the dialog properly when run as a script.
# However, the main reason for the tests is to make sure the ctors don't crash.
# Also, for unit testing the value of c doesn't matter.

oldGui = g.app.gui ; guis = [g.app.gui]

if g.app.unitTesting:
    import leoGui
    guis.append(leoGui.unitTestGui({}))

for gui in guis:
    gui.runAboutLeoDialog(c,'version','copyright','url','email')
    gui.runAskLeoIDDialog()
    gui.runAskOkDialog(c,'title','message')
    gui.runAskOkCancelNumberDialog(c,'title','message')
    gui.runAskYesNoDialog(c,'title','message')
    gui.runAskYesNoCancelDialog(c,'title','message')

g.app.gui = oldGui</t>
<t tx="ekr.20050210092742">import leoTkinterComparePanel

leoTkinterComparePanel.leoTkinterComparePanel(c)

import leoTkinterFind

leoTkinterFind.leoTkinterFind(c)</t>
<t tx="ekr.20050210093857"></t>
<t tx="ekr.20050210180034"># The first script in Jython Essentials, by Pedroni &amp; Rappin.
import javax.swing as swing
import java.awt as awt
import java.lang as lang

def exit(event):
    lang.System.exit(0)
    
def onButtonPressed(event):
    field.text=quotes[event.source.text]
    
def createButton(name):
    return swing.JButton(name,preferredSize=(100,20),
        actionPerformed=onButtonPressed)
        
names = [ 'Groucho','Chico','Harpo']
quotes = {'Groucho':'Say the secret word','Chico':'Viaduct?','Harpo':'Honk!'}

w = swing.JFrame('Welcome to jython!',size=(200,200),windowClosing=exit)
w.contentPane.layout = awt.FlowLayout()

field = swing.JTextField(preferredSize=(200,20))
w.contentPane.add(field)

buttons = [createButton(name) for name in names]
for button in buttons:
    w.contentPane.add(button)

w.pack()
w.show()</t>
<t tx="ekr.20050210180937"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.headString()
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20050211121701">@others

test_g_removeExtraLws()</t>
<t tx="ekr.20050211121701.1">def removeExtraLws (s,tab_width):
    
    '''Removed extra indentation from one or more lines.'''
    
    lines = g.splitLines(s)

    # Find the first non-blank line:
    for s in lines:
       if s.strip():
            lws = g.get_leading_ws(s)
            w = g.computeWidth(lws,tab_width)
            # g.trace('w',w)
            break
    else: return s
    
    result = [g.removeLeadingWhitespace(line,w,tab_width) for line in lines]

    return ''.join(result)</t>
<t tx="ekr.20050211121701.2">def test_g_removeExtraLws():
    
    for s,expected in (
        (' a\n b\n c', 'a\nb\nc'),
        (' \n  A\n    B\n  C\n', '\nA\n  B\nC\n'),
    ):
        result = g.removeExtraLws(s,c.tab_width)
        assert result == expected, '\ns: %s\nexpected: %s\nresult:   %s' % (
            repr(s),repr(expected),repr(result))
            
    print 'Success'</t>
<t tx="ekr.20050216060307">@ignore</t>
<t tx="ekr.20050216060736">root = p.firstChild()

c.selectPosition(root,updateBeadList=False)

c.tangleCommands.tangle()</t>
<t tx="ekr.20050216060736.1">@root unittest\tangleTest1.txt

&lt;&lt; first child &gt;&gt;</t>
<t tx="ekr.20050216060736.2">This is the first child.
@c

And this is text</t>
<t tx="ekr.20050216062636">root = p.firstChild()
child = root.firstChild()
s = child.bodyString()

c.selectPosition(root,updateBeadList=False)

c.tangleCommands.untangle()
assert child.bodyString() != s, "untangle didn't update node"
assert child.isMarked()

child.setBodyTextOrPane(s)
child.clearMarked()
assert child.bodyString() == s, "unit test didn't restore body text"
assert not child.isMarked(), "unit test didn't restore mark"
</t>
<t tx="ekr.20050216062636.4">@root unittest\tangleTest1.txt

&lt;&lt; first child &gt;&gt;</t>
<t tx="ekr.20050216062636.5">This is the first child.
@c

And this is text (changed)</t>
<t tx="ekr.20050218015346">import glob
import inspect
import unittest

changed = c.isChanged() ; p1 = c.currentPosition()
&lt;&lt; class testRoutineTestCase &gt;&gt;
@others

plugins = getAllPlugins()

# g.printList(plugins)

if 1:
    g.app.unitTestDict["fail"] = False
    suite = unittest.makeSuite(unittest.TestCase)
    for plugin in plugins:
        n = addTestRoutinesInPluginToSuite(c,g,plugin,suite)
        if n:
            plural = g.choose(n==1,'','s')
            s = 'found %2d test routine%s for %s' % (n,plural,plugin)
            print s ; g.es(s)
    
    if 1: # For @suite nodes.  Better for unit testing.
        g.app.scriptDict['suite'] = suite
    else: # For script button nodes.  Good for testing.
        # Verbosity: 1: print just dots.
        unittest.TextTestRunner(verbosity=1).run(suite)
        c.setChanged(changed) # Restore changed state.
        c.selectVnode(p1) # N.B. Restore the selected node.</t>
<t tx="ekr.20050218015346.11">class testRoutineTestCase(unittest.TestCase):

    """Create a unit test from a snippet of code."""

    @others</t>
<t tx="ekr.20050218015346.12">def __init__ (self,c,g,moduleName,theClass,f,code,verbose=False):

     # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.moduleName = moduleName
    self.theClass = theClass
    self.f = f
    self.g = g
    self.code = code
    self.p = c.currentPosition().copy()
    self.verbose = verbose
</t>
<t tx="ekr.20050218015346.13">def fail (self,msg=None):

    """Mark a unit test as having failed."""

    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20050218015346.14">def setUp (self):

    g.app.unitTesting = True</t>
<t tx="ekr.20050218015346.15">def tearDown (self):

    g.app.unitTesting = False</t>
<t tx="ekr.20050218015346.16">def runTest (self):
    
    f = self.f ; name = f.__name__ ; theClass = self.theClass
    
    d = {'c':self.c,'g':self.g,'p':self.p}

    if 1: # Use dead text to ensure a clean environment.
        # The present code assumes all leading whitespace is consistent.
        code = removeLeadingWs(self.code)
        # The code is a def statement.  We concoct a call to the function or method.
        if theClass:
            s = '%s\n%s(self=None)\n' % (code,name)
        else:
            s = '%s\n%s()\n' % (code,name)
            
        if self.verbose:
            g.trace('executing...\n\n%s' % s)

        exec s in d # Execute s in a environment containing c, g and p.
        
    else: # Use live objects.
        if theClass:
            # Create a subclass of f's original class.
            class __dummyClass(theClass):
                # Create a ctor with a known signature.
                def __init__(self): pass
            # Make f a method of the dummyClass with name 'f'.
            # N.B. f is still a method of theClass, and must be called as such!
            if 0: # Override the method with f's actual name.
                g.funcToMethod(f,__dummyClass,name)
                obj = __dummyClass()
                f = getattr(obj,name)
                f(obj)
            else:
                # Use the name 'f' for f's name.
                g.funcToMethod(f,__dummyClass,'f')
                # Create an instance of __dummyClass and call it's f method.
                obj = __dummyClass()
                obj.f()
        else: # Execute a plain function.
            f(**keys)</t>
<t tx="ekr.20050218015346.17">def shortDescription (self):

    return 'test function',repr(self.f)</t>
<t tx="ekr.20050218015346.18">def addTestRoutinesInPluginToSuite (c,g,pluginName,suite):
    
    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    
    g.app.unitTesting = True # Disable imports of dangerous modules.
    plugin = g.importFromPath(pluginName,path,verbose=True)
    if not plugin:
        return len([])

    tests = findTestsInModule(plugin,pluginName)
    
    for test in tests:
        theClass,f = test
        code = inspect.getsource(f)
        testCase = testRoutineTestCase(c,g,pluginName,theClass,f,code,verbose=False)
        suite.addTest(testCase)
        
    return len(tests)
</t>
<t tx="ekr.20050218015346.19">def findTestsInModule (module,moduleName):
    
    # g.trace(moduleName)
    
    toString = g.listToString
    try:
        functions = inspect.getmembers(module,inspect.isfunction)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isfunction) for %s' % moduleName)
        functions = []
    try:
        classes = inspect.getmembers(module,inspect.isclass)
    except Exception:
        g.trace('Exception in inspect.getmembers(module,inspect.isclass) for %s' % moduleName)
        classes = []

    # Ignore subclasses of TestCase.
    classes = [theClass for className,theClass in classes
        if not issubclass(theClass,unittest.TestCase)]
    
    allMethods = []
    for theClass in classes:
        try:
            methods = inspect.getmembers(theClass,inspect.ismethod)
        except Exception:
            # This looks like a bug in inspect: The zodb classes have no methods.
            # g.trace('Exception in inspect.getmembers(theClass,inspect.ismethod) for %s' % moduleName)
            methods = []
        # print '\nmethods of class %s...\n\n%s' % (theClass,toString(methods))
        methods = [(theClass,f) for name,f in methods if name.startswith('test_')]
        allMethods.extend(methods)

    # Hack: remove duplicate tests from leoGlobals.py.
    functions = [(None,f) for name,f in functions
        if name.startswith('test_') and not name.startswith('test_g_')]

    if 0:
        &lt;&lt; print classes, methods &amp; functions &gt;&gt;
    
    result = functions
    result.extend(allMethods)
    return result</t>
<t tx="ekr.20050218015346.20">print '=' * 40

if classes:
    print 'classes in %s...\n%s' % (moduleName,toString(classes))
else:
    print 'no classes in %s' % (moduleName)
if allMethods:
    print 'test methods in %s...\n%s'   % (moduleName,toString(allMethods))
else:
    print 'no test methods in %s' % (moduleName)
if functions:
    print 'test functions in %s...\n%s' % (moduleName,toString(functions))
else:
    print 'no test functions in %s' % (moduleName)</t>
<t tx="ekr.20050218015346.21">def getAllPlugins ():

    path = g.os_path_abspath(g.os_path_join(g.app.loadDir,"..","plugins"))
    # g.trace(path)

    files = glob.glob(g.os_path_join(path,"*.py"))
    files = [g.os_path_abspath(f) for f in files]
    files = [str(g.shortFileName(f)) for f in files]
    files.sort()
    plugins = [g.os_path_splitext(f)[0] for f in files]
    
    # g.trace(g.listToString(plugins))
    return plugins</t>
<t tx="ekr.20050218015346.22">def removeLeadingWs (code):

    if not code.strip():
        return ''

    lines = g.splitLines(code)
    line = lines[0]
    i = g.skip_ws(line,0)
    ws = line[0:i]
    if not ws:
        return code
    result = [] ; n = len(ws)
    for line in lines:
        if line.startswith(ws):
            result.append(line[n:])
        else:
            print 'underindented line:%s' % repr(line)
            result.append(line)
            
    # g.trace(g.listToString(result))

    result = ''.join(result)
    return result
</t>
<t tx="ekr.20050218170806">p = p.firstChild().firstChild()
s = p.bodyString()
lines = g.splitLines(s)
prefixes = (
    'access=',
    'bccsender=',
    'filtered=',
    'registered=',
    'messagetocount=',
    'messagecount=',
    'lastmessagedate=',
    'lastsource=',
    'replyToAddresses=',
    'creationdate=',
    'reason=Approved before registration',
    'reason=Address Book Contact',
    'registrationDate=',
    'registrationRequestSent=',
    'reason=Pre-approved sender',
    'preaccepted=1',
)
result = []
for line in lines:
    for prefix in prefixes:
        if line.startswith(prefix):
            # print 'removing',line
            break
    else:
        if line.startswith('name='):
            result.append(line[5:])
        else:
            result.append(line)

result = ''.join(result)
p.setBodyStringOrPane(result)
print 'done!'</t>
<t tx="ekr.20050218170806.1">@killcolor
</t>
<t tx="ekr.20050218170806.2"></t>
<t tx="ekr.20050218174326.1">p = p.firstChild().firstChild()
s = p.bodyString()
lines = g.splitLines(s)
reject = 'reason=Rejected before registration'
result = []
entries = []
for line in lines:
    if line.startswith('['):
        # Add all previous entries
        for entry in entries:
            result.append(entry)
        entries = []
        entries.append(line)
    elif line.startswith(reject):
        # Kill all previous entries.
        entries = []
    else:
        entries.append(line)

result = ''.join(result)
p.setBodyStringOrPane(result)
print 'done!'</t>
<t tx="ekr.20050218184044.10">address_p = p.firstChild()
result_p = p.firstChild().next()

result = []
entries = []
for child in address_p.children_iter():
    s = child.bodyString()
    lines = g.splitLines(s)
    for line in lines:
        if line.startswith('['):
            # Add all previous entries
            if entries:
                if len(entries) &gt; 1:
                    # entries2 = [entries[0],entries[1]]
                    # entries2.extend(entries[2:])
                    result.append(','.join(entries[:2]))
                else:
                    result.append(entries[0])
            entries = [] ; entries2 = []
            entries.append(line.rstrip()[1:-1])
        elif line.strip():
            entries.append(line.rstrip())

result.sort()
result = '\n'.join(result)
result_p.setBodyStringOrPane(result)
print 'done!'</t>
<t tx="ekr.20050218184044.11"></t>
<t tx="ekr.20050219054039">@ These scripts work on the child nodes as shown.

The address children contained the actual data (removed for privacy)</t>
<t tx="ekr.20050219054039.1"></t>
<t tx="ekr.20050219054351">@killcolor
</t>
<t tx="ekr.20050219054351.1"></t>
<t tx="ekr.20050219071503">def callback(*args,**keys): g.trace()

table = (("Test",None,callback),)

c.frame.menu.createMenuItemsFromTable('File',table)</t>
<t tx="ekr.20050219073752.1">def callback(*args,**keys):
    g.trace('after Open With')

# Get the actual Tkinter menu.
fileMenu = c.frame.menu.getMenu('File')

# Now use raw Tkinter calls to insert the menu.
fileMenu.insert(3,'command',label='Test',command=callback) </t>
<t tx="ekr.20050219075759"></t>
<t tx="ekr.20050220024614"># Running this as a unit test would hang the unit tests!
g.pdb()</t>
<t tx="ekr.20050220034025">try:
    assert False, 'Assert False'
except AssertionError:
    g.es_exception()</t>
<t tx="ekr.20050220085042.1">def run (c):
    
    import leoTest
    u = leoTest.testUtils() 
    input  = u.findNodeAnywhere(c,'-elisp2py-input-')
    output = u.findNodeAnywhere(c,'-elisp2py-output-')
    assert input and output

    print ; print '*' * 60
    e = e2py(dumping=False)
    for p in input.children_iter():
        print ; print '-' * 10, p.headString()
        print p.bodyString()
        result = e.doOuterBlock(p.bodyString())
        print '-' * 20
        print result</t>
<t tx="ekr.20050220085042.2"></t>
<t tx="ekr.20050220091046">class e2py:
    
    '''A text-based (not token-based) approach to parsing.'''
    
    @others</t>
<t tx="ekr.20050220091046.1">def __init__ (self,dumping=False):
    
    self.dumping = dumping</t>
<t tx="ekr.20050220091046.2">def doOuterBlock (self,s):
    
    '''Handle outermost code.  Return a string, not a list.'''
    
    s = self.stripLws(s)
    result = self.doBlock(s)
    result = self.removeBlankLines(result)
    return '\n'.join(result)</t>
<t tx="ekr.20050220091046.3">def doParenBlock (self,s):
    
    ''' - Strip outer parens.
        - Call doBlock recursively for all inner parens.
        - Add one level of indentation to each line.'''
    n,ok = self.findMatchingBracket(s)
    assert n == len(s) and ok
    s = s[1:-1] # Strip the brackets
    i = 0
    i = g.skip_ws(s,i)
    j,id = self.skip_id(s,i)
    if id:
        s = s[j:].lstrip()
        if id == 'defun': result = self.doDef(s,id)
        elif id == 'let': result = self.doLet(s)
        elif id == 'if': result = self.doIf(s)
        elif id in ('prog1','progn'): result = self.doProg(s,id)
        else: result = self.doId(s,id)
    elif s[i] == '(':
        s = s[i:].lstrip()
        result = self.doDoubleParen(s)
    else: result = self.doBlock(s)
        
    self.dump(result)
    return result</t>
<t tx="ekr.20050220091046.4"></t>
<t tx="ekr.20050220091046.5"></t>
<t tx="ekr.20050220091236">    for p in before.subtree_iter():
        e = elisp2py.elisp2pyClass(c,p)
        e.convert()
        if 0:
            e.dump(e.tokens,heading="Tokens",verbose=2)
        if 1:
            e.dump(e.parseTree,heading="Parse Tree",verbose=2)
        if 0:
            e.dumpCodeList(e.codeList,heading="Code List")</t>
<t tx="ekr.20050220092732">def findMatchingBracket(self,s,i=0):

    ch1 = s[i]
    assert ch1 in "({["
    delim = self.matchingBracket(ch1)
    level = 1
    for ch in s[i+1:]:
        i += 1
        # g.trace(level,ch)
        if ch == ch1:
            level += 1
        elif ch == delim:
            level -= 1
            if level == 0: return i+1,True
    print "%s not matched by %s in %s" % (ch1,delim,s)
    return len(s),False</t>
<t tx="ekr.20050220093752">def matchingBracket (self,ch):
    
    assert ch in "({["
    
    if   ch == '(': return ')'
    elif ch == '{': return '}'
    else:           return ']'</t>
<t tx="ekr.20050220100049">def stripLws(self,s):
    
    lines = g.splitLines(s)
    result = [line.lstrip() for line in lines]
    return ''.join(result)</t>
<t tx="ekr.20050220103808">def skip_id(self,s,i=0):
    
    j = g.skip_id(s,i,chars='-')
    id = s[i:j]
    return j,id</t>
<t tx="ekr.20050220105058">def doDef(self,s,id):
    # g.trace(id)
    if id == 'defun':
        kind,i,j,name = self.getToken(s,0)
        if kind == 'id':
            kind,i,j,params = self.getToken(s,j)
            if kind == '()':
                s = s[j:]
                result = ['def %s %s:' % (name,params)]
                result.extend(self.indent(self.doBlock(s)))
                self.dump(result)
                return result
                
    # Fall through if error.
    result = [id]
    result.extend(self.indent(self.doBlock(s)))
    self.dump(result)
    return result</t>
<t tx="ekr.20050220105058.1">def doIf(self,s):
    
    # g.trace()
    
    if 1:
        result = ['if:']
        result.extend(self.indent(self.doBlock(s)))
        result.extend([':if'])

    else: # not yet.  Don't suck everything into the 'if' statement!
        block = self.doBlock(s)
        result = ['if (%s):' % ' '.join(block)]
    
    self.dump(result)
    return result</t>
<t tx="ekr.20050220105058.2">def doLet(self,s):
    
    # g.trace()
    
    result = ['let:']
    result.extend(self.indent(self.doBlock(s)))
    result.extend([':let'])
    
    self.dump(result)
    return result
</t>
<t tx="ekr.20050220105058.3">def doProg(self,s,id):
    
    # g.trace(id)
    
    result = [id]
    result.extend(self.indent(self.doBlock(s)))
    
    self.dump(result)
    return result</t>
<t tx="ekr.20050220105058.4">def skipString(self,s,i):

    # Skip the opening double quote.
    i1 = i
    ch = s[i]
    i += 1
    assert(ch == '"')

    while i &lt; len(s):
        ch = s[i]
        i += 1
        if ch == '"': return i
        elif ch == '\\': i += 1

    print "run-on elisp string: %s" % g.get_line(s[i1:])
    return i</t>
<t tx="ekr.20050220105726">def indent (self,lines,strip=True):
    
    '''Add a tab to each element of a list.'''
    
    return ['    ' + line for line in lines if not strip or line.strip()]</t>
<t tx="ekr.20050220111049">def doBlock (self,s,strip=True):
    
    '''Handle an outer block or a formerly parenthesized block.'''

    i = 0 ; result = []
    while i &lt; len(s):
        j = s.find('(',i)
        if j == -1:
            tail = s[i:]
            if tail:
                # g.trace(repr(tail))
                result.extend(g.splitLines(tail))
            break
        else:
            prev = s[i:j]
            if prev: result.extend(g.splitLines(prev))
            i = j
            n,ok = self.findMatchingBracket(s[i:])
            if ok:
                block = s[i:i+n]
                block = self.stripLws(block)
                block_result = self.doParenBlock(block)
                if block_result:
                    result.extend(block_result)
            i += n
    
    result = self.removeBlankLines(result)
    self.dump(result)
    return result</t>
<t tx="ekr.20050220111114">def doId(self,s,id):
    
    # g.trace(id)
    if 1:
        result = ['(%s:' % id]
        result.extend(self.indent(self.doBlock(s)))
        result.extend([':%s)' % id])
    else:
        result = [id]
        result.extend(self.doBlock(s))
    
    self.dump(result)
    return result</t>
<t tx="ekr.20050220111923">def dump(self,lines):
    
    if self.dumping:
        print '%s returns...' % g.callerName(2)
        lines = [str(line) for line in lines]
        print g.listToString(lines)</t>
<t tx="ekr.20050220114616">def getToken (self,s,i=0):

    i = g.skip_ws(s,i)
    if i &lt; len(s):
        ch = s[i]
        if ch == '"':
            j = self.skipString(s,i)
            val = '"',i,j,s[i:j]
        elif ch in string.ascii_letters or ch in string.digits or ch in '-_':
            j,name = self.skip_id(s,i)
            val = 'id',i,j,name
        elif ch == '(':
            j,ok = self.findMatchingBracket(s,i)
            if ok:
                val = '()',i,j,s[i:j]
            else:
                val = '(',i,i,'('
        else:
            val = ch,i,i,ch
    else:
        val = None,i,i,None
        
    # g.trace(repr(s[i]),val)
    return val</t>
<t tx="ekr.20050220122447">def removeBlankLines (self,lines):
    
    return [line for line in lines if line.strip()]</t>
<t tx="ekr.20050220124658">def doDoubleParen (self,s):

    n,ok = self.findMatchingBracket(s)
    if ok:
        s2 = s[:n] ; s3 = s[n:]
        result = ['(:']
        result.extend(self.indent(self.doParenBlock(s2)))
        result.extend([':)'])
        result.extend(self.doBlock(s3))
    else:
        result = self.doBlock(s)
        
    self.dump(result)
    return result
</t>
<t tx="ekr.20050225161940">@

To run the script:
    
1. Make the 'Exec File' node a script button.

2. Select either the @test node or the @thin node.

(You must change @@thin to @thin for this to work.)

3. Hit the Exec File button.</t>
<t tx="ekr.20050225161940.1">assert __name__ == '__builtin__', '__name__ is %s' % __name__</t>
<t tx="ekr.20050225161940.2">&lt;&lt; docstring &gt;&gt;
&lt;&lt; imports &gt;&gt;

@others

doatest()</t>
<t tx="ekr.20050225161940.3">"""this script will run python from Leo with @file somefile.py
using the py2.4 (2.3 compatible) subprocess module
to verify and code correct in the quickest possible manner.
unittests or other w/stdout stderr redirected to log.
wimped out for the moment on making it virtual.

If the presently selected node is an @test or @suite node this script runs them,
otherwise the script expects the node to a valid @file node that has been
written to disk and updated.

less complicated and thus more advanced unittesting:
py.test, similar to unittest as far as adding support.
and @test and @suite, many examples in test.leo
and my own dutest in dyna_menu with redirection to log
which calls leoTest.py on @test and @suite nodes 
otherwise for doctesting w/o needing an @file written.

good overview, see Recent Posts:
http://agiletesting.blogspot.com
http://agiletesting.blogspot.com/2005/01/
Python unit testing part 3: the py.test tool and library 
python-unit-testing-part-2-doctest part-1 unittest

tested win9x Leo4.3a2 py2.4 2.3
tested but little and probably not completely.
if it works once its done, right?
make an @button or add to a menu or plugin

Note: 
you may see some extraneous traceback 
vrs run outside Leo, can't be helped.

Warning: this may run arbitrary code.
no warranty expressed or implied!
"""
</t>
<t tx="ekr.20050225161940.5">def getAtFileName():
    
    '''Return the full path from any kind of @file node and applicable @path directives.'''
    
    # should return cwd, cd to files path
    # script should return cwd after run

    fname = p.anyAtFileNodeName()
    if fname:
        d = g.scanDirectives(c)
        path = d.get("path")
        fname = g.os_path_abspath(g.os_path_normpath(g.os_path_join(path, fname)))

    return fname</t>
<t tx="ekr.20050225161940.6">def doatest():

    _sosav = sys.__stdout__
    _sesav = sys.__stderr__
    sys.stdout = sys.__stdout__ = g.fileLikeObject()
    sys.stderr = sys.__stderr__ = g.fileLikeObject()

    h = p.headString()
    if h.startswith('@suite') or h.startswith('@test'):
        leoTest.doTests(all= False,verbosity=2)
    else: # Try to run an @file unittest.
        name = getAtFileName()
        if name:
            g.executeFile(name,'-v')
        else:
            g.es('Expecting @test, @suite or any @file node',color='blue')

    oo = sys.stdout.get()
    oe = sys.stderr.get()
    sys.stdout.close()
    sys.stderr.close()
    sys.stdout = sys.__stdout__ = _sosav
    sys.stderr = sys.__stderr__ = _sesav
    lines = g.splitLines(oo + oe)
    empty = True
    for line in lines:
        if line.rstrip():
            empty = False
    if lines and not empty:
        g.es('Output from test...',color='blue')
        for line in lines:
            g.es(line.rstrip())
    g.es('Test done',color='blue')

    c.frame.putStatusLine(' fini ', color= 'DodgerBlue')</t>
<t tx="ekr.20050225162123">@language python
@tabwidth -4

print __name__
#print 'hi'

assert __name__ == '__main__', '__name__ is %s' % __name__</t>
<t tx="ekr.20050225171553">import leoTest

try:
    import subprocess # Exists only in Python 2.4.
except ImportError:
    subprocess = None

import os
import StringIO
import sys
import unittest</t>
<t tx="ekr.20050310082013">@ http://sourceforge.net/forum/message.php?msg_id=3039793

heres a short script to open a leo, then a New leo from that one, pause then exit.

still have to work out how to collect error output, especially if Leo doesn't start at all
can't then depend on Leo error reporting!

make a node
@url ./leoopen1.au3

make another
@nosent leoopen1.au3
@c

@language elisp

; AutoIt Version: 3.0 a BASIC like language
; http://www.hiddensoft.com/AutoIt/

; Opens Leo with no filename, then opens a new, closes it
; Preliminary, will eventually programatically create
; leoPlugins.txt and various leoSettings.leo
; and run commands in all permutations looking for failures.

; Paths are hardwired but later scripts will be created on the fly
; maybe Leo can have a -trace mode to output to file a log of activities?

; exit when CTRL+ALT+x is pressed
HotKeySet("^!x", "MyExit")

Func MyExit()
    Exit 
EndFunc 

Opt("SendKeyDelay", 1)
Opt("WinWaitDelay", 80)

;fix path to leo.py
Run("python c:\c\leo\V43leos\leo\src\leo.py")
Sleep(2700) 

WinWaitActive("untitled")   

Sleep(700) 
Send("!Fn")  ; how to tell if there are errors?
Sleep(2700) 

WinWaitActive("untitled1")
Send("!Fx")
Sleep(2700) 

;careful you don't close the leo you are working from
Send("!Fx")</t>
<t tx="ekr.20050314103747">def convertPythonIndexToRowCol (s,i):
    
    '''Convert index i into string s into zero-based row/col indices.'''
    
    if not s or i == 0:
        return 0,0
    else:
        i = min(i,len(s)-1)
        # works regardless of what s[i] is
        row = s.count('\n',0,i) # Don't include i
        if row == 0:
            return row,i
        else:
            prevNl = s.rfind('\n',0,i) # Don't include i
            # assert prevNl &gt; -1
            return row,i-prevNl-1</t>
<t tx="ekr.20050314103747.1">def bruteForceConvertPythonIndexToRowCol (s,i):
        
    lines = g.splitLines(s)
    row,total = 0,0
    for line in lines:
        n = len(line)
        if i &lt; total + n:
            break
        else:
            total += n
            row += 1
    return row, i-total</t>
<t tx="ekr.20050314103747.2">def test_g_convertPythonIndexToRowCol ():
    
    s = '\nabc\n\npdq\nxy'
    
    for i in xrange(len(s)+1): # Test one-too-large case.
        try: ch = s[i]
        except IndexError: ch = '**'
        rowCol_1 = convertPythonIndexToRowCol(s,i)
        rowCol_2 = bruteForceConvertPythonIndexToRowCol(s,i)
        print '%2d %4s %5s' % (i,repr(ch),rowCol_1==rowCol_2),
        print rowCol_1,rowCol_2</t>
<t tx="ekr.20050314104217">@others

print '-' * 20
test_g_convertPythonIndexToRowCol()</t>
<t tx="ekr.20050315072359">@others

print '-' * 20
test_g_convertRowColToPythonIndex()</t>
<t tx="ekr.20050315072359.1">def convertRowColToPythonIndex (s,row,col):
    
    lines = g.splitLines(s)

    if row &gt; len(lines) or col &gt; len(lines[row]):
        raise IndexError
    
    prev = 0
    for line in lines[:row]:
        prev += len(line)
        
    return prev + col</t>
<t tx="ekr.20050315072359.2">def test_g_convertRowColToPythonIndex ():

    s = '\nabc\n\npdq\nxy'
    lines = g.splitLines(s)
    row = 0 ; prev = -1
    for line in lines:
        col = 0
        for ch in line:
            i = convertRowColToPythonIndex(s,row,col)
            assert i == prev + 1,'i %d prev %d' % (i,prev)
            if not g.app.unitTesting:
                print '%4s %2d %2d %2d' % (repr(ch),row,col,i)
            prev = i
            col += 1
        row += 1</t>
<t tx="ekr.20050316063336"># Comment

print z</t>
<t tx="ekr.20050316074630.1">import leoTest

leoTest.throwAssertionError()</t>
<t tx="ekr.20050328101834"></t>
<t tx="ekr.20050328101834.1"></t>
<t tx="ekr.20050328101834.2"></t>
<t tx="ekr.20050328101834.3"></t>
<t tx="ekr.20050331070207">import leoPlugins

golf = leoPlugins.getPluginModule('golf')

if not golf:
    golf = leoPlugins.loadOnePlugin('golf',verbose=True)
    keys = {'c':c}
    if golf: golf.onCreate('tag',keys)

if golf:
    controller = golf.controllers.get(c)
    if controller:
        controller.golfCommand()

if not golf or not controller:
    # Ask to be removed.
    g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050406082407">@language html
@ignore</t>
<t tx="ekr.20050406082407.1">@first &lt;?xml version="1.0" encoding="UTF-8"?&gt;

&lt;body&gt;

&lt;/body&gt;</t>
<t tx="ekr.20050408084135">@ 

Any unit test that changes the structure of the outline should do the
following:

- The setUp method should do
    self.undoMark = c.undoer.getMark()
before altering the outline.

- The tearDown method should do
    c.undoer.rollBackToMark(self.undoMark)
after restoring the outline.

u.rollBackToMark deletes all entries in the undo stack following the saved mark.
This eliminates references to nodes that no longer exist in the present outline.</t>
<t tx="ekr.20050415090637">True:  Allows control-dragging to create clones.
False: All drags move nodes.

See also: look_for_control_drag_on_mouse_down
Setting this setting to False allows Leo to be used on Aqua.</t>
<t tx="ekr.20050417095020.11"># Honor the first line's leading whitespace.

import leoTest

leoTest.singleParagraphTest(c,p,5,16)
</t>
<t tx="ekr.20050417095020.12"># Honor the first and second line's leading whitespace.

import leoTest

leoTest.singleParagraphTest(c,p,5,16)
</t>
<t tx="ekr.20050417095020.13"># Single paragraph, hanging indentation.

import leoTest

leoTest.singleParagraphTest(c,p,5,8)
</t>
<t tx="ekr.20050417095020.14"># Single paragraph, hanging indentation with other indentation beyond line 2.

import leoTest

leoTest.singleParagraphTest(c,p,5,8)</t>
<t tx="ekr.20050417095020.15"># Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.

import leoTest

leoTest.singleParagraphTest(c,p,5,8)</t>
<t tx="ekr.20050417095124.16">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.17">This line is under 40 chars.</t>
<t tx="ekr.20050417095124.18">This line is under 40 chars.</t>
<t tx="ekr.20050417095124.19">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.20">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20050417095124.21">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20050417095124.22">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.23">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20050417095124.24">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20050417095124.25">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.26">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20050417095124.27">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20050417095124.28">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.29">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20050417095124.30">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20050417095124.31">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.32">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20050417095124.33">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20050417095124.34">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417095124.35">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20050417095124.36">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20050417095124.37">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

</t>
<t tx="ekr.20050417095124.38">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20050417095124.39">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20050417095124.40">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20050417095124.41">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Services StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20050417095124.42">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Services StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20050417095124.43">@language plain
@pagewidth 40
@tabwidth 8

</t>
<t tx="ekr.20050417095124.44">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20050417095124.45">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20050417102057">@ Rewritten by EKR.  April 17, 2005.

Each data node must have three children:
    
- a "before" node
- an "after" node
- a "tempNode" node

A parent to before and after nodes will contain pagewidth and language formatting directives.</t>
<t tx="ekr.20050417102114"># Wrap a long line, no trailing newline.

import leoTest

leoTest.singleParagraphTest(c,p,2,24)</t>
<t tx="ekr.20050417102114.1">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20050417102114.2">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20050417104821">@language plain
@pagewidth 40
@tabwidth 8

</t>
<t tx="ekr.20050417111144"># Wrap a long line, with trailing newline.

import leoTest

# Wrap a long line, no trailing newline.
leoTest.singleParagraphTest(c,p,3,0)</t>
<t tx="ekr.20050417111144.1">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417111144.2">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20050417111144.3">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20050417111240"></t>
<t tx="ekr.20050417113549"># Wrap a long line and some short ones.

import leoTest

leoTest.singleParagraphTest(c,p,4,10)</t>
<t tx="ekr.20050417113910">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417113910.1">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20050417113910.2">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20050417113921"></t>
<t tx="ekr.20050417114153"># Wrap a paragraph with interior lines that have leading white space.

import leoTest

leoTest.singleParagraphTest(c,p,4,12)</t>
<t tx="ekr.20050417114221">@language plain
@pagewidth 40
@tabwidth 8</t>
<t tx="ekr.20050417114221.1"></t>
<t tx="ekr.20050417114221.2">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20050417114221.3">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20050417114836"># No wrapping required, so don't change a thing.

import leoTest

leoTest.singleParagraphTest(c,p,1,28)
</t>
<t tx="ekr.20050417114914"></t>
<t tx="ekr.20050417115111"></t>
<t tx="ekr.20050417115257"></t>
<t tx="ekr.20050417115414"></t>
<t tx="ekr.20050417115559"></t>
<t tx="ekr.20050417115709"></t>
<t tx="ekr.20050417120312.1"># Multiple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.

import leoTest

leoTest.multiParagraphTest(c,p)</t>
<t tx="ekr.20050417120312.2"></t>
<t tx="ekr.20050417121448"># A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.
# Cursor should move to next paragraph after formatting a paragraph.

import leoTest

leoTest.multiParagraphWithListTest(c,p)</t>
<t tx="ekr.20050417121448.1"></t>
<t tx="ekr.20050417121942">@
Ran into a problem with the wrapping eating blank lines that delimit paragraphs
if those blank lines have any leading whitespace. This test is to make sure that
still works.

If you "show invisibles" you'll see the leading whitespace in the blank lines --
which is different from the "testMultiParagraphWithList" test.
@c

import leoTest

leoTest.leadingWSOnEmptyLinesTest(c,p)</t>
<t tx="ekr.20050417121942.1"></t>
<t tx="ekr.20050417122215.1">import leoTest

leoTest.directiveBreaksParagraphTest(c,p)</t>
<t tx="ekr.20050417122215.2"></t>
<t tx="ekr.20050417124704"></t>
<t tx="ekr.20050417201845"></t>
<t tx="ekr.20050417201845.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050417201845.2">before
after</t>
<t tx="ekr.20050417201845.3">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20050417201845.4">2.0
5.0 lineend -1c</t>
<t tx="ekr.20050417202052"></t>
<t tx="ekr.20050417202052.1">line1
&lt;&lt; section 1&gt;&gt;
if 1:
    &lt;&lt; section 2&gt;&gt;
line 2
    &lt;&lt; section 3 &gt;&gt;
line 3</t>
<t tx="ekr.20050417202112">line1
&lt;&lt; section 1&gt;&gt;
if 1:
    &lt;&lt; section 2&gt;&gt;
line 2
    &lt;&lt; section 3 &gt;&gt;
line 3</t>
<t tx="ekr.20050417202112.1"></t>
<t tx="ekr.20050417202112.2"></t>
<t tx="ekr.20050417202112.3"></t>
<t tx="ekr.20050417202243">1.0
7.0 lineend - 1c</t>
<t tx="ekr.20050417202713"></t>
<t tx="ekr.20050417202713.1">@language python

def addCommentTest():

    if 1:
        a = 2
        b = 3
        
    pass</t>
<t tx="ekr.20050417202713.2">@language python

def addCommentTest():

    # if 1:
        # a = 2
        # b = 3
        
    pass</t>
<t tx="ekr.20050417202713.3">5.0
7.0 lineend -1c</t>
<t tx="ekr.20050417202817"></t>
<t tx="ekr.20050417202817.1">@language python

def deleteCommentTest():

    # if 1:
        # a = 2
        # b = 3
        
    pass</t>
<t tx="ekr.20050417202817.2">@language python

def deleteCommentTest():

    if 1:
        a = 2
        b = 3
        
    pass</t>
<t tx="ekr.20050417202817.3">5.0
7.0 lineend -1c</t>
<t tx="ekr.20050417203114"></t>
<t tx="ekr.20050417203114.1"></t>
<t tx="ekr.20050417203310">@tabwidth -4

line 1
    line 2
      line 3
line4</t>
<t tx="ekr.20050417203310.1">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417203336">1.0
6.0 lineend - 1c</t>
<t tx="ekr.20050417204830">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417204834">@tabwidth -4

line 1
	line 2
	  line 3
line4</t>
<t tx="ekr.20050417204901">1.0
6.0 lineend - 1c</t>
<t tx="ekr.20050417204940"></t>
<t tx="ekr.20050417204940.1">@tabwidth -4

line 1
    line 2
      line 3
line4</t>
<t tx="ekr.20050417204940.2">@tabwidth -4

line 1
	line 2
	  line 3
line4
</t>
<t tx="ekr.20050417204940.3">1.0
6.0 lineend - 1c</t>
<t tx="ekr.20050417205012"></t>
<t tx="ekr.20050417205012.1">@tabwidth -4

line 1
	line 2
	  line 3
line4</t>
<t tx="ekr.20050417205012.2">@tabwidth -4

line 1
    line 2
      line 3
line4
</t>
<t tx="ekr.20050417205012.3">1.0
6.0 lineend - 1c</t>
<t tx="ekr.20050419033955"></t>
<t tx="ekr.20050419034527" str_ekr_attribute="abc"># Set the attribute.
d = {'str_ekr_attribute': 'abc'}
p.v.t.unknownAttributes = d</t>
<t tx="ekr.20050419034527.1">for p in c.allNodes_iter():
    h = p.headString()
    if hasattr(p.v.t,'unknownAttributes'):
        d = p.v.t.unknownAttributes
        val = d.get('str_ekr_attribute')
        if val:
           g.es('str_ekr_attribute is: %s' % val)</t>
<t tx="ekr.20050419070841"></t>
<t tx="ekr.20050419082439"></t>
<t tx="ekr.20050419084109"></t>
<t tx="ekr.20050419084109.1"></t>
<t tx="ekr.20050419085933"></t>
<t tx="ekr.20050427101736">class ZipFile(  	file[, mode[, compression]])
    Open a ZIP file, where file can be either a path to a file (a string) or a file-like object. The mode parameter should be 'r' to read an existing file, 'w' to truncate and write a new file, or 'a' to append to an existing file. For mode is 'a' and file refers to an existing ZIP file, then additional files are added to it. If file does not refer to a ZIP file, then a new ZIP archive is appended to the file. This is meant for adding a ZIP archive to another file, such as python.exe. Using

cat myzip.zip &gt;&gt; python.exe

    also works, and at least WinZip can read such files. compression is the ZIP compression method to use when writing the archive, and should be ZIP_STORED or ZIP_DEFLATED; unrecognized values will cause RuntimeError to be raised. If ZIP_DEFLATED is specified but the zlib module is not available, RuntimeError is also raised. The default is ZIP_STORED. </t>
<t tx="ekr.20050427101736.1">import zipfile

path = r'c:\prog\leoCVS\leo\test\ziptest.zip'

zf = zipfile.ZipFile(path,'w',zipfile.ZIP_DEFLATED)
zf.writestr('This is a test: EKR','ziptest')
zf.close()</t>
<t tx="ekr.20050427101736.2">import zipfile

path = r'c:\prog\leoCVS\leo\src\leoPy.leo'
path = r'c:\prog\leoCVS\leo\test\ziptest.zip'

if zipfile.is_zipfile(path):
    try:
        zf = zipfile.ZipFile(path)
        names = zf.namelist()
        for name in names:
            print 'name',repr(name),'contents',zf.read(name)
        zf.close()
    except Exception:
        g.es_exception()
        zf = None</t>
<t tx="ekr.20050427102426"></t>
<t tx="ekr.20050428085106">print '-'*60
count = 0
for p in c.allNodes_iter():
    count += 1
    print ' '*p.level(),p.headString()
print 'found',count,'nodes'</t>
<t tx="ekr.20050503095605">table = ('spawnv',None,(
    'os.spawnv',[
    r'c:\vim\vim63\gvim.exe',
    ' --servername LEO ',
    ' --remote-silent ',
    ],
    ".py")),

c.frame.menu.createOpenWithMenuFromTable(table)</t>
<t tx="ekr.20050505053411"></t>
<t tx="ekr.20050505104328"># To run this test, set @bool redirect_execute_script_output_to_log_pane = True in the @settings tree.

print 'hi'
print c.config.redirect_execute_script_output_to_log_pane
print c.xyzzy</t>
<t tx="ekr.20050505104752"># For testing error handling in g.executeScript</t>
<t tx="ekr.20050508195711">@nowrap
aaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccc ddddddddddddddd eeeeeeeeeeeeeee ffffffffffffffff </t>
<t tx="ekr.20050509072745">@language html</t>
<t tx="ekr.20050509072745.1">print '-'*20
print g.getScript(c,p,forcePythonSentinels=False)</t>
<t tx="ekr.20050509072745.2">&lt;body&gt;
@others
&lt;/body&gt;</t>
<t tx="ekr.20050509072745.3">This is a body</t>
<t tx="ekr.20050511085027">node granularity: start a new undo unit when typing moves to a new node.
line granularity: start a new undo unit when typing moves to new line.
word granularity: start a new undo unit when typing starts a new word.
char granularity: start a new undo unit for each character typed.

'line' granularity is the default used if no valid setting is specified.

Leo used char granularity for all version prior to 4.3. char granularity is not
recommended; it is clumsy and wasteful of computer memory.</t>
<t tx="ekr.20050512083700"></t>
<t tx="ekr.20050512083700.1">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markChangedHeadlines()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()
                
if not ok: raise</t>
<t tx="ekr.20050512083807">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markChangedRoots()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()
                
if not ok: raise</t>
<t tx="ekr.20050512083807.1">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markAllAtFileNodesDirty()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()
                
if not ok: raise</t>
<t tx="ekr.20050512083807.2">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markAtFileNodesDirty()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()
                
if not ok: raise</t>
<t tx="ekr.20050512083816">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markClones()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()
                
if not ok: raise</t>
<t tx="ekr.20050512083822">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markHeadline()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()
                
if not ok: raise</t>
<t tx="ekr.20050512083822.1">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.markSubheads()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()
                
if not ok: raise</t>
<t tx="ekr.20050512083822.2">marks = [p.v for p in c.allNodes_iter() if p.isMarked()]
try:
    ok = True
    try:
        c.unmarkAll()
    except Exception:
        ok = False
finally:
    for p in c.allNodes_iter():
        if p.v in marks:
            if not p.isMarked():
                p.setMarked()
        else:
            if p.isMarked():
                p.clearMarked()

if not ok: raise</t>
<t tx="ekr.20050512084850"></t>
<t tx="ekr.20050512084850.1">pass</t>
<t tx="ekr.20050512084850.2">pass</t>
<t tx="ekr.20050512130051">Defines the primary splitter orientation.

The primary panes are the body pane and the secondary pane.
The secondary pane contains the outline and log panes.

vertical: body pane below outline and log panes.
horizontal: body pane to left of outline and log panes.</t>
<t tx="ekr.20050518070540"></t>
<t tx="ekr.20050518070540.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518070540.4">2.0
2.0 lineend -1c</t>
<t tx="ekr.20050518070545">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518070927"></t>
<t tx="ekr.20050518070927.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518070927.2">before
    &lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20050518070927.3">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20050518070927.4">2.0
5.0 lineend -1c</t>
<t tx="ekr.20050518071251"></t>
<t tx="ekr.20050518071251.1">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050518071251.4">2.0
2.0 lineend -1c</t>
<t tx="ekr.20050518071258">before
    &lt;&lt; section &gt;&gt;
    sec line 1
        sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20050601072505">athis skkdfkjdkfjakdjf;akjf;akljf;asdjf;ajf;
a;ljf;

;alkjf;a
;alkjf;akljf;lds;kfja;sdkfj;adskfjads;kfjads;kfljaa;ljf;ladskjf;dsalkjf;asdkf
def this akjd;flk
This is a test of coloring.  It works if we use a thread.
lakjdf;kjadf
alkjdf;kaljdf;kdkdkkdkd;what is going ondkjf;akf;ak
for while do if const
This is a test of something.
I wonder what it could be.
This could be the start of something wonderful.

This is a test.
#dddddddddddddddddddddddddddddddddddddddThis
this is a t
I have no idea.
;alkd;fkajd;fkjd
this is a test for to from is a test of something
kdkjf;akf;klja;dfkj
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from and still this is good.

# Wow.  It is so cool to get beter performance.
adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf


adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf
a
;alkd;fkajd;fkjd
this is a test for to from 
thkdj;akf;kja;dfkj;alkjkk;alkjf;akld;flkajd;flkajd;flkja;
;aljf;akljf;adskfj
;akjf;akljf;a
a;kjf;alkjf;aksjf;asdjf;
ajf;ajf;ads
;alkjf;adsjf
a;sjf;alkf
from

adkdfjk;;alkdjf;kjf;klajf
alkjd;fkja;dfkj
;akjf;ad
;ajf;ajf




</t>
<t tx="ekr.20050602213517">@color
@doc test
line 2
@c
int
@color
@ doc
line 2
@c</t>
<t tx="ekr.20050603134109">@language c // c delegates to cpp rule within c.xml

int enum

assert(True)

&lt;&lt; xyzzy &gt;&gt;

/** Doxygen comment */</t>
<t tx="ekr.20050607084934">@language plain
</t>
<t tx="ekr.20050608081744">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@="&amp;Notepad"

Test of @ at end of text.
@</t>
<t tx="ekr.20050608081942">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@="&amp;Notepad"</t>
<t tx="ekr.20050608082208">@ignore

@language plain
@nocolor
</t>
<t tx="ekr.20050608082702">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad</t>
<t tx="ekr.20050608082702.1">Test of leading @ sign

[HKEY_CLASSES_ROOT\*\shell\open]
@notepad
</t>
<t tx="ekr.20050618053006">p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20050618053006.1">@language plsql
"a string"
-- reserved keywords
abort
accept,
access,
add,
admin,
after,
all,
allocate,
alter,
analyze,
and,
any,
archive,
archivelog,
array,
arraylen,
as,
asc,
assert,
assign,
at,
audit,
authorization,
avg,
backup,
base_table,
become,
before,
begin,
between,
binary_integer,
block,
body,
boolean,
by,
cache,
cancel,
cascade,
case,
change,
char,
char_base,
character,
check,
checkpoint,
close,
cluster,
clusters,
cobol,
colauth,
column,
columns,
comment,
commit,
compile,
compress,
connect,
constant,
constraint,
constraints,
contents,
continue,
controlfile,
count,
crash,
create,
current,
currval,
cursor,
cycle,
data_base,
database,
datafile,
date,
dba,
debugoff,
debugon,
dec,
decimal,
declare,
default,
definition,
delay,
delete,
delta,
desc,
digits,
disable,
dismount,
dispose,
distinct,
distinct,
do,
double,
drop,
drop,
dump,
each,
else,
else,
elsif,
enable,
end,
end,
entry,
escape,
events,
except,
exception,
exception_init,
exceptions,
exclusive,
exec,
execute,
exists,
exists,
exit,
explain,
extent,
externally,
false,
fetch,
fetch,
file,
float,
float,
flush,
for,
for,
force,
foreign,
form,
fortran,
found,
freelist,
freelists,
from,
from,
function,
generic,
go,
goto,
grant,
group,
groups,
having,
identified,
if,
immediate,
in,
including,
increment,
index,
indexes,
indicator,
initial,
initrans,
insert,
instance,
int,
integer,
intersect,
into,
is,
key,
language,
layer,
level,
like,
limited,
link,
lists,
lock,
logfile,
long,
loop,
manage,
manual,
max,
maxdatafiles,
maxextents,
maxinstances,
maxlogfiles,
maxloghistory,
maxlogmembers,
maxtrans,
maxvalue,
min,
minextents,
minus,
minvalue,
mlslabel,
mod,
mode,
modify,
module,
mount,
natural,
new,
new,
next,
nextval,
noarchivelog,
noaudit,
nocache,
nocompress,
nocycle,
nomaxvalue,
nominvalue,
none,
noorder,
noresetlogs,
normal,
nosort,
not,
notfound,
nowait,
null,
number,
number_base,
numeric,
of,
off,
offline,
old,
on,
online,
only,
open,
open,
optimal,
option,
or,
order,
others,
out,
own,
package,
package,
parallel,
partition,
pctfree,
pctincrease,
pctused,
plan,
pli,
positive,
pragma,
precision,
primary,
prior,
private,
private,
privileges,
procedure,
procedure,
profile,
public,
quota,
raise,
range,
raw,
read,
real,
record,
recover,
references,
referencing,
release,
remr,
rename,
resetlogs,
resource,
restricted,
return,
reuse,
reverse,
revoke,
role,
roles,
rollback,
row,
rowid,
rowlabel,
rownum,
rows,
rowtype,
run,
savepoint,
schema,
scn,
section,
segment,
select,
select,
separate,
sequence,
session,
set,
set,
share,
shared,
size,
size,
smallint,
smallint,
snapshot,
some,
sort,
space,
sql,
sqlbuf,
sqlcode,
sqlerrm,
sqlerror,
sqlstate,
start,
start,
statement,
statement_id,
statistics,
stddev,
stop,
storage,
subtype,
successful,
sum,
sum,
switch,
synonym,
sysdate,
system,
tabauth,
table,
tables,
tables,
tablespace,
task,
temporary,
terminate,
then,
thread,
time,
to,
tracing,
transaction,
trigger,
triggers,
true,
truncate,
type,
uid,
under,
union,
unique,
unlimited,
until,
update,
use,
user,
using,
validate,
values,
varchar,
varchar2,
variance,
view,
views,
when,
whenever,
where,
while,
with,
work,
write,
xor</t>
<t tx="ekr.20050618061835">@killcolor

Here is a tutorial written by Roger Erens.

Version Date        LeoID       Remarks
------- ----        -----       -------
0.1     20050519    rogererens  Initial version</t>
<t tx="ekr.20050618061835.1">So you think "Well, since I've written this piece of funky Python software, and everybody keeps saying how useful unit testing is, I really ought to start using unit tests." And since Leo's creator has said countless times in the Leo forums how easy unit testing in Leo is, a few uncomplicated examples might help convince you that he's not spamming.

Beware: this How-To should be the last time that you write tests AFTER having written your funky software! Test Driven Development dictates that tests have to be prepared BEFORE you get down to writing your actual code. See a nice tutorial on O'Reilly's website (url given in the descendant node).</t>
<t tx="ekr.20050618061835.2"></t>
<t tx="ekr.20050618061835.3">Comment by EKR: There is no need to do this if you use test.leo for your unit tests:  just use the unit test button.

From the console, start up a Leo instance. On MS Windows: go to the folder in which you installed Leo 4.3, open up the 'src' folder and double click the 'leo.py' file. Opening a command window, and typing "python leo.py" may be another way.

Use the File--&gt;Open... menu item to open the outline containing your code.

Choose a good-looking position to insert a new node called 'Test zone'. Copy the child node of the node you're reading right now, and paste it as a child node of 'Test zone'. The code it contains is essentially the same as found in the node
Unit tests...--&gt;Do @test
in the file 'test.leo' in the 'test' folder. I just added my 0.2 cents by adding some starting and finishing remarks. Remove them if they clutter your console too much.

Also, make sure that you have an entry 'Scripting' in the 'Plugins' menu (enable the plugin if neccessary). Now is a good time to save your leo file.

With the 'Scripting' plugin (also known as the 'mod_scripting' plugin) enabled, the net effect will be that the next time you open your outline, a blue button with the caption 'Do @test' shows up in the tool bar of Leo, if your screen is wide enough.
To get the button right away in the tool bar, I have to assume that you started Leo with the scripting plugin enabled. In this case, a yellow button with the caption 'script Button' can be pressed while having the node '@button Do @test' selected. Note: the resulting button will not be blue, but pink. Removing a button from the tool bar can be done by right-clicking it.

We'll see the use of this added button soon, but before that, read up on the 'assert' function in the Python manuals, since it is used a lot in testing. It won't be long before you're back here!</t>
<t tx="ekr.20050618061835.4">@color
import leoTest

print "\nStart of Do @test"
leoTest.doTests(all=False)
print "End of Do @test"</t>
<t tx="ekr.20050618061835.5">The first child node of the node you're reading right now, contains the simplest succeeding test possible.
Select it, and press the button 'Do @test'.
You can find the verbatim result as it got sent to my console in the second child node.

A few things are worth noting here:

1.  The node containing the test must have its headline start with '@test'.
2.  Whenever the 'assert' statement finds out that the expression given to it
    is 'True', a test passes successfully. There are more ways to pass a test, but
    for now, let us stick to the use of assert functions.
3.  A passed test is denoted with a single dot in the output. See the line between
    'Start of Do @test' and the line filled with dashes. This is compatible with the
    way traditional unit testing shows its progress.
4.  Below the dashed line in the output, a summary is printed. This one surely gives
    us a reason to lean back for a moment, and congratualate ourselves with another
    piece of robust, funky code!</t>
<t tx="ekr.20050618061835.6">@color
assert(True)</t>
<t tx="ekr.20050618061835.7">Start of Do @test
.
----------------------------------------------------------------------
Ran 1 test in 0.010s

OK
End of Do @test</t>
<t tx="ekr.20050618061835.8">Now that you've seen a passing test, it should be obvious to imagine how a failing test would look like. See the first child node, and then run it by pressing the 'Do @test' button as before.

Instead of a dot denoting success, we get an 'F' denoting a failure on the line following 'Start of Do @test'. When running a lot of tests, the next part, following the lines filled with '='s, helps to identify which test failed.
It also includes a trace back, but for AssertionErrors, it does not seem to offer much added value to me right now. On second thought: when you have multiple asserts in a test, the trace back can tell you which assert function failed. Still, I would choose for only one assert function per test and get rid of this trace back altogether. This would keep the console much cleaner, IMHO.</t>
<t tx="ekr.20050618061835.9">@color
assert('Spam' == 'Ham')</t>
<t tx="ekr.20050618061835.10">Start of Do @test
F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\Documents and Settings\re1705\My Documents\PythonStuff\leo\src\leoTes
t.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.010s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.11">A real fun feature of Leo is that Leo saves you from having to select each and single @test node and press the 'Do @test' button to obtain testing results. Just collecting the @test nodes under an organizing node, selecting that organizing node, and pressing the 'Do @test' button will suffice.
Of course, this was one of the key ideas of unit testing, but it's nice to see it being implemented by Leo so smoothly!

So, press the button while having this node selected, and see if your console's output matches the third child node more or less. </t>
<t tx="ekr.20050618061835.12">Start of Do @test
.F
======================================================================
FAIL: @test my second Leo test

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 3, in ?
AssertionError

----------------------------------------------------------------------
Ran 2 tests in 0.040s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.13">Okay: so you've seen now some simple stand-alone tests to get your toes wet.
Now, we get to the 'grande finale' and see real-life usage of the @test nodes.

The @test child node below illustrates the following points:

1.  The node imports the module to test (and keeps it up to date by reloading it).
2.  It also obtains data to use as input and referral. This is what you might call
    the setUp methods in traditional unit tests. If more tests need the same data,
    you can put the nodes in a central place where all the @test nodes can find
    them. Likewise, common code for several unit tests might be collected in a
    central place.
3.  Comparable with the traditional unit tests' tearDown method, some statements
    can follow the test itself, if neccessary. You might also consider using a
    try/finally construct.
4.  I have used g.es() statements instead of print statements, since the latter
    clutter the console. Try replacing the g.es() statements by corresponding
    print statements to see what I mean. With more than one @test node being tested,
    this will give quite a dreadful look.</t>
<t tx="ekr.20050618061835.14">@color

try:
    # SETUP
    import koekiemonster # this module defines a function want() which we want to test
    reload(koekiemonster) # changes in koekiemonster need to propagate to the test

    # obtaining the input parameter for the function
    inputNode = p.firstChild()
    inputData = inputNode.bodyString()
    
    # obtaining the expected result from the function with above input parameter
    expectedResultNode = inputNode.next()
    expected = expectedResultNode.bodyString()
    
    # execute the function with above input parameter
    result = koekiemonster.wants(inputData)
    
    # TEST
    assert(result == expected)
    
    # TEARDOWN
    g.es("Now it's time to clean up")

except AssertionError:
    # TEARDOWN
    g.es("Oh oh! %s failed:" % p.headString().strip())
    g.es("koekiemonster.wants(%s)==%s" % (inputData, result))
    g.es("Expected: %s" % expected)
    raise # pass the exception on to the unit test machinery</t>
<t tx="ekr.20050618061835.15">vegetables</t>
<t tx="ekr.20050618061835.16">Yuck!</t>
<t tx="ekr.20050618061835.17">Start of Do @test
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.070s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.18">Start of Do @test
Oh oh: @test koekiemonster.wants() failed:
koekiemonster.wants(vegetables)=Yack!
Expected: Yuck!
F
======================================================================
FAIL: @test koekiemonster.wants()

----------------------------------------------------------------------
Traceback (most recent call last):
  File "C:\leo\src\leoTest.py", line 148, in runTest
    exec script + '\n' in {'c':c,'g':g,'p':p}
  File "&lt;string&gt;", line 22, in ?
AssertionError

----------------------------------------------------------------------
Ran 1 test in 0.051s

FAILED (failures=1)
End of Do @test</t>
<t tx="ekr.20050618061835.19">With the aforementioned possibilities of running all @test nodes in a subtree with a single click on a button, the sharing of input/expected data, and the sharing of setUp/tearDown code, there hardly seems a need for the @suite nodes.

On Leo's website (http://webpages.charter.net/edreamleo/scripting.html#unit-testing-with-test-and-suite) I could still find some extra info on @suite nodes, not found in LeoDocs.leo:

&lt;quote&gt;

Using @suite nodes

Such nodes create a suite of tests. Leo executes the script in these nodes similar to @test nodes, but Leo assumes that the script in an @suite node will do the following:

    * Create a suite of unit tests
    * Put the suite in g.app.scriptDict["suite"]

The difference between @test and @suite is:

    * Leo creates a unit test from script in an @test node by creating an instance of generalTestCase, a subclass of unittest.TestCase.
    * The script in an @suite node creates the test suite.

An @suite nodes allows us to create "legacy" unit tests simply. For example, rather than rewriting all the reformatParagraph unit tests to use @test nodes, I simply wrote an @suite node with the following body.
import leoGlobals as g
import leoTest ; reload(leoTest)
suite = leoTest.makeReformatParagraphSuite()
g.app.scriptDict['suite'] = suite

&lt;/quote&gt;

Well, that's almost, but not quite completely, totally incomprehensible to me. Fortunately, since Leo's creator removed most of this quote from LeoDocs.leo and test.leo, this information appears to be outdated.</t>
<t tx="ekr.20050618061835.20">Don't forget to read the node
Users Guide--&gt;Chapter 7: Scripting Leo with Python--&gt;Unit testing with @test, @suite
in LeoDocs.leo, especially the final notes. Also investigate a little further in test.leo to see some heavy weight lifting.

This concludes my How-To on using @test. It was not written by an expert on (unit) testing;
it is more or less the result of keeping notes on my way to find out how I could get started
with unit tests in Leo. Maybe it's useful for other newbies as well.

Please post any remarks on one of the Leo Fora, and if deemed helpful, I'll be glad to incorporate them into a next version.

Happy testing!</t>
<t tx="ekr.20050618061950"></t>
<t tx="ekr.20050620085732"></t>
<t tx="ekr.20050704170739">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20050704172623">for p in c.allNodes_iter():
    print p.level()*' ',p.headString()
</t>
<t tx="ekr.20050705142631"></t>
<t tx="ekr.20050707183613">&lt;&lt; imports &gt;&gt;

@others

if 1:
    &lt;&lt; use IPShellEmbed &gt;&gt;
else:
    shell = LeoShell('shell')
    # g.redirectStdout()
    g.es_print('-'*40)
    body = p.bodyString()
    for line in g.splitLines(body):
        g.es(str(shell.prefilter(line,None)))
    #g.restoreStdout()</t>
<t tx="ekr.20050708091220.76">class LeoShell (IPython.iplib.InteractiveShell):
    
    @others
    
    # Set the default prefilter() function (this can be user-overridden)
    prefilter = _prefilter</t>
<t tx="ekr.20050708091220.77">def __init__ (self,name):
        
    self.shell = self
    self.name = name
    
    &lt;&lt; directory stuff &gt;&gt;
    &lt;&lt; set sensible command line defaults for self.rc &gt;&gt;
    &lt;&lt; define regexp's &gt;&gt;
    &lt;&lt; define escape stuff &gt;&gt;
    &lt;&lt; define namespaces &gt;&gt;
    &lt;&lt; create alias table &gt;&gt;
    &lt;&lt; define inpsector &gt;&gt;
    
    self.inputcache = dummyCache(self.user_ns)
    self.outputcache = dummyCache(self.user_ns)
    self.CACHELENGTH = 0</t>
<t tx="ekr.20050708091220.78">shell = IPython.Shell.IPShellEmbed (
    argv=[],
    banner='Welcome to IPython in Leo',
    exit_msg='Bye',
    rc_override={
        'confirm_exit':0,
        #'readline':0, # Crashes the interactive interp.
    },
)
shell()</t>
<t tx="ekr.20050708093114"># Don't get carried away with trying to make the autocalling catch too
# much:  it's better to be conservative rather than to trigger hidden
# evals() somewhere and end up causing side effects.

self.line_split = re.compile(
    r'^([\s*,;/])'
    r'([\?\w\.]+\w*\s*)'
    r'(\(?.*$)'
)

# RegExp to identify potential function names
self.re_fun_name = re.compile(r'[a-zA-Z_]([a-zA-Z0-9_.]*) *$')

# RegExp to exclude strings with this start from autocalling
self.re_exclude_auto = re.compile('^[!=()&lt;&gt;,\*/\+-]|^is ')

# try to catch also methods for stuff in lists/tuples/dicts: off
# (experimental). For this to work, the line_split regexp would need
# to be modified so it wouldn't break things at '['. That line is
# nasty enough that I shouldn't change it until I can test it _well_.
#self.re_fun_name = re.compile (r'[a-zA-Z_]([a-zA-Z0-9_.\[\]]*) ?$')</t>
<t tx="ekr.20050708093224"># escapes for automatic behavior on the command line
self.ESC_SHELL = '!'
self.ESC_HELP  = '?'
self.ESC_MAGIC = '%'
self.ESC_QUOTE = ','
self.ESC_QUOTE2 = ';'
self.ESC_PAREN = '/'

# And their associated handlers
self.esc_handlers = {
    self.ESC_PAREN: self.handle_auto,
    self.ESC_QUOTE: self.handle_auto,
    self.ESC_QUOTE2:self.handle_auto,
    self.ESC_MAGIC: self.handle_magic,
    self.ESC_HELP:  self.handle_help,
    self.ESC_SHELL: self.handle_shell_escape,
}</t>
<t tx="ekr.20050708093433"># Set __name__ to __main__ to better match the behavior of the normal interpreter.

self.user_ns = {
    '__name__'     :'__main__',
    '__builtins__' : __builtin__,
}

self.internal_ns = __main__.__dict__.copy()</t>
<t tx="ekr.20050708094606.1"># dict of names to be treated as system aliases.  Each entry in the
# alias table must be a 2-tuple of the form (N,name), where N is the
# number of positional arguments of the alias.
self.alias_table = {}</t>
<t tx="ekr.20050708095104">class dummyCache:
    
    @others</t>
<t tx="ekr.20050708095104.1">def log(self,line,continuation=None):
    
    # Called by the logger (not sure how).
    if 0:
        g.trace(line)</t>
<t tx="ekr.20050708105323.2">def usage(self):
    
    return 'A usage message'</t>
<t tx="ekr.20050708105323.3">def ipmagic(s):
    g.trace()
    return IPython.iplib.ipmagic(s)
    
def ipalias(s):
    g.trace()
    return IPython.iplib.ipalias(s)</t>
<t tx="ekr.20050708105742"># EKR: take from make_IPython

# This should have everything from  cmdline_opts and cmdline_only
self.rc = Struct(
    autocall = 1,
    autoindent=0,
    automagic = 1,
    banner = 1,
    cache_size = 1000,
    c = '',
    classic = 0,
    colors = 'NoColor',
    color_info = 0,
    confirm_exit = 1,
    debug = 0,
    deep_reload = 0,
    editor = '0',
    help = 0,
    ignore = 0,
    ipythondir = ipythondir,
    log = 0,
    logfile = '',
    logplay = '',
    multi_line_specials = 1,
    messages = 1,
    nosep = 0,
    pdb = 0,
    pprint = 0,
    profile = '',
    prompt_in1 = 'In [\\#]:',
    prompt_in2 = '   .\\D.:',
    prompt_out = 'Out[\\#]:',
    prompts_pad_left = 1,
    quick = 0,
    readline = 1,
    readline_merge_completions = 1,
    readline_omit__names = 0,
    rcfile = 'ipythonrc' + rc_suffix,
    screen_length = 0,
    separate_in = '\n',
    separate_out = '\n',
    separate_out2 = '',
    system_verbose = 0,
    gthread = 0,
    qthread = 0,
    wthread = 0,
    pylab = 0,
    tk = 0,
    upgrade = 0,
    Version = 0,
    xmode = 'Verbose',
    magic_docstrings = 0,  # undocumented, for doc generation
)</t>
<t tx="ekr.20050708110239"># EKR: take from make_IPython.

# Platform-dependent suffix and directory names
if os.name == 'posix':
    rc_suffix = ''
    ipdir_def = '.ipython'
else:
    rc_suffix = '.ini'
    ipdir_def = '_ipython'

# default directory for configuration
if 1: ### Leo
    ipythondir = g.app.loadDir
else:
    ipythondir = os.path.abspath(
        os.environ.get('IPYTHONDIR',
        os.path.join(IP.home_dir,ipdir_def)))</t>
<t tx="ekr.20050708110336">import IPython
import IPython.genutils
from IPython.Struct import Struct

import __builtin__
import __main__
import os
import re
import sys

# we need the directory where IPython itself is installed
IPython_dir = os.path.dirname(IPython.__file__)</t>
<t tx="ekr.20050708113006.2">def system(self,s):
    
    g.trace(s)
    pass</t>
<t tx="ekr.20050708142137">def __init__ (self,user_ns):
    
    self.last_prompt = None
    self.prompt_count = 0
    self.user_ns = user_ns
    
    if 1:
        self.prompt1 = dummyPrompt('name=prompt1')
        self.prompt2 = dummyPrompt('name=prompt2')
        self.prompt_out = dummyPrompt('name=prompt_out')
    else:
        input_sep='\n'
        self.ps1_str = '&gt;&gt;&gt; '   ### self._set_prompt_str(ps1,'In [\\#]: ','&gt;&gt;&gt; ')
        self.ps2_str = '... '   ### self._set_prompt_str(ps2,'   .\\D.: ','... ')
        self.ps_out_str = ','   ### self._set_prompt_str(ps_out,'Out[\\#]: ','')
        pad_left=True
            
        self.prompt1 = IPython.Prompts.Prompt1(self,
            sep=input_sep,prompt=self.ps1_str,pad_left=pad_left)
        self.prompt2 = IPython.Prompts.Prompt2(self,
            prompt=self.ps2_str,pad_left=pad_left)
        self.prompt_out = IPython.Prompts.PromptOut(self,
            sep='',prompt=self.ps_out_str,pad_left=pad_left)
        
    self.last_prompt = self.prompt1 # Total kludge.</t>
<t tx="ekr.20050708142137.2">def __len__ (self):
    return 0
    
def insert(self,n,line):
    pass
    
def pop(self):
    return ''</t>
<t tx="ekr.20050708143008">class dummyPrompt (IPython.Prompts.BasePrompt):

    """Interactive prompt similar to Mathematica's."""

	@others</t>
<t tx="ekr.20050708143008.2">def __init__(self,cache=None,sep=None,prompt=None,pad_left=False,name='prompt'):
    
    self.name = name</t>
<t tx="ekr.20050708143008.3">def set_p_str(self):
    """ Set the interpolating prompt strings.

    This must be called every time the color settings change, because the
    prompt_specials global may have changed."""
    
    return ###

    import os,time  # needed in locals for prompt string handling
    loc = locals()
    self.p_str = ItplNS('%s%s%s' %
                        ('${self.sep}${self.col_p}',
                         multiple_replace(prompt_specials, self.p_template),
                         '${self.col_norm}'),self.cache.user_ns,loc)
    
    self.p_str_nocolor = ItplNS(multiple_replace(prompt_specials_nocolor,
                                                 self.p_template),
                                self.cache.user_ns,loc)
</t>
<t tx="ekr.20050708143008.4">def write(self,msg):  # dbg

    return '' ###

    sys.stdout.write(msg)
    return ''
</t>
<t tx="ekr.20050708143008.5">def __str__(self):
    """Return a string form of the prompt.

    This for is useful for continuation and output prompts, since it is
    left-padded to match lengths with the primary one (if the
    self.pad_left attribute is set)."""
    
    return self.name ###

    out_str = str_safe(self.p_str)
    if self.pad_left:
        # We must find the amount of padding required to match lengths,
        # taking the color escapes (which are invisible on-screen) into
        # account.
        esc_pad = len(out_str) - len(str_safe(self.p_str_nocolor))
        format = '%%%ss' % (len(str(self.cache.last_prompt))+esc_pad)
        return format % out_str
    else:
        return out_str
</t>
<t tx="ekr.20050708143008.6"># these path filters are put in as methods so that we can control the
# namespace where the prompt strings get evaluated.

def cwd_filt(self,depth):

    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""
    
    cwd = os.getcwd().replace(HOME,"~")
    out = os.sep.join(cwd.split(os.sep)[-depth:])
    if out:
        return out
    else:
        return os.sep
</t>
<t tx="ekr.20050708143008.7">def cwd_filt2(self,depth):
    """Return the last depth elements of the current working directory.

    $HOME is always replaced with '~'.
    If depth==0, the full path is returned."""

    cwd = os.getcwd().replace(HOME,"~").split(os.sep)
    if '~' in cwd and len(cwd) == depth+1:
        depth += 1
    out = os.sep.join(cwd[-depth:])
    if out:
        return out
    else:
        return os.sep
</t>
<t tx="ekr.20050708144144.1">if 0:
    @others</t>
<t tx="ekr.20050708144144.2">def auto_rewrite(self,*args,**keys):
    return ''</t>
<t tx="ekr.20050708150223">ins_colors = IPython.OInspect.InspectColors
code_colors = IPython.PyColorize.ANSICodeColors

self.inspector = IPython.OInspect.Inspector(ins_colors,code_colors,'NoColor')</t>
<t tx="ekr.20050708152111">def _prefilter(self, line, continue_prompt):
    """Calls different preprocessors, depending on the form of line."""
    
    &lt;&lt; about this function &gt;&gt;

    # save the line away in case we crash, so the post-mortem handler can record it
    self._last_input_line = line

    #print '***line: &lt;%s&gt;' % line # dbg
    if not line.strip():
        &lt;&lt; handle empty line &gt;&gt;

    # print '***cont',continue_prompt  # dbg
    # special handlers are only allowed for single line statements
    if continue_prompt and not self.rc.multi_line_specials:
        return self.handle_normal(line,continue_prompt)

    # Get the structure of the input
    pre,iFun,theRest = self.split_user_input(line)
    #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg
    
    &lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;
    &lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;
    &lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;
    &lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;

    # If we get here, we have a normal Python line. Log and return.
    return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708152111.1"># All handlers *must* return a value, even if it's blank ('').

# Lines are NOT logged here. Handlers should process the line as
# needed, update the cache AND log it (so that the input cache array
# stays synced).

# This function is _very_ delicate, and since it's also the one which
# determines IPython's response to user input, it must be as efficient
# as possible.  For this reason it has _many_ returns in it, trying
# always to exit as quickly as it can figure out what it needs to do.

# This function is the main responsible for maintaining IPython's
# behavior respectful of Python's semantics.  So be _very_ careful if
# making changes to anything here.</t>
<t tx="ekr.20050708152111.2"># the input history needs to track even empty lines

if not continue_prompt:
    self.outputcache.prompt_count -= 1

return self.handle_normal('',continue_prompt)</t>
<t tx="ekr.20050708152111.3">handler = None
if line[-1] == self.ESC_HELP:
    handler = self.esc_handlers.get(line[-1])  # the ? can be at the end
    
if handler is None:
    # look at the first character of iFun, NOT of line, so we skip
    # leading whitespace in multiline input
    handler = self.esc_handlers.get(iFun[0:1])

if handler is not None:
    return handler(line,continue_prompt,pre,iFun,theRest)

# Emacs ipython-mode tags certain input lines
if line.endswith('# PYTHON-MODE'):
    return self.handle_emacs(line,continue_prompt)</t>
<t tx="ekr.20050708152111.4"># Allow ! in multi-line statements if multi_line_specials is on:
if (
    continue_prompt and self.rc.multi_line_specials and iFun.startswith(self.ESC_SHELL)
):
    return self.handle_shell_escape(line,continue_prompt,
            pre=pre,iFun=iFun,theRest=theRest)</t>
<t tx="ekr.20050708152111.5">oinfo = None

if hasattr(self,'magic_'+iFun):
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic
    if oinfo['ismagic']:
        # Be careful not to call magics when a variable assignment is
        # being made (ls='hi', for example)
        if (
            self.rc.automagic and
            (len(theRest)==0 or theRest[0] not in '!=()&lt;&gt;,') and 
            (self.rc.multi_line_specials or not continue_prompt)
        ):
            return self.handle_magic(line,continue_prompt,pre,iFun,theRest)
        else:
            return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708152111.6"># If the rest of the line begins with an (in)equality, assginment or
# function call, we should not call _ofind but simply execute it.
# This avoids spurious geattr() accesses on objects upon assignment.
#
# It also allows users to assign to either alias or magic names true
# python variables (the magic/alias systems always take second seat to
# true python code).
if theRest and theRest[0] in '!=()':
    return self.handle_normal(line,continue_prompt)

if oinfo is None:
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic

if not oinfo['found']:
    return self.handle_normal(line,continue_prompt)
else:
    #print 'iFun &lt;%s&gt; rest &lt;%s&gt;' % (iFun,theRest) # dbg
    if oinfo['isalias']:
        return self.handle_alias(line,continue_prompt,
                                     pre,iFun,theRest)

    if self.rc.autocall and \
           not self.re_exclude_auto.match(theRest) and \
           self.re_fun_name.match(iFun) and \
           callable(oinfo['obj']) :
        #print 'going auto'  # dbg
        return self.handle_auto(line,continue_prompt,pre,iFun,theRest)
    else:
        #print 'was callable?', callable(oinfo['obj'])  # dbg
        return self.handle_normal(line,continue_prompt)</t>
<t tx="ekr.20050708152111.7"></t>
<t tx="ekr.20050708152111.9">def _prefilter(self, line, continue_prompt):
    """Calls different preprocessors, depending on the form of line."""
    
    &lt;&lt; about this function &gt;&gt;

    #if line.startswith('%crash'): raise RuntimeError,'Crash now!'  # dbg

    # save the line away in case we crash, so the post-mortem handler can record it
    self._last_input_line = line

    if not line.strip():
        return ''

    # special handlers are only allowed for single line statements
    if continue_prompt and not self.rc.multi_line_specials:
        return line

    # Get the structure of the input
    pre,iFun,theRest = self.split_user_input(line)
    #print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun,theRest)  # dbg
    
    &lt;&lt; First check for explicit escapes in the last/first character &gt;&gt;
    &lt;&lt; Next, check if we can automatically execute this thing &gt;&gt;
    &lt;&lt; Let's try to find if the input line is a magic fn &gt;&gt;
    &lt;&lt; execute comparisons, assignsments or function calls &gt;&gt;

    # A normal Python line.
    return line</t>
<t tx="ekr.20050708152111.10"># All handlers *must* return a value, even if it's blank ('').

# Lines are NOT logged here. Handlers should process the line as
# needed, update the cache AND log it (so that the input cache array
# stays synced).

# This function is the main responsible for maintaining IPython's
# behavior respectful of Python's semantics.  So be _very_ careful if
# making changes to anything here.</t>
<t tx="ekr.20050708152111.12">handler = None
if line[-1] == self.ESC_HELP:
    handler = self.esc_handlers.get(line[-1])  # the ? can be at the end
    
if handler is None:
    # look at the first character of iFun, NOT of line, so we skip
    # leading whitespace in multiline input
    handler = self.esc_handlers.get(iFun[0:1])

if handler is not None:
    return handler(line,continue_prompt,pre,iFun,theRest)

# Emacs ipython-mode tags certain input lines
if line.endswith('# PYTHON-MODE'):
    return self.handle_emacs(line,continue_prompt)</t>
<t tx="ekr.20050708152111.13"># Allow ! in multi-line statements if multi_line_specials is on:
if (
    continue_prompt and self.rc.multi_line_specials and iFun.startswith(self.ESC_SHELL)
):
    return self.handle_shell_escape(line,continue_prompt,pre=pre,iFun=iFun,theRest=theRest)</t>
<t tx="ekr.20050708152111.14">oinfo = None

if hasattr(self,'magic_'+iFun):
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic
    if oinfo['ismagic']:
        # Be careful not to call magics when a variable assignment is
        # being made (ls='hi', for example)
        if (
            self.rc.automagic and
            (len(theRest)==0 or theRest[0] not in '!=()&lt;&gt;,') and 
            (self.rc.multi_line_specials or not continue_prompt)
        ):
            return self.handle_magic(line,continue_prompt,pre,iFun,theRest)
        else:
            return line</t>
<t tx="ekr.20050708152111.15"># If the rest of the line begins with an (in)equality, assginment or
# function call, we should not call _ofind but simply execute it.
# This avoids spurious geattr() accesses on objects upon assignment.
#
# It also allows users to assign to either alias or magic names true
# python variables (the magic/alias systems always take second seat to
# true python code).
if theRest and theRest[0] in '!=()':
    return line

if oinfo is None:
    oinfo = self._ofind(iFun) # FIXME - _ofind is part of Magic

if not oinfo['found']:
    return line

if oinfo['isalias']:
    return self.handle_alias(line,continue_prompt,pre,iFun,theRest)

if (self.rc.autocall and not self.re_exclude_auto.match(theRest) and 
    self.re_fun_name.match(iFun) and callable(oinfo['obj'])
):
    return self.handle_auto(line,continue_prompt,pre,iFun,theRest)
else:
    return line</t>
<t tx="ekr.20050708152111.17">def handle_alias(self,line,continue_prompt=None,pre=None,iFun=None,theRest=None):

    """Handle alias input lines. """

    theRest = esc_quotes(theRest)

    line_out = "%s%s.call_alias('%s','%s')" % (pre,self.name,iFun,theRest)

    return line_out</t>
<t tx="ekr.20050708152111.18">def handle_shell_escape(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):

    """Execute the line in a shell, empty return value"""

    # Example of a special handler. Others follow a similar pattern.
    if continue_prompt:  # multi-line statements
        if iFun.startswith('!!'):
            print 'SyntaxError: !! is not allowed in multiline statements'
            return pre
        else:
            cmd = ("%s %s" % (iFun[1:],theRest)).replace('"','\\"')
            line_out = '%s%s.system("%s")' % (pre,self.name,cmd)
    else: # single-line input
        if line.startswith('!!'):
            # rewrite iFun/theRest to properly hold the call to %sx and
            # the actual command to be executed, so handle_magic can work
            # correctly
            theRest = '%s %s' % (iFun[2:],theRest)
            iFun = 'sx'
            return self.handle_magic('%ssx %s' % (
                self.ESC_MAGIC,line[2:]),continue_prompt,pre,iFun,theRest)
        else:
            cmd = esc_quotes(line[1:])
            line_out = '%s.system("%s")' % (self.name,cmd)

    return line_out
</t>
<t tx="ekr.20050708152111.19">def handle_magic(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):
    
    """Execute magic functions.

    Also log them with a prepended # so the log is clean Python."""

    return '%sipmagic("%s")' % (pre,esc_quotes('%s %s' % (iFun,theRest)))</t>
<t tx="ekr.20050708152111.20">def handle_auto(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):

    """Hande lines which can be auto-executed, quoting if requested."""
    
    # This should only be active for single-line input!
    if continue_prompt:
        return line
    elif pre == self.ESC_QUOTE: # Auto-quote splitting on whitespace
        return '%s("%s")\n' % (iFun,'", "'.join(theRest.split()) )
    elif pre == self.ESC_QUOTE2: # Auto-quote whole string
        return '%s("%s")\n' % (iFun,theRest)
    else: # Auto-paren
        if theRest[0:1] in ('=','['):
            # Don't autocall in these cases.  They can be rebindings of an existing callable's name,
            # or item access for an object which is BOTH callable and implements __getitem__.
            return '%s %s\n' % (iFun,theRest)
        if theRest.endswith(';'):
            return '%s(%s);\n' % (iFun.rstrip(),theRest[:-1])
        else:
            return '%s(%s)\n' % (iFun.rstrip(),theRest)</t>
<t tx="ekr.20050708152111.21">def handle_help(self, line, continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Try to get some help for the object.

    obj? or ?obj   -&gt; basic information.
    obj?? or ??obj -&gt; more details.
    """

    # Don't process lines which would be otherwise valid python, such as "x=1 # what?"
    try:
        code.compile_command(line)
    except SyntaxError: # Only handle stuff which is NOT valid syntax
        if line[0]==self.ESC_HELP:
            line = line[1:]
        elif line[-1]==self.ESC_HELP:
            line = line[:-1]
        if line:
            self.magic_pinfo(line)
        else:
            page(self.usage,screen_lines=self.rc.screen_length)
        return '' # Empty string is needed here!
    except: pass

    return line</t>
<t tx="ekr.20050708152111.22">def handle_emacs(self,line,continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Handle input lines marked by python-mode."""

    # Currently, nothing is done.
    # The input cache shouldn't be updated
    return line</t>
<t tx="ekr.20050708152111.23"></t>
<t tx="ekr.20050708152111.24">if 0: # ref
    self.line_split = re.compile(
        r'^([\s*,;/])'          # Groups[0]: s, followed by special chars: , ; or /
        r'([\?\w\.]+\w*\s*)'    # Groups[1]: one char,
        r'(\(?.*$)' )           # Groups[2]: arg list

def split_user_input(self,line):

    """Split user input into pre-char, function part and rest."""

    lsplit = self.line_split.match(line)

    if lsplit is None:  # no regexp match returns None
        try:
            iFun,theRest = line.split(None,1)
        except ValueError:
            iFun,theRest = line,''
        pre = re.match('^(\s*)(.*)',line).groups()[0]
    else:
        pre,iFun,theRest = lsplit.groups()

    print 'line:&lt;%s&gt;' % line # dbg
    print 'pre &lt;%s&gt; iFun &lt;%s&gt; rest &lt;%s&gt;' % (pre,iFun.strip(),theRest) # dbg

    return pre,iFun.strip(),theRest</t>
<t tx="ekr.20050708152111.25">def update_cache(self, line):
    
    """puts line into cache"""
    
    pass</t>
<t tx="ekr.20050708165401.1">def handle_normal(self,line,continue_prompt=None,pre=None,iFun=None,theRest=None):
    """Handle normal input lines. Use as a template for handlers."""
    
    g.trace(line)

    if 0:
        self.log(line,continue_prompt)
        self.update_cache(line)

    return line</t>
<t tx="ekr.20050708165531.1">def esc_quotes(s):

    return IPython.iplib.esc_quotes(s)</t>
<t tx="ekr.20050715132524">from Pymacs import lisp
print lisp

lisp('2')</t>
<t tx="ekr.20050722115320">import leoEditCommands

e = leoEditCommands.leoEmacs(
    editor = None, ##
    minibuffer = None, ##
    commandlabel = 'commandLabel',
    c = c,
    extracommands=None
)

print e</t>
<t tx="ekr.20050726101758">c.prettyPrintPythonNode()</t>
<t tx="ekr.20050726101926">def keyPressed( self, event ):

    &lt;&lt; create the command &gt;&gt;
    self.kTconsume = self.kRconsume = consume = self.emacs.masterCommand(event,command)
    if consume:
        # Block the event from going elsewhere, like the DocumentModel.
        event.consume()
        return

    kc = event.getKeyChar()
    if self.tab_for_colon and kc == '\n':
        event.consume()
        self.insertPreviousLeadAndNewline()
    if self.completers.has_key(kc):
        &lt;&lt; handle auto completion &gt;&gt;
    elif kc == '\t' and self.tab_width == -4:
        &lt;&lt; handle auto-tabbing &gt;&gt;
</t>
<t tx="ekr.20050726101926.1">modifiers = event.getModifiers()
mtxt = event.getKeyModifiersText(modifiers)
ktxt = event.getKeyText(event.getKeyCode())

if mtxt == ktxt:
    command = mtxt
else:
    command = '%s %s' % (mtxt,ktxt).strip()
</t>
<t tx="ekr.20050726101926.2">editor = self.emacs.editor
doc = editor.getDocument()
pos = editor.getCaretPosition()
try:
    pc = doc.getText( pos -1, 1 )
    if pc in ( '"', "'" ): return
except: pass

event.consume()
self.kTconsume = True
self.kRconsume = True
ac = self.completers[ kc ]
doc.insertString( pos, '%s%s' %( kc, ac ), None )
editor.setCaretPosition( pos + 1 )
if hasattr(self.emacs.c.frame.body.editor, "autocompleter"):
    self.emacs.c.frame.body.editor.autocompleter.hideAutoBox() </t>
<t tx="ekr.20050726101926.3">self.kTconsume = True
self.kRconsume = True
event.consume()
editor = self.emacs.editor
doc = editor.getDocument()
pos = editor.getCaretPosition()
try:
    doc.insertString( pos, " " * 4, None )
except: pass</t>
<t tx="ekr.20050726112715">self.kTconsume = self.kRconsume = consume = self.emacs.masterCommand(event,command)

a = b() # Comment test.

"""test"""

# Comment test.
    # Comment test.

if 1:
    '''Test of multi-line handling: tailing whitespace: 
done.'''</t>
<t tx="ekr.20050726141158">@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "  "
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others</t>
<t tx="ekr.20050801070538">def compressed(a,b):
    if(a==b):
        a=b+c*d
    if a==b:
        return 1
    return(a,b,c)
        
def loose ( a , b ) :
    if a  ==  b:
        return 1
    while a != 2 :
        a = b + c * d
</t>
<t tx="ekr.20050801071700">
</t>
<t tx="ekr.20050801075332">def compressed(a,b):
    if(a==b):
        a=b+c*d
    if a==b:
        return 1
    return(a,b,c)
        
def loose ( a , b ) :
    if a  ==  b:
        return 1
    while a != 2 :
        a = b + c * d
</t>
<t tx="ekr.20050803075926">@tabwidth -4

# Solves the sudoku puzzle.

import copy

digits = '123456789' # valid digits.

if 0:
    &lt;&lt; 1-star puzzles &gt;&gt;
    &lt;&lt; 2-star puzzles &gt;&gt;
    &lt;&lt; 3-star puzzles &gt;&gt;
    &lt;&lt; 4-star puzzles &gt;&gt;
    &lt;&lt; 5-star puzzles &gt;&gt;

&lt;&lt; define data &gt;&gt;

@others

print '-' * 40

solver = sudokuClass(data=data)
if not solver.errors:
    solver.solve()
</t>
<t tx="ekr.20050803075926.1">class sudokuClass:
    
    '''A class to solve the sudoku puzzle.'''
    
    @others</t>
<t tx="ekr.20050803075926.2">def __init__ (self,data):
    
    # g.trace('main')
    self.cells = []
    self.cols = []
    self.colGroups = []
    self.data = data
    self.errors = 0
    self.excludedGroupNumbers = []
    self.level = 0
    self.rowGroups = []
    self.rows = []
    self.squareGroups = []
    self.tracing = True
    self.valid = True
    self.verbose = False

    # Check the data and finish the init process.
    self.checkData()
    self.initFromData()
    self.printData()
    self.finishInit()
    # self.dump()</t>
<t tx="ekr.20050803075926.3">def error (self,s):
    
    print 'oops',s
    self.errors += 1</t>
<t tx="ekr.20050803075926.4">def finishInit (self):

    for i in xrange(9):
        self.squareGroups.append(self.squareGroupClass(self,i))
        self.rowGroups.append(self.colGroupClass(self,i))
        self.colGroups.append(self.rowGroupClass(self,i))
    
    for z in self.squareGroups:
        z.finishCreate()
    for z in self.rowGroups:
        z.finishCreate()
    for z in self.colGroups:
        z.finishCreate()

    # Must be done last!
    for z in self.squareGroups:
        z.computeRelatedGroups()
    for z in self.cells:
        z.finishCreate()</t>
<t tx="ekr.20050803075926.5">def solve (self):
    
    n = 0 ; self.valid = True
    while not self.errors and self.valid:
        n += 1
        self.progress = 0
        if self.tracing:
            print '*' * 40
            print 'solve: iteration %d at level %d' % (n,self.level)
        if not self.check(): return False
        if self.tracing: self.printCells()
        for cell in self.cells:
            # Reduce the possible values for the cell.
            cell.reduce()
        if not self.valid: break
        for cell in self.cells:
            # Find any values that appear only in one place in a group.
            cell.unique()
        if self.isFinished():
            self.printCells('success!') ; return True
        if self.tracing: self.printCells()
        for cell in self.cells:
            # Remove any possible values that would make other groups impossible.
            cell.removeConflicts()
        if not self.valid: break
        if self.isFinished():
            if self.level == 0: self.printCells('success!')
            return True
        if self.progress == 0:
            &lt;&lt; guess an answer &gt;&gt;

    if self.tracing:
        if not self.valid:
            print ; print 'reached invalid state'
        if self.progress == 0:
            print ; print 'no progress'
        self.printCells()
    return False</t>
<t tx="ekr.20050803075926.7">class cellClass:
    
    '''A class representing what is known about a particular cell.'''
    
    @others</t>
<t tx="ekr.20050803080858">def dump (self):
    
    if 0:
        print ; print 'groups...'
        for group in self.groups:
            print 'group %d, rowsNumbers: %s colNumbers: %s' % (
                group.groupNumber,group.rowNumbers,group.colNumbers)
            
    if 0:
        print ; print 'row groups...'
        for group in self.rowGroups:
            print '%d %s' % (group.rowNumber, group.rowcol)
            
    if 0:
        print ; print 'related groups...'
        for group in self.groups:     
            print 'Groups related to group %d: %s' % (
                group.groupNumber,[g.groupNumber for g in group.relatedGroups])</t>
<t tx="ekr.20050803081438">def __init__ (self,sudoku,val,i,j):
    
    # g.trace('cell',i,j,val)
    self.i = i
    self.j = j
    self.groupNumber = sudoku.groupNumber(i,j)
    self.main = sudoku
    if val is None:     self.values = [digit for digit in digits]
    else:               self.values = [str(val)]
    self.verbose = self.main.verbose

    # Set by group ctors...
    self.colGroup = None
    self.rowGroup = None
    self.squareGroup = None</t>
<t tx="ekr.20050803095202">def groupNumber (self,row,col):
    
    return (3 * (row // 3)) + (col // 3)</t>
<t tx="ekr.20050803121102">def checkData (self):
    
    rows = len(self.data)
    
    if rows != 9:
        return self.error('wrong number of rows: %d' % rows)
        
    for row in self.data:
        cols = len(row)
        if cols != 9:
            return self.error('wrong number of columns in row %d: %d' % (i,cols))</t>
<t tx="ekr.20050803121102.2">def __init__ (self,sudoku,n):
    
    # g.trace('square',n)
    self.groupNumber = n
    self.main = sudoku
    
    # Set later...
    self.cells = []
    self.colNumbers = []
    self.rowNumbers = []
    self.relatedGroups = []</t>
<t tx="ekr.20050803121730">def printData (self,tag='initial data'):
    
    print ; print tag ; print

    i = 0
    for row in self.rows:
        i += 1
        print
        for ch in row:
            if ch:
                print ('  %s  ') % ch,
            else:
                print ' ___ ',
        if i % 3 == 0 and i &lt; 9:
            print ; print ; print '_' * 53
        print
    print</t>
<t tx="ekr.20050803130829">def finishCreate (self):
    
    main = self.main

    self.cells = [cell for cell in main.cells if cell.groupNumber == self.groupNumber]
    
    for cell in self.cells:
        cell.squareGroup = self

    self.rowNumbers = []
    for cell in self.cells:
        if cell.i not in self.rowNumbers:
            self.rowNumbers.append(cell.i)
    self.rowNumbers.sort()
            
    self.colNumbers = []
    for cell in self.cells:
        if cell.j not in self.colNumbers:
            self.colNumbers.append(cell.j)
    self.colNumbers.sort()</t>
<t tx="ekr.20050803134436.1">def valIsPossible (self,val):

    # g.trace(self,val)
    assert(val is not None)

    for cell in self.rowGroup.cells:
        if cell is not self:
            if len(cell.values) == 1 and cell.values[0] == val:
                if self.main.tracing:
                    g.trace('invalid guess: %s in row %d: %s' % (val,self.i,self.rowGroup.cells))
                return False
            
    for cell in self.colGroup.cells:
        if cell is not self:
            if len(cell.values) == 1 and cell.values[0] == val:
                if self.main.tracing:
                    g.trace('invalid guess: %s in col %d: %s' % (val,self.j,self.colGroup.cells))
                return False

    return True</t>
<t tx="ekr.20050803161504">def computeRelatedGroups (self):
    
    self.relatedGroups = []
    for group in self.main.squareGroups:
        if group is not self:
            related = False
            for n in group.colNumbers:
                if n in self.colNumbers:
                    related = True
            for n in group.rowNumbers:
                if n in self.rowNumbers:
                    related = True
            if related and group not in self.relatedGroups:
                self.relatedGroups.append(group)</t>
<t tx="ekr.20050803200132">def printCells (self,tag=''):
    
    print
    if tag: print tag ; print
    
    i = 0
    for cell in self.cells:
        if len(cell.values) == 9:
            print '%7s' % '1..9',
        else:
            print '%7s' % ''.join(cell.values),
        i += 1
        if i % 9 == 0:
            print</t>
<t tx="ekr.20050803200724">def __repr__ (self):
    
    return 'cell[%d,%d]' % (self.i, self.j)
    
__str__ = __repr__</t>
<t tx="ekr.20050803202932">def initFromData (self):
    
    i = 0
    for row in self.data:
        thisRow = []
        j = 0
        for ch in row:
            if ch in digits:    val = ch
            else:               val = None
            self.cells.append(self.cellClass(self,val,i,j))
            thisRow.append(val)
            j += 1
        self.rows.append(thisRow)
        i += 1

    for j in xrange(9):
        col = [row[j] for row in self.rows]
        self.cols.append(col)</t>
<t tx="ekr.20050803202932.1">def isFinished (self):
    
    for cell in self.cells:
        n = len(cell.values)
        assert(n &gt; 0) # We should have check for self.valid previously.
        if n &gt; 1:
            return False
    return True</t>
<t tx="ekr.20050803203001">def findBestGroup (self,excludedGroupNumbers):
    
    bestGroup = None
    bestKnown = 0
    for group in self.squareGroups:
        n = 0 # Number of known cells
        for cell in group.cells:
            if len(cell.values) == 1:
                n += 1
        if 9 &gt; n &gt; bestKnown:
            if group.groupNumber not in excludedGroupNumbers:
                bestGroup = group
                bestKnown = n

    if bestGroup:
        if self.tracing:
            print ; print 'best group %d' % bestGroup.groupNumber
            if 0:
                if self.verbose:
                    print 'unknown cells',
                    for cell in bestGroup.unknownCells():
                        print cell,
                    print 'unknown vals',
                    for val in bestGroup.unknownVals():
                        print val,
                    print

    return bestGroup</t>
<t tx="ekr.20050803210939">def findGuesses (self):
    
    guesses = []
    group = self.findBestGroup(self.excludedGroupNumbers)
    self.excludedGroupNumbers.append(group.groupNumber)
    if not group:
        g.trace('No groups left to guess: %s' % excludedGroupNumbers)
        self.valid = False
        return []

    # Generate all combinations of cells and unkown vals.
    cells = [cell for cell in group.cells if len(cell.values) &gt; 1]
    vals = []
    for cell in cells:
        for val in cell.values:
            if val not in vals: vals.append(val)
    n = len(vals)
    for i in xrange(n):
        guess = [] ; j = 0
        for cell in cells:
            bunch = g.bunch(cell=cell,val=vals[(i+j)%n])
            j += 1
            guess.append(bunch)
        if self.isValidGuess(guess):
            guesses.append(guess)
    
    if not guesses:
        g.trace('No valid guess for group %d' % group.groupNumber)
        self.valid = False
        return []

    if 0: # Another trace is in initFromGuess
        print 'level %d guesses...' % self.level
        for guess in guesses:
            for bunch in guess:
                print bunch.cell,bunch.val

    return guesses</t>
<t tx="ekr.20050803215553">def trace (self,s):
    
    if self.tracing:
        print s</t>
<t tx="ekr.20050804060706">def isValidGuess (self,guess):
    
    return True ##
    
    for bunch in guess:
        if not bunch.cell.valIsPossible(bunch.val):
            return False

    return True</t>
<t tx="ekr.20050804070733">def check (self):
    
    for groups in (self.colGroups,self.rowGroups,self.squareGroups):
        for group in groups:
            if not self.checkGroup(group):
                return False
    return True
</t>
<t tx="ekr.20050804071049">def checkGroup (self,group):

    vals = []
    for cell in group.cells:
        n = len(cell.values)
        if n == 1:
            val = cell.values[0]
            if val in vals:
                g.trace('%s appears twice in group %s' % (val,repr(group)))
                return False
            vals.append(val)
    return True</t>
<t tx="ekr.20050804071242"></t>
<t tx="ekr.20050804073824">data = (
    '',
) 

data = (
    'x6x3x2xxx',
    '42x18xxxx',
    'x19xx7xxx',
    'x8xx3xxxx',
    '2x6xxx5x7',
    'xxxx2xx6x',
    'xxx2xx17x',
    'xxxx91x53',
    'xxx5x4x2x',
)</t>
<t tx="ekr.20050805150320">import leoPlugins

rst3 = leoPlugins.getPluginModule('rst3')

if rst3:
    rst3.controller.processTree(p)
else:
    rst3 = leoPlugins.loadOnePlugin('rst3',verbose=True)
    if rst3:
        g.es('rst3 loaded')
        rst3.onCreate('tag',{'c':c})
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050805165407">@nocolor
@pagewidth 100
@language python</t>
<t tx="ekr.20050805175217">import leoPlugins

rst2 = leoPlugins.getPluginModule('rst2')

if rst2:
    rst2.onIconDoubleClick('tag',{'c':c,'p':p,}) # Tag should not be 'open2'
else:
    rst2 = leoPlugins.loadOnePlugin('rst2',verbose=True)
    if rst2:
        g.es('rst2 loaded')
    else:
        # Ask to be removed.
        g.app.scriptDict['removeMe'] = True</t>
<t tx="ekr.20050808191449"></t>
<t tx="ekr.20050809091430.1">Deletes p.v.rst2_http_attributename from all nodes after writing.

Deletes p.v.unknownAttributes if it then becomes empty.</t>
<t tx="ekr.20050809091430.3"></t>
<t tx="ekr.20050809091430.4">@nocolor

If False, add_node_marker and http_support_main  do nothing.  Otherwise add_node_marker does the following:
    
1. add_node_marker writes a string using generate_node_marker.

Generates 'http-node-marker-'+str(number), where number is config.node_counter
(incremented each time add_node_marker is called.

2. Enables the following code in :
@color

    if config.tag == 'open2':
        http_map = self.http_map
    else:
        http_map = {}
        config.anchormap = {}
        # maps v nodes to markers.
        config.node_counter = 0
    # [snip] code to write the tree
    if config.rst2_http_server_support:
        self.http_map = http_map</t>
<t tx="ekr.20050809091430.6"></t>
<t tx="ekr.20050809091430.8"></t>
<t tx="ekr.20050810095252"></t>
<t tx="ekr.20050811075608">data = (
    '8xxx9x21x',
    'x9x4xxxxx',
    'xx58x7xx9',
    '7xx1xx9xx',
    'xxxx5xxxx',
    'xx6xx3x28',
    '6xx5x93xx',
    'xxxxx6x7x',
    'x48x1xxx6',
)

data = ( # 8/3: solvable.
    'x5xx9xxxx',
    'xx48xxxx9',
    'xxx1x728x',
    '56xxxx137',
    'xxxxxxxxx',
    '173xxxx42',
    'x215x8xxx',
    '6xxxx38xx',
    'xxxx1xx6x')
    
data = ( # 1 stars
    'x4xxxx179',
    'xx2xx8x54',
    'xx6xx5xx8',
    'x8xx7x91x',
    'x5xx9xx3x',
    'x1xx6xx4x',
    '3xx4xx7xx',
    '57x1xx2xx',
    '928xxxx6x')
    
data = (
    '6xx75x1xx',
    '8xxxx34xx',
    'x3x96xx25',
    'xxx4xx3x2',
    '7xxxxxxx6',
    '2x1xx5xxx',
    '31xx89x4x',
    'xx65xxxx1',
    'xx5x42xx3') # solvable.
    
data = (
    'xxxxx6xx5',
    'xx41xx8xx',
    'x5xx78x42',
    '58xxxx9xx',
    '3xxxxxxx7',
    'xx6xxxx18',
    '24x39xx7x',
    'xx7xx52xx',
    '9xx7xxxxx') # solvable

data = (
    'xxxxx6xx5',
    'xx41xx8xx',
    'x5xx78x42',
    '58xxxx9xx',
    '3xxxxxxx7',
    'xx6xxxx18',
    '24x39xx7x',
    'xx7xx52xx',
    '9xx7xxxxx') # 9/8/05 3 stars

data = (
    'xxxx64x15',
    'x549xx6x2',
    'xxxxxxx7x',
    'xxxx8x2xx',
    '1x8xxx5x7',
    'xx7x4xxxx',
    'x3xxxxxxx',
    '8x2xx319x',
    '94x87xxxx') # 9/9/05 3 stars
        
data = (
    '8xxxxxxxx',
    'x915x36xx',
    'x62xxxx8x',
    'xx9xx8xxx',
    'x752x984x',
    'xxx4xx9xx',
    'x1xxxx42x',
    'xx49x276x',
    'xxx7xxxx5',
)</t>
<t tx="ekr.20050811141217">@language python

@ @rst-options
code_mode = False
show_leo_directives = True
number_code_lines = False
@c

#########################
ListManager Documentation
#########################

:Author: Steven Zatz, Modified by EKR.
:Contact: slzatz@hotmail.com
:Date: $Date$
:Status: This is a "work in progress"
:Revision: $Revision$
:Copyright: Application and documentation use the Python license which is compatible with the GPL. 

This is experimental documentation of a program called ListManager, written in
Python and wxPython using Leo to create both the application code and the
associated reST documentation.

ListManager is an application that allows a group of people working on a joint
project to maintain a common list of todos and related items that have owners,
due dates and associated notes. The application uses mysql as its database for
group use and also uses sqlite for locally resident databases for personal
lists. It works in conjunction with Outlook to allow email messages to be sent
to ListManager for inclusion in lists and uses Outlook to mail messages to
users.

.. contents:: Table of Contents
</t>
<t tx="ekr.20050811141217.1">@language python
@color
@others

@ @rst-options
code_mode = True
@c
</t>
<t tx="ekr.20050811141217.2">@ @rst-markup

Nothing unusual in what follows:  we start with the module imports, setting some global constants including Menu Ids and read the ListManager.ini file.</t>
<t tx="ekr.20050811141217.4">from wxPython.wx import *
from wxPython.lib.mixins.listctrl import wxListCtrlAutoWidthMixin

import os
import time
import pickle
import socket
import select
import random
import ConfigParser
import threading
import re
import sys

from pywintypes import CreateGuid
from win32com.client import Dispatch
#import win32pdh
import win32api
#from win32com.client import constants #--&gt; just needed two constants...

import MySQLdb
import sqlite
import mx.DateTime

from LMDialogs import CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog
#from wxTreeCtrl import TreeDialog

from printout import PrintTable</t>
<t tx="ekr.20050811141217.5">@nocolor

os
    uses ``os.getcwd``, ``os.path.split``, ``os.chdir``, ``os.path.join``, ``os.path.getmtime``, ``os.startfile``, ``os.environ``

time
    uses ``time.sleep``, ``time.asctime``

pickle
    used to serialize data that is moved from Outlook to ListManager via sockets.  

socket
    as noted above, a socket is opened between Outlook and ListManager to move messages back and forth

select
    ListManager selects on the socket to see if there is a message that has been queued by Outlook

random
    used by the reminder popup to select messages

ConfigParser
    not surprisingly, using ConfiParser to parse the ListManager.ini file.  

threading
    more for fun than absolute necessity, a thread is opened on starting the program that constructs the list of owners for items.  In theory, if the datasize and number of Lists were large enough it could delay the appearance of the GUI and its initial responsiveness if we didn't construct the ownerlist in a thread.  On the other hand, it really let me play with threads and with creating a custom event that signalled the construction of the owner list to the main thread by posting a custom event.

re
    mainly using ``re.sub('[\\/:*"&lt;&gt;|\?]','-',f)`` to make sure that files are constructed only with legal characters.  Also searching the body text of nodes using re because it allows case insensitive searches through ``re.compile(pat, re.I)``.

pywintypes.CreateGuid
    probably should use pure python GUID that is in ASPN cookbook but it was easiest to just use the Windows GUID function.  Thank you Mark Hammond for win32all.

win32com.client.Dispatch
    used when launching Outlook to send email messages

win32api
    using win32api.GetUserName() in case there is no user name in the ini file or no ini file

MySQLdb
    using Andy Dustman's python extension module to connect to mysql back-end.

sqlite
    using  D. Richard Hipp's python extension to connect to local sqlite databases

import mx.DateTime
    using Marc-Andr Lemburg's mx.DateTime for dealing with datetime stuff in the databases

CalendarDialog, ModifierDialog, TicklerDialog, MailDialog,LoggerDialog, FinishedDialog, FindDialog, EvalDialog, TreeDialog, StartupDialog
   should just import LMDialogs and then access each dialog class by LM.WhateverDialog

printout.PrintTable
    There was an existing wxPython print module for printing from tables that I have modified to print Lists.

*#from win32com.client import constants*
    probably not wise but since the app only needs two constants from this module, just set the directly.  If MSFT decides to change the api, this is not good.
</t>
<t tx="ekr.20050811141217.6">cwd = os.getcwd()
DIRECTORY = os.path.split(cwd)[0]
os.chdir(DIRECTORY)
del cwd

#Outlook Constants
olMailItem = 0x0
olFlagMarked = 0x2

OFFLINE_ONLY = False #False-&gt; Online only  ; True-&gt; Online and Offline possible; REMOTE_HOST = None -&gt; Offline only

VERSION = '1.02'

@ @rst-markup

The following two global constants are needed to create emails through Outlook via COM::

    olMailItem = 0x0
    olFlagMarked = 0x2

For some reason, it seemed easier to just include them explicitly rather than worrying about generating all the Outlook constants in order to use early binding.  I supppose if MSFT changes the api, that would be a problem.
</t>
<t tx="ekr.20050811141217.8">@ @rst-markup
Menu Ids -- not much more to say although there should be something to say.
@c

#File Menu-----------------#
idNEWLIST = 1000
idOPENLIST = 1010
idCLOSELIST = 1015
idCLOSEALL = 1017
idSAVEAS = 1020
idDELETELIST = 1025
idPAGESETUP = 1030
idPRINT = 1035
idPRINTPREV = 1040
idMAILLIST = 1045
idOFFLINE = 1048
idEXIT = 1050

#Edit Menu-----------------
idCUT = 1055
idCOPY = 1060
idPASTE = 1065
idDELETEITEMS = 1070
idCOMBINEITEMS = 1075
idFIND = 1080

#Item Menu-------------------
idNEWITEM = 1085
idTOGGLEFINISHED = 1090
idEDITOWNER = 1095
idDUEDATE = 1100
idEDITNOTE = 1105
idMAILITEM =1110

#Diplay Menu---------------------
idSHOWFINISHED = 1115
idSHOWALL = 1120
idREFRESH = 1125
idDISPLAYDATE = 1130

#Tool Menu------------------------
idTICKLERACTIVE = 1135
idSHOWNEXT = 1140
idSYNC = 1145
idARCHIVE = 1150
idEVALUATE = 1155
idTOOLPRINT = 1165
idSENDTO = 1170

#Help Menu-------------------------
idABOUT = 1175
idHELP = 1180


</t>
<t tx="ekr.20050811141217.10">config_file = os.path.join(DIRECTORY, "List Manager.ini")
defaults = dict(pw='python', db='listmanager', ext='txt', local='wxLMDB:sqlite', x='700', y='400')
cp = ConfigParser.ConfigParser(defaults=defaults)
cp.read(config_file) #ConfigParser closes the file

USER = cp.has_option('User','user') and cp.get('User','user') or win32api.GetUserName()

# the following all have default values provided in the constructor
PW = cp.get('User','pw')
DB = cp.get('Database','db')
NOTE_EXT = cp.get('Note','ext')
LOCAL_HOST = cp.get('Hosts','local')
X = cp.getint('Configuration','x')
Y = cp.getint('Configuration','y')

# the folloowing default to None
MAIL_LIST_PATH = cp.has_option('Mail','path') and cp.get('Mail','path') or None
QUICK_LIST = cp.has_option('User','quicklist') and cp.get('User','quicklist') or None

# the following default to False
STARTUP_DIALOG = cp.has_option('User','startup_dialog') and cp.getboolean('User','startup_dialog')
DELETE_LIST = cp.has_option('User','delete_list') and cp.getboolean('User','delete_list')
OUTLOOK = cp.has_option('Mail','outlook') and cp.getboolean('Mail','outlook')

if cp.has_option('Hosts','remote'):
    REMOTE_HOST = cp.get('Hosts','remote')
else:
    REMOTE_HOST = None
    OFFLINE_ONLY = True
    
# reading it again because of the way defaults are handled
cp = ConfigParser.ConfigParser()
cp.read(config_file) #ConfigParser closes the file

if cp.has_section('Synchronization'):
    SYNC_TABLES = [t[1] for t in cp.items('Synchronization')]
else:
    SYNC_TABLES = ['follow_ups']

</t>
<t tx="ekr.20050811141217.11">@nocolor

.. sidebar:: A typical *List Manager.ini* file:

    ::

        [Files]
        path0 = wxLMDB:sqlite:mine
        path1 = nycpsszatzsql:mysql:follow_ups
        
        [Database]
        db = listmanager
        
        [Note]
        ext = txt
        
        [Synchronization]
        sync2 = follow_ups
	sync1 = test
        
        [Hosts]
        remote = nycpsszatzsql:mysql
        local = wxLMDB:sqlite
        
        [User]
        startup_dialog = true
        user = szatz
        pw = python
        
        [Mail]
	outlook = true
	path = wxLMDB:sqlite:mail_transfer
        
        [Configuration]
        y = 642
        x = 975

Application uses the ``ConfigParser`` module ito parse the ini file.  Unfortunately, ``ConfigParser`` doesn't work exactly like I think it should although it has been improved in 2.3.  My main issue is in the handling of default options.  The default options specified through the constructor show up in every section.  For example, if you use the items(*section*) method
then in addition to returning a list of tuples with whatever option/value pairs exist in the section, the list will include all the default option/value pairs, which does not make a whole lot of sense to me.  At the least, there should be a 'nodefaults' argument whose default was *False* but which could be set to *True*.  The following methods should have this option:

- items
- options
- has_option

In any event, because a nodefaults option does not exist, I create the ConfigParser object twice -- once with default options and once without them.  

The application will work fine if there is no ini file. In an effort to save some typing but not be too obscure, many of the options are read such that they default to the correct value either through explicit defaults in the constructor or statements that evaluate to *None* or *False*.

    ``QUICK_LIST = cp.has_option('User','quicklist') and cp.get('User','quicklist') or None``
    
    ``OUTLOOK = cp.has_option('Mail','outlook') and cp.getboolean('Mail,'outlook')``</t>
<t tx="ekr.20050811141217.12">class ListManager(wxFrame):
    @others

@ @rst-markup

ListManager is the main class in the application and is a sublass of ``wxFrame``, which is typical for a wxPython application.  From a GUI standpoint, the main child window of the ListManager object is a ``wxNoteBook`` object that holds one ``wxListCtrl`` per notebook page and one ``wxListBox``.  The ``wxListCtrl``\s display item information (e.g., name of the item, owners of the item, etc.) for a particular List and the ``wxListBox``\es displays a list of owners that is used to filter the items displayed by the ``wxListCtrl`` object.

Each ``wxListCtrl`` object has its own set of events that it is hooked to (see CreateNewNotebookPage`&lt;&lt; ListControl Events &gt;&gt;`_.
</t>
<t tx="ekr.20050811141217.14"></t>
<t tx="ekr.20050811141217.16">def __init__(self, parent, id, title, size):
    wxFrame.__init__(self, parent, id, title, size = size)

    self.SetIcon(wxIcon('bitmaps//wxpdemo.ico', wxBITMAP_TYPE_ICO))
    self.CreateStatusBar()
  
    &lt;&lt; ListManager Attributes &gt;&gt;
    &lt;&lt; Menu Setup &gt;&gt;
    &lt;&lt; Toolbar Setup &gt;&gt;
    &lt;&lt; Menu/Toolbar Events &gt;&gt;
    &lt;&lt; Create Controls&gt;&gt;
    &lt;&lt; Layout Stuff &gt;&gt;
    &lt;&lt; Other Events &gt;&gt;
    &lt;&lt; GUI Instance Objects &gt;&gt;
    &lt;&lt; Create Socket &gt;&gt;
    &lt;&lt; Load Recent Files &gt;&gt;
    &lt;&lt; Idle Timer &gt;&gt;
    
    ownerthread = threading.Thread(target=self.createownerlist)
    ownerthread.start()
    self.ModifierDialog = None

</t>
<t tx="ekr.20050811141217.17">@nocolor

The ListManager ``__init__`` method is pretty straightforward.  The ``__init__`` arguments are the ones that need to be passed to ``wxFrame __init__`` method. The wxFrame class has the following form:

    ``wxFrame(parent, id, title, pos=wxDefaultPosition, size=wxDefaultSize, style=wxDEFAULT_FRAME_STYLE, name="frame")``

The default style (``wxDEFAULT_FRAME_STYLE``) includes ``wxMINIMIZE_BOX``, ``wxMAXIMIZE_BOX``, ``wxRESIZE_BORDER``, ``wxSYSTEM_MENU``, ``wxCAPTION`` (the latter is the text that appears in the title bar).

``SetIcon`` is a method of ``wxFrame`` that sets the icon in the upper left of the title bar of the frame.  The wxIcon class has the following form:

    ``wxIcon(filename, type, desiredWidth=-1, desiredHeight=-1)``

``CreateStatusBar`` is a method of ``wxFrame``. The wxPython form is:

        ``CreateStatusBar(number=1, style=0, id=-1)``

*number* --&gt;
    number of fields to create. Specify a value greater than 1 to create a multi-field status bar.

``CreateStatusBar`` needs to be called before &lt;&lt; Load Recent Files &gt;&gt;.

The various sections of ``__init__`` are explained in their corresponding section::

    &lt;&lt; ListManager Attributes &gt;&gt;
    &lt;&lt; Menu Setup &gt;&gt;
    &lt;&lt; Toolbar Setup &gt;&gt;
    &lt;&lt; Menu/Toolbar Events &gt;&gt;
    &lt;&lt; Create Controls&gt;&gt;
    &lt;&lt; Layout Stuff &gt;&gt;
    &lt;&lt; Other Events &gt;&gt;
    &lt;&lt; GUI Instance Objects &gt;&gt;
    &lt;&lt; Create Socket &gt;&gt;
    &lt;&lt; Load Recent Files &gt;&gt;</t>
<t tx="ekr.20050811141217.18">self.PropertyDicts = []
self.ItemLists = []
self.ListCtrls = []
self.OwnerLBoxes = []

self.L = -1
self.curIdx = -1

self.printdata = wxPrintData()
self.printdata.SetPaperId(wxPAPER_LETTER)
self.printdata.SetOrientation(wxPORTRAIT)

#self._options = {} #would be used in loadconfig

self.copyitems = []    
self.modified = {}
self.tickler_active = False

#there is a wxPanel in the AddListControl method so each wxListCtrl has a different panel as parent
#there is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference

self.editor = []

self.Cursors = {}
self.sqlite_connections = []
self.popupvisible = False
self.in_place_editor = None
self.showrecentcompleted = 0

self.LC_font = wxFont(9, wxSWISS, wxNORMAL, wxNORMAL)

self.date_titles = {'createdate':"Create Date",'duedate':"Due Date",'timestamp':"Last Modified",'finisheddate':"Completion Date"}
self.attr2col_num = {'priority':0, 'name':1,'owners':2, 'date':3}

self.FindDialog = FindDialog(self, "Find...", "")
self.EvalDialog = EvalDialog(self, "Evaluate...", "")
</t>
<t tx="ekr.20050811141217.19">@nocolor

self.PropertyDicts
    list of dictionaries that describe properties of each ListManager List (note that when referring to a collection of ListManager items a capital *L* List and table are used interchangeably).

self.ItemLists
    list of lists that consist of instance objects of class ``Item``.  Each of the lists contained in self.ItemLists correspond to the items that are being displayed in the ListCtrl.  So ``self.Itemlist[2]`` corresponds to the 2nd tab of the notebook and to the items in self.ListCtrls[2].

The class ``Item`` is just an empty class being used as a convenience to hold item attributes::

    class Item:
        pass

The purpose of the class is just to create an object that can have various attributes as follows:

+-----------------+----------------------------------------------------+
|item.id          |GUID                                                |
+-----------------+----------------------------------------------------+
|item.name        |string that describes the item                      |
+-----------------+----------------------------------------------------+
|item.priority    |integer ranging from 1 (high) to 3 (low)            |
+-----------------+----------------------------------------------------+
|item.owners      |list of the form ["Zatz, Steve", "Hoffman, Steve"]  |
+-----------------+----------------------------------------------------+
|item.note        |string that provides additional info on item        |
+-----------------+----------------------------------------------------+
|item.timestamp   |timestamp indicating when an item was last modified |
+-----------------+----------------------------------------------------+
|item.duedate     |default is None; mx.DateTime date                   |
+-----------------+----------------------------------------------------+
|item.createdate  |mx.DateTime.now() mx.DateTime timestamp             |
+-----------------+----------------------------------------------------+
|item.finisheddate|efaut is None; mx.DateTime date                     |
+-----------------+----------------------------------------------------+

self.ListCtrls
    list of of instance objects of class ListCtrls, which are a subclass of wxPython class wxListCtrl.

self.OwnerLBoxes
    list of of instance objects of wxPython class wxListBox, which is a simple one column List Control.

The wxPython constructor for a wxListBox is:

    ``wxListBox(parent, id, pos=wxDefaultPosition, size=wxDefaultSize, choices=[], style=0)``

self.L
    index of the currently active notebook tab.  If there are any tabs in the notebook then one of them is always selected.  If there are no tabs then this is indicated by setting ``self.L = -1``.

self.curIdx
    currently selected row in the active ``ListCtrl``.  There are times like after a row is deleted in which there may be rows visible but no row is selected.

The following lines set the default printer data::

    self.printdata = wxPrintData()
    self.printdata.SetPaperId(wxPAPER_LETTER)
    self.printdata.SetOrientation(wxPORTRAIT)


The wxPython class ``wxPrintData`` holds a variety of information related to printers and printer device contexts. This class is used to create a wxPrinterDC and a wxPostScriptDC. It is also used as a data member of wxPrintDialogData and wxPageSetupDialogData, as part of the mechanism for transferring data between the print dialogs and the application.

self.copyitems
    list that contains item instance objects that have been copied from one list to be moved to another list.

self.modified
    dictionary that contains the information concerning whether any of several elements have been changed.  Chose a dictionary more to test the idea that I could create a simple method that would update the dictionary and here is an example:

    ``EVT_TEXT(self, self.name.GetId(), lambda e: self.modified.update({'name':1}))``

So this lambda function means that if an ``EVT_TEXT`` event occurs then update the dictionary by adding the key to the dictionary (the value is not used and arbitrarily set to 1).  The wxPython form for the macro ``EVT_TEXT`` is:

    ``EVT_TEXT(window, id, func)``

A ``wxEVT_COMMAND_TEXT_UPDATED`` event is generated when the text in a ``wxTextCtrl`` changes and that is what ``EVT_TEXT`` catches. Note that this event will always be sent when the text controls content changes - whether this is due to user input or comes programmatically (for example, if ``SetValue()`` is called)

self.Cursors
    dictionary that holds the database cursor objects.  For example, it will look like:  ``{'sqlite':&lt;sqlite cursor object&gt;,'nycpsltszatz':&lt;mysql cursor object&gt;}``

self.tickler_active
    booean determines whether the tickler capabililty is active; can be shut off by unchecking Tickler menu item

self.editor
    list that holds the dictionaries that describe the notes that are edited by the external text editor::

        [
        {
        'table': 'mine',
        'host': 'wxLMDB:sqlite',
        'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\Journal Scan schedule.txt',
        'id': '1AB34FB9-9EE6-4AFC-8AF0-FFCA50103BF3',
        'time': 1070850894
        }, 
        {
        'table': 'factoids',
        'host': 'wxLMDB:sqlite',
        'path': 'C:\\DOCUME~1\\STEVEN~1\\LOCALS~1\\Temp\\How many cme programs are sponsored- - 91%.txt', 
        'id': '9CAC4D18-DE1C-4535-B9A5-4CDB1AD3F304', 
        'time': 1070850908
        }
        ]

The method that uses self.editor is `&lt;&lt; Check if Edited File has Changed &gt;&gt;`_.

There is a ``wxPanel`` in the ``AddListControl`` method so each ``wxListCtrl`` has a different panel as parent.

There is a nb_sizer = wxNotebookSizer(nb) class but doesn't seem to make any difference.

self.sqlite_connections
    Here because the sqlite connection has a weakreference that deletes it when you want it around

self.popupvisible
    boolean that is used to ensure that two reminder popups aren't visible at the same time.

self.in_place_editor 
    boolean that indicates whether the inplace item name text editor is active or not.

self.showrecentcompleted
    integer that determines the number of days in the past to retain completed items in the display.

self.LC_font
    default font for all of the ``ListCtrls``:  ``self.LC_font = wxFont(9, wxSWISS, wxNORMAL, wxNORMAL)``

The wxPython ``wxFont`` constructor is:

    ``wxFont(pointSize, family, style, weight, underline=False, faceName="", wencoding=wxFONTENCODING_DEFAULT)``

self.date_titles
    dictionary that holds the various dates that are associated with each item and which can be displayed in the date column.  The dictionary is not modified.  We use one column of each ``ListCtrl`` to display any one of the four dates that that the application tracks. This dictionary associates the item attribute with the text that will be displayed in both the column header for the date and in the dropdown that allows you to change the date:  ``self.date_titles = {'createdate':"Create Date",'duedate':"Due Date",'timestamp':"Last Modified",'finisheddate':"Completion Date"}``

self.attr2col_num
    dictionary that associates the item attribute with the column that attribute is displayed in in the ``ListCtrl``:  ``self.attr2col_num = {'priority':0, 'name':1,'owners':2, 'date':3}``

The following lines construct the Find Dialog and the Dialog that catches errors and shows expressions for debugging::

    self.FindDialog = FindDialog(self, "Find...", "")
    self.EvalDialog = EvalDialog(self, "Evaluate...", "")</t>
<t tx="ekr.20050811141217.20">filemenu = wxMenu()
filemenu.Append(idNEWLIST, "New List...", "Create a new List")
filemenu.Append(idOPENLIST, "Open List...", "Open a List")
filemenu.Append(idCLOSELIST, "Close", "Close the current List")
filemenu.Append(idCLOSEALL, "Close All", "Close all open Lists")
filemenu.Append(idSAVEAS, "Save As Text File...", "Save the current List")
filemenu.AppendSeparator()
filemenu.Append(idDELETELIST, "Delete List...", "Select a list to delete")
filemenu.AppendSeparator()
filemenu.Append(idPAGESETUP, "Page Setup...")
filemenu.Append(idPRINT, "Print...", "Print the current view")
filemenu.Append(idPRINTPREV, "Print Preview")
filemenu.AppendSeparator()
filemenu.Append(idMAILLIST, "Mail...", "Mail the current view")
filemenu.AppendSeparator()
filemenu.AppendCheckItem(idOFFLINE, "Work Offline")
filemenu.AppendSeparator()
filemenu.Append(idEXIT, "Exit", "Exit the program")

editmenu = wxMenu()
editmenu.Append(idCUT, "Cut\tCtrl+X")
editmenu.Append(idCOPY, "Copy\tCtrl+C")
editmenu.Append(idPASTE, "Paste\tCtrl+V")
editmenu.AppendSeparator()
editmenu.Append(idDELETEITEMS, "Delete")
editmenu.AppendSeparator()
editmenu.Append(idCOMBINEITEMS, "Combine Items...")
editmenu.AppendSeparator()
editmenu.Append(idFIND, "Find...")

itemmenu = wxMenu()
itemmenu.Append(idNEWITEM, "New Item")
itemmenu.AppendSeparator()
itemmenu.Append(idTOGGLEFINISHED, "Toggle Finished")
itemmenu.Append(idEDITOWNER, "Owner...")
itemmenu.Append(idDUEDATE, "Due Date...")
itemmenu.Append(idEDITNOTE, "Note...")
itemmenu.AppendSeparator()
itemmenu.Append(idMAILITEM, "Mail...")

displaymenu = wxMenu()
displaymenu.Append(idSHOWFINISHED, "Show/Hide Finished...")
displaymenu.AppendSeparator()
displaymenu.Append(idSHOWALL, "Show All", "Show all items in the current list")
displaymenu.AppendSeparator()
displaymenu.Append(idREFRESH, "Refresh Display", "Refresh the Display")
displaymenu.Append(idDISPLAYDATE, "Select Date to Display")

toolmenu = wxMenu()
toolmenu.AppendCheckItem(idTICKLERACTIVE, "Tickler Active")
toolmenu.Check(idTICKLERACTIVE,False)
toolmenu.Append(idSHOWNEXT, "Show Next Reminder")
toolmenu.Append(idSYNC, "Synchronize local and remote DBs")
toolmenu.Append(idARCHIVE, "Archive completed items in list...")
toolmenu.Append(idEVALUATE, "Evaluate an expression...")

helpmenu = wxMenu()
helpmenu.Append(idABOUT, "About ListManager")
helpmenu.Append(idHELP, "Help")

menubar = wxMenuBar()
menubar.Append(filemenu, '&amp;File')
menubar.Append(editmenu, 'Edit')
menubar.Append(itemmenu, 'Item')
menubar.Append(displaymenu, 'Display')
menubar.Append(toolmenu, 'Tools')
menubar.Append(helpmenu, 'Help')
self.SetMenuBar(menubar)
toolmenu.Enable(idSHOWNEXT,self.tickler_active)
filemenu.Enable(idDELETELIST,DELETE_LIST)
filemenu.Check(idOFFLINE,OFFLINE_ONLY)

#file history
self.filehistory = wxFileHistory()
self.filehistory.UseMenu(filemenu)

</t>
<t tx="ekr.20050811141217.21">@nocolor

+------------------------+------------------------------------------------+
|**File Menu**           |                                                |
+------------------------+------------------------------------------------+
| "New List... "         ||nl| ``self.OnNewList``                         |
+------------------------+------------------------------------------------+
| "Open List..."         ||ol| ``self.OnOpenList``                        |
+------------------------+------------------------------------------------+
| "Close"                |``self.OnCloseList``                            |
+------------------------+------------------------------------------------+
| "Close All"            |``self.OnCloseAll``                             |
+------------------------+------------------------------------------------+
| "Save As Text File..." |``self.OnSaveAsText``                           |
+------------------------+------------------------------------------------+
| "Delete List..."       ||de| ``self.OnDeleteList``                      |
+------------------------+------------------------------------------------+
| "Page Setup..."        ||ps| ``self.OnPageSetup``                       |
+------------------------+------------------------------------------------+
| "Print..."             ||pt| ``self.OnPrint``                           |
+------------------------+------------------------------------------------+
| "Print Preview"        ||pp| ``lambda e: self.OnPrint(e, prev=True)``   |
+------------------------+------------------------------------------------+
| "Mail..."              |``self.OnMailView``                             |
+------------------------+------------------------------------------------+
| "Work Offline"         |``self.OnWorkOffline``                          |
+------------------------+------------------------------------------------+
| "Exit"                 |``self.OnExit``                                 |
+------------------------+------------------------------------------------+
| **Edit Menu**          |                                                |
+------------------------+------------------------------------------------+
| "Cut" [Ctrl+X ]        ||ec| ``lambda e: self.OnCopyItems(e, cut=True)``|
+------------------------+------------------------------------------------+
| "Copy" [Ctrl+C]        ||ey| ``self.OnCopyItems``                       |
+------------------------+------------------------------------------------+
| "Paste" [Ctrl+V]       ||ep| ``self.OnPasteItems``                      |
+------------------------+------------------------------------------------+
| "Delete"               ||de| ``self.OnDeleteItems``                     |
+------------------------+------------------------------------------------+
| "Combine Items..."     |``self.OnCombineItems``                         |
+------------------------+------------------------------------------------+
| "Find..."              ||fi| ``self.OnFind``                            |
+------------------------+------------------------------------------------+
| **Item Menu**          |                                                |
+------------------------+------------------------------------------------+
| "New Item"             ||ni| ``self.OnNewItem``                         |
+------------------------+------------------------------------------------+
| "Toggle Finished"      ||co| ``self.OnToggleFinished``                  |
+------------------------+------------------------------------------------+
| "Owner..."             ||ow| ``self.OnEditOwner``                       |
+------------------------+------------------------------------------------+
| "Due Date..."          ||dd| ``self.OnDueDate``                         |
+------------------------+------------------------------------------------+
| "Note..."              ||en| ``self.OnEditNote``                        |
+------------------------+------------------------------------------------+
| "Mail..."              ||mi| ``self.OnMailItem``                        |
+------------------------+------------------------------------------------+
| **Display Menu**       |                                                |
+------------------------+------------------------------------------------+
| "Show/Hide Finished..."|``self.OnShowFinished``                         |
+------------------------+------------------------------------------------+
| "Show All"             |``self.OnShowAll``                              |
+------------------------+------------------------------------------------+
| "Refresh Display"      ||re| ``self.OnRefresh``                         |
+------------------------+------------------------------------------------+
|"Select Date to Display"|``self.OnDisplayDateCategory``                  |
+------------------------+------------------------------------------------+
| **Tool Menu**          |                                                |
+------------------------+------------------------------------------------+
| "Tickler Active"       |``self.OnActivateTickler``                      |
+------------------------+------------------------------------------------+
| "Show Next Reminder"   |``self.OnShowTickler``                          |
+------------------------+------------------------------------------------+
| "Synchronize ..."      |``self.OnSync``                                 |
+------------------------+------------------------------------------------+
| "Archive completed..." |``self.OnArchive``                              |
+------------------------+------------------------------------------------+
| "Evaluate expression"  |``self.OnShowEvaluate``                         |
+------------------------+------------------------------------------------+
| **Help Menu**          |                                                |
+------------------------+------------------------------------------------+
| "About ListManager"    |``self.OnShowAbout``                            |
+------------------------+------------------------------------------------+
| "Help"                 |``self.OnShowHelp``                             |
+------------------------+------------------------------------------------+




</t>
<t tx="ekr.20050811141217.22">tb = self.CreateToolBar(wxTB_HORIZONTAL|wxTB_FLAT)

tb.AddLabelTool(idNEWLIST, "New (local) List", wxBitmap('bitmaps\\new.bmp'), shortHelp="Create New List")
tb.AddLabelTool(idOPENLIST, "Open", wxBitmap('bitmaps\\open.bmp'), shortHelp="Open List")
tb.AddSeparator()
tb.AddLabelTool(idTOOLPRINT, "Print", wxBitmap('bitmaps\\print.bmp'), shortHelp="Print List")
tb.AddLabelTool(idPRINTPREV, "Preview", wxBitmap('bitmaps\\preview.bmp'), shortHelp="Print Preview")
tb.AddLabelTool(idPAGESETUP, "Setup", wxBitmap('bitmaps\\setup.bmp'), shortHelp="Page Setup")
tb.AddSeparator()
tb.AddLabelTool(idNEWITEM, "New Item", wxBitmap('bitmaps\\new_item.bmp'), shortHelp="Create New Item")
tb.AddSeparator()
tb.AddLabelTool(idREFRESH, "Refresh", wxBitmap('bitmaps\\refresh.bmp'), shortHelp="Refresh Display")     
tb.AddSeparator()
tb.AddLabelTool(idEDITNOTE, "Edit Note", wxBitmap('bitmaps\\edit_doc.bmp'), shortHelp="Edit Note")
tb.AddSeparator()
tb.AddLabelTool(idFIND, "Find", wxBitmap('bitmaps\\find.bmp'), shortHelp = "Find Item")        
tb.AddSeparator()
tb.AddLabelTool(idCUT, "Cut", wxBitmap('bitmaps\\editcut.bmp'), shortHelp ="Cut Item")        
tb.AddLabelTool(idCOPY, "Copy", wxBitmap('bitmaps\\copy.bmp'), shortHelp ="Copy Item")
tb.AddLabelTool(idPASTE, "Paste", wxBitmap('bitmaps\\paste.bmp'), shortHelp="Paste Item")
tb.AddSeparator()
tb.AddLabelTool(idTOGGLEFINISHED, "Toggle Date", wxBitmap('bitmaps\\filledbox.bmp'), shortHelp="Toggle Finished Date")
tb.AddLabelTool(idDELETEITEMS, "Delete", wxBitmap('bitmaps\\delete.bmp'), shortHelp="Delete Item")
tb.AddLabelTool(idDUEDATE, "Due Date", wxBitmap('bitmaps\\calendar.bmp'), shortHelp="Enter Due Date")
tb.AddLabelTool(idEDITOWNER,"Owner", wxBitmap('bitmaps\\owners.bmp'), shortHelp="Select Owner(s)")
tb.AddSeparator()
tb.AddLabelTool(idMAILITEM, "Mail", wxBitmap('bitmaps\\mail.bmp'), shortHelp="Mail Item")

if QUICK_LIST:
    tb.AddSeparator()
    tb.AddLabelTool(idSENDTO, "Send to", wxBitmap('bitmaps\\sendto.bmp'), shortHelp="Send to %s"%QUICK_LIST)
    
tb.Realize()
</t>
<t tx="ekr.20050811141217.23">@ignore
@nocolor
@wrap

.. image:: images\toolbar.gif

+------+-----------------------+-----------------------------------------------+
||nl|  | Creates a new List    |``self.OnNewList``                             |                  
+------+-----------------------+-----------------------------------------------+
||ol|  | Open an existing List |``self.OnOpenList``                            |
+------+-----------------------+-----------------------------------------------+
||pt|  | Print                 |``lambda e: self.OnPrint(e,showprtdlg=False))``|
+------+-----------------------+-----------------------------------------------+
||pp|  | Print Preview         |``lambda e: self.OnPrint(e, prev=True))``      |
+------+-----------------------+-----------------------------------------------+
||ps|  | Page Setup            |``self.OnPageSetup``                           |
+------+-----------------------+-----------------------------------------------+
||ni|  | New Item              |``self.OnNewItem``                             |
+------+-----------------------+-----------------------------------------------+
||re|  | Refresh               |``self.OnRefresh``                             |
+------+-----------------------+-----------------------------------------------+
||en|  | Edit Note             |``self.OnEditNote``                            |
+------+-----------------------+-----------------------------------------------+
||fi|  | Find                  |``self.OnFind``                                |
+------+-----------------------+-----------------------------------------------+
||ec|  | Cut                   |``lambda e: self.OnCopyItems(e, cut=True))``   |
+------+-----------------------+-----------------------------------------------+
||ey|  | Copy                  |``self.OnCopyItems``                           |
+------+-----------------------+-----------------------------------------------+
||ep|  | Paste                 |``self.OnPasteItems``                          |
+------+-----------------------+-----------------------------------------------+
||co|  | Toggle Finished       |``self.OnToggleFinished``                      |
+------+-----------------------+-----------------------------------------------+
||de|  | Delete Item           |``self.OnDeleteItems``                         |
+------+-----------------------+-----------------------------------------------+
||dd|  | Set Item Due Date     |``self.OnDueDate``                             |
+------+-----------------------+-----------------------------------------------+
||ow|  | Set Item Owners       |``self.OnEditOwner``                           |
+------+-----------------------+-----------------------------------------------+
||mi|  | Mail Item             |``self.OnMailItem``                            |
+------+-----------------------+-----------------------------------------------+


.. |nl| image:: images\newlist.gif
.. |ol| image:: images\openlist.gif
.. |pt| image:: images\print.gif
.. |pp| image:: images\printprev.gif
.. |ps| image:: images\page_setup.gif
.. |ni| image:: images\new_item.gif
.. |re| image:: images\refresh.gif
.. |en| image:: images\edit_note.gif
.. |fi| image:: images\find.gif
.. |ec| image:: images\editcut.gif
.. |ey| image:: images\editcopy.gif
.. |ep| image:: images\editpaste.gif
.. |co| image:: images\complete.gif
.. |de| image:: images\delete.gif
.. |dd| image:: images\duedate.gif
.. |ow| image:: images\owners.gif
.. |mi| image:: images\mail_item.gif
</t>
<t tx="ekr.20050811141217.24">#File Menu ------------------------------------
EVT_MENU(self, idNEWLIST, self.OnNewList)
EVT_MENU(self, idOPENLIST, self.OnOpenList)
EVT_MENU(self, idCLOSELIST, self.OnCloseList)
EVT_MENU(self, idCLOSEALL, self.OnCloseAll)
EVT_MENU(self, idSAVEAS, self.OnSaveAsText)
EVT_MENU(self, idDELETELIST, self.OnDeleteList)
EVT_MENU(self, idPAGESETUP, self.OnPageSetup)
EVT_MENU(self, idPRINT, self.OnPrint)
EVT_MENU(self, idPRINTPREV, lambda e: self.OnPrint(e, prev=True))
EVT_MENU(self, idOFFLINE, self.OnWorkOffline)
EVT_MENU(self, idMAILLIST, self.OnMailView)      
EVT_MENU_RANGE(self, wxID_FILE1, wxID_FILE9, self.OnFileList)
EVT_MENU(self, idEXIT, self.OnExit)
#Edit Menu ------------------------------------
EVT_MENU(self, idCUT, lambda e: self.OnCopyItems(e, cut=True))        
EVT_MENU(self, idCOPY, self.OnCopyItems)
EVT_MENU(self, idPASTE, self.OnPasteItems)
EVT_MENU(self, idDELETEITEMS, self.OnDeleteItems)
EVT_MENU(self, idCOMBINEITEMS, self.OnCombineItems)
EVT_MENU(self, idFIND, self.OnFind)
#item Menu ------------------------------------
EVT_MENU(self, idNEWITEM, self.OnNewItem)
EVT_MENU(self, idTOGGLEFINISHED, self.OnToggleFinished)             
EVT_MENU(self, idDUEDATE, self.OnDueDate)
EVT_MENU(self, idEDITOWNER, self.OnEditOwner)
EVT_MENU(self, idEDITNOTE, self.OnEditNote)
EVT_MENU(self, idMAILITEM, self.OnMailItem)
#Dips Menu ------------------------------------
EVT_MENU(self, idSHOWFINISHED, self.OnShowFinished)
EVT_MENU(self, idSHOWALL, self.OnShowAll)
EVT_MENU(self, idREFRESH, self.OnRefresh)
EVT_MENU(self, idDISPLAYDATE, self.OnDisplayDateCategory)
#Tool Menu ---------------------------------------
EVT_MENU(self, idTICKLERACTIVE, self.OnActivateTickler)
EVT_MENU(self, idSHOWNEXT, self.OnShowTickler)
EVT_MENU(self, idSYNC, self.OnSync)
EVT_MENU(self, idARCHIVE, self.OnArchive)
EVT_MENU(self, idEVALUATE, self.OnShowEvaluate)
#Help Menu -----------------------------------------
EVT_MENU(self, idABOUT, self.OnShowAbout)
EVT_MENU(self, idHELP, self.OnShowHelp)

EVT_TOOL(self, idTOOLPRINT, lambda e: self.OnPrint(e,showprtdlg=False))

if QUICK_LIST:
    EVT_TOOL(self, idSENDTO, lambda e: self.OnMoveToSpecificList(e,QUICK_LIST))
</t>
<t tx="ekr.20050811141217.25">@ignore
@nocolor
@wrap

(see toolbar table above)

Note about the use of lambda functions in ``EVT`` macros:

    When an event occurs, it sends an event object to the method that the event is connected to through the ``EVT`` macro.  If we want to have several ``EVT`` macros connect to the same method with different arguments then one way to accomplish that is to use a lambda function.  Instead of calling the a method directly with the event object as an argument, the lambda function will be called (with the event object argument) and the action of the lambda function will be to call the method in question with whatever additional arguments are specified.  For example::

        EVT_MENU(self, idPRINTPREV, lambda e: self.OnPrint(e, prev=True))

    The method ``OnPrint`` is the callback for both the Print event and the Print Preview event and by using a lambda function, we can pass an additional argument to the method (in this case setting the additional argument *prev* to True).

Printing by clicking the print icon in the Toolbar |pt| doesn't bring up a dialog it just prints to the default printer and that is why there is a separate ``EVT_TOOL`` macro with an ``idTOOLPRINT`` id::

    EVT_TOOL(self, idTOOLPRINT, lambda e: self.OnPrint(e,showprtdlg=False))</t>
<t tx="ekr.20050811141217.26">upper_panel = wxPanel(self, -1)   #size = (900,400)
bottom_panel = wxPanel(self, -1, size = (900,150)) #900 note that 000 seems to work???

nb = wxNotebook(upper_panel, -1, size=(900,500), style=wxNB_BOTTOM)

f = wxFont(10, wxSWISS, wxNORMAL, wxNORMAL)
self.name = wxTextCtrl(bottom_panel, -1, size = (285,42), style = wxTE_MULTILINE|wxTE_RICH2)#34 #wxTE_PROCESS_ENTER
self.name.SetDefaultStyle(wxTextAttr("BLACK", font = f))
     
self.owners = wxTextCtrl(bottom_panel, -1, size = (250,42),style = wxTE_MULTILINE|wxTE_RICH2)
self.owners.SetDefaultStyle(wxTextAttr("BLACK", font = f))

self.note = wxTextCtrl(bottom_panel, -1, size = (400,50), style=wxTE_MULTILINE)
 </t>
<t tx="ekr.20050811141217.27">@ignore
@nocolor
@wrap

The ``wxFrame`` has two ``wxPanels``:  *upper_panel* will contain the notebook.  The *bottom_panel* will contain the various item textctrls including name, owners and note.

</t>
<t tx="ekr.20050811141217.28">EVT_TEXT(self, self.name.GetId(), lambda e: self.modified.update({'name':1}))
EVT_TEXT(self, self.note.GetId(), lambda e: self.modified.update({'note':1}))
EVT_TEXT(self, self.owners.GetId(), lambda e: self.modified.update({'owners':1}))

EVT_CLOSE(self, self.OnWindowExit)

EVT_IDLE(self, self.OnIdle)

</t>
<t tx="ekr.20050811141217.29">@ignore
@nocolor
@wrap

The ``EVT_TEXT`` event macros indicate whether a particular textctrl has changed.

``EVT_CLOSE(self, self.OnWindowExit)`` is used to record settings and cleanup on exiting

``EVT_IDLE(self, self.OnIdle)`` --&gt; Idle events used for checking text files and transfers from Outlook

There are also a number of events related to the individual ListCtrls that are placed on Notebook pages `&lt;&lt; ListControl Events &gt;&gt;`_.


    
</t>
<t tx="ekr.20050811141217.30">#Appears necessary to really get the listcontrol to size with the overall window  
#upper_panel sizer
sizer = wxBoxSizer(wxHORIZONTAL)
sizer.Add(nb,1,wxALIGN_LEFT|wxEXPAND)
upper_panel.SetSizer(sizer)        

#sizer for the row of data items
box = wxBoxSizer(wxHORIZONTAL)
box.Add(self.name,1,wxEXPAND)
box.Add(self.owners,0)

#bottom_panel sizer  
sizer = wxBoxSizer(wxVERTICAL)        
sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
sizer.Add(self.note,1,wxALIGN_LEFT|wxEXPAND)
bottom_panel.SetSizer(sizer)

sizer = wxBoxSizer(wxVERTICAL)
sizer.Add(upper_panel,1,wxALIGN_TOP|wxEXPAND)
sizer.Add(bottom_panel,0,wxALIGN_TOP|wxEXPAND)

self.SetAutoLayout(1)
self.SetSizer(sizer)
#sizer.Fit(self) #actively does bad things to the dimensions on startup
</t>
<t tx="ekr.20050811141217.31">@ignore
@nocolor
@wrap

.. Not sure I have the strength but will discuss sizers here.  The basis use of sizers is pretty straightforward in my opinion, however, what is wildly hard to remember are the meaning of the parameters in the sizer Add method.

The parent of the ``wxPanel`` object *upper_panel* is the *ListManager*, which is a subclass of ``wxFrame``.  The parent of ``wxNotebook`` object *nb* is *upper_panel*.  Since the only child of *upper_panel* is the *nb* it wasn't obvious to me that a sizer was needed but apparently without it the ``wxListCtrl`` that will be a child of the wxPanel of *nb* won't size right if we don't do it this was.

::

    Frame ---&gt; upper_panel ---&gt; notebook ---&gt; panel (for each page) ---&gt; listctrl
      |                                                             |            } one on each page
      ---&gt; lower_panel ---&gt; variety of textctrls                    ---&gt; listbox</t>
<t tx="ekr.20050811141217.32">self.toolmenu = toolmenu
self.filemenu = filemenu
self.nb = nb
self.tb = tb
</t>
<t tx="ekr.20050811141217.33">@ignore
@nocolor
@wrap

No comments yet.</t>
<t tx="ekr.20050811141217.34">if OUTLOOK:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM) # Create a TCP socket
    s.bind(('localhost',8888)) # Bind to port 8888
    s.listen(5) # Listen, but allow no more than
    self.sock = s
</t>
<t tx="ekr.20050811141217.35">@ignore
@nocolor
@wrap

No comment</t>
<t tx="ekr.20050811141217.36">try:
    pathlist = [f[1] for f in cp.items('Files')]
except:
    pathlist = []
    
if pathlist:
    pathlist.sort()
    pathlist.reverse()
    for path in pathlist[1:]:
        self.OnFileList(path=path)

    #don't want to trigger the page change event until n-1 of n files are loaded
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)

    self.OnFileList(path=pathlist[0])
else:
    EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)



</t>
<t tx="ekr.20050811141217.37">@ignore
@nocolor
@wrap

``pathlist = [f[1] for f in cp.items('Files')]``

This uses the new in 2.3 ``ConfigParser`` method ``items``.  This will not work unless ConfigParser has been constructed without any defaults and so a ConfigParser object is created twice.

The only remotely subtle thing here is that we don't want to execute the ``EVT_NOTEBOOK_PAGE_CHANGED`` statement while we're doing the initial loading of files since it does unnecessary processing.  The statement is executed before the last file is loaded.</t>
<t tx="ekr.20050811141217.38">ID_TIMER = wxNewId()
self.timer = wxTimer(self, ID_TIMER) 
EVT_TIMER(self,  ID_TIMER, self.OnIdle)
self.timer.Start(3000)
</t>
<t tx="ekr.20050811141217.39">@ignore
@nocolor
@wrap

Need to figure out exactly what this timer is doing.</t>
<t tx="ekr.20050811141217.40"></t>
<t tx="ekr.20050811141217.41">@ignore
@nocolor
@wrap

No comment.</t>
<t tx="ekr.20050811141217.42">def createownerlist(self):
    
    if REMOTE_HOST and OFFLINE_ONLY is False:
        cursor = self.GetCursor(REMOTE_HOST)
        sql = "SHOW TABLES" #sorted
    else:
        cursor = self.GetCursor(LOCAL_HOST)
        sql = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
        
    cursor.execute(sql)
    results = cursor.fetchall()

    #excluding 'system' tables and archive tables
    excluded_tables = ['user_sync','sync','owners']
    tables = [t for (t,) in results if t.find('_archive')== -1 and t not in excluded_tables]

    sql_list = []
    for table in tables:
        sql_list.append("""SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s"""%((table,)*3))
                
    sql = " UNION ".join(sql_list)
    cursor.execute(sql)
    results = cursor.fetchall()
    
    _list = [x[0] for x in results]
    if '' in _list:
        _list.remove('')
    if None in _list:
        _list.remove(None)
        
    self._list = _list
    
    #posting custom event to signal that this thread is done
    evt = wxPyEvent()
    evt_id = wxNewEventType()
    evt.SetEventType(evt_id)
    self.Connect(-1, -1, evt_id, self.createownerdialog)
    wxPostEvent(self, evt)

</t>
<t tx="ekr.20050811141217.43">@ignore
@nocolor
@wrap

This method grabs the owners from many of the tables to create a list of possile owners for each item.  The alternative is actually to create a separate owner table but it seemed to make sense to just construct the owners on the fly from the various List databases.  This is done in a thread so no matter how long it takes to construct the owners it doesn't slow the appearance of the GUI.  The result of this method is the contruction of the instance variable *self._list*.

The most interesting thing here is creating a custom event (without needing to create an event macro) to signal that this thread is done::
    
    evt = wxPyEvent()
    evt_id = wxNewEventType()
    evt.SetEventType(evt_id)
    self.Connect(-1, -1, evt_id, self.createownerdialog)
    wxPostEvent(self, evt)

The code above is adapted from the more general ``wxCallAfter``, which I could have used but just wanted to explicitly show the steps involved in creating a custom event, associating it with a callback and posting it.   

The general point is that if you want to notify the main GUI thread of something going on in a non-GUI thread, posting events is an easy way to do it whether you use the code above, the more complete wxCallAfter (see below) from which it was derived or actually create your own custom event macro (farther below).

The code for ``wxCallAfter`` is::

    def wxCallAfter(callable, *args, **kw):
         """
         Call the specified function after the current and pending event
         handlers have been completed.  This is also good for making GUI
         method calls from non-GUI threads.
         """
         app = wxGetApp()
         assert app, 'No wxApp created yet'
    
         global _wxCallAfterId
         if _wxCallAfterId is None:
             _wxCallAfterId = wxNewEventType()
             app.Connect(-1, -1, _wxCallAfterId,
                   lambda event: event.callable(*event.args, **event.kw) )
         evt = wxPyEvent()
         evt.SetEventType(_wxCallAfterId)
         evt.callable = callable
         evt.args = args
         evt.kw = kw
         wxPostEvent(app, evt)

Unless you want multiple handlers to be able to respond to a custom event (by using evt.Skip()) or just want custom event macros that are like native event macros there doesn't seem to be much need to create full-blown custom events.  If you do need to, here is how it is done::

    wxEVT_THREAD_DONE = wxNewEventType()
    
    def EVT_THREAD_DONE(win, func):
        win.Connect(-1, -1, wxEVT_THREAD_DONE, func)
        
    class ThreadDoneEvent(wxPyEvent):
        def __init__(self):
            wxPyEvent.__init__(self)
            self.SetEventType(wxEVT_THREAD_DONE)
            
When you want to post the custom event, you do the following::
    
    evt = ThreadDoneEvent() 
    wxPostEvent(win, evt)</t>
<t tx="ekr.20050811141217.44">def createownerdialog(self, evt=None):
    self.ModifierDialog = ModifierDialog(parent=self, title="Select owner(s)", size=(180,300), style=wxCAPTION, modifierlist = self._list)
    del self._list

</t>
<t tx="ekr.20050811141217.45">@ignore
@nocolor
@wrap

When the thread is done that creates the owner list it posts an event whose callback is this method.  This method uses *self._list* that was generated by the ``createownerlist`` method.  As an alternative, we could probably pass the list as an attribute of the event that is generated in the thread.</t>
<t tx="ekr.20050811141217.46"></t>
<t tx="ekr.20050811141217.47">@ignore
@nocolor
@wrap

The main method here is the one that constructs a new Notebook page by creating a new ListCtrl and new OwnerListBox and populating them.  The second method does what is needed when an existing notebook page is selected.

</t>
<t tx="ekr.20050811141217.48">def CreateNewNotebookPage(self, host, table):
    
    Properties = {'owner':'*ALL',
                'LCdate':'duedate',
                'sort':{'attribute':'priority','direction':0}, #these could be set in Config
                'showfinished':0} #-1 show them all; 0 show none; integer show for that many days
    
    Properties['table'] = table
    Properties['host'] = host
                
    self.PropertyDicts.append(Properties)

    self.L = len(self.ItemLists)#could use self.ListCtrls, self.OwnerLBoxes, etc. with a -1
    
    results = self.ReadFromDB()
    if results is None:
        self.PropertyDicts = self.PropertyDicts[:-1]
        self.L = self.L - 1
        return
        
    panel = wxPanel(self.nb, -1, size = (900,400))
    LCtrl = ListCtrl(panel, -1, style=wxLC_REPORT|wxSUNKEN_BORDER|wxLC_VRULES|wxLC_HRULES)
    LCtrl.SetFont(self.LC_font)
    self.ListCtrls.append(LCtrl)
    
    OLBox = wxListBox(panel, -1, size = (126,550), choices = [""], style=wxLB_SORT|wxSUNKEN_BORDER)
    self.OwnerLBoxes.append(OLBox)
    
    sizer = wxBoxSizer(wxHORIZONTAL)
    sizer.Add(OLBox,0,wxALIGN_LEFT|wxEXPAND)
    sizer.Add(LCtrl,1,wxALIGN_LEFT|wxEXPAND)
    panel.SetSizer(sizer)
        
    self.ItemLists.append(self.CreateAndDisplayList(results)) 

    &lt;&lt; Fill OwnerListBox &gt;&gt;
    &lt;&lt; ListControl Events &gt;&gt;
    
    #img_num = LCtrl.arrows[Properties['sort']['direction']]
    #LCtrl.SetColumnImage(self.attr2col_num[Properties['sort']['attribute']], img_num)
    
    rdbms = host.split(':')[1]
    if rdbms == 'mysql':
        tab_title = '%s (remote)'%table
    else:
        tab_title = table
    
    if table in SYNC_TABLES:
        tab_title = '*'+tab_title
                             
    self.nb.AddPage(panel,tab_title)
    self.nb.SetSelection(self.L)
    
    self.filehistory.AddFileToHistory('%s:%s'%(host,table))

    self.SetStatusText("Successfully loaded %s"%tab_title)
    
</t>
<t tx="ekr.20050811141217.49">@ignore
@nocolor
@wrap

This method creates the ListCtrl and ListBox that appears on every notebook page.

Each list has a properties dictionary associated with it.

+--------------+----------------------------------------------------------------------------------------------------+
|'owner'       |The owner that is filtering the display or '\*ALL'                                                  |
+--------------+----------------------------------------------------------------------------------------------------+
|'LCdate'      |Date that is displayed by the ListCtrl; values: 'duedate', 'createdate', 'timestamp', 'finisheddate'|
+--------------+----------------------------------------------------------------------------------------------------+
|'sort'        |Value is a dictionary of the form {'attribute':'priority','direction':0}                            |
+--------------+----------------------------------------------------------------------------------------------------+
|'showfinished'|Values: -1 show them all; 0 show none; integer show for that many days                              |
+--------------+----------------------------------------------------------------------------------------------------+
|'table'       |The table that holds the List                                                                       |
+--------------+----------------------------------------------------------------------------------------------------+
|'host'        |The form for this is 'nycpsszatzsql:mysql' or 'wxLMDB:sqlite'                                       |
+--------------+----------------------------------------------------------------------------------------------------+

</t>
<t tx="ekr.20050811141217.50">cursor = self.GetCursor(host)
if cursor is None:
    print "Couldn't get cursor to fill OwnerListBox"
    return
    
cursor.execute("SELECT owner1 FROM %s UNION SELECT owner2 FROM %s UNION SELECT owner3 FROM %s"%((table,)*3))

owners = [x for (x,) in cursor.fetchall()]

if None in owners:
    owners.remove(None)
if '' in owners:
    owners.remove('')

OLBox.Clear()
for name in owners: 
    OLBox.Append(name)
OLBox.Append('*ALL')
OLBox.SetSelection(0)

</t>
<t tx="ekr.20050811141217.51">@ignore
@nocolor
@wrap

The list is sorted by the ListBox control.

mysql doesn't like '%s' while sqlite is fine with '%s' for table names.

If you don't do ``OLBox.Clear()`` then you get a blank line in the list that must be from initiating it with "".

Relying on the fact that '\*All' should be first alphabetically, which is dumb so should change it.</t>
<t tx="ekr.20050811141217.52">LCId = LCtrl.GetId()
EVT_LIST_ITEM_SELECTED(self, LCId, self.OnItemSelected)
EVT_LIST_ITEM_ACTIVATED(self, LCId, self.OnDisplayInPlaceEditor)
EVT_LEFT_DOWN(LCtrl, self.OnLeftDown) 
EVT_LEFT_DCLICK(LCtrl, self.OnLeftDown)
EVT_RIGHT_DOWN(LCtrl, self.OnRightDown)
EVT_LIST_COL_CLICK(self, LCId, self.OnColumnClick)
EVT_LIST_COL_RIGHT_CLICK(self, LCId, self.OnColumnRightClick)

# the following is a ListBox event
EVT_LISTBOX(self, OLBox.GetId(), self.OnFilterOwners)

</t>
<t tx="ekr.20050811141217.53">@ignore
@nocolor
@wrap

It would seem that the two mouse events:  ``EVT_LEFT_DOWN(LCtrl, self.OnLeftDown)`` and ``EVT_LEFT_DCLICK(LCtrl, self.OnLeftDown)`` could be owned by the ListManager object and not each ListCtrl object, but when I tried this, the mouse events were not detected. I did not investigate this for long so maybe I was just screwing things up or perhaps a ``wxFrame`` cannot detect a mousedown event (does that make sense?).  In any event (no pun intended), it is certainly not a big deal to create these mousedown events for each ListCtrl.

Each ListBox object has one event associated with it that occurs, not surprisingly, when a name in the control is selected.  The callback, *self.OnFilterOwners*, causes the ListCtrl to display only the items of the selected owner.</t>
<t tx="ekr.20050811141217.54">def OnPageChange(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    self.L = L = self.nb.GetSelection()

    &lt;&lt; Find Highlighted Row &gt;&gt;
    &lt;&lt; Update Title &gt;&gt;
    
    evt.Skip() #051403
    
</t>
<t tx="ekr.20050811141217.55">@ignore
@nocolor
@wrap



Call-back for the ``EVT_NOTEBOOK_PAGE_CHANGED(self,nb.GetId(),self.OnPageChange)`` event.

self.modified is the dictionary that indicates which textctrls have data that has changed.

.. note::

    Not sure whether event.Skip() is needed or not.</t>
<t tx="ekr.20050811141217.56">idx = self.ListCtrls[L].GetNextItem(-1, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
if idx != -1:
    self.curIdx = idx
    #LCtrl.EnsureVisible(idx)
    self.OnItemSelected()
elif self.ItemLists[L]:
    self.curIdx = 0
    self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    #the line above triggers an OnItemSelected EVT so don't need self.OnItemSelected() 092803
else:
    self.curIdx = -1

</t>
<t tx="ekr.20050811141217.57">@ignore
@nocolor
@wrap

</t>
<t tx="ekr.20050811141217.58">location,rdbms = self.PropertyDicts[L]['host'].split(':')
table = self.PropertyDicts[L]['table']
self.SetTitle("List Manager:  %s:  %s:  %s"%(location,rdbms,table))

</t>
<t tx="ekr.20050811141217.59">@ignore
@nocolor
@wrap

</t>
<t tx="ekr.20050811141217.60"></t>
<t tx="ekr.20050811141217.61">def OnShowTickler(self, evt=None):
    if self.popupvisible:
        return
    
    self.popupvisible = True
    
    host = 'wxLMDB:sqlite'
    cursor = self.Cursors[host]
    table = 'follow_ups'

    sql = "SELECT COUNT() FROM "+table+" WHERE finisheddate IS NULL AND priority &gt; 1"
    cursor.execute(sql)
    results = cursor.fetchone()

    num_items = int(results[0])
    
    if not num_items:
        return

    if self.modified: #Should decide if this should be put back or not
        self.OnUpdate()
        
    n = random.randint(0,num_items-1)

    sql = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM "+table+" WHERE finisheddate IS NULL AND priority &gt; 1 LIMIT 1 OFFSET %d"%n
    
    try:
        cursor.execute(sql)
    except:
        print "In OnShowTickler and attempt to Select an item failed"
        return
        
    row = cursor.fetchone()
    
    class Item: pass
    item = Item()

    item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
    item.name = row[1]
    item.createdate = row[2]
    item.finisheddate = row[3]
    item.duedate = row[4]
    item.owners = [z for z in row[5:7] if z is not None] #if you carry around ['tom',None,None] you have an issue when you go write it
    item.id = row[8]
    item.timestamp = row[9]
    item.note = row[10]

    dlg = TicklerDialog(self, "", "Do something about this!!!", size=(550,350))
    TC = dlg.TC
    
    f = wxFont(14, wxSWISS, wxITALIC, wxBOLD, False)
    TC.SetDefaultStyle(wxTextAttr("BLUE",wxNullColour, f))
    TC.AppendText("%s..."%item.name)

    if item.priority == 3:
        TC.SetDefaultStyle(wxTextAttr("RED","YELLOW",f))
    TC.AppendText("%d\n\n"%item.priority)
    
    f = wxFont(8, wxSWISS, wxNORMAL, wxNORMAL)
    TC.SetDefaultStyle(wxTextAttr("BLACK","WHITE", f))
    TC.AppendText("owners: %s\n"%", ".join(item.owners))
    TC.AppendText("created on: %s\n"%item.createdate.Format('%m/%d/%y'))
    if item.duedate:
        ddate = item.duedate.Format('%m/%d/%y')
    else:
        ddate = "&lt;no due date&gt;"
    TC.AppendText("due on: %s\n\n"%ddate)

    note = item.note
    if not note:
        note = "&lt;no note&gt;"
    TC.AppendText("%s\n\n"%note)
    f = wxFont(10, wxSWISS, wxITALIC, wxBOLD)
    TC.SetDefaultStyle(wxTextAttr("BLACK",wxNullColour, f))
    TC.AppendText('follow_ups')
    TC.ShowPosition(0)   #did not do anything
    TC.SetInsertionPoint(0)
    result = dlg.ShowModal()
    dlg.Destroy()
    self.popupvisible = False     

    if result in (wxID_OK, wxID_APPLY):

        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table:
                break
        else:
            print "Can't find %s"%table
            return
                    
        self.nb.SetSelection(L) #if the page changes it sends a EVT_NOTEBOOK_PAGE_CHANGED, which calls OnPageChange
        self.L = L
        self.FindNode(item)
        if result==wxID_APPLY:
            self.OnMailItem(item)

    elif result==wxID_FORWARD:
        self.OnShowTickler()

</t>
<t tx="ekr.20050811141217.62">def OnActivateTickler(self, evt):
    self.tickler_active = not self.tickler_active
    self.toolmenu.Enable(idSHOWNEXT,self.tickler_active)

    
</t>
<t tx="ekr.20050811141217.63"></t>
<t tx="ekr.20050811141217.64">def OnMailItem(self, evt=None, item=None):
    if item is None:
        if self.curIdx == -1:
            return
        else:
            item = self.ItemLists[self.L][self.curIdx]
        
    dlg = MailDialog(self,"Mail a reminder", size=(450,500),
               recipients=item.owners,    
               subject=item.name,
               body=self.GetNote())          
    result = dlg.ShowModal()
    if result==wxID_OK:
        outlook= Dispatch("Outlook.Application")
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = to = dlg.RTC.GetValue()
        newMsg.Subject = subject = dlg.STC.GetValue()
        newMsg.Body = body = dlg.BTC.GetValue()

        #newMsg.FlagStatus = constants.olFlagMarked
        
        newMsg.Display()

        dlg.Destroy()            
        #del outlook

        self.note.SetSelection(0,0)
        self.note.WriteText("**************************************************\n")
        self.note.WriteText("Email sent on %s\n"%mx.DateTime.today().Format("%m/%d/%y"))
        self.note.WriteText("To: %s\n"%to)
        self.note.WriteText("Subject: %s\n"%subject)
        self.note.WriteText("%s\n"%body)
        self.note.WriteText("**************************************************\n")

</t>
<t tx="ekr.20050811141217.65">def OnMailView(self, evt=None):
    recipients = [self.PropertyDicts[self.L]['owner']]
    
    body = ""
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+"%d. %s (%d)\n"%(i+1, item.name, item.priority)
    
    subject = "Follow-ups " + mx.DateTime.today().Format("%m/%d/%y")
            
    dlg = MailDialog(self,"Follow-up List", size=(450,500),
               recipients=recipients,
               subject=subject,
               body=body)
               
    val = dlg.ShowModal()
    dlg.Destroy()
    if val==wxID_OK:
        outlook= Dispatch("Outlook.Application")
        newMsg = outlook.CreateItem(olMailItem) #outlook.CreateItem(constants.olMailItem)
        newMsg.To = dlg.RTC.GetValue()
        newMsg.Subject = dlg.STC.GetValue()
        newMsg.Body = dlg.BTC.GetValue()

        newMsg.FlagStatus = olFlagMarked #constants.olFlagMarked
        newMsg.Categories = "Follow-up"
        
        newMsg.Display()
    
        #del outlook

</t>
<t tx="ekr.20050811141217.66"></t>
<t tx="ekr.20050811141217.67">def OnCopyItems(self, event=None, cut=False):
    if self.curIdx == -1:
        return
        
    L = self.L
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]
    
    &lt;&lt; Find Highlighted Items &gt;&gt;
    
    self.SetStatusText("%d items copied"%len(copyitems))
    if cut:
        self.OnDeleteItems()

</t>
<t tx="ekr.20050811141217.68">copyitems = []
i = -1
while 1:
    i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
    if i==-1:
        break
    item = IList[i]
    item.notes = self.GetNote(L,item) #handles the database situation
    copyitems.append(item)

self.copyitems = copyitems</t>
<t tx="ekr.20050811141217.69">def OnPasteItems(self, evt=None, L=None): #noselect 051603
    #used by OnMoveToList, OnMoveToSpecificList and called directly
    if not self.copyitems:
        print "Nothing was selected to be copied"
        return
        
    if L is None: #this is not needed by OnMoveTo or OnDragToTab but is for a straight call
        L = self.L
        
    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    
    items = self.copyitems
    numitems = len(items)
    
    for item in items:

        z = item.owners+[None,None,None]

        id = self.GetUID() #we do give it a new id
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        createdate = mx.DateTime.now() #need this or else it won't be seen as a new item when synching; would be seen as updated
        command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
        cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
        
        timestamp = self.TimeStamper(host, cursor, table, id)
        
        #creating a new item breaks the connection between item.x and new_item.x
        class Item: pass
        new_item = Item()
        new_item.id = id
        new_item.priority = item.priority
        new_item.owners = item.owners
        new_item.name = item.name
        new_item.timestamp = timestamp
        new_item.duedate =item.duedate
        new_item.finisheddate = item.finisheddate
        new_item.createdate = createdate
        IList.insert(0,new_item)
        
    self.DisplayList(IList,L)
    
    #If we didn't come from OnMoveToList or OnMoveToSpecificList where L != self.L
    if L==self.L:
        for i in range(numitems):
            LCtrl.SetItemState(i, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = numitems-1



</t>
<t tx="ekr.20050811141217.70">def OnDeleteItems(self, event=None):
    """Called directly and by OnCopyItems (cut = true)
    """
    if self.curIdx == -1: #not absolutely necessary but gets you out quickly
        return
        
    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]
    
    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        item = IList.pop(i)
        LCtrl.DeleteItem(i)

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        cursor.execute("DELETE from "+table+" WHERE id = %s", (item.id,))
            
        #Track Deletes for Syncing ############################################
        if table in SYNC_TABLES:
            if host.split(':')[1] == 'sqlite':
                timestamp = mx.DateTime.now()
                cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,item.name,timestamp))
            else:
                cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,USER,item.name))
        #########################################################################
        i-=1

    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does cause self.modified --&gt;{'name':1}
    self.modified = {}
    self.curIdx = -1

</t>
<t tx="ekr.20050811141217.71"></t>
<t tx="ekr.20050811141217.72">def OnLeftDown(self, evt):
    print "Here"
    if self.modified:
        #if inplace editor is open and you click anywhere (same or different row from current row) but in the editor itself then just to close editor
        flag = self.modified.has_key('inplace')
        self.OnUpdate()
        if flag:
            evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row
            return
    
    x,y = evt.GetPosition()
    LCtrl = self.ListCtrls[self.L]
    
    #Using HitTest to obtain row clicked on because there was a noticable delay in the generation of an
    #EVT_LIST_ITEM_SELECTED event when you click on the already selected row
    idx,flags = LCtrl.HitTest((x,y))
    
    #if you are below rows of items then idx = -1 which could match self.curIdx = -1
    if idx == -1:
        return
    
    # only if you click on the currently selected row do the following events occur
    if idx == self.curIdx:
        if x &lt; 18:
            self.OnToggleFinished()
        elif x &lt; 33:
            self.OnPriority()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1):
            self.OnDisplayInPlaceEditor()
        elif x &lt; 33 + LCtrl.GetColumnWidth(1) + LCtrl.GetColumnWidth(2): 
            self.OnEditOwner()
        else:
            self.OnDueDate
    else:
        evt.Skip() #without Skip, EVT_LIST_ITEM_SELECTED is not generated if you click in a new row



</t>
<t tx="ekr.20050811141217.73">def OnRightDown(self, evt):
    x,y = evt.GetPosition()
    
    sendtomenu = wxMenu()
    
    open_tables = []
    for page,Properties in enumerate(self.PropertyDicts):
        host,table = Properties['host'],Properties['table']
        open_tables.append((host,table))
        sendtomenu.Append(1+page,"%s (%s)"%(table,host))
        EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))
        
    sendtomenu.Delete(self.L+1) # don't send it to the page you're already on
    sendtomenu.AppendSeparator()
    
    self.closed_tables = []
    for host,cursor in self.Cursors.items():

        location, rdbms = host.split(':')

        if rdbms == 'sqlite':
            cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
        elif rdbms == 'mysql':
            cursor.execute("SHOW tables")

        results = cursor.fetchall()
        
        page+=1
        for (table,) in results:
            if not ((host,table) in open_tables or table in ['user_sync','owners','sync']):
                self.closed_tables.append((host,table))
                sendtomenu.Append(1+page,"%s (%s)"%('*'+table,host))
                EVT_MENU(self, 1+page, lambda e,p=page: self.OnMoveToList(e,p))
                page+=1

    self.PopupMenu(sendtomenu,(x+125,y+40))
    sendtomenu.Destroy()

</t>
<t tx="ekr.20050811141217.74"></t>
<t tx="ekr.20050811141217.75">def OnCombineItems(self, evt):
    L = self.L
    idx = self.curIdx
    IList = self.ItemLists[L]
    LCtrl = self.ListCtrls[L]
    
    combine_list = []
    i = -1
    while 1:
        i = LCtrl.GetNextItem(i, wxLIST_NEXT_ALL, wxLIST_STATE_SELECTED)
        if i==-1:
            break
        combine_list.append((IList[i].createdate,IList[i]))

    
    if len(combine_list) &lt; 2:
        print "Fewer than two items highlighted"
        return
    
    combine_list.sort()
    combine_list.reverse()
    
    dlg = wxMessageDialog(self,
                        "Combine the %d selected items?"%len(combine_list),
                        "Combine Items?",
                        wxICON_QUESTION|wxYES_NO)
                        
    if dlg.ShowModal() == wxID_YES:
        Properties = self.PropertyDicts[L]
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        t_item = combine_list[0][1]
        merge_list = combine_list[1:]
        new_note = ""
        
        for date,item in merge_list:
            note = self.GetNote(item=item)
            date = date.Format("%m/%d/%y")
            new_note = "%s\n%s %s\n\n%s"%(new_note, date, item.name, note)
            
            cursor.execute("DELETE from "+table+" WHERE id = %s", (item.id,))
            #Track Deletes for Syncing ############################################
            if table in SYNC_TABLES:
                if host.split(':')[1] == 'sqlite':
                    timestamp = mx.DateTime.now()
                    cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,item.name,timestamp))
                else:
                    cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(item.id,'d',table,USER,item.name))
            #########################################################################
                
        t_note = self.GetNote(item=t_item)
        t_note = "%s\n%s"%(t_note,new_note)
        
        #What about combining owners?######################################
        
        cursor.execute("UPDATE "+table+" SET name = %s, note = %s WHERE id = %s", (t_item.name+"*",t_note,t_item.id))
        t_item.timestamp = self.TimeStamper(host, cursor, table, t_item.id)
        
        self.OnRefresh()
        LCtrl.SetItemState(0, 0, wxLIST_STATE_SELECTED)
        IList = self.ItemLists[L]
        id = t_item.id
        idx = -1
        for item in IList:
            idx+=1
            if id == item.id:
                break
        else:
            idx = -1 
    
        #should never be -1
        if idx != -1:	
            LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
            LCtrl.EnsureVisible(idx)
        self.curIdx = idx
        
    dlg.Destroy()

</t>
<t tx="ekr.20050811141217.76">def OnMoveToList(self, evt=None, page=0):
    self.OnCopyItems(cut=True)
    pc = self.nb.GetPageCount()
    if page &lt; pc:		
        self.OnPasteItems(L=page)
    else:
        host,table = self.closed_tables[page-pc]
        cursor = self.Cursors[host]# in ini self.Cursors[host]
    
        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id
            
            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)
            
    self.copyitems = []
    
</t>
<t tx="ekr.20050811141217.77">def OnMoveToSpecificList(self, evt=None, table='follow_ups'):
    matches = {}
    for page,Properties in enumerate(self.PropertyDicts):
        host,tble = Properties['host'],Properties['table']
        if tble == table:
            rdbms = host.split(':')[1]
            matches[rdbms] = page
        
    self.OnCopyItems(cut=True)
    
    if matches:
        if matches.get('mysql'):	
            self.OnPasteItems(L=matches['mysql'])
        else:
            self.OnPasteItems(L=matches['sqlite'])
    else:
        cursor = self.Cursors[LOCAL_HOST]
    
        for item in self.copyitems:
            z = item.owners+[None,None,None]
            id = self.GetUID() #give it a new id
            
            #need this or else it won't be seen as a new item when syncing; would be seen as updated
            createdate = mx.DateTime.now() 
            command = "INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,note,owner1,owner2,owner3,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)"
            cursor.execute(command,(item.priority,item.name,createdate,item.finisheddate,item.duedate,item.notes,z[0],z[1],z[2],id))
            timestamp = self.TimeStamper(host, cursor, table, id)
            
    self.copyitems = []

            

</t>
<t tx="ekr.20050811141217.78"></t>
<t tx="ekr.20050811141217.79">def OnToggleFinished(self, evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx

    item = self.ItemLists[L][idx]
    LC_Item = LCtrl.GetItem(idx)
    
    if not item.finisheddate:
        item.finisheddate = mx.DateTime.today()
        LC_Item.SetImage(LCtrl.idx0)
    else:
        item.finisheddate = None
        LC_Item.SetImage(LCtrl.idx1)
    
    &lt;&lt; draw item &gt;&gt;

    self.tb.EnableTool(30, True)
    
    host = Properties['host']	
    cursor = self.Cursors[host]
    table = Properties['table']
    
    cursor.execute("UPDATE "+table+" SET finisheddate = %s WHERE id = %s", (item.finisheddate, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    elif Properties['LCdate'] == 'finisheddate':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.finisheddate.Format('%m/%d/%y'))



</t>
<t tx="ekr.20050811141217.80">if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)
    
elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)
    
elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight
    
LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20050811141217.81">def OnPriority(self, event=None, input=None):
    L = self.L
    idx = self.curIdx
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]
    
    if input:
        item.priority=input

    else:
        if item.priority &lt; 3:
            item.priority+= 1
        else:
            item.priority=1

    LC_Item = LCtrl.GetItem(idx)

    &lt;&lt; draw item &gt;&gt;

    text = str(item.priority)        
    LCtrl.SetStringItem(idx, 0, text)

    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    
    cursor.execute("UPDATE "+table+" SET priority = %s WHERE id = %s", (item.priority,item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))
        
    wxCallAfter(LCtrl.SetFocus)
    
</t>
<t tx="ekr.20050811141217.82">if item.finisheddate:
    #It appears that SetTextColour resets font weight to Normal but this makes no sense
    #This means that all finished items have Normal weight whether they are priority 3,2 or 1
    #May actually be that GetItem() and then SetItem() sets the weight to Normal no matter what it was originally
    LC_Item.SetTextColour(wxLIGHT_GREY)
    
elif item.priority==1:
    #see note above about SetTextColour apparently resetting weight
    LC_Item.SetTextColour(wxBLACK)
    
elif item.priority==2:
    #LC_Item.SetTextColour(wxBLACK) -- this line should be necessary but it does not appear to be
    # ? font is black so ? if have to reset it
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight

else:
    LC_Item.SetTextColour(wxRED) #appears to be the only way to set color - can't through font
    f = self.LC_font #LCtrl.font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) # resetting font weight
    
LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20050811141217.83"></t>
<t tx="ekr.20050811141217.84">def OnDisplayInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]
    
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
        
    #if self.Conflict(host, cursor, table, item): return #works -- may be overkill so i've commented it out
    
    TCid = wxNewId()
    y = LCtrl.GetItemPosition(idx)[1] 
    length = LCtrl.GetColumnWidth(1)

    editor = wxTextCtrl(self, TCid, pos = (167,y+28), size = (length,23), style=wxTE_PROCESS_ENTER)
    editor.SetFont(wxFont(9, wxSWISS, wxNORMAL, wxNORMAL))
    editor.SetBackgroundColour(wxColour(red=255,green=255,blue=175)) #Yellow
    editor.AppendText(item.name)
    editor.Show(True)
    editor.Raise()
    editor.SetSelection(-1,-1)
    editor.SetFocus()	
    
    EVT_TEXT_ENTER(self, TCid, self.OnCloseInPlaceEditor)		

    self.in_place_editor = editor
    self.modified['inplace'] = 1	





</t>
<t tx="ekr.20050811141217.85">def OnCloseInPlaceEditor(self,evt=None):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    idx = self.curIdx
    item = self.ItemLists[L][idx]
    
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    LCdate = Properties['LCdate']
    
    #if self.Conflict(host, cursor, table, item)...

    text = self.in_place_editor.GetValue().strip()[:150]
    item.name = text
    LCtrl.SetStringItem(idx, self.attr2col_num['name'], text)
    self.in_place_editor.Destroy()
    
    cursor.execute("UPDATE "+table+" SET name = %s WHERE id = %s", (text, item.id))
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format('%m/%d %H:%M:%S'))

    self.name.Clear()
    self.name.AppendText(text) #this will cause self.modified['name'] = 1, which is dealt with below
    
    #using default in case for some reason self.modified does not have the keys
    self.modified.pop('inplace', None)
    self.modified.pop('name', None)
        
    wxCallAfter(LCtrl.SetFocus) #sets focus on LCtrl and current selection to be highlighted



</t>
<t tx="ekr.20050811141217.86">def OnDueDate(self, evt=None):
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    item = self.ItemLists[L][idx]
    LCtrl = self.ListCtrls[L]

    if item.duedate:
        date = wxDateTime()
        date.SetTimeT(item.duedate) #I am surprised it takes a mx.DateTime object; supposed to need ticks
    else:
        date = 0
    dlg = CalendarDialog(parent=self,
                 title="Select a date",
                 size=(400,400),
                 style=wxCAPTION,
                 date = date)
    if dlg.ShowModal()==wxID_OK:
        date = dlg.cal.GetDate() # this is some date object
        #date = date.GetTicks()
        item.duedate = mx.DateTime.DateFromTicks(date.GetTicks())

        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']
        
        cursor.execute("UPDATE "+table+" SET duedate = %s WHERE id = %s", (item.duedate,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
        elif Properties['LCdate'] == 'duedate':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.duedate.Format('%m/%d/%y'))
    dlg.cal.Destroy()
    dlg.Destroy()
    
</t>
<t tx="ekr.20050811141217.87">def OnEditOwner(self, evt=None): #, new=False) removed Aug. 31 for simplicity
    idx = self.curIdx
    if idx == -1:
        return
    L = self.L
    Properties = self.PropertyDicts[L]
    LCtrl = self.ListCtrls[L]
    item = self.ItemLists[L][idx]
    if not self.ModifierDialog:
        print "self.ModifierDialog is still being constructed"
        return
    #need to clear the current selections or you'll just be making more and more selections
    self.ModifierDialog.SelectCurrent(item.owners)
    self.ModifierDialog.tc.Clear()
    self.ModifierDialog.CenterOnParent()
    
    val = self.ModifierDialog.ShowModal()

    if val == wxID_OK:
        item.owners, new_names = self.ModifierDialog.GetUserInput()
        
        &lt;&lt; Common Owner Code &gt;&gt;

        for owner in item.owners:
            if self.OwnerLBoxes[L].FindString(owner) == -1:
                self.OwnerLBoxes[L].Append(owner)

        for owner in new_names:
            self.ModifierDialog.lb.Append(owner)
        
        host = Properties['host']
        cursor = self.Cursors[host]
        table = Properties['table']

        cursor.execute("UPDATE "+table+" SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s", (z[0],z[1],z[2],item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))

        if 'owners' in self.modified:
            del self.modified['owners']
            
    wxCallAfter(LCtrl.SetFocus)
    
</t>
<t tx="ekr.20050811141217.88">owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)
        
z = item.owners+[None,None,None] #note that + creates a new list
</t>
<t tx="ekr.20050811141217.89">def OnUpdate(self, evt=None):
    if 'inplace' in self.modified:
        self.OnCloseInPlaceEditor()
        if not self.modified:
            return

    L = self.L
    LCtrl = self.ListCtrls[L]
    IList = self.ItemLists[L]
    Properties = self.PropertyDicts[L]
    OLBox = self.OwnerLBoxes[L]
    idx = self.curIdx

    # there is some chance that it is never true that idx == -1 and then this could be eliminated
    if idx != -1:
        item = IList[idx]
    else:
        msg = wxMessageDialog(self, "There is no selected item to update", "", wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        self.modified = {}
        return
        
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    
    if 'name' in self.modified:
        item.name = self.name.GetValue().strip()[:150]
        LCtrl.SetStringItem(idx, self.attr2col_num['name'], item.name)
        cursor.execute("UPDATE "+table+" SET name =%s WHERE id = %s",(item.name,item.id))
        
    if 'note' in self.modified:
        note = self.note.GetValue() #a blank note starts out as None but after this it becomes '' -- ??
        cursor.execute("UPDATE "+table+" SET note =%s WHERE id = %s",(note,item.id))
        
    if 'owners' in self.modified:
        owner_str = self.owners.GetValue().strip()
        item.owners = []
        if owner_str:
            owner_list = [x.strip() for x in owner_str.split(';')]
            for owner in owner_list:
                owner = ", ".join([x.strip().title() for x in owner.split(',')])
                item.owners.append(owner)
            
        &lt;&lt; Common Owner Code &gt;&gt;

        cursor.execute("UPDATE "+table+" SET owner1 = %s, owner2 = %s, owner3 = %s WHERE id = %s", (z[0],z[1],z[2],item.id))
        
        for owner in item.owners:
            if self.ModifierDialog.lb.FindString(owner) == -1:
                self.ModifierDialog.lb.Append(owner)
                OLBox.Append(owner)
            elif OLBox.FindString(owner) == -1:
                OLBox.Append(owner)		
                
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(idx, 3, item.timestamp.Format("%m/%d %H:%M:%S"))
    
    self.modified = {}
    
    
</t>
<t tx="ekr.20050811141217.90">owner_str = '; '.join(item.owners)
LCtrl.SetStringItem(idx, self.attr2col_num['owners'], owner_str)
self.owners.Clear()
self.owners.AppendText(owner_str)
        
z = item.owners+[None,None,None] #note that + creates a new list
</t>
<t tx="ekr.20050811141217.91">def OnNewItem(self, evt=None):
    L=self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    
    if self.curIdx != -1:
        LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)
    
    &lt;&lt; Clear data fields &gt;&gt;
    
    class Item: pass
    item = Item()
    item.name = '&lt;New Item&gt;'
    item.priority = 1
    item.owners = []
    item.createdate = mx.DateTime.now() #need this to be a timestamp and not just date for syncing
    item.duedate = item.finisheddate = None

    self.ItemLists[L].insert(0,item)
    
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    item.id = self.GetUID()
    
    cursor.execute("INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,id) VALUES (%s,%s,%s,%s,%s,%s)",
                (item.priority,item.name,item.createdate,None,None,item.id))
        
    item.timestamp = self.TimeStamper(host, cursor, table, item.id)
    
    #tracking new item for syncing will happen in Edit Name

    LCtrl.InsertImageStringItem(0,"1", LCtrl.idx1)
    LCtrl.SetStringItem(0,1,item.name)

    if Properties['LCdate'] == 'timestamp':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    elif Properties['LCdate'] == 'createdate':
        LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))

    self.curIdx = 0
    
    #if Display is being filtered we assume that is the owner of the new node
    owner = Properties['owner']	
    if owner and owner!='*ALL':
        self.ListCtrls[L].SetStringItem(0, self.attr2col_num['owners'], owner)
        item.owners = [owner]
        
        self.owners.Clear()
        self.owners.AppendText(owner)
        
        cursor.execute("UPDATE "+table+" SET owner1 = %s WHERE id = %s", (owner,item.id))
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)  #not really necessary since just got a timestamp
    
    # decided that it was actually better not to ask for the owner on a new node	
    #else:
        #self.OnEditOwner()
    
    LCtrl.SetFocus() #needed for the in place editor to look right
    LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    
    self.OnDisplayInPlaceEditor() #(new=True)</t>
<t tx="ekr.20050811141217.92">self.name.Clear()
self.owners.Clear()
self.note.Clear()</t>
<t tx="ekr.20050811141217.93">@ Need to decide if we are going to have timestamp checking to be sure something hasn't changed
Note that there would not need to be timestamp checking on a new node
Also  there is no need to timestamp check on a local DB
The following code seems to work fine, however, I have just commented out the calls to it in NameEditor methods
@c
def Conflict(self, host, cursor, table, item):
    if host is 'sqlite':
        return False
    cursor.execute("Select timestamp from "+table+" WHERE id = %s", (item.id,))
    db_timestamp = cursor.fetchone()[0]
    if db_timestamp != item.timestamp:
        print "There is a conflict and you should refresh display"
        return True
    else:
        return False
</t>
<t tx="ekr.20050811141217.94">def OnEditNote(self, evt=None):
    if self.modified:
        self.OnUpdate()
    
    idx = self.curIdx
    
    if idx == -1:
        return
        
    L = self.L
        
    #if self.editor:
        #machine = None
        #win32pdh.EnumObjects(None, machine, 0, 1) # resets Enum otherwise it seems to hold onto old data
        #object = "Process"
        #items, instances = win32pdh.EnumObjectItems(None,None,"Process", -1)
        #if 'TextPad' in instances:
            #print "TextPad is running"
        #else:
            #self.editor = {}
    
    item = self.ItemLists[L][idx]
    file_name = re.sub('[\\/:*"&lt;&gt;|\?]','-',item.name) #make sure all chars are legal file name characters
    
    path = os.path.join(os.environ['TMP'],file_name[:50])+'.%s'%NOTE_EXT
        
    f = file(path,'w')
    f.write(self.GetNote())
    f.close()
    
    os.startfile(path)
    
    id = item.id
    for d in self.editor:
        if d['id'] == id:
            return

    ed = {}
    ed['time'] = os.path.getmtime(path)
    ed['host'] = self.PropertyDicts[L]['host']
    ed['table'] = self.PropertyDicts[L]['table']
    ed['path'] = path
    ed['id'] = item.id
    
    self.editor.append(ed)
    
    time.sleep(.1)
</t>
<t tx="ekr.20050811141217.95"></t>
<t tx="ekr.20050811141217.96">def OnNewList(self, event=None):
    if self.modified:
        self.OnUpdate()
    
    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]
        
    dlg = wxSingleChoiceDialog(self, 'Databases', 'Choose a database:', hosts, wxCHOICEDLG_STYLE)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        host = dlg.GetStringSelection()
    else:
        return
        
    cursor = self.GetCursor(host)
    if cursor is None:
        return
        
    dlg = wxTextEntryDialog(self, 'What is the name of the new table?', 'Create Table')
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        table = dlg.GetValue()
    else:
        return
    
    if not table:
        return
        
    location, rdbms = host.split(':')
    
    if rdbms == 'sqlite':
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
    else:
        cursor.execute("SHOW tables")
    
    if (table,) in cursor.fetchall():
        msg = wxMessageDialog(self,
                              "Table '%s' already exists"%table,
                              "Duplicate Table",
                              wxICON_ERROR|wxOK)
        msg.ShowModal()
        msg.Destroy()
        return
        
    dlg = wxMessageDialog(self,
          "Are you sure you want to create Table '%s'?"%table,
          "Create Table?",
          wxICON_QUESTION|wxYES_NO)

    if dlg.ShowModal() == wxID_YES:
        self.CreateTable(host,table)
        self.CreateNewNotebookPage(host,table)

        #self.AddListControl(tab_title) #add listcontrol displays the list
        
        #self.OnNewItem()
        
    dlg.Destroy()


</t>
<t tx="ekr.20050811141217.97">def OnFileList(self, evt=None, path=None):
    if self.modified:
        self.OnUpdate()
        
    #if there is no event, we got here through the start up loading of lists
    if evt:
        fileNum = evt.GetId() - wxID_FILE1			
        path = self.filehistory.GetHistoryFile(fileNum)
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)
        # only need to check if table is open if this is not at startup
        if table in [p['table'] for p in self.PropertyDicts if p['host'] == host]:
            dlg = wxMessageDialog(self,"%s (%s) is already open!"%(table,host),"List Open",wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            return
        
    else:
        location, rdbms, table = path.split(':')
        host = '%s:%s'%(location, rdbms)
    
    cursor = self.GetCursor(host)
    if cursor is None:
        return
        
    if rdbms == 'sqlite':
        sql = "SELECT name FROM sqlite_master WHERE name = '%s'"%table
    else:
        sql = "SHOW TABLES LIKE '%s'"%table
    
    cursor.execute(sql)
    if not cursor.fetchall():
        dlg = wxMessageDialog(self,
                    "Table '%s' at host '%s' does not appear to exist!"%(table,host),
                    "Table does not exist",
                    wxICON_ERROR|wxOK)
        dlg.ShowModal()
        dlg.Destroy()
        return
        
    self.CreateNewNotebookPage(host,table)

</t>
<t tx="ekr.20050811141217.98">def OnOpenList(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    tree = {}
    
    if OFFLINE_ONLY is True or REMOTE_HOST is None:
        hosts = [LOCAL_HOST]
    else:
        hosts = [LOCAL_HOST, REMOTE_HOST]
        
    for host in hosts:
        cursor = self.GetCursor(host)
        if cursor:
            if host.split(':')[1] == 'sqlite':
                sql = "SELECT name FROM sqlite_master WHERE type='table' ORDER BY name"
            else:
                sql = "SHOW TABLES" #sorted
    
            cursor.execute(sql)
            results = cursor.fetchall()
    
            #excluding already open tables + 'system' tables
            excluded_tables = [p['table'] for p in self.PropertyDicts if p['host'] == host]
            excluded_tables.extend(['user_sync','sync','owners'])
    
            tables = [t for (t,) in results if t not in excluded_tables]
    
            tree[host] = tables

    dlg = TreeDialog(self, "Open List", tree=tree)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_OK:
        sel = dlg.TreeCtrl.GetSelection()
        table = dlg.TreeCtrl.GetItemText(sel)
        sel = dlg.TreeCtrl.GetItemParent(sel)
        host = dlg.TreeCtrl.GetItemText(sel)
        
        if host in hosts: #takes care of highlighting root or hosts
            self.CreateNewNotebookPage(host,table)
</t>
<t tx="ekr.20050811141217.99">def OnDeleteList(self, evt=None):
    #ini controls whether the menu item is enabled
    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    table = Properties['table']
        
    #if table is in SYNC_TABLES, should we make a point of that?
    dlg = wxMessageDialog(self,
                        "Are you sure that you want to delete table %s (%s)?\n(Please note that you cannot recover it once it is deleted!)"%(table,host),
                        "Delete Table...",
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)
    
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return
        
    rdbms = host.split(':')[1]
    
    if rdbms == 'mysql':
        dlg = wxMessageDialog(self,
                        "Are you sure really really sure you want to delete table %s (%s)?\n(You really really cannot recover it once it is deleted)"%(table,host),
                        "Delete Table...",
                        wxICON_EXCLAMATION|wxYES_NO|wxNO_DEFAULT)
                        
        val = dlg.ShowModal()
        dlg.Destroy()
        if val == wxID_NO:
            return

    cursor = self.Cursors[host]
    cursor.execute("DROP TABLE %s"%table)
    
    self.OnCloseList()

</t>
<t tx="ekr.20050811141217.100">def OnCloseList(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    L = self.L
            
    del self.ItemLists[L]
    del self.PropertyDicts[L]
    del self.ListCtrls[L]
    del self.OwnerLBoxes[L]

    self.nb.DeletePage(L)        

    ln = len(self.PropertyDicts)
    if ln:
        self.nb.SetSelection(0)
        self.L = 0
    else:
        self.L = -1




</t>
<t tx="ekr.20050811141217.101">def OnCloseAll(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    while self.L != -1:
        self.OnCloseList()
        
    self.name.Clear()
    self.owners.Clear()
    self.note.Clear()
    #note that Clearing does set self.modified (eg {'name':1})
    self.modified = {}
    
</t>
<t tx="ekr.20050811141217.102">def OnSaveAsText(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    Properties = self.PropertyDicts[self.L]
    wildcard = "txt files (*.txt)|*.txt|All files (*.*)|*.*"
    #dlg = wxFileDialog(self, "Save file", "", Properties['table'], wildcard, wxSAVE|wxOVERWRITE_PROMPT|wxCHANGE_DIR)
        
    body = ""
    for i,item in enumerate(self.ItemLists[self.L]):
        body = body+"%d. %s (%d)\n"%(i+1, item.name, item.priority)
    
    table = Properties['table']
    location, rdbms = Properties['host'].split(':')
    filename = re.sub('[\\/:*"&lt;&gt;|\?]','-','%s-%s-%s'%(location,rdbms,table)) 
    filename = filename[:50]+'.txt'

    path = os.path.join(DIRECTORY,filename)
    
    f = file(path,'w')
    f.write(body)
    f.close()

    os.startfile(path)

    self.SetStatusText("Saved file %s"%path)
    
</t>
<t tx="ekr.20050811141217.103">def OnArchive(self, evt=None):
    if self.modified:
        self.OnUpdate()
        
    Properties = self.PropertyDicts[self.L]
    host = Properties['host']
    cursor = self.Cursors[host]
    table = Properties['table']
    rdbms = host.split(':')[1]
        
    table_archive = table+'_archive'
    
    #need to test for existence of table_archive
    if rdbms == 'sqlite':
        cursor.execute("SELECT name FROM sqlite_master WHERE type='table' ORDER BY name")
    else:
        cursor.execute("SHOW tables")

    results = cursor.fetchall()
    
    if (table_archive,) not in results:
        dlg = wxMessageDialog(self,
                    "Do you want to create an archive for table %s (%s)"%(table,rdbms),
                    "Create an archive...",
                    wxICON_QUESTION|wxYES_NO)
        val = dlg.ShowModal()
        dlg.Destroy()
        if val==wxID_YES:
            self.CreateTable(host,table_archive)
        else:
            return
    
    label1 = "In table %s (%s) \narchive all finished items older than:"%(table,rdbms)
    label2 = "Archive all finished items"
    dlg = FinishedDialog(self, "Archive completed items", days=7, spin_label=label1, check_label=label2)
    
    val = dlg.ShowModal()
    dlg.Destroy() #dialogs and frames not destroyed right away to allow processing events, methods
    if val==wxID_CANCEL:
        return
        
    if dlg.check.GetValue():
        cursor.execute("SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM "+table+" WHERE finisheddate IS NOT NULL")
    else:
        days = dlg.text.GetValue()
        date = mx.DateTime.today() - int(days)
        cursor.execute("SELECT id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note FROM "+table+" WHERE finisheddate &lt; %s",(date,))

    results = cursor.fetchall()
    dlg = wxMessageDialog(self,
                        "Archiving will remove %d records from %s.\nDo you want to proceed?"%(len(results),table),
                        "Proceed to archive...",
                        wxICON_QUESTION|wxYES_NO)
    
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return

    if table in SYNC_TABLES:
        if rdbms == 'sqlite':
            def track_deletes():
                timestamp = mx.DateTime.now()
                cursor.execute("INSERT INTO sync (id,action,table_name,name,timestamp) VALUES (%s,%s,%s,%s,%s)",(id,'d',table,name,timestamp))
        else:
            def track_deletes():
                cursor.execute("INSERT INTO sync (id,action,table_name,user,name) VALUES (%s,%s,%s,%s,%s)",(id,'d',table,USER,name))
    else:
        def track_deletes():
            pass	

    for row in results:
        # the next line is necessary because pysqlite returns a tuple-like object that is not a tuple
        r = tuple(row)
        id = r[0]
        name = r[2]
        cursor.execute("INSERT INTO "+table_archive+"  (id,priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,note) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)",r)
        timestamp = self.TimeStamper(host, cursor, table_archive, id)
        cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        track_deletes()
        
    self.OnRefresh()
    dlg = wxMessageDialog(self,
                        "Table %s had items older than %s days successfully archived"%(table,days),
                        "Archiving successful...",
                        wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
</t>
<t tx="ekr.20050811141217.104">def OnWorkOffline(self, evt=None):
    global OFFLINE_ONLY
    OFFLINE_ONLY = not OFFLINE_ONLY
    if OFFLINE_ONLY:
        del self.Cursors[REMOTE_HOST]
    else:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, "Cannot connect to remote server! Will set to work offline.", "ListManager", style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True

    self.filemenu.Check(idOFFLINE,OFFLINE_ONLY)
    
</t>
<t tx="ekr.20050811141217.105">@ignore
@nocolor
@wrap


This method toggles whether we are working offline only or both on and offline.</t>
<t tx="ekr.20050811141217.106"></t>
<t tx="ekr.20050811141217.107">def OnItemSelected(self, evt=None):
    if self.modified:
        self.OnUpdate()

    if evt:
        idx = evt.GetIndex()
    elif self.curIdx != -1:
        idx = self.curIdx
    else: # really to catch self.curIdx = -1 (see OnDelete and OnRefresh)
        self.name.Clear() # could be moved out of if
        self.owners.Clear() # could be moved out of if
        self.note.Clear()
        #note that Clearing does set self.modified (eg {'name':1})
        self.modified = {}
        return
    
    L = self.L
    item = self.ItemLists[L][idx]

    self.name.Clear()
    self.name.AppendText(item.name) #SetValue(item.name) - if you use setvalue you don't get the font
        
    self.owners.Clear()
    self.owners.AppendText('; '.join(item.owners))
    
    note = self.GetNote(L,item)
    if note.find("&lt;leo_file&gt;") != -1:
        self.note.SetValue("Leo Outline")
        self.note.SetEditable(False)
    else:
        self.note.SetValue(note)
        self.note.SetEditable(True)
        
    self.ListCtrls[L].EnsureVisible(idx)
    self.curIdx = idx
    
    #writing to text widgets caused wxEVT_COMMAND_TEXT_UPDATED which is caught by EVT_TEXT, which updates self.modified
    self.modified={}

</t>
<t tx="ekr.20050811141217.108">def OnItemActivated(self,evt):
    print "On Activated"
    
</t>
<t tx="ekr.20050811141217.109">def OnShowAll(self, evt=None):
    L = self.L
    OLBox = self.OwnerLBoxes[L]
    
    Properties = self.PropertyDicts[L]
    Properties['showfinished'] = -1
    Properties['owner'] = '*ALL'
    
    OLBox.SetStringSelection('*ALL')
    
    self.OnRefresh()
</t>
<t tx="ekr.20050811141217.110">def OnRefresh(self, evt=None):
    #OnItemSelected should be able to handle no items so this could be very short
    L = self.L
    
    results = self.ReadFromDB()
    self.ItemLists[L] = self.CreateAndDisplayList(results)

    if self.ItemLists[L]:
        self.ListCtrls[L].SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0
    else:
        self.curIdx = -1		
        
    self.OnItemSelected()
</t>
<t tx="ekr.20050811141217.111">def OnFilterOwners(self, evt=None):
    if self.modified:
        self.OnUpdate()
    sel = self.OwnerLBoxes[self.L].GetStringSelection()
    
    if sel:
        self.PropertyDicts[self.L]['owner'] = sel
        self.OnRefresh()
</t>
<t tx="ekr.20050811141217.112">def OnColumnClick(self, evt):
    col_num = evt.GetColumn()
    L = self.L
    LCtrl = self.ListCtrls[L]
    Sort = self.PropertyDicts[L]['sort']
    attr2col = self.attr2col_num
    
    prev_sort_attr = Sort.get('attribute') #if this is the first sort Properties['sort'] is {}
    
    #following is a little bit ugly but gets the key from the value, which is col_num
    Sort['attribute'] = attr2col.keys()[attr2col.values().index(col_num)]
    
    if prev_sort_attr == Sort['attribute']:
        Sort['direction'] = not Sort['direction']
    else:
        Sort['direction'] = 0
    
    self.OnRefresh()

    LCtrl.ClearColumnImage(attr2col['priority'])
    LCtrl.ClearColumnImage(attr2col['date'])
    img_num = LCtrl.arrows[Sort['direction']]
    LCtrl.SetColumnImage(col_num, img_num)
    
</t>
<t tx="ekr.20050811141217.113">def OnShowFinished(self,evt):
    Properties = self.PropertyDicts[self.L]
    label1 = "Enter the number of days to retain\ncompleted tasks in the display:"
    label2 = "Show all finished items"
    dlg = FinishedDialog(self, "Display of completed items", days=Properties['showfinished'], spin_label=label1, check_label=label2)
    if dlg.ShowModal()==wxID_OK:
        if dlg.check.GetValue():
            Properties['showfinished'] = -1
        else:
            days = dlg.text.GetValue()
            Properties['showfinished'] = int(days)			
        self.OnRefresh()
    dlg.Destroy()
    
</t>
<t tx="ekr.20050811141217.114">def OnColumnRightClick(self, evt=None):
    col = evt.GetColumn()
    if col != self.attr2col_num['date']:
        return
        
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    
    #x,y = evt.GetPosition()
    datemenu = wxMenu()
    
    for i,date in enumerate(['Create Date','Last Modified','Due Date','Completion Date']):
        datemenu.Append(200+i, date)
        EVT_MENU(self, 200+i, lambda e, i=i: self.ChangeDateDisplayed(e,i))

    x = LCtrl.GetColumnWidth(1)+ LCtrl.GetColumnWidth(2) + LCtrl.GetColumnWidth(3)
    self.PopupMenu(datemenu,(x,40))
    datemenu.Destroy()


</t>
<t tx="ekr.20050811141217.115">def OnDisplayDateCategory(self, evt=None):
    dlg = wxSingleChoiceDialog(self, 'Date Display', 'Choose a date to display:',
                    ['Create Date','Last Modified','Due Date','Completion Date']
                    , wxOK|wxCANCEL)
    val = dlg.ShowModal()
    dlg.Destroy()
    
    if val == wxID_OK:
        idx = dlg.GetSelection()
        self.ChangeDateDisplayed(i=idx)
        
</t>
<t tx="ekr.20050811141217.116">def ChangeDateDisplayed(self, evt=None, i=0):
    L = self.L
    LCtrl = self.ListCtrls[L]
    self.PropertyDicts[L]['LCdate'] = displaydate = ('createdate','timestamp','duedate','finisheddate')[i]	
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles[displaydate])
    LCtrl.SetColumn(col_num,col_info)
    self.DisplayList(self.ItemLists[L])
    #self.OnRefresh() #have gone back and forth but think that it should be self.DisplayList
</t>
<t tx="ekr.20050811141217.117">def DisplayList(self, List, L=None):
    #OnPasteItems needs to be able to have an L that is not self.L
    if L is None:
        L = self.L
    LCtrl = self.ListCtrls[L]
    LCdate = self.PropertyDicts[L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    LCtrl.DeleteAllItems()
    
    for x,item in enumerate(List):
        &lt;&lt; draw item &gt;&gt;
        

</t>
<t tx="ekr.20050811141217.118">LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or "")

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)
    
elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20050811141217.119"></t>
<t tx="ekr.20050811141217.120">def OnPageSetup(self, evt):
    #need to pass printdata to tableprint

    psdata = wxPageSetupDialogData()

    # if want to vary margins will need to save them as ivars and then set
    #psdata.SetMarginTopLeft((self.Left,self.Top))
    psdata.EnableMargins(False)
    psdata.SetPrintData(self.printdata) #gets Paper Orientation and PaperId info from printdata
    
    dlg = wxPageSetupDialog(self, psdata)
    if dlg.ShowModal() == wxID_OK:
        self.printdata = dlg.GetPageSetupData().GetPrintData()
        dlg.Destroy()
</t>
<t tx="ekr.20050811141217.121">def OnPrint(self, evt=None, prev=False, showprtdlg=True): 		#???self.psdata = psdata
    IList = self.ItemLists[self.L]
    Properties = self.PropertyDicts[self.L]
    
    prt = PrintTable(self.printdata) #self.printdata is the wxPrintData object with Orientation Info

    font_name = prt.default_font_name
    prt.text_font = {'Name':font_name, 'Size':11, 'Colour':[0, 0, 0], 'Attr':[0, 0, 0]}
    prt.label_font = {'Name':font_name, 'Size':12, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}
    prt.header_font = {'Name':font_name, 'Size':14, 'Colour':[0, 0, 0], 'Attr':[1, 0, 0]}
    
    prt.row_def_line_colour = wxLIGHT_GREY
    prt.column_def_line_colour = wxLIGHT_GREY
    
    prt.left_margin = 0.5

    data = []
    for row,item in enumerate(IList):	
        data.append([str(item.priority),
                    item.name,
                    item.duedate and item.duedate.Format('%m/%d/%y') or '',
                    '; '.join([x.split(',')[0] for x in item.owners])]) #just last names
                    
        if item.finisheddate:
            prt.SetCellText(row, 0, wxLIGHT_GREY)
            prt.SetCellText(row, 1, wxLIGHT_GREY)
            prt.SetCellText(row, 2, wxLIGHT_GREY)
            prt.SetCellText(row, 3, wxLIGHT_GREY)

    prt.data = data
    prt.label = ['P','Item','Due','Owner']
    
    if self.printdata.GetOrientation() == wxPORTRAIT:
        prt.set_column = [.2, 5, .65, 1]
    else:
        prt.set_column = [.2, 7, .65, 1.5]
                       
    title = "Table: %s   Owner: %s    "%(Properties['table'],Properties['owner'])
    prt.SetHeader(title, type='Date &amp; Time', align=wxALIGN_LEFT, indent = 1.5)
    prt.SetFooter("Page No ", type ="Num")

    if prev:
        prt.Preview()
    else:
        prt.Print(prompt=showprtdlg)
</t>
<t tx="ekr.20050811141217.122"></t>
<t tx="ekr.20050811141217.123">def OnWindowExit(self, evt):
    #this is called if you close the ListManager Window with the X
    if evt.CanVeto():
        self.OnExit()
    else:
        evt.Skip()
</t>
<t tx="ekr.20050811141217.124">def OnExit(self, event=None):   
    &lt;&lt; save configuration file &gt;&gt;
    sys.stderr.dlg.Destroy() #destroys the error dialog; need to do this to shut down correctly
    if self.ModifierDialog: #only reason to check is if closed before ModifierDialog is constructed
        self.ModifierDialog.Destroy()
    self.Close(1)
</t>
<t tx="ekr.20050811141217.125">cp.remove_section('Files')
cp.add_section("Files")

x,y = self.GetSizeTuple()

cp.set('Configuration','x', str(x))
cp.set('Configuration','y', str(y))

numfiles = self.filehistory.GetNoHistoryFiles()

for n in range(numfiles):
    cp.set("Files", "path%d"%n, self.filehistory.GetHistoryFile(n))

try:
    #you have to give ConfigParser a writable object
    cfile = file(config_file, 'w')
    cp.write(cfile)
    cfile.close()
except IOError:
    print "The configuration file can't be written!"
    time.sleep(10) #so you can see that there was a problem
</t>
<t tx="ekr.20050811141217.126"></t>
<t tx="ekr.20050811141217.127">def OnFind(self, evt=None):
    self.FindDialog.Show(True)
    self.FindDialog.FindText.SetSelection(-1,-1)
    self.FindDialog.FindText.SetFocus()


</t>
<t tx="ekr.20050811141217.128">def FindString(self, evt=None):
    L = self.L
    Properties = self.PropertyDicts[L]
    cursor = self.Cursors[Properties['host']]
    table = Properties['table']
    
    pat = self.FindDialog.FindText.GetValue()
    likepat = r"'%"+pat+r"%'"
    finished = self.FindDialog.SearchFinished.GetValue()
    notes = self.FindDialog.SearchNotes.GetValue()
    
    if finished:
        WHERE = "WHERE "
    else:
        WHERE = "WHERE finisheddate IS NULL AND "
    
    if notes:
        SELECT = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp,note FROM %s "%table
        WHERE = WHERE + "(name LIKE %s OR note LIKE %s) ORDER BY timestamp DESC"%(likepat,likepat)
    else:
        SELECT = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s "%table
        WHERE = WHERE + "name LIKE %s ORDER BY timestamp DESC"%likepat

    sql = SELECT + WHERE			
    try:
        cursor.execute(sql)
    except:
        print "Cannot read %s: %s"%(Properties['host'],table)
        return
    else:
        results = cursor.fetchall()
    
    case = self.FindDialog.MatchCase.GetValue()
    whole = self.FindDialog.MatchWhole.GetValue()
    
    if whole:
        pat = '\\b%s\\b'%pat
    
    if case:
        z = re.compile(pat)
    else:
        z =re.compile(pat, re.I)

    if notes:
        results = [x for x in results if re.search(z,x[1]) or re.search(z,x[10])]
    else:
        results = [x for x in results if re.search(z,x[1])]
    
    Properties['LCdate'] = 'timestamp'
    self.ItemLists[L]= IList = self.CreateAndDisplayList(results)
    
    LCtrl = self.ListCtrls[L]
    col_num = self.attr2col_num['date']
    col_info = LCtrl.GetColumn(col_num)
    col_info.SetText(self.date_titles['timestamp'])
    LCtrl.SetColumn(col_num,col_info)
    
    if IList:
        self.curIdx = 0
        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
    else:		
        self.curIdx = -1
        
    self.OnItemSelected()
    
    Properties['sort'] = {'direction':0,'attribute':'date'}
    Properties['owner'] = '*ALL'
    
    owner_idx = self.OwnerLBoxes[L].GetSelection()
    if owner_idx != -1:
        self.OwnerLBoxes[L].SetSelection(owner_idx, 0) #get exception if index = -1

    self.SetStatusText("Found %d items"%len(IList))
</t>
<t tx="ekr.20050811141217.129">def FindNode(self, item, showfinished=True):
    L = self.L
    LCtrl = self.ListCtrls[L]
    Properties = self.PropertyDicts[L]
    
    Properties['owner'] = '*ALL'
    Properties['showfinished'] = showfinished
    
    self.ItemLists[L] = IList = self.CreateAndDisplayList(self.ReadFromDB())
    
    id = item.id
    idx = -1
    for item in IList:
        idx+=1
        if id == item.id:
            break
    else:
        idx = -1

    if idx != -1:	
        LCtrl.SetItemState(idx, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        LCtrl.EnsureVisible(idx)
    self.curIdx = idx
    
</t>
<t tx="ekr.20050811141217.130"></t>
<t tx="ekr.20050811141217.131">def GetCursor(self, host):
    cursor = self.Cursors.get(host)
    if cursor:
        return cursor
        
    location, rdbms = host.split(':')
        
    if rdbms == 'sqlite':
        db = os.path.join(DIRECTORY,location,DB)
        try:
            Con = sqlite.connect(db=db, autocommit=1)
            cursor = Con.cursor()
            self.sqlite_connections.append(Con)  #getting a weak reference error from PySQLite and this makes it go away
        except:
            dlg = wxMessageDialog(self,
                    "Could not connect to SQLite database at %s"%location,
                    "Connection problem!",
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None
        
    elif not OFFLINE_ONLY:
        try:
            Con = MySQLdb.connect(host=location, user=USER, passwd=PW, db=DB)
            cursor = Con.cursor()
        except:
            dlg = wxMessageDialog(self,
                    "host = %s | user = %s | password = %s**** | db = %s - could not connect!"%(host,USER,PW[:3],DB),
                    "Connection problem",
                    wxICON_ERROR|wxOK)
            dlg.ShowModal()
            dlg.Destroy()
            cursor = None
            
    if cursor:
        self.Cursors[host] = cursor
        
    return cursor


</t>
<t tx="ekr.20050811141217.132">def GetNote(self, L=None, item=None):
    if L is None:
        L = self.L
        
    if item is None:
        if self.curIdx != -1:
            item = self.ItemLists[L][self.curIdx]
        else:
            return ''
        
    Properties = self.PropertyDicts[L]
    
    cursor = self.Cursors[Properties['host']]
    table = Properties['table']
    cursor.execute("SELECT note from "+table+" WHERE id = %s", (item.id,))
    
    ###### Debug -- this does happen where note brings back None 053003
    z = cursor.fetchone()
    if z is None:
        print "In GetNote -&gt; SELECT should not bring back None"
        print "           -&gt; item.id=",item.id
        z = (None,)
    note = z[0]
    if note is None:
        note = ''
    return note
    
</t>
<t tx="ekr.20050811141217.133">def CreateTable(self, host, table):
    cursor = self.Cursors[host]
    rdbms = host.split(':')[1]
    if rdbms == 'sqlite':
        sql = """CREATE TABLE '%s' ('id' varchar(36) PRIMARY KEY,
'priority' int(1),
'name' varchar(150),
'createdate' datetime,
'finisheddate' date,
'duedate' date,
'owner1' varchar(25),
'owner2' varchar(25),
'owner3' varchar(25),
'note' text,
'timestamp' timestamp(14))"""%table
    else:
        sql = """CREATE TABLE `%s` (`id` varchar(36) NOT NULL default '',
`priority` int(1) NOT NULL default '1',
`name` varchar(150) NOT NULL default '',
`createdate` datetime NOT NULL default '0000-00-00 00:00:00',
`finisheddate` date default '0000-00-00',
`duedate` date default '0000-00-00',
`owner1` varchar(25) default '',
`owner2` varchar(25) default '',
`owner3` varchar(25) default '',
`note` text,
`timestamp` timestamp(14) NOT NULL,PRIMARY KEY  (`id`)) TYPE=MyISAM"""%table
        
    cursor.execute(sql)
</t>
<t tx="ekr.20050811141217.134">def ReadFromDB(self):
    L = self.L
    Properties = self.PropertyDicts[L]
    
    host = Properties['host']
    cursor = self.GetCursor(host)
    if cursor is None:
        return None
        
    table = Properties['table']
    
    owner = Properties['owner']
    if owner == '*ALL':
        WHERE = ""
    else:
        WHERE = 'WHERE (owner1 = "%s" OR owner2 = "%s" OR owner3 = "%s")'%(owner,owner,owner)
    
    #-1 show them all; 0 show none; integer show for that many days
    days = Properties['showfinished']	
    if days != -1:
        if days:
            date = mx.DateTime.now() - days
            t = "(finisheddate IS NULL OR finisheddate &gt; '%s')"%date
        else:
            t = "finisheddate IS NULL"
        
        if WHERE:
            WHERE = "%s AND %s"%(WHERE,t)
        else:
            WHERE = " WHERE %s"%t

    Sort = Properties['sort']
    if Sort:
        sort_attr = Sort['attribute']
        if sort_attr == 'date':
            sort_attr = Properties['LCdate']
        elif sort_attr == 'owners':
            sort_attr = 'owner1'
        
        WHERE = WHERE + " ORDER BY " + sort_attr
        #if not direction: WHERE = WHERE + " DESC"   works because ASC is the default
        if not Sort['direction']:
            WHERE = WHERE + " DESC" 

    sql = "SELECT priority,name,createdate,finisheddate,duedate,owner1,owner2,owner3,id,timestamp FROM %s %s"%(table,WHERE)
            
    try:
        cursor.execute(sql)
    except:
        print "Cannot read %s: %s"%(Properties['host'],table)
        return None #[]
    else:
        return cursor.fetchall()
        


</t>
<t tx="ekr.20050811141217.135">def CreateAndDisplayList(self, results):
    LCtrl = self.ListCtrls[self.L]
    LCdate = self.PropertyDicts[self.L]['LCdate']
    if LCdate == 'timestamp':
        format = '%m/%d %H:%M:%S'
    else:
        format = '%m/%d/%y'
    itemlist = []

    LCtrl.DeleteAllItems()
    class Item: pass
    
    for x,row in enumerate(results):
        
        item = Item()
        &lt;&lt; assign item attributes &gt;&gt;
        itemlist.append(item)
        
        &lt;&lt; draw item &gt;&gt;

    return itemlist


</t>
<t tx="ekr.20050811141217.136">item.priority = int(row[0]) #int(row[0]) needs int because it seems to come back as a long from MySQL
item.name = row[1]
item.createdate = row[2]
item.finisheddate = row[3]
item.duedate = row[4]
item.owners = [y for y in row[5:8] if y] #if you carry around ['tom',None,None] Note this is 5:8 not 5:7
item.id = row[8]
item.timestamp = row[9]

</t>
<t tx="ekr.20050811141217.137">LCtrl.InsertImageStringItem(x, str(item.priority), LCtrl.idx1)
LCtrl.SetStringItem(x,1,item.name)
LCtrl.SetStringItem(x,2,'; '.join(item.owners))
date = item.__dict__[LCdate]
LCtrl.SetStringItem(x,3,date and date.Format(format) or "")

if item.finisheddate:
    LC_Item = LCtrl.GetItem(x)
    LC_Item.SetImage(LCtrl.idx0) #might just want generic number or greyed one two three
    LC_Item.SetTextColour(wxLIGHT_GREY)
    LCtrl.SetItem(LC_Item)
    
elif item.priority==2:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #resetting weight
    LCtrl.SetItem(LC_Item)

elif item.priority==3:
    LC_Item = LCtrl.GetItem(x)
    f = self.LC_font
    f.SetWeight(wxBOLD)
    LC_Item.SetFont(f)
    f.SetWeight(wxNORMAL) #return to normal
    LC_Item.SetTextColour(wxRED)
    LCtrl.SetItem(LC_Item)</t>
<t tx="ekr.20050811141217.138">def OnSync(self, evt=None):
    if self.modified:
        self.OnUpdate()
    #Note that the results of an sqlite query are an instance that you need to turn into a tuple or MySQL gets unhappy

    if OFFLINE_ONLY:
        dlg = wxMessageDialog(self, "You need to be online to synchronize!", style = wxOK|wxICON_ERROR)
        dlg.ShowModal()
        dlg.Destroy()
        return
        
    dlg = wxMessageDialog(self,"Synchronize Table(s): "+" and ".join(SYNC_TABLES),"Synchronize...",wxICON_QUESTION|wxYES_NO)
    val = dlg.ShowModal()
    dlg.Destroy()
    if val == wxID_NO:
        return
    
    if REMOTE_HOST is None:
        print "There doesn't appear to be a Remote Server"
        return

    if LOCAL_HOST is None:
        print "There doesn't appear to be a Local Server"
        return
        
    print "LOCAL_HOST=",LOCAL_HOST
    print "REMOTE_HOST=",REMOTE_HOST

    r_cursor = self.GetCursor(REMOTE_HOST)
    if r_cursor is None:
        print "Couldn't get a cursor for %s"%REMOTE_HOST
        return

    l_cursor = self.GetCursor(LOCAL_HOST)
    if l_cursor is None:
        print "Couldn't get a cursor for %s"%LOCAL_HOST
        return

    # moving the sync time back a second to make sure that we don't lose track of any nodes
    #that are being updated or inserted at the same time as we are syncing
    r_cursor.execute("SELECT NOW()")
    l_now = mx.DateTime.now()-mx.DateTime.oneSecond
    r_now = r_cursor.fetchone()[0]-mx.DateTime.oneSecond
    #because of some inconsistent rounding appears necessary to make sure the sqlite timestamp is less than l_now
    #having seen same issue for mysql but for consistency (and because sqlite could also be "server" rdbms
    l_ts = l_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    r_ts = r_now - mx.DateTime.DateTimeDelta(0,0,0,0.02)
    print "l_now=",l_now, "l_ts =",l_ts
    print "r_now=",r_now, "r_ts=",r_ts

    r_cursor.execute("SELECT MAX(last_sync) FROM user_sync WHERE user = %s", (USER,))
    r_last_sync = r_cursor.fetchone()[0]
    print "last sync (remote time) =",r_last_sync

    l_cursor.execute("SELECT MAX(last_sync) FROM user_sync")
    l_last_sync = l_cursor.fetchone()[0] #note MAX returns a string with sqlite so we turn it make into DateTime
    l_last_sync = mx.DateTime.DateTimeFrom(l_last_sync)
    print "last sync (local time) =",l_last_sync

    for table in SYNC_TABLES:
        # Need to pick up changes for both so syncing one doesn't add new things and screw up the second sync
        print "Checking "+table+" on the Remote Server; changes (excluding deletes) are:"
        r_cursor.execute("SELECT id,createdate from "+table+" WHERE timestamp &gt; %s AND timestamp &lt;= %s",(r_last_sync,r_now)) 
        r_results = r_cursor.fetchall()
        print "Server changes (excluding deletes)"
        print r_results
        
        print "Checking "+table+" on Local; changes (excluding deletes) are:"
        l_cursor.execute("SELECT id,createdate from "+table+" WHERE timestamp &gt; %s AND timestamp &lt;= %s",(l_last_sync,l_now))
        l_results = l_cursor.fetchall()
        print "Local changes (excluding deletes)"
        print l_results

        for id, createdate in r_results:
            r_cursor.execute("SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM "+table+" WHERE ID = %s",(id,))
            row = r_cursor.fetchone()
            if row:
                if createdate &gt; r_last_sync:
                    l_cursor.execute("INSERT INTO "+table+" (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)", row) #*row also works
                    print "Created %s in %s on Local"%(id,table)
                else:
                    l_cursor.execute("UPDATE "+table+" SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s", row)
                    print "Updated %s in %s on Local"%(id,table)
                # for reasons I don't understand l_now here is a 1/100 ahead of l_now when inserted into user_sync
                l_cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (l_ts,id))
        
        for id, createdate in l_results:
            l_cursor.execute("SELECT priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id FROM "+table+" WHERE ID = %s",(id,))
            row = l_cursor.fetchone()
            if row:
                row = tuple(row)
                #above needed because sqlite returns an enhanced tuple-like object that is not a tuple
                if createdate &gt; l_last_sync:
                    r_cursor.execute("INSERT INTO "+table+" (priority,name,owner1,owner2,owner3,createdate,finisheddate,duedate,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s,%s,%s)", row)
                    print "Created %s in %s on Server"%(id,table)
                else:
                    r_cursor.execute("UPDATE "+table+" SET priority = %s, name =%s, owner1 = %s, owner2 = %s, owner3 = %s, createdate = %s, finisheddate = %s, duedate = %s, note = %s WHERE id = %s", row)
                    print "Updated %s in %s on Server"%(id,table)
                r_cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (r_ts,id))
    
    #Handle the deletes; Note if at some point only 'd's are being written won't have to check for 'd'
    r_cursor.execute("SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'",(r_last_sync,r_now))
    r_results = r_cursor.fetchall()

    l_cursor.execute("SELECT id,table_name FROM sync WHERE timestamp &gt; %s AND timestamp &lt;= %s AND action = 'd'",(l_last_sync,l_now))
    l_results = l_cursor.fetchall()

    for id,table in l_results:
        r_cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        print "Deleted %s from %s on Server (if it existed there)"%(id,table)

    for id,table in r_results:
        l_cursor.execute("DELETE from "+table+" WHERE id = %s", (id,))
        print "Deleted %s from %s on Local (if it existed there)"%(id,table)	
    #End of deletes code
    
    #update the user_sync database with the latest sync times
    l_cursor.execute("INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)", (USER,l_now)) #don't really need USER for local
    r_cursor.execute("INSERT INTO user_sync (user,last_sync) VALUES (%s,%s)", (USER,r_now)) 
    
    print "Synchronization completed"

</t>
<t tx="ekr.20050811141217.139">def TimeStamper(self, host, cursor, table, id):
    #note that you can insert a timestamp value into an mysql timestamp field
    if host.split(':')[1] == 'sqlite': #host -&gt; location:rdbms
        timestamp = mx.DateTime.now()
        cursor.execute("UPDATE "+table+" SET timestamp = %s WHERE id = %s", (timestamp,id))
    else:
        cursor.execute("Select timestamp from "+table+" WHERE id = %s", (id,))
        timestamp = cursor.fetchone()[0]
        
    return timestamp
</t>
<t tx="ekr.20050811141217.140"></t>
<t tx="ekr.20050811141217.141">def OnShowEvaluate(self, evt=None):
    
    self.EvalDialog.Show(True)
    self.EvalDialog.EvalText.SetSelection(-1,-1)
    self.EvalDialog.EvalText.SetFocus()
    
</t>
<t tx="ekr.20050811141217.142">def OnEvaluate(self, evt=None):
    expr = self.EvalDialog.EvalText.GetValue()
    print "%s =&gt; "%expr,
    print eval(expr)
    
</t>
<t tx="ekr.20050811141217.143"></t>
<t tx="ekr.20050811141217.144">def OnShowAbout(self, evt=None):
    from about import AboutBox
    dlg = AboutBox(self, app_version = VERSION)
    dlg.ShowModal()
    dlg.Destroy()
    
</t>
<t tx="ekr.20050811141217.145">def OnShowHelp(self, evt=None):
    os.startfile('ListManager.chm')
    
</t>
<t tx="ekr.20050811141217.146">def GetUID(self):
    pyiid = CreateGuid()
    # the str(pyiid) looks like {....} and doing [1:-1] strips that off
    return str(pyiid)[1:-1]
    
</t>
<t tx="ekr.20050811141217.147">def OnIdle(self, evt):	
    &lt;&lt; Check for Transfers From Outlook &gt;&gt;
    &lt;&lt; Check if Edited File has Changed &gt;&gt;
    
</t>
<t tx="ekr.20050811141217.148">@ignore
@nocolor
@wrap


First thing, when are idle events triggered? --&gt; in wxPython they occur after there are no more events to process in the event queue.  So when things are happening rapidly (such as mouse movement) you actually see more idle events and when nothing at all is happening, you don't see any.  This is pretty counterintuitive initially since you would think that idle events should happen when things are truly idle.</t>
<t tx="ekr.20050811141217.149">if OUTLOOK:
    input,output,exc = select.select([self.sock],[],[],0)
    if input:
        client,addr = self.sock.accept() # Get a connection
        rec = client.recv(8192)
        d = pickle.loads(rec)
        
        class Item: pass
        
        item = Item()
        item.id = self.GetUID()
        item.priority = 1
        item.createdate = mx.DateTime.now()
        item.duedate = item.finisheddate = None
        
        #outlook strings are unicode; ascii encode makes sure no chars above 127
        name = d['Subject'].encode('ascii','replace') 
        item.name = name[:150]
        
        owner = d['SenderName'].encode('ascii','replace') #encode takes unicode to standard strings
        owner = owner[:25]
        item.owners = [owner]
        
        note = d['CreationTime'] + '\n' + d['Body'].encode('ascii','replace')
        #foldername = d['Parent.Name']
        
        #location, rdbms, table = MAIL_LIST_PATH.split(':')
        #host = '%s:%s'%(location,rdbms)
        host, table = re.split('(.*?:.*?):', MAIL_LIST_PATH)[1:3] #really just for fun
        
        cursor = self.Cursors[host]
        
        cursor.execute("INSERT INTO "+table+" (priority,name,createdate,finisheddate,duedate,owner1,note,id) VALUES (%s,%s,%s,%s,%s,%s,%s,%s)",
            (item.priority, name, item.createdate, item.finisheddate, item.duedate, owner, note, item.id))
        
        item.timestamp = self.TimeStamper(host, cursor, table, item.id)
        
        #check to see if table is open
        for L,Properties in enumerate(self.PropertyDicts):
            if Properties['table'] == table and Properties['host'] == host:
                break
        else:
            print "Table not open but wrote to database anyway" #Needs to be a dialog box
            return
        
        # could have started to edit something and never finished it
        if self.modified:
            self.OnUpdate()
        
        if self.L != L:
            self.nb.SetSelection(L) # Note that this does not call OnPageChange if the page doesn't change
        
        LCtrl = self.ListCtrls[L]
        
        if self.curIdx != -1:
            LCtrl.SetItemState(self.curIdx, 0, wxLIST_STATE_SELECTED)
        
        self.ItemLists[L].insert(0,item)    
        LCtrl.InsertImageStringItem(0,"1", LCtrl.idx1)
        LCtrl.SetStringItem(0,self.attr2col_num['name'],name)
        LCtrl.SetStringItem(0, self.attr2col_num['owners'], owner)
        
        if Properties['LCdate'] == 'timestamp':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
        elif Properties['LCdate'] == 'createdate':
            LCtrl.SetStringItem(0, self.attr2col_num['date'], item.createdate.Format('%m/%d/%y'))
        
        LCtrl.SetItemState(0, wxLIST_STATE_SELECTED, wxLIST_STATE_SELECTED)
        self.curIdx = 0 

</t>
<t tx="ekr.20050811141217.150">@ignore
@nocolor 
@wrap


The select statement always confused me a bit so I'll come back to this to provide some more documentation of what is going on here.

The emails identified in Outlook are moved to ListManager through a socket connection.  There is a separate Outlook addin that allows the user to highlight an Outlook email message and click on a button in the Outlook toolbar to move the message into ListManager.  I find that many tasks originate or are documented in an email and this makes it very convenient to move those items from Outlook into ListManager without any retyping.
</t>
<t tx="ekr.20050811141217.151">for ed in self.editor:
    path = ed['path']
    t = os.path.getmtime(path)
    if t != ed['time']:
        f = file(path,'r')
        note = f.read()
        f.close()
        ed['time'] = t
        
        host = ed['host']
        cursor = self.Cursors[host]
        table = ed['table']
        id = ed['id']
        cursor.execute("UPDATE "+table+" SET note = %s WHERE id = %s", (note,id)) 
        # see @rst documentation note
        ts = self.TimeStamper(host, cursor, table, id)
        
        idx = self.curIdx
        L = self.L
        if idx != -1:
            item = self.ItemLists[L][idx]
            if item.id == id:
                self.note.SetValue(note)
                item.timestamp = ts
                
                if self.PropertyDicts[L]['LCdate'] == 'timestamp':
                    self.ListCtrls[L].SetStringItem(idx, self.attr2col_num['date'], item.timestamp.Format("%m/%d %H:%M:%S"))
    
                if 'note' in self.modified: #if necessary only if somehow note text didn't change
                    del self.modified['note']

</t>
<t tx="ekr.20050811141217.152">@ignore
@nocolor
@wrap

This section in the OnIdle method checks to see if there are any open editors that have had a change in data in a manner that is similar to the code in Leo that works with the Leo Open With menu item.

.. note::

    After the line::
    
        cursor.execute("UPDATE "+table+" SET note = %s WHERE id = %s", (note,id))
        
    normally the next line would be:: 
    
    	item.timestamp = self.TimeStamper(host, cursor, table, id)
    
    however, this is actually a bit tricky since by the time the editor is closed the user may be on a different notebook page and you'd have to go from id --&gt; self.ItemLists[L][idx] to update the display so it didn't seem like it was worth the effort.  This means that the display timestamp doesn't automatically update when the external editor is closed but will update if the display is refreshed. 
</t>
<t tx="ekr.20050811141217.153">class ListCtrl(wxListCtrl, wxListCtrlAutoWidthMixin):
    @others
</t>
<t tx="ekr.20050811141217.154">def __init__(self, parent, ID, pos=wxDefaultPosition, size=wxDefaultSize, style=0):
    wxListCtrl.__init__(self, parent, ID, pos, size, style)
    wxListCtrlAutoWidthMixin.__init__(self)

    self.il = wxImageList(16,16)

    sm_up = self.il.Add(wxBitmap('bitmaps\\up_arrow.bmp')) #(images.getSmallUpArrowBitmap())
    sm_dn = self.il.Add(wxBitmap('bitmaps\\down_arrow.bmp'))
    self.arrows = (sm_up,sm_dn)
    
    self.idx1 = self.il.Add(wxBitmap('bitmaps\\box.bmp'))
    self.idx0 = self.il.Add(wxBitmap('bitmaps\\filledwhitebox.bmp'))    

    self.SetImageList(self.il, wxIMAGE_LIST_SMALL)

    EVT_LIST_COL_BEGIN_DRAG(self, self.GetId(), self.OnColBeginDrag)    

    self.SetUpColumns()

</t>
<t tx="ekr.20050811141217.155">def SetUpColumns(self):
    #Need to to construct column heads for columns with sorting by hand to get sorting images on columns
    info = wxListItem()
    info.m_mask = wxLIST_MASK_TEXT | wxLIST_MASK_IMAGE | wxLIST_MASK_FORMAT
    info.m_image = -1

    #Oth column is priority which is sortable
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = "P"
    self.InsertColumnInfo(0, info)
    self.SetColumnWidth(0, 35)
    
    self.InsertColumn(1, "Name")
    self.SetColumnWidth(1, 590)

    self.InsertColumn(2, "Owner")
    self.SetColumnWidth(2, 100)
    
    #3th column is create ate and same as with priority - needs to constructed by hand
    info.m_format = wxLIST_FORMAT_LEFT
    info.m_text = "Due Date"
    self.InsertColumnInfo(3, info)
    self.SetColumnWidth(3, 75)                

</t>
<t tx="ekr.20050811141217.156">def OnColBeginDrag(self, evt):
    #if inplace editor then change its dimensions
    if evt.GetColumn() == 0:
        evt.Veto()
</t>
<t tx="ekr.20050811141217.157">class MyApp(wxApp):
    @others
</t>
<t tx="ekr.20050811141217.158">def OnInit(self):
    global OFFLINE_ONLY, CANCEL
    wxInitAllImageHandlers()
    
    if STARTUP_DIALOG:
        startup = StartupDialog(None, 'List Manager')
        val = startup.ShowModal()
        startup.Destroy()
        if val == wxID_YES:
            OFFLINE_ONLY = True
        elif val == wxID_NO:
            OFFLINE_ONLY = False
        elif val == wxID_CANCEL:
            CANCEL = True
            return True

    if OFFLINE_ONLY is False:
        server = REMOTE_HOST.split(':')[0]
        try:
            socket.gethostbyname(server)
        except:
            dlg = wxMessageDialog(None, "Cannot connect to remote server! Only offline access is possible.", "ListManager", style=wxOK|wxICON_EXCLAMATION|wxSTAY_ON_TOP)
            dlg.ShowModal()
            dlg.Destroy()
            OFFLINE_ONLY = True
            
    frame = ListManager(None, -1, "List Manager", size = (X,Y))
    frame.Show(True)
    self.SetTopWindow(frame)
    CANCEL = False
    return True


</t>
<t tx="ekr.20050811141217.159">class Logger:
    def __init__(self):
        self.dlg = LoggerDialog(None, "", "Alerts and Exceptions", dir=DIRECTORY)
    def write(self, error_msg):
        if not self.dlg.IsShown():
            self.dlg.text.AppendText("\n%s\n"%time.asctime())
            self.dlg.Show(True)
        
        self.dlg.text.AppendText(error_msg)

</t>
<t tx="ekr.20050811141217.160">def run():
    app = MyApp(0)
    if not CANCEL:
        sys.stderr = sys.stdout = Logger()
        app.MainLoop()
    
if __name__ == '__main__':
    run()
</t>
<t tx="ekr.20050811141217.161">@ @rst-options
code_mode = True
@c


@language python
from wxPython.wx import *
# the following two are needed for the calendar
from wxPython.calendar import *
from wxPython.utils import *
import os
@others</t>
<t tx="ekr.20050811141217.162">class TicklerDialog(wxDialog):
    @others
</t>
<t tx="ekr.20050811141217.163">def __init__(self, parent, msg, caption, pos = wxDefaultPosition, size = wxDefaultSize):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP | wxTHICK_FRAME | wxCAPTION)

    TC = wxTextCtrl(self, -1, msg, wxDefaultPosition,
                    (450,250),
                    wxTE_MULTILINE | wxTE_READONLY | wxTE_RICH2)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        
    
    sizer.Add(TC, 1, wxALIGN_CENTRE|wxALL, 5)
    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    
    sizer.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    btn = wxButton(self, wxID_OK, "GO TO ITEM")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_FORWARD, "SHOW NEXT")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_APPLY, "MAIL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    
    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    EVT_LEFT_DOWN(TC, self.OnLeftDown)
    EVT_BUTTON(self, wxID_FORWARD, self.OnForward)
    EVT_BUTTON(self, wxID_APPLY, self.OnMail)

    TC.SetCursor(wxStockCursor(wxCURSOR_ARROW))        

    self.TC = TC
</t>
<t tx="ekr.20050811141217.164">def OnLeftDown(self, evt):
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20050811141217.165">def OnForward(self, evt):
    self.EndModal(wxID_FORWARD)
</t>
<t tx="ekr.20050811141217.166">def OnMail(self, evt):
    self.EndModal(wxID_APPLY)        
</t>
<t tx="ekr.20050811141217.167">class StartupDialog(wxDialog):
    @others
</t>
<t tx="ekr.20050811141217.168">def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,115)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    msg = "You can connect to the server using the network,\nor work offline, or cancel this logon."

    image = wxStaticBitmap(self, -1, wxBitmap('bitmaps\\wxpdemo.bmp'), (-1,-1), size=(32,32)) #sizer determines position
    text = wxStaticText(self, -1, msg, (-1,-1), size=(250,32)) #sizer determines position

    rect = wxBoxSizer(wxHORIZONTAL)
    rect.Add(image, 0, wxALIGN_LEFT|wxALL, 4)
    rect.Add(text, 1, wxALIGN_CENTER|wxTOP, 7)
    sizer = wxBoxSizer(wxVERTICAL)


    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_NO, 'Connect')
    box.Add(btn, 0, wxALL, 10)
    btn.SetDefault()

    btn = wxButton(self, wxID_YES, 'Work Offline')
    box.Add(btn, 0, wxALL, 10)

    btn = wxButton(self, wxID_CANCEL, 'Cancel')
    box.Add(btn, 0, wxALL, 10)

    sizer.AddSizer(rect)
    sizer.AddSizer(box)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_NO, self.OnSelection)
    EVT_BUTTON(self, wxID_YES, self.OnSelection)
    EVT_BUTTON(self, wxID_CANCEL, self.OnSelection)</t>
<t tx="ekr.20050811141217.169">def OnSelection(self,evt):
    val = evt.GetId()
    self.EndModal(val)</t>
<t tx="ekr.20050811141217.170">class ModifierDialog(wxDialog):
    @others
</t>
<t tx="ekr.20050811141217.171">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             modifierlist=None,
             curselections = ''):
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)
    
    tc = wxTextCtrl(self, -1, "", size = (150,-1))
    sizer1.Add(tc, 0, wxALIGN_CENTRE|wxALL, 5)
    self.tc = tc

    if not modifierlist:
        modifierlist = []
    lb = wxListBox(self, -1,  wxDefaultPosition, (150,300), #wxPoint(90, 80)
                    modifierlist, wxLB_MULTIPLE|wxLB_SORT)

    sizer1.Add(lb, 1, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    

    btn = wxButton(self, wxID_OK, "OK")
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)

    for sel in curselections:
        index = lb.FindString(sel)
        if index !=-1:
            lb.SetSelection(index)

    self.lb = lb

    EVT_BUTTON(self, wxID_CANCEL, self.ClearSelections)


</t>
<t tx="ekr.20050811141217.172">def GetUserInput(self):
    idx_list = self.lb.GetSelections()
    mod_list =[]
    for i in idx_list:
        mod_list.append(self.lb.GetString(i))
        self.lb.Deselect(i) #071203

    new_list = []
    manual_string = self.tc.GetValue() #text entry box
    
    if manual_string:
        manual_list = [x.strip() for x in manual_string.split(';')]
        for name in manual_list:
            clean_name = ", ".join([x.strip().title() for x in name.split(',')])
            if clean_name not in mod_list:
                mod_list.append(clean_name)
                new_list.append(clean_name)

        
    return (mod_list, new_list)</t>
<t tx="ekr.20050811141217.173">def SelectCurrent(self, cur_sel):
    for sel in cur_sel:
        index = self.lb.FindString(sel)
        if index !=-1:
            self.lb.SetSelection(index)


</t>
<t tx="ekr.20050811141217.174">def ClearSelections(self, evt=None):
    idx_list = self.lb.GetSelections() #note you can't just use the indexes of the SelectCurrent since they may have clicked before cancelling
    for i in idx_list:
        self.lb.Deselect(i)

    evt.Skip()</t>
<t tx="ekr.20050811141217.175">class MailDialog(wxDialog):
    @others
</t>
<t tx="ekr.20050811141217.176">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxSTAY_ON_TOP| wxTHICK_FRAME|wxCAPTION|wxSYSTEM_MENU,
             recipients='',
             subject = '',
             body = ''):
    
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)

    recipients = "; ".join(recipients)
    label = wxStaticText(self, -1, "To:",wxDefaultPosition, size=(40,-1), style=wxALIGN_LEFT)
    RTC = wxTextCtrl(self, -1, recipients, size = (480,-1))
    box.Add(label)
    box.Add(RTC)

    #sizer.Add(10,10,0)      

    sizer.AddSizer(box)        

    box = wxBoxSizer(wxHORIZONTAL)       
    label = wxStaticText(self, -1, "Subject:",wxDefaultPosition, size=(40,-1),style=wxALIGN_LEFT)
    STC = wxTextCtrl(self, -1, subject, size = (480,-1)) 
    box.Add(label)
    box.Add(STC)

    sizer.AddSizer(box)
    sizer.Add(1, 5, 0)
    
    BTC = wxTextCtrl(self, -1, body, wxDefaultPosition, size = (500,400), style=wxTE_MULTILINE|wxTE_RICH2)

    sizer.Add(BTC)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, "SEND MAIL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)

    self.RTC = RTC
    self.STC = STC
    self.BTC = BTC

</t>
<t tx="ekr.20050811141217.177">class CalendarDialog(wxDialog):
    @others
</t>
<t tx="ekr.20050811141217.178">def __init__(self, parent, title,
             pos=wxDefaultPosition,
             size=wxDefaultSize,
             style=wxCAPTION,
             date=0):
    
    wxDialog.__init__(self, parent, -1, title, pos, size, style)

    if not date:
        date = wxDateTime_Now()

    cal = wxCalendarCtrl(self, -1, date, #pos = (25,50),
                         style = wxCAL_SHOW_HOLIDAYS | wxCAL_SUNDAY_FIRST)

    EVT_CALENDAR(self, cal.GetId(), self.OnCalSelected)

    #EVT_CLOSE(self, self.OnCloseWindow)          
    
    self.cal = cal

    # Set up control to display a set of holidays:
    EVT_CALENDAR_MONTH(self, cal.GetId(), self.OnChangeMonth)
    
    self.holidays = [(1,1), (10,31), (12,25) ]    # (these don't move around)
    
    self.OnChangeMonth()        

#-------------------------------------------------------------------------        
    sizer1 = wxBoxSizer(wxVERTICAL)
    sizer2 = wxBoxSizer(wxHORIZONTAL)
 
    sizer1.Add(cal, 0, wxALIGN_CENTRE|wxALL, 5)

    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    sizer1.Add(line, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxRIGHT|wxTOP, 5)
    

    btn = wxButton(self, wxID_OK, "OK")
    btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    #btn.SetDefault()
    sizer2.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer1.AddSizer(sizer2, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer1)
    self.SetAutoLayout(True)
    sizer1.Fit(self)
</t>
<t tx="ekr.20050811141217.179">def OnCalSelected(self, evt):
    self.result = evt.GetDate()
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20050811141217.180">def OnChangeMonth(self, evt=None):
    cur_month = self.cal.GetDate().GetMonth() + 1   # convert wxDateTime 0-11 =&gt; 1-12
    for month, day in self.holidays:
        if month == cur_month:
            self.cal.SetHoliday(day)        
</t>
<t tx="ekr.20050811141217.181">def OnCloseWindow(self, event):
    #self.cal.Destroy
    #self.Destroy()
    print "I got to close window"
</t>
<t tx="ekr.20050811141217.182">def GetDate(self):
    return self.result
</t>
<t tx="ekr.20050811141217.183">class FindDialog(wxDialog):
    @others
</t>
<t tx="ekr.20050811141217.184">def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,120)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    self.FindText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))
         
    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(self.FindText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, "OK")
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.MatchCase = wxCheckBox(self, -1, "Match Case")
    self.MatchWhole = wxCheckBox(self, -1, "Match Whole Word")
    box_c = wxBoxSizer(wxVERTICAL)
    box_c.Add(self.MatchCase, 0, wxLEFT|wxBOTTOM, 5)
    box_c.Add(self.MatchWhole, 0, wxLEFT, 5)

    self.SearchNotes = wxCheckBox(self, -1, "Search Notes")
    self.SearchFinished = wxCheckBox(self, -1, "Search Finished")
    box_d = wxBoxSizer(wxVERTICAL)
    box_d.Add(self.SearchNotes, 0, wxLEFT|wxBOTTOM, 5)
    box_d.Add(self.SearchFinished, 0, wxLEFT, 5)

    box_e = wxBoxSizer(wxHORIZONTAL)
    box_e.AddSizer(box_c)
    box_e.AddSizer(box_d)

    sizer = wxBoxSizer(wxVERTICAL)
    sizer.AddSizer(box_a)
    sizer.AddSizer(box_e)

    self.SetSizer(sizer)

    EVT_BUTTON(self, wxID_OK, parent.FindString)


</t>
<t tx="ekr.20050811141217.185">class EvalDialog(wxDialog):
    @others
</t>
<t tx="ekr.20050811141217.186">def __init__(self, parent, caption, msg, pos=wxDefaultPosition, size=(300,80)):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)    

    EvalText = wxTextCtrl(self, -1, msg, wxDefaultPosition,(200,24))

         
    box_a = wxBoxSizer(wxHORIZONTAL)
    box_a.Add(EvalText, 1, wxALIGN_CENTER|wxALL, 5)

    box_b = wxBoxSizer(wxVERTICAL)        
    btn = wxButton(self, wxID_OK, "OK")
    box_b.Add(btn, 0, wxALIGN_CENTER|wxALL,5)
    btn.SetDefault()               

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box_b.Add(btn, 0, wxALIGN_CENTER)

    box_a.AddSizer(box_b)

    self.SetSizer(box_a)

    self.EvalText = EvalText
    self.parent = parent

    #EVT_BUTTON(self, wxID_OK, self.PostOKEvent)
    EVT_BUTTON(self, wxID_OK, parent.OnEvaluate)



</t>
<t tx="ekr.20050811141217.187">def PostOKEvent(self, evt=None):
    wxPostEvent(self.parent, evt)
</t>
<t tx="ekr.20050811141217.188">class LoggerDialog(wxDialog):
    @others</t>
<t tx="ekr.20050811141217.189">def __init__(self, parent, msg, caption, pos=(-1,-1), size=(500,300), dir=None):
    wxDialog.__init__(self, parent, -1, caption, pos, size)
    #if pos == (-1,-1):
        #self.CenterOnScreen(wxBOTH)
        
    if dir:
        self.dir = dir
    else:
        self.dir = os.getcwd()
        
    text = wxTextCtrl(self, -1, msg, (-1,-1), (450,250), wxTE_MULTILINE | wxTE_READONLY)

    sizer = wxBoxSizer(wxVERTICAL)
    box = wxBoxSizer(wxHORIZONTAL)        
    
    sizer.Add(text, 1, wxALIGN_CENTRE|wxALL, 5)

    btn = wxButton(self, wxID_OK, "Close")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()
    
    ID_SAVE = wxNewId()

    btn = wxButton(self, ID_SAVE, "Save to File")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)        

    sizer.AddSizer(box, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    self.SetSizer(sizer)
    self.SetAutoLayout(True)
    sizer.Fit(self)
    
    self.text = text
    
    EVT_BUTTON(self, ID_SAVE, self.OnSave)
</t>
<t tx="ekr.20050811141217.190">def OnSave(self, evt):
        
    path = os.path.join(self.dir, 'logfile.txt')
        
    f = file(path,'a')
    f.write(self.text.GetValue())
    f.close()

    dlg = wxMessageDialog(self,"Appended text to logfile.text", "Notice", wxICON_INFORMATION|wxOK)
    dlg.ShowModal()
    dlg.Destroy()
    
    self.text.Clear()
</t>
<t tx="ekr.20050811141217.191">class FinishedDialog(wxDialog):
    @others</t>
<t tx="ekr.20050811141217.192">def __init__(self, parent, title,
            pos=wxDefaultPosition,
            size=wxDefaultSize,
            style=wxCAPTION,
            days=0,
            spin_label="",
            check_label=""):
             
    wxDialog.__init__(self, parent, -1, title, pos, size)
    self.Centre()
    
    self.check = wxCheckBox(self, -1, check_label)
    
    if days == -1:
        self.check.SetValue(True)
        days = 0
    
    panel = wxPanel(self, -1, (-1,-1),(225,75))
    wxStaticText(panel, -1, spin_label,(15, 15))
    self.text = wxTextCtrl(panel, -1, str(days), (30, 50), (30, -1))
    h = self.text.GetSize().height
    self.spin = wxSpinButton(panel, -1, (56, 50), (h, h), wxSP_VERTICAL)
    wxStaticText(panel, -1, 'days',(76, 53))
    self.spin.SetRange(0, 14)
    self.spin.SetValue(days)
    
    H_sizer = wxBoxSizer(wxHORIZONTAL)
    
    line = wxStaticLine(self, -1, size = (20,-1), style = wxLI_HORIZONTAL)
    
    btn = wxButton(self, wxID_OK, "OK")
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    H_sizer.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    
    V_sizer = wxBoxSizer(wxVERTICAL)
    V_sizer.Add(panel,1,wxALIGN_CENTER|wxEXPAND)
    V_sizer.Add(-1,5)
    V_sizer.Add(self.check,0,wxALIGN_LEFT|wxALL,5)
    V_sizer.Add(line,0, wxGROW|wxALIGN_CENTER_VERTICAL|wxTOP, 5)
    V_sizer.AddSizer(H_sizer, 0, wxGROW|wxALIGN_CENTER_VERTICAL|wxALL, 5)
    
    self.SetSizer(V_sizer)
    self.SetAutoLayout(True)
    V_sizer.Fit(self)

    EVT_SPIN(self, self.spin.GetId(), self.OnSpin)
    EVT_CHECKBOX(self, self.check.GetId(), self.OnCheck)
    
    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)
        
    self.Layout() #doesn't appear necessary


</t>
<t tx="ekr.20050811141217.193">def OnSpin(self, evt):
    self.text.SetValue(str(evt.GetPosition()))</t>
<t tx="ekr.20050811141217.194">def OnCheck(self, evt=None):
    if self.check.GetValue():
        self.spin.Enable(False)
        self.text.Enable(False)
    else:
        self.spin.Enable(True)
        self.text.Enable(True)
</t>
<t tx="ekr.20050811141217.195">class TreeDialog(wxDialog):
    @others</t>
<t tx="ekr.20050811141217.196">def __init__(self, parent, caption, pos=wxDefaultPosition, size=(300,400), tree={}):
    wxDialog.__init__(self, parent, -1, caption, pos, size, style=wxSTAY_ON_TOP|wxCAPTION)

    TreeCtrl = wxTreeCtrl(self, -1, wxDefaultPosition, (300,400), wxTR_HAS_BUTTONS)    #|wxTR_HIDE_ROOT)#wxDefaultSize,
    
    sizer = wxBoxSizer(wxVERTICAL)
    sizer.Add(TreeCtrl, 1, wxALIGN_CENTER|wxALL, 5)

    box = wxBoxSizer(wxHORIZONTAL)
    btn = wxButton(self, wxID_OK, "OK")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)
    btn.SetDefault()

    btn = wxButton(self, wxID_CANCEL, "CANCEL")
    box.Add(btn, 0, wxALIGN_CENTRE|wxALL, 5)

    sizer.AddSizer(box)
    self.SetAutoLayout(1)
    self.SetSizer(sizer)

    il = wxImageList(16,16)
    
    fldridx = il.Add(wxBitmap('bitmaps\\folder.bmp'))
    fldropenidx = il.Add(wxBitmap('bitmaps\\folder_open.bmp'))
    listidx =  il.Add(wxBitmap('bitmaps\\list.bmp'))

    TreeCtrl.SetImageList(il)

    root = TreeCtrl.AddRoot("List Manager")
    TreeCtrl.SetItemImage(root, fldridx, wxTreeItemIcon_Normal)
    TreeCtrl.SetItemImage(root, fldropenidx, wxTreeItemIcon_Expanded)

    for host in tree:
        child = TreeCtrl.AppendItem(root, host)
        TreeCtrl.SetItemImage(child, fldridx, wxTreeItemIcon_Normal)
        TreeCtrl.SetItemImage(child, fldropenidx, wxTreeItemIcon_Expanded)
        for listname in tree[host]:
            last = TreeCtrl.AppendItem(child, listname)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Normal)
            TreeCtrl.SetItemImage(last, listidx, wxTreeItemIcon_Selected)

    TreeCtrl.Expand(root)

    self.TreeCtrl= TreeCtrl
    self.il = il #? prevents GC

    EVT_LEFT_DCLICK(TreeCtrl, self.OnLeftDClick)
</t>
<t tx="ekr.20050811141217.197">def OnLeftDClick(self, event=None):
    self.EndModal(wxID_OK)
</t>
<t tx="ekr.20050811141217.198">@ @rst-options
code_mode = True
@c

@language python
&lt;&lt; outlookAddin declarations &gt;&gt;
@others

if __name__ == '__main__':
    import win32com.server.register
    win32com.server.register.UseCommandLine(OutlookAddin)
    if "--unregister" in sys.argv:
        UnregisterAddin(OutlookAddin)
    else:
        RegisterAddin(OutlookAddin)</t>
<t tx="ekr.20050811141217.199"># This is mainly stolen from Mark Hammond's demo plugin for win32com.client
# A demo plugin for Microsoft Outlook (NOT Outlook Express)

from win32com import universal
from win32com.server.exception import COMException
from win32com.client import gencache, DispatchWithEvents
from win32com.client import Dispatch
import winerror
import pythoncom
from win32com.client import constants
import win32ui ##
import sys
from socket import *
import pickle

# Support for COM objects we use.
#sz comment gencache.EnsureModule makes sure you are using makepy if the makepy-derived
#file doesn't already exist
#but as long as you did run makepy then you should just be alble to do a normal dispatch

mod = gencache.EnsureModule('{00062FFF-0000-0000-C000-000000000046}', 0, 9, 0, bForDemand=True) # Outlook 9
gencache.EnsureModule('{2DF8D04C-5BFA-101B-BDE5-00AA0044DE52}', 0, 2, 1, bForDemand=True) # Office 9

# The TLB defining the interfaces we implement
universal.RegisterInterfaces('{AC0714F2-3D04-11D1-AE7D-00A0C90F26F4}', 0, 1, 0, ["_IDTExtensibility2"])

Target = 'mail_transfer'


</t>
<t tx="ekr.20050811141217.200">class ButtonEvent:
    @others
</t>
<t tx="ekr.20050811141217.201">def OnClick(self, button, cancel):
    #activeExplorer and MailTransferFolder are globals defined in OnConnection
    sel = activeExplorer.Selection

    for i in range(1,sel.Count+1):
        item = sel.Item(i)
        item.Move(MailTransferFolder)

    return cancel

</t>
<t tx="ekr.20050811141217.202">class FolderEvent:
    @others
</t>
<t tx="ekr.20050811141217.203">def OnItemAdd(self, item):
    try:
        s = socket(AF_INET,SOCK_STREAM)
        s.connect(('localhost', 8888))
        d = {}
        d['Parent.Name'] = item.Parent.Name
        d['SenderName'] = item.SenderName
        d['Subject'] = item.Subject
        d['Body'] = item.Body[:5000]
        d['CreationTime'] = item.CreationTime.Format()
        str = pickle.dumps(d)
        s.send(str) # ?Receive no more than 1024 bytes
        s.close()
        win32ui.MessageBox("Sent %s to ListManager"%item.Subject)
    except:
        pass
</t>
<t tx="ekr.20050811141217.204">class OutlookAddin:
    &lt;&lt; class OutlookAddin declarations &gt;&gt;
    @others
</t>
<t tx="ekr.20050811141217.205">_com_interfaces_ = ['_IDTExtensibility2']
_public_methods_ = []
_reg_clsctx_ = pythoncom.CLSCTX_INPROC_SERVER
_reg_clsid_ = "{0F47D9F3-598B-4d24-B7E3-92AC15ED27E2}"
_reg_progid_ = "Python.Test.OutlookAddin"
_reg_policy_spec_ = "win32com.server.policy.EventHandlerPolicy"
</t>
<t tx="ekr.20050811141217.206">def OnConnection(self, application, connectMode, addin, custom):
    global MailTransferFolder
    global activeExplorer
    # ActiveExplorer may be none when started without a UI (eg, WinCE synchronisation)
    activeExplorer = application.ActiveExplorer()
    if activeExplorer:
        bars = activeExplorer.CommandBars
        toolbar = bars.Item("Standard")
        item = toolbar.Controls.Add(Type=constants.msoControlButton, Temporary=True)
        item = self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #? just need this to be an ivar
        item.Caption="List Manager"
        item.TooltipText = "Click to move"
        item.Enabled = True
        #self.toolbarButton = DispatchWithEvents(item, ButtonEvent) #need something that won't get GC'd. Note Dispatch returns item

    ns = application.GetNamespace("MAPI")
    Folders = ns.Folders

    for i in range(1,len(Folders)+1):
        if Folders[i].Name.find("Mailbox") != -1:
            folders = Folders[i].Folders
            break
    else:
        win32ui.MessageBox("Can't find Mailbox!")
        return	
    
    for i in range(1,len(folders)+1):
        if folders[i].Name == Target:
            MailTransferFolder = folders[i]
            self.targetMailbox = DispatchWithEvents(folders[i].Items, FolderEvent) #? just need this to be an ivar
            win32ui.MessageBox("Enabled: %s\nOutlookAddin3"%Target)
            break
    else:
        win32ui.MessageBox("Could not find mail folder: %s\nOutlookAddin3"%Target)</t>
<t tx="ekr.20050811141217.207">def OnDisconnection(self, mode, custom):
    print "OnDisconnection"
</t>
<t tx="ekr.20050811141217.208">def OnAddInsUpdate(self, custom):
    print "OnAddInsUpdate", custom
</t>
<t tx="ekr.20050811141217.209">def OnStartupComplete(self, custom):
    print "OnStartupComplete", custom
</t>
<t tx="ekr.20050811141217.210">def OnBeginShutdown(self, custom):
    print "OnBeginShutdown", custom
</t>
<t tx="ekr.20050811141217.211">def RegisterAddin(klass):
    import _winreg
    key = _winreg.CreateKey(_winreg.HKEY_CURRENT_USER, "Software\\Microsoft\\Office\\Outlook\\Addins")
    subkey = _winreg.CreateKey(key, klass._reg_progid_)
    _winreg.SetValueEx(subkey, "CommandLineSafe", 0, _winreg.REG_DWORD, 0)
    _winreg.SetValueEx(subkey, "LoadBehavior", 0, _winreg.REG_DWORD, 3)
    _winreg.SetValueEx(subkey, "Description", 0, _winreg.REG_SZ, klass._reg_progid_)
    _winreg.SetValueEx(subkey, "FriendlyName", 0, _winreg.REG_SZ, klass._reg_progid_)
</t>
<t tx="ekr.20050811141217.212">def UnregisterAddin(klass):
    import _winreg
    try:
        _winreg.DeleteKey(_winreg.HKEY_CURRENT_USER, "Software\\Microsoft\\Office\\Outlook\\Addins\\" + klass._reg_progid_)
    except WindowsError:
        pass
</t>
<t tx="ekr.20050816172657">import sys
sys.path.append(r'c:\reportlab_1_20')

debug = True

@others

from reportlab.pdfgen import canvas
c = canvas.Canvas('hello.pdf')
for i in (10,50):
    text(c,'x'*10,i,i)
# pencil(c,text='Note')

key = 'key1'

c.bookmarkPage(key)
c.addOutlineEntry('OutlineEntry',key)


c.showPage()
c.save()</t>
<t tx="ekr.20050816181619">def text(c,text,i=100,j=100):
    c.drawString(i,j,text)</t>
<t tx="ekr.20050816181619.1">def pencil(canvas, text="No.2"):
    from reportlab.lib.colors import yellow, red, black,white
    from reportlab.lib.units import inch
    u = inch/10.0
    canvas.setStrokeColor(black)
    canvas.setLineWidth(4)
    # draw erasor
    canvas.setFillColor(red)
    canvas.circle(30*u, 5*u, 5*u, stroke=1, fill=1)
    # draw all else but the tip (mainly rectangles with different fills)
    canvas.setFillColor(yellow)
    canvas.rect(10*u,0,20*u,10*u, stroke=1, fill=1)
    canvas.setFillColor(black)
    canvas.rect(23*u,0,8*u,10*u,fill=1)
    canvas.roundRect(14*u, 3.5*u, 8*u, 3*u, 1.5*u, stroke=1, fill=1)
    canvas.setFillColor(white)
    canvas.rect(25*u,u,1.2*u,8*u, fill=1,stroke=0)
    canvas.rect(27.5*u,u,1.2*u,8*u, fill=1, stroke=0)
    canvas.setFont("Times-Roman", 3*u)
    canvas.drawCentredString(18*u, 4*u, text)
    # now draw the tip
    penciltip(canvas,debug=0)
    # draw broken lines across the body.
    canvas.setDash([10,5,16,10],0)
    canvas.line(11*u,2.5*u,22*u,2.5*u)
    canvas.line(22*u,7.5*u,12*u,7.5*u)
</t>
<t tx="ekr.20050816181813">def penciltip(canvas, debug=1):
    from reportlab.lib.colors import tan, black, green
    from reportlab.lib.units import inch
    u = inch/10.0
    canvas.setLineWidth(4)
    if debug:
        canvas.scale(2.8,2.8) # make it big
        canvas.setLineWidth(1) # small lines
    canvas.setStrokeColor(black)
    canvas.setFillColor(tan)
    p = canvas.beginPath()
    p.moveTo(10*u,0)
    p.lineTo(0,5*u)
    p.lineTo(10*u,10*u)
    p.curveTo(11.5*u,10*u, 11.5*u,7.5*u, 10*u,7.5*u)
    p.curveTo(12*u,7.5*u, 11*u,2.5*u, 9.7*u,2.5*u)
    p.curveTo(10.5*u,2.5*u, 11*u,0, 10*u,0)
    canvas.drawPath(p, stroke=1, fill=1)
    canvas.setFillColor(black)
    p = canvas.beginPath()
    p.moveTo(0,5*u)
    p.lineTo(4*u,3*u)
    p.lineTo(5*u,4.5*u)
    p.lineTo(3*u,6.5*u)
    canvas.drawPath(p, stroke=1, fill=1)
    if debug:
        canvas.setStrokeColor(green) # put in a frame of reference
        canvas.grid([0,5*u,10*u,15*u], [0,5*u,10*u])</t>
<t tx="ekr.20050817110133">########
Headline
########

@ @rst-options
.. These options have NO EFFECT for rst2 plugin!
code_mode=False
generate_rst=True
http_server_support = False
show_organizer_nodes=True
show_headlines=True
show_leo_directives=True
stylesheet_path=c:\prog\leoCVS\leo\doc
write_intermediate_file = True
verbose=True
@c

This is a test of pdf stuff

.. contents::</t>
<t tx="ekr.20050817110133.1"></t>
<t tx="ekr.20050817110133.2">child node text</t>
<t tx="ekr.20050821072028"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20050821072028.1">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050821081021"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20050821081021.1">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050824190822">@color

import ZODB
import ZODB.FileStorage

storage = ZODB.FileStorage.FileStorage(r"c:\prog\zopeTemp\leo.fs")
# g.trace(storage)
db = ZODB.DB(storage)
try:
    try:
        print '-' * 20
        print 'opening ZODB'
        connection = db.open()
        g.trace(connection)
        root = connection.root()
        if 1:
            t = get_transaction()
            t.begin()
            # root.clear()
            root ['count'] = root.get('count',0) + 1
            t.commit()
        g.trace(root)
        connection.close()
    except Exception:
        g.es_exception()
finally:
    print 'closing ZODB'
    db.close()
    </t>
<t tx="ekr.20050910194752">class colGroupClass:
    
    @others</t>
<t tx="ekr.20050910194752.1">def __init__ (self,sudoku,j):
    
    # g.trace('col',j)
    self.j = j
    self.main = sudoku
    
    # Set later...
    self.cells = []
    self.col = None
   </t>
<t tx="ekr.20050910194752.2">class rowGroupClass:
    
    @others</t>
<t tx="ekr.20050910194752.3">def __init__ (self,sudoku,i):
    
    # g.trace('row',i)
    self.i = i
    self.main = sudoku
    
    # Set later...
    self.cells = []
    self.row = None</t>
<t tx="ekr.20050910195107">def finishCreate(self):
    
    j = self.j ; main = self.main

    self.col = self.main.cols[j]
    
    self.cells = [cell for cell in main.cells if cell.j == j]

    for cell in self.cells:
        cell.colGroup = self</t>
<t tx="ekr.20050910195107.1">def finishCreate(self):

    i = self.i ; main = self.main

    self.row = self.main.rows[i]

    self.cells = [cell for cell in main.cells if cell.i == i]

    for cell in self.cells:
        cell.rowGroup = self</t>
<t tx="ekr.20050911085945">if self.level &lt; 2:
    # Save the previous data.
    save = [g.bunch(cell=cell,values=cell.values[:]) for cell in self.cells]
    guesses = self.findGuesses()
    if self.tracing:
        print '-'*20,'%d valid guesses' % len(guesses)
    if not guesses:
        return False
    n = 0
    for guess in guesses:
        # Restore the previous state.
        for b in save:
            b.cell.values = b.values[:]
        # Make the guess.
        self.level += 1 ; n += 1
        if self.tracing:
            print ; print '-'*40,'making guess %d at level %d' % (n,self.level)
        for b in guess:
            b.cell.values = str(b.val)
            if self.tracing: g.trace(b.cell,b.val)
        if self.tracing:
            self.printCells()
        # Call ourselves recursively.
        ok = self.solve()
        self.level -= 1
        if ok: return True
    if self.tracing or self.level == 0:
        print 'no solution is possible at level %d' % self.level
    # Restore the previous state.
    for b in save:
        b.cell.values = b.values[:]
    return False
else:
    if self.tracing:
        print 'maximum depth exceeded'
return False</t>
<t tx="ekr.20050911092707">def reduce (self):
    
    '''Reduce the possible values in self.values: remove an item from
    self.values if any cell in this cell's groups contains only that value.

    Increments self.main.progress or set self.main.valid = False to indicate status.
    '''
    
    if not self.main.valid: return
    n = len(self.values)
    if n == 0: self.main.valid = False
    if n &lt; 2:  return
        
    for group in (
        self.colGroup,
        self.rowGroup,
        self.squareGroup,
    ):
        for cell in group.cells:
            if (
                cell is not self and
                len(cell.values) == 1 and 
                cell.values[0] in self.values
            ):
                self.values.remove(cell.values[0])
                n -= 1 
                if n == 0:
                    self.main.valid = False
                    return
                if n == 1:
                    self.setValue(self.values[0])
                else:
                    self.main.progress += 1</t>
<t tx="ekr.20050911092707.1">def unique (self):
    
    '''Set self.values to [val] if val appears in only one place in any of this cells groups.
    
    Increments self.main.progress or set self.main.valid = False to indicate status.
    '''
    
    if not self.main.valid: return
    n = len(self.values)
    if n == 0: self.main.valid = False
    if n &lt; 2:  return
        
    for group in (
        self.colGroup,
        self.rowGroup,
        self.squareGroup,
    ):
        for val in self.values:
            spots = 0
            for cell in group.cells:
                if val in cell.values:
                    spots += 1
            # val is in self.values, and self is in each of its groups.
            assert(spots&gt;0)
            if spots == 1:
                # We have found the only possible place for this value.
                self.setValue(val) # Increments self.main.progress.
                return</t>
<t tx="ekr.20050911094544">def setValue (self,val):
    
    '''We have discovered the proper value for this cell.
    Set self.values=[val] and remove val from self.values from all *other* cells of this groups.'''
    
    values = self.values
    if self.main.tracing:
        g.trace(self,val,values)
    assert(val in values)
    values.remove(val)
    self.main.progress += 1
    self.values = [str(val)]
    
    for group in (
        self.colGroup,
        self.rowGroup,
        self.squareGroup,
    ):
        for cell in group.cells:
            if cell is not self:
                if val in cell.values:
                    cell.values.remove(str(val))
                    self.main.progress += 1
                    if len(cell.values) == 0:
                        self.main.valid = False</t>
<t tx="ekr.20050911094859"></t>
<t tx="ekr.20050911101819">class squareGroupClass:
    
    @others</t>
<t tx="ekr.20050911101819.1">def __repr__ (self):
    
    return '&lt;square group %d&gt;' % self.groupNumber
    
__str__ = __repr__</t>
<t tx="ekr.20050911102800">def __repr__ (self):
    
    return '&lt;col group %d&gt;' % self.j
    
__str__ = __repr__</t>
<t tx="ekr.20050911102800.1">def __repr__ (self):
    
    return '&lt;row group %d&gt;' % self.i
    
__str__ = __repr__</t>
<t tx="ekr.20050911111404"># This is about the most sophisticated deduction that a human could make.

def removeConflicts (self):
    
    '''Remove a possible value if assigning to this value would make it
    impossible to satisfy a related group.
    
    Increments self.main.progress or set self.main.valid = False to indicate status. '''
    
    if not self.main.valid: return
    n = len(self.values)
    if n == 0: self.main.valid = False
    if n &lt; 2:  return
    
    i,j = self.i,self.j
    
    colGroups = [group for group in self.colGroups if group != self.squareGroup]
    rowGroups = [group for group in self.rowGroups if group != self.squareGroup]
    
    # Check for row conflicts.
    for val in self.values:
        for group in rowGroups:
            spots = 0
            for cell in group.cells:
                if i != cell.i and val in cell.values:
                    spots += 1
            if spots == 0:
                self.trace('row conflict: cell: %s, val: %s, group %s' % (self,val,group))
                self.values.remove(val)
                n -= 1 ; self.main.progress += 1
                if n == 0:
                    self.main.valid = False
                return

    # Check for col conflicts.
    for val in self.values:
        for group in colGroups:
            spots = 0
            for cell in group.cells:
                if j != cell.j and val in cell.values:
                    spots += 1
            if spots == 0:
                self.trace('col conflict: cell: %s, val: %s, group %s' % (self,val,group))
                self.values.remove(val)
                n -= 1
                if n == 0:
                    self.main.valid = False
                if n == 1:
                    self.setValue(self.values[0])
                else:
                    self.main.progress += 1
                return</t>
<t tx="ekr.20050911112043.1"></t>
<t tx="ekr.20050911112043.2">def error (self,s):
    
    self.main.error(s)
    
def trace (self,s):
    
    self.main.trace(s)</t>
<t tx="ekr.20050911112310">c.save()</t>
<t tx="ekr.20050911113403">def finishCreate(self):
    
    # g.trace(self)
    assert(self.colGroup)
    assert(self.rowGroup)
    assert(self.squareGroup)

    self.colGroups = [group for group in self.main.squareGroups if self.j in group.colNumbers]
    self.rowGroups = [group for group in self.main.squareGroups if self.i in group.rowNumbers]</t>
<t tx="ekr.20050911123109"># Neither of these are solvable without guessing.

data = ( 
    '1x5xxx37x',
    'xxxxxx2xx',
    'x973xxx1x',
    'xxxx531x2',
    '3xx8x1xx4',
    '2x147xxxx',
    'x7xxx864x',
    'xx8xxxxxx',
    'x12xxx8x7') # 8/4 5 stars

data = ( 
    '2xxxx1834',
    'xxxx9xxxx',
    'x1x3xxx5x',
    'xx75xxxxx',
    '16xxxxx72',
    'xxxxx93xx',
    'x7xxx4x1x',
    'xxxx8xxxx',
    '8549xxxx3') # 8/9 5 stars (may be invalid)</t>
<t tx="ekr.20050911135016">@ A group is essentially just a collection of cells.</t>
<t tx="ekr.20050911144450"></t>
<t tx="ekr.20050911145104">data = (
    'x13xxxxx2',
    '6x2xx4xx8',
    '4xx3xxx6x',
    '2xx8xxxx7',
    'xxx715xxx',
    '9xxxx3xx4',
    'x2xxx1xx3',
    '1xx5xx4x9',
    '8xxxxx62x') # 9/10/05 4 stars</t>
<t tx="ekr.20050917082428"></t>
<t tx="ekr.20050917082428.1">part 1, line 1
part 2, line 2, no newline
</t>
<t tx="ekr.20050917082428.2">part 2, line 1, no newline
</t>
<t tx="ekr.20050917082428.3">part 3, line 1
part 3, line 2, newline
</t>
<t tx="ekr.20050927122648">data = (
    'x4735xxx9',
    'x5x8x93xx',
    'xx84xx12x',
    '12x57xxx8',
    '7x5xxx2x6',
    '3xxx82x17',
    'x12xx59xx',
    'xx92x6x4x',
    '4xxx1875x',
)

data = (
    '19xxx84xx',
    '7xxx9xxxx',
    'x5xxxx986',
    'x19xxxx6x',
    '8xxxxxxx5',
    'x6xxxx72x',
    '684xxxx3x',
    'xxxx2xxx7',
    'xx26xxx14',
)

data = (
    'xx2xx7xx9',
    'x8x249x3x',
    'x31xx572x',
    'xx9xx8xx1',
    'x65xxx847',
    '4xx7xx2xx',
    'x931xx65x',
    'x5x862x73',
    '8xx5xx4xx') # 1 star
        
data = ( # 8/10 1 star
    'x6xxx5x19',
    'x9x34xxxx',
    'x8x96x5xx',
    'xxx8x93x1',
    '8x9xxx4x7',
    '2x17x4xxx',
    'xx3x86x4x',
    'xxxx27x6x',
    '47x5xxx8x')</t>
<t tx="ekr.20050929065040">data = (
    'xxx395xxx',
    'xx5xx89x2',
    'xxxx2xxx5',
    '6x2xxxxx7',
    'x84xxx53x',
    '7xxxxx1x6',
    '3xxx6xxxx',
    '5x62xx7xx',
    'xxx831xxx',
)

data = ( # 8/6 2 stars
    '2x6xxxx49',
    'x37xx9xxx',
    '1xx7xxxx6',
    'xxx58x9xx',
    '7x5xxx8x4',
    'xx9x62xxx',
    '9xxxx4xx1',
    'xxx3xx49x',
    '41xxxx2x8')
        
data = (
    '9xx7x3xx6',
    'x87xx2xxx',
    '15xxxxx9x',
    'xxx6xx82x',
    'xx8xxx1xx',
    'x26xx8xxx',
    'x6xxxxx31',
    'xxx4xx97x',
    '4xx2x1xx8') # 8/30 2 stars
        
data = (
    '8xx3xxx7x',
    'xx57xxxxx',
    '9xx165x3x',
    '34xxxxxx9',
    'xxx5x4xxx',
    '7xxxxxx83',
    'x8x253xx4',
    'xxxxx65xx',
    'x2xxx1xx6',
) # 9/6/ 2 stars

data = ( 
    'x6x29xx8x',
    'xx8xxxx3x',
    'x1xx78xxx',
    'x217x9xx8',
    '6xxxxxxx3',
    '7xx6x492x',
    'xxx12xx4x',
    'x7xxxx3xx',
    'x5xx86x7x') # 2 stars</t>
<t tx="ekr.20050930124917">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20051010091827"></t>
<t tx="ekr.20051011211253">import Tkinter as Tk
import tkFont

images = {}

@others

h = 500 ; w = 900

top = Tk.Toplevel(None) ; top.title("Debugger")

outer = Tk.Frame(top,height=h,width=w)
outer.pack(expand=1,fill='both')

canvas = Tk.Canvas(outer,background='LightSteelBlue1',width=14)
canvas.pack(side='left',fill='y',expand=0)

text = Tk.Text(outer)
text.pack(side='left',fill='both',expand=1,pady=0,padx=0)

line_h = getLineHeight(text)
# print line_h
image = getImage('minusnode.gif',canvas)

y = line_h / 2 - 2
while y &lt; h:
    id = canvas.create_image(4,y,image=image,anchor="nw")
    y += line_h
</t>
<t tx="ekr.20051011213138">def getImage(name,canvas):
    
    icon = images.get(name)
    if icon: return icon
        
    try:
        fullname = g.os_path_join(g.app.loadDir,"..","Icons",name)
        fullname = g.os_path_normpath(fullname)
        image = Tk.PhotoImage(master=canvas,file=fullname)
        images [name] = image
        return image
    except:
        g.es("Exception loading: " + fullname)
        g.es_exception()
        return None</t>
<t tx="ekr.20051011215038">def getLineHeight (text):

    try:
        fontName = text.cget('font')
        font = tkFont.Font(font=fontName)
        metrics = font.metrics()
        return metrics ["linespace"]
    except Exception:
        g.es("exception setting outline line height")
        g.es_exception()
        return 20 # default</t>
<t tx="ekr.20051012104957"></t>
<t tx="ekr.20051013160521"># g.app.config.updateSettings(c)
g.es('test_setting',c.config.getBool('test_setting'))</t>
<t tx="ekr.20051013162226"></t>
<t tx="ekr.20051015065018"># This problem has been around forever.
print '-' * 40
# Yes. We *do* want to warn in c.config.exists.
print 'exists',g.app.config.exists(c,'showMinibuffer','bool')
val = c.config.getBool('showMinibuffer')
print 'bool:showMinibuffer',val
val = c.config.getShortcut('showMinibuffer')
print 'shortcut:showMinibuffer',val</t>
<t tx="ekr.20051015100336"></t>
<t tx="ekr.20051015103450">k = c.keyHandler

def f (event):
    g.es_print('Hello',color='purple')
    
def f2 (event):
    g.es_print('Hello2',color='purple')

k.registerCommand('print-hello','Alt-Ctrl-Shift-p',f)
k.registerCommand('print-hello2',None,f2)</t>
<t tx="ekr.20051016110449">c.frame.log.selectTab('Test')
g.es('Test',color='red')</t>
<t tx="ekr.20051016113248">c.frame.log.selectTab('Log')
g.es('Test',color='blue')</t>
<t tx="ekr.20051016174943">g.es('my-command',color='red')</t>
<t tx="ekr.20051016174943.1">print 'This is my command 3'</t>
<t tx="ekr.20051016205407">g.es('hi',color='red')</t>
<t tx="ekr.20051017093427">a

b

c
d

e</t>
<t tx="ekr.20051017104401"></t>
<t tx="ekr.20051018071924">	</t>
<t tx="ekr.20051020104412.37">import leoFind
import leoTkinterDialog
import Tkinter as Tk

@others

#c = self.c ; 
log = c.frame.log ; tabName = 'Find'

if log.frameDict.get(tabName):
    log.selectTab(tabName)
else:
    log.selectTab(tabName)
    f = log.frameDict.get(tabName)
    t = log.textDict.get(tabName)
    t.pack_forget()
    leoTkinterFindTab(c,f)
    # End of script causes the tab to be hidden.</t>
<t tx="ekr.20051020104805">class leoTkinterFindTab (leoFind.leoFind):

    """A class that implements Leo's tkinter find tab."""

    @others</t>
<t tx="ekr.20051020104805.1">if 0:
    @others</t>
<t tx="ekr.20051020104805.2">def destroySelf (self):
    
    self.top.destroy()</t>
<t tx="ekr.20051020104805.3"></t>
<t tx="ekr.20051020104805.4">def __init__(self,c,parentFrame):

    # Init the base class...
    leoFind.leoFind.__init__(self,c,title='Find Tab')
    
    &lt;&lt; create the tkinter intVars &gt;&gt;
    
    # These are created later.
    self.find_ctrl = None
    self.change_ctrl = None 

    self.createFrame(parentFrame)
    
    self.init(c) # New in 4.3: init only once.</t>
<t tx="ekr.20051020104805.5">self.dict = {}

for key in self.intKeys:
    self.dict[key] = Tk.IntVar()

for key in self.newStringKeys:
    self.dict[key] = Tk.StringVar()
    
self.s_ctrl = Tk.Text() # Used by find.search()</t>
<t tx="ekr.20051020104805.6">def createFrame (self,parentFrame):
    
    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; Create the Find and Change panes &gt;&gt;
    &lt;&lt; Create two columns of radio and checkboxes &gt;&gt;
    &lt;&lt; Create two rows of buttons &gt;&gt;
    
    for widget in (self.find_ctrl, self.change_ctrl):
        widget.bind ("&lt;1&gt;",  self.resetWrap)
        widget.bind("&lt;Key&gt;", self.resetWrap)
        widget.bind("&lt;Control-a&gt;",self.selectAllFindText)
        #widget.bind(g.virtual_event_name("SelectAll"),self.selectAllFindText)
    
    for widget in (outer, self.find_ctrl, self.change_ctrl):
        widget.bind("&lt;Key-Return&gt;", findButtonCallback)
        widget.bind("&lt;Key-Escape&gt;", self.onCloseWindow)</t>
<t tx="ekr.20051020104805.7">fc = Tk.Frame(outer, bd="1m")
fc.pack(anchor="n", fill="x", expand=1)

# Removed unused height/width params: using fractions causes problems in some locales!
fpane = Tk.Frame(fc, bd=1)
cpane = Tk.Frame(fc, bd=1)

fpane.pack(anchor="n", expand=1, fill="x")
cpane.pack(anchor="s", expand=1, fill="x")

# Create the labels and text fields...
flab = Tk.Label(fpane, width=8, text="Find:")
clab = Tk.Label(cpane, width=8, text="Change:")

# Use bigger boxes for scripts.
self.find_ctrl   = ftxt = Tk.Text(fpane,bd=1,relief="groove",height=2,width=15) # was height=4,width=20
self.change_ctrl = ctxt = Tk.Text(cpane,bd=1,relief="groove",height=2,width=15) # was height=4,width=20
&lt;&lt; Bind Tab and control-tab &gt;&gt;

if 0:# Add scrollbars.
    fBar = Tk.Scrollbar(fpane,name='findBar')
    cBar = Tk.Scrollbar(cpane,name='changeBar')
    
    for bar,txt in ((fBar,ftxt),(cBar,ctxt)):
        txt['yscrollcommand'] = bar.set
        bar['command'] = txt.yview
        bar.pack(side="right", fill="y")

flab.pack(side="left")
clab.pack(side="left")
ctxt.pack(side="right", expand=1, fill="x") # was 'both'
ftxt.pack(side="right", expand=1, fill="x") # was 'both'</t>
<t tx="ekr.20051020104805.8">def setFocus(w):
    w.focus_set()
    g.app.gui.setSelectionRange(w,"1.0","1.0")
    return "break"
    
def toFind(event,w=ftxt): return setFocus(w)
def toChange(event,w=ctxt): return setFocus(w)
    
def insertTab(w):
    data = g.app.gui.getSelectionRange(w)
    if data: start,end = data
    else: start = end = g.app.gui.getInsertPoint(w)
    g.app.gui.replaceSelectionRangeWithText(w,start,end,"\t")
    return "break"

def insertFindTab(event,w=ftxt): return insertTab(w)
def insertChangeTab(event,w=ctxt): return insertTab(w)

ftxt.bind("&lt;Tab&gt;",toChange)
ctxt.bind("&lt;Tab&gt;",toFind)
ftxt.bind("&lt;Control-Tab&gt;",insertFindTab)
ctxt.bind("&lt;Control-Tab&gt;",insertChangeTab)</t>
<t tx="ekr.20051020104805.9">columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(anchor="e",expand=1,padx="7p",pady="2p") # Don't fill.

numberOfColumns = 4 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    (self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    (self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    (self.dict["radio-find-type"],"&amp;Script Search","script-search")]
checkLists[0] = [
    ("Scrip&amp;t Change",self.dict["script_change"])]
checkLists[1] = [
    ("&amp;Whole Word",  self.dict["whole_word"]),
    ("&amp;Ignore Case", self.dict["ignore_case"]),
    ("Wrap &amp;Around", self.dict["wrap"]),
    ("&amp;Reverse",     self.dict["reverse"])]
radioLists[2] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &amp;Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None)] #,"selection-only")]
checkLists[2] = []
checkLists[3] = [
    ("Search &amp;Headline Text", self.dict["search_headline"]),
    ("Search &amp;Body Text",     self.dict["search_body"]),
    ("&amp;Mark Finds",           self.dict["mark_finds"]),
    ("Mark &amp;Changes",         self.dict["mark_changes"])]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020104805.10"># Create the button panes
buttons  = Tk.Frame(outer,bd=1)
buttons2 = Tk.Frame(outer,bd=1)
buttons.pack (anchor="n",expand=1,fill="x")
buttons2.pack(anchor="n",expand=1,fill="x")

# In 4.4 it's dubious to define these keys.  For example, Alt-x must be reserved!
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w
# HotKeys used for plain buttons (enter),d,g,t

def findButtonCallback(event=None):
    __pychecker__ = '--no-argsused' # the event param must be present.
    self.findButton()
    return 'break'

# Create the first row of buttons
findButton=Tk.Button(buttons,
    width=9,text="Find",bd=4,command=findButtonCallback) # The default.
findButton.pack(pady="1p",padx="25p",side="left")

if 1:
    incrementalBox = underlinedTkButton("check",buttons,
        anchor="w",text="Incremental")
        # Not yet.  This may affect the file format!
        # ,variable=self.dict['incremental'])
    incrementalBox.button.pack(pady="1p",side="left",expand=1)
    incrementalBox.bindHotKey(ftxt)
    incrementalBox.bindHotKey(ctxt)

findAllButton = underlinedTkButton("button",buttons,
    width=9,text="Find All",command=self.findAllButton)
findAllButton.button.pack(pady="1p",padx="25p",side="right",fill="x")
findAllButton.bindHotKey(ftxt)
findAllButton.bindHotKey(ctxt)

# Create the second row of buttons
changeButton = underlinedTkButton("button",buttons2,
    width=10,text="Change",command=self.changeButton)
changeButton.button.pack(pady="1p",padx="25p",side="left")
changeButton.bindHotKey(ftxt)
changeButton.bindHotKey(ctxt)

changeFindButton = underlinedTkButton("button",buttons2,
    text="Change, Then Find",command=self.changeThenFindButton)
changeFindButton.button.pack(pady="1p",side="left",expand=1)
changeFindButton.bindHotKey(ftxt)
changeFindButton.bindHotKey(ctxt)
    
changeAllButton = underlinedTkButton("button",buttons2,
    width=10,text="Change All",command=self.changeAllButton)
changeAllButton.button.pack(pady="1p",padx="25p",side="right")
changeAllButton.bindHotKey(ftxt)
changeAllButton.bindHotKey(ctxt)</t>
<t tx="ekr.20051020104805.11">def init (self,c):

    # N.B.: separate c.ivars are much more convenient than a dict.
    for key in self.intKeys:
        # New in 4.3: get ivars from @settings.
        val = c.config.getBool(key)
        setattr(self,key,val)
        val = g.choose(val,1,0) # Work around major Tk problem.
        self.dict[key].set(val)
        # g.trace(key,val)

    &lt;&lt; set find/change widgets &gt;&gt;
    &lt;&lt; set radio buttons from ivars &gt;&gt;</t>
<t tx="ekr.20051020104805.12">self.find_ctrl.delete("1.0","end")
self.change_ctrl.delete("1.0","end")

# New in 4.3: Get setting from @settings.
for w,setting,defaultText in (
    (self.find_ctrl,"find_text",'&lt;find pattern here&gt;'),
    (self.change_ctrl,"change_text",''),
):
    s = c.config.getString(setting)
    if not s: s = defaultText
    w.insert("end",s)</t>
<t tx="ekr.20051020104805.13">found = False
for var,setting in (
    ("pattern_match","pattern-search"),
    #("script_search","script-search")
):
    val = self.dict[var].get()
    if val:
        self.dict["radio-find-type"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-find-type"].set("plain-search")
    
found = False
for var,setting in (
    ("suboutline_only","suboutline-only"),
    ("node_only","node-only"),
    ("selection_only","selection-only")): # 11/9/03
    val = self.dict[var].get()
    if val:
        self.dict["radio-search-scope"].set(setting)
        found = True ; break
if not found:
    self.dict["radio-search-scope"].set("entire-outine")</t>
<t tx="ekr.20051020104805.14">def update_ivars (self):
    
    """Called just before doing a find to update ivars from the find panel."""

    for key in self.intKeys:
        val = self.dict[key].get()
        setattr(self, key, val) # No more _flag hack.
        # g.trace(key,val)

    # Set ivars from radio buttons. Convert these to 1 or 0.
    find_type = self.dict["radio-find-type"].get()
    self.pattern_match = g.choose(find_type == "pattern-search",1,0)
    self.script_search = g.choose(find_type == "script-search",1,0)

    search_scope = self.dict["radio-search-scope"].get()
    self.suboutline_only = g.choose(search_scope == "suboutline-only",1,0)
    self.node_only       = g.choose(search_scope == "node-only",1,0)
    self.selection       = g.choose(search_scope == "selection-only",1,0) # 11/9/03

    # New in 4.3: The caller is responsible for removing most trailing cruft.
    # Among other things, this allows Leo to search for a single trailing space.
    s = self.find_ctrl.get("1.0","end")
    s = g.toUnicode(s,g.app.tkEncoding)
    # g.trace(repr(s))
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    self.find_text = s

    s = self.change_ctrl.get("1.0","end")
    if s and s[-1] in ('\r','\n'):
        s = s[:-1]
    s = g.toUnicode(s,g.app.tkEncoding)
    self.change_text = s</t>
<t tx="ekr.20051020104805.15">def adjust_find_text(self,s):
    
    w = self.find_ctrl
    
    w.delete("1.0","end")
    w.insert("end",s)</t>
<t tx="ekr.20051020104805.16">def onCloseWindow(self,event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    self.top.withdraw()</t>
<t tx="ekr.20051020104805.17">def dismiss (self):
    
    self.top.withdraw()</t>
<t tx="ekr.20051020104805.18">def bringToFront (self):
    
    """Bring the tkinter Find Panel to the front."""
    
    c = self.c ; t = self.find_ctrl ; gui = g.app.gui
            
    self.top.withdraw() # Helps bring the window to the front.
    self.top.deiconify()
    self.top.lift()

    gui.set_focus(c,t,tag='bringToFront')
    
    # Apparently, the text can not be adjusted unless the widget has focus...
    s = t.get('1.0','end')
    if s and s[-1] in ('\n','\r'):
        t.delete('end-1c','end')

    # New in 4.3: don't highlight the stupid added trailing newline!
    gui.setTextSelection (t,"1.0","end-1c") # Thanks Rich.
    
    def setFocusCallback():
        # g.trace()
        gui.set_focus(c,t,tag='tkFind.bringToFront')
    
    # We must do this after other callbacks.  Sheesh.
    self.top.after(500,setFocusCallback)
</t>
<t tx="ekr.20051020104805.19">def selectAllFindText (self,event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    try:
        w = self.frame.focus_get()
        g.app.gui.setTextSelection(w,"1.0","end")
        return "break"
    except:
        return None # To keep pychecker happy.</t>
<t tx="ekr.20051020104805.20">def gui_search (self,t,*args,**keys):
    return t.search(*args,**keys)

def init_s_ctrl (self,s):
    t = self.s_ctrl	
    t.delete("1.0","end")
    t.insert("end",s)
    t.mark_set("insert",g.choose(self.reverse,"end","1.0"))
    return t</t>
<t tx="ekr.20051020105921">self.top = Tk.Frame(parentFrame)

if 1: # Left justify
    self.top.pack(side='left',fill='y',pady=10)
else:
    self.top.pack(side='top',pady=20)

self.frame = Tk.Frame(self.top)
self.frame.pack(side="top")

# Used for alignment.
outer = Tk.Frame(self.frame)
outer.pack(padx=2,pady=2)</t>
<t tx="ekr.20051020110046">class underlinedTkButton:
    
    @others</t>
<t tx="ekr.20051020110046.1">def __init__(self,buttonType,parent_widget,**keywords):

    self.buttonType = buttonType
    self.parent_widget = parent_widget
    self.hotKey = None
    text = keywords['text']

    &lt;&lt; set self.hotKey if '&amp;' is in the string &gt;&gt;

    # Create the button...
    if self.hotKey:
        keywords['text'] = text
        keywords['underline'] = index

    if buttonType.lower() == "button":
        self.button = Tk.Button(parent_widget,keywords)
    elif buttonType.lower() == "check":
        self.button = Tk.Checkbutton(parent_widget,keywords)
    elif buttonType.lower() == "radio":
        self.button = Tk.Radiobutton(parent_widget,keywords)
    else:
        g.trace("bad buttonType")
    
    self.text = text # for traces</t>
<t tx="ekr.20051020110046.2">index = text.find('&amp;')

if index &gt; -1:

    if index == len(text)-1:
        # The word ends in an ampersand.  Ignore it; there is no hot key.
        text = text[:-1]
    else:
        self.hotKey = text [index + 1]
        text = text[:index] + text[index+1:]</t>
<t tx="ekr.20051020110046.3">def bindHotKey (self,widget):
    
    if self.hotKey:
        for key in (self.hotKey.lower(),self.hotKey.upper()):
            widget.bind("&lt;Alt-%s&gt;" % key,self.buttonCallback)
</t>
<t tx="ekr.20051020110046.4"># The hot key has been hit.  Call the button's command.

def buttonCallback (self, event=None):
    
    __pychecker__ = '--no-argsused' # the event param must be present.

    # g.trace(self.text)

    self.button.invoke ()
    
    # See if this helps.
    return 'break'
</t>
<t tx="ekr.20051020111605">columnsFrame = Tk.Frame(outer,relief="groove",bd=2)
columnsFrame.pack(expand=1,padx="7p",pady="2p") # Use ,fill='x' to left justify

numberOfColumns = 2 # Number of columns
columns = [] ; radioLists = [] ; checkLists = []
for i in xrange(numberOfColumns):
    columns.append(Tk.Frame(columnsFrame,bd=1))
    radioLists.append([])
    checkLists.append([])

for i in xrange(numberOfColumns):
    columns[i].pack(side="left",padx="1p") # fill="y" Aligns to top. padx expands columns.
    
# HotKeys used for check/radio buttons:  a,b,c,e,h,i,l,m,n,o,p,r,s,t,w

radioLists[0] = [
    #(self.dict["radio-find-type"],"P&amp;Lain Search","plain-search"),  
    #(self.dict["radio-find-type"],"&amp;Pattern Match Search","pattern-search"),
    # (self.dict["radio-find-type"],"&amp;Script Search","script-search"),
]
checkLists[0] = [
    # ("Scrip&amp;t Change",self.dict["script_change"]),
    ("Whole Word",      self.dict["whole_word"]),
    ("Ignore Case",     self.dict["ignore_case"]),
    ("Wrap Around",     self.dict["wrap"]),
    ("Reverse",         self.dict["reverse"]),
    ('Regexp',          self.dict["radio-find-type"]=='pattern-search'),
    ("Search Headline", self.dict["search_headline"]),
    ("Search Body",     self.dict["search_body"]),
]

radioLists[1] = [
    (self.dict["radio-search-scope"],"&amp;Entire Outline","entire-outine"),
    (self.dict["radio-search-scope"],"Suboutline &amp;Only","suboutline-only"),  
    (self.dict["radio-search-scope"],"&amp;Node Only","node-only"),
    # I don't know what selection-only is supposed to do.
    (self.dict["radio-search-scope"],"Selection Only",None), #,"selection-only")
]
checkLists[1] = [
    ("&amp;Mark Finds",           self.dict["mark_finds"]),
    ("Mark &amp;Changes",         self.dict["mark_changes"]),
    ('Show Context',          self.dict['batch']),
]

for i in xrange(numberOfColumns):
    for var,name,val in radioLists[i]:
        box = underlinedTkButton("radio",columns[i],anchor="w",text=name,variable=var,value=val)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        if val == None: box.button.configure(state="disabled")
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
    for name,var in checkLists[i]:
        box = underlinedTkButton("check",columns[i],anchor="w",text=name,variable=var)
        box.button.pack(fill="x")
        box.button.bind("&lt;1&gt;", self.resetWrap)
        box.bindHotKey(ftxt)
        box.bindHotKey(ctxt)
        if var is None: box.button.configure(state="disabled")</t>
<t tx="ekr.20051020124457"></t>
<t tx="ekr.20051020124457.1">print c.searchCommands.c

c.searchCommands.openFindTab(event=None)</t>
</tnodes>
</leo_file>
