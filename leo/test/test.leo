<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="7897" clone_windows="0"/>
<globals body_outline_ratio="0.438470728793">
	<global_window_position top="122" left="401" height="641" width="803"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20041001211817" annotate="7d71002e"><vh>Buttons &amp; settings</vh>
<v t="ekr.20051020124457"><vh>Disabled buttons</vh>
<v t="ekr.20041230121429"><vh>@@ button pydoc</vh></v>
<v t="ekr.20050210180937"><vh>@@ button jython</vh></v>
<v t="ekr.20050704170739"><vh>@@button Ipython</vh></v>
<v t="ekr.20050821072028"><vh>@@button Lines Up</vh>
<v t="ekr.20050821072028.1"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20050821081021"><vh>@@button Lines Down</vh>
<v t="ekr.20050821081021.1" a="M"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20050930124917"><vh>@@button outlineToClipboard</vh></v>
<v t="ekr.20041001194357"><vh>@@button Unit Test</vh></v>
<v t="ekr.20051221091553"><vh>@@command dbl-click @key = Alt-Shift-C</vh></v>
<v t="ekr.20051219184032"><vh>@@button run timer</vh></v>
<v t="ekr.20051121143509"><vh>@@button shorten-lines</vh>
<v t="ekr.20051124065932"><vh>to do</vh></v>
<v t="ekr.20051121143951.1"><vh>splitLongLine</vh></v>
<v t="ekr.20051124080305"><vh>chooseBreakPoint</vh></v>
</v>
<v t="ekr.20060104162223"><vh>@@button file-mode</vh></v>
</v>
<v t="ekr.20051025070722"><vh>@button Beautify</vh></v>
<v t="ekr.20051105114247"><vh>@button scripts.leo</vh></v>
<v t="ekr.20051025091355"><vh>@button Spell</vh></v>
<v t="ekr.20050911112310"><vh>@button Save</vh></v>
<v t="ekr.20051201090822"><vh>@settings</vh>
<v t="ekr.20051201063427.1"><vh>@shortcuts</vh></v>
</v>
<v t="ekr.20060119121607"><vh>Run tcl script</vh>
<v t="ekr.20060119121607.1"><vh>@@button Run tcl  script</vh></v>
<v t="ekr.20060119121607.2"><vh>My first tcl script</vh></v>
<v t="ekr.20060119121607.3"><vh>My second tcl scrip, organized with noweb markup</vh>
<v t="ekr.20060119121607.4"><vh>the actual script</vh></v>
</v>
</v>
</v>
<v t="ekr.20051104081824" annotate="7d71002e"><vh>Tests</vh>
<v t="ekr.20051108102719"><vh>Test backward search</vh>
<v t="ekr.20051108102719.1"><vh>a</vh></v>
<v t="ekr.20051108102719.2"><vh>b</vh></v>
<v t="ekr.20051108102719.3"><vh>c</vh></v>
<v t="ekr.20051108111341"><vh>test</vh></v>
</v>
<v t="ekr.20051113055640"><vh>Find bug</vh>
<v t="ekr.20051113055640.1"><vh>Report</vh></v>
<v t="ekr.20051113055640.2"><vh>This is a sample node</vh></v>
<v t="ekr.20051113055640.3"><vh>@thin findBug.txt</vh></v>
</v>
<v t="ekr.20051120173510"><vh>@@button remove-blank-lines</vh></v>
<v t="ekr.20051121064026"><vh>@@button indent-relative</vh></v>
<v t="ekr.20051017093427"><vh>Test of remove-blank-lines</vh></v>
</v>
<v t="ekr.20051120173230" annotate="7d71002e"><vh>Prototypes</vh>
<v t="ekr.20051111114555"><vh>Subprocess tests</vh>
<v t="ekr.20051112134206.1"><vh>subprocess.py (For study, but not very helpful)</vh>
<v t="ekr.20051112134206.2"><vh>&lt;&lt; about this module &gt;&gt;</vh></v>
<v t="ekr.20051112134206.3"><vh>&lt;&lt;imports &gt;&gt;</vh></v>
<v t="ekr.20051112135040"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20051112134206.8"><vh>_cleanup</vh></v>
<v t="ekr.20051112134206.9"><vh>call</vh></v>
<v t="ekr.20051112134206.10"><vh>list2cmdline</vh></v>
<v t="ekr.20051112134206.11"><vh>class Popen</vh>
<v t="ekr.20051112134206.12"><vh>__init__</vh></v>
<v t="ekr.20051112134206.13"><vh>_translate_newlines</vh></v>
<v t="ekr.20051112135040.2"><vh>&lt;&lt; Windows methods &gt;&gt;</vh>
<v t="ekr.20051112134206.14"><vh>_get_handles</vh></v>
<v t="ekr.20051112135040.3"><vh>_make_inheritable</vh></v>
<v t="ekr.20051112135040.4"><vh>_find_w9xpopen</vh></v>
<v t="ekr.20051112135040.5"><vh>_execute_child</vh></v>
<v t="ekr.20051112135040.6"><vh>poll</vh></v>
<v t="ekr.20051112135040.7"><vh>wait</vh></v>
<v t="ekr.20051112135040.8"><vh>_readerthread</vh></v>
<v t="ekr.20051112135040.9"><vh>communicate</vh></v>
</v>
<v t="ekr.20051112135040.12"><vh>&lt;&lt; POSIX methods &gt;&gt;</vh>
<v t="ekr.20051112134206.15"><vh>_get_handles</vh></v>
<v t="ekr.20051112135040.13"><vh>_set_cloexec_flag</vh></v>
<v t="ekr.20051112135040.14"><vh>_close_fds</vh></v>
<v t="ekr.20051112135040.15"><vh>_execute_child</vh></v>
<v t="ekr.20051112135040.16"><vh>_handle_exitstatus</vh></v>
<v t="ekr.20051112135040.17"><vh>poll</vh></v>
<v t="ekr.20051112135040.18"><vh>wait</vh></v>
<v t="ekr.20051112135040.19"><vh>communicate</vh></v>
</v>
</v>
<v t="ekr.20051112134206.16"><vh>_demo_posix</vh></v>
<v t="ekr.20051112134206.17"><vh>_demo_windows</vh></v>
</v>
<v t="ekr.20051111143349.29"><vh>class debugCommandsClass (not used yet)</vh>
<v t="ekr.20051111143349.30"><vh> ctor</vh></v>
<v t="ekr.20051111143349.31"><vh>getPublicCommands (debugCommandsClass)</vh></v>
<v t="ekr.20051111143349.33"><vh>openDebugTab</vh></v>
<v t="ekr.20051111143349.20"><vh>hideTab</vh></v>
</v>
<v t="ekr.20051111114555.1"><vh>@thin leoDebugger.py</vh></v>
<v t="ekr.20051111114555.2"><vh>@@button dbProc</vh>
<v t="ekr.20051111145211.1"><vh>openDebugTab</vh></v>
<v t="ekr.20051111143349.1"><vh>class debugTab</vh>
<v t="ekr.20051111143349.2"><vh>Birth &amp; death</vh>
<v t="ekr.20051111143349.3"><vh>__init__</vh>
<v t="ekr.20051111143349.7"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051111143922"><vh>&lt;&lt; create buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051111143349.16"><vh>callbacks</vh>
<v t="ekr.20051111145134"><vh>askButtonCallback</vh></v>
<v t="ekr.20051111145134.1"><vh>killButtonCallback</vh></v>
<v t="ekr.20051111145134.2"><vh>runButtonCallback</vh></v>
<v t="ekr.20051111145134.3"><vh>tellButtonCallback</vh></v>
</v>
<v t="ekr.20051111151132"><vh>get &amp; send</vh></v>
<v t="ekr.20051111162912"><vh>nonBlockingRead</vh></v>
<v t="ekr.20051111153206"><vh>stdinClass (not used)</vh></v>
</v>
</v>
</v>
<v t="ekr.20051120173230.1"><vh>Server stuff</vh>
<v t="ekr.20051116122352"><vh>@thin c:\AppServ\www\php-test.php</vh></v>
<v t="ekr.20051116133640"><vh>@thin c:\AppServ\www\form.html</vh></v>
<v t="ekr.20051116133640.1"><vh>@thin c:\AppServ\www\welcome.php</vh></v>
</v>
<v t="ekr.20051120173230.2"><vh>Diff stuff</vh>
<v t="ekr.20051116222849"><vh>Tools/Scripts/diff.py</vh>
<v t="ekr.20051116222849.1"><vh>&lt;&lt; diff declarations &gt;&gt;</vh></v>
<v t="ekr.20051116222849.2"><vh>main</vh></v>
</v>
<v t="ekr.20051116222016.1"><vh>difflib.py</vh>
<v t="ekr.20051116222016.2"><vh>&lt;&lt; difflib declarations &gt;&gt;</vh></v>
<v t="ekr.20051116222016.3"><vh>_calculate_ratio</vh></v>
<v t="ekr.20051116222016.4" a="M"><vh>class SequenceMatcher</vh>
<v t="ekr.20051116222016.5"><vh>__init__</vh></v>
<v t="ekr.20051116222016.6"><vh>set_seqs</vh></v>
<v t="ekr.20051116222016.7"><vh>set_seq1</vh></v>
<v t="ekr.20051116222016.8"><vh>set_seq2</vh></v>
<v t="ekr.20051116222016.9"><vh>__chain_b</vh></v>
<v t="ekr.20051116222016.10"><vh>find_longest_match</vh></v>
<v t="ekr.20051116222016.11"><vh>get_matching_blocks</vh></v>
<v t="ekr.20051116222016.12"><vh>__helper</vh></v>
<v t="ekr.20051116222016.13"><vh>get_opcodes</vh></v>
<v t="ekr.20051116222016.14"><vh>get_grouped_opcodes</vh></v>
<v t="ekr.20051116222016.15"><vh>ratio</vh></v>
<v t="ekr.20051116222016.16"><vh>quick_ratio</vh></v>
<v t="ekr.20051116222016.17"><vh>real_quick_ratio</vh></v>
</v>
<v t="ekr.20051116222016.18"><vh>get_close_matches</vh></v>
<v t="ekr.20051116222016.19"><vh>_count_leading</vh></v>
<v t="ekr.20051116222016.20" a="M"><vh>class Differ</vh>
<v t="ekr.20051116222016.21"><vh>&lt;&lt; class Differ declarations &gt;&gt;</vh></v>
<v t="ekr.20051116222016.22"><vh>__init__</vh></v>
<v t="ekr.20051116222016.23"><vh>compare</vh></v>
<v t="ekr.20051116222016.24"><vh>_dump</vh></v>
<v t="ekr.20051116222016.25"><vh>_plain_replace</vh></v>
<v t="ekr.20051116222016.26"><vh>_fancy_replace</vh></v>
<v t="ekr.20051116222016.27"><vh>_fancy_helper</vh></v>
<v t="ekr.20051116222016.28"><vh>_qformat</vh></v>
</v>
<v t="ekr.20051116222016.29"><vh>IS_LINE_JUNK</vh></v>
<v t="ekr.20051116222016.30"><vh>IS_CHARACTER_JUNK</vh></v>
<v t="ekr.20051116222016.31" a="M"><vh>unified_diff</vh></v>
<v t="ekr.20051116222016.32" a="M"><vh>context_diff</vh></v>
<v t="ekr.20051116222016.33"><vh>ndiff</vh></v>
<v t="ekr.20051116222016.34"><vh>_mdiff</vh></v>
<v t="ekr.20051116222016.35"><vh>class HtmlDiff</vh>
<v t="ekr.20051116222016.36"><vh>&lt;&lt; class HtmlDiff declarations &gt;&gt;</vh></v>
<v t="ekr.20051116222016.37"><vh>__init__</vh></v>
<v t="ekr.20051116222016.38"><vh>make_file</vh></v>
<v t="ekr.20051116222016.39"><vh>_tab_newline_replace</vh></v>
<v t="ekr.20051116222016.40"><vh>_split_line</vh></v>
<v t="ekr.20051116222016.41"><vh>_line_wrapper</vh></v>
<v t="ekr.20051116222016.42"><vh>_collect_lines</vh></v>
<v t="ekr.20051116222016.43"><vh>_format_line</vh></v>
<v t="ekr.20051116222016.44"><vh>_make_prefix</vh></v>
<v t="ekr.20051116222016.45"><vh>_convert_flags</vh></v>
<v t="ekr.20051116222016.46"><vh>make_table</vh></v>
</v>
<v t="ekr.20051116222016.47"><vh>restore</vh></v>
<v t="ekr.20051116222016.48"><vh>_test</vh></v>
</v>
<v t="ekr.20051117095207"><vh>diff children</vh>
<v t="ekr.20051117095207.1"><vh>a</vh></v>
<v t="ekr.20051117095207.2"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20051130182536"><vh>IronPython stuff</vh>
<v t="ekr.20051130182536.1"><vh>batch file</vh>
<v t="ekr.20051130182412" tnodeList="ekr.20051130182412"><vh>@file ironPythonTest.bat</vh></v>
</v>
<v t="ekr.20051130181738" a="M" tnodeList="ekr.20051130181738"><vh>@file ironPythonTest.py</vh></v>
</v>
<v t="ekr.20051214093711"><vh>redemo</vh>
<v t="ekr.20060103102234"><vh>notes</vh></v>
<v t="ekr.20051214094526"><vh>createFrame</vh></v>
</v>
</v>
<v t="ekr.20051214100048" annotate="7d71002e"><vh>Recent tests</vh>
<v t="ekr.20051201153400"><vh>Print Hi</vh></v>
<v t="ekr.20051209074151"><vh>@read-only findBug.txt</vh></v>
<v t="ekr.20051209084028"><vh>@view findBug.txt</vh></v>
<v t="ekr.20060107082808"><vh>Error test</vh>
<v t="ekr.20060107082808.1"><vh>child</vh></v>
</v>
<v t="ekr.20060108113440"><vh>test of wiki markup</vh></v>
<v t="ekr.20060108160837"><vh>@run dir</vh></v>
<v t="ekr.20060108163923"><vh>For the fileactions plugin</vh>
<v t="ekr.20060108163323"><vh>FileActions</vh>
<v t="ekr.20060108163323.1"><vh>*</vh></v>
</v>
<v t="ekr.20060108163117"><vh>@file-ref c:\prog\leoCVS\leo\test\ironPythonTest.bat</vh></v>
</v>
<v t="ekr.20060113083051"><vh>Scrolling test</vh></v>
<v t="ekr.20060112062919"><vh>@@file commentTest.xml</vh></v>
<v t="ekr.20060113083051"><vh>Scrolling test</vh></v>
<v t="ekr.20060114164015"><vh>test editing state</vh></v>
<v t="ekr.20060119121607.5"><vh>tcl show bindings</vh></v>
<v t="ekr.20060119170038"><vh>python show bindings</vh></v>
<v t="ekr.20060119110527"><vh>Using bindtags</vh></v>
</v>
<v t="ekr.20060122115629" a="TV"><vh>Edit tests</vh></v>
</vnodes>
<tnodes>
<t tx="ekr.20041001194357"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(all=False)</t>
<t tx="ekr.20041001211817"></t>
<t tx="ekr.20041230121429">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20050210180937"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.headString()
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20050704170739">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20050821072028"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20050821072028.1">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050821081021"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20050821081021.1">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050911112310">c.save()
c.redraw_now() # Must be done here.</t>
<t tx="ekr.20050930124917">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20051017093427">a
 
b

c
d

e

This is a test of navigation.
</t>
<t tx="ekr.20051020124457"></t>
<t tx="ekr.20051025070722">c.prettyPrintPythonNode()</t>
<t tx="ekr.20051025091355">c.spellCommands.openSpellTab()
</t>
<t tx="ekr.20051104081824"></t>
<t tx="ekr.20051105114247">name = "scripts.leo"
fileName = g.os_path_join(g.app.loadDir,"..","scripts",name)
ok,frame = g.openWithFileName(fileName,c)
if not ok:
    g.es("not found: %s" % name)</t>
<t tx="ekr.20051108102719"></t>
<t tx="ekr.20051108102719.1">alpha</t>
<t tx="ekr.20051108102719.2">beta</t>
<t tx="ekr.20051108102719.3">gamma</t>
<t tx="ekr.20051108111341">test a test</t>
<t tx="ekr.20051111114555"></t>
<t tx="ekr.20051111114555.2"># Simulation of debugger process

import subprocess
import sys
import time
import Tkinter as Tk

@others

openDebugTab(c)</t>
<t tx="ekr.20051111143349.1">class debugTab:

    """A class that implements Leo's tkinter debug tab."""

    @others</t>
<t tx="ekr.20051111143349.2"></t>
<t tx="ekr.20051111143349.3">def __init__(self,c,parentFrame):

    self.c = c
    self.db = None

    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; create buttons &gt;&gt;
    </t>
<t tx="ekr.20051111143349.7">configName = 'log_pane_Debug_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.frame = Tk.Frame(self.top,background=bg)
self.outerFrame = outer = Tk.Frame(self.frame,background=bg)

self.top.pack   (side='top',expand=0,fill='x',pady=5)
    # Don't expand, so the frame goes to the top.

self.frame.pack (side="top",expand=1,fill='x')
outer.pack      (side='top',expand=1,fill='x',padx=2,pady=2,)</t>
<t tx="ekr.20051111143349.16"></t>
<t tx="ekr.20051111143349.20">def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051111143349.29">if 0:
    class debugCommandsClass (baseEditCommandsClass):
    
        '''Implements debug commands.'''
    
        @others</t>
<t tx="ekr.20051111143349.30">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.debugTabHandler = None</t>
<t tx="ekr.20051111143349.31">def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':    self.hideDebugTab,
        'open-debug-tab':   self.openDebugTab,
    }</t>
<t tx="ekr.20051111143349.33">def openDebugTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Debug'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.debugTabHandler = debugTab(c,f)</t>
<t tx="ekr.20051111143922">buttons  = Tk.Frame(outer,background=bg)
buttons.pack(side='top',expand=1)

width = 10

for text,callback in (
    ('Run', self.runButtonCallback),
    ('Kill',self.killButtonCallback),
    ('Ask', self.askButtonCallback),
    ('Tell',self.tellButtonCallback),
):
    w = Tk.Button(buttons,text=text,command=callback)
    w.configure(width=width)
    w.pack(side='left',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051111145134">def askButtonCallback (self,event=None):

    __pychecker__ = '--no-argsused'

    self.send('ask')
    print 'ask returns', self.get()

    return 'break'</t>
<t tx="ekr.20051111145134.1">def killButtonCallback (self,event=None):

    __pychecker__ = '--no-argsused'

    self.send('kill')

    if self.db:
        self.db.wait()
        self.db = None
        print ; print 'done!'

    return 'break'</t>
<t tx="ekr.20051111145134.2">def runButtonCallback (self,event=None):

    __pychecker__ = '--no-argsused'

    g.trace()

    dbPath = g.os_path_join('..','test','leoDebugger.py')
    args = [r"c:\python24\python", dbPath]
    pipe = subprocess.PIPE
    
    if self.db:
        g.trace('already running')
    else:
        self.db = subprocess.Popen(args,
            stdin=pipe,
            stdout=pipe, ## sys.stdout
            stderr=sys.stderr,
        )
        # stdout, stderr = self.db.communicate(s)

    return 'break'
</t>
<t tx="ekr.20051111145134.3">def tellButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'
    
    self.send('tell')

    return 'break'</t>
<t tx="ekr.20051111145211.1">def openDebugTab (c):

    log = c.frame.log ; tabName = 'Debug'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        debugTab(c,f)</t>
<t tx="ekr.20051111151132">if 0: # Communicate waits for the process to terminate!
    stdout, stderr = self.db.communicate(s)

def get(self):
    
    if self.db:
        # Busy waiting:
        while 1:
            time.sleep(0.4)
            s = self.nonBlockingRead(self.db.stdout)
            if s:
                return s
            else:
                g.trace('waiting for ask')
    else:
        g.trace('not running')
        return ''

def send(self,s):

    if self.db:
       self.db.stdin.write(s)
    else:
        g.trace('not running')</t>
<t tx="ekr.20051111153206">class stdinClass:
    
    '''A class for controlled stdin.'''
    
    def __init__ (self):
        self.s = ''
        
    def write (self,s):
        self.s = s
        
    def readline(self):
        s = self.s
        self.s = ''
        return s</t>
<t tx="ekr.20051111162912">def nonBlockingRead(self,f):
    
    f.seek(0,0) ; p1 = f.tell() # p1 is present position.
    f.seek(0,2) ; p2 = f.tell() # p2 is end position.

    if p2 &gt; p1:
        f.seek(p1,0) # Restore point
        s = f.read(p2-p1)
        f.seek(0,2) # Move to the end.
    else:
        s = ''

    return s</t>
<t tx="ekr.20051112134206.1">@language python
@tabwidth -4

&lt;&lt; about this module &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;

@others

if __name__ == "__main__":
    if mswindows:
        _demo_windows()
    else:
        _demo_posix()
</t>
<t tx="ekr.20051112134206.2"># subprocess - Subprocesses with accessible I/O streams
#
# For more information about this module, see PEP 324.
#
# Copyright (c) 2003-2004 by Peter Astrand &lt;astrand@lysator.liu.se&gt;
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of the
# author not be used in advertising or publicity pertaining to
# distribution of the software without specific, written prior
# permission.
#
# THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

r"""subprocess - Subprocesses with accessible I/O streams

This module allows you to spawn processes, connect to their
input/output/error pipes, and obtain their return codes.  This module
intends to replace several other, older modules and functions, like:

os.system
os.spawn*
os.popen*
popen2.*
commands.*

Information about how the subprocess module can be used to replace these
modules and functions can be found below.



Using the subprocess module
===========================
This module defines one class called Popen:

class Popen(args, bufsize=0, executable=None,
            stdin=None, stdout=None, stderr=None,
            preexec_fn=None, close_fds=False, shell=False,
            cwd=None, env=None, universal_newlines=False,
            startupinfo=None, creationflags=0):


Arguments are:

args should be a string, or a sequence of program arguments.  The
program to execute is normally the first item in the args sequence or
string, but can be explicitly set by using the executable argument.

On UNIX, with shell=False (default): In this case, the Popen class
uses os.execvp() to execute the child program.  args should normally
be a sequence.  A string will be treated as a sequence with the string
as the only item (the program to execute).

On UNIX, with shell=True: If args is a string, it specifies the
command string to execute through the shell.  If args is a sequence,
the first item specifies the command string, and any additional items
will be treated as additional shell arguments.

On Windows: the Popen class uses CreateProcess() to execute the child
program, which operates on strings.  If args is a sequence, it will be
converted to a string using the list2cmdline method.  Please note that
not all MS Windows applications interpret the command line the same
way: The list2cmdline is designed for applications using the same
rules as the MS C runtime.

bufsize, if given, has the same meaning as the corresponding argument
to the built-in open() function: 0 means unbuffered, 1 means line
buffered, any other positive value means use a buffer of
(approximately) that size.  A negative bufsize means to use the system
default, which usually means fully buffered.  The default value for
bufsize is 0 (unbuffered).

stdin, stdout and stderr specify the executed programs' standard
input, standard output and standard error file handles, respectively.
Valid values are PIPE, an existing file descriptor (a positive
integer), an existing file object, and None.  PIPE indicates that a
new pipe to the child should be created.  With None, no redirection
will occur; the child's file handles will be inherited from the
parent.  Additionally, stderr can be STDOUT, which indicates that the
stderr data from the applications should be captured into the same
file handle as for stdout.

If preexec_fn is set to a callable object, this object will be called
in the child process just before the child is executed.

If close_fds is true, all file descriptors except 0, 1 and 2 will be
closed before the child process is executed.

if shell is true, the specified command will be executed through the
shell.

If cwd is not None, the current directory will be changed to cwd
before the child is executed.

If env is not None, it defines the environment variables for the new
process.

If universal_newlines is true, the file objects stdout and stderr are
opened as a text files, but lines may be terminated by any of '\n',
the Unix end-of-line convention, '\r', the Macintosh convention or
'\r\n', the Windows convention.  All of these external representations
are seen as '\n' by the Python program.  Note: This feature is only
available if Python is built with universal newline support (the
default).  Also, the newlines attribute of the file objects stdout,
stdin and stderr are not updated by the communicate() method.

The startupinfo and creationflags, if given, will be passed to the
underlying CreateProcess() function.  They can specify things such as
appearance of the main window and priority for the new process.
(Windows only)


This module also defines two shortcut functions:

call(*args, **kwargs):
    Run command with arguments.  Wait for command to complete, then
    return the returncode attribute.

    The arguments are the same as for the Popen constructor.  Example:

    retcode = call(["ls", "-l"])


Exceptions
----------
Exceptions raised in the child process, before the new program has
started to execute, will be re-raised in the parent.  Additionally,
the exception object will have one extra attribute called
'child_traceback', which is a string containing traceback information
from the childs point of view.

The most common exception raised is OSError.  This occurs, for
example, when trying to execute a non-existent file.  Applications
should prepare for OSErrors.

A ValueError will be raised if Popen is called with invalid arguments.


Security
--------
Unlike some other popen functions, this implementation will never call
/bin/sh implicitly.  This means that all characters, including shell
metacharacters, can safely be passed to child processes.


Popen objects
=============
Instances of the Popen class have the following methods:

poll()
    Check if child process has terminated.  Returns returncode
    attribute.

wait()
    Wait for child process to terminate.  Returns returncode attribute.

communicate(input=None)
    Interact with process: Send data to stdin.  Read data from stdout
    and stderr, until end-of-file is reached.  Wait for process to
    terminate.  The optional stdin argument should be a string to be
    sent to the child process, or None, if no data should be sent to
    the child.

    communicate() returns a tuple (stdout, stderr).

    Note: The data read is buffered in memory, so do not use this
    method if the data size is large or unlimited.

The following attributes are also available:

stdin
    If the stdin argument is PIPE, this attribute is a file object
    that provides input to the child process.  Otherwise, it is None.

stdout
    If the stdout argument is PIPE, this attribute is a file object
    that provides output from the child process.  Otherwise, it is
    None.

stderr
    If the stderr argument is PIPE, this attribute is file object that
    provides error output from the child process.  Otherwise, it is
    None.

pid
    The process ID of the child process.

returncode
    The child return code.  A None value indicates that the process
    hasn't terminated yet.  A negative value -N indicates that the
    child was terminated by signal N (UNIX only).


Replacing older functions with the subprocess module
====================================================
In this section, "a ==&gt; b" means that b can be used as a replacement
for a.

Note: All functions in this section fail (more or less) silently if
the executed program cannot be found; this module raises an OSError
exception.

In the following examples, we assume that the subprocess module is
imported with "from subprocess import *".


Replacing /bin/sh shell backquote
---------------------------------
output=`mycmd myarg`
==&gt;
output = Popen(["mycmd", "myarg"], stdout=PIPE).communicate()[0]


Replacing shell pipe line
-------------------------
output=`dmesg | grep hda`
==&gt;
p1 = Popen(["dmesg"], stdout=PIPE)
p2 = Popen(["grep", "hda"], stdin=p1.stdout)
output = p2.communicate()[0]


Replacing os.system()
---------------------
sts = os.system("mycmd" + " myarg")
==&gt;
p = Popen("mycmd" + " myarg", shell=True)
sts = os.waitpid(p.pid, 0)

Note:

* Calling the program through the shell is usually not required.

* It's easier to look at the returncode attribute than the
  exitstatus.

A more real-world example would look like this:

try:
    retcode = call("mycmd" + " myarg", shell=True)
    if retcode &lt; 0:
        print &gt;&gt;sys.stderr, "Child was terminated by signal", -retcode
    else:
        print &gt;&gt;sys.stderr, "Child returned", retcode
except OSError, e:
    print &gt;&gt;sys.stderr, "Execution failed:", e


Replacing os.spawn*
-------------------
P_NOWAIT example:

pid = os.spawnlp(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg")
==&gt;
pid = Popen(["/bin/mycmd", "myarg"]).pid


P_WAIT example:

retcode = os.spawnlp(os.P_WAIT, "/bin/mycmd", "mycmd", "myarg")
==&gt;
retcode = call(["/bin/mycmd", "myarg"])


Vector example:

os.spawnvp(os.P_NOWAIT, path, args)
==&gt;
Popen([path] + args[1:])


Environment example:

os.spawnlpe(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg", env)
==&gt;
Popen(["/bin/mycmd", "myarg"], env={"PATH": "/usr/bin"})


Replacing os.popen*
-------------------
pipe = os.popen(cmd, mode='r', bufsize)
==&gt;
pipe = Popen(cmd, shell=True, bufsize=bufsize, stdout=PIPE).stdout

pipe = os.popen(cmd, mode='w', bufsize)
==&gt;
pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin


(child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize)
==&gt;
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdin, child_stdout) = (p.stdin, p.stdout)


(child_stdin,
 child_stdout,
 child_stderr) = os.popen3(cmd, mode, bufsize)
==&gt;
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
(child_stdin,
 child_stdout,
 child_stderr) = (p.stdin, p.stdout, p.stderr)


(child_stdin, child_stdout_and_stderr) = os.popen4(cmd, mode, bufsize)
==&gt;
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)


Replacing popen2.*
------------------
Note: If the cmd argument to popen2 functions is a string, the command
is executed through /bin/sh.  If it is a list, the command is directly
executed.

(child_stdout, child_stdin) = popen2.popen2("somestring", bufsize, mode)
==&gt;
p = Popen(["somestring"], shell=True, bufsize=bufsize
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdout, child_stdin) = (p.stdout, p.stdin)


(child_stdout, child_stdin) = popen2.popen2(["mycmd", "myarg"], bufsize, mode)
==&gt;
p = Popen(["mycmd", "myarg"], bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdout, child_stdin) = (p.stdout, p.stdin)

The popen2.Popen3 and popen3.Popen4 basically works as subprocess.Popen,
except that:

* subprocess.Popen raises an exception if the execution fails
* the capturestderr argument is replaced with the stderr argument.
* stdin=PIPE and stdout=PIPE must be specified.
* popen2 closes all filedescriptors by default, but you have to specify
  close_fds=True with subprocess.Popen.
"""</t>
<t tx="ekr.20051112134206.3">import sys
mswindows = (sys.platform == "win32")

import os
import types
import traceback

if mswindows:
    import threading
    import msvcrt
    if 0: # &lt;-- change this to use pywin32 instead of the _subprocess driver
        import pywintypes
        from win32api import GetStdHandle, STD_INPUT_HANDLE, \
                             STD_OUTPUT_HANDLE, STD_ERROR_HANDLE
        from win32api import GetCurrentProcess, DuplicateHandle, \
                             GetModuleFileName, GetVersion
        from win32con import DUPLICATE_SAME_ACCESS, SW_HIDE
        from win32pipe import CreatePipe
        from win32process import CreateProcess, STARTUPINFO, \
                                 GetExitCodeProcess, STARTF_USESTDHANDLES, \
                                 STARTF_USESHOWWINDOW, CREATE_NEW_CONSOLE
        from win32event import WaitForSingleObject, INFINITE, WAIT_OBJECT_0
    else:
        from _subprocess import *
        
        class STARTUPINFO:
            dwFlags = 0
            hStdInput = None
            hStdOutput = None
            hStdError = None
        class pywintypes:
            error = IOError
else:
    import select
    import errno
    import fcntl
    import pickle</t>
<t tx="ekr.20051112134206.8">def _cleanup():

    for inst in _active[:]:
        inst.poll()
</t>
<t tx="ekr.20051112134206.9">PIPE = -1
STDOUT = -2

def call(*args, **kwargs):
    """Run command with arguments.  Wait for command to complete, then
    return the returncode attribute.

    The arguments are the same as for the Popen constructor.  Example:

    retcode = call(["ls", "-l"])
    """
    return Popen(*args, **kwargs).wait()</t>
<t tx="ekr.20051112134206.10">def list2cmdline(seq):
    """
    Translate a sequence of arguments into a command line
    string, using the same rules as the MS C runtime:

    1) Arguments are delimited by white space, which is either a
       space or a tab.

    2) A string surrounded by double quotation marks is
       interpreted as a single argument, regardless of white space
       contained within.  A quoted string can be embedded in an
       argument.

    3) A double quotation mark preceded by a backslash is
       interpreted as a literal double quotation mark.

    4) Backslashes are interpreted literally, unless they
       immediately precede a double quotation mark.

    5) If backslashes immediately precede a double quotation mark,
       every pair of backslashes is interpreted as a literal
       backslash.  If the number of backslashes is odd, the last
       backslash escapes the next double quotation mark as
       described in rule 3.
    """

    # See
    # http://msdn.microsoft.com/library/en-us/vccelng/htm/progs_12.asp
    result = []
    needquote = False
    for arg in seq:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg)
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backspaces.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backspaces, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.append('"')

    return ''.join(result)
</t>
<t tx="ekr.20051112134206.11">class Popen(object):
    
	@others

    if mswindows:
        &lt;&lt; Windows methods &gt;&gt;
    else:
        &lt;&lt; POSIX methods &gt;&gt;</t>
<t tx="ekr.20051112134206.12">def __init__(self, args, bufsize=0, executable=None,
             stdin=None, stdout=None, stderr=None,
             preexec_fn=None, close_fds=False, shell=False,
             cwd=None, env=None, universal_newlines=False,
             startupinfo=None, creationflags=0):
    """Create new Popen instance."""
    _cleanup()

    if mswindows:
        if preexec_fn is not None:
            raise ValueError("preexec_fn is not supported on Windows "
                             "platforms")
        if close_fds:
            raise ValueError("close_fds is not supported on Windows "
                             "platforms")
    else:
        # POSIX
        if startupinfo is not None:
            raise ValueError("startupinfo is only supported on Windows "
                             "platforms")
        if creationflags != 0:
            raise ValueError("creationflags is only supported on Windows "
                             "platforms")

    self.stdin = None
    self.stdout = None
    self.stderr = None
    self.pid = None
    self.returncode = None
    self.universal_newlines = universal_newlines

    # Input and output objects. The general principle is like
    # this:
    #
    # Parent                   Child
    # ------                   -----
    # p2cwrite   ---stdin---&gt;  p2cread
    # c2pread    &lt;--stdout---  c2pwrite
    # errread    &lt;--stderr---  errwrite
    #
    # On POSIX, the child objects are file descriptors.  On
    # Windows, these are Windows file handles.  The parent objects
    # are file descriptors on both platforms.  The parent objects
    # are None when not using PIPEs. The child objects are None
    # when not redirecting.

    (p2cread, p2cwrite,
     c2pread, c2pwrite,
     errread, errwrite) = self._get_handles(stdin, stdout, stderr)

    self._execute_child(args, executable, preexec_fn, close_fds,
                        cwd, env, universal_newlines,
                        startupinfo, creationflags, shell,
                        p2cread, p2cwrite,
                        c2pread, c2pwrite,
                        errread, errwrite)

    if p2cwrite:
        self.stdin = os.fdopen(p2cwrite, 'wb', bufsize)
    if c2pread:
        if universal_newlines:
            self.stdout = os.fdopen(c2pread, 'rU', bufsize)
        else:
            self.stdout = os.fdopen(c2pread, 'rb', bufsize)
    if errread:
        if universal_newlines:
            self.stderr = os.fdopen(errread, 'rU', bufsize)
        else:
            self.stderr = os.fdopen(errread, 'rb', bufsize)

    _active.append(self)
</t>
<t tx="ekr.20051112134206.13">def _translate_newlines(self, data):
    
    data = data.replace("\r\n", "\n")
    data = data.replace("\r", "\n")
    return data
</t>
<t tx="ekr.20051112134206.14">def _get_handles(self, stdin, stdout, stderr):
    """Construct and return tupel with IO objects:
    p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
    """
    if stdin == None and stdout == None and stderr == None:
        return (None, None, None, None, None, None)

    p2cread, p2cwrite = None, None
    c2pread, c2pwrite = None, None
    errread, errwrite = None, None

    if stdin == None:
        p2cread = GetStdHandle(STD_INPUT_HANDLE)
    elif stdin == PIPE:
        p2cread, p2cwrite = CreatePipe(None, 0)
        # Detach and turn into fd
        p2cwrite = p2cwrite.Detach()
        p2cwrite = msvcrt.open_osfhandle(p2cwrite, 0)
    elif type(stdin) == types.IntType:
        p2cread = msvcrt.get_osfhandle(stdin)
    else:
        # Assuming file-like object
        p2cread = msvcrt.get_osfhandle(stdin.fileno())
    p2cread = self._make_inheritable(p2cread)

    if stdout == None:
        c2pwrite = GetStdHandle(STD_OUTPUT_HANDLE)
    elif stdout == PIPE:
        c2pread, c2pwrite = CreatePipe(None, 0)
        # Detach and turn into fd
        c2pread = c2pread.Detach()
        c2pread = msvcrt.open_osfhandle(c2pread, 0)
    elif type(stdout) == types.IntType:
        c2pwrite = msvcrt.get_osfhandle(stdout)
    else:
        # Assuming file-like object
        c2pwrite = msvcrt.get_osfhandle(stdout.fileno())
    c2pwrite = self._make_inheritable(c2pwrite)

    if stderr == None:
        errwrite = GetStdHandle(STD_ERROR_HANDLE)
    elif stderr == PIPE:
        errread, errwrite = CreatePipe(None, 0)
        # Detach and turn into fd
        errread = errread.Detach()
        errread = msvcrt.open_osfhandle(errread, 0)
    elif stderr == STDOUT:
        errwrite = c2pwrite
    elif type(stderr) == types.IntType:
        errwrite = msvcrt.get_osfhandle(stderr)
    else:
        # Assuming file-like object
        errwrite = msvcrt.get_osfhandle(stderr.fileno())
    errwrite = self._make_inheritable(errwrite)

    return (p2cread, p2cwrite,
            c2pread, c2pwrite,
            errread, errwrite)</t>
<t tx="ekr.20051112134206.15">def _get_handles(self, stdin, stdout, stderr):
    """Construct and return tupel with IO objects:
    p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
    """
    p2cread, p2cwrite = None, None
    c2pread, c2pwrite = None, None
    errread, errwrite = None, None

    if stdin == None:
        pass
    elif stdin == PIPE:
        p2cread, p2cwrite = os.pipe()
    elif type(stdin) == types.IntType:
        p2cread = stdin
    else:
        # Assuming file-like object
        p2cread = stdin.fileno()

    if stdout == None:
        pass
    elif stdout == PIPE:
        c2pread, c2pwrite = os.pipe()
    elif type(stdout) == types.IntType:
        c2pwrite = stdout
    else:
        # Assuming file-like object
        c2pwrite = stdout.fileno()

    if stderr == None:
        pass
    elif stderr == PIPE:
        errread, errwrite = os.pipe()
    elif stderr == STDOUT:
        errwrite = c2pwrite
    elif type(stderr) == types.IntType:
        errwrite = stderr
    else:
        # Assuming file-like object
        errwrite = stderr.fileno()

    return (p2cread, p2cwrite,
            c2pread, c2pwrite,
            errread, errwrite)</t>
<t tx="ekr.20051112134206.16">def _demo_posix():
    #
    # Example 1: Simple redirection: Get process list
    #
    plist = Popen(["ps"], stdout=PIPE).communicate()[0]
    print "Process list:"
    print plist

    #
    # Example 2: Change uid before executing child
    #
    if os.getuid() == 0:
        p = Popen(["id"], preexec_fn=lambda: os.setuid(100))
        p.wait()

    #
    # Example 3: Connecting several subprocesses
    #
    print "Looking for 'hda'    "
    p1 = Popen(["dmesg"], stdout=PIPE)
    p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
    print repr(p2.communicate()[0])

    #
    # Example 4: Catch execution error
    #
    print
    print "Trying a weird file    "
    try:
        print Popen(["/this/path/does/not/exist"]).communicate()
    except OSError, e:
        if e.errno == errno.ENOENT:
            print "The file didn't exist.  I thought so    "
            print "Child traceback:"
            print e.child_traceback
        else:
            print "Error", e.errno
    else:
        print &gt;&gt;sys.stderr, "Gosh.  No error."
</t>
<t tx="ekr.20051112134206.17">def _demo_windows():
    #
    # Example 1: Connecting several subprocesses
    #
    print "Looking for 'PROMPT' in set output    "
    p1 = Popen("set", stdout=PIPE, shell=True)
    p2 = Popen('find "PROMPT"', stdin=p1.stdout, stdout=PIPE)
    print repr(p2.communicate()[0])

    #
    # Example 2: Simple execution of program
    #
    print "Executing calc    "
    p = Popen("calc")
    p.wait()
</t>
<t tx="ekr.20051112135040">__all__ = ["Popen", "PIPE", "STDOUT", "call"]

try:
    MAXFD = os.sysconf("SC_OPEN_MAX")
except:
    MAXFD = 256

# True/False does not exist on 2.2.0
try:
    False
except NameError:
    False = 0
    True = 1

_active = []</t>
<t tx="ekr.20051112135040.2">@others</t>
<t tx="ekr.20051112135040.3">def _make_inheritable(self, handle):
    
    """Return a duplicate of handle, which is inheritable"""

    return DuplicateHandle(GetCurrentProcess(), handle,
                           GetCurrentProcess(), 0, 1,
                           DUPLICATE_SAME_ACCESS)</t>
<t tx="ekr.20051112135040.4">def _find_w9xpopen(self):
    
    """Find and return absolut path to w9xpopen.exe"""

    w9xpopen = os.path.join(os.path.dirname(GetModuleFileName(0)),
                            "w9xpopen.exe")
    if not os.path.exists(w9xpopen):
        # Eeek - file-not-found - possibly an embedding
        # situation - see if we can locate it in sys.exec_prefix
        w9xpopen = os.path.join(os.path.dirname(sys.exec_prefix),
                                "w9xpopen.exe")
        if not os.path.exists(w9xpopen):
            raise RuntimeError("Cannot locate w9xpopen.exe, which is "
                               "needed for Popen to work with your "
                               "shell or platform.")
    return w9xpopen</t>
<t tx="ekr.20051112135040.5">def _execute_child(self, args, executable, preexec_fn, close_fds,
                   cwd, env, universal_newlines,
                   startupinfo, creationflags, shell,
                   p2cread, p2cwrite,
                   c2pread, c2pwrite,
                   errread, errwrite):
    """Execute program (MS Windows version)"""

    if not isinstance(args, types.StringTypes):
        args = list2cmdline(args)

    # Process startup details
    default_startupinfo = STARTUPINFO()
    if startupinfo == None:
        startupinfo = default_startupinfo
    if not None in (p2cread, c2pwrite, errwrite):
        startupinfo.dwFlags |= STARTF_USESTDHANDLES
        startupinfo.hStdInput = p2cread
        startupinfo.hStdOutput = c2pwrite
        startupinfo.hStdError = errwrite

    if shell:
        default_startupinfo.dwFlags |= STARTF_USESHOWWINDOW
        default_startupinfo.wShowWindow = SW_HIDE
        comspec = os.environ.get("COMSPEC", "cmd.exe")
        args = comspec + " /c " + args
        if (GetVersion() &gt;= 0x80000000L or
                os.path.basename(comspec).lower() == "command.com"):
            # Win9x, or using command.com on NT. We need to
            # use the w9xpopen intermediate program. For more
            # information, see KB Q150956
            # (http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp)
            w9xpopen = self._find_w9xpopen()
            args = '"%s" %s' % (w9xpopen, args)
            # Not passing CREATE_NEW_CONSOLE has been known to
            # cause random failures on win9x.  Specifically a
            # dialog: "Your program accessed mem currently in
            # use at xxx" and a hopeful warning about the
            # stability of your system.  Cost is Ctrl+C wont
            # kill children.
            creationflags |= CREATE_NEW_CONSOLE

    # Start the process
    try:
        hp, ht, pid, tid = CreateProcess(executable, args,
                                 # no special security
                                 None, None,
                                 # must inherit handles to pass std
                                 # handles
                                 1,
                                 creationflags,
                                 env,
                                 cwd,
                                 startupinfo)
    except pywintypes.error, e:
        # Translate pywintypes.error to WindowsError, which is
        # a subclass of OSError.  FIXME: We should really
        # translate errno using _sys_errlist (or simliar), but
        # how can this be done from Python?
        raise WindowsError(*e.args)

    # Retain the process handle, but close the thread handle
    self._handle = hp
    self.pid = pid
    ht.Close()

    # Child is launched. Close the parent's copy of those pipe
    # handles that only the child should have open.  You need
    # to make sure that no handles to the write end of the
    # output pipe are maintained in this process or else the
    # pipe will not close when the child process exits and the
    # ReadFile will hang.
    if p2cread != None:
        p2cread.Close()
    if c2pwrite != None:
        c2pwrite.Close()
    if errwrite != None:
        errwrite.Close()</t>
<t tx="ekr.20051112135040.6">def poll(self):
    """Check if child process has terminated.  Returns returncode
    attribute."""
    if self.returncode == None:
        if WaitForSingleObject(self._handle, 0) == WAIT_OBJECT_0:
            self.returncode = GetExitCodeProcess(self._handle)
            _active.remove(self)
    return self.returncode</t>
<t tx="ekr.20051112135040.7">def wait(self):
    """Wait for child process to terminate.  Returns returncode
    attribute."""
    if self.returncode == None:
        obj = WaitForSingleObject(self._handle, INFINITE)
        self.returncode = GetExitCodeProcess(self._handle)
        _active.remove(self)
    return self.returncode</t>
<t tx="ekr.20051112135040.8">def _readerthread(self, fh, buffer):

    buffer.append(fh.read())
</t>
<t tx="ekr.20051112135040.9">def communicate(self, input=None):
    """Interact with process: Send data to stdin.  Read data from
    stdout and stderr, until end-of-file is reached.  Wait for
    process to terminate.  The optional input argument should be a
    string to be sent to the child process, or None, if no data
    should be sent to the child.

    communicate() returns a tuple (stdout, stderr)."""
    stdout = None # Return
    stderr = None # Return

    if self.stdout:
        stdout = []
        stdout_thread = threading.Thread(target=self._readerthread,
                                         args=(self.stdout, stdout))
        stdout_thread.setDaemon(True)
        stdout_thread.start()
    if self.stderr:
        stderr = []
        stderr_thread = threading.Thread(target=self._readerthread,
                                         args=(self.stderr, stderr))
        stderr_thread.setDaemon(True)
        stderr_thread.start()

    if self.stdin:
        if input != None:
            self.stdin.write(input)
        self.stdin.close()

    if self.stdout:
        stdout_thread.join()
    if self.stderr:
        stderr_thread.join()

    # All data exchanged.  Translate lists into strings.
    if stdout != None:
        stdout = stdout[0]
    if stderr != None:
        stderr = stderr[0]

    # Translate newlines, if requested.  We cannot let the file
    # object do the translation: It is based on stdio, which is
    # impossible to combine with select (unless forcing no
    # buffering).
    if self.universal_newlines and hasattr(open, 'newlines'):
        if stdout:
            stdout = self._translate_newlines(stdout)
        if stderr:
            stderr = self._translate_newlines(stderr)

    self.wait()
    return (stdout, stderr)</t>
<t tx="ekr.20051112135040.12">@others</t>
<t tx="ekr.20051112135040.13">def _set_cloexec_flag(self, fd):
    try:
        cloexec_flag = fcntl.FD_CLOEXEC
    except AttributeError:
        cloexec_flag = 1

    old = fcntl.fcntl(fd, fcntl.F_GETFD)
    fcntl.fcntl(fd, fcntl.F_SETFD, old | cloexec_flag)</t>
<t tx="ekr.20051112135040.14">def _close_fds(self, but):
    for i in range(3, MAXFD):
        if i == but:
            continue
        try:
            os.close(i)
        except:
            pass</t>
<t tx="ekr.20051112135040.15">def _execute_child(self, args, executable, preexec_fn, close_fds,
                   cwd, env, universal_newlines,
                   startupinfo, creationflags, shell,
                   p2cread, p2cwrite,
                   c2pread, c2pwrite,
                   errread, errwrite):
    """Execute program (POSIX version)"""

    if isinstance(args, types.StringTypes):
        args = [args]

    if shell:
        args = ["/bin/sh", "-c"] + args

    if executable == None:
        executable = args[0]

    # For transferring possible exec failure from child to parent
    # The first char specifies the exception type: 0 means
    # OSError, 1 means some other error.
    errpipe_read, errpipe_write = os.pipe()
    self._set_cloexec_flag(errpipe_write)

    self.pid = os.fork()
    if self.pid == 0:
        # Child
        try:
            # Close parent's pipe ends
            if p2cwrite:
                os.close(p2cwrite)
            if c2pread:
                os.close(c2pread)
            if errread:
                os.close(errread)
            os.close(errpipe_read)

            # Dup fds for child
            if p2cread:
                os.dup2(p2cread, 0)
            if c2pwrite:
                os.dup2(c2pwrite, 1)
            if errwrite:
                os.dup2(errwrite, 2)

            # Close pipe fds.  Make sure we doesn't close the same
            # fd more than once.
            if p2cread:
                os.close(p2cread)
            if c2pwrite and c2pwrite not in (p2cread,):
                os.close(c2pwrite)
            if errwrite and errwrite not in (p2cread, c2pwrite):
                os.close(errwrite)

            # Close all other fds, if asked for
            if close_fds:
                self._close_fds(but=errpipe_write)

            if cwd != None:
                os.chdir(cwd)

            if preexec_fn:
                apply(preexec_fn)

            if env == None:
                os.execvp(executable, args)
            else:
                os.execvpe(executable, args, env)

        except:
            exc_type, exc_value, tb = sys.exc_info()
            # Save the traceback and attach it to the exception object
            exc_lines = traceback.format_exception(exc_type,
                                                   exc_value,
                                                   tb)
            exc_value.child_traceback = ''.join(exc_lines)
            os.write(errpipe_write, pickle.dumps(exc_value))

        # This exitcode won't be reported to applications, so it
        # really doesn't matter what we return.
        os._exit(255)

    # Parent
    os.close(errpipe_write)
    if p2cread and p2cwrite:
        os.close(p2cread)
    if c2pwrite and c2pread:
        os.close(c2pwrite)
    if errwrite and errread:
        os.close(errwrite)

    # Wait for exec to fail or succeed; possibly raising exception
    data = os.read(errpipe_read, 1048576) # Exceptions limited to 1 MB
    os.close(errpipe_read)
    if data != "":
        child_exception = pickle.loads(data)
        raise child_exception</t>
<t tx="ekr.20051112135040.16">def _handle_exitstatus(self, sts):
    if os.WIFSIGNALED(sts):
        self.returncode = -os.WTERMSIG(sts)
    elif os.WIFEXITED(sts):
        self.returncode = os.WEXITSTATUS(sts)
    else:
        # Should never happen
        raise RuntimeError("Unknown child exit status!")

    _active.remove(self)</t>
<t tx="ekr.20051112135040.17">def poll(self):
    """Check if child process has terminated.  Returns returncode
    attribute."""
    if self.returncode == None:
        try:
            pid, sts = os.waitpid(self.pid, os.WNOHANG)
            if pid == self.pid:
                self._handle_exitstatus(sts)
        except os.error:
            pass
    return self.returncode</t>
<t tx="ekr.20051112135040.18">def wait(self):
    """Wait for child process to terminate.  Returns returncode
    attribute."""
    if self.returncode == None:
        pid, sts = os.waitpid(self.pid, 0)
        self._handle_exitstatus(sts)
    return self.returncode</t>
<t tx="ekr.20051112135040.19">def communicate(self, input=None):
    """Interact with process: Send data to stdin.  Read data from
    stdout and stderr, until end-of-file is reached.  Wait for
    process to terminate.  The optional input argument should be a
    string to be sent to the child process, or None, if no data
    should be sent to the child.

    communicate() returns a tuple (stdout, stderr)."""
    read_set = []
    write_set = []
    stdout = None # Return
    stderr = None # Return

    if self.stdin:
        # Flush stdio buffer.  This might block, if the user has
        # been writing to .stdin in an uncontrolled fashion.
        self.stdin.flush()
        if input:
            write_set.append(self.stdin)
        else:
            self.stdin.close()
    if self.stdout:
        read_set.append(self.stdout)
        stdout = []
    if self.stderr:
        read_set.append(self.stderr)
        stderr = []

    while read_set or write_set:
        rlist, wlist, xlist = select.select(read_set, write_set, [])

        if self.stdin in wlist:
            # When select has indicated that the file is writable,
            # we can write up to PIPE_BUF bytes without risk
            # blocking.  POSIX defines PIPE_BUF &gt;= 512
            bytes_written = os.write(self.stdin.fileno(), input[:512])
            input = input[bytes_written:]
            if not input:
                self.stdin.close()
                write_set.remove(self.stdin)

        if self.stdout in rlist:
            data = os.read(self.stdout.fileno(), 1024)
            if data == "":
                self.stdout.close()
                read_set.remove(self.stdout)
            stdout.append(data)

        if self.stderr in rlist:
            data = os.read(self.stderr.fileno(), 1024)
            if data == "":
                self.stderr.close()
                read_set.remove(self.stderr)
            stderr.append(data)

    # All data exchanged.  Translate lists into strings.
    if stdout != None:
        stdout = ''.join(stdout)
    if stderr != None:
        stderr = ''.join(stderr)

    # Translate newlines, if requested.  We cannot let the file
    # object do the translation: It is based on stdio, which is
    # impossible to combine with select (unless forcing no
    # buffering).
    if self.universal_newlines and hasattr(open, 'newlines'):
        if stdout:
            stdout = self._translate_newlines(stdout)
        if stderr:
            stderr = self._translate_newlines(stderr)

    self.wait()
    return (stdout, stderr)</t>
<t tx="ekr.20051113055640"></t>
<t tx="ekr.20051113055640.1">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3425131
By: yarkot

OK - This is _STILL_ happening w 4.4a3, and on a different (windows) computer,
with a clean installed system, and with a different underlying Python.

So that YOU can reproduce (or not) your self:

Here is the process:

Create a test leo file, with 3 nodes (reproduced as best I can here w/o being
able to paste clippings):

-----

[ ] This is a sample node
[-] @thin sample.txt
    [ ] Test node

-----

@thin contains:
-------------
@
@c
@others
---------------

Enable the "find"tab;

[ ] Test   node contains this:

---------------
This is a test.
This is the first test line;
This is just some line.
This is the second test line.
------------------------

Go to "@thin" node;  
enter "test" as search string in find tab;
Click "FIND" button once (we'll keep that line);
Click "FIND" a second time (delete this entire line);

Now contents of "Test" node is:
----------------
This is a test.
This is just some line.
This is the second test line.
----------------

and the cursor is at the front of "some line" (the middle line);

Now Click "FIND" again in the find tab;  NOW the contents of "Test" node is:
------------------
This is a test.
This is the first test line;
This is just some line.
This is the second test line.
----------------
With find causing "test" on the second line to be selected ("FIND" resurrected
this line "from somewhere") .

This is w/ Python 2.4.2 (same behavior was w/ 2.3.5 w/ Leo 4.4.a2, on a different
computer).

Both are windows XP machines.</t>
<t tx="ekr.20051113055640.2"></t>
<t tx="ekr.20051116222016.1">@language python
@tabwidth -4
&lt;&lt; difflib declarations &gt;&gt;
@others

if __name__ == "__main__":
    _test()
</t>
<t tx="ekr.20051116222016.2">#! /usr/bin/env python

"""
Module difflib -- helpers for computing deltas between objects.

Function get_close_matches(word, possibilities, n=3, cutoff=0.6):
    Use SequenceMatcher to return list of the best "good enough" matches.

Function context_diff(a, b):
    For two lists of strings, return a delta in context diff format.

Function ndiff(a, b):
    Return a delta: the difference between `a` and `b` (lists of strings).

Function restore(delta, which):
    Return one of the two sequences that generated an ndiff delta.

Function unified_diff(a, b):
    For two lists of strings, return a delta in unified diff format.

Class SequenceMatcher:
    A flexible class for comparing pairs of sequences of any type.

Class Differ:
    For producing human-readable deltas from sequences of lines of text.

Class HtmlDiff:
    For producing HTML side by side comparison with change highlights.
"""

__all__ = ['get_close_matches', 'ndiff', 'restore', 'SequenceMatcher',
           'Differ','IS_CHARACTER_JUNK', 'IS_LINE_JUNK', 'context_diff',
           'unified_diff', 'HtmlDiff']

import heapq</t>
<t tx="ekr.20051116222016.3">def _calculate_ratio(matches, length):

    if length:
        return 2.0 * matches / length
    return 1.0</t>
<t tx="ekr.20051116222016.4">class SequenceMatcher:

    """
    SequenceMatcher is a flexible class for comparing pairs of sequences of
    any type, so long as the sequence elements are hashable.  The basic
    algorithm predates, and is a little fancier than, an algorithm
    published in the late 1980's by Ratcliff and Obershelp under the
    hyperbolic name "gestalt pattern matching".  The basic idea is to find
    the longest contiguous matching subsequence that contains no "junk"
    elements (R-O doesn't address junk).  The same idea is then applied
    recursively to the pieces of the sequences to the left and to the right
    of the matching subsequence.  This does not yield minimal edit
    sequences, but does tend to yield matches that "look right" to people.

    SequenceMatcher tries to compute a "human-friendly diff" between two
    sequences.  Unlike e.g. UNIX(tm) diff, the fundamental notion is the
    longest *contiguous* &amp; junk-free matching subsequence.  That's what
    catches peoples' eyes.  The Windows(tm) windiff has another interesting
    notion, pairing up elements that appear uniquely in each sequence.
    That, and the method here, appear to yield more intuitive difference
    reports than does diff.  This method appears to be the least vulnerable
    to synching up on blocks of "junk lines", though (like blank lines in
    ordinary text files, or maybe "&lt;P&gt;" lines in HTML files).  That may be
    because this is the only method of the 3 that has a *concept* of
    "junk" &lt;wink&gt;.

    Example, comparing two strings, and considering blanks to be "junk":

    &gt;&gt;&gt; s = SequenceMatcher(lambda x: x == " ",
                             "private Thread currentThread;",
                             "private volatile Thread currentThread;")
    &gt;&gt;&gt;

    .ratio() returns a float in [0, 1], measuring the "similarity" of the
    sequences.  As a rule of thumb, a .ratio() value over 0.6 means the
    sequences are close matches:

    &gt;&gt;&gt; print round(s.ratio(), 3)
    0.866
    &gt;&gt;&gt;

    If you're only interested in where the sequences match,
    .get_matching_blocks() is handy:

    &gt;&gt;&gt; for block in s.get_matching_blocks():
             print "a[%d] and b[%d] match for %d elements" % block
    a[0] and b[0] match for 8 elements
    a[8] and b[17] match for 6 elements
    a[14] and b[23] match for 15 elements
    a[29] and b[38] match for 0 elements

    Note that the last tuple returned by .get_matching_blocks() is always a
    dummy, (len(a), len(b), 0), and this is the only case in which the last
    tuple element (number of elements matched) is 0.

    If you want to know how to change the first sequence into the second,
    use .get_opcodes():

    &gt;&gt;&gt; for opcode in s.get_opcodes():
             print "%6s a[%d:%d] b[%d:%d]" % opcode
     equal a[0:8] b[0:8]
    insert a[8:8] b[8:17]
     equal a[8:14] b[17:23]
     equal a[14:29] b[23:38]

    See the Differ class for a fancy human-friendly file differencer, which
    uses SequenceMatcher both to compare sequences of lines, and to compare
    sequences of characters within similar (near-matching) lines.

    See also function get_close_matches() in this module, which shows how
    simple code building on SequenceMatcher can be used to do useful work.

    Timing:  Basic R-O is cubic time worst case and quadratic time expected
    case.  SequenceMatcher is quadratic time for the worst case and has
    expected-case behavior dependent in a complicated way on how many
    elements the sequences have in common; best case time is linear.

    Methods:

    __init__(isjunk=None, a='', b='')
        Construct a SequenceMatcher.

    set_seqs(a, b)
        Set the two sequences to be compared.

    set_seq1(a)
        Set the first sequence to be compared.

    set_seq2(b)
        Set the second sequence to be compared.

    find_longest_match(alo, ahi, blo, bhi)
        Find longest matching block in a[alo:ahi] and b[blo:bhi].

    get_matching_blocks()
        Return list of triples describing matching subsequences.

    get_opcodes()
        Return list of 5-tuples describing how to turn a into b.

    ratio()
        Return a measure of the sequences' similarity (float in [0,1]).

    quick_ratio()
        Return an upper bound on .ratio() relatively quickly.

    real_quick_ratio()
        Return an upper bound on ratio() very quickly.
    """
    
	@others

</t>
<t tx="ekr.20051116222016.5">def __init__(self, isjunk=None, a='', b=''):
    """Construct a SequenceMatcher.

    Optional arg isjunk is None (the default), or a one-argument
    function that takes a sequence element and returns true iff the
    element is junk.  None is equivalent to passing "lambda x: 0", i.e.
    no elements are considered to be junk.  For example, pass
        lambda x: x in " \\t"
    if you're comparing lines as sequences of characters, and don't
    want to synch up on blanks or hard tabs.

    Optional arg a is the first of two sequences to be compared.  By
    default, an empty string.  The elements of a must be hashable.  See
    also .set_seqs() and .set_seq1().

    Optional arg b is the second of two sequences to be compared.  By
    default, an empty string.  The elements of b must be hashable. See
    also .set_seqs() and .set_seq2().
    """

    # Members:
    # a
    #      first sequence
    # b
    #      second sequence; differences are computed as "what do
    #      we need to do to 'a' to change it into 'b'?"
    # b2j
    #      for x in b, b2j[x] is a list of the indices (into b)
    #      at which x appears; junk elements do not appear
    # fullbcount
    #      for x in b, fullbcount[x] == the number of times x
    #      appears in b; only materialized if really needed (used
    #      only for computing quick_ratio())
    # matching_blocks
    #      a list of (i, j, k) triples, where a[i:i+k] == b[j:j+k];
    #      ascending &amp; non-overlapping in i and in j; terminated by
    #      a dummy (len(a), len(b), 0) sentinel
    # opcodes
    #      a list of (tag, i1, i2, j1, j2) tuples, where tag is
    #      one of
    #          'replace'   a[i1:i2] should be replaced by b[j1:j2]
    #          'delete'    a[i1:i2] should be deleted
    #          'insert'    b[j1:j2] should be inserted
    #          'equal'     a[i1:i2] == b[j1:j2]
    # isjunk
    #      a user-supplied function taking a sequence element and
    #      returning true iff the element is "junk" -- this has
    #      subtle but helpful effects on the algorithm, which I'll
    #      get around to writing up someday &lt;0.9 wink&gt;.
    #      DON'T USE!  Only __chain_b uses this.  Use isbjunk.
    # isbjunk
    #      for x in b, isbjunk(x) == isjunk(x) but much faster;
    #      it's really the has_key method of a hidden dict.
    #      DOES NOT WORK for x in a!
    # isbpopular
    #      for x in b, isbpopular(x) is true iff b is reasonably long
    #      (at least 200 elements) and x accounts for more than 1% of
    #      its elements.  DOES NOT WORK for x in a!

    self.isjunk = isjunk
    self.a = self.b = None
    self.set_seqs(a, b)
</t>
<t tx="ekr.20051116222016.6">def set_seqs(self, a, b):
    
    """Set the two sequences to be compared.

    &gt;&gt;&gt; s = SequenceMatcher()
    &gt;&gt;&gt; s.set_seqs("abcd", "bcde")
    &gt;&gt;&gt; s.ratio()
    0.75
    """

    self.set_seq1(a)
    self.set_seq2(b)
</t>
<t tx="ekr.20051116222016.7">def set_seq1(self, a):
    """Set the first sequence to be compared.

    The second sequence to be compared is not changed.

    &gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")
    &gt;&gt;&gt; s.ratio()
    0.75
    &gt;&gt;&gt; s.set_seq1("bcde")
    &gt;&gt;&gt; s.ratio()
    1.0
    &gt;&gt;&gt;

    SequenceMatcher computes and caches detailed information about the
    second sequence, so if you want to compare one sequence S against
    many sequences, use .set_seq2(S) once and call .set_seq1(x)
    repeatedly for each of the other sequences.

    See also set_seqs() and set_seq2().
    """

    if a is self.a:
        return
    self.a = a
    self.matching_blocks = self.opcodes = None
</t>
<t tx="ekr.20051116222016.8">def set_seq2(self, b):
    """Set the second sequence to be compared.

    The first sequence to be compared is not changed.

    &gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")
    &gt;&gt;&gt; s.ratio()
    0.75
    &gt;&gt;&gt; s.set_seq2("abcd")
    &gt;&gt;&gt; s.ratio()
    1.0
    &gt;&gt;&gt;

    SequenceMatcher computes and caches detailed information about the
    second sequence, so if you want to compare one sequence S against
    many sequences, use .set_seq2(S) once and call .set_seq1(x)
    repeatedly for each of the other sequences.

    See also set_seqs() and set_seq1().
    """

    if b is self.b:
        return
    self.b = b
    self.matching_blocks = self.opcodes = None
    self.fullbcount = None
    self.__chain_b()
</t>
<t tx="ekr.20051116222016.9"># For each element x in b, set b2j[x] to a list of the indices in
# b where x appears; the indices are in increasing order; note that
# the number of times x appears in b is len(b2j[x])     
# when self.isjunk is defined, junk elements don't show up in this
# map at all, which stops the central find_longest_match method
# from starting any matching block at a junk element     
# also creates the fast isbjunk function     
# b2j also does not contain entries for "popular" elements, meaning
# elements that account for more than 1% of the total elements, and
# when the sequence is reasonably large (&gt;= 200 elements); this can
# be viewed as an adaptive notion of semi-junk, and yields an enormous
# speedup when, e.g., comparing program files with hundreds of
# instances of "return NULL;"     
# note that this is only called when b changes; so for cross-product
# kinds of matches, it's best to call set_seq2 once, then set_seq1
# repeatedly

def __chain_b(self):
    # Because isjunk is a user-defined (not C) function, and we test
    # for junk a LOT, it's important to minimize the number of calls.
    # Before the tricks described here, __chain_b was by far the most
    # time-consuming routine in the whole module!  If anyone sees
    # Jim Roskind, thank him again for profile.py -- I never would
    # have guessed that.
    # The first trick is to build b2j ignoring the possibility
    # of junk.  I.e., we don't call isjunk at all yet.  Throwing
    # out the junk later is much cheaper than building b2j "right"
    # from the start.
    b = self.b
    n = len(b)
    self.b2j = b2j = {}
    populardict = {}
    for i, elt in enumerate(b):
        if elt in b2j:
            indices = b2j[elt]
            if n &gt;= 200 and len(indices) * 100 &gt; n:
                populardict[elt] = 1
                del indices[:]
            else:
                indices.append(i)
        else:
            b2j[elt] = [i]

    # Purge leftover indices for popular elements.
    for elt in populardict:
        del b2j[elt]

    # Now b2j.keys() contains elements uniquely, and especially when
    # the sequence is a string, that's usually a good deal smaller
    # than len(string).  The difference is the number of isjunk calls
    # saved.
    isjunk = self.isjunk
    junkdict = {}
    if isjunk:
        for d in populardict, b2j:
            for elt in d.keys():
                if isjunk(elt):
                    junkdict[elt] = 1
                    del d[elt]

    # Now for x in b, isjunk(x) == x in junkdict, but the
    # latter is much faster.  Note too that while there may be a
    # lot of junk in the sequence, the number of *unique* junk
    # elements is probably small.  So the memory burden of keeping
    # this dict alive is likely trivial compared to the size of b2j.
    self.isbjunk = junkdict.has_key
    self.isbpopular = populardict.has_key
</t>
<t tx="ekr.20051116222016.10">def find_longest_match(self, alo, ahi, blo, bhi):
    """Find longest matching block in a[alo:ahi] and b[blo:bhi].

    If isjunk is not defined:

    Return (i,j,k) such that a[i:i+k] is equal to b[j:j+k], where
        alo &lt;= i &lt;= i+k &lt;= ahi
        blo &lt;= j &lt;= j+k &lt;= bhi
    and for all (i',j',k') meeting those conditions,
        k &gt;= k'
        i &lt;= i'
        and if i == i', j &lt;= j'

    In other words, of all maximal matching blocks, return one that
    starts earliest in a, and of all those maximal matching blocks that
    start earliest in a, return the one that starts earliest in b.

    &gt;&gt;&gt; s = SequenceMatcher(None, " abcd", "abcd abcd")
    &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)
    (0, 4, 5)

    If isjunk is defined, first the longest matching block is
    determined as above, but with the additional restriction that no
    junk element appears in the block.  Then that block is extended as
    far as possible by matching (only) junk elements on both sides.  So
    the resulting block never matches on junk except as identical junk
    happens to be adjacent to an "interesting" match.

    Here's the same example as before, but considering blanks to be
    junk.  That prevents " abcd" from matching the " abcd" at the tail
    end of the second sequence directly.  Instead only the "abcd" can
    match, and matches the leftmost "abcd" in the second sequence:

    &gt;&gt;&gt; s = SequenceMatcher(lambda x: x==" ", " abcd", "abcd abcd")
    &gt;&gt;&gt; s.find_longest_match(0, 5, 0, 9)
    (1, 0, 4)

    If no blocks match, return (alo, blo, 0).

    &gt;&gt;&gt; s = SequenceMatcher(None, "ab", "c")
    &gt;&gt;&gt; s.find_longest_match(0, 2, 0, 1)
    (0, 0, 0)
    """

    # CAUTION:  stripping common prefix or suffix would be incorrect.
    # E.g.,
    #    ab
    #    acab
    # Longest matching block is "ab", but if common prefix is
    # stripped, it's "a" (tied with "b").  UNIX(tm) diff does so
    # strip, so ends up claiming that ab is changed to acab by
    # inserting "ca" in the middle.  That's minimal but unintuitive:
    # "it's obvious" that someone inserted "ac" at the front.
    # Windiff ends up at the same place as diff, but by pairing up
    # the unique 'b's and then matching the first two 'a's.

    a, b, b2j, isbjunk = self.a, self.b, self.b2j, self.isbjunk
    besti, bestj, bestsize = alo, blo, 0
    # find longest junk-free match
    # during an iteration of the loop, j2len[j] = length of longest
    # junk-free match ending with a[i-1] and b[j]
    j2len = {}
    nothing = []
    for i in xrange(alo, ahi):
        # look at all instances of a[i] in b; note that because
        # b2j has no junk keys, the loop is skipped if a[i] is junk
        j2lenget = j2len.get
        newj2len = {}
        for j in b2j.get(a[i], nothing):
            # a[i] matches b[j]
            if j &lt; blo:
                continue
            if j &gt;= bhi:
                break
            k = newj2len[j] = j2lenget(j-1, 0) + 1
            if k &gt; bestsize:
                besti, bestj, bestsize = i-k+1, j-k+1, k
        j2len = newj2len

    # Extend the best by non-junk elements on each end.  In particular,
    # "popular" non-junk elements aren't in b2j, which greatly speeds
    # the inner loop above, but also means "the best" match so far
    # doesn't contain any junk *or* popular non-junk elements.
    while besti &gt; alo and bestj &gt; blo and \
          not isbjunk(b[bestj-1]) and \
          a[besti-1] == b[bestj-1]:
        besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
    while besti+bestsize &lt; ahi and bestj+bestsize &lt; bhi and \
          not isbjunk(b[bestj+bestsize]) and \
          a[besti+bestsize] == b[bestj+bestsize]:
        bestsize += 1

    # Now that we have a wholly interesting match (albeit possibly
    # empty!), we may as well suck up the matching junk on each
    # side of it too.  Can't think of a good reason not to, and it
    # saves post-processing the (possibly considerable) expense of
    # figuring out what to do with it.  In the case of an empty
    # interesting match, this is clearly the right thing to do,
    # because no other kind of match is possible in the regions.
    while besti &gt; alo and bestj &gt; blo and \
          isbjunk(b[bestj-1]) and \
          a[besti-1] == b[bestj-1]:
        besti, bestj, bestsize = besti-1, bestj-1, bestsize+1
    while besti+bestsize &lt; ahi and bestj+bestsize &lt; bhi and \
          isbjunk(b[bestj+bestsize]) and \
          a[besti+bestsize] == b[bestj+bestsize]:
        bestsize = bestsize + 1

    return besti, bestj, bestsize
</t>
<t tx="ekr.20051116222016.11">def get_matching_blocks(self):
    """Return list of triples describing matching subsequences.

    Each triple is of the form (i, j, n), and means that
    a[i:i+n] == b[j:j+n].  The triples are monotonically increasing in
    i and in j.

    The last triple is a dummy, (len(a), len(b), 0), and is the only
    triple with n==0.

    &gt;&gt;&gt; s = SequenceMatcher(None, "abxcd", "abcd")
    &gt;&gt;&gt; s.get_matching_blocks()
    [(0, 0, 2), (3, 2, 2), (5, 4, 0)]
    """

    if self.matching_blocks is not None:
        return self.matching_blocks
    self.matching_blocks = []
    la, lb = len(self.a), len(self.b)
    self.__helper(0, la, 0, lb, self.matching_blocks)
    self.matching_blocks.append( (la, lb, 0) )
    return self.matching_blocks
</t>
<t tx="ekr.20051116222016.12"># builds list of matching blocks covering a[alo:ahi] and
# b[blo:bhi], appending them in increasing order to answer

def __helper(self, alo, ahi, blo, bhi, answer):
    i, j, k = x = self.find_longest_match(alo, ahi, blo, bhi)
    # a[alo:i] vs b[blo:j] unknown
    # a[i:i+k] same as b[j:j+k]
    # a[i+k:ahi] vs b[j+k:bhi] unknown
    if k:
        if alo &lt; i and blo &lt; j:
            self.__helper(alo, i, blo, j, answer)
        answer.append(x)
        if i+k &lt; ahi and j+k &lt; bhi:
            self.__helper(i+k, ahi, j+k, bhi, answer)
</t>
<t tx="ekr.20051116222016.13">def get_opcodes(self):
    """Return list of 5-tuples describing how to turn a into b.

    Each tuple is of the form (tag, i1, i2, j1, j2).  The first tuple
    has i1 == j1 == 0, and remaining tuples have i1 == the i2 from the
    tuple preceding it, and likewise for j1 == the previous j2.

    The tags are strings, with these meanings:

    'replace':  a[i1:i2] should be replaced by b[j1:j2]
    'delete':   a[i1:i2] should be deleted.
                Note that j1==j2 in this case.
    'insert':   b[j1:j2] should be inserted at a[i1:i1].
                Note that i1==i2 in this case.
    'equal':    a[i1:i2] == b[j1:j2]

    &gt;&gt;&gt; a = "qabxcd"
    &gt;&gt;&gt; b = "abycdf"
    &gt;&gt;&gt; s = SequenceMatcher(None, a, b)
    &gt;&gt;&gt; for tag, i1, i2, j1, j2 in s.get_opcodes():
            print ("%7s a[%d:%d] (%s) b[%d:%d] (%s)" %
                   (tag, i1, i2, a[i1:i2], j1, j2, b[j1:j2]))
     delete a[0:1] (q) b[0:0] ()
      equal a[1:3] (ab) b[0:2] (ab)
    replace a[3:4] (x) b[2:3] (y)
      equal a[4:6] (cd) b[3:5] (cd)
     insert a[6:6] () b[5:6] (f)
    """

    if self.opcodes is not None:
        return self.opcodes
    i = j = 0
    self.opcodes = answer = []
    for ai, bj, size in self.get_matching_blocks():
        # invariant:  we've pumped out correct diffs to change
        # a[:i] into b[:j], and the next matching block is
        # a[ai:ai+size] == b[bj:bj+size].  So we need to pump
        # out a diff to change a[i:ai] into b[j:bj], pump out
        # the matching block, and move (i,j) beyond the match
        tag = ''
        if i &lt; ai and j &lt; bj:
            tag = 'replace'
        elif i &lt; ai:
            tag = 'delete'
        elif j &lt; bj:
            tag = 'insert'
        if tag:
            answer.append( (tag, i, ai, j, bj) )
        i, j = ai+size, bj+size
        # the list of matching blocks is terminated by a
        # sentinel with size 0
        if size:
            answer.append( ('equal', ai, i, bj, j) )
    return answer</t>
<t tx="ekr.20051116222016.14">def get_grouped_opcodes(self, n=3):
    """ Isolate change clusters by eliminating ranges with no changes.

    Return a generator of groups with upto n lines of context.
    Each group is in the same format as returned by get_opcodes().

    &gt;&gt;&gt; from pprint import pprint
    &gt;&gt;&gt; a = map(str, range(1,40))
    &gt;&gt;&gt; b = a[:]
    &gt;&gt;&gt; b[8:8] = ['i']     # Make an insertion
    &gt;&gt;&gt; b[20] += 'x'       # Make a replacement
    &gt;&gt;&gt; b[23:28] = []      # Make a deletion
    &gt;&gt;&gt; b[30] += 'y'       # Make another replacement
    &gt;&gt;&gt; pprint(list(SequenceMatcher(None,a,b).get_grouped_opcodes()))
    [[('equal', 5, 8, 5, 8), ('insert', 8, 8, 8, 9), ('equal', 8, 11, 9, 12)],
     [('equal', 16, 19, 17, 20),
      ('replace', 19, 20, 20, 21),
      ('equal', 20, 22, 21, 23),
      ('delete', 22, 27, 23, 23),
      ('equal', 27, 30, 23, 26)],
     [('equal', 31, 34, 27, 30),
      ('replace', 34, 35, 30, 31),
      ('equal', 35, 38, 31, 34)]]
    """

    codes = self.get_opcodes()
    if not codes:
        codes = [("equal", 0, 1, 0, 1)]
    # Fixup leading and trailing groups if they show no changes.
    if codes[0][0] == 'equal':
        tag, i1, i2, j1, j2 = codes[0]
        codes[0] = tag, max(i1, i2-n), i2, max(j1, j2-n), j2
    if codes[-1][0] == 'equal':
        tag, i1, i2, j1, j2 = codes[-1]
        codes[-1] = tag, i1, min(i2, i1+n), j1, min(j2, j1+n)

    nn = n + n
    group = []
    for tag, i1, i2, j1, j2 in codes:
        # End the current group and start a new one whenever
        # there is a large range with no changes.
        if tag == 'equal' and i2-i1 &gt; nn:
            group.append((tag, i1, min(i2, i1+n), j1, min(j2, j1+n)))
            yield group
            group = []
            i1, j1 = max(i1, i2-n), max(j1, j2-n)
        group.append((tag, i1, i2, j1 ,j2))
    if group and not (len(group)==1 and group[0][0] == 'equal'):
        yield group
</t>
<t tx="ekr.20051116222016.15">def ratio(self):
    """Return a measure of the sequences' similarity (float in [0,1]).

    Where T is the total number of elements in both sequences, and
    M is the number of matches, this is 2.0*M / T.
    Note that this is 1 if the sequences are identical, and 0 if
    they have nothing in common.

    .ratio() is expensive to compute if you haven't already computed
    .get_matching_blocks() or .get_opcodes(), in which case you may
    want to try .quick_ratio() or .real_quick_ratio() first to get an
    upper bound.

    &gt;&gt;&gt; s = SequenceMatcher(None, "abcd", "bcde")
    &gt;&gt;&gt; s.ratio()
    0.75
    &gt;&gt;&gt; s.quick_ratio()
    0.75
    &gt;&gt;&gt; s.real_quick_ratio()
    1.0
    """

    matches = reduce(lambda sum, triple: sum + triple[-1],
                     self.get_matching_blocks(), 0)
    return _calculate_ratio(matches, len(self.a) + len(self.b))
</t>
<t tx="ekr.20051116222016.16">def quick_ratio(self):
    """Return an upper bound on ratio() relatively quickly.

    This isn't defined beyond that it is an upper bound on .ratio(), and
    is faster to compute.
    """

    # viewing a and b as multisets, set matches to the cardinality
    # of their intersection; this counts the number of matches
    # without regard to order, so is clearly an upper bound
    if self.fullbcount is None:
        self.fullbcount = fullbcount = {}
        for elt in self.b:
            fullbcount[elt] = fullbcount.get(elt, 0) + 1
    fullbcount = self.fullbcount
    # avail[x] is the number of times x appears in 'b' less the
    # number of times we've seen it in 'a' so far      kinda
    avail = {}
    availhas, matches = avail.has_key, 0
    for elt in self.a:
        if availhas(elt):
            numb = avail[elt]
        else:
            numb = fullbcount.get(elt, 0)
        avail[elt] = numb - 1
        if numb &gt; 0:
            matches = matches + 1
    return _calculate_ratio(matches, len(self.a) + len(self.b))
</t>
<t tx="ekr.20051116222016.17">def real_quick_ratio(self):
    """Return an upper bound on ratio() very quickly.

    This isn't defined beyond that it is an upper bound on .ratio(), and
    is faster to compute than either .ratio() or .quick_ratio().
    """

    la, lb = len(self.a), len(self.b)
    # can't have more matches than the number of elements in the
    # shorter sequence
    return _calculate_ratio(min(la, lb), la + lb)
</t>
<t tx="ekr.20051116222016.18">def get_close_matches(word, possibilities, n=3, cutoff=0.6):
    """Use SequenceMatcher to return list of the best "good enough" matches.

    word is a sequence for which close matches are desired (typically a
    string).

    possibilities is a list of sequences against which to match word
    (typically a list of strings).

    Optional arg n (default 3) is the maximum number of close matches to
    return.  n must be &gt; 0.

    Optional arg cutoff (default 0.6) is a float in [0, 1].  Possibilities
    that don't score at least that similar to word are ignored.

    The best (no more than n) matches among the possibilities are returned
    in a list, sorted by similarity score, most similar first.

    &gt;&gt;&gt; get_close_matches("appel", ["ape", "apple", "peach", "puppy"])
    ['apple', 'ape']
    &gt;&gt;&gt; import keyword as _keyword
    &gt;&gt;&gt; get_close_matches("wheel", _keyword.kwlist)
    ['while']
    &gt;&gt;&gt; get_close_matches("apple", _keyword.kwlist)
    []
    &gt;&gt;&gt; get_close_matches("accept", _keyword.kwlist)
    ['except']
    """

    if not n &gt;  0:
        raise ValueError("n must be &gt; 0: %r" % (n,))
    if not 0.0 &lt;= cutoff &lt;= 1.0:
        raise ValueError("cutoff must be in [0.0, 1.0]: %r" % (cutoff,))
    result = []
    s = SequenceMatcher()
    s.set_seq2(word)
    for x in possibilities:
        s.set_seq1(x)
        if s.real_quick_ratio() &gt;= cutoff and \
           s.quick_ratio() &gt;= cutoff and \
           s.ratio() &gt;= cutoff:
            result.append((s.ratio(), x))

    # Move the best scorers to head of list
    result = heapq.nlargest(n, result)
    # Strip scores for the best n matches
    return [x for score, x in result]
</t>
<t tx="ekr.20051116222016.19">def _count_leading(line, ch):
    """
    Return number of `ch` characters at the start of `line`.

    Example:

    &gt;&gt;&gt; _count_leading('   abc', ' ')
    3
    """

    i, n = 0, len(line)
    while i &lt; n and line[i] == ch:
        i += 1
    return i
</t>
<t tx="ekr.20051116222016.20">class Differ:
	&lt;&lt; class Differ declarations &gt;&gt;
	@others
</t>
<t tx="ekr.20051116222016.21">r"""
Differ is a class for comparing sequences of lines of text, and
producing human-readable differences or deltas.  Differ uses
SequenceMatcher both to compare sequences of lines, and to compare
sequences of characters within similar (near-matching) lines.

Each line of a Differ delta begins with a two-letter code:

    '- '    line unique to sequence 1
    '+ '    line unique to sequence 2
    '  '    line common to both sequences
    '? '    line not present in either input sequence

Lines beginning with '? ' attempt to guide the eye to intraline
differences, and were not present in either input sequence.  These lines
can be confusing if the sequences contain tab characters.

Note that Differ makes no claim to produce a *minimal* diff.  To the
contrary, minimal diffs are often counter-intuitive, because they synch
up anywhere possible, sometimes accidental matches 100 pages apart.
Restricting synch points to contiguous matches preserves some notion of
locality, at the occasional cost of producing a longer diff.

Example: Comparing two texts.

First we set up the texts, sequences of individual single-line strings
ending with newlines (such sequences can also be obtained from the
`readlines()` method of file-like objects):

&gt;&gt;&gt; text1 = '''  1. Beautiful is better than ugly.
       2. Explicit is better than implicit.
       3. Simple is better than complex.
       4. Complex is better than complicated.
     '''.splitlines(1)
&gt;&gt;&gt; len(text1)
4
&gt;&gt;&gt; text1[0][-1]
'\n'
&gt;&gt;&gt; text2 = '''  1. Beautiful is better than ugly.
       3.   Simple is better than complex.
       4. Complicated is better than complex.
       5. Flat is better than nested.
     '''.splitlines(1)

Next we instantiate a Differ object:

&gt;&gt;&gt; d = Differ()

Note that when instantiating a Differ object we may pass functions to
filter out line and character 'junk'.  See Differ.__init__ for details.

Finally, we compare the two:

&gt;&gt;&gt; result = list(d.compare(text1, text2))

'result' is a list of strings, so let's pretty-print it:

&gt;&gt;&gt; from pprint import pprint as _pprint
&gt;&gt;&gt; _pprint(result)
['    1. Beautiful is better than ugly.\n',
 '-   2. Explicit is better than implicit.\n',
 '-   3. Simple is better than complex.\n',
 '+   3.   Simple is better than complex.\n',
 '?     ++\n',
 '-   4. Complex is better than complicated.\n',
 '?            ^                     ---- ^\n',
 '+   4. Complicated is better than complex.\n',
 '?           ++++ ^                      ^\n',
 '+   5. Flat is better than nested.\n']

As a single multi-line string it looks like this:

&gt;&gt;&gt; print ''.join(result),
    1. Beautiful is better than ugly.
-   2. Explicit is better than implicit.
-   3. Simple is better than complex.
+   3.   Simple is better than complex.
?     ++
-   4. Complex is better than complicated.
?            ^                     ---- ^
+   4. Complicated is better than complex.
?           ++++ ^                      ^
+   5. Flat is better than nested.

Methods:

__init__(linejunk=None, charjunk=None)
    Construct a text differencer, with optional filters.

compare(a, b)
    Compare two sequences of lines; generate the resulting delta.
"""</t>
<t tx="ekr.20051116222016.22">def __init__(self, linejunk=None, charjunk=None):
    """
    Construct a text differencer, with optional filters.

    The two optional keyword parameters are for filter functions:

    - `linejunk`: A function that should accept a single string argument,
      and return true iff the string is junk. The module-level function
      `IS_LINE_JUNK` may be used to filter out lines without visible
      characters, except for at most one splat ('#').  It is recommended
      to leave linejunk None; as of Python 2.3, the underlying
      SequenceMatcher class has grown an adaptive notion of "noise" lines
      that's better than any static definition the author has ever been
      able to craft.

    - `charjunk`: A function that should accept a string of length 1. The
      module-level function `IS_CHARACTER_JUNK` may be used to filter out
      whitespace characters (a blank or tab; **note**: bad idea to include
      newline in this!).  Use of IS_CHARACTER_JUNK is recommended.
    """

    self.linejunk = linejunk
    self.charjunk = charjunk
</t>
<t tx="ekr.20051116222016.23">def compare(self, a, b):
    r"""
    Compare two sequences of lines; generate the resulting delta.

    Each sequence must contain individual single-line strings ending with
    newlines. Such sequences can be obtained from the `readlines()` method
    of file-like objects.  The delta generated also consists of newline-
    terminated strings, ready to be printed as-is via the writeline()
    method of a file-like object.

    Example:

    &gt;&gt;&gt; print ''.join(Differ().compare('one\ntwo\nthree\n'.splitlines(1),
                                        'ore\ntree\nemu\n'.splitlines(1))),
    - one
    ?  ^
    + ore
    ?  ^
    - two
    - three
    ?  -
    + tree
    + emu
    """

    cruncher = SequenceMatcher(self.linejunk, a, b)
    for tag, alo, ahi, blo, bhi in cruncher.get_opcodes():
        if tag == 'replace':
            g = self._fancy_replace(a, alo, ahi, b, blo, bhi)
        elif tag == 'delete':
            g = self._dump('-', a, alo, ahi)
        elif tag == 'insert':
            g = self._dump('+', b, blo, bhi)
        elif tag == 'equal':
            g = self._dump(' ', a, alo, ahi)
        else:
            raise ValueError, 'unknown tag %r' % (tag,)

        for line in g:
            yield line
</t>
<t tx="ekr.20051116222016.24">def _dump(self, tag, x, lo, hi):
    """Generate comparison results for a same-tagged range."""
    for i in xrange(lo, hi):
        yield '%s %s' % (tag, x[i])
</t>
<t tx="ekr.20051116222016.25">def _plain_replace(self, a, alo, ahi, b, blo, bhi):
    assert alo &lt; ahi and blo &lt; bhi
    # dump the shorter block first -- reduces the burden on short-term
    # memory if the blocks are of very different sizes
    if bhi - blo &lt; ahi - alo:
        first  = self._dump('+', b, blo, bhi)
        second = self._dump('-', a, alo, ahi)
    else:
        first  = self._dump('-', a, alo, ahi)
        second = self._dump('+', b, blo, bhi)

    for g in first, second:
        for line in g:
            yield line
</t>
<t tx="ekr.20051116222016.26">def _fancy_replace(self, a, alo, ahi, b, blo, bhi):
    r"""
    When replacing one block of lines with another, search the blocks
    for *similar* lines; the best-matching pair (if any) is used as a
    synch point, and intraline difference marking is done on the
    similar pair. Lots of work, but often worth it.

    Example:

    &gt;&gt;&gt; d = Differ()
    &gt;&gt;&gt; results = d._fancy_replace(['abcDefghiJkl\n'], 0, 1,
                                    ['abcdefGhijkl\n'], 0, 1)
    &gt;&gt;&gt; print ''.join(results),
    - abcDefghiJkl
    ?    ^  ^  ^
    + abcdefGhijkl
    ?    ^  ^  ^
    """

    # don't synch up unless the lines have a similarity score of at
    # least cutoff; best_ratio tracks the best score seen so far
    best_ratio, cutoff = 0.74, 0.75
    cruncher = SequenceMatcher(self.charjunk)
    eqi, eqj = None, None   # 1st indices of equal lines (if any)

    # search for the pair that matches best without being identical
    # (identical lines must be junk lines, &amp; we don't want to synch up
    # on junk -- unless we have to)
    for j in xrange(blo, bhi):
        bj = b[j]
        cruncher.set_seq2(bj)
        for i in xrange(alo, ahi):
            ai = a[i]
            if ai == bj:
                if eqi is None:
                    eqi, eqj = i, j
                continue
            cruncher.set_seq1(ai)
            # computing similarity is expensive, so use the quick
            # upper bounds first -- have seen this speed up messy
            # compares by a factor of 3.
            # note that ratio() is only expensive to compute the first
            # time it's called on a sequence pair; the expensive part
            # of the computation is cached by cruncher
            if cruncher.real_quick_ratio() &gt; best_ratio and \
                  cruncher.quick_ratio() &gt; best_ratio and \
                  cruncher.ratio() &gt; best_ratio:
                best_ratio, best_i, best_j = cruncher.ratio(), i, j
    if best_ratio &lt; cutoff:
        # no non-identical "pretty close" pair
        if eqi is None:
            # no identical pair either -- treat it as a straight replace
            for line in self._plain_replace(a, alo, ahi, b, blo, bhi):
                yield line
            return
        # no close pair, but an identical pair -- synch up on that
        best_i, best_j, best_ratio = eqi, eqj, 1.0
    else:
        # there's a close pair, so forget the identical pair (if any)
        eqi = None

    # a[best_i] very similar to b[best_j]; eqi is None iff they're not
    # identical

    # pump out diffs from before the synch point
    for line in self._fancy_helper(a, alo, best_i, b, blo, best_j):
        yield line

    # do intraline marking on the synch pair
    aelt, belt = a[best_i], b[best_j]
    if eqi is None:
        # pump out a '-', '?', '+', '?' quad for the synched lines
        atags = btags = ""
        cruncher.set_seqs(aelt, belt)
        for tag, ai1, ai2, bj1, bj2 in cruncher.get_opcodes():
            la, lb = ai2 - ai1, bj2 - bj1
            if tag == 'replace':
                atags += '^' * la
                btags += '^' * lb
            elif tag == 'delete':
                atags += '-' * la
            elif tag == 'insert':
                btags += '+' * lb
            elif tag == 'equal':
                atags += ' ' * la
                btags += ' ' * lb
            else:
                raise ValueError, 'unknown tag %r' % (tag,)
        for line in self._qformat(aelt, belt, atags, btags):
            yield line
    else:
        # the synch pair is identical
        yield '  ' + aelt

    # pump out diffs from after the synch point
    for line in self._fancy_helper(a, best_i+1, ahi, b, best_j+1, bhi):
        yield line
</t>
<t tx="ekr.20051116222016.27">def _fancy_helper(self, a, alo, ahi, b, blo, bhi):
    g = []
    if alo &lt; ahi:
        if blo &lt; bhi:
            g = self._fancy_replace(a, alo, ahi, b, blo, bhi)
        else:
            g = self._dump('-', a, alo, ahi)
    elif blo &lt; bhi:
        g = self._dump('+', b, blo, bhi)

    for line in g:
        yield line
</t>
<t tx="ekr.20051116222016.28">def _qformat(self, aline, bline, atags, btags):
    r"""
    Format "?" output and deal with leading tabs.

    Example:

    &gt;&gt;&gt; d = Differ()
    &gt;&gt;&gt; results = d._qformat('\tabcDefghiJkl\n', '\t\tabcdefGhijkl\n',
                              '  ^ ^  ^      ', '+  ^ ^  ^      ')
    &gt;&gt;&gt; for line in results: print repr(line)
        
    '- \tabcDefghiJkl\n'
    '? \t ^ ^  ^\n'
    '+ \t\tabcdefGhijkl\n'
    '? \t  ^ ^  ^\n'
    """

    # Can hurt, but will probably help most of the time.
    common = min(_count_leading(aline, "\t"),
                 _count_leading(bline, "\t"))
    common = min(common, _count_leading(atags[:common], " "))
    atags = atags[common:].rstrip()
    btags = btags[common:].rstrip()

    yield "- " + aline
    if atags:
        yield "? %s%s\n" % ("\t" * common, atags)

    yield "+ " + bline
    if btags:
        yield "? %s%s\n" % ("\t" * common, btags)
</t>
<t tx="ekr.20051116222016.29"># With respect to junk, an earlier version of ndiff simply refused to
# *start* a match with a junk element.  The result was cases like this:
#     before: private Thread currentThread;
#     after:  private volatile Thread currentThread;
# If you consider whitespace to be junk, the longest contiguous match
# not starting with junk is "e Thread currentThread".  So ndiff reported
# that "e volatil" was inserted between the 't' and the 'e' in "private".
# While an accurate view, to people that's absurd.  The current version
# looks for matching blocks that are entirely junk-free, then extends the
# longest one of those as far as possible but only with matching junk.
# So now "currentThread" is matched, then extended to suck up the
# preceding blank; then "private" is matched, and extended to suck up the
# following blank; then "Thread" is matched; and finally ndiff reports
# that "volatile " was inserted before "Thread".  The only quibble
# remaining is that perhaps it was really the case that " volatile"
# was inserted after "private".  I can live with that &lt;wink&gt;.

import re

def IS_LINE_JUNK(line, pat=re.compile(r"\s*#?\s*$").match):
    r"""
    Return 1 for ignorable line: iff `line` is blank or contains a single '#'.

    Examples:

    &gt;&gt;&gt; IS_LINE_JUNK('\n')
    True
    &gt;&gt;&gt; IS_LINE_JUNK('  #   \n')
    True
    &gt;&gt;&gt; IS_LINE_JUNK('hello\n')
    False
    """

    return pat(line) is not None
</t>
<t tx="ekr.20051116222016.30">def IS_CHARACTER_JUNK(ch, ws=" \t"):

    r"""
    Return 1 for ignorable character: iff `ch` is a space or tab.

    Examples:

    &gt;&gt;&gt; IS_CHARACTER_JUNK(' ')
    True
    &gt;&gt;&gt; IS_CHARACTER_JUNK('\t')
    True
    &gt;&gt;&gt; IS_CHARACTER_JUNK('\n')
    False
    &gt;&gt;&gt; IS_CHARACTER_JUNK('x')
    False
    """

    return ch in ws
</t>
<t tx="ekr.20051116222016.31">def unified_diff(a, b, fromfile='', tofile='', fromfiledate='',
                 tofiledate='', n=3, lineterm='\n'):
    r"""
    Compare two sequences of lines; generate the delta as a unified diff.

    Unified diffs are a compact way of showing line changes and a few
    lines of context.  The number of context lines is set by 'n' which
    defaults to three.

    By default, the diff control lines (those with ---, +++, or @@) are
    created with a trailing newline.  This is helpful so that inputs
    created from file.readlines() result in diffs that are suitable for
    file.writelines() since both the inputs and outputs have trailing
    newlines.

    For inputs that do not have trailing newlines, set the lineterm
    argument to "" so that the output will be uniformly newline free.

    The unidiff format normally has a header for filenames and modification
    times.  Any or all of these may be specified using strings for
    'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.  The modification
    times are normally expressed in the format returned by time.ctime().

    Example:

    &gt;&gt;&gt; for line in unified_diff('one two three four'.split(),
                     'zero one tree four'.split(), 'Original', 'Current',
                     'Sat Jan 26 23:30:50 1991', 'Fri Jun 06 10:20:52 2003',
                     lineterm=''):
             print line
    --- Original Sat Jan 26 23:30:50 1991
    +++ Current Fri Jun 06 10:20:52 2003
    @@ -1,4 +1,4 @@
    +zero
     one
    -two
    -three
    +tree
     four
    """

    started = False
    for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):
        if not started:
            yield '--- %s %s%s' % (fromfile, fromfiledate, lineterm)
            yield '+++ %s %s%s' % (tofile, tofiledate, lineterm)
            started = True
        i1, i2, j1, j2 = group[0][1], group[-1][2], group[0][3], group[-1][4]
        yield "@@ -%d,%d +%d,%d @@%s" % (i1+1, i2-i1, j1+1, j2-j1, lineterm)
        for tag, i1, i2, j1, j2 in group:
            if tag == 'equal':
                for line in a[i1:i2]:
                    yield ' ' + line
                continue
            if tag == 'replace' or tag == 'delete':
                for line in a[i1:i2]:
                    yield '-' + line
            if tag == 'replace' or tag == 'insert':
                for line in b[j1:j2]:
                    yield '+' + line
</t>
<t tx="ekr.20051116222016.32"># See http://www.unix.org/single_unix_specification/
def context_diff(a, b, fromfile='', tofile='',
                 fromfiledate='', tofiledate='', n=3, lineterm='\n'):
    r"""
    Compare two sequences of lines; generate the delta as a context diff.

    Context diffs are a compact way of showing line changes and a few
    lines of context.  The number of context lines is set by 'n' which
    defaults to three.

    By default, the diff control lines (those with *** or ---) are
    created with a trailing newline.  This is helpful so that inputs
    created from file.readlines() result in diffs that are suitable for
    file.writelines() since both the inputs and outputs have trailing
    newlines.

    For inputs that do not have trailing newlines, set the lineterm
    argument to "" so that the output will be uniformly newline free.

    The context diff format normally has a header for filenames and
    modification times.  Any or all of these may be specified using
    strings for 'fromfile', 'tofile', 'fromfiledate', and 'tofiledate'.
    The modification times are normally expressed in the format returned
    by time.ctime().  If not specified, the strings default to blanks.

    Example:

    &gt;&gt;&gt; print ''.join(context_diff('one\ntwo\nthree\nfour\n'.splitlines(1),
               'zero\none\ntree\nfour\n'.splitlines(1), 'Original', 'Current',
               'Sat Jan 26 23:30:50 1991', 'Fri Jun 06 10:22:46 2003')),
    *** Original Sat Jan 26 23:30:50 1991
    --- Current Fri Jun 06 10:22:46 2003
    ***************
    *** 1,4 ****
      one
    ! two
    ! three
      four
    --- 1,4 ----
    + zero
      one
    ! tree
      four
    """

    started = False
    prefixmap = {'insert':'+ ', 'delete':'- ', 'replace':'! ', 'equal':'  '}
    for group in SequenceMatcher(None,a,b).get_grouped_opcodes(n):
        if not started:
            yield '*** %s %s%s' % (fromfile, fromfiledate, lineterm)
            yield '--- %s %s%s' % (tofile, tofiledate, lineterm)
            started = True

        yield '***************%s' % (lineterm,)
        if group[-1][2] - group[0][1] &gt;= 2:
            yield '*** %d,%d ****%s' % (group[0][1]+1, group[-1][2], lineterm)
        else:
            yield '*** %d ****%s' % (group[-1][2], lineterm)
        visiblechanges = [e for e in group if e[0] in ('replace', 'delete')]
        if visiblechanges:
            for tag, i1, i2, _, _ in group:
                if tag != 'insert':
                    for line in a[i1:i2]:
                        yield prefixmap[tag] + line

        if group[-1][4] - group[0][3] &gt;= 2:
            yield '--- %d,%d ----%s' % (group[0][3]+1, group[-1][4], lineterm)
        else:
            yield '--- %d ----%s' % (group[-1][4], lineterm)
        visiblechanges = [e for e in group if e[0] in ('replace', 'insert')]
        if visiblechanges:
            for tag, _, _, j1, j2 in group:
                if tag != 'delete':
                    for line in b[j1:j2]:
                        yield prefixmap[tag] + line
</t>
<t tx="ekr.20051116222016.33">def ndiff(a, b, linejunk=None, charjunk=IS_CHARACTER_JUNK):
    r"""
    Compare `a` and `b` (lists of strings); return a `Differ`-style delta.

    Optional keyword parameters `linejunk` and `charjunk` are for filter
    functions (or None):

    - linejunk: A function that should accept a single string argument, and
      return true iff the string is junk.  The default is None, and is
      recommended; as of Python 2.3, an adaptive notion of "noise" lines is
      used that does a good job on its own.

    - charjunk: A function that should accept a string of length 1. The
      default is module-level function IS_CHARACTER_JUNK, which filters out
      whitespace characters (a blank or tab; note: bad idea to include newline
      in this!).

    Tools/scripts/ndiff.py is a command-line front-end to this function.

    Example:

    &gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(1),
                      'ore\ntree\nemu\n'.splitlines(1))
    &gt;&gt;&gt; print ''.join(diff),
    - one
    ?  ^
    + ore
    ?  ^
    - two
    - three
    ?  -
    + tree
    + emu
    """
    return Differ(linejunk, charjunk).compare(a, b)
</t>
<t tx="ekr.20051116222016.34">def _mdiff(fromlines, tolines, context=None, linejunk=None,
           charjunk=IS_CHARACTER_JUNK):
    """Returns generator yielding marked up from/to side by side differences.

    Arguments:
    fromlines -- list of text lines to compared to tolines
    tolines -- list of text lines to be compared to fromlines
    context -- number of context lines to display on each side of difference,
               if None, all from/to text lines will be generated.
    linejunk -- passed on to ndiff (see ndiff documentation)
    charjunk -- passed on to ndiff (see ndiff documentation)

    This function returns an interator which returns a tuple:
    (from line tuple, to line tuple, boolean flag)

    from/to line tuple -- (line num, line text)
        line num -- integer or None (to indicate a context seperation)
        line text -- original line text with following markers inserted:
            '\0+' -- marks start of added text
            '\0-' -- marks start of deleted text
            '\0^' -- marks start of changed text
            '\1' -- marks end of added/deleted/changed text

    boolean flag -- None indicates context separation, True indicates
        either "from" or "to" line contains a change, otherwise False.

    This function/iterator was originally developed to generate side by side
    file difference for making HTML pages (see HtmlDiff class for example
    usage).

    Note, this function utilizes the ndiff function to generate the side by
    side difference markup.  Optional ndiff arguments may be passed to this
    function and they in turn will be passed to ndiff.
    """
    import re

    # regular expression for finding intraline change indices
    change_re = re.compile('(\++|\-+|\^+)')

    # create the difference iterator to generate the differences
    diff_lines_iterator = ndiff(fromlines,tolines,linejunk,charjunk)

    def _make_line(lines, format_key, side, num_lines=[0,0]):
        """Returns line of text with user's change markup and line formatting.

        lines -- list of lines from the ndiff generator to produce a line of
                 text from.  When producing the line of text to return, the
                 lines used are removed from this list.
        format_key -- '+' return first line in list with "add" markup around
                          the entire line.
                      '-' return first line in list with "delete" markup around
                          the entire line.
                      '?' return first line in list with add/delete/change
                          intraline markup (indices obtained from second line)
                      None return first line in list with no markup
        side -- indice into the num_lines list (0=from,1=to)
        num_lines -- from/to current line number.  This is NOT intended to be a
                     passed parameter.  It is present as a keyword argument to
                     maintain memory of the current line numbers between calls
                     of this function.

        Note, this function is purposefully not defined at the module scope so
        that data it needs from its parent function (within whose context it
        is defined) does not need to be of module scope.
        """
        num_lines[side] += 1
        # Handle case where no user markup is to be added, just return line of
        # text with user's line format to allow for usage of the line number.
        if format_key is None:
            return (num_lines[side],lines.pop(0)[2:])
        # Handle case of intraline changes
        if format_key == '?':
            text, markers = lines.pop(0), lines.pop(0)
            # find intraline changes (store change type and indices in tuples)
            sub_info = []
            def record_sub_info(match_object,sub_info=sub_info):
                sub_info.append([match_object.group(1)[0],match_object.span()])
                return match_object.group(1)
            change_re.sub(record_sub_info,markers)
            # process each tuple inserting our special marks that won't be
            # noticed by an xml/html escaper.
            for key,(begin,end) in sub_info[::-1]:
                text = text[0:begin]+'\0'+key+text[begin:end]+'\1'+text[end:]
            text = text[2:]
        # Handle case of add/delete entire line
        else:
            text = lines.pop(0)[2:]
            # if line of text is just a newline, insert a space so there is
            # something for the user to highlight and see.
            if not text:
                text = ' '
            # insert marks that won't be noticed by an xml/html escaper.
            text = '\0' + format_key + text + '\1'
        # Return line of text, first allow user's line formatter to do it's
        # thing (such as adding the line number) then replace the special
        # marks with what the user's change markup.
        return (num_lines[side],text)

    def _line_iterator():
        """Yields from/to lines of text with a change indication.

        This function is an iterator.  It itself pulls lines from a
        differencing iterator, processes them and yields them.  When it can
        it yields both a "from" and a "to" line, otherwise it will yield one
        or the other.  In addition to yielding the lines of from/to text, a
        boolean flag is yielded to indicate if the text line(s) have
        differences in them.

        Note, this function is purposefully not defined at the module scope so
        that data it needs from its parent function (within whose context it
        is defined) does not need to be of module scope.
        """
        lines = []
        num_blanks_pending, num_blanks_to_yield = 0, 0
        while True:
            # Load up next 4 lines so we can look ahead, create strings which
            # are a concatenation of the first character of each of the 4 lines
            # so we can do some very readable comparisons.
            while len(lines) &lt; 4:
                try:
                    lines.append(diff_lines_iterator.next())
                except StopIteration:
                    lines.append('X')
            s = ''.join([line[0] for line in lines])
            if s.startswith('X'):
                # When no more lines, pump out any remaining blank lines so the
                # corresponding add/delete lines get a matching blank line so
                # all line pairs get yielded at the next level.
                num_blanks_to_yield = num_blanks_pending
            elif s.startswith('-?+?'):
                # simple intraline change
                yield _make_line(lines,'?',0), _make_line(lines,'?',1), True
                continue
            elif s.startswith('--++'):
                # in delete block, add block coming: we do NOT want to get
                # caught up on blank lines yet, just process the delete line
                num_blanks_pending -= 1
                yield _make_line(lines,'-',0), None, True
                continue
            elif s.startswith('--?+') or s.startswith('--+') or \
                 s.startswith('- '):
                # in delete block and see a intraline change or unchanged line
                # coming: yield the delete line and then blanks
                from_line,to_line = _make_line(lines,'-',0), None
                num_blanks_to_yield,num_blanks_pending = num_blanks_pending-1,0
            elif s.startswith('-+?'):
                # intraline change
                yield _make_line(lines,None,0), _make_line(lines,'?',1), True
                continue
            elif s.startswith('-?+'):
                # intraline change
                yield _make_line(lines,'?',0), _make_line(lines,None,1), True
                continue
            elif s.startswith('-'):
                # delete FROM line
                num_blanks_pending -= 1
                yield _make_line(lines,'-',0), None, True
                continue
            elif s.startswith('+--'):
                # in add block, delete block coming: we do NOT want to get
                # caught up on blank lines yet, just process the add line
                num_blanks_pending += 1
                yield None, _make_line(lines,'+',1), True
                continue
            elif s.startswith('+ ') or s.startswith('+-'):
                # will be leaving an add block: yield blanks then add line
                from_line, to_line = None, _make_line(lines,'+',1)
                num_blanks_to_yield,num_blanks_pending = num_blanks_pending+1,0
            elif s.startswith('+'):
                # inside an add block, yield the add line
                num_blanks_pending += 1
                yield None, _make_line(lines,'+',1), True
                continue
            elif s.startswith(' '):
                # unchanged text, yield it to both sides
                yield _make_line(lines[:],None,0),_make_line(lines,None,1),False
                continue
            # Catch up on the blank lines so when we yield the next from/to
            # pair, they are lined up.
            while(num_blanks_to_yield &lt; 0):
                num_blanks_to_yield += 1
                yield None,('','\n'),True
            while(num_blanks_to_yield &gt; 0):
                num_blanks_to_yield -= 1
                yield ('','\n'),None,True
            if s.startswith('X'):
                raise StopIteration
            else:
                yield from_line,to_line,True

    def _line_pair_iterator():
        """Yields from/to lines of text with a change indication.

        This function is an iterator.  It itself pulls lines from the line
        iterator.  It's difference from that iterator is that this function
        always yields a pair of from/to text lines (with the change
        indication).  If necessary it will collect single from/to lines
        until it has a matching pair from/to pair to yield.

        Note, this function is purposefully not defined at the module scope so
        that data it needs from its parent function (within whose context it
        is defined) does not need to be of module scope.
        """
        line_iterator = _line_iterator()
        fromlines,tolines=[],[]
        while True:
            # Collecting lines of text until we have a from/to pair
            while (len(fromlines)==0 or len(tolines)==0):
                from_line, to_line, found_diff =line_iterator.next()
                if from_line is not None:
                    fromlines.append((from_line,found_diff))
                if to_line is not None:
                    tolines.append((to_line,found_diff))
            # Once we have a pair, remove them from the collection and yield it
            from_line, fromDiff = fromlines.pop(0)
            to_line, to_diff = tolines.pop(0)
            yield (from_line,to_line,fromDiff or to_diff)

    # Handle case where user does not want context differencing, just yield
    # them up without doing anything else with them.
    line_pair_iterator = _line_pair_iterator()
    if context is None:
        while True:
            yield line_pair_iterator.next()
    # Handle case where user wants context differencing.  We must do some
    # storage of lines until we know for sure that they are to be yielded.
    else:
        context += 1
        lines_to_write = 0
        while True:
            # Store lines up until we find a difference, note use of a
            # circular queue because we only need to keep around what
            # we need for context.
            index, contextLines = 0, [None]*(context)
            found_diff = False
            while(found_diff is False):
                from_line, to_line, found_diff = line_pair_iterator.next()
                i = index % context
                contextLines[i] = (from_line, to_line, found_diff)
                index += 1
            # Yield lines that we have collected so far, but first yield
            # the user's separator.
            if index &gt; context:
                yield None, None, None
                lines_to_write = context
            else:
                lines_to_write = index
                index = 0
            while(lines_to_write):
                i = index % context
                index += 1
                yield contextLines[i]
                lines_to_write -= 1
            # Now yield the context lines after the change
            lines_to_write = context-1
            while(lines_to_write):
                from_line, to_line, found_diff = line_pair_iterator.next()
                # If another change within the context, extend the context
                if found_diff:
                    lines_to_write = context-1
                else:
                    lines_to_write -= 1
                yield from_line, to_line, found_diff
</t>
<t tx="ekr.20051116222016.35">_file_template = """
&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
          "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;

&lt;html&gt;

&lt;head&gt;
    &lt;meta http-equiv="Content-Type"
          content="text/html; charset=ISO-8859-1" /&gt;
    &lt;title&gt;&lt;/title&gt;
    &lt;style type="text/css"&gt;%(styles)s
    &lt;/style&gt;
&lt;/head&gt;

&lt;body&gt;
    %(table)s%(legend)s
&lt;/body&gt;

&lt;/html&gt;"""

_styles = """
        table.diff {font-family:Courier; border:medium;}
        .diff_header {background-color:#e0e0e0}
        td.diff_header {text-align:right}
        .diff_next {background-color:#c0c0c0}
        .diff_add {background-color:#aaffaa}
        .diff_chg {background-color:#ffff77}
        .diff_sub {background-color:#ffaaaa}"""

_table_template = """
    &lt;table class="diff" id="difflib_chg_%(prefix)s_top"
           cellspacing="0" cellpadding="0" rules="groups" &gt;
        &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt;
        &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt; &lt;colgroup&gt;&lt;/colgroup&gt;
        %(header_row)s
        &lt;tbody&gt;
%(data_rows)s        &lt;/tbody&gt;
    &lt;/table&gt;"""

_legend = """
    &lt;table class="diff" summary="Legends"&gt;
        &lt;tr&gt; &lt;th colspan="2"&gt; Legends &lt;/th&gt; &lt;/tr&gt;
        &lt;tr&gt; &lt;td&gt; &lt;table border="" summary="Colors"&gt;
                      &lt;tr&gt;&lt;th&gt; Colors &lt;/th&gt; &lt;/tr&gt;
                      &lt;tr&gt;&lt;td class="diff_add"&gt;&amp;nbsp;Added&amp;nbsp;&lt;/td&gt;&lt;/tr&gt;
                      &lt;tr&gt;&lt;td class="diff_chg"&gt;Changed&lt;/td&gt; &lt;/tr&gt;
                      &lt;tr&gt;&lt;td class="diff_sub"&gt;Deleted&lt;/td&gt; &lt;/tr&gt;
                  &lt;/table&gt;&lt;/td&gt;
             &lt;td&gt; &lt;table border="" summary="Links"&gt;
                      &lt;tr&gt;&lt;th colspan="2"&gt; Links &lt;/th&gt; &lt;/tr&gt;
                      &lt;tr&gt;&lt;td&gt;(f)irst change&lt;/td&gt; &lt;/tr&gt;
                      &lt;tr&gt;&lt;td&gt;(n)ext change&lt;/td&gt; &lt;/tr&gt;
                      &lt;tr&gt;&lt;td&gt;(t)op&lt;/td&gt; &lt;/tr&gt;
                  &lt;/table&gt;&lt;/td&gt; &lt;/tr&gt;
    &lt;/table&gt;"""

class HtmlDiff(object):
    """For producing HTML side by side comparison with change highlights.

    This class can be used to create an HTML table (or a complete HTML file
    containing the table) showing a side by side, line by line comparison
    of text with inter-line and intra-line change highlights.  The table can
    be generated in either full or contextual difference mode.

    The following methods are provided for HTML generation:

    make_table -- generates HTML for a single side by side table
    make_file -- generates complete HTML file with a single side by side table

    See tools/scripts/diff.py for an example usage of this class.
    """
	&lt;&lt; class HtmlDiff declarations &gt;&gt;
	@others
    
del re
</t>
<t tx="ekr.20051116222016.36">_file_template = _file_template
_styles = _styles
_table_template = _table_template
_legend = _legend
_default_prefix = 0

</t>
<t tx="ekr.20051116222016.37">def __init__(self,tabsize=8,wrapcolumn=None,linejunk=None,
             charjunk=IS_CHARACTER_JUNK):
    """HtmlDiff instance initializer

    Arguments:
    tabsize -- tab stop spacing, defaults to 8.
    wrapcolumn -- column number where lines are broken and wrapped,
        defaults to None where lines are not wrapped.
    linejunk,charjunk -- keyword arguments passed into ndiff() (used to by
        HtmlDiff() to generate the side by side HTML differences).  See
        ndiff() documentation for argument default values and descriptions.
    """
    self._tabsize = tabsize
    self._wrapcolumn = wrapcolumn
    self._linejunk = linejunk
    self._charjunk = charjunk
</t>
<t tx="ekr.20051116222016.38">def make_file(self,fromlines,tolines,fromdesc='',todesc='',context=False,
              numlines=5):
    """Returns HTML file of side by side comparison with change highlights

    Arguments:
    fromlines -- list of "from" lines
    tolines -- list of "to" lines
    fromdesc -- "from" file column header string
    todesc -- "to" file column header string
    context -- set to True for contextual differences (defaults to False
        which shows full differences).
    numlines -- number of context lines.  When context is set True,
        controls number of lines displayed before and after the change.
        When context is False, controls the number of lines to place
        the "next" link anchors before the next change (so click of
        "next" link jumps to just before the change).
    """

    return self._file_template % dict(
        styles = self._styles,
        legend = self._legend,
        table = self.make_table(fromlines,tolines,fromdesc,todesc,
                                context=context,numlines=numlines))
</t>
<t tx="ekr.20051116222016.39">def _tab_newline_replace(self,fromlines,tolines):
    """Returns from/to line lists with tabs expanded and newlines removed.

    Instead of tab characters being replaced by the number of spaces
    needed to fill in to the next tab stop, this function will fill
    the space with tab characters.  This is done so that the difference
    algorithms can identify changes in a file when tabs are replaced by
    spaces and vice versa.  At the end of the HTML generation, the tab
    characters will be replaced with a nonbreakable space.
    """
    def expand_tabs(line):
        # hide real spaces
        line = line.replace(' ','\0')
        # expand tabs into spaces
        line = line.expandtabs(self._tabsize)
        # relace spaces from expanded tabs back into tab characters
        # (we'll replace them with markup after we do differencing)
        line = line.replace(' ','\t')
        return line.replace('\0',' ').rstrip('\n')
    fromlines = [expand_tabs(line) for line in fromlines]
    tolines = [expand_tabs(line) for line in tolines]
    return fromlines,tolines
</t>
<t tx="ekr.20051116222016.40">def _split_line(self,data_list,line_num,text):
    """Builds list of text lines by splitting text lines at wrap point

    This function will determine if the input text line needs to be
    wrapped (split) into separate lines.  If so, the first wrap point
    will be determined and the first line appended to the output
    text line list.  This function is used recursively to handle
    the second part of the split line to further split it.
    """
    # if blank line or context separator, just add it to the output list
    if not line_num:
        data_list.append((line_num,text))
        return

    # if line text doesn't need wrapping, just add it to the output list
    size = len(text)
    max = self._wrapcolumn
    if (size &lt;= max) or ((size -(text.count('\0')*3)) &lt;= max):
        data_list.append((line_num,text))
        return

    # scan text looking for the wrap point, keeping track if the wrap
    # point is inside markers
    i = 0
    n = 0
    mark = ''
    while n &lt; max and i &lt; size:
        if text[i] == '\0':
            i += 1
            mark = text[i]
            i += 1
        elif text[i] == '\1':
            i += 1
            mark = ''
        else:
            i += 1
            n += 1

    # wrap point is inside text, break it up into separate lines
    line1 = text[:i]
    line2 = text[i:]

    # if wrap point is inside markers, place end marker at end of first
    # line and start marker at beginning of second line because each
    # line will have its own table tag markup around it.
    if mark:
        line1 = line1 + '\1'
        line2 = '\0' + mark + line2

    # tack on first line onto the output list
    data_list.append((line_num,line1))

    # use this routine again to wrap the remaining text
    self._split_line(data_list,'&gt;',line2)
</t>
<t tx="ekr.20051116222016.41">def _line_wrapper(self,diffs):
    """Returns iterator that splits (wraps) mdiff text lines"""

    # pull from/to data and flags from mdiff iterator
    for fromdata,todata,flag in diffs:
        # check for context separators and pass them through
        if flag is None:
            yield fromdata,todata,flag
            continue
        (fromline,fromtext),(toline,totext) = fromdata,todata
        # for each from/to line split it at the wrap column to form
        # list of text lines.
        fromlist,tolist = [],[]
        self._split_line(fromlist,fromline,fromtext)
        self._split_line(tolist,toline,totext)
        # yield from/to line in pairs inserting blank lines as
        # necessary when one side has more wrapped lines
        while fromlist or tolist:
            if fromlist:
                fromdata = fromlist.pop(0)
            else:
                fromdata = ('',' ')
            if tolist:
                todata = tolist.pop(0)
            else:
                todata = ('',' ')
            yield fromdata,todata,flag
</t>
<t tx="ekr.20051116222016.42">def _collect_lines(self,diffs):
    """Collects mdiff output into separate lists

    Before storing the mdiff from/to data into a list, it is converted
    into a single line of text with HTML markup.
    """

    fromlist,tolist,flaglist = [],[],[]
    # pull from/to data and flags from mdiff style iterator
    for fromdata,todata,flag in diffs:
        try:
            # store HTML markup of the lines into the lists
            fromlist.append(self._format_line(0,flag,*fromdata))
            tolist.append(self._format_line(1,flag,*todata))
        except TypeError:
            # exceptions occur for lines where context separators go
            fromlist.append(None)
            tolist.append(None)
        flaglist.append(flag)
    return fromlist,tolist,flaglist
</t>
<t tx="ekr.20051116222016.43">def _format_line(self,side,flag,linenum,text):
    """Returns HTML markup of "from" / "to" text lines

    side -- 0 or 1 indicating "from" or "to" text
    flag -- indicates if difference on line
    linenum -- line number (used for line number column)
    text -- line text to be marked up
    """
    try:
        linenum = '%d' % linenum
        id = ' id="%s%s"' % (self._prefix[side],linenum)
    except TypeError:
        # handle blank lines where linenum is '&gt;' or ''
        id = ''
    # replace those things that would get confused with HTML symbols
    text=text.replace("&amp;","&amp;amp;").replace("&gt;","&amp;gt;").replace("&lt;","&amp;lt;")

    # make space non-breakable so they don't get compressed or line wrapped
    text = text.replace(' ','&amp;nbsp;').rstrip()

    return '&lt;td class="diff_header"%s&gt;%s&lt;/td&gt;&lt;td nowrap="nowrap"&gt;%s&lt;/td&gt;' \
           % (id,linenum,text)
</t>
<t tx="ekr.20051116222016.44">def _make_prefix(self):
    """Create unique anchor prefixes"""

    # Generate a unique anchor prefix so multiple tables
    # can exist on the same HTML page without conflicts.
    fromprefix = "from%d_" % HtmlDiff._default_prefix
    toprefix = "to%d_" % HtmlDiff._default_prefix
    HtmlDiff._default_prefix += 1
    # store prefixes so line format method has access
    self._prefix = [fromprefix,toprefix]
</t>
<t tx="ekr.20051116222016.45">def _convert_flags(self,fromlist,tolist,flaglist,context,numlines):
    """Makes list of "next" links"""

    # all anchor names will be generated using the unique "to" prefix
    toprefix = self._prefix[1]

    # process change flags, generating middle column of next anchors/links
    next_id = ['']*len(flaglist)
    next_href = ['']*len(flaglist)
    num_chg, in_change = 0, False
    last = 0
    for i,flag in enumerate(flaglist):
        if flag:
            if not in_change:
                in_change = True
                last = i
                # at the beginning of a change, drop an anchor a few lines
                # (the context lines) before the change for the previous
                # link
                i = max([0,i-numlines])
                next_id[i] = ' id="difflib_chg_%s_%d"' % (toprefix,num_chg)
                # at the beginning of a change, drop a link to the next
                # change
                num_chg += 1
                next_href[last] = '&lt;a href="#difflib_chg_%s_%d"&gt;n&lt;/a&gt;' % (
                     toprefix,num_chg)
        else:
            in_change = False
    # check for cases where there is no content to avoid exceptions
    if not flaglist:
        flaglist = [False]
        next_id = ['']
        next_href = ['']
        last = 0
        if context:
            fromlist = ['&lt;td&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;No Differences Found&amp;nbsp;&lt;/td&gt;']
            tolist = fromlist
        else:
            fromlist = tolist = ['&lt;td&gt;&lt;/td&gt;&lt;td&gt;&amp;nbsp;Empty File&amp;nbsp;&lt;/td&gt;']
    # if not a change on first line, drop a link
    if not flaglist[0]:
        next_href[0] = '&lt;a href="#difflib_chg_%s_0"&gt;f&lt;/a&gt;' % toprefix
    # redo the last link to link to the top
    next_href[last] = '&lt;a href="#difflib_chg_%s_top"&gt;t&lt;/a&gt;' % (toprefix)

    return fromlist,tolist,flaglist,next_href,next_id
</t>
<t tx="ekr.20051116222016.46">def make_table(self,fromlines,tolines,fromdesc='',todesc='',context=False,
               numlines=5):
    """Returns HTML table of side by side comparison with change highlights

    Arguments:
    fromlines -- list of "from" lines
    tolines -- list of "to" lines
    fromdesc -- "from" file column header string
    todesc -- "to" file column header string
    context -- set to True for contextual differences (defaults to False
        which shows full differences).
    numlines -- number of context lines.  When context is set True,
        controls number of lines displayed before and after the change.
        When context is False, controls the number of lines to place
        the "next" link anchors before the next change (so click of
        "next" link jumps to just before the change).
    """

    # make unique anchor prefixes so that multiple tables may exist
    # on the same page without conflict.
    self._make_prefix()

    # change tabs to spaces before it gets more difficult after we insert
    # markkup
    fromlines,tolines = self._tab_newline_replace(fromlines,tolines)

    # create diffs iterator which generates side by side from/to data
    if context:
        context_lines = numlines
    else:
        context_lines = None
    diffs = _mdiff(fromlines,tolines,context_lines,linejunk=self._linejunk,
                  charjunk=self._charjunk)

    # set up iterator to wrap lines that exceed desired width
    if self._wrapcolumn:
        diffs = self._line_wrapper(diffs)

    # collect up from/to lines and flags into lists (also format the lines)
    fromlist,tolist,flaglist = self._collect_lines(diffs)

    # process change flags, generating middle column of next anchors/links
    fromlist,tolist,flaglist,next_href,next_id = self._convert_flags(
        fromlist,tolist,flaglist,context,numlines)

    import cStringIO
    s = cStringIO.StringIO()
    fmt = '            &lt;tr&gt;&lt;td class="diff_next"%s&gt;%s&lt;/td&gt;%s' + \
          '&lt;td class="diff_next"&gt;%s&lt;/td&gt;%s&lt;/tr&gt;\n'
    for i in range(len(flaglist)):
        if flaglist[i] is None:
            # mdiff yields None on separator lines skip the bogus ones
            # generated for the first line
            if i &gt; 0:
                s.write('        &lt;/tbody&gt;        \n        &lt;tbody&gt;\n')
        else:
            s.write( fmt % (next_id[i],next_href[i],fromlist[i],
                                       next_href[i],tolist[i]))
    if fromdesc or todesc:
        header_row = '&lt;thead&gt;&lt;tr&gt;%s%s%s%s&lt;/tr&gt;&lt;/thead&gt;' % (
            '&lt;th class="diff_next"&gt;&lt;br /&gt;&lt;/th&gt;',
            '&lt;th colspan="2" class="diff_header"&gt;%s&lt;/th&gt;' % fromdesc,
            '&lt;th class="diff_next"&gt;&lt;br /&gt;&lt;/th&gt;',
            '&lt;th colspan="2" class="diff_header"&gt;%s&lt;/th&gt;' % todesc)
    else:
        header_row = ''

    table = self._table_template % dict(
        data_rows=s.getvalue(),
        header_row=header_row,
        prefix=self._prefix[1])

    return table.replace('\0+','&lt;span class="diff_add"&gt;'). \
                 replace('\0-','&lt;span class="diff_sub"&gt;'). \
                 replace('\0^','&lt;span class="diff_chg"&gt;'). \
                 replace('\1','&lt;/span&gt;'). \
                 replace('\t','&amp;nbsp;')
</t>
<t tx="ekr.20051116222016.47">def restore(delta, which):
    r"""
    Generate one of the two sequences that generated a delta.

    Given a `delta` produced by `Differ.compare()` or `ndiff()`, extract
    lines originating from file 1 or 2 (parameter `which`), stripping off line
    prefixes.

    Examples:

    &gt;&gt;&gt; diff = ndiff('one\ntwo\nthree\n'.splitlines(1),
                      'ore\ntree\nemu\n'.splitlines(1))
    &gt;&gt;&gt; diff = list(diff)
    &gt;&gt;&gt; print ''.join(restore(diff, 1)),
    one
    two
    three
    &gt;&gt;&gt; print ''.join(restore(diff, 2)),
    ore
    tree
    emu
    """
    try:
        tag = {1: "- ", 2: "+ "}[int(which)]
    except KeyError:
        raise ValueError, ('unknown delta choice (must be 1 or 2): %r'
                           % which)
    prefixes = ("  ", tag)
    for line in delta:
        if line[:2] in prefixes:
            yield line[2:]
</t>
<t tx="ekr.20051116222016.48">def _test():
    import doctest, difflib
    return doctest.testmod(difflib)
</t>
<t tx="ekr.20051116222849">@language python
@tabwidth -4
&lt;&lt; diff declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="ekr.20051116222849.1">""" Command line interface to difflib.py providing diffs in four formats:

* ndiff:    lists every line and highlights interline changes.
* context:  highlights clusters of changes in a before/after format.
* unified:  highlights clusters of changes in an inline format.
* html:     generates side by side comparison with change highlights.

"""

import sys, os, time, difflib, optparse

</t>
<t tx="ekr.20051116222849.2">def main():

    usage = "usage: %prog [options] fromfile tofile"
    parser = optparse.OptionParser(usage)
    parser.add_option("-c", action="store_true", default=False, help='Produce a context format diff (default)')
    parser.add_option("-u", action="store_true", default=False, help='Produce a unified format diff')
    parser.add_option("-m", action="store_true", default=False, help='Produce HTML side by side diff (can use -c and -l in conjunction)')
    parser.add_option("-n", action="store_true", default=False, help='Produce a ndiff format diff')
    parser.add_option("-l", "--lines", type="int", default=3, help='Set number of context lines (default 3)')

    (options, args) = parser.parse_args()

    if len(args) == 0:
        parser.print_help()
        sys.exit(1)
    if len(args) != 2:
        parser.error("need to specify both a fromfile and tofile")

    n = options.lines
    fromfile, tofile = args

    fromdate = time.ctime(os.stat(fromfile).st_mtime)
    todate   = time.ctime(os.stat(tofile).st_mtime)
    fromlines = open(fromfile, 'U').readlines()
    tolines   = open(tofile, 'U').readlines()

    if options.u:
        diff = difflib.unified_diff(fromlines, tolines, fromfile, tofile, fromdate, todate, n=n)
    elif options.n:
        diff = difflib.ndiff(fromlines, tolines)
    elif options.m:
        diff = difflib.HtmlDiff().make_file(fromlines,tolines,fromfile,tofile,context=options.c,numlines=n)
    else:
        diff = difflib.context_diff(fromlines, tolines, fromfile, tofile, fromdate, todate, n=n)

    sys.stdout.writelines(diff)
</t>
<t tx="ekr.20051117095207">import difflib

d = difflib.Differ()
p1 = p.firstChild()
p2 = p1.next()
p1Lines = g.splitLines(p1.bodyString())
p2Lines = g.splitLines(p2.bodyString())

# d.compare returns an iterator
print ; print '*' * 60
print ''.join(list(d.compare(p1Lines,p2Lines)))</t>
<t tx="ekr.20051117095207.1">1. Beautiful is better than ugly.
2. Explicit is better than implicit.
3. Simple is better than complex.
4. Complex is better than complicated.
</t>
<t tx="ekr.20051117095207.2">1. Beautiful is better than ugly.
3.   Simple is better than complex.
4. Complicated is better than complex.
5. Flat is better than nested.
</t>
<t tx="ekr.20051120173230"></t>
<t tx="ekr.20051120173230.1"></t>
<t tx="ekr.20051120173230.2"></t>
<t tx="ekr.20051120173510">c.executeMinibufferCommand('remove-blank-lines')</t>
<t tx="ekr.20051121064026">c.executeMinibufferCommand('indent-relative')</t>
<t tx="ekr.20051121143509">@others

d = g.scanDirectives(c,p)
w = d.get('pagewidth',100)
tab_width = d.get('tabwidth',4)

print '*' * 60

if d.get('language','').lower() == 'python':
    result = [] ; inComment = False ; inString = False
    for line in g.splitlines(p.bodyString()):
        i,junk = g.skip_leading_ws_with_indent(line,0,tab_width)
        lws = line[:i]
        # g.trace('lws',repr(lws))
        result.extend(splitLongLine(line,lws,w,tab_width,inComment,inString))
    
    print ''.join(result)
else:
    print 'Not Python code'</t>
<t tx="ekr.20051121143951.1">def splitLongLine(s,lws,w,tab_width,inComment,inString):

    if not s or g.computeWidth (s,tab_width) &lt; w:
        return [s]
        
    i,inComment,inString,backslash = chooseBreakPoint(s,w,tab_width,inComment,inString)
    if i is None: return [s]

    if inComment:
        tab = ''
    else:
        tab = g.choose(tab_width &lt; 0,' ' * abs(tab_width),'\t')
    comment = g.choose(inComment,'# ','')
    list1 = [s[:i+1]]
    list2 = splitLongLine(s[i+1:],lws+tab,w,tab_width,inComment,inString)
    list1.append('%s\n%s%s%s' % (backslash,lws,comment,tab))
    list1.extend(list2)
    return list1</t>
<t tx="ekr.20051124065932">@

Bug: can't split after opening quote.
* Handle-triple-quote strings properly.
** Skip @doc parts.
- Handle tabs properly when splitting.</t>
<t tx="ekr.20051124080305">def chooseBreakPoint (s,w,tab_width,inComment,inString):
    
    '''Return (i,inComment,inString,backSlash) where::
    - i is the index at which to break the line.
    - inComment is True if we are in a comment.
    - inString is True if we are in a string.
    - backslash is '\\' if the broken line must end in a backslash'''

    i, i2 = -1,-1 # The index of the rightmost valid breakpoint.
    for k in xrange(len(s)):
        ch = s[k]
        if k &gt;= w and i &gt; -1:
            break
        elif inComment:
            if ch in (' ','\t'): i = k
        elif ch in ('"',"'"):
            inString = not inString
            if not inString:
                i = max(0,k-1) ; i2 = -1
        elif inString:
            if ch in (' ','\t'): i = k
        else:
            if ch in ('(','[')  and g.skip_ws(s,k+1) &gt; abs(tab_width):
                i = k ;  g.trace(k,repr(ch),repr(s))
            if ch in (' ','\t') and g.skip_ws(s,k) &gt; abs(tab_width):
                i2 = k ;  g.trace(k,repr(ch),repr(s))
            if ch == '#':
                inComment = True ; inString = False; i = k ; i2 = -1

    if i == -1 and i2 == -1:
        return None,inComment,inString,'' # No break is possible.
    elif i == -1:
        # Break at a blank.
        i2 = max(i2,g.skip_ws(s,i2)-1)
        return i2,inComment,inString,'\\'
    elif inComment:
        i = max(i,g.skip_ws(s,i)-1)
        return i,True,False,''
    elif inString:
        i = max(i,g.skip_ws(s,i)-1)
        return i,False,True,'\\'
    else:
        # Break at a bracket.
        i = max(i,g.skip_ws(s,i+1)-1)
        return i,False,False,''</t>
<t tx="ekr.20051130181738">print 'Let the wild rumpus start!'

import sys
import System
sys.LoadAssemblyByName("System.Windows.Forms")

if 0: # Works
    def click(*args):
        print args ; System.Windows.Forms.Application.Exit()
    f = System.Windows.Forms.Form()
    f.Click += click
    f.Show()
    System.Windows.Forms.Application.Run()

else: # Works: automatically exits, so I like it better.
    def click(*args): print args
    f = System.Windows.Forms.Form()
    f.Click += click
    System.Windows.Forms.Application.Run(f)
    
print 'done'</t>
<t tx="ekr.20051130182412">REM -i option crashes, so this test program had better be a winforms program.

cd c:\prog\IronPython-0.9.5

bin\IronPythonConsole c:\prog\leoCVS\leo\test\ironPythonTest.py
</t>
<t tx="ekr.20051130182536"></t>
<t tx="ekr.20051130182536.1">@comment REM_</t>
<t tx="ekr.20051201063427.1">### execute-script = Ctrl-e # Ctrl-e conflicts with end-of-line</t>
<t tx="ekr.20051201090822"></t>
<t tx="ekr.20051201153400">before

print    'hi'.
print    'there'.

after</t>
<t tx="ekr.20051209074151"></t>
<t tx="ekr.20051209084028"></t>
<t tx="ekr.20051214093711">import sys
import Tkinter as Tk

@others

log = c.frame.log; tabName = 'redemo'
pypath = g.os_path_split(sys.executable )[0]
pyScripts = g.os_path_join(pypath, 'Tools/Scripts')
redemo = g.importFromPath('redemo', pyScripts)

f = log.frameDict.get(tabName)
if f:
    log.selectTab(tabName)
else:
    log.selectTab(tabName)
    t = log.textDict.get(tabName)
    t.pack_forget()
    f = log.frameDict.get(tabName)
    createFrame(f)</t>
<t tx="ekr.20051214094526">def createFrame (f):

    root = f #use this for tab
    #root = Tk.Tk(f)  #uncomment this for popup
    
    demo = redemo.ReDemo(root)
    demo.promptdisplay.pack_forget()
    demo.labeldisplay.pack_forget()
    demo.regexdisplay.pack(fill = 'y', expand = 0)

    demo.regexdisplay.focus_set()

    regexconfig = {
        'font': ('verdana',11,'bold'), 'bg': 'AntiqueWhite',
        'insertontime': 400, 'insertofftime': 650,
        #'width':40,
    }

    demo.regexdisplay.configure(regexconfig)
    return root</t>
<t tx="ekr.20051214100048"></t>
<t tx="ekr.20051219184032">import leoTest
leoTest.runTimerOnNode(p,count=1000)</t>
<t tx="ekr.20051221091553">c.frame.tree.OnIconDoubleClick(p)
</t>
<t tx="ekr.20060103102234">@nocolor
@
http://sourceforge.net/forum/message.php?msg_id=3494187
By: nobody

Ed's version shows how to properly initialize the tab.
new version, choice of popup or in tab.
gota believe theres a few still too frightened of 4.4
as popup will probably work on earlier Leo ok.

you do have to delete 'redemo' tab to rerun the script.
attaching the logs scroll not working yet.
I found the scroll widget, but its not cooperating.
scroll isn't really that useful, you need to have
enough room to see all the fields.
sorry if you're on a phone or other limited screen...

swapping the sample data and results fields might help.
will probably have to duplicate the reDemo.__init__
made the entry a text 3 line widget to make verbose possible
edit height or scroll or drag around to input more lines.

added Checkbutton UNICODE, (not well tested)
who knows if this is fixed in py2.5+ this redemo may break
this is probably the limit of working without editing redemo.py,
gets more fragile as you depend on more methods and structures.
yet it is only possible because of the way the code is written.
little things like saving the list of frames etc.
a tradition I am probably not living up to.

added button to output re.compile line to use w/flags
and it does an eval to verify it will compile ok.

added help button to display sre.__doc__ to log pane.
        
sourceforge forums now is htmlizing some entities
like gt, lt and quotes. what are they afraid of?
do they know we post code here?
has anyone posted one and do they read bug reports?
they sure don't make it easy to give feedback.
do they even try the forums after they mangle them?
are they mangling everyones forums?

redemo script now has its own page
[http://rclick.netfirms.com/redemoleo.htm]  

start of more extensive object introspecter than dir(obj)
adds itself to the Leo g. namespace for later use.
[http://rclick.netfirms.com/dir_obj.htm]    

for regex inverse button you must download:
[http://www.uselesspython.com/jpetkau1.py]
save as reinv.py in the python path or leo/extensions 

there may be another version if I can fix the scroll.
e</t>
<t tx="ekr.20060104162223">c.keyHandler.simulateCommand('enter-file-mode')</t>
<t tx="ekr.20060107082808">print 'here'

@others</t>
<t tx="ekr.20060107082808.1">print 'there'
if 1:
    print 'everywhere'
  print 'bad'
print 'done'</t>
<t tx="ekr.20060108113440">@markup wiki

@

__bold__</t>
<t tx="ekr.20060108160837"></t>
<t tx="ekr.20060108163117"></t>
<t tx="ekr.20060108163323"></t>
<t tx="ekr.20060108163323.1">print 'filename',filename
p = c.currentPosition()
print 'body:',repr(p.bodyString())</t>
<t tx="ekr.20060108163923"></t>
<t tx="ekr.20060112062919">@first &lt;?xml version="1.0" encoding="windows-1250" ?&gt;
@language html
@ 
comment line
@c
@others
</t>
<t tx="ekr.20060113083051">import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &gt;&gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &gt;&gt; stdout, s, aaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccc ddddddddddddddddddddddddd eeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff
        print &gt;&gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &gt;&gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &gt;&gt; stdout, s,
        print &gt;&gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &gt;&gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &gt;&gt; stdout, s,
        print &gt;&gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &gt;&gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &gt;&gt; stdout, s,
        print &gt;&gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &gt;&gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &gt;&gt; stdout, s,
        print &gt;&gt; stderr, s,
print 'bye'</t>
<t tx="ekr.20060114164015">print '-' * 20
name = g.app.gui.widget_name
w = p.edit_widget()
print name(w),w.cget('state')
c.editPosition(p)
w = p.edit_widget()
print name(w),w.cget('state')
c.endEditing()
c.selectPosition(p)
w = p.edit_widget()
print name(w),w.cget('state')</t>
<t tx="ekr.20060119110527">def callback(event):
    print event.keysym_num,event.state

b = c.frame.body.bodyCtrl
print b.bindtags()

if 0:
    aList = list(b.bindtags())
    tag = 'default-leo-bindings'
    
    # Associates the callback with the tag.
    b.bind_class(tag,'&lt;Key&gt;',callback,'+')
    aList.insert(0,tag)
    
    # The binding will not be active until this statement
    
    b.bindtags(tuple(aList)) # Must be a tuple, not a list.
    print b.bindtags()</t>
<t tx="ekr.20060119121607">@language tcltk</t>
<t tx="ekr.20060119121607.1"># To use this script, you must make this a script button, either with the
# 'Script Button' button or by making this an @button node.

# Executes body text of selected node as a tcl script.
# For more information, see http://wiki.tcl.tk/6878

# This statement allows you to organize your scripts using noweb markup.
s = g.getScript(c,p,forcePythonSentinels=False)
g.es(g.app.root.tk.eval(s))</t>
<t tx="ekr.20060119121607.2"># This is a comment
set x 50
return [expr $x*10]</t>
<t tx="ekr.20060119121607.3">@others</t>
<t tx="ekr.20060119121607.4"># This is a comment
set x 50 +
return [expr $x*10]</t>
<t tx="ekr.20060119121607.5">text .t
foreach tag [bindtags .t] {
  foreach keysym [bind $tag] {
    set script [bind $tag $keysym]
    puts "event $keysym for tag $tag executes: $script\n"
  }
}
</t>
<t tx="ekr.20060119170038">t = c.frame.body.bodyCtrl

for tag in t.bindtags():
    print '-' * 20, tag
    print t.bind_class(tag)

# foreach tag [bindtags .t] {
  # foreach keysym [bind $tag] {
    # set script [bind $tag $keysym]
    # puts "event $keysym for tag $tag executes: $script\n"
  # }
# }
# 
</t>
<t tx="ekr.20060122115629">import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &amp;gt;&amp;gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &amp;gt;&amp;gt; stdout, s, aaaaaaaaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbbbbbbbbbbb cccccccccccccccccccc ddddddddddddddddddddddddd eeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff
        print &amp;gt;&amp;gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &amp;gt;&amp;gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &amp;gt;&amp;gt; stdout, s,
        print &amp;gt;&amp;gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &amp;gt;&amp;gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &amp;gt;&amp;gt; stdout, s,
        print &amp;gt;&amp;gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &amp;gt;&amp;gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &amp;gt;&amp;gt; stdout, s,
        print &amp;gt;&amp;gt; stderr, s,
print 'bye'
import os
import sys
import time

print "Hello from Leo's debugger"

stdin = sys.stdin
stdout = sys.stdout
stderr = sys.stderr

@others

s = ''
while s != 'kill':
    print &amp;gt;&amp;gt; stderr, '.', # visible.
    time.sleep(0.5)
    s = nonBlockingRead(stdin)
    if s:
        print &amp;gt;&amp;gt; stdout, s,
        print &amp;gt;&amp;gt; stderr, s,
print 'bye'</t>
</tnodes>
</leo_file>
