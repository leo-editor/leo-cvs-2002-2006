<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="5946" clone_windows="0"/>
<globals body_outline_ratio="0.481481481481">
	<global_window_position top="29" left="348" height="864" width="913"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="EKR.20040623200709"><vh>@thin ../src/leoTest.py</vh></v>
<v t="ekr.20040721153143"><vh>Gc/Profile/Timeit scripts</vh>
<v t="ekr.20040721113934"><vh>runProfile</vh></v>
<v t="ekr.20040721114839.1"><vh>runTimeit</vh></v>
<v t="ekr.20040721145258.1"><vh>Run gc</vh></v>
</v>
<v t="ekr.20040708205841"><vh>Other tests...</vh>
<v t="ekr.20040414082806"><vh>Clone test</vh>
<v t="ekr.20040409140301"><vh>clone test</vh>
<v t="ekr.20040409140301.1"><vh>b</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028"><vh>sibling</vh></v>
</v>
<v t="ekr.20040409140301.3"><vh>a</vh></v>
</v>
<v t="ekr.20040409140343"><vh>d</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028.1"><vh>sibling 2</vh></v>
</v>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409140343.1"><vh>last</vh></v>
</v>
<v t="EKR.20040523112430"><vh>Cloning headlines</vh>
<v t="EKR.20040523112430.1"><vh>read me</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.8"><vh>f</vh></v>
</v>
<v t="ekr.20040312101720"><vh>Experiments</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
<v t="ekr.20040323075614"><vh>Test of using an iterator inside a list comprehension</vh></v>
<v t="ekr.20040323080317"><vh>Test of using c.allNodes_iter to create a list of all positions</vh></v>
<v t="ekr.20040323082119"><vh>Creating a list of distinct vnodes</vh></v>
<v t="ekr.20040325082811"><vh>Test that back quotes are not needed in es</vh></v>
<v t="ekr.20040325130503"><vh>test of list comparisons</vh></v>
<v t="ekr.20040325140133"><vh>test that childIndex doesn't mess with p</vh></v>
<v t="ekr.20040325155043"><vh>Test of __cmp__ vrs equal</vh></v>
<v t="EKR.20040615070332"><vh>Test print</vh></v>
<v t="ekr.20040711140206"><vh>String-based imports...</vh>
<v t="ekr.20040710125250"><vh>import from string</vh>
<v t="ekr.20040710125250.2"><vh>@test import from string</vh></v>
</v>
<v t="ekr.20040711093916"><vh>Subclass the file type for use with imp module</vh></v>
<v t="ekr.20040711085843"><vh>Use parser module to simulate import from string</vh>
<v t="ekr.20040711092603"><vh>test1</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707110818"><vh>File Tests...</vh>
<v t="EKR.20040430162649.23"><vh>(double @root bug)</vh>
<v t="EKR.20040430162649.24"><vh>Assert fails</vh></v>
<v t="EKR.20040430162649.25"><vh>double at-root test (assert fails)</vh></v>
</v>
<v t="EKR.20040427092657"><vh>@ file-thin c:\prog\test\at-file-thin-test.txt</vh>
<v t="EKR.20040427092657.1"><vh>node 1</vh>
<v t="EKR.20040428145741"><vh>&lt;&lt; node 1 ref &gt;&gt;</vh>
<v t="EKR.20040428145741.1"><vh>child node 1</vh></v>
<v t="EKR.20040428145741.2"><vh>child node 2</vh></v>
</v>
</v>
<v t="EKR.20040427092657.2"><vh>&lt;&lt; ref &gt;&gt;</vh>
<v t="EKR.20040428150018"><vh>organizer node</vh>
<v t="EKR.20040428145826"><vh>ref child 1</vh></v>
<v t="EKR.20040428145826.1"><vh>ref child 2</vh></v>
</v>
</v>
</v>
<v t="EKR.20040625110032"><vh>@ thin c:\prog\test\mixedCommentDelims.txt</vh>
<v t="EKR.20040625110032.1"><vh>node 1</vh></v>
<v t="EKR.20040625110032.2"><vh>node 2</vh>
<v t="EKR.20040625110032.3"><vh>Node 3</vh></v>
</v>
</v>
<v t="ekr.20040419105536"><vh>@file c:\prog\test\perlLineNumbersTest.txt</vh>
<v t="ekr.20040419105536.1"><vh>one</vh></v>
<v t="ekr.20040419105536.2"><vh>two</vh></v>
</v>
<v t="ekr.20040330103006"><vh>@file c:\prog\test\testSectionDelims.txt</vh></v>
<v t="EKR.20040608095146.1"><vh>@file login_process.cfm</vh></v>
<v t="EKR.20040531110157"><vh>at-file thin tests</vh>
<v t="EKR.20040520104329"><vh>@thin c:\prog\test\thinCloneTest.txt</vh></v>
<v t="EKR.20040524050419"><vh>@file c:\prog\test\fatGrandChildTest.txt</vh>
<v t="EKR.20040524050419.1"><vh>Organizer node</vh>
<v t="EKR.20040524050419.2"><vh>&lt;&lt; defined in grandchild &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040524050438"><vh>@thin c:\prog\test\grandChildTest.txt</vh></v>
<v t="EKR.20040525083635"><vh>@file c:\prog\test\orphanMessageTest.txt</vh>
<v t="EKR.20040525083635.1"><vh>orphan</vh></v>
</v>
</v>
<v t="EKR.20040430162649.12"><vh>REM_ hack and perlpod hacks</vh>
<v t="EKR.20040430162649.13"><vh>perlpod test</vh>
<v t="EKR.20040430162649.14"><vh>perlpod test</vh>
<v t="EKR.20040430162649.15"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040430162649.16"><vh>REM test</vh>
<v t="EKR.20040430162649.17"><vh>@file c:/prog/test/remTest.txt</vh></v>
</v>
</v>
<v t="EKR.20040430162649.20"><vh>Suppress @@ sentinel unless leading @ starts a directive</vh>
<v t="EKR.20040430162649.21"><vh>@file c:\prog\test\perltest.txt</vh></v>
</v>
<v t="ekr.20040704104554"><vh>Test mixed @language directives in a single node</vh>
<v t="ekr.20040704104554.1"><vh>Mixed script</vh></v>
<v t="ekr.20040704104554.2"><vh>@thin c:\prog\test\mixedLanguages.txt</vh></v>
</v>
<v t="EKR.20040606204316"><vh>Test of @first</vh>
<v t="EKR.20040606204316.1"><vh>@thin atFirstTest.txt</vh></v>
</v>
<v t="EKR.20040622074004"><vh>Test of conflicting node defs</vh>
<v t="EKR.20040622074004.1"><vh>a</vh>
<v t="EKR.20040622074004.2"><vh>b</vh></v>
<v t="EKR.20040622074004.3"><vh>c</vh></v>
</v>
<v t="EKR.20040622102618"><vh>@thin c:\prog\test\cloneConflicts.txt</vh></v>
</v>
<v t="ekr.20040701081330"><vh>Test of decendent attributes</vh>
<v t="ekr.20040701065412"><vh>@ thin c:\prog\test\attribTest.txt</vh>
<v t="ekr.20040701065412.1"><vh>Marked</vh></v>
<v t="ekr.20040701065412.2"><vh>Expanded</vh>
<v t="ekr.20040701065412.3"><vh>child</vh></v>
</v>
<v t="ekr.20040701065412.4"><vh>Marked and expanded</vh>
<v t="ekr.20040701065412.5"><vh>child2</vh></v>
</v>
<v t="ekr.20040701065424"><vh>Neither Expanded or marked</vh>
<v t="ekr.20040701065424.1"><vh>child</vh></v>
</v>
</v>
</v>
<v t="EKR.20040627103732"><vh>Test of writing descendent uA's</vh>
<v t="EKR.20040627121836"><vh>print all tnode attributes</vh></v>
<v t="EKR.20040627103902"><vh>Test of user icons</vh></v>
<v t="EKR.20040627103801"><vh>@thin c:\prog\test\uaTest.txt</vh></v>
</v>
<v t="EKR.20040430162649.1"><vh>Unicode tests</vh>
<v t="EKR.20040430162649.2"><vh> Tests</vh>
<v t="EKR.20040430162649.3"><vh>@file-asis c:\prog\test\asisTest.txt</vh></v>
<v t="EKR.20040430162649.4"><vh>@file-nosent c:\prog\test\nosentTest.txt</vh></v>
<v t="EKR.20040430162649.5" tnodeList="EKR.20040430162649.5"><vh>@file-noref c:\prog\test\norefTest.txt</vh></v>
</v>
<v t="EKR.20040430162649.6"><vh> Tests</vh>
<v t="EKR.20040430162649.7"><vh>Import/export tests</vh>
<v t="EKR.20040430162649.8"><vh>test</vh>
<v t="EKR.20040430162649.9"><vh>NewHeadlineë</vh></v>
</v>
</v>
<v t="EKR.20040430162649.10"><vh>@file c:/prog/test/unicodeTest.doc</vh>
<v t="EKR.20040430162649.11"><vh>NewÖ</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040708210442"><vh>Manual tests...</vh>
<v t="EKR.20040605200750"><vh>autocompleter test</vh></v>
<v t="EKR.20040430162649.22"><vh>Other Reformat Paragraph tests</vh></v>
<v t="EKR.20040604082113"><vh>Test of @tabwidth</vh></v>
<v t="EKR.20040610092248"><vh>Test of pasting into big node</vh></v>
<v t="EKR.20040604170105"><vh>Test of Remove sentinels</vh></v>
<v t="ekr.20040711044029.1"><vh>Test new docutils stull</vh></v>
</v>
<v t="ekr.20040722051235"><vh>Mini tests of script buttons</vh>
<v t="ekr.20040712101754.273"><vh>Redundant: @suite run all doctests in @file nodes</vh></v>
<v t="ekr.20040721094335"><vh>runProfile button mini-test </vh></v>
<v t="ekr.20040721115141"><vh>runTimeit mini-test </vh></v>
<v t="ekr.20040721173532"><vh>profile redraws</vh></v>
</v>
<v t="EKR.20040608095146"><vh>Perfect import stuff...</vh>
<v t="EKR.20040504083716"><vh>Mulder Update script</vh>
<v t="EKR.20040504083716.39"><vh>sync</vh>
<v t="EKR.20040504153320"><vh>&lt;&lt; compute sourcetime and targettime &gt;&gt;</vh></v>
<v t="EKR.20040504153320.1"><vh>&lt;&lt; compute operation &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040716062608"><vh>Perfect Import Script</vh></v>
</v>
<v t="ekr.20040707104245"><vh>Printing tests...</vh>
<v t="ekr.20040323085933"><vh>Print findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040309111054"><vh>Print iterations: do not delete</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102"><vh>Clone test data</vh>
<v t="ekr.20040309111102.1"><vh>aa</vh></v>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.8"><vh>d</vh>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.9"><vh>e</vh></v>
<v t="ekr.20040309111102.10"><vh>z</vh></v>
</v>
<v t="ekr.20040309111232"><vh>last node</vh></v>
</v>
<v t="ekr.20040705191805"><vh>Print abbreviations</vh>
<v t="ekr.20040705212227"><vh>@file file</vh></v>
<v t="ekr.20040705192522"><vh>@silentfile silentfile</vh></v>
<v t="ekr.20040705192522.1"><vh>@file-asis file-asis</vh></v>
<v t="ekr.20040705192522.2"><vh>@asis asis</vh></v>
<v t="ekr.20040705192522.3"><vh>@nosentinelsfile nosentinelsfile</vh></v>
<v t="ekr.20040705191805.1"><vh>@file-nosent file-nosent</vh></v>
<v t="ekr.20040705191805.2"><vh>@nosent nosent</vh></v>
<v t="ekr.20040705192610"><vh>@rawfile rawfile</vh></v>
<v t="ekr.20040705192522.4"><vh>@file-noref file-noref</vh></v>
<v t="ekr.20040705192522.5"><vh>@noref noref</vh></v>
<v t="ekr.20040705192522.6"><vh>@file-thin file-thin</vh></v>
<v t="ekr.20040705192610.1"><vh>@thin thin</vh></v>
</v>
<v t="ekr.20040323085406"><vh>Print isAnyAtFileNode</vh></v>
<v t="ekr.20040708135624"><vh>Print fundChildrenOf and </vh></v>
<v t="EKR.20040526193608"><vh>Tests of pickle &amp; hexlify</vh></v>
<v t="EKR.20040526094831"><vh>Test of undo registration</vh></v>
<v t="EKR.20040526200017" myPlugin="7d710055016171014930310a732e"><vh>Test of unknownAttributes</vh></v>
<v t="EKR.20040602101648"><vh>Test of "end1" hook</vh></v>
<v t="EKR.20040603064545"><vh>Print timestamps of all nodes</vh></v>
<v t="EKR.20040603174633"><vh>test of focus</vh></v>
<v t="EKR.20040611083703"><vh>Using a generator instead of readLinesClass</vh></v>
<v t="EKR.20040612150543"><vh>Test of better error messages in Execute Script command</vh>
<v t="EKR.20040612215136"><vh>Contains error</vh></v>
</v>
<v t="EKR.20040627100615"><vh>Test of error messages when redirecting output</vh></v>
<v t="ekr.20040710141351"><vh>print all docstrings from a module</vh>
<v t="ekr.20040710145459"><vh>&lt;&lt; print names sorted by type &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040724171040"><vh>Tk bindtags test</vh></v>
<v t="ekr.20040708210636"><vh>User Icon tests</vh>
<v t="ekr.20040317173327"><vh>Delete user icons</vh></v>
<v t="ekr.20040317101155"><vh>Test of user icons</vh>
<v t="ekr.20040317185041"><vh>&lt;&lt; define event callbacks &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040730185319"><vh>Test drawing of root node w/o children</vh></v>
</v>
<v t="ekr.20040312021734"><vh>Scripts</vh>
<v t="ekr.20040318091620"><vh>Clear all unknown attributes</vh></v>
<v t="EKR.20040424065452"><vh>Compare script</vh></v>
<v t="EKR.20040424091411"><vh>Compare script using text mode to ignore newlines</vh></v>
<v t="EKR.20040517074600.8"><vh>Count pages</vh></v>
<v t="ekr.20040311090054"><vh>Dump fileIndex</vh></v>
<v t="ekr.20040319111213"><vh>FilterHoist script</vh>
<v t="ekr.20040319111213.1"><vh>description</vh></v>
<v t="ekr.20040319142708"><vh>filter</vh></v>
<v t="ekr.20040319142202"><vh>old code</vh>
<v t="ekr.20040319111213.2"><vh>filter</vh></v>
<v t="ekr.20040319111213.3"><vh>search</vh></v>
</v>
<v t="ekr.20040319111213.4"><vh>filterHoist</vh></v>
<v t="ekr.20040319111213.5"><vh>addMenu</vh></v>
</v>
<v t="ekr.20040715105834"><vh>Fun...</vh>
<v t="EKR.20040626212434"><vh>Drawing experiments</vh>
<v t="EKR.20040626212434.1"><vh>Rectangles &amp; ovals</vh></v>
<v t="EKR.20040626212434.2"><vh>Lines &amp; arcs</vh></v>
<v t="EKR.20040626213007"><vh>Paul Klee</vh></v>
<v t="EKR.20040627150213"><vh>Complex functions</vh></v>
</v>
<v t="ekr.20040714055306"><vh>elispToPy</vh>
<v t="ekr.20040715133744"><vh>To do</vh></v>
<v t="ekr.20040713123617.1"><vh>e2pyScript</vh>
<v t="ekr.20040713200238"><vh>Ref</vh>
<v t="ekr.20040713131315"><vh>To do</vh>
<v t="ekr.20040713133131"><vh>Tokens</vh></v>
<v t="ekr.20040713133131.1"><vh>Statements</vh></v>
<v t="ekr.20040713133131.2"><vh>Expressions</vh></v>
</v>
<v t="ekr.20040713130853"><vh>Docs</vh>
<v t="ekr.20040713130853.1"><vh>What elisp2py does</vh></v>
<v t="ekr.20040713130853.2"><vh>Theory of operation</vh></v>
<v t="ekr.20040713130853.3"><vh>&lt;&lt; specify user types &gt;&gt;</vh></v>
<v t="ekr.20040713130853.4"><vh>&lt;&lt; define testData &gt;&gt;</vh></v>
</v>
<v t="ekr.20040713144336"><vh>from c2py</vh>
<v t="ekr.20040713130853.15"><vh>Top-level scripts</vh>
<v t="ekr.20040713130853.16"><vh>convertCurrentTree</vh></v>
<v t="ekr.20040713130853.17"><vh>convertLeoTree</vh></v>
<v t="ekr.20040713130853.18"><vh>convertCFileToPython</vh></v>
<v t="ekr.20040713130853.7"><vh>speedTest</vh></v>
</v>
<v t="ekr.20040713130853.19"><vh>Top Level</vh>
<v t="ekr.20040713130853.20"><vh>convertCStringToPython</vh></v>
<v t="ekr.20040713130853.21"><vh>OLDconvertCodeList</vh></v>
<v t="ekr.20040713130853.22"><vh>convertDocList</vh></v>
<v t="ekr.20040713130853.23"><vh>skipDocPart</vh></v>
<v t="ekr.20040713130853.24"><vh>skipCodePart</vh></v>
</v>
<v t="ekr.20040713144926.1"><vh>Utils</vh>
<v t="ekr.20040713130853.61"><vh>safeReplace</vh></v>
<v t="ekr.20040713130853.43"><vh>match</vh></v>
<v t="ekr.20040713130853.44"><vh>matchWord</vh></v>
</v>
<v t="ekr.20040713130853.27"><vh>convertLeadingBlanks</vh></v>
<v t="ekr.20040713130853.28"><vh>findInList</vh></v>
<v t="ekr.20040713130853.29"><vh>findInCode</vh></v>
<v t="ekr.20040713130853.30"><vh>mungeAllFunctions</vh>
<v t="ekr.20040713130853.31"><vh>handlePossibleFunctionHeader</vh></v>
<v t="ekr.20040713130853.32"><vh>massageFunctionArgs</vh></v>
<v t="ekr.20040713130853.33"><vh>massageFunctionHead (sets gClassName)</vh></v>
<v t="ekr.20040713130853.34"><vh>massageFunctionBody</vh>
<v t="ekr.20040713130853.35"><vh>massageIvars</vh></v>
<v t="ekr.20040713130853.36"><vh>removeCasts</vh></v>
<v t="ekr.20040713130853.37"><vh>removeTypeNames</vh></v>
</v>
</v>
<v t="ekr.20040713130853.38"><vh>handleAllKeywords</vh>
<v t="ekr.20040713130853.39"><vh>handleKeyword</vh></v>
</v>
<v t="ekr.20040713130853.40"><vh>isWs and isWOrNl</vh></v>
<v t="ekr.20040713130853.41"><vh>isSectionDef</vh></v>
<v t="ekr.20040713130853.42"><vh>isStringOrComment</vh></v>
<v t="ekr.20040713130853.45"><vh>prevNonWsChar and prevNonWsOrNlChar</vh></v>
<v t="ekr.20040713144926.2"><vh>remove</vh>
<v t="ekr.20040713130853.46"><vh>removeAllCComments</vh></v>
<v t="ekr.20040713130853.47"><vh>removeAllCSentinels</vh></v>
<v t="ekr.20040713130853.48"><vh>removeAllPythonComments</vh></v>
<v t="ekr.20040713130853.49"><vh>removeAllPythonSentinels</vh></v>
<v t="ekr.20040713130853.50"><vh>removeAtRoot</vh></v>
<v t="ekr.20040713130853.51"><vh>removeBlankLines</vh></v>
<v t="ekr.20040713130853.52"><vh>removeExcessWs</vh>
<v t="ekr.20040713130853.53"><vh>removeExessWsFromLine</vh></v>
</v>
<v t="ekr.20040713130853.54"><vh>removeLeadingAtCode</vh></v>
<v t="ekr.20040713130853.55"><vh>removeMatchingBrackets</vh></v>
<v t="ekr.20040713130853.56"><vh>removeSemicolonsAtEndOfLines</vh></v>
<v t="ekr.20040713130853.57"><vh>removeTrailingWs</vh></v>
</v>
<v t="ekr.20040713144926.3"><vh>replace...</vh>
<v t="ekr.20040713130853.58"><vh>replace</vh></v>
<v t="ekr.20040713130853.59"><vh>replaceComments</vh></v>
<v t="ekr.20040713130853.60"><vh>replaceSectionDefs</vh></v>
</v>
<v t="ekr.20040713144926.4"><vh>skip...</vh>
<v t="ekr.20040713130853.62"><vh>skipCBlockComment</vh></v>
<v t="ekr.20040713130853.63"><vh>skipPastLine</vh></v>
<v t="ekr.20040713130853.64"><vh>skipPastWord</vh></v>
<v t="ekr.20040713130853.65"><vh>skipString</vh></v>
<v t="ekr.20040713130853.66"><vh>skipStringOrComment</vh></v>
<v t="ekr.20040713130853.68"><vh>skipWs and skipWsAndNl</vh></v>
</v>
</v>
<v t="ekr.20040713150856.1"><vh>g.scanning...</vh>
<v t="ekr.20040713150856.8"><vh>Scanners: calling scanError</vh>
<v t="ekr.20040713150856.9"><vh>skip_block_comment</vh></v>
<v t="ekr.20040713150856.10"><vh>skip_braces</vh></v>
<v t="ekr.20040713150856.12"><vh>skip_parens</vh></v>
<v t="ekr.20040713150856.13"><vh>skip_pascal_begin_end</vh></v>
<v t="ekr.20040713150856.14"><vh>skip_pascal_block_comment</vh></v>
<v t="ekr.20040713150856.15"><vh>skip_pascal_string : called by tangle</vh></v>
<v t="ekr.20040713150856.20"><vh>skip_python_string</vh></v>
<v t="ekr.20040713150856.21"><vh>skip_string : called by tangle</vh></v>
<v t="ekr.20040713150856.22"><vh>skip_to_semicolon</vh></v>
</v>
<v t="ekr.20040713150856.24"><vh>Scanners: no error messages</vh>
<v t="ekr.20040713150856.25"><vh>escaped</vh></v>
<v t="ekr.20040713150856.26"><vh>find_line_start</vh></v>
<v t="ekr.20040713150856.27"><vh>find_on_line</vh></v>
<v t="ekr.20040713150856.28"><vh>is_c_id</vh></v>
<v t="ekr.20040713150856.29"><vh>is_nl</vh></v>
<v t="ekr.20040713150856.30"><vh>is_special</vh></v>
<v t="ekr.20040713150856.31"><vh>is_ws &amp; is_ws_or_nl</vh></v>
<v t="ekr.20040713150856.32"><vh>match</vh></v>
<v t="ekr.20040713150856.33"><vh>match_c_word</vh></v>
<v t="ekr.20040713150856.34"><vh>match_ignoring_case</vh></v>
<v t="ekr.20040713150856.35"><vh>match_word</vh></v>
<v t="ekr.20040713150856.36"><vh>skip_blank_lines</vh></v>
<v t="ekr.20040713150856.37"><vh>skip_c_id</vh></v>
<v t="ekr.20040713150856.38"><vh>skip_id</vh></v>
<v t="ekr.20040713150856.39"><vh>skip_line, skip_to_end_of_line</vh></v>
<v t="ekr.20040713150856.40"><vh>skip_long</vh></v>
<v t="ekr.20040713150856.41"><vh>skip_matching_delims</vh></v>
<v t="ekr.20040713150856.42"><vh>skip_nl</vh></v>
<v t="ekr.20040713150856.43"><vh>skip_non_ws</vh></v>
<v t="ekr.20040713150856.44"><vh>skip_pascal_braces</vh></v>
<v t="ekr.20040713150856.45"><vh>skip_to_char</vh></v>
<v t="ekr.20040713150856.46"><vh>skip_ws, skip_ws_and_nl</vh></v>
</v>
<v t="ekr.20040713150856.47"><vh>splitLines &amp; joinLines</vh></v>
</v>
<v t="ekr.20040713205718"><vh>createIndentedBlock NOT USED</vh>
<v t="ekr.20040714074445"><vh>&lt;&lt; insert nl and ws tokens &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040713131350"><vh>-input-</vh>
<v t="ekr.20040715071555"><vh>igrep-read-file-name</vh></v>
</v>
<v t="ekr.20040713132127.1"><vh>igrep.el</vh>
<v t="ekr.20040713132127.2"><vh>provide</vh></v>
<v t="ekr.20040713132127.3"><vh>const igrep-version</vh></v>
<v t="ekr.20040713132127.4"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.5"><vh>var igrep-options</vh></v>
<v t="ekr.20040713132127.6"><vh>put</vh></v>
<v t="ekr.20040713132127.7"><vh>var igrep-read-options</vh></v>
<v t="ekr.20040713132127.8"><vh>put</vh></v>
<v t="ekr.20040713132127.9"><vh>var igrep-read-multiple-files</vh></v>
<v t="ekr.20040713132127.10"><vh>put</vh></v>
<v t="ekr.20040713132127.11"><vh>var igrep-expression-default</vh></v>
<v t="ekr.20040713132127.12"><vh>put</vh></v>
<v t="ekr.20040713132127.13"><vh>var igrep-files-default</vh></v>
<v t="ekr.20040713132127.14"><vh>put</vh></v>
<v t="ekr.20040713132127.15"><vh>var igrep-verbose-prompts</vh></v>
<v t="ekr.20040713132127.16"><vh>put</vh></v>
<v t="ekr.20040713132127.17"><vh>var igrep-insert-default-key</vh></v>
<v t="ekr.20040713132127.18"><vh>put</vh></v>
<v t="ekr.20040713132127.19"><vh>var igrep-save-buffers</vh></v>
<v t="ekr.20040713132127.20"><vh>put</vh></v>
<v t="ekr.20040713132127.21"><vh>var igrep-null-device</vh></v>
<v t="ekr.20040713132127.22"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.23"><vh>var igrep-program</vh></v>
<v t="ekr.20040713132127.24"><vh>var igrep-expression-option</vh></v>
<v t="ekr.20040713132127.25"><vh>var igrep-program-table</vh></v>
<v t="ekr.20040713132127.26"><vh>var igrep-use-zgrep</vh></v>
<v t="ekr.20040713132127.27"><vh>var igrep-find</vh></v>
<v t="ekr.20040713132127.28"><vh>var igrep-find-program</vh></v>
<v t="ekr.20040713132127.29"><vh>var igrep-find-prune-clause</vh></v>
<v t="ekr.20040713132127.30"><vh>var igrep-find-file-clause</vh></v>
<v t="ekr.20040713132127.31"><vh>var igrep-find-use-xargs</vh></v>
<v t="ekr.20040713132127.32"><vh>var igrep-program-default</vh></v>
<v t="ekr.20040713132127.33"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.34"><vh>var igrep-expression-history</vh></v>
<v t="ekr.20040713132127.35"><vh>var igrep-files-history</vh></v>
<v t="ekr.20040713132127.36"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.37"><vh>igrep-insinuate</vh></v>
<v t="ekr.20040713132127.38"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.39"><vh>igrep</vh></v>
<v t="ekr.20040713132127.40"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.41"><vh>igrep-find</vh></v>
<v t="ekr.20040713132127.42"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.43"><vh>igrep-visited-files</vh></v>
<v t="ekr.20040713132127.44"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.45"><vh>dired-do-igrep</vh></v>
<v t="ekr.20040713132127.46"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.47"><vh>dired-do-igrep-find</vh></v>
<v t="ekr.20040713132127.48"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.49"><vh>Buffer-menu-igrep</vh></v>
<v t="ekr.20040713132127.50"><vh>unnamed data</vh></v>
<v t="ekr.20040713132127.51"><vh>igrep-dired-file-current-word</vh></v>
<v t="ekr.20040713132127.52"><vh>igrep-buffer-file-name-pattern</vh></v>
<v t="ekr.20040713132127.53"><vh>igrep-dired-directory-file-pattern</vh></v>
<v t="ekr.20040713132127.54"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.55"><vh>igrep-format-find-command</vh></v>
<v t="ekr.20040713132127.56"><vh>defmacro</vh></v>
<v t="ekr.20040713132127.57"><vh>igrep-default-expression</vh></v>
<v t="ekr.20040713132127.58"><vh>igrep-default-files</vh></v>
<v t="ekr.20040713132127.59"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.60"><vh>igrep-read-args</vh></v>
<v t="ekr.20040713132127.61"><vh>igrep-read-program</vh></v>
<v t="ekr.20040713132127.62"><vh>igrep-read-options</vh></v>
<v t="ekr.20040713132127.63"><vh>igrep-read-expression</vh></v>
<v t="ekr.20040713132127.64"><vh>igrep-insert-default-expression</vh></v>
<v t="ekr.20040713132127.65"><vh>igrep-insert-default-files</vh></v>
<v t="ekr.20040713132127.66"><vh>defsubst</vh></v>
<v t="ekr.20040713132127.67"><vh>igrep-read-files</vh></v>
<v t="ekr.20040713132127.68"><vh>igrep-read-file-name</vh></v>
<v t="ekr.20040713132127.69"><vh>unnamed data</vh></v>
</v>
</v>
<v t="ekr.20040713130853.8"><vh>elisp2py.py</vh>
<v t="ekr.20040715093804"><vh>Utility functions</vh>
<v t="ekr.20040715073230"><vh>isList &amp; isToken</vh></v>
<v t="ekr.20040715082059"><vh>printHeading</vh></v>
<v t="ekr.20040714095247"><vh>parseTreeToString</vh></v>
</v>
<v t="ekr.20040713150037"><vh>class tok</vh>
<v t="ekr.20040713150037.1"><vh>tok.__init__</vh></v>
<v t="ekr.20040714170021"><vh>tok.isParseTok</vh></v>
<v t="ekr.20040713150712"><vh>tok.copy</vh></v>
<v t="ekr.20040713173923"><vh>tok.match</vh></v>
<v t="ekr.20040713174349"><vh>tok.dump</vh></v>
<v t="ekr.20040713180208"><vh>tok.toString &amp; allies</vh>
<v t="ekr.20040713164604"><vh>tok.wsToString</vh></v>
</v>
</v>
<v t="ekr.20040715080216"><vh>class lineClass</vh>
<v t="ekr.20040715080738"><vh>line.__init__</vh></v>
<v t="ekr.20040715081031"><vh>line.add</vh></v>
<v t="ekr.20040715080738.1"><vh>line.toString</vh></v>
</v>
<v t="ekr.20040713144036"><vh>class elisp2pyClass</vh>
<v t="ekr.20040713144036.1"><vh>e.__init__</vh>
<v t="ekr.20040714061625"><vh>&lt;&lt; define elisp constants &gt;&gt;</vh></v>
<v t="ekr.20040714061625.2"><vh>&lt;&lt; define elisp functions &gt;&gt;</vh></v>
<v t="ekr.20040714061625.1"><vh>&lt;&lt; define elisp statements &gt;&gt;</vh></v>
<v t="ekr.20040715090957"><vh>&lt;&lt; define code gen dispatch table &gt;&gt;</vh></v>
</v>
<v t="ekr.20040713152809"><vh>Utils</vh>
<v t="ekr.20040713193437"><vh>deleteTokens</vh></v>
<v t="ekr.20040713161629.1"><vh>dump</vh></v>
<v t="ekr.20040713152318"><vh>error &amp; warning</vh></v>
<v t="ekr.20040713151556.1"><vh>findMatchingBracket</vh></v>
<v t="ekr.20040713160302"><vh>findTokens</vh></v>
<v t="ekr.20040714060941"><vh>isMatchingBracket</vh></v>
<v t="ekr.20040714053807.1"><vh>isStatement</vh></v>
<v t="ekr.20040714054620.1"><vh>matchTokens</vh></v>
<v t="ekr.20040713150314.1"><vh>replaceAll (not used yet)</vh></v>
<v t="ekr.20040713144926"><vh>tokenize &amp; allies</vh>
<v t="ekr.20040713154118"><vh>skipString</vh></v>
</v>
</v>
<v t="ekr.20040713211010"><vh>convert (main line)</vh></v>
<v t="ekr.20040714082939"><vh>Parser &amp; allies</vh>
<v t="ekr.20040714155341"><vh>parse</vh>
<v t="ekr.20040714154314"><vh>&lt;&lt; give error message about mismatched parens &gt;&gt;</vh></v>
</v>
<v t="ekr.20040714091940.1"><vh>block</vh></v>
</v>
<v t="ekr.20040714222507"><vh>Code gen</vh>
<v t="ekr.20040715081425"><vh>dumpCodeList</vh></v>
<v t="ekr.20040715075914"><vh>newCodeLine</vh></v>
<v t="ekr.20040714072448"><vh>removeBlankLines</vh></v>
</v>
<v t="ekr.20040715090957.2"><vh>gen_xxx</vh>
<v t="ekr.20040715071350"><vh>gen</vh></v>
<v t="ekr.20040715125453"><vh>gen_computed_function</vh></v>
<v t="ekr.20040715120001"><vh>gen_cond</vh></v>
<v t="ekr.20040715120001.1"><vh>gen_defconst</vh></v>
<v t="ekr.20040715120001.2"><vh>gen_defsubst</vh></v>
<v t="ekr.20040715093122"><vh>gen_defun</vh></v>
<v t="ekr.20040715120001.3"><vh>gen_defvar</vh></v>
<v t="ekr.20040715121456"><vh>gen_expression</vh></v>
<v t="ekr.20040715091409"><vh>gen_function</vh></v>
<v t="ekr.20040715120001.4"><vh>gen_if</vh></v>
<v t="ekr.20040715120001.5"><vh>gen_let, gen_let_star</vh></v>
<v t="ekr.20040715084435"><vh>gen_list</vh></v>
<v t="ekr.20040715120001.7"><vh>gen_prog, gen_prog1, gen_progn</vh></v>
<v t="ekr.20040715120001.8"><vh>gen_set &amp; gen_setq</vh></v>
<v t="ekr.20040715090957.1"><vh>gen_statement</vh></v>
<v t="ekr.20040715075845"><vh>gen_token</vh></v>
<v t="ekr.20040715120001.9"><vh>gen_unless, gen_when, gen_while</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="EKR.20040613162717"><vh>Report newlines</vh></v>
<v t="ekr.20040312021734.1"><vh>Script to clean unused tnodeLists</vh></v>
<v t="ekr.20040330095252"><vh>script to clear log frame</vh></v>
<v t="ekr.20040322120331"><vh>script to print tnodeList's</vh></v>
<v t="EKR.20040517074600.9"><vh>Scripts to debug font problem</vh>
<v t="EKR.20040517074600.10"><vh>Show font</vh></v>
<v t="EKR.20040517074600.11"><vh>Show settings</vh>
<v t="EKR.20040517074600.12"><vh>getFontSettings</vh></v>
</v>
<v t="EKR.20040517074600.13"><vh>Print default font</vh></v>
</v>
<v t="ekr.20040723065021"><vh>stripBlankLines</vh>
<v t="ekr.20040723065047"><vh>Test</vh></v>
</v>
<v t="ekr.20040717121014"><vh>tellGnxScript</vh></v>
<v t="ekr.20040706071823"><vh>test of Python's parser module</vh></v>
</v>
<v t="ekr.20040723064143.1"><vh>To do (when file tests are easier)</vh>
<v t="ekr.20040723064143.2"><vh>Finish unit tests for @asis</vh></v>
<v t="ekr.20040723064143.3"><vh>Test error recovery when reading descendentTnodeUa's</vh></v>
</v>
<v t="EKR.20040619133116" a="ETV"><vh>Unit testing...</vh>
<v t="ekr.20040327114250" tnodeList="ekr.20040327114250"><vh>@file c:\prog\test\unittest\batchTest.py</vh></v>
<v t="ekr.20040712101754"><vh>Unit Tests</vh>
<v t="ekr.20040716144017"><vh>Perfect Import tests</vh>
<v t="ekr.20040716071029.6"><vh>@test inserting a line: no trailing newline</vh>
<v t="ekr.20040716071856.1"><vh>-input</vh></v>
<v t="ekr.20040716081019"><vh>-input-after</vh></v>
<v t="ekr.20040716071856"><vh>-output-sent</vh></v>
<v t="ekr.20040716091245"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716084934"><vh>-i_lines</vh></v>
<v t="ekr.20040716084934.1"><vh>-j_lines</vh></v>
<v t="ekr.20040716081943"><vh>-result</vh></v>
</v>
<v t="ekr.20040716140926"><vh>@test replace one line</vh>
<v t="ekr.20040716140926.1"><vh>-input</vh></v>
<v t="ekr.20040716140926.2"><vh>-input-after</vh></v>
<v t="ekr.20040716140926.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716140926.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716140926.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716140926.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716140926.7"><vh>-result</vh></v>
</v>
<v t="ekr.20040716141621"><vh>@test replace multiple lines</vh>
<v t="ekr.20040716141621.1"><vh>-input</vh></v>
<v t="ekr.20040716141621.2"><vh>-input-after</vh></v>
<v t="ekr.20040716141621.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716141621.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716141621.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716141621.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716141621.7"><vh>-result</vh></v>
</v>
<v t="ekr.20040716142121"><vh>@test replace across sentinel blocks: Succeeds ONLY when ignoring sentinels</vh>
<v t="ekr.20040716142423"><vh>-input</vh>
<v t="ekr.20040716142423.1"><vh>Node 1</vh></v>
<v t="ekr.20040716142423.2"><vh>Node 2</vh></v>
</v>
<v t="ekr.20040716142121.2"><vh>-input-after</vh>
<v t="ekr.20040717071133"><vh>Node 1</vh></v>
<v t="ekr.20040717071133.1"><vh>Node 2</vh></v>
</v>
<v t="ekr.20040716142121.3"><vh>-output-sent</vh></v>
<v t="ekr.20040716142121.5"><vh>-i_lines</vh></v>
<v t="ekr.20040716142121.6"><vh>-j_lines</vh></v>
<v t="ekr.20040716142121.4"><vh>-output-after-sent</vh></v>
<v t="ekr.20040716142121.7"><vh>-result</vh></v>
</v>
</v>
<v t="ekr.20040712101754.7"><vh>Import/Export tests</vh>
<v t="ekr.20040712101754.8"><vh>@suite Import tests</vh></v>
<v t="ekr.20040712101754.9"><vh>@suite Export tests</vh></v>
<v t="ekr.20040712101754.10"><vh>importTests</vh>
<v t="ekr.20040712101754.11"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.12"><vh>importAtRoot</vh>
<v t="ekr.20040712101754.13"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.16"><vh>importNowebFiles</vh>
<v t="ekr.20040712101754.17"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.18"><vh>importFlattenedOutline</vh>
<v t="ekr.20040712101754.19"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.20"><vh>importCWEBFiles</vh>
<v t="ekr.20040712101754.21"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.22"><vh>removeSentinels</vh>
<v t="ekr.20040712101754.23"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.14"><vh>importAtFile</vh>
<v t="ekr.20040712101754.15"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040712101754.24"><vh>exportTests</vh>
<v t="ekr.20040712101754.25"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.26"><vh>exportHeadlines</vh>
<v t="ekr.20040712101754.27"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.28"><vh>flattenOutline</vh>
<v t="ekr.20040712101754.29"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.30"><vh>weave</vh>
<v t="ekr.20040712101754.31"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.32"><vh>outlineToNoweb</vh>
<v t="ekr.20040712101754.33"><vh>dialog</vh></v>
</v>
<v t="ekr.20040712101754.34"><vh>outlineToCWEB</vh>
<v t="ekr.20040712101754.35"><vh>dialog</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.2"><vh>Test Leo files...</vh>
<v t="ekr.20040730181601"><vh>@test minimalLeoFile.leo</vh></v>
<v t="ekr.20040730181610"><vh>@test minimalLeoFile2.leo</vh></v>
<v t="ekr.20040712101754.3"><vh>@test test.leo</vh></v>
<v t="ekr.20040803090901"><vh>@test leoDist.leo</vh></v>
<v t="ekr.20040712101754.4"><vh>@test LeoPy.leo</vh></v>
<v t="ekr.20040712101754.5"><vh>@test leoPlugins.leo</vh></v>
<v t="ekr.20040712101754.6"><vh>@test LeoDocs.leo</vh></v>
</v>
<v t="ekr.20040712101754.36"><vh>Non-file tests</vh>
<v t="ekr.20040712101754.37"><vh>@suite Edit body tests</vh>
<v t="ekr.20040712101754.38"><vh>editBodyTests</vh>
<v t="ekr.20040712101754.39"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.40"><vh>extractSection</vh>
<v t="ekr.20040712101754.41"><vh>before</vh></v>
<v t="ekr.20040712101754.42"><vh>after</vh>
<v t="ekr.20040712101754.43"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040712101754.44"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.45"><vh>indentBody</vh>
<v t="ekr.20040712101754.46"><vh>before</vh></v>
<v t="ekr.20040712101754.47"><vh>after</vh></v>
<v t="ekr.20040712101754.48"><vh>selection</vh></v>
</v>
<v t="ekr.20040712101754.49"><vh>dedentBody</vh>
<v t="ekr.20040712101754.50"><vh>before</vh></v>
<v t="ekr.20040712101754.51"><vh>after</vh></v>
<v t="ekr.20040712101754.52"><vh>selection</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.53"><vh>@suite Reformat Paragraph Tests</vh>
<v t="ekr.20040712101754.54"><vh>What I did</vh></v>
<v t="ekr.20040712101754.55"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040712101754.56"><vh>tempNode</vh></v>
<v t="ekr.20040712101754.57"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040712101754.58"><vh>before</vh></v>
<v t="ekr.20040712101754.59"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.60"><vh>testTrailingNewline</vh>
<v t="ekr.20040712101754.61"><vh>before</vh></v>
<v t="ekr.20040712101754.62"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.63"><vh>testMixedLineLengths</vh>
<v t="ekr.20040712101754.64"><vh>before</vh></v>
<v t="ekr.20040712101754.65"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.66"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040712101754.67"><vh>before</vh></v>
<v t="ekr.20040712101754.68"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.69"><vh>testNoChangeRequired</vh>
<v t="ekr.20040712101754.70"><vh>before</vh></v>
<v t="ekr.20040712101754.71"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.72"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040712101754.73"><vh>before</vh></v>
<v t="ekr.20040712101754.74"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.75"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040712101754.76"><vh>before</vh></v>
<v t="ekr.20040712101754.77"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.78"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040712101754.79"><vh>before</vh></v>
<v t="ekr.20040712101754.80"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.81"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040712101754.82"><vh>before</vh></v>
<v t="ekr.20040712101754.83"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.84"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040712101754.85"><vh>before</vh></v>
<v t="ekr.20040712101754.86"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.87"><vh>testMultiParagraph</vh>
<v t="ekr.20040712101754.88"><vh>before</vh></v>
<v t="ekr.20040712101754.89"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.90"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040712101754.91"><vh>before</vh></v>
<v t="ekr.20040712101754.92"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.93"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040712101754.94"><vh>before</vh></v>
<v t="ekr.20040712101754.95"><vh>after</vh></v>
</v>
<v t="ekr.20040712101754.96"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040712101754.97"><vh>before</vh></v>
<v t="ekr.20040712101754.98"><vh>after</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.99"><vh>@test c iters</vh>
<v t="ekr.20040712101754.100"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="ekr.20040712101754.101"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20040802065214"><vh>@test changing headline marks descendent @thin nodes dirty</vh>
<v t="ekr.20040802065214.1"><vh>bogus</vh></v>
</v>
<v t="ekr.20040712101754.272"><vh>@test CheckOutline</vh></v>
<v t="ekr.20040802071519"><vh>@test p.setBodyStringOrPane</vh>
<v t="ekr.20040802071519.1"><vh>child</vh></v>
</v>
<v t="ekr.20040713070526"><vh>@test Pretty Print command</vh>
<v t="ekr.20040713123617"><vh>tempNode</vh></v>
<v t="ekr.20040713071919"><vh>before</vh></v>
<v t="ekr.20040713123828.1"><vh>after</vh></v>
</v>
<v t="ekr.20040803091512" a="M"><vh>@test bogus tnodeList doesn't corrupt @thin nodes</vh></v>
<v t="ekr.20040712101754.102"><vh>atFileTests...</vh>
<v t="ekr.20040712101754.103"><vh>@test @file no newline</vh>
<v t="ekr.20040712101754.104"><vh>@@file</vh></v>
<v t="ekr.20040712101754.105"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.106"><vh>@test @file one newline</vh>
<v t="ekr.20040712101754.107"><vh>@@file</vh></v>
<v t="ekr.20040712101754.108"><vh>Output</vh></v>
</v>
<v t="ekr.20040712101754.109"><vh>@test @file two newlines</vh>
<v t="ekr.20040712101754.110"><vh>@@file</vh></v>
<v t="ekr.20040712101754.111"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.12"><vh>@test @thin</vh>
<v t="ekr.20040707141957.13"><vh>@@thin</vh></v>
<v t="ekr.20040707141957.14"><vh>Output</vh></v>
</v>
</v>
<v t="ekr.20040712101754.115"><vh>Colorizer tests...</vh>
<v t="ekr.20040712101754.116"><vh>@test @comment after @language plain</vh>
<v t="ekr.20040712101754.117"><vh>Test</vh></v>
</v>
<v t="ekr.20040712101754.118"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20040712101754.119"><vh>Actionscript</vh></v>
</v>
<v t="ekr.20040712101754.120"><vh>@test colorizer C</vh>
<v t="ekr.20040712101754.121"><vh>C</vh></v>
</v>
<v t="ekr.20040712101754.122"><vh>@test colorizer C#</vh>
<v t="ekr.20040712101754.123"><vh>C#</vh></v>
</v>
<v t="ekr.20040712101754.124"><vh>@test colorizer css</vh>
<v t="ekr.20040712101754.125"><vh>css</vh></v>
</v>
<v t="ekr.20040712101754.126"><vh>@test colorizer CWEB</vh>
<v t="ekr.20040712101754.127"><vh>CWEB</vh>
<v t="ekr.20040712101754.128"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040712101754.129"><vh>@test colorizer elisp</vh>
<v t="ekr.20040712101754.130"><vh>elisp</vh></v>
</v>
<v t="ekr.20040712101754.131"><vh>@test colorizer HTML string bug</vh>
<v t="ekr.20040712101754.132"><vh>String bug in html</vh></v>
</v>
<v t="ekr.20040712101754.133"><vh>@test colorizer HTML1</vh>
<v t="ekr.20040712101754.134"><vh>HTML1</vh></v>
</v>
<v t="ekr.20040712101754.135"><vh>@test colorizer HTML2</vh>
<v t="ekr.20040712101754.136"><vh>HTML2</vh></v>
</v>
<v t="ekr.20040712101754.137"><vh>@test colorizer LaTex</vh>
<v t="ekr.20040712101754.138"><vh>LaTex</vh></v>
</v>
<v t="ekr.20040712101754.139"><vh>@test colorizer mixed</vh>
<v t="ekr.20040712101754.140"><vh>Mixed</vh></v>
</v>
<v t="ekr.20040712101754.141"><vh>@test colorizer PHP</vh>
<v t="ekr.20040712101754.142"><vh>PHP</vh></v>
</v>
<v t="ekr.20040712101754.143"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="ekr.20040712101754.144"><vh>python.xml</vh>
<v t="ekr.20040712101754.145"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="ekr.20040712101754.146"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="ekr.20040712101754.147"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="ekr.20040712101754.148"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="ekr.20040712101754.149"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="ekr.20040712101754.150"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="ekr.20040712101754.151"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="ekr.20040712101754.152"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="ekr.20040712101754.153"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040712101754.154"><vh>@test colorizer Python1</vh>
<v t="ekr.20040712101754.155"><vh>Python1</vh></v>
</v>
<v t="ekr.20040712101754.156"><vh>@test colorizer Python2</vh>
<v t="ekr.20040712101754.157"><vh>Python2</vh></v>
</v>
<v t="ekr.20040712101754.158"><vh>@test colorizer rapidq</vh>
<v t="ekr.20040712101754.159"><vh>rapidq</vh></v>
</v>
<v t="ekr.20040712101754.160"><vh>@test colorizer Rebol</vh>
<v t="ekr.20040712101754.161"><vh>Rebol</vh></v>
</v>
<v t="ekr.20040712101754.162"><vh>@test colorizer shell</vh>
<v t="ekr.20040712101754.163"><vh>shell</vh></v>
</v>
<v t="ekr.20040712101754.164"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="ekr.20040712101754.165"><vh>tex.xml</vh>
<v t="ekr.20040712101754.166"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="ekr.20040712101754.167"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040712101754.168"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20040712101754.169"><vh>wikiTest1</vh></v>
</v>
<v t="ekr.20040712101754.170"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20040712101754.171"><vh>wikiTest2</vh></v>
</v>
<v t="ekr.20040712101754.172"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20040712101754.173"><vh>wikiTest3</vh></v>
</v>
</v>
<v t="ekr.20040712101754.174"><vh>Mini tests...</vh>
<v t="ekr.20040712101754.175"><vh>@test p.t == p.v.t</vh></v>
<v t="ekr.20040712101754.176"><vh>@test python keywords</vh></v>
<v t="ekr.20040712101754.177"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20040712101754.178"><vh>File Conversion</vh>
<v t="ekr.20040712101754.179"><vh>moreHead</vh></v>
<v t="ekr.20040712101754.180"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20040712101754.181"><vh>inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
<v t="ekr.20040712101754.182"><vh>parent</vh>
<v t="ekr.20040712101754.183"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
</v>
<v t="ekr.20040712101754.184"><vh>@test consistency of p.v.t.vnodeList &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040712101754.185"><vh>@test that cloned nodes actually share subtrees</vh></v>
<v t="ekr.20040712101754.186"><vh>@test batch mode</vh></v>
</v>
<v t="ekr.20040712101754.187"><vh>Position tests...</vh>
<v t="ekr.20040712101754.188"><vh>@test p.iters and v.iters</vh>
<v t="ekr.20040712101754.189"><vh>child1</vh>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.192"><vh>c</vh></v>
<v t="ekr.20040712101754.190"><vh>a</vh>
<v t="ekr.20040712101754.191"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.193"><vh>d</vh>
<v t="ekr.20040712101754.194"><vh>e</vh></v>
</v>
</v>
<v t="ekr.20040712101754.195"><vh>child2</vh></v>
<v t="ekr.20040712101754.196"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="ekr.20040712101754.197"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="ekr.20040712101754.198"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20040712101754.199"><vh>@test p.comparisons</vh></v>
<v t="ekr.20040712101754.200"><vh>@test that clones share subtrees</vh></v>
<v t="ekr.20040712101754.201"><vh>@test consistency of c.allNodes_iter() and p.ThreadNext()</vh></v>
<v t="ekr.20040712101754.202"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20040712101754.203"><vh>@test consistency of level</vh></v>
<v t="ekr.20040712101754.204"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20040712101754.205"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20040712101754.206"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20040712101754.207"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20040712101754.208"><vh>@test consistency of tnodeListAndParents</vh></v>
<v t="ekr.20040712101754.209"><vh>@test hasNextBack</vh></v>
<v t="ekr.20040712101754.210"><vh>@test hasParentChild</vh></v>
<v t="ekr.20040712101754.211"><vh>@test hasThreadNextBack</vh></v>
<v t="ekr.20040712101754.212"><vh>@test vnode list</vh></v>
<v t="ekr.20040722055040"><vh>@test isAncestorOf</vh></v>
</v>
<v t="ekr.20040723062819"><vh>Syntax Checks...</vh>
<v t="EKR.20040612095237"><vh>@test checkPythonCode (bad syntax)</vh>
<v t="EKR.20040610192622.1"><vh>Check Syntax data (bad)</vh></v>
</v>
<v t="ekr.20040715154319"><vh>@test checkPythonCode (bad tabnanny)</vh>
<v t="EKR.20040610194209.1"><vh>TabNanny data (bad)</vh></v>
</v>
<v t="ekr.20040712101813"><vh>@test checkAllPythonCode</vh></v>
</v>
</v>
<v t="ekr.20040712101754.274" a="M"><vh>@suite run all doctests in leo*.py</vh></v>
<v t="ekr.20040712101754.261"><vh>Plugins tests</vh>
<v t="ekr.20040801141212"><vh>@suite test syntax of all plugins correctly</vh>
<v t="ekr.20040801141543"><vh>class parseFileTestCase</vh>
<v t="ekr.20040801141543.1"><vh>__init__</vh></v>
<v t="ekr.20040801141543.3"><vh>runTest</vh></v>
<v t="ekr.20040801141543.5"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040801145836"><vh>(dangerous) @suite run unitTest method of plugins</vh>
<v t="ekr.20040801150333"><vh>class runPluginTestCase</vh>
<v t="ekr.20040801150333.1"><vh>__init__</vh></v>
<v t="ekr.20040801150333.2"><vh>runTest</vh></v>
<v t="ekr.20040801150333.3"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040801124822.1"><vh>@test plugins/nodenavigator.py</vh></v>
</v>
<v t="ekr.20040712101754.213"><vh>Unfinished tests...</vh>
<v t="ekr.20040712101754.214"><vh>Outline tests (Sometimes fails)</vh>
<v t="ekr.20040712101754.215"><vh>test of p.copyTreeAfter and p.copyTreeFromSelfTo</vh>
<v t="ekr.20040712101754.216"><vh>root1</vh>
<v t="ekr.20040712101754.217"><vh>a</vh>
<v t="ekr.20040712101754.218"><vh>c</vh>
<v t="ekr.20040712101754.219"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20040712101754.220"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.221"><vh>Manual test of testUtils.replaceOutline</vh>
<v t="ekr.20040712101754.222"><vh>outline1</vh>
<v t="ekr.20040712101754.223"><vh>a</vh></v>
</v>
<v t="ekr.20040712101754.224"><vh>outline2</vh>
<v t="ekr.20040712101754.225"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.226"><vh>testUtils.replaceOutline</vh></v>
<v t="ekr.20040712101754.227"><vh>@@ suite Outline/Undo tests</vh>
<v t="ekr.20040712101754.228"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040712101754.229"><vh>class outlineTestCase</vh>
<v t="ekr.20040712101754.230"><vh>__init__</vh></v>
<v t="ekr.20040712101754.231"><vh>outlineCommand</vh></v>
<v t="ekr.20040712101754.232"><vh>runTest</vh></v>
<v t="ekr.20040712101754.233"><vh>setUp</vh></v>
<v t="ekr.20040712101754.234"><vh>tearDown</vh></v>
<v t="ekr.20040712101754.235"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040712101754.236"><vh>outlineTests</vh>
<v t="ekr.20040712101754.237"><vh>moveOutlineDown</vh>
<v t="ekr.20040712101754.238"><vh>before</vh>
<v t="ekr.20040712101754.239"><vh>a</vh></v>
<v t="ekr.20040712101754.240"><vh>move</vh></v>
<v t="ekr.20040712101754.241"><vh>b</vh></v>
</v>
<v t="ekr.20040712101754.242"><vh>after</vh>
<v t="ekr.20040712101754.243"><vh>a</vh></v>
<v t="ekr.20040712101754.244"><vh>b</vh></v>
<v t="ekr.20040712101754.245"><vh>move</vh></v>
</v>
<v t="ekr.20040712101754.246"><vh>ref</vh>
<v t="ekr.20040712101754.247"><vh>a</vh></v>
<v t="ekr.20040712101754.248"><vh>move</vh></v>
<v t="ekr.20040712101754.249"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040712101754.250"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040712101754.251"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040712101754.252"><vh>moveOutlineUp</vh></v>
</v>
</v>
<v t="ekr.20040712101754.253"><vh>Find Command tests...(Not finished)</vh>
<v t="ekr.20040712101754.254"><vh>@suite Find sommands tests</vh>
<v t="ekr.20040712101754.255"><vh>class findCommandTestCase</vh>
<v t="ekr.20040712101754.256"><vh>setUp</vh></v>
<v t="ekr.20040712101754.257"><vh>testFindCommand</vh></v>
<v t="ekr.20040712101754.258"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040712101754.259"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040712101754.260"><vh>findTests</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707081532.1"><vh>Do @test</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040424065452">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
lines1 = f1.readlines()
lines2 = f2.readlines()
f1.close() ; f2.close()

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
text1 = f1.read()
text2 = f2.read()
f1.close() ; f2.close()

cr1 = text1.count('\r')
cr2 = text2.count('\r')

print '-'*20
print "lines ",len(lines1),len(lines2)
print "chars ",len(text1),len(text2)
print "non-cr",len(text1)-cr1,len(text2)-cr2
print "cr    ",cr1,cr2</t>
<t tx="EKR.20040424091411">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
g.es("equal (raw mode)",f1.read()==f2.read())
f1.close() ; f2.close()

f1 = open(p1) ; f2 = open(p2)
g.es("equal (text mode)",f1.read()==f2.read())
f1.close() ; f2.close()</t>
<t tx="EKR.20040427092657">@ignore

root line 1

@others

root after at-others

&lt;&lt; ref &gt;&gt;
</t>
<t tx="EKR.20040427092657.1">node 1 line 1

&lt;&lt; node 1 ref &gt;&gt;

node 1 last line</t>
<t tx="EKR.20040427092657.2">ref line 1

@others</t>
<t tx="EKR.20040428145741">node 1 ref line 1

@others</t>
<t tx="EKR.20040428145741.1"></t>
<t tx="EKR.20040428145741.2"></t>
<t tx="EKR.20040428145826"></t>
<t tx="EKR.20040428145826.1"></t>
<t tx="EKR.20040428150018">text of organizer node</t>
<t tx="EKR.20040430162649.1"></t>
<t tx="EKR.20040430162649.2"></t>
<t tx="EKR.20040430162649.3">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.4">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.5">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.6">@ignore

Ä á Û</t>
<t tx="EKR.20040430162649.7">@encoding iso-8859-1</t>
<t tx="EKR.20040430162649.8"></t>
<t tx="EKR.20040430162649.9"></t>
<t tx="EKR.20040430162649.10">@encoding cp1252
@others</t>
<t tx="EKR.20040430162649.11">aÖb</t>
<t tx="EKR.20040430162649.12">@ignore</t>
<t tx="EKR.20040430162649.13">@language perlpod
@path c:\prog\test</t>
<t tx="EKR.20040430162649.14">@root perlpod.txt
@ Multi-line
doc part
&lt;&lt;ref&gt;&gt;</t>
<t tx="EKR.20040430162649.15">@ doc part2
@c
code line1
code line2
@ more doc part</t>
<t tx="EKR.20040430162649.16">@comment REM_</t>
<t tx="EKR.20040430162649.17">test 6</t>
<t tx="EKR.20040430162649.20">@ atFile.directiveKind is return miscDirective on _any_ line that starts with @</t>
<t tx="EKR.20040430162649.21">@ignore

line 1
@line 2
    @line 3
line 4</t>
<t tx="EKR.20040430162649.22">@language plain
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
    
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
     a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="EKR.20040430162649.23">@ignore</t>
<t tx="EKR.20040430162649.24">enabling: *
Exception in Tkinter callback
Traceback (most recent call last):
  File "c:\python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "leoFrame.py", line 1368, in OnTangle
    self.commands.tangleCommands.tangle()
  File "leoTangle.py", line 507, in tangle
    self.tangleTree(v,report_errors)
  File "leoTangle.py", line 644, in tangleTree
    self.tanglePass1(v) # sets self.v
  File "leoTangle.py", line 589, in tanglePass1
    self.skip_body(v)
  File "leoTangle.py", line 1062, in skip_body
    self.st_enter_root_name(old_root_name,code,doc)
  File "leoTangle.py", line 2040, in st_enter_root_name
    assert(code)
AssertionError
</t>
<t tx="EKR.20040430162649.25">@root a.txt
@ 

@root a.txt 
some text 
@ </t>
<t tx="EKR.20040504083716"># EKR: I don't remember the status of this.

@language python

import leoGlobals as g
import shutil

testing = True

sourcedir=r"c:/prog/test/perfectImport"
targetdir=r"c:/prog/test/perfectImport/leo"
s1 = g.os_path_join(sourcedir,"leoAtFile.py")
t1 = g.os_path_join(targetdir,"leoAtFile.py")
files = [(s1,t1)]

@others

print ; print '-' * 20

sync(files) # push or pull, depending on date.
</t>
<t tx="EKR.20040504083716.39">def sync(files):
    
    """Do a pull or a push, depending on the date of the files."""
    
    none, push, pull = 'None', 'push', 'pull'
    mu = g.mulderUpdateAlgorithm()

    for sourcefilename, targetfilename in files:
        &lt;&lt; compute sourcetime and targettime &gt;&gt;
        &lt;&lt; compute operation &gt;&gt;
        if operation == push:
            if testing: print push, sourcefilename, targetfilename
            strippedLines = mu.removeSentinelsFromFile(sourcefilename)
            mu.write_if_changed(strippedLines,sourcefilename,targetfilename)
            mu.copy_time(sourcefilename,targetfilename)
        elif operation == pull:
            if testing: print pull, sourcefilename, targetfilename
            if sourcetime:
                mu.propagateDiffsToSentinelsFile(sourcefilename,targetfilename)
                mu.copy_time(targetfilename,sourcefilename)
            else:
                shutil.copy2(targetfilename,sourcefilename)</t>
<t tx="EKR.20040504153320">sourcetime = targettime = None

if g.os_path_exists(sourcefilename):
    sourcetime = g.os_path_getmtime(sourcefilename)

if g.os_path_exists(targetfilename):
    targettime = g.os_path_getmtime(targetfilename)</t>
<t tx="EKR.20040504153320.1">operation = None
if sourcetime:
    if targettime:
        if sourcetime &gt; targettime:
            operation = push
        elif sourcetime &lt; targettime:
            operation = pull
    else:
        operation = push
elif targettime:
    operation = pull</t>
<t tx="EKR.20040517074600.8">import leoGlobals as g
import leoTest

u = leoTest.testUtils()
nodes = 0 ; lines = 0
c = g.top()
c.clearAllVisited()
v = u.findNodeAnywhere(c,"Plugins &amp; scripts")
after = v.nodeAfterTree()
trace(v,after)
while v and v != after:
    if not v.t.isVisited():
        v.t.setVisited()
        nodes += 1
        lines += len(splitLines(v.bodyString()))
    v = v.threadNext()
    
pages = ((nodes * 10) + lines) / 50
print "nodes,lines,pages",nodes,lines,pages
g.es("nodes,lines,pages",nodes,lines,pages)</t>
<t tx="EKR.20040517074600.9"></t>
<t tx="EKR.20040517074600.10">import leoGlobals as g
config = g.app.config

font = config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        tag = "body")
        
print font

c = top() ; body = c.frame.body.bodyCtrl

print body

# body.configure(font=font)</t>
<t tx="EKR.20040517074600.11">import leoGlobals as g
import tkFont

@others

c = g.top()

# Body pane.
fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
print "body:",fn,name,size,slant,weight

if 0:

    # Log pane.
    fn = c.frame.log.getFontConfig()
    font = tkFont.Font(font=fn)
    name,size,slant,weight = getFontSettings(font)
    g.es("log:" + name + "," + `size` + "," + slant + "," + weight)
    
    # Tree pane.
    font = c.frame.tree.getFont()
    name,size,slant,weight = getFontSettings(font)
    g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="EKR.20040517074600.12">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="EKR.20040517074600.13">import leoGlobals as g

font = g.app.config.defaultFont

print font.cget("family"), font.cget("weight")</t>
<t tx="EKR.20040520104329"></t>
<t tx="EKR.20040523112430"></t>
<t tx="EKR.20040523112430.1"></t>
<t tx="EKR.20040523112430.2"></t>
<t tx="EKR.20040523112430.3"></t>
<t tx="EKR.20040523112430.4"></t>
<t tx="EKR.20040523112430.5"></t>
<t tx="EKR.20040523112430.6"></t>
<t tx="EKR.20040523112430.7"></t>
<t tx="EKR.20040523112430.8"></t>
<t tx="EKR.20040524050419">line 1
@others
&lt;&lt; defined in grandchild &gt;&gt;
last line</t>
<t tx="EKR.20040524050419.1">Organizer line</t>
<t tx="EKR.20040524050419.2">grandChild line</t>
<t tx="EKR.20040524050438"></t>
<t tx="EKR.20040525083635">@others</t>
<t tx="EKR.20040525083635.1"></t>
<t tx="EKR.20040526094831">import leoGlobals as g

def redoBletch(self):
    g.trace()
    
def undoBletch(self):
    g.trace()
    
c = g.top() ; u = c.undoer
p = c.currentPosition()

if 0:
    # bad functions
    u.registerUndoHandlers("Bletch","abc","xyz")
else:
    u.registerUndoHandlers("Bletch",undoBletch,redoBletch)
    
# "Execute" the Bletch command :-)  The Edit command should contain "Undo Bletch"
u.setUndoParams("Bletch",p)

# Selecting "Undo Bletch" will enable "Redo Bletch", etc.</t>
<t tx="EKR.20040526193608">import leoGlobals as g
import binascii
import pickle

d = { "a":True }

print '-' * 40

s = pickle.dumps(d,bin=True)
s2 = binascii.hexlify(s)
print `s`,s2

s3 = binascii.unhexlify(s2)
d2 = cPickle.loads(s3)

print `d2`
print d == d2, d is d2</t>
<t tx="EKR.20040526200017">import leoGlobals as g

c = g.top() ; p = c.currentPosition()


d = { "a":True }

if 1:
    # Warning: executing this in the a2 code base will cause any save operation to fail.
    p.v.unknownAttributes = { "myPlugin" : d }
    
print repr(p.v.unknownAttributes)</t>
<t tx="EKR.20040531110157">@ignore</t>
<t tx="EKR.20040602101648">import leoGlobals as g
import leoPlugins

def onEnd (tag,keys):
    print "onEnd",tag,keys
    
count = 0
    
def onIdle (tag,keys):
    global count ; count += 1
    if count % 10 == 0:
        print "onIdle",count,keys.get("c")

leoPlugins.registerHandler("end1", onEnd)
print "onEnd registered as end1 hook"

leoPlugins.registerHandler("idle", onIdle)
print "onIdle registered as idle hook"</t>
<t tx="EKR.20040603064545">import leoGlobals as g

c = g.top()

for p in c.all_positions_iter():
    print p.v.t.fileIndex</t>
<t tx="EKR.20040603174633">import leoGlobals as g
c = g.top()
print c.frame.bodyCtrl.focus()</t>
<t tx="EKR.20040604082113">@tabwidth -4
@language plain

    
    a   b   c
a   b   c   d
aa  b   c   d
aaa b   c   d
end</t>
<t tx="EKR.20040604170105">import leoGlobals as g
import os

c = g.top()

print os.getcwd()
name = g.os_path_join("test","removeSentTest.txt")
c.importCommands.removeSentinelsCommand(name)</t>
<t tx="EKR.20040605200750">@ignore # Suppress Check Python Code warnings.

string.join

__add__

'a'.__add__


def test(a,b): pass

v.copyTree(self,root)</t>
<t tx="EKR.20040606204316">@ignore</t>
<t tx="EKR.20040606204316.1"></t>
<t tx="EKR.20040608095146">@language python
@tabwidth -4</t>
<t tx="EKR.20040608095146.1">@ignore
@language html

&lt;!--- Get all records from the database that match this users credentials ---&gt;
&lt;cfquery name="qLoginVerify" datasource="xxxx"&gt;
SELECT user_name, user_pass, course_dir
FROM login
WHERE user_name = '#user_name#'
AND user_pass = '#user_pass#'
AND course_dir = '#course_dir#'
&lt;/cfquery&gt;

&lt;cfif qLoginVerify.RecordCount&gt;
&lt;!--- This user has logged in correctly; 
change the value of the session.allowin value ---&gt;
&lt;cfset session.allowin = session.directoryshort&gt;
&lt;/cfif&gt;

&lt;!--- now redirect to "index.cfm", which will go to login if problem ---&gt;

&lt;cflocation url="#session.location#"&gt;
</t>
<t tx="EKR.20040610092248">@killcolor
@language plain

Note: Previously, one could crash Leo by pasting a large text into a headline.  Leo now truncates that text, and furthermore Leo no longer makes all headline text into one gigantic line.  Therefore, we don't have to test Tk's ability to handle super-long lines.

The test:  Copy the following and paste it into a headline.  Leo should give 2 truncation messages:

- Truncating headline to one line.
- Truncating headline to 250 characters.

About a year ago I found the website at www.literateprogamming.com and was immediately convinced that the basic idea of Literate Programming is an important breakthrough. At the time I was working on a contract trying to decipher a true masterpiece of over-engineering, and if at any time during the construction of this masterpiece the perpetrators had been required to explain themselves in English, my client would have saved millions of dollars.

I never did try CWEB or NOWEB though, because on the literate programming site I read about a tool named “Leo” that combined outlines with Literate Programming techniques. Since I’ve always found outlining tools very useful I downloaded and tried this. I found that using this tool completely changed my programming practice and brought out all of the power inherent in the original Literate Programming idea as I understood it.</t>
<t tx="EKR.20040610192622.1">import string

string.join(a,b] # A syntax error</t>
<t tx="EKR.20040610194209.1">@tabwidth 4

# Tabnanny _only_ checks errors involving tabs.
# It does _not_ check other indentation errors.
# It does _not_ check syntax.

if 1: # Essential, so we don't create a syntax error.
    a = 5
	b = 6 #Contains tab.
    c = 3</t>
<t tx="EKR.20040611083703"># This kind of code is used in the prototypes of new commands.

from __future__ import generators

import leoGlobals as g

@others

lines = "a\nb\nc\nd"

if 1: # Both work
    readline = g.readLinesGenerator(lines).next
else:
    readline = g.readLinesClass(lines).next

print '-' * 20

if 1: # Both work
    for s in g.readLinesGenerator(lines):
        print s,
else:
    while 1:
        s = readline()
        if s: print s,
        else: break
    
print ; print '-' * 20</t>
<t tx="EKR.20040612095237">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import unittest

c = g.top()

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False)

assert result=="error", "checkPythonCode returns: %s" % result
</t>
<t tx="EKR.20040612150543"># Test
@others
# Last</t>
<t tx="EKR.20040612215136">a = 1
print "hello"
c = b
</t>
<t tx="EKR.20040613162717">import leoGlobals as g

path = r"c:\prog\leoScripts(before).txt"
path = r"c:\prog\leoScripts(after).txt"

print g.top().currentPosition()

try:
    f = open(path,"rb")
    s = f.read()
    f.close()
    
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
        
    g.es("cr %d, nl %d %s" % (cr,nl,path))

except IOError:
    print "can not open",path</t>
<t tx="EKR.20040615070332"># "LPT1:", "PRN:" and "PRN" all freeze

s = 'stuff\n'
port = 'USB002'

try:
    f = file(port,'w')
    f.write(s)
    f.flush()
    f.close()
    print "done"
except IOError:
    print "Can not open",port</t>
<t tx="EKR.20040619133116"></t>
<t tx="EKR.20040622074004">@ignore</t>
<t tx="EKR.20040622074004.1"></t>
<t tx="EKR.20040622074004.2">node b, line 1 (changed 12)</t>
<t tx="EKR.20040622074004.3"></t>
<t tx="EKR.20040622102618"></t>
<t tx="EKR.20040625110032">@ignore

@others</t>
<t tx="EKR.20040625110032.1"></t>
<t tx="EKR.20040625110032.2"># @language html

@comment &lt;!-- --&gt;</t>
<t tx="EKR.20040625110032.3"></t>
<t tx="EKR.20040626212434"></t>
<t tx="EKR.20040626212434.1">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

mincolor,maxcolor=125,225

for n in xrange(5000):
    x,y = rand(0,900),rand(0,500)
    w = rand(1,10) ; h = w * r.uniform(0.5,1.5)
    color = "#%02x%02x%02x" % (rand(0,maxcolor/2),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    kind = rand(1,3)
    sign = rand(-1,1) # rand(0,2)-1
    if kind == 1:
        canvas.create_rectangle(x,y,x+w,y+h,fill=color,width=0)
    elif kind == 2:
        canvas.create_oval(x,y,x+w,y+h,fill=color,width=0)
    else:
        canvas.create_line(x,y,x+sign*5*w,y+5*h,fill=color)
    if 0: # Redrawing slows things down a lot.
        if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626212434.2">import leoGlobals as g
import Tkinter as Tk
import random as r

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top, height = "5i", width = "9i")
canvas.pack() ; top.update()
rand = r.randint

x,y = 10,10
mincolor,maxcolor=125,225

for n in xrange(2000):
    x2,y2 = rand(0,900),rand(0,500)
    color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    width = "%fm" % r.uniform(0.1,0.6)
    canvas.create_line(x,y,x2,y2,fill=color,width=width)
    extent = rand(180,270)
    canvas.create_arc(x,y,x2,y2,outline=color,width=width,style="arc",extent=extent)
    x,y = x2,y2
    # if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626213007">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

# Paul Klee
mincolor,maxcolor=125,225
xmax,ymax = 800,400
stipples = [None,"gray75"] # "gray12","gray25","gray50",]
h=w=90
for x in xrange(10,xmax,w):
    for y in xrange(10,ymax,h):
        color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
        range = h/6
        stipple = stipples[rand(0,len(stipples)-1)]
        dx = r.uniform(0.0,range) - range/2
        dy = r.uniform(0.0,range) - range/2
        canvas.create_rectangle(x+dx,y+dy,x+dx+w,y+dy+h,fill=color,width=0,stipple=stipple)</t>
<t tx="EKR.20040627100615">@ignore # Suppress Check Python Code warnings.

import leoGlobals as g

g.app.config.redirect_execute_script_output_to_log_pane = False

# Syntax error
print '

import leoGlobals as g
print g.app.config.redirect_execute_script_output_to_log_pane</t>
<t tx="EKR.20040627103732">@ignore</t>
<t tx="EKR.20040627103801"></t>
<t tx="EKR.20040627103902" lineYOffset="4b032e" icons="5d7100287d710128550577686572657102550a6265666f726549636f6e710355047870616471044b025504747970657105550466696c6571066806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286805680668084afdffffff6806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6802550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e"></t>
<t tx="EKR.20040627121836">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

next = p.next()

t = next.v.t
v = next.v

for s in t.__dict__:
    print s,getattr(t,s)</t>
<t tx="EKR.20040627150213">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

@others

mincolor,maxcolor=125,225
xmax,ymax = 300,300
h=w=1
i = r.uniform(2.0,4.0)
j = r.uniform(-5.0,5.0)
power = r.uniform(1.1,1.2)
    #(1.5,1.7)
for n in xrange(1):
    i += 0.5
    j += 0.5
    power += 0.01
    print "i,j,power:",i,j,power
    c = complex(i,j)
    for format,m in (
        #("#%02x%02x%02x",256),
        #("#%03x%03x%03x",256*8),
        ("#%04x%04x%04x",256*256),
    ):
        for x in xrange(0,xmax,1):
            for y in xrange(0,ymax,1):
                n = complex(x,y)
                z = pow(c*n,power)
                n1 = int(z.real*m) ; n2 = int(z.imag*m)
                color = format % (n1%m,n2%m,abs(n1-n2)%m)
                # canvas.create_rectangle(w*x,h*y,w*x+w,h*y+h,fill=color,width=0)
                canvas.create_line(x,y,x+1,y+1,fill=color,width=1)
        top.update()
print "done"</t>
<t tx="ekr.20040302091705">import leoGlobals as g

class position:
    def __init__(self):
        self.v = "a"
    def move(self):
        self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040309111054">import leoGlobals as g
import leoNodes

c = g.top()
position = leoNodes.position

@others

current = pos = c.currentPosition()
child1 = current.firstChild()
child2 = child1.firstChild()

if 0:
    print '-'*10, "parents"
    for p in child2.parents_iter(): print p
if 0:
    print '-'*10, "subtree"
    for p in pos.subtree_iter(): print p
if 0:
    print '-'*10, "children"
    for p in child1.children_iter(): print p
if 0:
    print '-'*10, "siblings"
    for p in pos.siblings_iter(): print p
if 1:
    print '-'*10, "all nodes"
    for p in pos.allNodes_iter():
        print p.isCloned(),p
</t>
<t tx="ekr.20040309111102"></t>
<t tx="ekr.20040309111102.1"></t>
<t tx="ekr.20040309111102.2"></t>
<t tx="ekr.20040309111102.3"></t>
<t tx="ekr.20040309111102.4"></t>
<t tx="ekr.20040309111102.5"></t>
<t tx="ekr.20040309111102.6"></t>
<t tx="ekr.20040309111102.7"></t>
<t tx="ekr.20040309111102.8"></t>
<t tx="ekr.20040309111102.9"></t>
<t tx="ekr.20040309111102.10"></t>
<t tx="ekr.20040309111232"></t>
<t tx="ekr.20040311090054">import leoGlobals as g
import leoNodes

c = g.top() ; root = c.rootPosition()

for p in root.allNodes_iter():
    print p.v.t.fileIndex</t>
<t tx="ekr.20040312021734"></t>
<t tx="ekr.20040312021734.1">import leoGlobals as g

c = g.top()

count = 0
for p in c.rootPosition().allNodes_iter():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20040312101720"></t>
<t tx="ekr.20040317101155" lineYOffset="4b032e" icons="5d7100287d7101285504747970657102550466696c65710355047870616471044b02550577686572657105550a6265666f726549636f6e71066803582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286802680368084afdffffff6803582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6805550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e">import leoGlobals as g

c = g.top()

p = c.currentPosition()
p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

&lt;&lt; define event callbacks &gt;&gt;

path = r"c:\prog\leoCVS\leo\Icons"
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
    "type" : "file", "file" : icon1,
    "where" : "beforeIcon",
    "yoffset" : -3,
    # "yoffset" : 5, "ypad" : -5,
    # "height" : 40, # automatically adjust headline y position.
    "xpad": 2
}

# Classes and functions can only be pickled if they are at the top level of a module.
    #"onClick" : onClick,
    #"onRightClick" : onRightClick,
    #"onDoubleClick" : onDoubleClick }

d2 = {
    "type" : "file", "file" : icon2,
    "where" : "beforeHeadline",
    "yoffset" : -3,
    "xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()
</t>
<t tx="ekr.20040317173327">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0
            
c.redraw()</t>
<t tx="ekr.20040317185041">def onClick(p=p):
    
    g.trace(p)

def onRightClick(p=p):
    
    g.trace(p)

def onDoubleClick(p=p):
    
    g.trace(p)</t>
<t tx="ekr.20040318091620">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if hasattr(p.v.t,"unknownAttributes"):
        print "deleting unknownAttributes:",p
        delattr(p.v.t,"unknownAttributes")
            
c.redraw()</t>
<t tx="ekr.20040319111213">from leoPlugins import *
from leoGlobals import *
from leoNodes import *
import Tkinter
import re
import sys

@others

fhp = None
fhp_entry = None
    
if 1:
    addMenu("none",None)
else:
    hooks = choose(sys.platform == 'win32',
        ('open2',"new"),
        ('start2','open2',"new"))
        
    print "hi"
        
    registerHandler(hooks,addMenu)

    __version__ = ".1"
    plugin_signon(__name__)
</t>
<t tx="ekr.20040319111213.1">@nocolor

@ This is what it does:

1. Under Outline it puts an Option called 'FilterHoist'
2. Selecting the option pops up an ugly little window.  On it is a section where
you can type in text.  You can close the window with the close button.  You
can activate the functionality with the Filter Button.
3. Filtering will walk the Leo tree, looking for a text match from the Text
field with the Nodes bodyString.
4. After finding some nodes it creates a new node at the root.  Then it clones
the matching nodes under that new node.  A Hoist operation is performed on the
new node.  This gives a view of all matching nodes.

I put this together because I wanted a find that was based in terms of Leo's
nodes.  Find as it is bounces you around the Tree(it bothers me).  This brings
the nodes to you and presents them.  As it is I may work further on this if
people like the idea.  It's possible I might migrate it to the NodeRoundup plugin
to.

You need 2.3 python; it uses generators in it's find method.

That was one motivation for writing this thing, using a generator vs. Recursive
approach to tree walking.</t>
<t tx="ekr.20040319111213.2">def OLDfilter(c,e):

    v = c.rootVnode()
    
    nodes = []
    while v:
        nodes.append(v)
        v = v.next()
    
    regex = re.compile(e.get())
    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        ticker = c.rootVnode().insertAfter(t)
        for z in nodes:
            for x in search(z,regex):
                clone = x.clone( x )
                clone.moveToNthChildOf(ticker,0)
        c.setCurrentVnode(ticker)
        ticker.moveToRoot(c.rootVnode())
    c.endUpdate()
    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040319111213.3">def OLDsearch(vn,regex):

    sn = vn 
    while vn != None:
        if regex.search( vn.t.bodyString ) : yield vn
        nc = vn.numberOfChildren()
        if nc == 0:
            i = vn.childIndex()
            p = vn.parent()
            if p == None: 
                vn = None
                continue
            if i == 0:
                while 1:
                    if p == sn :
                        vn = None
                        break
                    vn = p.back() 
                    if vn == None:
                        p = p.parent()
                        continue
                    break
                continue                                                        
            vn = p.nthChild( i - 1)
            continue
        vn = vn.nthChild( nc - 1 )
</t>
<t tx="ekr.20040319111213.4">def filterHoist(c):

    global fhp
    global e
    
    if fhp is None:

        fhp = Tkinter.Toplevel()
        fhp.title('FilterHoist')

        fhp_entry = e = Tkinter.Entry(fhp)
        e.pack(side="top",fill="both")

        def closeCallback(fhp=fhp):
            fhp.withdraw()
            
        def filterCallback(c=c,entry=e):
            filter(c,entry)

        b1 = Tkinter.Button(fhp,text='Close',command=closeCallback)
        b2 = Tkinter.Button(fhp,text='Filter',command=filterCallback)
        b1.pack(side="left")
        b2.pack(side="right")

    fhp.geometry('200x200+250+250') 
    fhp.deiconify()
    fhp_entry.focus_set()
</t>
<t tx="ekr.20040319111213.5">def addMenu(tag,keywords):
    
    c = top()
    
    trace()
    
    def callback(c=c):
        filterHoist(c)
    
    table = ("FilterHoist",None,callback),

    c.frame.menu.createMenuItemsFromTable("Outline",table)</t>
<t tx="ekr.20040319142202"></t>
<t tx="ekr.20040319142708">def filter(c,e):
    
    pat = re.compile(e.get())

    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        newRoot = c.rootVnode().insertAfter(t)
        p = c.rootVnode()
        while p:
            if pat.search(p.bodyString()):
                clone = p.clone(p)
                clone.moveToLastChildOf(newRoot)
            p = p.threadNext()
        newRoot.moveToRoot(c.rootVnode())
        c.setCurrentVnode(newRoot)
    c.endUpdate()

    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040322120331">import leoGlobals as g
c = g.top()

print '-'*20
for p in c.allNodes_iter():
    if hasattr(p.v.t,"tnodeList"):
        print p,p.v.t.tnodeList</t>
<t tx="ekr.20040323075614">import leoGlobals as g

class test_iter_class:
    def __init__ (self):
        self.vals = ("a","b","c")
        self.n = 0
    def __iter__(self):
        return self
    def next(self):
        if self.n &lt; len(self.vals):
            val = self.vals[self.n]
            self.n += 1
            return val
        else:
            raise StopIteration
            
def test_iter(): return test_iter_class()
        
vals = [val for val in test_iter()]

print vals
</t>
<t tx="ekr.20040323080317">import leoGlobals as g
c = g.top()

print '-'*20

# These are equivalent.
positions1 = [p for p in c.allNodes_iter(copy=True)]
positions2 = [p.copy() for p in c.allNodes_iter()]

assert(len(positions1) == len(positions2))
for i in xrange(len(positions1)):
    assert(positions1[i] == positions2[i])

if 0:
    for p in positions1:
        print p
print "done"</t>
<t tx="ekr.20040323082119">import leoGlobals as g
c = g.top()

print '-'*20

positions = [p.copy() for p in c.allNodes_iter()]

tnodes = {} ; vnodes = []
for p in c.allNodes_iter():
    t = p.v.t
    if tnodes.get(t) is None:
        tnodes[t]=t
        vnodes.append(p.v)
        
print len(positions),len(vnodes)

for v in vnodes:
    print v</t>
<t tx="ekr.20040323085406">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isAnyAtFileNode():
        print p
        
print "done"</t>
<t tx="ekr.20040323085933">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isDirty():
        vnodes = p.findAllPotentiallyDirtyNodes()
        print '-'*5, p
        for v in vnodes:
            print v

print "done"</t>
<t tx="ekr.20040325082811">import leoGlobals as g

g.es("v",g.top().currentPosition())
g.es(1,2)</t>
<t tx="ekr.20040325130503">stack1 = ["a","b","c"]
stack2 = ["a","b","c"]
stack3 = ["a","b","d"]
stack4 = ["a","b"]
print stack1 == stack2
print stack1 == stack3
print stack1 == stack4</t>
<t tx="ekr.20040325140133">import leoGlobals as g
c = g.top() ; p = c.currentPosition()

print p.v.headString()
print p.childIndex()
print p.v.headString()</t>
<t tx="ekr.20040325155043">import timeit

s1 = '''\
class test(object):
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s2 = '''\
class test:
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s3 = '''\
import leoNodes
p1 = leoNodes.position(None,[])
p2 = leoNodes.position(None,[])'''

for s in (s1,s2,s3):
    t1 = timeit.Timer(stmt='p1==p2',setup=s).timeit()
    t2 = timeit.Timer(stmt='p1.equal(p2)',setup=s).timeit()
    print "%2.2f,%2.2f,%0.2f" % (t1,t2,t1/t2)
</t>
<t tx="ekr.20040327114250">@ignore

# A file to be executed in batch mode as part of unit testing.

@language python
@tabwidth -4

path = r"c:\prog\test\unittest\createdFile.txt"
f = None
try:
    f = open(path,"w")
    f.write("This is a test")
finally:
    if f: f.close()</t>
<t tx="ekr.20040330095252">import leoGlobals as g
c = g.top()
t = c.frame.log.logCtrl
print t
t.delete("1.0","end")</t>
<t tx="ekr.20040330103006">@ignore
@language c

oblk[1] = b64[((iblk[0] &amp; 0x03) &lt;&lt; 4) |
((iblk[1] &amp; 0xF0) &gt;&gt; 4)];
oblk[2] = b64[((iblk[1] &amp; 0x0F) &lt;&lt; 2) |
((iblk[2] &amp; 0xC0) &gt;&gt; 6)];
</t>
<t tx="ekr.20040409140301"></t>
<t tx="ekr.20040409140301.1"></t>
<t tx="ekr.20040409140301.2"></t>
<t tx="ekr.20040409140301.3"></t>
<t tx="ekr.20040409140343"></t>
<t tx="ekr.20040409140343.1"></t>
<t tx="ekr.20040409142028"></t>
<t tx="ekr.20040409142028.1"></t>
<t tx="ekr.20040409142108"></t>
<t tx="ekr.20040409142108.1"></t>
<t tx="ekr.20040414082806"></t>
<t tx="ekr.20040419105536">@ignore
@language perl

@others</t>
<t tx="ekr.20040419105536.1">line 1</t>
<t tx="ekr.20040419105536.2">line 2</t>
<t tx="ekr.20040701065412">@others</t>
<t tx="ekr.20040701065412.1">marked node</t>
<t tx="ekr.20040701065412.2"></t>
<t tx="ekr.20040701065412.3"></t>
<t tx="ekr.20040701065412.4"></t>
<t tx="ekr.20040701065412.5"></t>
<t tx="ekr.20040701065424"></t>
<t tx="ekr.20040701065424.1"></t>
<t tx="ekr.20040701081330">@ignore</t>
<t tx="ekr.20040704104554">@ignore</t>
<t tx="ekr.20040704104554.1">@language html
@language python
</t>
<t tx="ekr.20040704104554.2">@language python
@language html</t>
<t tx="ekr.20040705191805">@ignore

import leoGlobals as g
import leoNodes

c = g.top()
p = c.currentPosition()

print '-' * 20
format = "%18s"
for child in p.children_iter():
    print ; print child.headString()
    print format % "isAnyAtFileNode",   child.isAnyAtFileNode()
    print format % "anyAtFileNodeName", child.anyAtFileNodeName()
    print format % "isAtFileNode",      child.isAtFileNode()
    print format % "isAtNoSentFileNode",child.isAtNoSentFileNode()
    print format % "isAtNorefFileNode", child.isAtNorefFileNode()
    print format % "isAtAsisFileNode",  child.isAtAsisFileNode()
    print format % "isAtThinFileNode",  child.isAtThinFileNode()</t>
<t tx="ekr.20040705191805.1"></t>
<t tx="ekr.20040705191805.2"></t>
<t tx="ekr.20040705192522"></t>
<t tx="ekr.20040705192522.1"></t>
<t tx="ekr.20040705192522.2"></t>
<t tx="ekr.20040705192522.3"></t>
<t tx="ekr.20040705192522.4"></t>
<t tx="ekr.20040705192522.5"></t>
<t tx="ekr.20040705192522.6"></t>
<t tx="ekr.20040705192610"></t>
<t tx="ekr.20040705192610.1"></t>
<t tx="ekr.20040705212227"></t>
<t tx="ekr.20040706071823"># This works, and doesn't seem convenient for Leo's importers.

import leoGlobals as g

try:
    import parser
    import pprint
    path = r"c:\prog\test\importIndentTest.py"
    f = open(path)
    s = f.read()
    f.close()
    ast = parser.suite(s)
    tup = ast.totuple()
    print `ast`
    pprint.pprint(tup)
except:
    import traceback
    traceback.print_exc()</t>
<t tx="ekr.20040707081532.1"># You can run all tests by selecting the Unit Test headline.

import leoTest
reload(leoTest)

leoTest.doTests(all=False)</t>
<t tx="ekr.20040707104245"></t>
<t tx="ekr.20040707110818">@ignore # Suppress @file reads/writes

</t>
<t tx="ekr.20040707141957.12">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.13">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.14">#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:@@thin
Line 1

#@@last
#@nonl
#@-node:ekr.20040707141957.13:@@thin
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040708135624">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()


print "children", '-' * 20
children = u.findChildrenOf(p)
for child in children: print child.headString()

print "subtree", '-' * 20
descendents = u.findSubnodesOf(p)
for descendent in descendents: print descendent.headString()</t>
<t tx="ekr.20040708205841">@language python
@tabwidth -4</t>
<t tx="ekr.20040708210442"></t>
<t tx="ekr.20040708210636"></t>
<t tx="ekr.20040710125250">@language plain

The first idea was to use Python's imp module to simulate an import from a file.  This does not work well because imp expects a file, not a StringIO object.

The second idea was to use Python's parser module.  But this returns an instance type, not a module.

A third idea would be to subclass the file type to fool the imp module.

A fourth idea would be to use the ihooks module.  Apparently this module was designed to do something like what I am trying to do!  However, there doesn't seem to be docs for it, so I have imported the code...

@color</t>
<t tx="ekr.20040710125250.2">import leoGlobals as g
import imp
import StringIO

@
load_module( name, file, filename, description) 

Load a module that was previously found by find_module() (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it is equivalent to a reload()! The name argument indicates the full module name (including the package name, if this is a submodule of a package). The file argument is an open file, and filename is the corresponding file name; these can be None and '', respectively, when the module is not being loaded from a file. The description argument is a tuple, as would be returned by get_suffixes(), describing what kind of module must be loaded. 
If the load is successful, the return value is the module object; otherwise, an exception (usually ImportError) is raised. 

Important: the caller is responsible for closing the file argument, if it was not None, even when an exception is raised. This is best done using a try ... finally statement.
@c

s = """

def foobar(): pass

"""

@ get_suffixes( ) 

Return a list of triples, each describing a particular type of module. Each triple has the form (suffix, mode, type), where suffix is a string to be appended to the module name to form the filename to search for, mode is the mode string to pass to the built-in open() function to open the file (this can be 'r' for text files or 'rb' for binary files), and type is the file type, which has one of the values PY_SOURCE, PY_COMPILED, or C_EXTENSION, described below.
@c

print '-' * 20
description = (".py","r",imp.PY_SOURCE)
theFile = StringIO.StringIO(s) # Create a file-like object
print repr(theFile)
try:
    imp.load_module("myModule",theFile,"myFileName",description)
except:
    g.es_exception()



</t>
<t tx="ekr.20040710141351">import leoGlobals as g
import leoTest
import types

specialDictNames = ('__builtins__','__doc__','__name__','__file__','__module__')

def printDoc(x,s):
    if hasattr(x,"__doc__") and x.__doc__:
        print "%4d %s" % (len(x.__doc__),s)
    else:
        print "%4s %s" % (' ',s)

print '-' * 60
print "%4d %s" % (len(leoTest.__doc__),"leoTest")

if 1:
    for s in leoTest.__dict__:
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) != types.ModuleType:
                printDoc(x,s)
                if type(x) == types.ClassType:
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print ' '*4,
                            printDoc(x2,s2)
else:
    &lt;&lt; print names sorted by type &gt;&gt;</t>
<t tx="ekr.20040710145459">for theType,typeName in (
    (types.ModuleType,"modules"),
    (types.ClassType,"classes"),
    (types.FunctionType,"functions"),
):

    print ; print "%s..." % typeName
    for s in leoTest.__dict__:
        
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) == theType:
                printDoc(x,s)
                if theType == types.ClassType:
                    print "\tmethods..."
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print "\t",
                            printDoc(x2,s2)</t>
<t tx="ekr.20040711044029.1">import leoGlobals as g
import leoTest
import glob
reload(leoTest)

c = g.top()

print '-' * 40

if 0:
    print "modules in test.leo..."
    paths = leoTest.findAllAtFileNodes(c)
    modules = leoTest.importAllModulesInPathList(paths)
    for module in modules:
        print module
    
if 1:
    print "modules in leo/src..."
    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    for module in modules:
        print module
        
if 0:
    directory = g.os_path_join(g.app.loadDir,"..","src")
    glob_path = g.os_path_join(directory,"leo*.py")
    files = glob.glob(glob_path)
    modules = leoTest.importAllModulesInPathList(files)
    for module in modules:
        print module</t>
<t tx="ekr.20040711085843">import leoGlobals as g
import compiler

c = g.top()
p = c.currentPosition()

for child in p.children_iter():
    h = child.headString()
    body = child.bodyString()
    
    try:
        val = compiler.parse(body)
        print type(val)
        print val
    except SyntaxError:
        g.es("Syntax error: %s" % h,color="blue")</t>
<t tx="ekr.20040711092603">import doctest
print doctest</t>
<t tx="ekr.20040711093916">import leoGlobals as g

if 0:

    class myFile(file):
        pass
        
    print myFile
    print issubclass(myFile,file)
    print isinstance(myFile,file)
    print super(myFile)
    print __import__
    
if 0:
    
    old_import = __import__
        
    def myImport(*args,**keys):
        print "myImport"
        global old_import
        old_import(*args,**keys)
        
    __import__ = myImport
    
mod = __import__("leoApp")
print mod</t>
<t tx="ekr.20040711140206">@ By far the simplest way is just to write the string to a temp file, then import the temp files.

All other approaches quickly get deeply involved with Leo's internals...</t>
<t tx="ekr.20040712101754"></t>
<t tx="ekr.20040712101754.2">@language python
@tabwidth -4</t>
<t tx="ekr.20040712101754.3">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040712101754.4">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","src","LeoPy.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.5">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","plugins","leoPlugins.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.6">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040712101754.7">@language python
@tabwidth -4</t>
<t tx="ekr.20040712101754.8"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("importTests",doImport=True)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.9"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g

import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("exportTests",doImport=False)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.10">@language plain</t>
<t tx="ekr.20040712101754.11"></t>
<t tx="ekr.20040712101754.12"></t>
<t tx="ekr.20040712101754.13">openFileDialog
c:\\prog\\test\\perfectImport\\formatter.py</t>
<t tx="ekr.20040712101754.14"></t>
<t tx="ekr.20040712101754.15">openFileDialog
c:\\prog\\test\\perfectImport\\formatter.py</t>
<t tx="ekr.20040712101754.16"></t>
<t tx="ekr.20040712101754.17">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040712101754.18"></t>
<t tx="ekr.20040712101754.19">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040712101754.20"></t>
<t tx="ekr.20040712101754.21">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040712101754.22"></t>
<t tx="ekr.20040712101754.23">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040712101754.24">@language plain</t>
<t tx="ekr.20040712101754.25"></t>
<t tx="ekr.20040712101754.26"></t>
<t tx="ekr.20040712101754.27">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040712101754.28"></t>
<t tx="ekr.20040712101754.29">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040712101754.30"></t>
<t tx="ekr.20040712101754.31">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040712101754.32"></t>
<t tx="ekr.20040712101754.33">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040712101754.34"></t>
<t tx="ekr.20040712101754.35">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040712101754.36"></t>
<t tx="ekr.20040712101754.37"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeEditBodySuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.38">@language plain

The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.</t>
<t tx="ekr.20040712101754.39"></t>
<t tx="ekr.20040712101754.40"></t>
<t tx="ekr.20040712101754.41">before
&lt;&lt; section &gt;&gt;
sec line 1
    sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040712101754.42">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040712101754.43">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20040712101754.44">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040712101754.45"></t>
<t tx="ekr.20040712101754.46">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040712101754.47">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040712101754.48">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040712101754.49"></t>
<t tx="ekr.20040712101754.50">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040712101754.51">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040712101754.52">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040712101754.53"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeReformatParagraphSuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.54">@language plain

Changed made by EKR on 7/8/04.

- Created @suite node to call makeReformatParagraphSuite

- Used makeSuite(reformatParagraphTestCase,'test') in makeReformatParagraphSuite instead of list of tests.

- modified setUp to handle these new conventions.
    - Search for reformatParagraphsTests anywhere in the tree
    - Created tempNode inside reformatParagraphsTests tree.</t>
<t tx="ekr.20040712101754.55">@language plain

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth and language formatting directives
</t>
<t tx="ekr.20040712101754.56"></t>
<t tx="ekr.20040712101754.57">@language plain
@pagewidth 40
@tabwidth 8

Wrap a long line, no trailing newline.</t>
<t tx="ekr.20040712101754.58">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040712101754.59">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040712101754.60">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040712101754.61">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040712101754.62">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040712101754.63">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040712101754.64">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040712101754.65">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040712101754.66">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040712101754.67">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040712101754.68">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040712101754.69">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040712101754.70">This line is under 40 chars.</t>
<t tx="ekr.20040712101754.71">This line is under 40 chars.</t>
<t tx="ekr.20040712101754.72">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040712101754.73">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040712101754.74">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040712101754.75">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040712101754.76">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040712101754.77">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040712101754.78">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040712101754.79">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040712101754.80">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040712101754.81">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040712101754.82">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040712101754.83">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040712101754.84">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040712101754.85">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20040712101754.86">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040712101754.87">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Mutliple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040712101754.88">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040712101754.89">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040712101754.90">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040712101754.91">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040712101754.92">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040712101754.93">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040712101754.94">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040712101754.95">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040712101754.96">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040712101754.97">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040712101754.98">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040712101754.99">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
    print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

if 0: # all nodes
    for v in c.all_vnodes_iter(): print v
    for t in c.all_tnodes_iter(): print t
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print v
    for t in c.all_unique_tnodes_iter(): print t</t>
<t tx="ekr.20040712101754.100">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"</t>
<t tx="ekr.20040712101754.101">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20040712101754.102">@language plain</t>
<t tx="ekr.20040712101754.103">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.104">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040712101754.105">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@nonl
#@-node:@@file
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040712101754.106">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.107">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20040712101754.108">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20040712101754.109">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040712101754.110">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.111">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20040712101754.115"></t>
<t tx="ekr.20040712101754.116">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.117">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
ths continues */

More plain text.</t>
<t tx="ekr.20040712101754.118">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.119">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040712101754.120">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.121">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040712101754.122">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.123">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040712101754.124">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.125">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20040712101754.126">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.127">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040712101754.128">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20040712101754.129">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.130">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040712101754.131">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.132">@language html

b = "cd"
d
</t>
<t tx="ekr.20040712101754.133">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.134">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040712101754.135">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.136">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040712101754.137">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.138">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040712101754.139">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.140">@ignore
@ doc
@c
@language c
    @others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040712101754.141">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.142">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20040712101754.143">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.144">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20040712101754.145">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="ekr.20040712101754.146">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="ekr.20040712101754.147">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="ekr.20040712101754.148">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="ekr.20040712101754.149">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="ekr.20040712101754.150">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="ekr.20040712101754.151">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="ekr.20040712101754.152">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20040712101754.153">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="ekr.20040712101754.154">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.155">@language python

"""python
string""" ; following = a

'this\
is'''</t>
<t tx="ekr.20040712101754.156">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.157">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
    
def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20040712101754.158">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.159">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20040712101754.160">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.161">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040712101754.162">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.163"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20040712101754.164">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.165">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="ekr.20040712101754.166">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="ekr.20040712101754.167">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="ekr.20040712101754.168">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.169"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text"""

if 1 and 2:
    pass

import leoGlobals as g ; print g.app().loadDir</t>
<t tx="ekr.20040712101754.170">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.171"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""


if 1 and 2:
    pass

import leoGlobals as g ; print g.app().loadDir
</t>
<t tx="ekr.20040712101754.172">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040712101754.173"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""

if 1 and 2:
    pass</t>
<t tx="ekr.20040712101754.174"></t>
<t tx="ekr.20040712101754.175">import leoGlobals as g
c = g.top()
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
    assert(p.t == p.v.t)</t>
<t tx="ekr.20040712101754.176">import leoGlobals as g
c = g.top()

c.frame.body.colorizer.python_keywords.append("as")</t>
<t tx="ekr.20040712101754.177">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

p = p.firstChild()
assert(p.headString()=="File Conversion")
p.convertTreeToString()</t>
<t tx="ekr.20040712101754.178">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040712101754.179">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040712101754.180">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.bodyString() ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040712101754.181"># The actual test is in a child node.</t>
<t tx="ekr.20040712101754.182"></t>
<t tx="ekr.20040712101754.183">import leoGlobals as g
c = g.top()

try:
    for p in c.allNodes_iter():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            if p.v._parent: parents1 = p.v._parent.t.vnodeList
            else:           parents1 = []
            parents2 = p.v.directParents()
        
        assert len(parents1) == len(parents2), "length mismatch: %s, %s" % (p,p.v._parent)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print "parents1"
    for parent in parents1: print parent
    print "parents2"
    for parent in parents2: print parent
    raise</t>
<t tx="ekr.20040712101754.184">import leoGlobals as g
c = g.top()
try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert len(parents) == len(vparents), "length mismatch: %s,%s" % (p,child)
                for parent in parents:
                    assert parent in vparents, "not in vparents: %s,%s" % (p,child)
                for parent in vparents:
                    assert parent in parents, "not in parents: %s,%s" % (p,child)
except AssertionError:
    print "parents..."
    for parent in parents: print parent
    print "vparents..."
    for parent in vparents: print parent
    raise # for unittest.</t>
<t tx="ekr.20040712101754.185">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040712101754.186">import os

path = r"c:\prog\test\unittest\createdFile.txt"

s = r"c:\python23\python c:\prog\LeoCVS\leo\src\leo.py -script c:\prog\test\unittest\batchTest.py"

if os.path.exists(path):
    print ; print "@test batch mode: deleting",path
    os.remove(path)

os.system(s)
assert(os.path.exists(path))
</t>
<t tx="ekr.20040712101754.187"></t>
<t tx="ekr.20040712101754.188">import leoNodes
import leoGlobals as g

c = g.top()
current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print v
    for v in vList2: print v

if 0:
    print len(allList),len(vList1),len(vList2)

&lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="ekr.20040712101754.189"></t>
<t tx="ekr.20040712101754.190"></t>
<t tx="ekr.20040712101754.191"></t>
<t tx="ekr.20040712101754.192"></t>
<t tx="ekr.20040712101754.193"></t>
<t tx="ekr.20040712101754.194"></t>
<t tx="ekr.20040712101754.195"></t>
<t tx="ekr.20040712101754.196">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    # print "consistency tests pass"

except AssertionError:
    print tag
    print "list1"
    for v in list1: print v
    print "list2"
    for v in list2: print v
    raise</t>
<t tx="ekr.20040712101754.197">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="ekr.20040712101754.198">if 0:
    for v in current.vnodes_iter(): print v
    for v in current.unique_vnodes_iter(): print v

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print v
    for t in root.tnodes_iter(): print t

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print v
    for t in child.tnodes_iter(): print t</t>
<t tx="ekr.20040712101754.199">import leoGlobals as g
c = g.top()
p = c.currentPosition()
    
assert(p == p.copy())
assert(p != p.threadNext())</t>
<t tx="ekr.20040712101754.200">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040712101754.201">import leoGlobals as g
c = g.top()

for copy in (True,False):
    p2 = c.rootPosition()
    for p in c.allNodes_iter(copy=copy):
        assert p==p2, "%s != %s" % (p,p2)
        p2.moveToThreadNext()
        
    assert not p2, repr(p2)
</t>
<t tx="ekr.20040712101754.202">import leoGlobals as g
c = g.top()

for copy in (True,False):
    for p in c.allNodes_iter(copy=copy):
        
        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToNext()

    assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.203">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)
        
    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())</t>
<t tx="ekr.20040712101754.204">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040712101754.205">import leoGlobals as g
c = g.top()

for copy in (True,False):

    for p in c.allNodes_iter():
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToParent()

        assert not p2, repr(p2)</t>
<t tx="ekr.20040712101754.206"># Test consistency of p.parent, p.next, p.back and p.firstChild.

import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))
        
    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())
        
    if p.hasBack():
        assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040712101754.207">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040712101754.208">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned():
        parents = p.v.t.vnodeList
        for child in p.children_iter():
            vparents = child.v.directParents()
            assert(len(parents) == len(vparents))
            for parent in parents:
                assert(parent in vparents)
            for parent in vparents:
                assert(parent in parents)</t>
<t tx="ekr.20040712101754.209">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))
            
    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))</t>
<t tx="ekr.20040712101754.210">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))
            
    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))</t>
<t tx="ekr.20040712101754.211">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))
            
    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040712101754.212">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    vnodeList = p.v.t.vnodeList

    for v in vnodeList:

        assert(v.t == p.v.t)
        if p.v.isCloned():
            assert(v.isCloned())
            assert(len(vnodeList) &gt; 1)
        else:
            assert(not v.isCloned())
            assert(len(vnodeList) == 1)</t>
<t tx="ekr.20040712101754.213"></t>
<t tx="ekr.20040712101754.214"></t>
<t tx="ekr.20040712101754.215">import leoGlobals as g
import leoNodes

c = g.top();  p = c.currentPosition()
root1 = p.firstChild()

root2 = root1.copyTreeAfter()
root2.initHeadString("root2")
c.checkOutline()
c.redraw()
root2.doDelete(root1)
c.checkOutline()
c.redraw()</t>
<t tx="ekr.20040712101754.216"></t>
<t tx="ekr.20040712101754.217"></t>
<t tx="ekr.20040712101754.218"></t>
<t tx="ekr.20040712101754.219"></t>
<t tx="ekr.20040712101754.220"></t>
<t tx="ekr.20040712101754.221">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.headString()=="outline1")
assert(outline2.headString()=="outline2")

u.replaceOutline(c,outline1,outline2)
c.redraw()
c.checkOutline()</t>
<t tx="ekr.20040712101754.222"></t>
<t tx="ekr.20040712101754.223"></t>
<t tx="ekr.20040712101754.224"></t>
<t tx="ekr.20040712101754.225"></t>
<t tx="ekr.20040712101754.226">def replaceOutline (self,c,outline1,outline2):
    
    """Replace outline1 by a copy of outline 2,
    
    retaining the headline of outline1."""

    u = self
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete(copy)</t>
<t tx="ekr.20040712101754.227"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = makeOutlineSuite("outlineTests")

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.228">def makeOutlineSuite(parentHeadline):
    
    """Create an outline test for every descendant of testParentHeadline.."""
    
    c = g.top() ; v = c.currentVnode()
    u = leoTest.testUtils()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    parent = u.findNodeAnywhere(c,parentHeadline)
    
    for child in parent.children_iter(copy=True):
        before = u.findNodeInTree(child,"before")
        after  = u.findNodeInTree(child,"after")
        ref    = u.findNodeInTree(child,"ref")
        if before and after and ref:
            test = outlineTestCase(c,child,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040712101754.229">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20040712101754.230">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.u = leoTest.testUtils()

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref</t>
<t tx="ekr.20040712101754.231">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert move, "no move node"
    
    c.selectVnode(move)
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()

    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))</t>
<t tx="ekr.20040712101754.232">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20040712101754.233">def setUp(self,*args,**keys):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert self.u.compareOutlines(self.before,self.ref,compareHeadlines=False),\
        "compare failed"
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20040712101754.234">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()</t>
<t tx="ekr.20040712101754.235">def shortDescription (self):
    
    return self.parent.headString()</t>
<t tx="ekr.20040712101754.236"></t>
<t tx="ekr.20040712101754.237"></t>
<t tx="ekr.20040712101754.238"></t>
<t tx="ekr.20040712101754.239"></t>
<t tx="ekr.20040712101754.240"></t>
<t tx="ekr.20040712101754.241"></t>
<t tx="ekr.20040712101754.242"></t>
<t tx="ekr.20040712101754.243"></t>
<t tx="ekr.20040712101754.244"></t>
<t tx="ekr.20040712101754.245"></t>
<t tx="ekr.20040712101754.246"></t>
<t tx="ekr.20040712101754.247"></t>
<t tx="ekr.20040712101754.248"></t>
<t tx="ekr.20040712101754.249"></t>
<t tx="ekr.20040712101754.250"></t>
<t tx="ekr.20040712101754.251"></t>
<t tx="ekr.20040712101754.252"></t>
<t tx="ekr.20040712101754.253"></t>
<t tx="ekr.20040712101754.254"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = unittest.makeSuite(findCommandTestCase,'test')

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.255">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20040712101754.256">def setUp(self,*args,**keys):
    
    self.u = u = leoTest.testUtils()
    self.c = c = g.top()
    self.find_p = u.findNodeAnywhere(c,"findTests")
    
    assert(self.find_p)
</t>
<t tx="ekr.20040712101754.257">def testFindCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.258">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.259">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20040712101754.260">aaa</t>
<t tx="ekr.20040712101754.261"></t>
<t tx="ekr.20040712101754.272">import leoGlobals as g

c = g.top()
errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.
assert errors == 0, "Check Outline reported %d errors" % errors</t>
<t tx="ekr.20040712101754.273">import leoGlobals as g
import doctest
import unittest
import leoTest
reload(leoTest)
c = g.top()

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
paths = leoTest.findAllAtFileNodes(c)
modules = leoTest.importAllModulesInPathList(paths)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101754.274">import leoGlobals as g
import unittest
import leoTest
reload(leoTest)
c = g.top()

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
path = g.os_path_join(g.app.loadDir,"..","src")
modules = leoTest.importAllModulesInPath(path)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040712101813">import leoGlobals as g

c = g.top()

result = c.checkAllPythonCode(unittest=True,ignoreAtIgnore=True)

assert result=="ok", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20040713070526">@language python 

import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

dump = False 
all = False 

if all:
    c.prettyPrintAllPythonCode(dump=dump)
else:
    # Warning: at present the before and after text is unprotected:
    # Running Pretty Print on these nodes will negate the value of the test.
    temp = u.findNodeInTree(p,"tempNode")
    before = u.findNodeInTree(p,"before")
    after = u.findNodeInTree(p,"after")
    temp.scriptSetBodyString(before.bodyString())
    c.prettyPrintPythonCode(p=temp,dump=dump)
    assert temp.bodyString() == after.bodyString()</t>
<t tx="ekr.20040713071919">@ This is    a test of stuff.in doc parts.

         I wonder           what will happen.
@c

def        spam (self         )  :   

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "Ä á Û"
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others</t>
<t tx="ekr.20040713123617">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c 

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "Ä á Û"
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others </t>
<t tx="ekr.20040713123617.1">@language python
@tabwidth -4

import leoGlobals as g
import elisp2py
import leoTest
reload(leoTest)
reload(elisp2py)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()
before = u.findNodeInTree(p,"-input-")

print ; print '*' * 80

for p in before.subtree_iter():
    e = elisp2py.elisp2pyClass(c,p)
    e.convert()
    if 0:
        e.dump(e.tokens,heading="Tokens",verbose=2)
    if 1:
        e.dump(e.parseTree,heading="Parse Tree",verbose=2)
    if 0:
        e.dumpCodeList(e.codeList,heading="Code List")</t>
<t tx="ekr.20040713123828.1">@ This is a test of stuff.in doc parts.

         I wonder what will happen.
@c 

def spam (self):

    """ This is a ' triple'   quoted string:
        It should remain untouched."""
    
    if a==3:
        print "Ä á Û"
        
    ''' Another ' triple'   quoted string:
        It should remain untouched.'''
        
    "yet another\
    multi-line string"
        
class eggs:
    
    """ A typical doc string """
    
    @others </t>
<t tx="ekr.20040713130853"></t>
<t tx="ekr.20040713130853.1">@ elisp2py converts elisp text into python text.  The conversion is not complete.  Nevertheless, elisp2py eliminates much of the tedious text manipulation that would otherwise be required.

The following is a list of the translations performed by c2py.  These transformations are controlled by convertCodeList().

I.  Prepass

These translations happen before removing all curly braces.

Suppose we are translating:

    aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
    {
        body
    }

1. Translates the function prototype, i.e., translates:

    aTypeSpec aClass::aMethod(t1 v1,...,tn vn)
to:
    def aMethod(v1,...vn):

As a special case, c2py translates:

    aTypeSpec aClass::aClass(t1 v1,...,tn vn)
to:
    aClass.__init__(t1 v1,...,tn vn)

Yes, I know, aClass.__init__ isn't proper Python, but retaining the class name is useful.

2. Let t denote any member of typeList or classList.

    a) Removes all casts of the form (t) or (t*) or (t**), etc.
    b) Converts t x, t *x, t **x, etc. to x.
    c) Converts x = new t(...) to x = t(...)
    d) For all i in ivarsDict[aClass] converts this -&gt; i to self.i
    e) For all i in ivarsDict[aClass] converts i to self.i

3. Converts &lt; &lt; x &gt; &gt; = to @c.  This Leo-specific translation is not done when translating files.

II.  Main Pass

This pass does the following simple translations everywhere except in comments and strings.

Changes all -&gt; to .
Changes all this.self to self (This corrects problems during the prepass.)
Removes all curly braces
Changes all #if to if
Changes all else if to elif
Changes all #else to else:
Changes all else to else:
Removes all #endif
Changes all &amp;&amp; to and
Changes all || to or
Changes all TRUE to True
Changes all FALSE to False
Changes all NULL to None
Changes all this to self
Changes all @code to @c.  This Leo-specific translation is not done when translating files.

III.  Complex Pass

This pass attempts more complex translations.

Converts if ( x ) to if x:
Converts elif ( x ) to elif x:
Converts while ( x ) to while x:
Converts for ( x ; y ; z ) to for x SEMI y SEMI z:

remove all semicolons.

IV.  Final Pass

This pass completes the translation.

Removes all semicolons.
Removes @c if it starts the text.  This Leo-specific translation is not done when translating files.
Removes all blank lines.
Removes excess whitespace from all lines, leaving leading whitespace unchanged.
Replaces C/C++ comments by Python comments.
Removes trailing whitespace from all lines.
</t>
<t tx="ekr.20040713130853.2">@ Strategy and Performance

The speed of elisp2py is unimportant.  We don't care about the memory used because we translate only small pieces of text at a time.

We can do body[i:j] = x, regardless of len(x).  We can also do del body[i:j] to delete characters.

We scan repeatedly through the text.  Using many passes greatly simplifies the code and does not slow down elisp2py significantly.

The script does not scan within strings or comments.  The idiom to handle such scans is the following:

def someScan(body):
    i = 0
    while i &lt; body(len):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif &lt;&lt; found what we are looking for ? &gt;&gt; :
            &lt;&lt; convert what we are looking for, setting i &gt;&gt;
        else: i += 1

That's about all there is to it.
</t>
<t tx="ekr.20040713130853.3">@ Please change the following lists so they contain the types and classes used by your program.

c2py removes all type definitions correctly; it converts
    new aType(...)
to
    aType(...)
@c

classList = [
    "vnode", "tnode", "Commands",
    "wxString", "wxTreeCtrl", "wxTextCtrl", "wxSplitterWindow" ]
    
typeList = ["char", "void", "short", "long", "int", "double", "float"]

@ Please change ivarsDict so it represents the instance variables (ivars) used by your program's classes.

ivarsDict is a dictionary used to translate ivar i of class c to self.i.  It also translates this-&gt;i to self.i.
@c
    
ivarsDict = {
    "atFile": [ "mCommands", "mErrors", "mStructureErrors",
        "mTargetFileName", "mOutputFileName", "mOutputStream",
        "mStartSentinelComment", "mEndSentinelComment", "mRoot"],

    "vnode": ["mCommands", "mJoinList", "mIconVal", "mTreeID", "mT", "mStatusBits"],

    "tnode": ["mBodyString", "mBodyRTF", "mJoinHead", "mStatusBits", "mFileIndex",
        "mSelectionStart", "mSelectionLength", "mCloneIndex"],
        
    "LeoFrame": ["mNextFrame", "mPrevFrame", "mCommands"],

    "Commands": [
        # public
        "mCurrentVnode", "mLeoFrame", "mInhibitOnTreeChanged", "mMaxTnodeIndex",
        "mTreeCtrl", "mBodyCtrl", "mFirstWindowAndNeverSaved",
        #private
        "mTabWidth", "mChanged", "mOutlineExpansionLevel", "mUsingClipboard",
        "mFileName", "mMemoryInputStream", "mMemoryOutputStream", "mFileInputStream",
        "mInputFile", "mFileOutputStream", "mFileSize", "mTopVnode", "mTagList",
        "mMaxVnodeTag",
        "mUndoType", "mUndoVnode", "mUndoParent", "mUndoBack", "mUndoN",
        "mUndoDVnodes", "mUndoLastChild", "mUndoablyDeletedVnode" ]}</t>
<t tx="ekr.20040713130853.4">testData = [ "\n@doc\n\
This is a doc part: format, whilest, {};-&gt;.\n\
&lt;&lt;\
section def&gt;&gt;=\n\
LeoFrame::LeoFrame(vnode *v, char *s, int i)\n\
{\n\
    // test ; {} /* */.\n\
    #if 0 //comment\n\
        if(gLeoFrameList)gLeoFrameList -&gt; mPrevFrame = this ;\n\
        else\n\
            this -&gt; mNextFrame = gLeoFrameList ;\n\
    #else\n\
        \n\
        vnode *v = new vnode(a,b);\n\
        Commands *commander = (Commands) NULL ; // after cast\n\
        this -&gt; mPrevFrame = NULL ;\n\
    #endif\n\
    if (a==b)\n\
        a = 2;\n\
    else if (a ==c)\n\
        a = 3;\n\
    else return; \n\
    /* Block comment test:\n\
        if(2):while(1): end.*/\n\
    for(int i = 1; i &lt; limit; ++i){\n\
        mVisible = FALSE ;\n\
        mOnTop = TRUE ;\n\
    }\n\
    // trailing ws.	 \n\
    mCommands = new Commands(this, mTreeCtrl, mTextCtrl) ;\n\
    gActiveFrame = this ;\n\
}\n\
    ", "&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
\n\
void vnode::OnCopyNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
    mCommands -&gt; copyOutline();\n\
}\n\
\n@doc\n\
another doc part if, then, else, -&gt; \n&lt;&lt;" +
"vnode methods &gt;&gt;=\n\
void vnode::OnPasteNode(wxCommandEvent&amp; WXUNUSED(event))\n\
{\n\
    mCommands -&gt; pasteOutline();\n\
}\n" ]</t>
<t tx="ekr.20040713130853.7">def speedTest(passes):

    import time
    file = r"c:\prog\LeoPy\LeoPy.leo"
    f=open(file)
    if not f:
        print "not found: ", file
        return
    s=f.read()
    f.close()
    print "file:", file, " size:", len(s), " passes:", passes
    print "speedTest start"
    time1 = time.clock()
    p = passes
    while p &gt; 0:
        n = len(s) ; i = 0 ; lines = 0
        while -1 &lt; i &lt; n:
            if s[i] == '\n':
                lines += 1 ; i += 1
            else:
                i = s.find('\n',i) # _much_ faster than list-based-find.
            continue
            # match is about 9 times slower than simple test.
            if s[i]=='\n': # match(s,i,'\n'): # 
                i += 1
            else:
                i += 1
        p -= 1
    time2 = time.clock()
    print "lines:", lines
    print "speedTest done:"
    print "elapsed time:", time2-time1
    print "time/pass:", (time2-time1)/passes</t>
<t tx="ekr.20040713130853.8">@language python
@tabwidth -4

import leoGlobals as g
import string

tabWidth = 4 # how many blanks in a tab.
printFlag = False
doLeoTranslations,dontDoLeoTranslations = True,False

gClassName = "" # The class name for the present function.  Used to modify ivars.
gIvars = [] # List of ivars to be converted to self.ivar

@others
</t>
<t tx="ekr.20040713130853.15">@ We separate the processing into two parts, 1) a leo-aware driver that iterates over @file trees and 2) a text-based part that processes one or more files or strings.
</t>
<t tx="ekr.20040713130853.16">def convertCurrentTree():

    import c2py
    import leo
    import leoGlobals
    c=leoGlobals.top()
    v = c.currentVnode()
    c2py.convertLeoTree(v,c)</t>
<t tx="ekr.20040713130853.17">def convertLeoTree(v,c):

    after=v.nodeAfterTree()
    while v and v != after:
        s=v.bodyString()
        print "converting:", v.headString()
        s=convertCStringToPython(s, doLeoTranslations )
        v.setBodyStringOrPane(s)
        v=v.threadNext()
    c.Repaint() # for backward compatibility.
    print "end of c2py"</t>
<t tx="ekr.20040713130853.18">def convertCFileToPython(file):

    f=open(file, 'r')
    if not f: return
    s = f.read()
    f.close();
    f=open(file + ".py", 'w')
    if not f: return
    s = convertCStringToPython(s, dontDoLeoTranslations )
    f.write(s)
    f.close()</t>
<t tx="ekr.20040713130853.19"></t>
<t tx="ekr.20040713130853.20">def convertCStringToPython(s, leoFlag):

    # print "convertCStringToPython:start\n", s
    firstPart = True
    codeList = stringToList(s)
    
    if not leoFlag:
        convertCodeList(codeList, firstPart, dontDoLeoTranslations)
        return listToString(codeList)

    outputList = []
    i = 0
    while i &lt; len(codeList):
        j = skipCodePart(codeList,i)
        if j &gt; i:
            code = codeList[i:j]
            convertCodeList(code, firstPart, doLeoTranslations)
            i = j
            #print "-----code:", listToString(code)
            for item in code:
                outputList.append(item)
        firstPart = False # don't remove @c from here on.
        j = skipDocPart(codeList,i)
        if j &gt; i:
            doc = codeList[i:j]
            convertDocList(doc)
            #print "-----doc:", listToString(doc)
            i = j
            for item in doc:
                outputList.append(item)
    
    result = listToString(outputList)
    global printFlag
    if printFlag: print "-----:\n", result
    return result</t>
<t tx="ekr.20040713130853.21">def OLDconvert(self,list, firstPart, leoFlag):
    #first
    convertLeadingBlanks(list)
    if leoFlag:
        replaceSectionDefs(list)
    mungeAllFunctions(list)
    #next
    safeReplace(list, " -&gt; ", '.')
    safeReplace(list, "-&gt;", '.')
    safeReplace(list, " . ", '.')
    safeReplace(list, "this.self", "self")
    safeReplace(list, "{", None)
    safeReplace(list, "}", None)
    safeReplace(list, "#if", "if")
    safeReplace(list, "#else", "else")
    safeReplace(list, "#endif", None)
    safeReplace(list, "else if", "elif")
    safeReplace(list, "else", "else:")
    safeReplace(list, "&amp;&amp;", "and")
    safeReplace(list, "||", "or")
    safeReplace(list, "TRUE", "True")
    safeReplace(list, "FALSE", "False")
    safeReplace(list, "NULL", "None")
    safeReplace(list, "this", "self")
    safeReplace(list, "try", "try:")
    safeReplace(list, "catch", "except:")
    if leoFlag:
        safeReplace(list, "@code", "@c")
    #next
    handleAllKeywords(list)
    # after processing for keywords
    removeSemicolonsAtEndOfLines(list)
    #last
    if firstPart and leoFlag: removeLeadingAtCode(list)
    removeBlankLines(list)
    removeExcessWs(list)
    # your taste may vary: in Python I don't like extra whitespace
    safeReplace(list, " :", ":") 
    safeReplace(list, ", ", ",")
    safeReplace(list, " ,", ",")
    safeReplace(list, " (", "(")
    safeReplace(list, "( ", "(")
    safeReplace(list, " )", ")")
    safeReplace(list, ") ", ")")
    replaceComments(list) # should follow all calls to safeReplace
    removeTrailingWs(list)
    safeReplace(list, "\t ", "\t") # happens when deleting declarations.</t>
<t tx="ekr.20040713130853.22">def convertDocList(docList):

    # print "convertDocList:", docList
    if matchWord(docList, 0, "@doc"):
        i = skipWs(docList, 4)
        if match(docList, i, "\n"):
            i += 1
        docList[0:i] = list("@ ")</t>
<t tx="ekr.20040713130853.23">def skipDocPart(list, i):
    
    # print "skipDocPart", i
    while i &lt; len(list):
        if matchWord(list, i, "@code") or matchWord(list, i, "@c"):
            break
        elif isSectionDef(list,i):
            break
        else: i = skipPastLine(list, i)
    return i</t>
<t tx="ekr.20040713130853.24">def skipCodePart(codeList, i):
    
    # print "skipCodePart", i
    if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
        return i
    while i &lt; len(codeList):
        if match(codeList, i, "//"):
            i = skipPastLine(codeList,i)
        elif match(codeList, i, "/*"):
            i = skipCBlockComment(codeList,i)
        elif match(codeList, i, '"') or match(codeList, i, "'"):
            i = skipString(codeList,i)
        elif match(codeList, i, "\n"):
            i += 1
            if matchWord(codeList, i, "@doc") or matchWord(codeList, i, "@"):
                break
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.27">def convertLeadingBlanks(list):

    global tabWidth
    if tabWidth &lt; 2: return
    i = 0
    while i &lt; len(list):
        n = 0
        while i &lt; len(list) and list[i] == ' ':
            n += 1 ; i += 1
            if n == tabWidth:
                list[i-tabWidth:i] = ['\t']
                i = i - tabWidth + 1
                n = 0
        i = skipPastLine(list, i)</t>
<t tx="ekr.20040713130853.28">def findInList(list, i, findStringOrList):

    findList = stringToList(findStringOrList)
    
    while i &lt; len(list):
        if match(list, i, findList): return i
        else: i += 1
    return -1</t>
<t tx="ekr.20040713130853.29">def findInCode(codeList, i, findStringOrList):

    findList = stringToList(findStringOrList)
    
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList, i, findList):
            return i
        else: i += 1
    return -1</t>
<t tx="ekr.20040713130853.30"># We scan for a '{' at the top level that is preceeded by ')'
# @code and &lt; &lt; x &gt; &gt; = have been replaced by @c
def mungeAllFunctions(codeList):

    prevSemi = 0 # Previous semicolon: header contains all previous text
    i = 0
    firstOpen = None
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
            prevSemi = i
        elif match(codeList, i, '('):
            if not firstOpen:
                firstOpen = i
            i += 1
        elif match(codeList, i, '#'):
            i = skipPastLine(codeList, i)
            prevSemi = i
        elif match(codeList, i, ';'):
            i += 1
            prevSemi = i
        elif matchWord(codeList, i, "@code"):
            i += 5
            prevSemi = i # restart the scan
        elif matchWord(codeList, i, "@c"):
            i += 2 ; prevSemi = i # restart the scan
        elif match(codeList, i, "{"):
            i = handlePossibleFunctionHeader(codeList,i,prevSemi,firstOpen)
            prevSemi = i ; firstOpen = None # restart the scan
        else: i += 1</t>
<t tx="ekr.20040713130853.31"># converts function header lines from c++ format to python format.
# That is, converts
# x1..nn w::y ( t1 z1,..tn zn) {
# to
# def y (z1,..zn): {

def handlePossibleFunctionHeader(codeList, i, prevSemi, firstOpen):

    assert(match(codeList,i,"{"))
    prevSemi = skipWsAndNl(codeList, prevSemi)
    close = prevNonWsOrNlChar(codeList, i)
    if close &lt; 0 or codeList[close] != ')':
        return 1 + skipToMatchingBracket(codeList, i)
    if not firstOpen:
        return 1 + skipToMatchingBracket(codeList, i)
    close2 = skipToMatchingBracket(codeList, firstOpen)
    if close2 != close:
        return 1 + skipToMatchingBracket(codeList, i)
    open = firstOpen
    assert(codeList[open]=='(')
    head = codeList[prevSemi:open]
    # do nothing if the head starts with "if", "for" or "while"
    k = skipWs(head,0)
    if k &gt;= len(head) or not head[k] in string.letters:
        return 1 + skipToMatchingBracket(codeList, i)
    kk = skipPastWord(head,k)
    if kk &gt; k:
        headString = listToString(head[k:kk])
        # C keywords that might be followed by '{'
        # print "headString:", headString
        if headString in [ "class", "do", "for", "if", "struct", "switch", "while"]:
            return 1 + skipToMatchingBracket(codeList, i)
    args = codeList[open:close+1]
    k = 1 + skipToMatchingBracket(codeList,i)
    body = codeList[i:k]
    #print "head:", listToString(head)
    #print "args:", listToString(args)
    #print "body:", listToString(body)
    #print "tot: ", listToString(codeList[prevSemi:k])
    head = massageFunctionHead(head)
    args = massageFunctionArgs(args)
    body = massageFunctionBody(body)
    #print "head2:", listToString(head)
    #print "args2:", listToString(args)
    #print "body2:", listToString(body)
    #print "tot2: ", listToString(codeList[prevSemi:k])
    result = []
    for item in head:
        result.append(item)
    for item in args:
        result.append(item)
    for item in body:
        result.append(item)
    codeList[prevSemi:k] = result
    return k</t>
<t tx="ekr.20040713130853.32">def massageFunctionArgs(args):
    global gClassName
    assert(args[0]=='(')
    assert(args[-1]==')')

    result = ['('] ; lastWord = []
    if gClassName:
        for item in list("self,"): result.append(item) #can put extra comma

    i = 1
    while i &lt; len(args):
        i = skipWsAndNl(args, i)
        c = args[i]
        if c in string.letters:
            j = skipPastWord(args,i)
            lastWord = args[i:j]
            i = j
        elif c == ',' or c == ')':
            for item in lastWord:
                result.append(item)
            if lastWord != [] and c == ',':
                result.append(',')
            lastWord = []
            i += 1
        else: i += 1
    if result[-1] == ',':
        del result[-1]
    result.append(')')
    result.append(':')
    # print "new args:", listToString(result)
    return result</t>
<t tx="ekr.20040713130853.33">def massageFunctionHead(head):

    # print "head:", listToString(head)
    result = []
    prevWord = []
    global gClassName ; gClassName = []
    i = 0
    while i &lt; len(head):
        i = skipWsAndNl(head, i)
        if i &lt; len(head) and head[i] in string.letters:
            result = []
            j = skipPastWord(head,i)
            prevWord = head[i:j]
            i = j
            # look for ::word2
            i = skipWs(head,i)
            if match(head,i,"::"):
                # Set the global to the class name.
                gClassName = listToString(prevWord)
                # print "class name:", gClassName
                i = skipWs(head, i+2)
                if i &lt; len(head) and (head[i]=='~' or head[i] in string.letters):
                    j = skipPastWord(head,i)
                    if head[i:j] == prevWord:
                        for item in list("__init__"): result.append(item)
                    elif head[i]=='~' and head[i+1:j] == prevWord:
                        for item in list("__del__"): result.append(item)
                    else:
                        # for item in "::": result.append(item)
                        for item in head[i:j]: result.append(item)
                    i = j
            else:
                for item in prevWord:result.append(item)
        else: i += 1
        
    finalResult = list("def ")
    for item in result: finalResult.append(item)
    # print "new head:", listToString(finalResult)
    return finalResult</t>
<t tx="ekr.20040713130853.34">def massageFunctionBody(body):

    body = massageIvars(body)
    body = removeCasts(body)
    body = removeTypeNames(body)
    return body</t>
<t tx="ekr.20040713130853.35">def massageIvars(body):

    if gClassName and ivarsDict.has_key(gClassName):
        ivars = ivarsDict [ gClassName ]
    else:
        ivars = []
    # print "key:ivars=", gClassName, ':', `ivars`

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif body[i] in string.letters:
            j = skipPastWord(body,i)
            word = listToString(body[i:j])
            # print "looking up:", word
            if word in ivars:
                # replace word by self.word
                # print "replacing", word, " by self.", word
                word = "self." + word
                word = list(word)
                body[i:j] = word
                delta = len(word)-(j-i)
                i = j + delta
            else: i = j
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.36">def removeCasts(body):

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif match(body, i, '('):
            start = i
            i = skipWs(body, i+1)
            if body[i] in string.letters:
                j = skipPastWord(body,i)
                word = listToString(body[i:j])
                i = j
                if word in classList or word in typeList:
                    i = skipWs(body, i)
                    while match(body,i,'*'):
                        i += 1
                    i = skipWs(body, i)
                    if match(body,i,')'):
                        i += 1
                        # print "removing cast:", listToString(body[start:i])
                        del body[start:i]
                        i = start
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.37"># Do _not_ remove type names when preceeded by new.

def removeTypeNames(body):

    i = 0
    while i &lt; len(body):
        if isStringOrComment(body,i):
            i = skipStringOrComment(body,i)
        elif matchWord(body, i, "new"):
            i = skipPastWord(body,i)
            i = skipWs(body,i)
            # don't remove what follows new.
            if body[i] in string.letters:
                i = skipPastWord(body,i)
        elif body[i] in string.letters:
            j = skipPastWord(body,i)
            word = listToString(body[i:j])
            if word in classList or word in typeList:
                k = skipWs(body, j)
                while match(body,k,'*'):
                    k += 1 ; j = k
                # print "Deleting type name:", listToString(body[i:j])
                del body[i:j]
            else:
                i = j
        else: i += 1
    return body</t>
<t tx="ekr.20040713130853.38"># converts if ( x ) to if x:
# converts while ( x ) to while x:
def handleAllKeywords(codeList):

    # print "handAllKeywords:", listToString(codeList)
    i = 0
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif ( matchWord(codeList,i,"if") or
            matchWord(codeList,i,"while") or
            matchWord(codeList,i,"for") or
            matchWord(codeList,i,"elif") ):
            i = handleKeyword(codeList,i)
        else:
            i += 1
    # print "handAllKeywords2:", listToString(codeList)</t>
<t tx="ekr.20040713130853.39">def handleKeyword(codeList,i):

    isFor = False
    if (matchWord(codeList,i,"if")):
        i += 2
    elif (matchWord(codeList,i,"elif")):
        i += 4
    elif (matchWord(codeList,i,"while")):
        i += 5
    elif (matchWord(codeList,i,"for")):
        i += 3
        isFor = True
    else: assert(0)
    # Make sure one space follows the keyword
    k = i
    i = skipWs(codeList,i)
    if k == i:
        c = codeList[i]
        codeList[i:i+1] = [ ' ', c ]
        i += 1
    # Remove '(' and matching ')' and add a ':'
    if codeList[i] == "(":
        j = removeMatchingBrackets(codeList,i)
        if j &gt; i and j &lt; len(codeList):
            c = codeList[j]
            codeList[j:j+1] = [":", " ", c]
            j = j + 2
        return j
    return i</t>
<t tx="ekr.20040713130853.40">def isWs(c):
    return c == ' ' or c == '\t'
    
def isWsOrNl(c):
    return c == ' ' or c == '\t' or c == '\n'</t>
<t tx="ekr.20040713130853.41"># returns the ending index if i points to &lt; &lt; x &gt; &gt; =
def isSectionDef(list, i):

    i = skipWs(list,i)
    if not match(list,i,"&lt;&lt;"): return False
    while i &lt; len(list) and list[i] != '\n':
        if match(list,i,"&gt;&gt;="): return i+3
        else: i += 1
    return False</t>
<t tx="ekr.20040713130853.42">def isStringOrComment(list, i):

    return match(list,i,"'") or match(list,i,'"') or match(list,i,"//") or match(list,i,"/*")</t>
<t tx="ekr.20040713130853.43"># returns True if findList matches starting at codeList[i]

def match (codeList, i, findStringOrList):

    findList = stringToList(findStringOrList)
    n = len(findList)
    j = 0
    while i+j &lt; len(codeList) and j &lt; len(findList):
        if codeList[i+j] != findList[j]:
            return False
        else:
            j += 1
            if j == n:
                return i+j
    return False</t>
<t tx="ekr.20040713130853.44">def matchWord (codeList, i, findStringOrList):

    j = match(codeList,i,findStringOrList)
    if not j:
        return False
    elif j &gt;= len(codeList):
        return True
    else:
        c = codeList[j]
        return not (c in string.letters or c in string.digits or c == '_')</t>
<t tx="ekr.20040713130853.45">def prevNonWsChar(list, i):

    i -= 1
    while i &gt;= 0 and isWs(list[i]):
        i -= 1
    return i

def prevNonWsOrNlChar(list, i):

    i -= 1
    while i &gt;= 0 and isWsOrNl(list[i]):
        i -= 1
    return i</t>
<t tx="ekr.20040713130853.46">def removeAllCComments(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            i = skipString(list,i)
        elif match(list,i,"//"):
            j = skipPastLine(list,i)
            print "deleting single line comment:", listToString(list[i:j])
            del list[i:j]
        elif match(list,i,"/*"):
            j = skipCBlockComment(list,i)
            print "deleting block comment:", listToString(list[i:j])
            del list[i:j]
        else:
            i += 1</t>
<t tx="ekr.20040713130853.47">def removeAllCSentinels(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            # string starts a line.
            i = skipString(list,i)
            i = skipPastLine(list,i)
        elif match(list,i,"/*"):
            # block comment starts a line
            i = skipCBlockComment(list,i)
            i = skipPastLine(line,i)
        elif match(list,i,"//@"):
            j = skipPastLine(list,i)
            print "deleting sentinel:", listToString(list[i:j])
            del list[i:j]
        else:
            i = skipPastLine(list,i)</t>
<t tx="ekr.20040713130853.48">def removeAllPythonComments(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            i = skipString(list,i)
        elif match(list,i,"#"):
            j = skipPastLine(list,i)
            print "deleting comment:", listToString(list[i:j])
            del list[i:j]
        else:
            i += 1</t>
<t tx="ekr.20040713130853.49">def removeAllPythonSentinels(list, delim):

    i = 0
    while i &lt; len(list):
        if match(list,i,"'") or match(list,i,'"'):
            # string starts a line.
            i = skipString(list,i)
            i = skipPastLine(list,i)
        elif match(list,i,"#@"):
            j = skipPastLine(list,i)
            print "deleting sentinel:", listToString(list[i:j])
            del list[i:j]
        else:
            i = skipPastLine(list,i)</t>
<t tx="ekr.20040713130853.50">def removeAtRoot (codeList):

    i = skipWs(codeList, 0)
    if matchWord(codeList,i,"@root"):
        j = skipPastLine(codeList,i)
        del codeList[i:j]

    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,"\n"):
            i = skipWs(codeList, i+1)
            if matchWord (codeList,i,"@root"):
                j = skipPastLine(codeList,i)
                del codeList[i:j]
        else: i += 1
</t>
<t tx="ekr.20040713130853.51">def removeBlankLines(codeList):

    i = 0
    while i &lt; len(codeList):
        j = i
        while j &lt; len(codeList) and (codeList[j]==" " or codeList[j]=="\t"):
            j += 1
        if j== len(codeList) or codeList[j] == '\n':
            del codeList[i:j+1]
        else:
            oldi = i
            i = skipPastLine(codeList,i)</t>
<t tx="ekr.20040713130853.52">def removeExcessWs(codeList):

    i = 0
    i = removeExcessWsFromLine(codeList,i)
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,'\n'):
            i += 1
            i = removeExcessWsFromLine(codeList,i)
        else: i += 1</t>
<t tx="ekr.20040713130853.53">def removeExcessWsFromLine(codeList,i):

    assert(i==0 or codeList[i-1] == '\n')
    i = skipWs(codeList,i)
    while i &lt; len(codeList):
        if isStringOrComment(codeList,i): break # safe
        elif match(codeList, i, '\n'): break
        elif match(codeList, i, ' ') or match(codeList, i, '\t'):
            # Replace all whitespace by one blank.
            k = i
            i = skipWs(codeList,i)
            codeList[k:i] = [' ']
            i = k + 1 # make sure we don't go past a newline!
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.54">def removeLeadingAtCode(codeList):

    i = skipWsAndNl(codeList,0)
    if matchWord(codeList,i,"@code"):
        i = skipWsAndNl(codeList,5)
        del codeList[0:i]
    elif matchWord(codeList,i,"@c"):
        i = skipWsAndNl(codeList,2)
        del codeList[0:i]</t>
<t tx="ekr.20040713130853.55">def removeMatchingBrackets(codeList, i):

    j = skipToMatchingBracket(codeList, i)
    if j &gt; i and j &lt; len(codeList):
        # print "del brackets:", listToString(codeList[i:j+1])
        c = codeList[j]
        if c == ')' or c == ']' or c == '}':
            del codeList[j:j+1]
            del codeList[i:i+1]
            # print "returning:", listToString(codeList[i:j])
            return j - 1
        else: return j + 1
    else: return j</t>
<t tx="ekr.20040713130853.56">def removeSemicolonsAtEndOfLines(list):

    i = 0
    while i &lt; len(list):
        if isStringOrComment(list,i):
            i = skipStringOrComment(list,i)
        elif list[i] == ';':
            j = skipWs(list,i+1)
            if j &gt;= len(list) or match(list,j,'\n') or match(list,j,'#') or match(list,j,"//"):
                del list[i]
            else: i += 1
        else: i += 1</t>
<t tx="ekr.20040713130853.57">def removeTrailingWs(list):

    i = 0
    while i &lt; len(list):
        if isWs(list[i]):
            j = i
            i = skipWs(list,i)
            assert(j &lt; i)
            if i &gt;= len(list) or list[i] == '\n':
                # print "removing trailing ws:", `i-j`
                del list[j:i]
                i = j
        else: i += 1</t>
<t tx="ekr.20040713130853.58"># Replaces all occurances of findString by changeString.
# Deletes all occurances if change is None
def replace(codeList, findString, changeString):

    if len(findString)==0: return
    findList = stringToList(findString)
    changeList = stringToList(changeString)

    i = 0
    while i &lt; len(codeList):
        if match(codeList, i, findList):
            codeList[i:i+len(findList)] = changeList
            i += len(changeList)
        else: i += 1</t>
<t tx="ekr.20040713130853.59"># For Leo we expect few block comments; doc parts are much more common.

def replaceComments(codeList):

    i = 0
    if match(codeList, i, "//"):
        codeList[0:2] = ['#']
    while i &lt; len(codeList):
        if match(codeList, i, "//"):
            codeList[i:i+2] = ['#']
            i = skipPastLine(codeList,i)
        elif match(codeList, i, "/*"):
            j = skipCBlockComment(codeList,i)
            del codeList[j-2:j]
            codeList[i:i+2] = ['#']
            j -= 2 ; k = i ; delta = -1
            while k &lt; j + delta :
                if codeList[k]=='\n':
                    codeList[k:k+1] = ['\n', '#', ' ']
                    delta += 2 ; k += 3 # progress!
                else: k += 1
            i = j + delta
        elif match(codeList, i, '"') or match(codeList, i, "'"):
            i = skipString(codeList,i)
        else: i += 1</t>
<t tx="ekr.20040713130853.60"># Replaces &lt; &lt; x &gt; &gt; = by @c (at the start of lines).
def replaceSectionDefs(codeList):

    i = 0
    j = isSectionDef(codeList,i)
    if j &gt; 0: codeList[i:j] = list("@c ")

    while i &lt; len(codeList):
        if isStringOrComment(codeList,i):
            i = skipStringOrComment(codeList,i)
        elif match(codeList,i,"\n"):
            i += 1
            j = isSectionDef(codeList,i)
            if j &gt; i: codeList[i:j] = list("@c ")
        else: i += 1</t>
<t tx="ekr.20040713130853.61"># Replaces occurances of findString by changeString outside of C comments and strings.
# Deletes all occurances if change is None.
def safeReplace(codeList, findString, changeString):

    if len(findString)==0: return
    findList = stringToList(findString)
    changeList = stringToList(changeString)
    i = 0
    if findList[0] in string.letters: #use matchWord
        while i &lt; len(codeList):
            if isStringOrComment(codeList,i):
                i = skipStringOrComment(codeList,i)
            elif matchWord(codeList, i, findList):
                codeList[i:i+len(findList)] = changeList
                i += len(changeList)
            else: i += 1
    else: #use match
        while i &lt; len(codeList):
            if match(codeList, i, findList):
                codeList[i:i+len(findList)] = changeList
                i += len(changeList)
            else: i += 1</t>
<t tx="ekr.20040713130853.62">def skipCBlockComment(codeList, i):

    assert(match(codeList, i, "/*"))
    i += 2

    while i &lt; len(codeList):
        if match(codeList, i, "*/"): return i + 2
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.63">def skipPastLine(codeList, i):

    while i &lt; len(codeList) and codeList[i] != '\n':
        i += 1
    if i &lt; len(codeList) and codeList[i] == '\n':
        i += 1
    return i</t>
<t tx="ekr.20040713130853.64">def skipPastWord(list, i):

    assert(list[i] in string.letters or list[i]=='~')
    
    # Kludge: this helps recognize dtors.
    if list[i]=='~':
        i += 1
    
    while i &lt; len(list) and (
        list[i] in string.letters or
        list[i] in string.digits or
        list[i]=='_'):
        i += 1
    return i</t>
<t tx="ekr.20040713130853.65">def skipString(codeList, i):

    delim = codeList[i] # handle either single or double-quoted strings
    assert(delim == '"' or delim == "'")
    i += 1

    while i &lt; len(codeList):
        if codeList[i] == delim: return i + 1
        elif codeList[i] == '\\': i += 2
        else: i += 1
    return i</t>
<t tx="ekr.20040713130853.66">def skipStringOrComment(list,i):

    if match(list,i,"'") or match(list,i,'"'):
        return skipString(list,i)
    if match(list, i, "//"):
        return skipPastLine(list,i)
    elif match(list, i, "/*"):
        return skipCBlockComment(list,i)
    else: assert(0)</t>
<t tx="ekr.20040713130853.68">def skipWs(list, i):

    while i &lt; len(list):
        c = list[i]
        if c == ' ' or c == '\t':
            i += 1
        else: break
    return i
    
def skipWsAndNl(list, i):

    while i &lt; len(list):
        c = list[i]
        if c == ' ' or c == '\t' or c == '\n':
            i += 1
        else: break
    return i</t>
<t tx="ekr.20040713131315">@killcolor


indentation level depends on def, if, while, etc., not on parens.

</t>
<t tx="ekr.20040713131350">@language elisp</t>
<t tx="ekr.20040713132127.1">@ignore
@language elisp
</t>
<t tx="ekr.20040713132127.2">;;; -*-unibyte: t;-*-

;;;; igrep.el --- An improved interface to `grep` and `find`.

;;; SCCS @(#)igrep.el	2.95

;;; Description:
;;; 
;;; The `igrep' command is like `grep' except that it takes three
;;; required arguments (PROGRAM, EXPRESSION, and FILES) and an optional
;;; argument (OPTIONS) instead of just one argument (COMMAND).  The
;;; analogous `egrep' and `fgrep' commands are also defined for
;;; convenience.
;;; 
;;; The `igrep-find' command is like `igrep' except that it uses `find`
;;; to recursively `grep` a directory.  The analogous `egrep-find' and
;;; `fgrep-find' commands are also defined for convenience.
;;; 
;;; When called interactively, `igrep' and `igrep-find' (and their
;;; analogues) provide defaults for the EXPRESSION and FILES arguments
;;; based on the current word and the visited file name (if the
;;; `igrep-expression-default' and `igrep-files-default' options are
;;; set, respectively).  The `igrep-insert-default-key' option allows
;;; the default value to be inserted into the minibuffer for editing;
;;; since Emacs 20 provides that via the minibuffer history, it's only
;;; enabled for older versions by default. Other options that control
;;; the user interface are `igrep-read-options', `igrep-read-multiple-files',
;;; `igrep-verbose-prompts', and `igrep-save-buffers'.
;;; 
;;; Besides the basic `igrep-program' and `igrep-find-program' global
;;; variables, other variables control the syntax of the `grep` and
;;; `find` shell commands that are executed: `igrep-options',
;;; `igrep-expression-option', `igrep-find-prune-clause',
;;; `igrep-find-file-clause', and `igrep-find-use-xargs'.
;;; 
;;; The `igrep-use-zgrep' user option controls whether the corresponding
;;; GNU (gzip) "zPROGRAM" script is used, to `grep` compressed files.
;;; Special minibuffer history lists are maintained for the EXPRESSION
;;; and FILES arguments.
;;; 
;;; The `agrep' and `agrep-find' commands are interfaces to the
;;; approximate `grep` utility, which is distributed with the `glimpse'
;;; indexing and query tool (available from
;;; &lt;URL:http://glimpse.cs.arizona.edu:1994/&gt;).
;;; 
;;; `grep' itself can be advised to provide the `igrep' interface when
;;; it is invoked interactively (so that when it's called
;;; programmatically, it still uses the original argument list), via the
;;; `igrep-insinuate' command.  `igrep-insinuate' also defines
;;; `grep-find' as an alias for `igrep-find', `dired-do-grep' and
;;; `dired-do-grep-find' as aliases for `dired-do-igrep' and
;;; `dired-do-igrep-find', and `Buffer-menu-grep' as an alias for
;;; `Buffer-menu-igrep'.
;;; 
;;; When run interactively from Dired mode, the various `igrep' commands
;;; provide defaults for the EXPRESSION and FILES arguments that are
;;; based on the visited directory (including any inserted
;;; subdirectories) and the current file.  The alternative
;;; `dired-do-igrep' and `dired-do-igrep-find' commands respect the
;;; `dired-do-*' command conventions: a prefix argument is interpreted
;;; as the number of succeeding files to `grep`, otherwise all the
;;; marked files are `grep`ed.
;;; 
;;; The `igrep-visited-files' command provides a simple way to `grep`
;;; just those files that are being visited in buffers.  The
;;; `Buffer-menu-igrep' command does the same thing, for buffers marked
;;; for selection in Buffer Menu mode.

;;; Copyright:
;;; 
;;; Copyright © 1994-1998,2000-2002 Kevin Rodgers
;;; 
;;; This program is free software; you can redistribute it and/or modify
;;; it under the terms of the GNU General Public License as published by
;;; the Free Software Foundation; either version 2 of the License, or
;;; at your option) any later version.
;;; 
;;; This program is distributed in the hope that it will be useful,
;;; but WITHOUT ANY WARRANTY; without even the implied warranty of
;;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
;;; GNU General Public License for more details.
;;; 
;;; You should have received a copy of the GNU General Public License
;;; along with this program; if not, write to the Free Software
;;; Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
;;; 
;;; Neither my former nor current employer (Martin Marietta and
;;; Information Handling Services, respectively) has disclaimed any
;;; copyright interest in igrep.el.
;;; 
;;; Kevin Rodgers &lt;kevinr@ihs.com&gt;          Lead Software Engineer
;;; Information Handling Services           Electronic Systems Development
;;; 15 Inverness Way East, M/S A201         GO BUFFS!
;;; Englewood CO 80112-5776 USA             1+ (303) 397-2807[voice]/-2244[fax]

;;; Installation:
;;; 
;;; 1. Put this file in a directory that is a member of load-path, and
;;;    byte-compile it (e.g. with `M-x byte-compile-file') for better
;;;    performance.  You can ignore any warnings about references to free
;;;    variables and "not known to be defined" functions.
;;; 2. Put these forms in default.el or ~/.emacs:
;;;    (autoload 'igrep "igrep"
;;;       "*Run `grep` PROGRAM to match EXPRESSION in FILES..." t)
;;;    (autoload 'igrep-find "igrep"
;;;       "*Run `grep` via `find`..." t)
;;;    (autoload 'igrep-visited-files "igrep"
;;;       "*Run `grep` ... on all visited files." t)
;;;    (autoload 'dired-do-igrep "igrep"
;;;       "*Run `grep` on the marked (or next prefix ARG) files." t)
;;;    (autoload 'dired-do-igrep-find "igrep"
;;;       "*Run `grep` via `find` on the marked (or next prefix ARG) directories." t)
;;;    (autoload 'Buffer-menu-igrep "igrep"
;;;      "*Run `grep` on the files visited in buffers marked with '&gt;'." t)
;;;    (autoload 'igrep-insinuate "igrep"
;;;      "Define `grep' aliases for the corresponding `igrep' commands." t)
;;; 2. a. For completeness, you can add these forms as well:
;;;    (autoload 'grep "igrep"
;;;       "*Run `grep` PROGRAM to match EXPRESSION in FILES..." t)
;;;    (autoload 'egrep "igrep"
;;;       "*Run `egrep`..." t)
;;;    (autoload 'fgrep "igrep"
;;;       "*Run `fgrep`..." t)
;;;    (autoload 'agrep "igrep"
;;;       "*Run `agrep`..." t)
;;;    (autoload 'grep-find "igrep"
;;;       "*Run `grep` via `find`..." t)
;;;    (autoload 'egrep-find "igrep"
;;;       "*Run `egrep` via `find`..." t)
;;;    (autoload 'fgrep-find "igrep"
;;;       "*Run `fgrep` via `find`..." t)
;;;    (autoload 'agrep-find "igrep"
;;;       "*Run `agrep` via `find`..." t)
;;; 3. If you are running Windows 95/NT, you should install findutils
;;;    and grep from release 17.1 (or higher) of the Cygnus GNU-Win32
;;;    distribution.  See &lt;URL:http://www.cygnus.com/misc/gnu-win32/&gt;.

;;; Usage:
;;; 
;;; These igrep commands accept 1, 2, or 3 `C-u' prefix arguments:
;;; 	M-x igrep		M-x igrep-find
;;; 	M-x  grep		M-x  grep-find	[after `M-x igrep-insinuate']
;;; 	M-x egrep		M-x egrep-find
;;; 	M-x fgrep		M-x fgrep-find
;;; 	M-x agrep		M-x agrep-find
;;; 
;;; These igrep commands accept a single `C-u' prefix argument:
;;; 	M-x igrep-visited-files
;;; 	M-x Buffer-menu-igrep	[in the *Buffer List* buffer]
;;; 
;;; These igrep commands interpret a prefix argument like the Emacs
;;; `dired-do-*' commands:
;;; 	M-x dired-do-igrep	M-x dired-do-igrep-find
;;; 	M-x  dired-do-grep	M-x  dired-do-grep-find	[after `M-x
;;; 							 igrep-insinuate']
;;; 
;;; These Emacs commands can be used after any igrep command:
;;; 	C-x ` (M-x next-error)
;;; 	C-c C-c (M-x compile-goto-error)	[in the *igrep* buffer]

;;; Customization examples:
;;; 
;;; To ignore case by default:
;;; 	(setq igrep-options "-i")
;;; To search subdirectories by default:
;;; 	(setq igrep-find t)
;;; To search files with the GNU (gzip) zgrep script:
;;; 	(setq igrep-use-zgrep t)
;;; or define new igrep commands (this works for zegrep and zfgrep as well):
;;; 	(igrep-define zgrep)		; M-x zgrep
;;; 	(igrep-find-define zgrep)	; M-x zgrep-find
;;; To search "*.[ch]" files by default in C mode:
;;; 	(put 'igrep-files-default 'c-mode
;;; 	     (lambda () "*.[ch]"))
;;; To disable the default search expression and/or files pattern,
;;; except for specific modes:
;;; 	(setq igrep-expression-default 'ignore)
;;; 	(setq igrep-files-default 'ignore)
;;; To avoid exceeding some shells' limit on command argument length
;;; (this only searches files in the current directory):
;;; 	(setq igrep-find t
;;; 	      igrep-find-prune-clause "-type d \\! -name .")

;;; To do:
;;; 
;;; 1. Replace igrep-options with a table that maps igrep-program
;;;    to the appropriate options.
;;; 2. Generalize support for the -prune find clause (e.g. -fstype nfs).
;;; 3. Provide support for `glimpse`.
;;; 4. Add a menu interface.
;;; 5. Port to Emacs 20 (custom).

;;; Emacs Lisp Archive Entry:
;;; Filename: igrep.el
;;; Author: Kevin Rodgers &lt;kevinr@ihs.com&gt;
;;; Version: 2.95
;;; Description: An improved interface to `grep` and `find`.
;;; Keywords: search
;;; Last-Updated: 02/04/22


;;; Package interface:

(provide 'igrep)

(require 'compile)			; compile-internal, grep-regexp-alist,
					; grep-null-device

(eval-when-compile
  (require 'dired)			; dired-directory,
					; dired-get-filename,
					; dired-current-directory,
					; dired-get-marked-files,
					; dired-mark-get-files
  (or (featurep 'ange-ftp)
      (featurep 'efs)
      (condition-case nil
	  (load-library "ange-ftp")	; ange-ftp-ftp-name
	(error nil))
      (condition-case nil
	  (load-library "efs")		; efs-ftp-path
	(error nil)))
  )

</t>
<t tx="ekr.20040713132127.3">(defconst igrep-version "2.95"
  "Version of igrep.el")</t>
<t tx="ekr.20040713132127.4">


;;; User options:

</t>
<t tx="ekr.20040713132127.5">(defvar igrep-options nil

  "*The options passed by `\\[igrep]' to `igrep-program', or nil.

`-n' will automatically be passed to `igrep-program', to generate the
output expected by `\\[next-error]' and `\\[compile-goto-error]'.
`-e' will automatically be passed to `igrep-program', if it supports
that option.")</t>
<t tx="ekr.20040713132127.6">
(put 'igrep-options 'variable-interactive
     "xOptions (\"-xyz\" or nil): ")

</t>
<t tx="ekr.20040713132127.7">(defvar igrep-read-options nil
  "*If non-nil, `\\[igrep]' always prompts for options;
otherwise, it only prompts when 1 or 3 `C-u's are given as a prefix arg.")</t>
<t tx="ekr.20040713132127.8">
(put 'igrep-read-options 'variable-interactive
     "XAlways prompt for options? (t or nil): ")

</t>
<t tx="ekr.20040713132127.9">(defvar igrep-read-multiple-files nil
  "*If non-nil, `\\[igrep]' always prompts for multiple-files;
otherwise, it only prompts when 2 or 3 `C-u's are given as a prefix arg.")</t>
<t tx="ekr.20040713132127.10">
(put 'igrep-read-multiple-files 'variable-interactive
     "XAlways prompt for multiple files? (t or nil): ")

</t>
<t tx="ekr.20040713132127.11">(defvar igrep-expression-default 'current-word
  "*If non-nil, a function that returns a default EXPRESSION for `\\[igrep]'.
The function is called with no arguments and should return a string (or nil).

A different function can be specified for any particular mode by specifying
a value for that `major-mode' property; for example:
	(put 'igrep-expression-default 'dired-mode
	     'igrep-dired-file-current-word)")</t>
<t tx="ekr.20040713132127.12">
(put 'igrep-expression-default 'variable-interactive
     "SProvide a default expression? (function or nil): ")
(put 'igrep-expression-default 'dired-mode
     'igrep-dired-file-current-word)

</t>
<t tx="ekr.20040713132127.13">(defvar igrep-files-default 'igrep-buffer-file-name-pattern
  "*If non-nil, a function that returns the default FILES for `\\[igrep]'.
The function is called with no arguments and should return a string,
or a list of strings (or nil).

A different function can be specified for any particular mode by specifying
a value for that `major-mode' property; for example:
	(put 'igrep-files-default 'dired-mode
	     'igrep-dired-directory-file-pattern)")</t>
<t tx="ekr.20040713132127.14">
(put 'igrep-files-default 'variable-interactive
     "SProvide a default file pattern? (function or nil): ")
(put 'igrep-files-default 'dired-mode
     'igrep-dired-directory-file-pattern)

</t>
<t tx="ekr.20040713132127.15">(defvar igrep-verbose-prompts t
  "*If t, `\\[igrep]' prompts for arguments verbosely;
if not t but non-nil, `\\[igrep]' prompts for arguments semi-verbosely;
if nil, `\\[igrep]' prompts for arguments tersely.")</t>
<t tx="ekr.20040713132127.16">
(put 'igrep-verbose-prompts 'variable-interactive
     "XPrompt verbosely? (t, 'semi, or nil): ")

</t>
<t tx="ekr.20040713132127.17">(defvar igrep-insert-default-key
  (if (&lt; emacs-major-version 20) "\C-c\C-e")
  "*The key used to insert the default argument in the minibuffer.
In Emacs 20, the default is available via the minibuffer history \
(\\&lt;minibuffer-local-map&gt;\\[next-history-element]).")</t>
<t tx="ekr.20040713132127.18">
(put 'igrep-insert-default-key 'variable-interactive
     "kSet key to insert the default `\\[igrep]' argument in the minibuffer: ")

</t>
<t tx="ekr.20040713132127.19">(defvar igrep-save-buffers 'query
  "*If t, `\\[igrep]' first saves each modified file buffer;
if not t but non-nil, `\\[igrep]' offers to save each modified file buffer.")</t>
<t tx="ekr.20040713132127.20">
(put 'igrep-save-buffers 'variable-interactive
     "XSave modified buffers? (t, 'query, or nil): ")


;;; User variables:

</t>
<t tx="ekr.20040713132127.21">(defvar igrep-null-device
  (cond ((boundp 'grep-null-device) grep-null-device) ; Emacs 19
	((boundp 'null-device) null-device)))</t>
<t tx="ekr.20040713132127.22"> ; Emacs 20

</t>
<t tx="ekr.20040713132127.23">(defvar igrep-program "grep"
  "The default program run by `\\[igrep]' and `\\[igrep-find]'.
It must accept a `grep` expression argument and one or more file names, plus
the \"-n\" option.
If nil, `\\[igrep]' prompts for the program to run.")</t>
<t tx="ekr.20040713132127.24">(defvar igrep-expression-option
  (if (equal (call-process igrep-program nil nil nil
			   "-e" "foo" igrep-null-device)
	     1)
      "-e")
  "If non-nil, the option used to specify the EXPRESSION argument to `\\[igrep]',
to protect an initial `-' from option processing.")</t>
<t tx="ekr.20040713132127.25">(defvar igrep-program-table		; referenced by igrep-use-zgrep
  (let ((exec-directories exec-path)
	(program-obarray (make-vector 11 0)))
    (while exec-directories
      (if (and (car exec-directories)
	       (file-directory-p (car exec-directories))
	       (file-readable-p (car exec-directories)))
	  (let ((grep-programs
		 (directory-files (car exec-directories)
				  nil "grep\\(\\.exe\\)?\\'")))
	    (while grep-programs
	      ;; Check `(file-executable-p (car grep-programs))'?
	      (if (save-match-data
		    (string-match "\\.exe\\'" (car grep-programs)))
		  (intern (substring (car grep-programs) 0 -4) program-obarray)
		(intern (car grep-programs) program-obarray))
	      (setq grep-programs (cdr grep-programs)))))
      (setq exec-directories (cdr exec-directories)))
    program-obarray)
  "An obarray of available `grep` programs, passed by `igrep-read-program'
to `completing-read' when `igrep-program' is nil.")</t>
<t tx="ekr.20040713132127.26">(defvar igrep-use-zgrep
  (if (intern-soft "zgrep" igrep-program-table)
      'files)
  "If t, `\\[igrep]' searches files using the GNU (gzip) `zPROGRAM` script;
If not t but non-nil, `\\[igrep]' searches compressed FILES using `zPROGRAM`;
if nil, `\\[igrep]' searches files with `PROGRAM`.")</t>
<t tx="ekr.20040713132127.27">(defvar igrep-find nil
  "If non-nil, `\\[igrep]' searches directories using `find`.
See `igrep-find'.")</t>
<t tx="ekr.20040713132127.28">(defvar igrep-find-program "find"
  "The program run by `\\[igrep-find]'.")</t>
<t tx="ekr.20040713132127.29">(defvar igrep-find-prune-clause
  (if (equal (call-process igrep-find-program nil nil nil
			   igrep-null-device "-prune")
	     0)
      (format "-type d %s -name RCS -o -name CVS -o -name SCCS %s"
	      (shell-quote-argument "(")
	      (shell-quote-argument ")")))
  "The `find` clause used to prune directories, or nil;
see `igrep-find'.")</t>
<t tx="ekr.20040713132127.30">(defvar igrep-find-file-clause
  (format "-type f %s -name %s %s -name %s %s -name %s" ; -type l
	  (shell-quote-argument "!")
	  (shell-quote-argument "*~")	; Emacs backup
	  (shell-quote-argument "!")
	  (shell-quote-argument "*,v")	; RCS file
	  (shell-quote-argument "!")
	  (shell-quote-argument "s.*"))	; SCCS file
  "The `find` clause used to filter files passed to `grep`, or nil;
see `igrep-find'.")</t>
<t tx="ekr.20040713132127.31">(defvar igrep-find-use-xargs
  (if (equal (call-process igrep-find-program nil nil nil
			   igrep-null-device "-print0")
	     0)
      'gnu)
  "If `gnu', `\\[igrep-find]' executes
	`find ... -print0 | xargs -0 -e grep ...`;
if not `gnu' but non-nil, `\\[igrep-find]' executes
	`find ... -print | xargs -e grep ...`;
if nil, `\\[igrep-find]' executes
	`find ... -exec grep ...`.")</t>
<t tx="ekr.20040713132127.32">(defvar igrep-program-default "grep"
  "The default `grep` program, passed by `igrep-read-program'
to `completing-read' when `igrep-program' is nil.")</t>
<t tx="ekr.20040713132127.33">


;;; Internal variables:

</t>
<t tx="ekr.20040713132127.34">(defvar igrep-expression-history '()
  "The minibuffer history list for `\\[igrep]'s EXPRESSION argument.")</t>
<t tx="ekr.20040713132127.35">(defvar igrep-files-history '()
  "The minibuffer history list for `\\[igrep]'s FILES argument.")</t>
<t tx="ekr.20040713132127.36">


;;; Commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.37">(defun igrep-insinuate (&amp;optional override)
  "Define `grep' aliases for the corresponding `igrep' commands.
With a prefix arg, override the current `grep` command definitions."
  (interactive "P")
  (if override
      (defalias 'grep 'igrep)
    (defadvice grep (around igrep-interactive first (&amp;rest command-args)
			    activate)
      "If called interactively, use the `\\[igrep]' interface instead,
where COMMAND-ARGS is (PROGRAM EXPRESSION FILES [OPTIONS]);
if called programmatically, COMMAND-ARGS is still (COMMAND)."
      (interactive (igrep-read-args))
      (if (interactive-p)
	  (apply 'igrep command-args)
	ad-do-it)))
  (if (or (not (fboundp 'grep-find))
	  override)
      (defalias 'grep-find 'igrep-find))
  (if (or (not (fboundp 'dired-do-grep))
	  override)
      (defalias 'dired-do-grep 'dired-do-igrep))
  (if (or (not (fboundp 'dired-do-grep-find))
	  override)
      (defalias 'dired-do-grep-find 'dired-do-igrep-find))
  (if (or (not (fboundp 'Buffer-menu-grep))
	  override)
      (defalias 'Buffer-menu-grep 'Buffer-menu-igrep)))</t>
<t tx="ekr.20040713132127.38">

;;;###autoload
</t>
<t tx="ekr.20040713132127.39">(defun igrep (program expression files &amp;optional options)
  "*Run `grep` PROGRAM to match EXPRESSION in FILES.
The output is displayed in the *igrep* buffer, which `\\[next-error]' and
`\\[compile-goto-error]' parse to find each line of matched text.

PROGRAM may be nil, in which case it defaults to `igrep-program'.

EXPRESSION is automatically quoted by `shell-quote-argument'.

FILES is either a file name pattern (expanded by the shell named by
`shell-file-name') or a list of file name patterns.

Optional OPTIONS is also passed to PROGRAM; it defaults to `igrep-options'.

If a prefix argument \
\(`\\[universal-argument]') \
is given when called interactively,
or if `igrep-read-options' is set, OPTIONS is read from the minibuffer.

If two prefix arguments \
\(`\\[universal-argument] \\[universal-argument]') \
are given when called interactively,
or if `igrep-read-multiple-files' is set, FILES is read from the minibuffer
multiple times.

If three prefix arguments \
\(`\\[universal-argument] \\[universal-argument] \\[universal-argument]') \
are given when called interactively,
or if `igrep-read-options' and `igrep-read-multiple-files' are set,
OPTIONS is read and FILES is read multiple times.

If `igrep-find' is non-nil, the directory or directories
containing FILES is recursively searched for files whose name matches
the file name component of FILES (and whose contents match EXPRESSION)."
  (interactive
   (igrep-read-args))
  (if (null program)
      (setq program (or igrep-program "grep")))
  (if (null options)
      (setq options igrep-options))
  (if (not (listp files))		; (stringp files)
      (setq files (list files)))
  (if (and (member ?~ (mapcar 'string-to-char files))
	   (save-match-data
	     (string-match "\\`[rj]?sh\\(\\.exe\\)?\\'"
			   (file-name-nondirectory shell-file-name))))
      ;; (restricted, job-control, or standard) Bourne shell doesn't expand ~:
      (setq files
	    (mapcar 'expand-file-name files)))
  (let* ((use-zgrep (cond ((eq igrep-use-zgrep t))
			  (igrep-use-zgrep
			   (let ((files files)
				 (compressed-p nil))
			     (while (and files (not compressed-p))
			       (if (save-match-data
				     (string-match "\\.g?[zZ]\\'" (car files)))
				   (setq compressed-p t))
			       (setq files (cdr files)))
			     compressed-p))
			  (t nil)))
	 (command (format "%s -n %s %s %s %s %s"
			  (if (and use-zgrep
				   (save-match-data
				     (not (string-match "\\`z" program))))
			      (setq program (concat "z" program))
			    program)
			  (or options "")
			  (or igrep-expression-option
			      (progn
				(if (save-match-data
				      (string-match "\\`-" expression))
				    (setq expression (concat "\\" expression)))
				""))
			  (shell-quote-argument expression)
			  (if igrep-find
			      (if igrep-find-use-xargs
				  ""
				(shell-quote-argument "{}"))
			    (mapconcat (lambda (file)
					 (let ((dir (file-name-directory file)))
					   (if dir
					       (expand-file-name
						(file-name-nondirectory file)
						(shell-quote-argument dir))
					     file)))
				       files " "))
			  igrep-null-device)))
    (if igrep-find
	(setq command
	      (igrep-format-find-command command files)))
    (cond ((eq igrep-save-buffers t) (save-some-buffers t))
	  (igrep-save-buffers (save-some-buffers)))
    (compile-internal command (format "No more %s matches" program)
		      "igrep" nil grep-regexp-alist)))</t>
<t tx="ekr.20040713132127.40">

;; Analogue commands:

(defmacro igrep-define (analogue-command &amp;rest igrep-bindings)
  "Define ANALOGUE-COMMAND as an `igrep' analogue command.
Optional (VARIABLE VALUE) arguments specify temporary bindings for the command."
;;;  (interactive "SCommand: ") ; C-u =&gt; read bindings?
  (let ((analogue-program (symbol-name analogue-command)))
    `(defun ,analogue-command (&amp;rest igrep-args)
       ,(format "*Run `%s` via `\\[igrep]'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
		analogue-program)
       (interactive
	(let ((igrep-program (if igrep-program ,analogue-program))
	      (igrep-program-default ,analogue-program))
	  (igrep-read-args)))
       (let (,@ igrep-bindings)
	 (apply 'igrep
		(cond ((interactive-p) (car igrep-args))
		      ((car igrep-args))
		      (t ,analogue-program))
		(cdr igrep-args))))))

(igrep-define egrep)
(igrep-define fgrep)
(igrep-define agrep
  (igrep-use-zgrep nil)
  (igrep-expression-option "-e"))


;; Recursive (`find`) commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.41">(defun igrep-find (&amp;rest igrep-args)
  "*Run `grep` via `find`; see `igrep' and `igrep-find'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
  (interactive
   (let ((igrep-find t))
     (igrep-read-args)))
  (let ((igrep-find t))
    (apply 'igrep igrep-args)))</t>
<t tx="ekr.20040713132127.42">

;; Analogue recursive (`find`) commands:

(defmacro igrep-find-define (analogue-command &amp;rest igrep-bindings)
  "Define ANALOGUE-COMMAND-find as an `igrep' analogue `find` command.
Optional (VARIABLE VALUE) arguments specify temporary bindings for the command."
;;;  (interactive "SCommand: ") ; C-u =&gt; read bindings?
  (let ((analogue-program (symbol-name analogue-command)))
    (setq analogue-command
	  (intern (format "%s-find" analogue-command)))
    `(defun ,analogue-command (&amp;rest igrep-args)
       ,(format "*Run `%s` via `\\[igrep-find]'.
All arguments (including prefix arguments, when called interactively)
are handled by `igrep'."
		analogue-program)
       (interactive
	(let ((igrep-program (if igrep-program ,analogue-program))
	      (igrep-program-default ,analogue-program)
	      (igrep-find t))
	  (igrep-read-args)))
       (let (,@ igrep-bindings)
	 (apply 'igrep-find
		(cond ((interactive-p) (car igrep-args))
		      ((car igrep-args))
		      (t ,analogue-program))
		(cdr igrep-args))))))

(igrep-find-define egrep)
(igrep-find-define fgrep)
(igrep-find-define agrep
  (igrep-use-zgrep nil)
  (igrep-expression-option "-e"))

;;;###autoload
</t>
<t tx="ekr.20040713132127.43">(defun igrep-visited-files (program expression &amp;optional options)
  "*Run `grep` PROGRAM to match EXPRESSION (with optional OPTIONS) \
on all visited files.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args (igrep-read-args 'no-files)))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     igrep-args))
  (igrep program expression
	 (let ((directory-abbrev-alist
		(cons (cons (regexp-quote (expand-file-name default-directory))
			    "./")	; or even ""
		      directory-abbrev-alist)))
	   (mapcar 'abbreviate-file-name
		   (apply 'nconc
			  (mapcar (lambda (buffer)
				    (let ((file (buffer-file-name buffer)))
				      (if (and file
					       (cond ((featurep 'ange-ftp)
						      (not (ange-ftp-ftp-name file)))
						     ((featurep 'efs)
						      (not (efs-ftp-path file)))
						     (t t))
					       ;; (file-exists-p file)
					       )
					  (list file))))
				  (buffer-list)))))
	 options))</t>
<t tx="ekr.20040713132127.44">


;; Dired commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.45">(defun dired-do-igrep (program expression &amp;optional options arg)
  "*Run `grep` on the marked (or next prefix ARG) files.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args
	  (let ((current-prefix-arg nil))
	    (igrep-read-args t))))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     ;; Append ARG:
     (nconc igrep-args (list current-prefix-arg))))
  (igrep program
	 expression
	 (funcall (cond ((fboundp 'dired-get-marked-files) ; GNU Emacs
			 'dired-get-marked-files)
			((fboundp 'dired-mark-get-files) ; XEmacs
			 'dired-mark-get-files))
		  t arg)
	 options))</t>
<t tx="ekr.20040713132127.46">



;; Dired recursive (`find`) commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.47">(defun dired-do-igrep-find (program expression &amp;optional options arg)
  "*Run `grep` on the marked (or next prefix ARG) directories.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args
	  (let ((current-prefix-arg nil)
		(igrep-find t))
	    (igrep-read-args t))))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     ;; Append ARG:
     (nconc igrep-args (list current-prefix-arg))))
  (let ((igrep-find t))
    (dired-do-igrep program expression options arg)))</t>
<t tx="ekr.20040713132127.48">



;; Buffer menu commands:

;;;###autoload
</t>
<t tx="ekr.20040713132127.49">(defun Buffer-menu-igrep (program expression &amp;optional options)
  "*Run `grep` on the files visited in buffers marked with '&gt;'.
See `\\[igrep]'."
  (interactive
   (let ((igrep-args (igrep-read-args 'no-files)))
     ;; Delete FILES:
     (setcdr (nthcdr 1 igrep-args) (nthcdr 3 igrep-args))
     igrep-args))
  ;; See Buffer-menu-select:
  (let ((marked-files '())
	marked-buffer
	file)
    (goto-char (point-min))
    (while (search-forward "\n&gt;" nil t)
      (setq marked-buffer (Buffer-menu-buffer t)
	    file (buffer-file-name marked-buffer))
      (if (and file
	       ;; local:
	       (cond ((featurep 'ange-ftp)
		      (not (ange-ftp-ftp-name file)))
		     ((featurep 'efs)
		      (not (efs-ftp-path file)))
		     (t t)))
	  (setq marked-files (cons file marked-files)))
;;;    (let ((buffer-read-only nil))
;;;      (delete-char -1)
;;;      (insert ?\ ))
      )
    (setq marked-files (nreverse marked-files))
    (igrep program expression
	   (let ((directory-abbrev-alist
		  (cons (cons (regexp-quote (expand-file-name default-directory))
			      "./")	; or even ""
			directory-abbrev-alist)))
	     (mapcar 'abbreviate-file-name marked-files))
	   options)))</t>
<t tx="ekr.20040713132127.50">


;;; User functions:

</t>
<t tx="ekr.20040713132127.51">(defun igrep-dired-file-current-word ()
  "Return the current word in the file on this line, if it is visible;
else, return the file name on this line, if there is one;
otherwise, return the current word."
  (let* ((dired-file
	  (dired-get-filename t t))
	 (dired-file-buffer
	  (if dired-file
	      (get-file-buffer (expand-file-name dired-file))))
	 (dired-file-buffer-window
	  (if dired-file-buffer
	      (get-buffer-window dired-file-buffer))))
    (cond (dired-file-buffer-window (save-excursion
				      (set-buffer dired-file-buffer)
				      (current-word)))
	  (dired-file)
	  (t (current-word)))))</t>
<t tx="ekr.20040713132127.52">(defun igrep-buffer-file-name-pattern ()
  "Return a shell file name pattern based on `buffer-file-name', or \"*\"."
  ;; (Based on other-possibly-interesting-files in ~/as-is/unix.el, by
  ;; Wolfgang Rupprecht &lt;wolfgang@mgm.mit.edu&gt;.)
  (if buffer-file-name
      (let ((file-name (file-name-nondirectory buffer-file-name)))
	(concat "*"
		(save-match-data
		  (if (string-match "\\.[^.]+\\(\\.g?[zZ]\\)?\\'"
				    file-name)
		      (substring file-name (match-beginning 0)
				 (match-end 0))))))
    "*"))</t>
<t tx="ekr.20040713132127.53">(defun igrep-dired-directory-file-pattern ()
"Return a shell file name pattern based on `dired-directory', or \"*\"."
  (cond ((stringp dired-directory)
	 (if (file-directory-p dired-directory)
	     "*"
	   (file-name-nondirectory dired-directory))) ; wildcard
	((consp dired-directory)	; (DIR FILE ...)
	 (mapconcat 'identity (cdr dired-directory) " "))))</t>
<t tx="ekr.20040713132127.54">


;;; Utilities:

(defsubst igrep-file-directory (name)
  "Return the directory component of NAME, or \".\" if it has no
directory component."
  (directory-file-name (or (file-name-directory name)
			   (file-name-as-directory "."))))

(defsubst igrep-file-pattern (name)
  "Return the file component of NAME, or \"*\" if it has no file component."
  (let ((pattern (file-name-nondirectory name)))
       (if (string= pattern "")
	   "*"
	 pattern)))

</t>
<t tx="ekr.20040713132127.55">(defun igrep-format-find-command (command files)
  "Format `grep` COMMAND to be invoked via `find` on FILES."
  (let ((directories '())
	(patterns '()))
    (while files
      (let ((dir (igrep-file-directory (car files)))
	    (pat (igrep-file-pattern (car files))))
	(if (and (not (string= dir "."))
		 (file-symlink-p dir))
	    (setq dir (concat dir "/.")))
	(if (not (member dir directories))
	    (setq directories (cons dir directories)))
	(cond ((equal pat "*")
	       (setq patterns t))
	      ((and (listp patterns)
		    (not (member pat patterns)))
	       (setq patterns (cons pat patterns)))))
      (setq files (cdr files)))
    (format (cond ((eq igrep-find-use-xargs 'gnu)
		   ;; | \\\n
		   "%s %s %s %s %s -print0 | xargs -0 -e %s")
		  (igrep-find-use-xargs
		   ;; | \\\n
		   "%s %s %s %s %s -print | xargs -e %s")
		  (t
		   "%s %s %s %s %s -exec %s %s"))
	    igrep-find-program
	    (mapconcat 'shell-quote-argument (nreverse directories)
		       " ")
	    (if igrep-find-prune-clause
		(format "%s -prune -o" igrep-find-prune-clause)
	      "")
	    (or igrep-find-file-clause "")
	    (if (listp patterns)
		(if (cdr patterns)	; (&gt; (length patterns) 1)
		    (format "%s %s %s"
			    (shell-quote-argument "(")
			    (mapconcat (lambda (pat)
					 (format "-name %s"
						 (shell-quote-argument pat)))
				       (nreverse patterns)
				       " -o ")
			    (shell-quote-argument ")"))
		  (format "-name %s" (shell-quote-argument (car patterns))))
	      "")
	    command
	    (shell-quote-argument ";")
	    )))</t>
<t tx="ekr.20040713132127.56">

(defmacro igrep-default-arg (variable)
  "Return the default arg based on VARIABLE."
  `(if ,variable
       (cond ((get (quote ,variable) major-mode)
	      (funcall (get (quote ,variable) major-mode)))
	     (t (funcall ,variable)))))

</t>
<t tx="ekr.20040713132127.57">(defun igrep-default-expression ()
  (igrep-default-arg igrep-expression-default))</t>
<t tx="ekr.20040713132127.58">(defun igrep-default-files ()
  (let* ((dired-subdirectory (if (eq major-mode 'dired-mode)
				 (dired-current-directory t)))
	 (default-files (igrep-default-arg igrep-files-default)))
    (if (not (listp default-files))	; stringp
	(setq default-files (list default-files)))
    (if dired-subdirectory
	(mapcar (lambda (file)
		  (concat dired-subdirectory file))
		default-files)
      default-files)))</t>
<t tx="ekr.20040713132127.59">

(defsubst igrep-prefix (prefix string &amp;rest strings)
  "If PREFIX is non-nil or any STRINGS are specified, concatenate them
before and after STRING; otherwise, return the STRING."
  (if (or prefix strings)
      (apply 'concat prefix string strings)
    string))

</t>
<t tx="ekr.20040713132127.60">(defun igrep-read-args (&amp;optional no-files)
  "Read and return a list: (PROGRAM EXPRESSION FILES OPTIONS).
If NO-FILES is non-nil, then FILES is not read and nil is returned
in its place."
  (let* ((pre-prefix (if (and igrep-find (eq igrep-verbose-prompts t))
			 "[find] "))
	 (program
	  (igrep-read-program pre-prefix))
	 (prefix (if (and program (eq igrep-verbose-prompts t))
		     (igrep-prefix pre-prefix program " ")
		   pre-prefix))
	 (options
	  (igrep-read-options prefix))
	 (post-prefix (if (and options (eq igrep-verbose-prompts t))
			    (igrep-prefix prefix options " ")
			  prefix)))
    (list program
	  (igrep-read-expression post-prefix)
	  (if (not no-files)
	      (igrep-read-files post-prefix))
	  options)))</t>
<t tx="ekr.20040713132127.61">(defun igrep-read-program (&amp;optional prompt-prefix)
  "If `igrep-program' is nil, read and return a program name from the
minibuffer; otherwise, return `igrep-program'.
Optional PROMPT-PREFIX is prepended to the \"Program: \" prompt."
  (or igrep-program
      (let ((prompt "Program: "))
	(completing-read (igrep-prefix prompt-prefix prompt) igrep-program-table
			 nil t igrep-program-default))))</t>
<t tx="ekr.20040713132127.62">(defun igrep-read-options (&amp;optional prompt-prefix)
  "If `current-prefix-arg' is '(4) or '(64), read and return an options
string from the minibuffer; otherwise, return `igrep-options'.
Optional PROMPT-PREFIX is prepended to the \"Options: \" prompt."
  (if (or igrep-read-options
	  (and (consp current-prefix-arg)
	       (memq (prefix-numeric-value current-prefix-arg)
		     '(4 64))))
      (let ((prompt "Options: "))
	(read-string (igrep-prefix prompt-prefix prompt)
		     (or igrep-options "-")))
    igrep-options))</t>
<t tx="ekr.20040713132127.63">(defun igrep-read-expression (&amp;optional prompt-prefix)
  "Read and return a `grep` expression string from the minibuffer.
Optional PROMPT-PREFIX is prepended to the \"Expression: \" prompt."
  (if igrep-insert-default-key
      (define-key minibuffer-local-map igrep-insert-default-key
	'igrep-insert-default-expression))
  (let* ((default-expression (igrep-default-expression))
	 (prompt (igrep-prefix prompt-prefix
			       (if default-expression
				   (format "Expression [default: %s]: "
					   default-expression)
				 "Expression: ")))
	 (expression (cond ((and (featurep 'xemacs) (emacs-version&gt;= 21 4))
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history
						  nil ; ABBREV-TABLE
						  default-expression))
			   ((and (not (featurep 'xemacs))
				 (&gt;= emacs-major-version 20))
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history
						  default-expression))
			   (t
			    (read-from-minibuffer prompt
						  nil nil nil
						  'igrep-expression-history)))))
    (if (equal expression "")
	(progn
	  (or (equal default-expression (car igrep-expression-history))
	      (setq igrep-expression-history
		    (cons default-expression igrep-expression-history)))
	  default-expression)
      expression)))</t>
<t tx="ekr.20040713132127.64">(defun igrep-insert-default-expression (&amp;optional clear-minibuffer)
  "*Insert the default expression in the minibuffer.
If a prefix argument is specified, clear the minibuffer contents first."
  (interactive "P")
  (if clear-minibuffer
      (delete-region (if (fboundp 'minibuffer-prompt-end) ; Emacs 21
			 (minibuffer-prompt-end)
		       (point-min))
		     (point-max)))
  (insert (or (save-excursion
		(set-buffer (window-buffer minibuffer-scroll-window))
		(igrep-default-expression))
	      "")))</t>
<t tx="ekr.20040713132127.65">(defun igrep-insert-default-files (&amp;optional clear-minibuffer)
  "*Insert the default files in the minibuffer.
If a prefix argument is specified, clear the minibuffer contents first."
  (interactive "P")
  (if clear-minibuffer
      (delete-region (if (fboundp 'minibuffer-prompt-end) ; Emacs 21
			 (minibuffer-prompt-end)
		       (point-min))
		     (point-max)))
  (insert (mapconcat 'identity
		     (save-excursion
		       (set-buffer (window-buffer minibuffer-scroll-window))
		       (igrep-default-files))
		     " ")))</t>
<t tx="ekr.20040713132127.66">

(defsubst igrep-default-key (command &amp;optional keymap key)
  "Return the key bound to COMMAND in KEYMAP, preferably KEY."
  (if (null keymap)
      (setq keymap (current-global-map)))
  (if (and key
	   (eq (lookup-key keymap key) command))
      key
    (where-is-internal command keymap t)))

</t>
<t tx="ekr.20040713132127.67">(defun igrep-read-files (&amp;optional prompt-prefix)
  "Read and return a file name pattern from the minibuffer.
If `current-prefix-arg' is '(16) or '(64), read multiple file name
patterns and return them in a list.  Optional PROMPT-PREFIX is
prepended to the \"File(s): \" prompt."
  (let* ((default-files (igrep-default-files))
	 (default-files-string (mapconcat 'identity default-files " "))
	 (insert-default-directory nil)	; use relative path names
	 (file (igrep-read-file-name
		(igrep-prefix prompt-prefix
			      (if default-files
				  (format "File(s) [default: %s]: "
					  default-files-string)
				"File(s): "))
		nil default-files-string nil nil
		'igrep-files-history))
	 (files (cond ((equal file default-files-string)
		       (setq file default-files))
		      ((not (listp file))
		       (setq file (list file))))))
    (if (or igrep-read-multiple-files
	    (and (consp current-prefix-arg)
		 (memq (prefix-numeric-value current-prefix-arg)
		       '(16 64))))
	(let ((prompt
	       (igrep-prefix prompt-prefix
			     (if igrep-verbose-prompts
				 (format "File(s): [Type `%s' when done] "
					 (key-description
					  (igrep-default-key 'exit-minibuffer
							     minibuffer-local-completion-map
							     "\r")))
			       "File(s): "))))
	  (while (not (string= (setq file
				     (igrep-read-file-name prompt
							   nil "" nil nil
							   'igrep-files-history))
			       ""))
	    (setq files (cons file files)))
	  (nreverse files))
      files)))</t>
<t tx="ekr.20040713132127.68">(defun igrep-read-file-name (prompt
  &amp;optional directory default existing initial history)
  "Just like `read-file-name', but with optional HISTORY.
Also: convert DIRECTORY to DIRECTORY/* file name pattern."
  (if igrep-insert-default-key
      (define-key minibuffer-local-completion-map igrep-insert-default-key
	'igrep-insert-default-files))
  (let ((file-name
	 (if history
	     (let ((file-name-history (symbol-value history)))
	       (prog1 (read-file-name prompt directory default existing initial)
		 (set history file-name-history)))
	   (read-file-name prompt directory default existing initial))))
    (if (and (not (string-equal file-name ""))
	     (file-directory-p file-name))
	(expand-file-name "*" file-name)
      file-name)))</t>
<t tx="ekr.20040713132127.69">

;;; Local Variables:
;;; eval: (put 'igrep-define 'lisp-indent-hook 1)
;;; eval: (put 'igrep-find-define 'lisp-indent-hook 1)
;;; End:

;;;; igrep.el ends here
</t>
<t tx="ekr.20040713133131">; -&gt; #

'x --&gt; x (??)

"multilline comment" --&gt; """multilline comment"""

strip parens from cond, etc.</t>
<t tx="ekr.20040713133131.1">defFun -&gt; def

lambda -&gt; ?

cond -&gt; if, elif, ... else

prog, progn -&gt; while

defvar x y --&gt; x = y  (or self.x = y) ??</t>
<t tx="ekr.20040713133131.2">(if (equal (call-process igrep-program nil nil nil
			   "-e" "foo" igrep-null-device)
	     1)
      "-e")

if (&lt; emacs-major-version 20) "\C-c\C-e")  -&gt; if &lt;cond&gt;: &lt;val&gt;

(&lt; a b) --&gt; a &lt; b

(x args) --&gt; x(args)</t>
<t tx="ekr.20040713144036">class elisp2pyClass:
    
    """A class to convert elisp programs into Python syntax."""
    
    @others</t>
<t tx="ekr.20040713144036.1">def __init__ (self,c,p,*args,**keys):
    
    self.c = c
    self.p = p
    self.tabwidth = 4

    &lt;&lt; define elisp constants &gt;&gt;
    &lt;&lt; define elisp statements &gt;&gt;
    &lt;&lt; define elisp functions &gt;&gt;
    
    self.allStatements = list(self.statements)
    self.allStatements.extend(self.functions)
    
    &lt;&lt; define code gen dispatch table &gt;&gt;</t>
<t tx="ekr.20040713144336"></t>
<t tx="ekr.20040713144926">def tokenize (self,s):
    
    e = self
    name1 = string.letters + '_'
    result = []
    if not s.strip():
        return result

    i = 0 ; n = len(s) ; progress = -1
    while i &lt; n:
        assert(i &gt; progress)
        progress = i
        ch = s[i]
        if ch == '\r':
            i += 1
        elif ch in "@'()[]{}&lt;&gt;\n": # Handle single-quote here?
            result.append(tok(ch,ch))
            i += 1
        elif ch in "\ \t":
            j = g.skip_ws(s,i) # Doesn't handle ff, so ff loops.
            ws = s[i:j]
            result.append(tok("ws",ws))
            i = j
        elif ch == '\f':
            result.append(tok("form-feed",'\f'))
            i += 1
        elif ch == '"':
            j = e.skipString(s,i)
            val = s[i:j]
            result.append(tok("string",val))
            i = j
        elif ch in name1:
            j = g.skip_id(s,i,chars='-*') # '-*' valid in elisp.
            val = s[i:j]
            result.append(tok("id",val))
            i = j
        elif ch in string.digits:
            j,value = g.skip_long(s,i)
            val = s[i:j]
            result.append(tok("number",val))
            i = j
        elif ch == ';':
            j = g.skip_to_end_of_line(s,i)
            val = s[i:j]
            result.append(tok("comment",val))
            i = j
        else:
            result.append(tok("misc",ch))
            i += 1
            
    return result</t>
<t tx="ekr.20040713144926.1"></t>
<t tx="ekr.20040713144926.2"></t>
<t tx="ekr.20040713144926.3"></t>
<t tx="ekr.20040713144926.4"></t>
<t tx="ekr.20040713150037">class tok:
    
    """ A class representing an elisp or python token"""
    
    @others</t>
<t tx="ekr.20040713150037.1">def __init__ (self,kind,val="",parseTree=None):
    
    self.kind = kind
    self.val = val
    self.parseTree = parseTree</t>
<t tx="ekr.20040713150314.1">def replaceAll (self,tokens,findKind,changeTok):
    
    self = e

    result = []
    for token in tokens:
        if token.kind == findKind:
            result.append(changeTok.copy())
        else:
            result.append(token)</t>
<t tx="ekr.20040713150712">def copy (self,token):
    
    return tok(self.kind,self.val)</t>
<t tx="ekr.20040713150856.1"></t>
<t tx="ekr.20040713150856.8">@ These scanners all call g.scanError() directly or indirectly, so they will call g.es() if they find an error.  g.scanError() also bumps c.tangleCommands.errors, which is harmless if we aren't tangling, and useful if we are.

These routines are called by the Import routines and the Tangle routines.
</t>
<t tx="ekr.20040713150856.9"># Scans past a block comment (an old_style C comment).

def skip_block_comment (s,i):

    assert(g.match(s,i,"/*"))
    j = i ; i += 2 ; n = len(s)
    
    k = string.find(s,"*/",i)
    if k == -1:
        g.scanError("Run on block comment: " + s[j:i])
        return n
    else: return k + 2</t>
<t tx="ekr.20040713150856.10">@ This code is called only from the import logic, so we are allowed to try some tricks.  In particular, we assume all braces are matched in #if blocks.
@c

def skip_braces(s,i):

    """Skips from the opening to the matching brace.
    
    If no matching is found i is set to len(s)"""

    # start = g.get_line(s,i)
    assert(g.match(s,i,'{'))
    level = 0 ; n = len(s)
    while i &lt; n:
        c = s[i]
        if c == '{':
            level += 1 ; i += 1
        elif c == '}':
            level -= 1
            if level &lt;= 0: return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,'//'): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,'/*'): i = g.skip_block_comment(s,i)
        # 7/29/02: be more careful handling conditional code.
        elif g.match_word(s,i,"#if") or g.match_word(s,i,"#ifdef") or g.match_word(s,i,"#ifndef"):
            i,delta = g.skip_pp_if(s,i)
            level += delta
        else: i += 1
    return i
</t>
<t tx="ekr.20040713150856.12">def skip_parens(s,i):

    """Skips from the opening ( to the matching ).
    
    If no matching is found i is set to len(s)"""

    level = 0 ; n = len(s)
    assert(g.match(s,i,'('))
    while i &lt; n:
        c = s[i]
        if c == '(':
            level += 1 ; i += 1
        elif c == ')':
            level -= 1
            if level &lt;= 0:  return i
            i += 1
        elif c == '\'' or c == '"': i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i</t>
<t tx="ekr.20040713150856.13">def skip_pascal_begin_end(s,i):

    """Skips from begin to matching end.
    If found, i points to the end. Otherwise, i &gt;= len(s)
    The end keyword matches begin, case, class, record, and try."""

    assert(g.match_c_word(s,i,"begin"))
    level = 1 ; i = g.skip_c_id(s,i) # Skip the opening begin.
    while i &lt; len(s):
        ch = s[i]
        if ch =='{' : i = g.skip_pascal_braces(s,i)
        elif ch =='"' or ch == '\'': i = g.skip_pascal_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_line(s,i)
        elif g.match(s,i,"(*"): i = g.skip_pascal_block_comment(s,i)
        elif g.match_c_word(s,i,"end"):
            level -= 1 ;
            if level == 0:
                # lines = s[i1:i+3] ; g.trace('\n' + lines + '\n')
                return i
            else: i = g.skip_c_id(s,i)
        elif g.is_c_id(ch):
            j = i ; i = g.skip_c_id(s,i) ; name = s[j:i]
            if name in ["begin", "case", "class", "record", "try"]:
                level += 1
        else: i += 1
    return i
</t>
<t tx="ekr.20040713150856.14"># Scans past a pascal comment delimited by (* and *).

def skip_pascal_block_comment(s,i):
    
    j = i
    assert(g.match(s,i,"(*"))
    i = string.find(s,"*)",i)
    if i &gt; -1: return i + 2
    else:
        g.scanError("Run on comment" + s[j:i])
        return len(s)</t>
<t tx="ekr.20040713150856.15">def skip_pascal_string(s,i):

    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')

    while i &lt; len(s):
        if s[i] == delim:
            return i + 1
        else: i += 1

    g.scanError("Run on string: " + s[j:i])
    return i</t>
<t tx="ekr.20040713150856.20">def skip_python_string(s,i):

    if g.match(s,i,"'''") or g.match(s,i,'"""'):
        j = i ; delim = s[i]*3 ; i += 3
        k = string.find(s,delim,i)
        if k &gt; -1: return k+3
        g.scanError("Run on triple quoted string: " + s[j:i])
        return len(s)
    else:
        return g.skip_string(s,i)</t>
<t tx="ekr.20040713150856.21">def skip_string(s,i):
    
    j = i ; delim = s[i] ; i += 1
    assert(delim == '"' or delim == '\'')
    
    n = len(s)
    while i &lt; n and s[i] != delim:
        if s[i] == '\\' : i += 2
        else: i += 1

    if i &gt;= n:
        g.scanError("Run on string: " + s[j:i])
    elif s[i] == delim:
        i += 1

    # g.trace(s[j:i])
    return i
</t>
<t tx="ekr.20040713150856.22"># Skips to the next semicolon that is not in a comment or a string.

def skip_to_semicolon(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c == ';': return i
        elif c == '\'' or c == '"' : i = g.skip_string(s,i)
        elif g.match(s,i,"//"): i = g.skip_to_end_of_line(s,i)
        elif g.match(s,i,"/*"): i = g.skip_block_comment(s,i)
        else: i += 1
    return i</t>
<t tx="ekr.20040713150856.24"></t>
<t tx="ekr.20040713150856.25"># Returns True if s[i] is preceded by an odd number of backslashes.

def escaped(s,i):

    count = 0
    while i-1 &gt;= 0 and s[i-1] == '\\':
        count += 1
        i -= 1
    return (count%2) == 1</t>
<t tx="ekr.20040713150856.26">def find_line_start(s,i):

    # bug fix: 11/2/02: change i to i+1 in rfind
    i = string.rfind(s,'\n',0,i+1) # Finds the highest index in the range.
    if i == -1: return 0
    else: return i + 1</t>
<t tx="ekr.20040713150856.27">def find_on_line(s,i,pattern):

    # j = g.skip_line(s,i) ; g.trace(s[i:j])
    j = string.find(s,'\n',i)
    if j == -1: j = len(s)
    k = string.find(s,pattern,i,j)
    if k &gt; -1: return k
    else: return None</t>
<t tx="ekr.20040713150856.28">def is_c_id(ch):

    return ch and (ch in string.ascii_letters or ch in string.digits or ch == '_')
</t>
<t tx="ekr.20040713150856.29">def is_nl(s,i):

    return i &lt; len(s) and (s[i] == '\n' or s[i] == '\r')</t>
<t tx="ekr.20040713150856.30"># We no longer require that the directive appear befor any @c directive or section definition.

def is_special(s,i,directive):

    """Return True if the body text contains the @ directive."""

    # j = g.skip_line(s,i) ; g.trace(s[i:j],':',directive)
    assert (directive and directive [0] == '@' )

    # 10/23/02: all directives except @others must start the line.
    skip_flag = directive in ("@others","@all")
    while i &lt; len(s):
        if g.match_word(s,i,directive):
            return True, i
        else:
            i = g.skip_line(s,i)
            if skip_flag:
                i = g.skip_ws(s,i)
    return False, -1</t>
<t tx="ekr.20040713150856.31">def is_ws(c):

    return c == '\t' or c == ' '
    
def is_ws_or_nl(s,i):

    return g.is_nl(s,i) or (i &lt; len(s) and g.is_ws(s[i]))</t>
<t tx="ekr.20040713150856.32"># Warning: this code makes no assumptions about what follows pattern.

def match(s,i,pattern):

    return s and pattern and string.find(s,pattern,i,i+len(pattern)) == i</t>
<t tx="ekr.20040713150856.33">def match_c_word (s,i,name):

    if name == None: return False
    n = len(name)
    if n == 0: return False
    return name == s[i:i+n] and (i+n == len(s) or not g.is_c_id(s[i+n]))</t>
<t tx="ekr.20040713150856.34">def match_ignoring_case(s1,s2):

    if s1 == None or s2 == None: return False
    return string.lower(s1) == string.lower(s2)</t>
<t tx="ekr.20040713150856.35">def match_word(s,i,pattern):

    if pattern == None: return False
    j = len(pattern)
    if j == 0: return False
    if string.find(s,pattern,i,i+j) != i:
        return False
    if i+j &gt;= len(s):
        return True
    c = s[i+j]
    return not (c in string.ascii_letters or c in string.digits or c == '_')</t>
<t tx="ekr.20040713150856.36">def skip_blank_lines(s,i):

    while i &lt; len(s):
        if g.is_nl(s,i) :
            i = g.skip_nl(s,i)
        elif g.is_ws(s[i]):
            j = g.skip_ws(s,i)
            if g.is_nl(s,j):
                i = j
            else: break
        else: break
    return i</t>
<t tx="ekr.20040713150856.37">def skip_c_id(s,i):

    n = len(s)
    while i &lt; n:
        c = s[i]
        if c in string.ascii_letters or c in string.digits or c == '_':
            i += 1
        else: break
    return i</t>
<t tx="ekr.20040713150856.38">def skip_id(s,i,chars=None):

    n = len(s)
    while i &lt; n:
        ch = s[i]
        if ch in string.ascii_letters or ch in string.digits or ch == '_':
            i += 1
        elif chars and ch in chars:
            i += 1
        else: break
    return i
</t>
<t tx="ekr.20040713150856.39">@ These methods skip to the next newline, regardless of whether the newline may be preceeded by a backslash. Consequently, they should be used only when we know that we are not in a preprocessor directive or string.
@c

def skip_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i + 1
        
def skip_to_end_of_line (s,i):

    i = string.find(s,'\n',i)
    if i == -1: return len(s)
    else: return i</t>
<t tx="ekr.20040713150856.40">def skip_long(s,i):
    
    """Scan s[i:] for a valid int.
    Return (i, val) or (i, None) if s[i] does not point at a number.
    """

    digits = string.digits
    val = 0
    i = g.skip_ws(s,i)
    n = len(s)
    if i &gt;= n or s[i] not in "+-" + digits:
        return i, None
    # Rewritten: 7/18/02.
    j = i
    if s[i] in '+-':    # whr allow sign if first digit
        i +=1
    while i &lt; n and s[i] in digits:
        i += 1
    try: # 4/24/03: There may be no digits, which would raise an exception.
        val = int(s[j:i])
        return i, val
    except:
        return i,None
</t>
<t tx="ekr.20040713150856.41">def skip_matching_delims(s,i,delim1,delim2):
    
    assert(g.match(s,i,delim1))

    i += len(delim1)
    k = string.find(s,delim2,i)
    if k == -1:
        return len(s)
    else:
        return k + len(delim2)</t>
<t tx="ekr.20040713150856.42"># We need this function because different systems have different end-of-line conventions.

def skip_nl (s,i):

    """Skips a single "logical" end-of-line character."""

    if g.match(s,i,"\r\n"): return i + 2
    elif g.match(s,i,'\n') or g.match(s,i,'\r'): return i + 1
    else: return i</t>
<t tx="ekr.20040713150856.43">def skip_non_ws (s,i):

    n = len(s)
    while i &lt; n and not g.is_ws(s[i]):
        i += 1
    return i</t>
<t tx="ekr.20040713150856.44"># Skips from the opening { to the matching }.

def skip_pascal_braces(s,i):

    # No constructs are recognized inside Pascal block comments!
    k = string.find(s,'}',i)
    if i == -1: return len(s)
    else: return k</t>
<t tx="ekr.20040713150856.45">def skip_to_char(s,i,ch):
    
    j = string.find(s,ch,i)
    if j == -1:
        return len(s),s[i:]
    else:
        return j,s[i:j]
</t>
<t tx="ekr.20040713150856.46">def skip_ws(s,i):

    n = len(s)
    while i &lt; n and g.is_ws(s[i]):
        i += 1
    return i
    
def skip_ws_and_nl(s,i):

    n = len(s)
    while i &lt; n and (g.is_ws(s[i]) or g.is_nl(s,i)):
        i += 1
    return i</t>
<t tx="ekr.20040713150856.47">def splitLines (s):
    
    """Split s into lines, preserving the number of lines and the ending of the last line."""
    
    if s:
        return s.splitlines(True) # This is a Python string function!
    else:
        return []

def joinLines (aList):
    
    return ''.join(aList)</t>
<t tx="ekr.20040713151556.1">def findMatchingBracket(self,tokens,i):

    tok1 = tokens[i] ; i += 1
    assert tok1.kind in "({["
   
    if   tok1.kind == '(': delim = ')'
    elif tok1.kind == '{': delim = '}'
    else:                  delim = ']'

    level = 1
    while i &lt; len(tokens):
        tok = tokens[i]
        # g.trace(level,delim,tok.kind)
        i += 1
        if tok.kind == tok1.kind:
            level += 1
        elif tok.kind == delim:
            level -= 1
            if level == 0: return i-1

    self.warning("%s not matched by %s" % (tok1.kind,delim))
    return None</t>
<t tx="ekr.20040713152318">def warning (self,message):
    
    print "Error:", message

def warning (self,message):
    
    print "Warning:", message
</t>
<t tx="ekr.20040713152809"></t>
<t tx="ekr.20040713154118">def skipString(self,s,i):

    # Skip the opening double quote.
    i1 = i
    ch = s[i]
    i += 1
    assert(ch == '"')

    while i &lt; len(s):
        ch = s[i]
        i += 1
        if ch == '"': return i
        elif ch == '\\': i += 1

    self.warning("run-on elisp string:", g.get_line(s[i1:]))
    return i</t>
<t tx="ekr.20040713160302">def findTokens(self,tokens,i,findTokens):
    
    """Search for a match with findTokens.
    Return i,i+len(findTokens) if found, or None,None otherwise."""

    e = self
    
    while i &lt; len(tokens):
        
        if e.matchTokens(tokens,i,findTokens):
            return i,i+len(findTokens)
        else:
            i += 1

    return None,None # Not found</t>
<t tx="ekr.20040713161629.1">def dump (self,tokens,verbose=2,heading=""):
    
    e = self ; p = e.p ; v2 = verbose &gt;= 2
    
    if verbose == 0:
        return
    
    if heading: printHeading(heading,char='=',len=60)
    else:       printHeading(p.headString())
    
    if verbose == 1:
        vals = [tok.val for tok in tokens]
        s = ''.join(vals)
        s = g.toEncodedString(s,g.app.tkEncoding)
        print s
    elif verbose in (2,3):
       
        if verbose == 2:
            for tok in tokens:
                print tok.toString(verbose=verbose),
        else:
            for tok in tokens:
                print tok.toString(verbose=verbose)</t>
<t tx="ekr.20040713164604">def wsToString (self,ws):
    
    allBlanks = True
    for ch in ws:
        if ch != ' ':
            allBlanks = False
            
    if allBlanks:
       return "&lt;' '*%d&gt;" % len(ws)
    else:
        result = ["&lt;"]
        for ch in ws:
            if ch == ' ':
                result.append(" ")
            elif ch == '\t':
                result.append("tab")
            elif ch == '\f':
                result.append("feed")
            else:
                result.append("&lt;%s&gt;" % repr(ch)) # should never happen.
        
        result.append("&gt;")
        return ''.join(result)</t>
<t tx="ekr.20040713173923">def match (self,tok2):
    
    tok1 = self
    
    val = (
        tok2 is not None and
        tok1.kind == tok2.kind and
        (not tok1.val or not tok2.val or (tok1.val == tok2.val)))
        
    if 0:
        if tok1.kind==tok2.kind:
            g.trace(val,tok1.kind,repr(tok1.val),tok2.kind)
        
    return val</t>
<t tx="ekr.20040713174349">def dump (self,verbose=2):
    
    tok = self

    if verbose == 2:
        print tok.toString(verbose=verbose)
    else:
        print tok.toString(verbose=verbose),</t>
<t tx="ekr.20040713180208">def toString (self,verbose=2):
    
    tok = self
    
    if verbose &lt; 2: return
    val = tok.val or ""
    val = g.toEncodedString(val,g.app.tkEncoding)
    
    if tok.isParseTok():
        parseTree = parseTreeToString(tok.parseTree)
        if tok.val == "TREE":
            return "%s"% (parseTree)
        else:
            return "%s: %s"% (tok.val,parseTree)
    
    elif verbose == 2:
        if len(tok.kind) == 1:    return tok.kind
        elif tok.kind=="form-feed": return "\nform-feed\n"
        elif tok.kind=="comment":   return "&lt;comment&gt;\n"
        elif tok.kind=="string":    return "&lt;string&gt;"
        else:                       return val
    
    elif verbose == 3:
        if tok.kind == '\n':      return "%9s:" % "newline"
        elif tok.kind=="form-feed": return "%9s:" % "form-feed"
        elif len(tok.kind)==1:      return "%9s:" % tok.kind
        elif tok.kind == "ws":
                return "%9s: %s" % (tok.kind,tok.wsToString(val))
        else:   return "%9s: &lt;%s&gt;" % (tok.kind,val)</t>
<t tx="ekr.20040713193437">def deleteTokens (self,tokens,delToken):
            
    return [tok for tok in tokens if not tok.match(delToken)]</t>
<t tx="ekr.20040713200238">@language elisp</t>
<t tx="ekr.20040713205718">def createIndentedBlock (self,tokens,level):
    
    e = self ; p = e.p ; level1 = level
    
    i = 0
    while i &lt; len(tokens):
        t = tokens[i]
        if t.kind == '(':
            &lt;&lt; insert nl and ws tokens &gt;&gt;
            level += 1
            i += 3
        elif t.kind == ')':
            level -= 1 ; i += 1
        elif t.kind == "string" and level == level1:
            &lt;&lt; insert nl and ws tokens &gt;&gt;
            i += 3
        else:
            i += 1

    return tokens</t>
<t tx="ekr.20040713211010">def convert (self):
    
    e = self ; p = e.p

    e.tokens = e.tokenize(p.bodyString())
    e.tokens = e.deleteTokens(e.tokens,tok("ws"))
    e.tokens = e.deleteTokens(e.tokens,tok('\n'))
    disposableTokens = e.tokens[:]
    e.parseTree = e.parse(disposableTokens)

    e.codeList = [] ; e.indent = 0
    e.codeLine = lineClass(0) # The line being accumulated.
    e.gen(e.parseTree)

    if 0: # Old code
        e.tokens = e.removeBlankLines(e.tokens)</t>
<t tx="ekr.20040714053807.1">def isStatement (self,tokens,i):
    
    """Returns the statement or function f if (f is at tokens[i]."""
    
    e = self
    
    for s in e.allStatements:
        toks = [tok('('),tok('id',s)]
        if e.matchTokens(tokens,i,toks):
            return s

    return False
      
    
</t>
<t tx="ekr.20040714054620.1">def matchTokens (self,tokens,i,findTokens):
    
    """Return True if tokens match findTokens at position i."""

    j = 0
    while j &lt; len(findTokens):
        tok = tokens[i+j]
        ftok = findTokens[j]
        if not tok.match(ftok):
            return False
        j += 1
    return True</t>
<t tx="ekr.20040714055306"></t>
<t tx="ekr.20040714060941">def isMatchingBracket(self,tokens,i,j):
    
    toki = tokens[i]
    tokj = tokens[j]

    f1 = "({[".find(toki.kind)
    f2 = ")}]".find(tokj.kind)
    
    # g.trace(f1,f2,repr(toki.kind),repr(tokj.kind))
    
    return f1 == f2 and f1 != -1</t>
<t tx="ekr.20040714061625">self.constants = ("t","nil")</t>
<t tx="ekr.20040714061625.1">self.statements = (
    "defconst","defun","defsubst","defvar",
    "cond",
    "if",
    "let","let*",
    "prog","prog1","progn",
    "set","setq",
    "unless","when","while",
)

</t>
<t tx="ekr.20040714061625.2">self.functions = (
    "and","or","not",
    "apply","eval",
    "cons","car","cdr",
    "error","princ",
    "eq","ne","equal","gt","ge","lt","le",
    "mapcar","type-of",
)</t>
<t tx="ekr.20040714072448">def removeBlankLines (self,tokens):
    
    e = self
    
    i = 0
    while i &lt; len(tokens):
        
        if tokens[i].kind == '\n':
            j = i ; i += 1
            while i &lt; len(tokens) and tokens[i].kind == "ws":
                i += 1
            if i &gt;= len(tokens) or tokens[i].kind == '\n':
                del tokens[j:i]
                i = j
            else: i += 1
        else: i += 1
            
    return tokens</t>
<t tx="ekr.20040714074445">ws = tok("ws",' '*e.tabwidth*level)
nl = tok('\n','\n')
tokens.insert(i,nl)
tokens.insert(i+1,ws)</t>
<t tx="ekr.20040714082939"></t>
<t tx="ekr.20040714091940.1">def block (self,tokens):
    
    """Parse a block of tokens."""
    
    e = self

    i = 0 ; result = []
    while i &lt; len(tokens):
        if tokens[i].kind == '(':
            j = e.findMatchingBracket(tokens,i)
            if j is None:
                # To do: print error message.
                i += 1
            else:
                # Strip off the matching parens.
                block = tokens[i+1:j]
                # Recursively parse this block.
                result.append(e.parse(block,topLevel=False))
                i = j + 1
        else:
            result.append(tokens[i])
            i += 1

    return result</t>
<t tx="ekr.20040714095247">def parseTreeToString (parseTree,level=0,verbose=2):

    result = [] ; levelSpaces = ' '*2*level
    indent = False

    if parseTree is None:
        result.append("None")

    if isToken(parseTree):
        s = parseTree.toString(verbose=2)
        if s: result.append(s + ' ')

    elif isList(parseTree):
        if verbose &gt;= 2:
            result.append('\n%s[' % levelSpaces)
        else:
            result.append('[')
        for item in parseTree:
            s = parseTreeToString(item,level+1,verbose=verbose)
            if s: result.append(s)
        result.append(']')

    else:
        result.append("unknown type in parseTreeToString")
        
    return ''.join(result)</t>
<t tx="ekr.20040714154314">if fTok:
    e.error("No (%s has no matching ')'" % fTok.kind)
else:
    e.error("Mismatched parens")</t>
<t tx="ekr.20040714155341">def parse (self,tokens,topLevel=True):
    
    """A recursive-descent parser for elisp."""
    
    e = self
    i = 0
    while i &lt; len(tokens):
        # g.trace(tokens[i].kind)
        if tokens[i].kind != '(':
            i += 1 ; continue
        j = e.findMatchingBracket(tokens,i)
        fTok = i+1 &lt; len(tokens) and tokens[i+1]
        if j is None:
            &lt;&lt; give error message about mismatched parens &gt;&gt;
            i += 1 ; continue
        # Strip off the matching parens.
        block = tokens[i+1:j]
        parseTree = e.block(block)
        # A top-level token is helpful for dumping, etc.
        if topLevel: token = tok('TREE','TREE',parseTree)
        else:        token = parseTree
        tokens[i:j+1] = [token]
        # We are replacing everyting by a _single_ token.
        i = i + 1 
            
    return tokens</t>
<t tx="ekr.20040714170021">def isParseTok (self):
    
    tok = self
    
    return type(tok.parseTree) == type([])</t>
<t tx="ekr.20040714222507"></t>
<t tx="ekr.20040715071350">def gen(self,object):
    
    """The top-level code generator.
    
    May be called recursively to generate inner parts of the tree."""
    
    e = self

    if isToken(object):
        t = object
        if t.kind == "TREE":
            e.gen(t.parseTree)
        else:
            e.gen_token(t,outerList=None)
        
    elif isList(object):
        e.gen_list(object)
            
    else:
        print "unknown object in parse tree:", repr(object)</t>
<t tx="ekr.20040715071555">(defun igrep-read-file-name (prompt
  &amp;optional directory default existing initial history)
  "Just like `read-file-name', but with optional HISTORY.
Also: convert DIRECTORY to DIRECTORY/* file name pattern."
  (if igrep-insert-default-key
      (define-key minibuffer-local-completion-map igrep-insert-default-key
	'igrep-insert-default-files))
  (let ((file-name
	 (if history
	     (let ((file-name-history (symbol-value history)))
	       (prog1 (read-file-name prompt directory default existing initial)
		 (set history file-name-history)))
	   (read-file-name prompt directory default existing initial))))
    (if (and (not (string-equal file-name ""))
	     (file-directory-p file-name))
	(expand-file-name "*" file-name)
      file-name)))</t>
<t tx="ekr.20040715073230">def isList (object):
    
    return type(object) == type([])

def isToken (object):
    
    return isinstance(object,tok)</t>
<t tx="ekr.20040715075845">def gen_token (self,t,outerList=None):
    
    e = self
    
    g.trace(t.kind,t.val)
    
    if 0: # Not yet.

        if t.kind == 'id' and t.val in e.allStatements:
            
            g.trace(t.toString())
            
            line = e.newCodeLine()
            line.add(t.val)
            
            # Only TREE tokens have parse trees.
            # We are _inside_ a parse tree.</t>
<t tx="ekr.20040715075914">def newCodeLine (self):
    
    e = self
    
    if e.codeLine:
        e.codeList.append(e.codeLine)
        
    e.codeLine = line = lineClass(e.indent) # Create a new line object.
    
    return line</t>
<t tx="ekr.20040715080216">class lineClass:
    
    """Represents a code line being accumulated."""
    
    @others</t>
<t tx="ekr.20040715080738">def __init__ (self,indent):
        
        self.parts = []
        self.indent = indent</t>
<t tx="ekr.20040715080738.1">def toString (self):
    
    line = self
    
    theList = [str(part) + ' ' for part in self.parts]
    
    return ' ' * 2 * self.indent + ''.join(theList)</t>
<t tx="ekr.20040715081031">def add (self,s):
    
    self.parts.append(s)</t>
<t tx="ekr.20040715081425">def dumpCodeList (self,codeList,heading=""):
    
    printHeading(heading,char='=',len=60)
    
    for line in codeList:
        
        print line.toString()</t>
<t tx="ekr.20040715082059">def printHeading (s,char='-',len=20):
    
    banner = char * len

    print
    print banner
    print s
    print banner
    print</t>
<t tx="ekr.20040715084435">def gen_list (self,theList):
    
    e = self
    
    assert(isList(theList))
    if not theList:
        return
        
    item1 = theList[0]

    if isToken(item1):
        # The normal case looks like a function call: "(id args)"
        # Handle all args here.
        t = item1
        if t.kind == "TREE":
            e.gen(t.parseTree)
        elif t.kind == 'id':
            e.gen_statement(t,theList[1:])
        else:
            g.trace("unexpected token",t.kind,t.val)
            name = None
            e.gen_function(name,theList)
    elif isList(item1):
        # The first item is a list.
        for arg in theList:
            e.gen(arg)
                
    else: g.trace("unknown item",item1)</t>
<t tx="ekr.20040715090957">self.code_gen_dispatch_dict = {

    "cond"      : self.gen_cond,     
    "defconst"  : self.gen_defconst,
    "defun"     : self.gen_defun,
    "defsubst"  : self.gen_defsubst, 
    "defvar"    : self.gen_defvar, 
    "if"        : self.gen_if,
    "let"       : self.gen_let, 
    "let*"      : self.gen_let_star, 
    "prog"      : self.gen_prog, 
    "prog1"     : self.gen_prog1, 
    "progn"     : self.gen_progn, 
    "set"       : self.gen_set, 
    "setq"      : self.gen_setq, 
    "unless"    : self.gen_unless, 
    "when"      : self.gen_when, 
    "while"     : self.gen_while,
}
</t>
<t tx="ekr.20040715090957.1">def gen_statement (self,t,args):
    
    e = self
    
    expr_names = (
        "and","or","not",
        "eq","ne","equal","gt","ge","lt","le",)
    
    assert(t.kind=='id')
    
    name = t.val # The name of the statement.
    f = e.code_gen_dispatch_dict.get(name)

    if f:
        # Syntax-specific code generators.
        f(args)
    elif name in expr_names:
        # We will try to simply expression.
        e.gen_expression(args)
    else:
        # Generic code generator.
        e.gen_function(name,args)</t>
<t tx="ekr.20040715090957.2"></t>
<t tx="ekr.20040715091409">def gen_function (self,name,args):
    
    e = self
    g.trace(len(args),name)
    for arg in args:
        e.gen(arg)</t>
<t tx="ekr.20040715093122">def gen_defun(self,args):
    
    e = self
    
    g.trace()
    
    if len(args) == 1:
        print "def %s ():" % parseTreeToString(args[0])
        
    elif len(args) &gt;= 2:
        
        print "def %s (%s):" % (
            parseTreeToString(args[0]),
            parseTreeToString(args[1]).strip())
            
    e.indent += 1

    for arg in args[2:]:
        e.gen(arg)
        
    e.indent -= 1</t>
<t tx="ekr.20040715093804"></t>
<t tx="ekr.20040715105834"></t>
<t tx="ekr.20040715120001">def gen_cond (self,t,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.1">def gen_defconst(self,t,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.2">def gen_defsubst(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.3">def gen_defvar(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.4">def gen_if(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
</t>
<t tx="ekr.20040715120001.5">def gen_let(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

def gen_let_star(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

</t>
<t tx="ekr.20040715120001.7">def gen_prog(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_prog1(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_progn(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)</t>
<t tx="ekr.20040715120001.8">def gen_set(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_setq(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)</t>
<t tx="ekr.20040715120001.9">def gen_unless(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_when(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)
    
def gen_while(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    e.gen_list(args)

</t>
<t tx="ekr.20040715121456">def gen_expression(self,args):
    
    e = self
    g.trace(parseTreeToString(args))
    
    if isList(args):
        for arg in args:
            e.gen_expression(arg)
    elif args:
        e.gen(args)
</t>
<t tx="ekr.20040715125453">def gen_computed_function (self,args):
    
    e = self

    g.trace()

    for arg in args:
        e.gen(arg)</t>
<t tx="ekr.20040715133744">@language plain

Complete the code generators.  This involves handling all the special cases.

Maybe someday.  For now, I can't bear to waste any more time on this project.</t>
<t tx="ekr.20040715154319">@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import unittest

c = g.top()

result = c.checkPythonCode(unittest=True,ignoreAtIgnore=False)

assert result=="error", "checkPythonCode returns: %s" % result</t>
<t tx="ekr.20040716062608"># Run this script to import a file.
# This is undoable because the Import @file command is undoable.

import leoGlobals as g

c = g.top()

path = r"c:\prog\test\perfectImport"

# Two files from Python23/Lib
name1 = g.os_path_join(path,"formatter.py")
name2 = g.os_path_join(path,"SimpleHTTPServer.py")
names = [name1]

c.importCommands.importFilesCommand (names,"@file",
    perfectImport=True,testing=False,verbose=True)</t>
<t tx="ekr.20040716071029.6"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716071856">#@+leo-ver=4-thin
#@+node:ekr.20040716071856.1:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716071856.1:-input
#@-leo
</t>
<t tx="ekr.20040716071856.1">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716081019">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716081943">#@+leo-ver=4-thin
#@+node:ekr.20040716071856.1:-input
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716071856.1:-input
#@-leo
</t>
<t tx="ekr.20040716084934">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716084934.1">Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716091245">#@+leo-ver=4-thin
#@+node:ekr.20040716081019:-input-after
Proof of concept implementation of sentinel free Leo files.
We try to insert a line after here.
This is an inserted line
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716081019:-input-after
#@-leo
</t>
<t tx="ekr.20040716140926"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716140926.1">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.2">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.3">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.1:-input
Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.1:-input
#@-leo
</t>
<t tx="ekr.20040716140926.4">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.2:-input-after
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.2:-input-after
#@-leo
</t>
<t tx="ekr.20040716140926.5">Proof of concept implementation of sentinel free Leo files.
This line will be replaced.
This should be after the inserted line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.6">Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)</t>
<t tx="ekr.20040716140926.7">#@+leo-ver=4-thin
#@+node:ekr.20040716140926.1:-input
Proof of concept implementation of sentinel free Leo files.
This line is the replacement line
This should be after the replaced line.
This should be the last line (no newline following!)
#@nonl
#@-node:ekr.20040716140926.1:-input
#@-leo
</t>
<t tx="ekr.20040716141621"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

assert leoTest.runPerfectImportTest(c,p,testing=False,verbose=False)
</t>
<t tx="ekr.20040716141621.1">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.2">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.3">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.1:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.1:-input
#@-leo
</t>
<t tx="ekr.20040716141621.4">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.2:-input-after
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.2:-input-after
#@-leo
</t>
<t tx="ekr.20040716141621.5">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.6">Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11</t>
<t tx="ekr.20040716141621.7">#@+leo-ver=4-thin
#@+node:ekr.20040716141621.1:-input
Line 0
   Line 1
   Line 2
   Line 3
   Line 4

 We have two subclasses:
   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.
   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.

 Line 10
 Line 11
#@nonl
#@-node:ekr.20040716141621.1:-input
#@-leo
</t>
<t tx="ekr.20040716142121"># See the node called "About the Perfect Import tests" in leoTests.py for details.

@ignore # Suppress Check Python Code warnings.

@language python
@tabwidth -4

import leoGlobals as g
import leoTest ; reload(leoTest)
c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

ignoreSentinelsInCompare = True # Fails when False

assert leoTest.runPerfectImportTest(c,p,
    testing=False,verbose=False,
    ignoreSentinelsInCompare=ignoreSentinelsInCompare)</t>
<t tx="ekr.20040716142121.2">root line 1
root line 2</t>
<t tx="ekr.20040716142121.3">#@+leo-ver=4-thin
#@+node:ekr.20040716142423:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142423:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.1:Node 1
node 1: line 1
node 1: line 2
#@-node:ekr.20040716142423.1:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.2:Node 2
node 2: line 1
node 2: line 2
#@-node:ekr.20040716142423.2:Node 2
#@-leo
</t>
<t tx="ekr.20040716142121.4">#@+leo-ver=4-thin
#@+node:ekr.20040716142121.2:-input-after
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142121.2:-input-after
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040717071133:Node 1
node 1: line 1
These lines should be totally different
#@-node:ekr.20040717071133:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040717071133.1:Node 2
and should span node boundaries
node 2: line 2
#@-node:ekr.20040717071133.1:Node 2
#@-leo
</t>
<t tx="ekr.20040716142121.5">root line 1
root line 2
node 1: line 1
node 1: line 2
node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20040716142121.6">root line 1
root line 2
node 1: line 1
These lines should be totally different
and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20040716142121.7">#@+leo-ver=4-thin
#@+node:ekr.20040716142423:-input
root line 1
root line 2
#@nonl
#@-node:ekr.20040716142423:-input
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.1:Node 1
node 1: line 1
These lines should be totally different
and should span node boundaries
#@-node:ekr.20040716142423.1:Node 1
#@-leo
#@+leo-ver=4-thin
#@+node:ekr.20040716142423.2:Node 2
node 2: line 2
#@-node:ekr.20040716142423.2:Node 2
#@-leo
</t>
<t tx="ekr.20040716142423">root line 1
root line 2</t>
<t tx="ekr.20040716142423.1">node 1: line 1
node 1: line 2
</t>
<t tx="ekr.20040716142423.2">node 2: line 1
node 2: line 2
</t>
<t tx="ekr.20040716144017"># See the node called "About the Perfect Import tests" in leoTests.py for how to set up these tests.
</t>
<t tx="ekr.20040717071133">node 1: line 1
These lines should be totally different
</t>
<t tx="ekr.20040717071133.1">and should span node boundaries
node 2: line 2
</t>
<t tx="ekr.20040717121014">import leoGlobals as g

c = g.top()

p = c.currentPosition()

print "gnx", p.v.t.fileIndex, p.headString()</t>
<t tx="ekr.20040721094335">for i in xrange(10000):
    if i % 1000 == 0:
        print i</t>
<t tx="ekr.20040721113934">import leoGlobals as g
import profile
import pstats

# Note: the profiled code should do all needed imports.

path = "c:/prog/test/leoProfile.txt"

c = g.top() ; p = c.currentPosition()

if p.bodyString().rstrip():
    s = p.bodyString().rstrip() + '\n'
    profile.run(s,path)
    print '-' * 40
    print "Profiling info sent to %s" % path
    stats = pstats.Stats(path)
    stats.strip_dirs()
    stats.sort_stats('cum','file','name')
    stats.print_stats()
</t>
<t tx="ekr.20040721114839.1">try: import timeit # Exists only in Python 2.3 and above.
except ImportError: 
    timeit = None
    print "Can not import timeit"
import leoGlobals as g

c = g.top() ; p = c.currentPosition()

if timeit and p.bodyString().strip():
    s = p.bodyString().rstrip() + '\n'
    t = timeit.Timer(s)
    try:
        count = 1000000 # The default is 1 million.
        result = t.timeit(count)
        print "count: %d time: %f %s" % (count,result,p.headString().strip())
    except:
        t.print_exc()</t>
<t tx="ekr.20040721115141"># There will never be an overflow here, no matter how many times timeit executes this.

try:
    i = 0
    i += 1
except OverflowError:
    pass</t>
<t tx="ekr.20040721145258.1">import leoTest
reload(leoTest)

leoTest.runGc(disable=True)</t>
<t tx="ekr.20040721153143"></t>
<t tx="ekr.20040721173532">import leoGlobals as g
c = g.top()

# c.redraw just schedules the actual drawing.
# We want to profile the actual idle-time drawing.

c.frame.tree.idle_redraw()</t>
<t tx="ekr.20040722051235"></t>
<t tx="ekr.20040722055040">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    child = p.firstChild()
    while child:
        for parent in p.self_and_parents_iter():
            assert parent.isAncestorOf(child)
        child.moveToNext()

    next = p.next()
    assert not p.isAncestorOf(next)</t>
<t tx="ekr.20040723062819"></t>
<t tx="ekr.20040723064143.1">@ignore
@nocolor

- Unit tests for undo/redo.

- Unit tests for tangle/untangle commands.

- Unit tests for Find commands.

- Unit tests for dialogs.</t>
<t tx="ekr.20040723064143.2">@ - Support toString in asis methods
</t>
<t tx="ekr.20040723064143.3"></t>
<t tx="ekr.20040723065021">import leoGlobals as g
c = g.top()

print '-' * 60

# Tag the start of the command.
c.undoer.setUndoParams("Change All",c.currentPosition())

n = 0 ; total = 0
for p in c.currentPosition().self_and_subtree_iter():
    total += 1
    body = p.bodyString()
    s = g.stripBlankLines(body)
    if s != body:
        n += 1
        p.setBodyStringOrPane(s,g.app.tkEncoding)
        c.undoer.setUndoParams("Change",p,
            oldText=body,newText=s,oldSel=None, newSel=None)

# Tag the end of the command.
c.undoer.setUndoParams("Change All",c.currentPosition()) 

print "%d nodes changed (%d total)" % (n,total)
</t>
<t tx="ekr.20040723065047">@ignore
a
  b
  
c  
  
last
  </t>
<t tx="ekr.20040724171040">import Tkinter as Tk

root = Tk.Tk()
c = Tk.Canvas(root,background='white')
print c.bindtags()

if 0:
    c.pack(expand=1,fill='both')
    f = Tk.Frame(c)
    c.create_window(0,0,window=f,anchor='nw')
    f.pack_configure(fill='both',expand=1)
    body = olCreateControl(self,frame,f)
    c.on = False 
    sel = lambda event, c = c, body = body:select(event,c,body)
    ai = lambda event, c = c, body = body, colorizer = frame.body:add_item(event,c,body,colorizer.getColorizer())
    c.bind("&lt;Key&gt;",watcher,'+')
    c.bind("&lt;Key&gt;",sel,'+')
    c.bind("&lt;Key&gt;",ai,'+')
    ctags = c.bindtags()
    btags = body.bindtags()
    btags =(ctags[0],btags[0],btags[1],btags[2],btags[3])
    body.bindtags(btags)</t>
<t tx="ekr.20040730181601">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","minimalLeoFile.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040730181610">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","minimalLeoFile2.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040730185319"></t>
<t tx="ekr.20040801124822.1">import leoGlobals as g
import leoTest
reload(leoTest)

leoTest.testPlugin("nodenavigator.py",verbose=False)</t>
<t tx="ekr.20040801141212"># N.B.  We don't import the files: multiple imports might cause problems.
import leoGlobals as g
import unittest
import leoTest
reload(leoTest)

c = g.top()

@others

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():

    f = file(path)
    assert f, "File not found: %s" % path
    s = f.read() ; f.close()
    test = parseFileTestCase(c,path,checkCompile=True,checkTabs=True)
    suite.addTest(test)

if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040801141543">class parseFileTestCase (unittest.TestCase):

    @others</t>
<t tx="ekr.20040801141543.1">def __init__ (self,c,path,checkCompile,checkTabs):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.checkCompile = checkCompile
    self.checkTabs = checkTabs
    assert self.checkCompile or self.checkTabs, "not checking anything"</t>
<t tx="ekr.20040801141543.3">def runTest(self):
    
    c = self.c ; path = self.path

    s = file(path).read()

    if self.checkCompile:
        leoTest.checkFileSyntax(path,s)

    if self.checkTabs:
        leoTest.checkFileTabs(path,s)</t>
<t tx="ekr.20040801141543.5">def shortDescription (self):
    
    fn = str(g.shortFileName(self.path))
    
    if self.checkCompile and self.checkTabs:
        return "Test syntax and tabbing of %s plugin" % fn
    elif self.checkCompile:
        return "Test syntax of %s plugin" % fn
    else:
        return "Test tabbing of %s plugin" % fn</t>
<t tx="ekr.20040801145836"># WARNING: Importing files this way tends to crash test.leo.

import leoGlobals as g
import unittest
import leoTest
reload(leoTest)

c = g.top()
verbose = False

@others

suite = unittest.makeSuite(unittest.TestCase)

g.app.unitTesting = True # Disable additional installation.

suite = unittest.makeSuite(unittest.TestCase)

for path in leoTest.getAllPluginFilenames():
    dir,fileName = g.os_path_split(path)
    try:
        module = g.importFromPath(fileName,dir)
    except:
        s = "Can not import %s" % path
        print s ; g.es(s)
        module = None
    
    # Run any unit tests in the module itself.
    if module and hasattr(module,"unitTest"):
        if verbose:
            print "Creating unit test for plugins/%s..." % fileName
        test = runPluginTestCase(c,path,module,verbose=verbose)
        suite.addTest(test)

    g.app.unitTesting = True # Disable additional installation.

if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040801150333">class runPluginTestCase (unittest.TestCase):

    @others</t>
<t tx="ekr.20040801150333.1">def __init__ (self,c,path,module,verbose=False):

    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.path = path
    self.module = module</t>
<t tx="ekr.20040801150333.2">def runTest(self):
    
    fn = g.shortFileName(self.path)
    
    self.module.unitTest(verbose=verbose)</t>
<t tx="ekr.20040801150333.3">def shortDescription (self):
    
    fn = str(g.shortFileName(self.path))
    
    return "Run unitTest function in %s plugin if it exists" % fn</t>
<t tx="ekr.20040802065214"># Make sure that changing this headline marks descendent @thin nodes dirty.

import leoGlobals as g

c = g.top() ; p = c.currentPosition()

h = p.headString()

c.beginUpdate()
try:
    child = p.firstChild()
    child.initHeadString("@thin bogus")
    assert child.headString() == "@thin bogus", "setting headline failed"
    child.clearDirty()
    assert not child.isDirty(), "clearing dirty failed"
    p.setHeadString("changed")
    assert child.isDirty(), "setting descendent @thin nodes dirty failed."
finally:
    p.setHeadString(h)
    child.setHeadString("bogus")
    p.clearDirty()
    child.clearDirty()
c.endUpdate()
</t>
<t tx="ekr.20040802065214.1">test</t>
<t tx="ekr.20040802071519"># Tests that p.setBodyStringOrPane works immediately.

import leoGlobals as g

c = g.top() ; p = c.currentPosition()

h = p.headString()

try:
    child = p.firstChild()
    before = child.bodyString()
    after = "after"
    child.setBodyStringOrPane("after")
    c.selectPosition(child)
    t = c.frame.body.bodyCtrl
    s = t.get("1.0","end")
    assert s.rstrip() == after.rstrip(), \
        "setBodyStringOrPane failed: %s, %s" % (repr(s),repr(after))
finally:
    child.setBodyStringOrPane(before)
    c.selectPosition(p)</t>
<t tx="ekr.20040802071519.1">after</t>
<t tx="ekr.20040803090901">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","dist","leoDist.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040803091512">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; u = leoTest.testUtils()

name = "@thin ../src/leoTest.py"

p = u.findNodeAnywhere(c,name)

assert p, "Can't find %s" % name

p.v.t.tnodeList = ["bogus tnodeList"]

if 0: # This causes p to be written, thereby clearing the tnodeList.
    p.setDirty()
    
if 0: # This actually saves this file, so it is a bit dangerous.
    g.app.unitTesting = True
    g.app.unitTestDict = {}
    c.save()
    ok = g.app.unitTestDict.get("warning")
    assert ok, "putVnode failed to give warning"
    g.app.unitTesting = False</t>
</tnodes>
</leo_file>
