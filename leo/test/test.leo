<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="5438" clone_windows="0"/>
<globals body_outline_ratio="0.5561861521">
	<global_window_position top="32" left="333" height="881" width="856"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040303080938"><vh>Diary</vh>
<v t="ekr.20040315210314"><vh>March 2004</vh>
<v t="ekr.20040315210314.1"><vh>3/15: Created stubs for Find Commands tests</vh></v>
<v t="ekr.20040315210314.2"><vh>3/15: Convert this file to 4.2 format</vh></v>
<v t="ekr.20040309095121"><vh>3/9: created more position mini tests</vh></v>
<v t="ekr.20040303080938.1"><vh>3/3: created position tests</vh></v>
</v>
</v>
<v t="EKR.20040626212434"><vh>Drawing experiments</vh>
<v t="EKR.20040626212434.1"><vh>Rectangles &amp; ovals</vh></v>
<v t="EKR.20040626212434.2"><vh>Lines &amp; arcs</vh></v>
<v t="EKR.20040626213007"><vh>Paul Klee</vh></v>
<v t="EKR.20040627150213"><vh>Complex functions</vh></v>
</v>
<v t="ekr.20040312021734"><vh>Scripts</vh>
<v t="ekr.20040311090054"><vh>Dump fileIndex</vh></v>
<v t="ekr.20040312021734.1"><vh>Script to clean unused tnodeLists</vh></v>
<v t="ekr.20040318091620"><vh>Clear all unknown attributes</vh></v>
<v t="ekr.20040319111213"><vh>FilterHoist script</vh>
<v t="ekr.20040319111213.1"><vh>description</vh></v>
<v t="ekr.20040319142708"><vh>filter</vh></v>
<v t="ekr.20040319142202"><vh>old code</vh>
<v t="ekr.20040319111213.2"><vh>filter</vh></v>
<v t="ekr.20040319111213.3"><vh>search</vh></v>
</v>
<v t="ekr.20040319111213.4"><vh>filterHoist</vh></v>
<v t="ekr.20040319111213.5"><vh>addMenu</vh></v>
</v>
<v t="ekr.20040322120331"><vh>script to print tnodeList's</vh></v>
<v t="ekr.20040330095252"><vh>script to clear log frame</vh></v>
<v t="EKR.20040424065452"><vh>Compare script</vh></v>
<v t="EKR.20040424091411"><vh>Compare script using text mode to ignore newlines</vh></v>
<v t="EKR.20040517074600.8"><vh>Count pages</vh></v>
<v t="EKR.20040517074600.9"><vh>Scripts to debug font problem</vh>
<v t="EKR.20040517074600.10"><vh>Show font</vh></v>
<v t="EKR.20040517074600.11"><vh>Show settings</vh>
<v t="EKR.20040517074600.12"><vh>getFontSettings</vh></v>
</v>
<v t="EKR.20040517074600.13"><vh>Print default font</vh></v>
</v>
<v t="EKR.20040613162717"><vh>Report newlines</vh></v>
<v t="ekr.20040706071823"><vh>test of Python's parser module</vh></v>
</v>
<v t="ekr.20040708205841"><vh>Other tests...</vh>
<v t="ekr.20040414082806"><vh>Clone test</vh>
<v t="ekr.20040409140301"><vh>clone test</vh>
<v t="ekr.20040409140301.1"><vh>b</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028"><vh>sibling</vh></v>
</v>
<v t="ekr.20040409140301.3"><vh>a</vh></v>
</v>
<v t="ekr.20040409140343"><vh>d</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028.1"><vh>sibling 2</vh></v>
</v>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409140343.1"><vh>last</vh></v>
</v>
<v t="EKR.20040523112430"><vh>Cloning headlines</vh>
<v t="EKR.20040523112430.1"><vh>read me</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.8"><vh>f</vh></v>
</v>
<v t="ekr.20040312101720"><vh>Experiments</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
<v t="ekr.20040323075614"><vh>Test of using an iterator inside a list comprehension</vh></v>
<v t="ekr.20040323080317"><vh>Test of using c.allNodes_iter to create a list of all positions</vh></v>
<v t="ekr.20040323082119"><vh>Creating a list of distinct vnodes</vh></v>
<v t="ekr.20040325082811"><vh>Test that back quotes are not needed in es</vh></v>
<v t="ekr.20040325130503"><vh>test of list comparisons</vh></v>
<v t="ekr.20040325140133"><vh>test that childIndex doesn't mess with p</vh></v>
<v t="ekr.20040325155043"><vh>Test of __cmp__ vrs equal</vh></v>
<v t="EKR.20040615070332"><vh>Test print</vh></v>
<v t="ekr.20040710125250"><vh>import from string</vh>
<v t="ekr.20040710125250.2"><vh>@test import from string</vh></v>
</v>
</v>
<v t="ekr.20040707110818"><vh>File Tests...</vh>
<v t="EKR.20040430162649.23"><vh>(double @root bug)</vh>
<v t="EKR.20040430162649.24"><vh>Assert fails</vh></v>
<v t="EKR.20040430162649.25"><vh>double at-root test (assert fails)</vh></v>
</v>
<v t="EKR.20040427092657"><vh>@ file-thin c:\prog\test\at-file-thin-test.txt</vh>
<v t="EKR.20040427092657.1"><vh>node 1</vh>
<v t="EKR.20040428145741"><vh>&lt;&lt; node 1 ref &gt;&gt;</vh>
<v t="EKR.20040428145741.1"><vh>child node 1</vh></v>
<v t="EKR.20040428145741.2"><vh>child node 2</vh></v>
</v>
</v>
<v t="EKR.20040427092657.2"><vh>&lt;&lt; ref &gt;&gt;</vh>
<v t="EKR.20040428150018"><vh>organizer node</vh>
<v t="EKR.20040428145826"><vh>ref child 1</vh></v>
<v t="EKR.20040428145826.1"><vh>ref child 2</vh></v>
</v>
</v>
</v>
<v t="EKR.20040625110032"><vh>@ thin c:\prog\test\mixedCommentDelims.txt</vh>
<v t="EKR.20040625110032.1"><vh>node 1</vh></v>
<v t="EKR.20040625110032.2"><vh>node 2</vh>
<v t="EKR.20040625110032.3"><vh>Node 3</vh></v>
</v>
</v>
<v t="ekr.20040419105536"><vh>@file c:\prog\test\perlLineNumbersTest.txt</vh>
<v t="ekr.20040419105536.1"><vh>one</vh></v>
<v t="ekr.20040419105536.2"><vh>two</vh></v>
</v>
<v t="ekr.20040330103006"><vh>@file c:\prog\test\testSectionDelims.txt</vh></v>
<v t="EKR.20040608095146.1"><vh>@file login_process.cfm</vh></v>
<v t="EKR.20040531110157"><vh>at-file thin tests</vh>
<v t="EKR.20040520104329"><vh>@thin c:\prog\test\thinCloneTest.txt</vh></v>
<v t="EKR.20040524050419"><vh>@file c:\prog\test\fatGrandChildTest.txt</vh>
<v t="EKR.20040524050419.1"><vh>Organizer node</vh>
<v t="EKR.20040524050419.2"><vh>&lt;&lt; defined in grandchild &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040524050438"><vh>@thin c:\prog\test\grandChildTest.txt</vh></v>
<v t="EKR.20040525083635"><vh>@file c:\prog\test\orphanMessageTest.txt</vh>
<v t="EKR.20040525083635.1"><vh>orphan</vh></v>
</v>
</v>
<v t="EKR.20040430162649.12"><vh>REM_ hack and perlpod hacks</vh>
<v t="EKR.20040430162649.13"><vh>perlpod test</vh>
<v t="EKR.20040430162649.14"><vh>perlpod test</vh>
<v t="EKR.20040430162649.15"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040430162649.16"><vh>REM test</vh>
<v t="EKR.20040430162649.17"><vh>@file c:/prog/test/remTest.txt</vh></v>
</v>
</v>
<v t="EKR.20040430162649.20"><vh>Suppress @@ sentinel unless leading @ starts a directive</vh>
<v t="EKR.20040430162649.21"><vh>@file c:\prog\test\perltest.txt</vh></v>
</v>
<v t="ekr.20040704104554"><vh>Test mixed @language directives in a single node</vh>
<v t="ekr.20040704104554.1"><vh>Mixed script</vh></v>
<v t="ekr.20040704104554.2"><vh>@thin c:\prog\test\mixedLanguages.txt</vh></v>
</v>
<v t="EKR.20040606204316"><vh>Test of @first</vh>
<v t="EKR.20040606204316.1"><vh>@thin atFirstTest.txt</vh></v>
</v>
<v t="EKR.20040622074004"><vh>Test of conflicting node defs</vh>
<v t="EKR.20040622074004.1"><vh>a</vh>
<v t="EKR.20040622074004.2" a="M"><vh>b</vh></v>
<v t="EKR.20040622074004.3"><vh>c</vh></v>
</v>
<v t="EKR.20040622102618"><vh>@thin c:\prog\test\cloneConflicts.txt</vh></v>
</v>
<v t="ekr.20040701081330"><vh>Test of decendent attributes</vh>
<v t="ekr.20040701065412"><vh>@ thin c:\prog\test\attribTest.txt</vh>
<v t="ekr.20040701065412.1" a="M"><vh>Marked</vh></v>
<v t="ekr.20040701065412.2"><vh>Expanded</vh>
<v t="ekr.20040701065412.3"><vh>child</vh></v>
</v>
<v t="ekr.20040701065412.4" a="M"><vh>Marked and expanded</vh>
<v t="ekr.20040701065412.5"><vh>child2</vh></v>
</v>
<v t="ekr.20040701065424"><vh>Neither Expanded or marked</vh>
<v t="ekr.20040701065424.1"><vh>child</vh></v>
</v>
</v>
</v>
<v t="EKR.20040627103732"><vh>Test of writing descendent uA's</vh>
<v t="EKR.20040627121836"><vh>print all tnode attributes</vh></v>
<v t="EKR.20040627103902"><vh>Test of user icons</vh></v>
<v t="EKR.20040627103801"><vh>@thin c:\prog\test\uaTest.txt</vh></v>
</v>
</v>
<v t="ekr.20040708210442"><vh>Manual tests...</vh>
<v t="EKR.20040605200750"><vh>autocompleter test</vh></v>
<v t="EKR.20040430162649.22"><vh>Other Reformat Paragraph tests</vh></v>
<v t="EKR.20040604082113"><vh>Test of @tabwidth</vh></v>
<v t="EKR.20040608092841"><vh>test of indent/undent with negative tab width</vh></v>
<v t="EKR.20040610131858"><vh>Test of Paste Node Retaining Clones</vh>
<v t="EKR.20040615144810"><vh>b</vh></v>
<v t="EKR.20040615144735"><vh>branch</vh>
<v t="EKR.20040615144810"><vh>b</vh></v>
<v t="EKR.20040610131858.1"><vh>a</vh>
<v t="EKR.20040610143643"><vh>b</vh></v>
<v t="EKR.20040610143643"><vh>b</vh></v>
</v>
<v t="EKR.20040610131858.1"><vh>a</vh>
<v t="EKR.20040610143643"><vh>b</vh></v>
<v t="EKR.20040610143643"><vh>b</vh></v>
</v>
<v t="EKR.20040610132739"><vh>copied</vh></v>
</v>
</v>
<v t="EKR.20040610092248"><vh>Test of pasting into big node</vh></v>
<v t="EKR.20040527154402"><vh>Test of undo extract section</vh>
<v t="EKR.20040528130659"><vh>a</vh></v>
<v t="EKR.20040528130659"><vh>a</vh></v>
</v>
<v t="EKR.20040604170105"><vh>Test of Remove sentinels</vh></v>
<v t="ekr.20040711044029.1"><vh>Test new docutils stull</vh></v>
</v>
<v t="ekr.20040707104245"><vh>Printing tests...</vh>
<v t="ekr.20040323085933"><vh>Print findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040309111054"><vh>Print iterations: do not delete</vh>
<v t="ekr.20040309111102"><vh>Clone test data</vh>
<v t="ekr.20040309111102.1"><vh>aa</vh></v>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.8"><vh>d</vh>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.9"><vh>e</vh></v>
<v t="ekr.20040309111102.10"><vh>z</vh></v>
</v>
<v t="ekr.20040309111232"><vh>last node</vh></v>
</v>
<v t="ekr.20040705191805"><vh>Print abbreviations</vh>
<v t="ekr.20040705212227"><vh>@file file</vh></v>
<v t="ekr.20040705192522" a="M"><vh>@silentfile silentfile</vh></v>
<v t="ekr.20040705192522.1"><vh>@file-asis file-asis</vh></v>
<v t="ekr.20040705192522.2"><vh>@asis asis</vh></v>
<v t="ekr.20040705192522.3" a="M"><vh>@nosentinelsfile nosentinelsfile</vh></v>
<v t="ekr.20040705191805.1"><vh>@file-nosent file-nosent</vh></v>
<v t="ekr.20040705191805.2"><vh>@nosent nosent</vh></v>
<v t="ekr.20040705192610" a="M"><vh>@rawfile rawfile</vh></v>
<v t="ekr.20040705192522.4"><vh>@file-noref file-noref</vh></v>
<v t="ekr.20040705192522.5"><vh>@noref noref</vh></v>
<v t="ekr.20040705192522.6"><vh>@file-thin file-thin</vh></v>
<v t="ekr.20040705192610.1"><vh>@thin thin</vh></v>
</v>
<v t="ekr.20040323085406"><vh>Print isAnyAtFileNode</vh></v>
<v t="ekr.20040708135624"><vh>Print fundChildrenOf and </vh></v>
<v t="EKR.20040526193608"><vh>Tests of pickle &amp; hexlify</vh></v>
<v t="EKR.20040526094831"><vh>Test of undo registration</vh></v>
<v t="EKR.20040526200017" myPlugin="7d710055016171014930310a732e"><vh>Test of unknownAttributes</vh></v>
<v t="EKR.20040602101648"><vh>Test of "end1" hook</vh></v>
<v t="EKR.20040603064545"><vh>Print timestamps of all nodes</vh></v>
<v t="EKR.20040603174633"><vh>test of focus</vh></v>
<v t="EKR.20040611083703"><vh>Using a generator instead of readLinesClass</vh></v>
<v t="EKR.20040612150543"><vh>Test of better error messages in Execute Script command</vh>
<v t="EKR.20040612215136"><vh>Contains error</vh></v>
</v>
<v t="EKR.20040627100615"><vh>Test of error messages when redirecting output</vh></v>
<v t="ekr.20040710141351"><vh>print all docstrings from a module</vh>
<v t="ekr.20040710145459"><vh>&lt;&lt; print names sorted by type &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040430162649.1"><vh>Unicode tests</vh>
<v t="EKR.20040430162649.2"><vh> Tests</vh>
<v t="EKR.20040430162649.3"><vh>@file-asis c:\prog\test\asisTest.txt</vh></v>
<v t="EKR.20040430162649.4"><vh>@file-nosent c:\prog\test\nosentTest.txt</vh></v>
<v t="EKR.20040430162649.5"><vh>@file-noref c:\prog\test\norefTest.txt</vh></v>
</v>
<v t="EKR.20040430162649.6"><vh> Tests</vh>
<v t="EKR.20040430162649.7"><vh>Import/export tests</vh>
<v t="EKR.20040430162649.8"><vh>test</vh>
<v t="EKR.20040430162649.9"><vh>NewHeadlineë</vh></v>
</v>
</v>
<v t="EKR.20040430162649.10"><vh>@file c:/prog/test/unicodeTest.doc</vh>
<v t="EKR.20040430162649.11"><vh>NewÖ</vh></v>
</v>
</v>
</v>
<v t="ekr.20040708210636"><vh>User Icon tests... (disrupts representation of outline)</vh>
<v t="ekr.20040317173327"><vh>Delete user icons</vh></v>
<v t="ekr.20040317101155"><vh>Test of user icons</vh>
<v t="ekr.20040317185041"><vh>&lt;&lt; define event callbacks &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040708215319"><vh>To do...</vh>
<v t="EKR.20040608095146"><vh>Perfect import stuff...</vh>
<v t="EKR.20040504083716.44"><vh>perfect import unit tests</vh>
<v t="EKR.20040504083716.45"><vh>@   file test_sentinels.py</vh>
<v t="EKR.20040504083716.47"><vh>class sentinel_test</vh>
<v t="EKR.20040504083716.48"><vh>setUp</vh></v>
<v t="EKR.20040504083716.49"><vh>setup_inputfile</vh></v>
<v t="EKR.20040504083716.50"><vh>setup_configfile</vh></v>
</v>
<v t="EKR.20040504083716.51"><vh>insert tests</vh>
<v t="EKR.20040504083716.52"><vh>class insert_test</vh>
<v t="EKR.20040504083716.53"><vh>setUp</vh></v>
<v t="EKR.20040504083716.54"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.55"><vh>replacement tests</vh>
<v t="EKR.20040504083716.56"><vh>class replace_test</vh>
<v t="EKR.20040504083716.57"><vh>setUp</vh></v>
<v t="EKR.20040504083716.58"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.59"><vh>class replace_test2</vh>
<v t="EKR.20040504083716.60"><vh>setUp</vh></v>
<v t="EKR.20040504083716.61"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.62"><vh>class replace_test3</vh>
<v t="EKR.20040504083716.63"><vh>setUp</vh></v>
<v t="EKR.20040504083716.64"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.65"><vh>class replace_test4</vh>
<v t="EKR.20040504083716.66"><vh>setUp</vh></v>
<v t="EKR.20040504083716.67"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.68"><vh>regression tests</vh>
<v t="EKR.20040504083716.69"><vh>class regression_test_1</vh>
<v t="EKR.20040504083716.70"><vh>setUp</vh></v>
<v t="EKR.20040504083716.71"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.72"><vh>main</vh></v>
</v>
<v t="EKR.20040504083716.73"><vh>not used</vh>
<v t="EKR.20040504083716.74"><vh>@file testtesting.ini</vh></v>
<v t="EKR.20040504083716.75"><vh>tests to write</vh>
<v t="EKR.20040504083716.76"><vh>Insert tests.</vh></v>
<v t="EKR.20040504083716.77"><vh>deletion tests.</vh></v>
<v t="EKR.20040504083716.78"><vh>Creation of backup files.</vh></v>
</v>
</v>
</v>
<v t="EKR.20040504083716"><vh>Mulder Update script</vh>
<v t="EKR.20040504083716.39"><vh>sync</vh>
<v t="EKR.20040504153320"><vh>&lt;&lt; compute sourcetime and targettime &gt;&gt;</vh></v>
<v t="EKR.20040504153320.1"><vh>&lt;&lt; compute operation &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
<v t="EKR.20040619133116" a="E"><vh>Unit testing...</vh>
<v t="ekr.20040327114250" tnodeList="ekr.20040327114250"><vh>@file c:\prog\test\unittest\batchTest.py</vh></v>
<v t="EKR.20040623200709"><vh>@thin ../src/leoTest.py</vh></v>
<v t="ekr.20040707091428" a="TV"><vh>Unit Tests</vh>
<v t="ekr.20040710120700"><vh>File Tests</vh>
<v t="ekr.20040707140849.35"><vh>Test Leo files...</vh>
<v t="ekr.20040707140849.39"><vh>@test test.leo</vh></v>
<v t="ekr.20040707140849.40"><vh>@test LeoPy.leo</vh></v>
<v t="ekr.20040707140849.41"><vh>@test leoPlugins.leo</vh></v>
<v t="ekr.20040707140849.42"><vh>@test LeoDocs.leo</vh></v>
</v>
<v t="ekr.20040707140849.26"><vh>Import/Export tests</vh>
<v t="ekr.20040708173308.1"><vh>@suite Import tests</vh></v>
<v t="ekr.20040708173549"><vh>@suite Export tests</vh></v>
<v t="ekr.20040303063549.90"><vh>importTests</vh>
<v t="ekr.20040708174345"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.91"><vh>importAtRoot</vh>
<v t="ekr.20040303063549.92"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.93"><vh>importAtFile</vh>
<v t="ekr.20040303063549.94"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.95"><vh>importNowebFiles</vh>
<v t="ekr.20040303063549.96"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.97"><vh>importFlattenedOutline</vh>
<v t="ekr.20040303063549.98"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.99"><vh>importCWEBFiles</vh>
<v t="ekr.20040303063549.100"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.88"><vh>removeSentinels</vh>
<v t="ekr.20040303063549.89"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.77"><vh>exportTests</vh>
<v t="ekr.20040708174345.1"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.78"><vh>exportHeadlines</vh>
<v t="ekr.20040303063549.79"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.80"><vh>flattenOutline</vh>
<v t="ekr.20040303063549.81"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.82"><vh>weave</vh>
<v t="ekr.20040303063549.83"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.84"><vh>outlineToNoweb</vh>
<v t="ekr.20040303063549.85"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.86"><vh>outlineToCWEB</vh>
<v t="ekr.20040303063549.87"><vh>dialog</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040708205640"><vh>Non-file tests</vh>
<v t="ekr.20040707140849.10"><vh>@suite Edit body tests</vh>
<v t="ekr.20040708113527"><vh>editBodyTests</vh>
<v t="ekr.20040708113823"><vh>tempNode</vh></v>
<v t="ekr.20040708113527.9"><vh>extractSection</vh>
<v t="ekr.20040708113527.10"><vh>before</vh></v>
<v t="ekr.20040708113527.11"><vh>after</vh>
<v t="ekr.20040708113527.12"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040708113527.13"><vh>selection</vh></v>
</v>
<v t="ekr.20040708113527.5"><vh>indentBody</vh>
<v t="ekr.20040708113527.6"><vh>before</vh></v>
<v t="ekr.20040708113527.7"><vh>after</vh></v>
<v t="ekr.20040708113527.8"><vh>selection</vh></v>
</v>
<v t="ekr.20040708113527.1"><vh>dedentBody</vh>
<v t="ekr.20040708113527.2"><vh>before</vh></v>
<v t="ekr.20040708113527.3"><vh>after</vh></v>
<v t="ekr.20040708113527.4"><vh>selection</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707140849.79"><vh>@suite Reformat Paragraph Tests</vh>
<v t="ekr.20040708080620"><vh>What I did</vh></v>
<v t="ekr.20040303063549.2"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040708080620.1"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.3"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040303063549.4"><vh>before</vh></v>
<v t="ekr.20040303063549.5"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.6"><vh>testTrailingNewline</vh>
<v t="ekr.20040303063549.7"><vh>before</vh></v>
<v t="ekr.20040303063549.8"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.9"><vh>testMixedLineLengths</vh>
<v t="ekr.20040303063549.10"><vh>before</vh></v>
<v t="ekr.20040303063549.11"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.12"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040303063549.13"><vh>before</vh></v>
<v t="ekr.20040303063549.14"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.15"><vh>testNoChangeRequired</vh>
<v t="ekr.20040303063549.16"><vh>before</vh></v>
<v t="ekr.20040303063549.17"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.18"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040303063549.19"><vh>before</vh></v>
<v t="ekr.20040303063549.20"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.21"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040303063549.22"><vh>before</vh></v>
<v t="ekr.20040303063549.23"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.24"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040303063549.25"><vh>before</vh></v>
<v t="ekr.20040303063549.26"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.27"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040303063549.28"><vh>before</vh></v>
<v t="ekr.20040303063549.29"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.30"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040303063549.31"><vh>before</vh></v>
<v t="ekr.20040303063549.32"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.33"><vh>testMultiParagraph</vh>
<v t="ekr.20040303063549.34"><vh>before</vh></v>
<v t="ekr.20040303063549.35"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.36"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040303063549.37"><vh>before</vh></v>
<v t="ekr.20040303063549.38"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.39"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040303063549.40"><vh>before</vh></v>
<v t="ekr.20040303063549.41"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.42"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040303063549.43"><vh>before</vh></v>
<v t="ekr.20040303063549.44"><vh>after</vh></v>
</v>
</v>
</v>
<v t="EKR.20040529092739"><vh>@test c iters</vh>
<v t="EKR.20040529093047"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="EKR.20040529093047.1"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20040707140849.1"><vh>atFileTests...</vh>
<v t="ekr.20040707141957.3"><vh>@test @file no newline</vh>
<v t="ekr.20040707141957.4"><vh>@@file</vh></v>
<v t="ekr.20040707141957.5"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.6"><vh>@test @file one newline</vh>
<v t="ekr.20040707141957.7"><vh>@@file</vh></v>
<v t="ekr.20040707141957.8"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.9"><vh>@test @file two newlines</vh>
<v t="ekr.20040707141957.10"><vh>@@file</vh></v>
<v t="ekr.20040707141957.11"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.12"><vh>@test @thin</vh>
<v t="ekr.20040707141957.13"><vh>@@thin</vh></v>
<v t="ekr.20040707141957.14"><vh>Output</vh></v>
</v>
</v>
<v t="ekr.20040707083523"><vh>Colorizer tests...</vh>
<v t="ekr.20040708210045"><vh>@test @comment after @language plain</vh>
<v t="EKR.20040430162649.19"><vh>Test</vh></v>
</v>
<v t="ekr.20040707090019"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20040707083523.1"><vh>Actionscript</vh></v>
</v>
<v t="ekr.20040707090300"><vh>@test colorizer C</vh>
<v t="ekr.20040707083523.2"><vh>C</vh></v>
</v>
<v t="ekr.20040707090300.1"><vh>@test colorizer C#</vh>
<v t="ekr.20040707083523.3"><vh>C#</vh></v>
</v>
<v t="ekr.20040707090647"><vh>@test colorizer css</vh>
<v t="ekr.20040707083523.4"><vh>css</vh></v>
</v>
<v t="ekr.20040707090647.1"><vh>@test colorizer CWEB</vh>
<v t="ekr.20040707083523.5"><vh>CWEB</vh>
<v t="ekr.20040707083523.6"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040707090647.2"><vh>@test colorizer elisp</vh>
<v t="ekr.20040707083523.7"><vh>elisp</vh></v>
</v>
<v t="ekr.20040708211223"><vh>@test colorizer HTML string bug</vh>
<v t="EKR.20040603103118"><vh>String bug in html</vh></v>
</v>
<v t="ekr.20040707090647.3"><vh>@test colorizer HTML1</vh>
<v t="ekr.20040707083523.8"><vh>HTML1</vh></v>
</v>
<v t="ekr.20040707090647.4"><vh>@test colorizer HTML2</vh>
<v t="ekr.20040707083523.9"><vh>HTML2</vh></v>
</v>
<v t="ekr.20040707090647.5"><vh>@test colorizer LaTex</vh>
<v t="ekr.20040707083523.10"><vh>LaTex</vh></v>
</v>
<v t="ekr.20040707090647.6"><vh>@test colorizer mixed</vh>
<v t="ekr.20040707083523.11"><vh>Mixed</vh></v>
</v>
<v t="ekr.20040707090647.7"><vh>@test colorizer PHP</vh>
<v t="ekr.20040707083523.12"><vh>PHP</vh></v>
</v>
<v t="EKR.20040430160416.1"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="EKR.20040430160416.5"><vh>python.xml</vh>
<v t="EKR.20040430160416.6"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="EKR.20040430160416.7"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="EKR.20040430160416.8"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="EKR.20040430160416.9"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="EKR.20040430160416.10"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="EKR.20040430160416.11"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="EKR.20040430160416.12"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="EKR.20040430160416.13"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="EKR.20040430160416.14"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707090647.8"><vh>@test colorizer Python1</vh>
<v t="ekr.20040707083523.13"><vh>Python1</vh></v>
</v>
<v t="ekr.20040707090647.9"><vh>@test colorizer Python2</vh>
<v t="ekr.20040707083523.14"><vh>Python2</vh></v>
</v>
<v t="ekr.20040707090647.10"><vh>@test colorizer rapidq</vh>
<v t="ekr.20040707083523.15"><vh>rapidq</vh></v>
</v>
<v t="ekr.20040707090647.11"><vh>@test colorizer Rebol</vh>
<v t="ekr.20040707083523.16"><vh>Rebol</vh></v>
</v>
<v t="ekr.20040707090647.12"><vh>@test colorizer shell</vh>
<v t="ekr.20040707083523.17"><vh>shell</vh></v>
</v>
<v t="ekr.20040708205153"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="EKR.20040430160416.2"><vh>tex.xml</vh>
<v t="EKR.20040430160416.3"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="EKR.20040430160416.4"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040707090647.13"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20040707083523.18"><vh>wikiTest1</vh></v>
</v>
<v t="ekr.20040707090647.14"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20040707083523.19"><vh>wikiTest2</vh></v>
</v>
<v t="ekr.20040707090647.15"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20040707083523.20"><vh>wikiTest3</vh></v>
</v>
</v>
<v t="ekr.20040707093334"><vh>Mini tests...</vh>
<v t="ekr.20040311125054"><vh>@test p.t == p.v.t</vh></v>
<v t="ekr.20040310145919"><vh>@test python keywords</vh></v>
<v t="ekr.20040315030123"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20040315025315"><vh>File Conversion</vh>
<v t="ekr.20040315025315.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315025315.2"><vh>moreHead</vh></v>
<v t="ekr.20040315025315.3"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20040318102920"><vh>inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20040318102920.1"><vh>parent</vh>
<v t="ekr.20040318102920.2"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
<v t="ekr.20040318102920.1"><vh>parent</vh>
<v t="ekr.20040318102920.2"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
</v>
<v t="ekr.20040323090541"><vh>@test consistency of p.v.t.vnodeList &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162303"><vh>@test that cloned nodes actually share subtrees</vh></v>
<v t="ekr.20040327105955"><vh>@test batch mode</vh></v>
</v>
<v t="ekr.20040707091428.1"><vh>Position tests...</vh>
<v t="EKR.20040528152529"><vh>@test p.iters and v.iters</vh>
<v t="EKR.20040527073459"><vh>child1</vh>
<v t="EKR.20040527072047"><vh>a</vh>
<v t="EKR.20040527072047.1"><vh>b</vh></v>
</v>
<v t="EKR.20040527074524"><vh>c</vh></v>
<v t="EKR.20040527072047"><vh>a</vh>
<v t="EKR.20040527072047.1"><vh>b</vh></v>
</v>
<v t="EKR.20040527074524.1"><vh>d</vh>
<v t="EKR.20040527074524.2"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040529105640"><vh>child2</vh></v>
<v t="EKR.20040529104307"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="EKR.20040527083449.1"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="EKR.20040527083449.2"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20040707091428.5"><vh>@test p.comparisons</vh></v>
<v t="ekr.20040707091428.6"><vh>@test that clones share subtrees</vh></v>
<v t="ekr.20040707091428.8"><vh>@test consistency of c.allNodes_iter() and p.ThreadNext()</vh></v>
<v t="ekr.20040707091428.9"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20040707091428.10"><vh>@test consistency of level</vh></v>
<v t="ekr.20040707091428.11"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20040707091428.12"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20040707091428.13"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20040707091428.14"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20040707091428.15"><vh>@test consistency of tnodeListAndParents</vh></v>
<v t="ekr.20040707091428.16"><vh>@test hasNextBack</vh></v>
<v t="ekr.20040707091428.17"><vh>@test hasParentChild</vh></v>
<v t="ekr.20040707091428.18"><vh>@test hasThreadNextBack</vh></v>
<v t="ekr.20040707091428.19"><vh>@test vnode list</vh></v>
</v>
</v>
<v t="ekr.20040707150427"><vh>Unfinished tests...</vh>
<v t="ekr.20040707140849.43"><vh>Outline tests (Sometimes fails)</vh>
<v t="ekr.20040708181226"><vh>test of p.copyTreeAfter and p.copyTreeFromSelfTo</vh>
<v t="ekr.20040708181226.1"><vh>root1</vh>
<v t="ekr.20040708181226.2"><vh>a</vh>
<v t="ekr.20040708185414"><vh>c</vh>
<v t="ekr.20040708203222"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20040708181226.3"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040708212348"><vh>Manual test of testUtils.replaceOutline</vh>
<v t="ekr.20040708214013"><vh>outline1</vh>
<v t="ekr.20040708214013.1"><vh>a</vh></v>
</v>
<v t="ekr.20040708213736"><vh>outline2</vh>
<v t="ekr.20040708213736.1"><vh>b</vh></v>
</v>
</v>
<v t="EKR.20040623223148.11"><vh>testUtils.replaceOutline</vh></v>
<v t="ekr.20040708174955" a="M"><vh>@@ suite Outline/Undo tests</vh>
<v t="ekr.20040707140849.44"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040707140849.45"><vh>class outlineTestCase</vh>
<v t="ekr.20040707140849.46"><vh>__init__</vh></v>
<v t="ekr.20040707140849.47"><vh>outlineCommand</vh></v>
<v t="ekr.20040707140849.48"><vh>runTest</vh></v>
<v t="ekr.20040707140849.49"><vh>setUp</vh></v>
<v t="ekr.20040707140849.50"><vh>tearDown</vh></v>
<v t="ekr.20040708175948"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040303063549.101"><vh>outlineTests</vh>
<v t="ekr.20040303063549.102"><vh>moveOutlineDown</vh>
<v t="ekr.20040708215633"><vh>before</vh>
<v t="ekr.20040708215633.1"><vh>a</vh></v>
<v t="ekr.20040708215633.2"><vh>move</vh></v>
<v t="ekr.20040708215633.3"><vh>b</vh></v>
</v>
<v t="ekr.20040303063549.107"><vh>after</vh>
<v t="ekr.20040303063549.108"><vh>a</vh></v>
<v t="ekr.20040303063549.109"><vh>b</vh></v>
<v t="ekr.20040303063549.110"><vh>move</vh></v>
</v>
<v t="ekr.20040303063549.111"><vh>ref</vh>
<v t="ekr.20040303063549.112"><vh>a</vh></v>
<v t="ekr.20040303063549.113"><vh>move</vh></v>
<v t="ekr.20040303063549.114"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040303063549.115"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040303063549.116"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040303063549.117"><vh>moveOutlineUp</vh></v>
</v>
</v>
<v t="ekr.20040708172357"><vh>Find Command tests...(Not finished)</vh>
<v t="ekr.20040707140849.19"><vh>@suite Find sommands tests</vh>
<v t="ekr.20040707140849.21"><vh>class findCommandTestCase</vh>
<v t="ekr.20040707140849.22"><vh>setUp</vh></v>
<v t="ekr.20040707140849.23"><vh>testFindCommand</vh></v>
<v t="ekr.20040707140849.24"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040707140849.25"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040708172802"><vh>findTests</vh></v>
</v>
<v t="ekr.20040707140849.51"><vh>test plugins (Not ready yet)</vh>
<v t="ekr.20040707151028"><vh>doPluginTest</vh></v>
</v>
<v t="EKR.20040623200709.75"><vh>OLD Plugin tests</vh>
<v t="EKR.20040623200709.76"><vh> makePluginsSuite</vh></v>
<v t="EKR.20040623200709.77"><vh>class pluginTestCase</vh>
<v t="EKR.20040623200709.78"><vh>__init__</vh></v>
<v t="EKR.20040623200709.79"><vh>pluginTest</vh></v>
<v t="EKR.20040623200709.80"><vh>runTest</vh></v>
<v t="EKR.20040623200709.81"><vh>setUp</vh></v>
<v t="EKR.20040623200709.82"><vh>shortDescription</vh></v>
<v t="EKR.20040623200709.83"><vh>tearDown</vh></v>
</v>
</v>
</v>
<v t="ekr.20040708214530"><vh>@test CheckOutline</vh></v>
<v t="ekr.20040710180851"><vh>Redundant: @suite run all doctests in @file nodes</vh></v>
<v t="ekr.20040711060313"><vh>@suite run all doctests in leo*.py</vh></v>
</v>
<v t="ekr.20040707071542.1"><vh>Do all @tests</vh></v>
<v t="ekr.20040707081532.1"><vh>Do @test</vh></v>
</v>
<v t="ekr.20040711100837"><vh>ihooks &amp; imp</vh>
<v t="ekr.20040711113027"><vh>@url http://docs.python.org/lib/module-imp.html</vh></v>
<v t="ekr.20040711100837.1"><vh>@url http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/59867</vh></v>
<v t="ekr.20040711095508.1"><vh>Python23/Lib/ihooks.py</vh>
<v t="ekr.20040711095508.2"><vh>&lt;&lt; ihooks declarations &gt;&gt;</vh></v>
<v t="ekr.20040711095508.3"><vh>class _Verbose</vh>
<v t="ekr.20040711095508.4"><vh>__init__</vh></v>
<v t="ekr.20040711095508.5"><vh>get_verbose</vh></v>
<v t="ekr.20040711095508.6"><vh>set_verbose</vh></v>
<v t="ekr.20040711095508.7"><vh>note</vh></v>
<v t="ekr.20040711095508.8"><vh>message</vh></v>
</v>
<v t="ekr.20040711095508.15"><vh>class Hooks (_Verbose)</vh>
<v t="ekr.20040711100837.2"><vh>imp interface</vh>
<v t="ekr.20040711095508.17"><vh>get_suffixes</vh></v>
<v t="ekr.20040711095508.18"><vh>new_module</vh></v>
<v t="ekr.20040711095508.19"><vh>is_builtin</vh></v>
<v t="ekr.20040711095508.20"><vh>init_builtin</vh></v>
<v t="ekr.20040711095508.21"><vh>is_frozen</vh></v>
<v t="ekr.20040711095508.22"><vh>init_frozen</vh></v>
<v t="ekr.20040711095508.23"><vh>get_frozen_object</vh></v>
<v t="ekr.20040711095508.24" a="M"><vh>load_source  (do I want ot override this?)</vh></v>
<v t="ekr.20040711095508.25"><vh>load_compiled</vh></v>
<v t="ekr.20040711095508.26"><vh>load_dynamic</vh></v>
<v t="ekr.20040711095508.27"><vh>load_package</vh></v>
<v t="ekr.20040711095508.28"><vh>add_module</vh></v>
</v>
<v t="ekr.20040711101236"><vh>sys interface</vh>
<v t="ekr.20040711095508.29"><vh>modules_dict</vh></v>
<v t="ekr.20040711095508.30"><vh>default_path</vh></v>
<v t="ekr.20040711095508.31"><vh>path_split</vh></v>
<v t="ekr.20040711095508.32"><vh>path_join</vh></v>
<v t="ekr.20040711095508.33"><vh>path_isabs</vh></v>
<v t="ekr.20040711095508.34"><vh>path_exists</vh></v>
<v t="ekr.20040711095508.35"><vh>path_isdir</vh></v>
<v t="ekr.20040711095508.36"><vh>path_isfile</vh></v>
<v t="ekr.20040711095508.37"><vh>path_islink</vh></v>
</v>
<v t="ekr.20040711095508.38"><vh>openfile</vh></v>
<v t="ekr.20040711095508.39"><vh>listdir</vh></v>
</v>
<v t="ekr.20040711101642"><vh>Loaders...</vh>
<v t="ekr.20040711095508.9"><vh>class BasicModuleLoader (_Verbose)</vh>
<v t="ekr.20040711095508.10"><vh>find_module</vh></v>
<v t="ekr.20040711095508.11"><vh>default_path</vh></v>
<v t="ekr.20040711095508.12"><vh>find_module_in_dir</vh></v>
<v t="ekr.20040711095508.13"><vh>find_builtin_module</vh></v>
<v t="ekr.20040711095508.14"><vh>load_module</vh></v>
</v>
<v t="ekr.20040711095508.40"><vh>class ModuleLoader (BasicModuleLoader)</vh>
<v t="ekr.20040711095508.41"><vh>__init__</vh></v>
<v t="ekr.20040711095508.42"><vh>default_path</vh></v>
<v t="ekr.20040711095508.43"><vh>modules_dict</vh></v>
<v t="ekr.20040711095508.44"><vh>get_hooks</vh></v>
<v t="ekr.20040711095508.45"><vh>set_hooks</vh></v>
<v t="ekr.20040711095508.46"><vh>find_builtin_module</vh></v>
<v t="ekr.20040711095508.47"><vh>find_module_in_dir</vh></v>
<v t="ekr.20040711095508.48" a="M"><vh>load_module</vh></v>
</v>
<v t="ekr.20040711095508.49"><vh>class FancyModuleLoader (ModuleLoader)</vh>
<v t="ekr.20040711095508.50"><vh>load_module</vh></v>
</v>
</v>
<v t="ekr.20040711101642.1"><vh>Importers...</vh>
<v t="ekr.20040711095508.51"><vh>class BasicModuleImporter (_Verbose)</vh>
<v t="ekr.20040711095508.52"><vh>__init__</vh></v>
<v t="ekr.20040711100837.3"><vh>getters/settesr</vh>
<v t="ekr.20040711095508.53"><vh>get_loader</vh></v>
<v t="ekr.20040711095508.54"><vh>set_loader</vh></v>
<v t="ekr.20040711095508.55"><vh>get_hooks</vh></v>
<v t="ekr.20040711095508.56"><vh>set_hooks</vh></v>
</v>
<v t="ekr.20040711095508.57"><vh>import_module</vh></v>
<v t="ekr.20040711095508.58"><vh>reload</vh></v>
<v t="ekr.20040711095508.59"><vh>unload</vh></v>
<v t="ekr.20040711095508.60"><vh>install</vh></v>
<v t="ekr.20040711095508.61"><vh>uninstall</vh></v>
</v>
<v t="ekr.20040711095508.62"><vh>class ModuleImporter (BasicModuleImporter)</vh>
<v t="ekr.20040711095508.63"><vh>import_module</vh></v>
<v t="ekr.20040711095508.64"><vh>determine_parent</vh></v>
<v t="ekr.20040711095508.65"><vh>find_head_package</vh></v>
<v t="ekr.20040711095508.66"><vh>load_tail</vh></v>
<v t="ekr.20040711095508.67"><vh>ensure_fromlist</vh></v>
<v t="ekr.20040711095508.68"><vh>import_it</vh></v>
<v t="ekr.20040711095508.69"><vh>reload</vh></v>
</v>
</v>
<v t="ekr.20040711095508.70"><vh>install</vh></v>
<v t="ekr.20040711095508.71"><vh>uninstall</vh></v>
</v>
<v t="ekr.20040711113027.1"><vh>import.c (contains imp module)</vh>
<v t="ekr.20040711113027.2"><vh>&lt;&lt; import #includes &gt;&gt;</vh></v>
<v t="ekr.20040711113027.3"><vh>&lt;&lt; import declarations &gt;&gt;</vh></v>
<v t="ekr.20040711113027.4"><vh>_PyImport_Init</vh></v>
<v t="ekr.20040711113027.5"><vh>_PyImportHooks_Init</vh></v>
<v t="ekr.20040711113027.6"><vh>_PyImport_Fini</vh></v>
<v t="ekr.20040711113846"><vh>Locks...</vh>
<v t="ekr.20040711113027.7"><vh>lock_import</vh></v>
<v t="ekr.20040711113027.8"><vh>unlock_import</vh></v>
<v t="ekr.20040711113027.9"><vh>imp_lock_held</vh></v>
<v t="ekr.20040711113027.10"><vh>imp_acquire_lock</vh></v>
<v t="ekr.20040711113027.11"><vh>imp_release_lock</vh></v>
</v>
<v t="ekr.20040711113027.12"><vh>PyImport_GetModuleDict</vh></v>
<v t="ekr.20040711113027.13"><vh>PyImport_Cleanup</vh></v>
<v t="ekr.20040711113027.14"><vh>PyImport_GetMagicNumber</vh></v>
<v t="ekr.20040711113027.15"><vh>_PyImport_FixupExtension</vh></v>
<v t="ekr.20040711113027.16"><vh>_PyImport_FindExtension</vh></v>
<v t="ekr.20040711113027.17"><vh>PyImport_AddModule</vh></v>
<v t="ekr.20040711113027.18"><vh>PyImport_ExecCodeModule</vh></v>
<v t="ekr.20040711113027.19"><vh>PyImport_ExecCodeModuleEx</vh></v>
<v t="ekr.20040711113027.20"><vh>make_compiled_pathname</vh></v>
<v t="ekr.20040711113027.21"><vh>check_compiled_module</vh></v>
<v t="ekr.20040711113027.22"><vh>read_compiled_module</vh></v>
<v t="ekr.20040711113027.23"><vh>load_compiled_module</vh></v>
<v t="ekr.20040711113027.24"><vh>parse_source_module</vh></v>
<v t="ekr.20040711113027.25"><vh>open_exclusive</vh></v>
<v t="ekr.20040711113027.26"><vh>write_compiled_module</vh></v>
<v t="ekr.20040711113027.27"><vh>load_source_module</vh></v>
<v t="ekr.20040711113027.28"><vh>load_package</vh></v>
<v t="ekr.20040711113027.29"><vh>is_builtin</vh></v>
<v t="ekr.20040711113027.30"><vh>get_path_importer</vh></v>
<v t="ekr.20040711113027.31"><vh>find_module</vh></v>
<v t="ekr.20040711113027.32"><vh>case_ok</vh></v>
<v t="ekr.20040711113027.33"><vh>find_init_module</vh></v>
<v t="ekr.20040711113027.35" a="M"><vh>load_module</vh></v>
<v t="ekr.20040711113027.36"><vh>init_builtin</vh></v>
<v t="ekr.20040711113027.37"><vh>find_frozen</vh></v>
<v t="ekr.20040711113027.38"><vh>get_frozen_object</vh></v>
<v t="ekr.20040711113027.39"><vh>PyImport_ImportFrozenModule</vh></v>
<v t="ekr.20040711113027.40"><vh>PyImport_ImportModule</vh></v>
<v t="ekr.20040711113027.41"><vh>import_module_ex</vh></v>
<v t="ekr.20040711113027.42"><vh>PyImport_ImportModuleEx</vh></v>
<v t="ekr.20040711113027.43"><vh>get_parent</vh></v>
<v t="ekr.20040711113027.44"><vh>load_next</vh></v>
<v t="ekr.20040711113027.45"><vh>mark_miss</vh></v>
<v t="ekr.20040711113027.46"><vh>ensure_fromlist</vh></v>
<v t="ekr.20040711113027.47"><vh>add_submodule</vh></v>
<v t="ekr.20040711113027.48"><vh>import_submodule</vh></v>
<v t="ekr.20040711113027.49"><vh>PyImport_ReloadModule</vh></v>
<v t="ekr.20040711113027.50"><vh>PyImport_Import</vh></v>
<v t="ekr.20040711113356"><vh>imp...</vh>
<v t="ekr.20040711113027.51"><vh>imp_get_magic</vh></v>
<v t="ekr.20040711113027.52"><vh>imp_get_suffixes</vh></v>
<v t="ekr.20040711113027.53"><vh>call_find_module</vh></v>
<v t="ekr.20040711113027.54"><vh>imp_find_module</vh></v>
<v t="ekr.20040711113027.55"><vh>imp_init_builtin</vh></v>
<v t="ekr.20040711113027.56"><vh>imp_init_frozen</vh></v>
<v t="ekr.20040711113027.57"><vh>imp_get_frozen_object</vh></v>
<v t="ekr.20040711113027.58"><vh>imp_is_builtin</vh></v>
<v t="ekr.20040711113027.59"><vh>imp_is_frozen</vh></v>
<v t="ekr.20040711113027.60" a="M"><vh>get_file (called from imp_load_module)</vh></v>
<v t="ekr.20040711113027.61"><vh>imp_load_compiled</vh></v>
<v t="ekr.20040711113027.62"><vh>imp_load_dynamic</vh></v>
<v t="ekr.20040711113027.63" a="M"><vh>imp_load_source</vh></v>
<v t="ekr.20040711113027.64" a="M"><vh>imp_load_module:calls load_module</vh></v>
<v t="ekr.20040711113027.65"><vh>imp_load_package</vh></v>
<v t="ekr.20040711113027.66"><vh>imp_new_module</vh></v>
</v>
<v t="ekr.20040711113356.1"><vh>doc strings</vh></v>
<v t="ekr.20040711113356.2"><vh>module table</vh></v>
<v t="ekr.20040711113027.67"><vh>setint</vh></v>
<v t="ekr.20040711113027.68"><vh>initimp</vh></v>
<v t="ekr.20040711113027.69"><vh>PyImport_ExtendInittab</vh></v>
<v t="ekr.20040711113027.70"><vh>PyImport_AppendInittab</vh></v>
</v>
<v t="ekr.20040711134323"><vh>Python23/Lib/test/test_imp.py (just checks locks)</vh>
<v t="ekr.20040711134323.2"><vh>verify_lock_state</vh></v>
<v t="ekr.20040711134323.3"><vh>testLock</vh></v>
<v t="ekr.20040711134323.4"><vh>test_main</vh></v>
</v>
</v>
<v t="EKR.20040612095237"><vh>Prototypes of new commands</vh>
<v t="ekr.20040402043516"><vh>A pretty printer for Leo</vh>
<v t="ekr.20040402084155"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040402064301" a="E"><vh>class prettyPrinter</vh>
<v t="ekr.20040402064301.1"><vh>__init__</vh></v>
<v t="ekr.20040402074431.1"><vh>dumpToken</vh></v>
<v t="ekr.20040402093822"><vh>get</vh></v>
<v t="ekr.20040402072335"><vh>put</vh></v>
<v t="ekr.20040402074431"><vh>putNormalToken</vh></v>
<v t="ekr.20040402081135"><vh>putOperator</vh></v>
<v t="ekr.20040402080311"><vh>putToken</vh></v>
</v>
</v>
<v t="EKR.20040610201941" a="E"><vh>Check Syntax prototype</vh>
<v t="EKR.20040610192622"><vh>Check Syntax script</vh></v>
<v t="EKR.20040610192622.1"><vh>Check Syntax data</vh></v>
</v>
<v t="EKR.20040610201236"><vh>Tabnanny prototype</vh>
<v t="EKR.20040610194209" a="E"><vh>TabNanny script</vh>
<v t="EKR.20040610195543"><vh>checkString</vh></v>
</v>
<v t="EKR.20040610195543.1"><vh>tabnanny.py (reference only) (good)</vh>
<v t="EKR.20040610195543.2"><vh>&lt;&lt; tabnanny declarations &gt;&gt;</vh></v>
<v t="EKR.20040610195543.3"><vh>errprint</vh></v>
<v t="EKR.20040610195543.4"><vh>main</vh></v>
<v t="EKR.20040610195543.5"><vh>class NannyNag</vh>
<v t="EKR.20040610195543.6"><vh>__init__</vh></v>
<v t="EKR.20040610195543.7"><vh>get_lineno</vh></v>
<v t="EKR.20040610195543.8"><vh>get_msg</vh></v>
<v t="EKR.20040610195543.9"><vh>get_line</vh></v>
</v>
<v t="EKR.20040610195543.10"><vh>check</vh></v>
<v t="EKR.20040610195543.11"><vh>class Whitespace</vh>
<v t="EKR.20040610195543.12"><vh>&lt;&lt; class Whitespace declarations &gt;&gt;</vh></v>
<v t="EKR.20040610195543.13"><vh>__init__</vh></v>
<v t="EKR.20040610195543.14"><vh>longest_run_of_spaces</vh></v>
<v t="EKR.20040610195543.15"><vh>indent_level</vh></v>
<v t="EKR.20040610195543.16"><vh>equal</vh></v>
<v t="EKR.20040610195543.17"><vh>not_equal_witness</vh></v>
<v t="EKR.20040610195543.18"><vh>less</vh></v>
<v t="EKR.20040610195543.19"><vh>not_less_witness</vh></v>
</v>
<v t="EKR.20040610195543.20"><vh>format_witnesses</vh></v>
<v t="EKR.20040610195543.21"><vh>process_tokens</vh></v>
</v>
<v t="EKR.20040610194209.1"><vh>TabNanny data (bad)</vh></v>
</v>
<v t="ekr.20040711085843" a="M"><vh>Use parser module to simulate import from string</vh>
<v t="ekr.20040711092603"><vh>test1</vh></v>
</v>
<v t="ekr.20040711093916"><vh>Subclass the file type for use with imp module</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="EKR.20040424065452">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
lines1 = f1.readlines()
lines2 = f2.readlines()
f1.close() ; f2.close()

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
text1 = f1.read()
text2 = f2.read()
f1.close() ; f2.close()

cr1 = text1.count('\r')
cr2 = text2.count('\r')

print '-'*20
print "lines ",len(lines1),len(lines2)
print "chars ",len(text1),len(text2)
print "non-cr",len(text1)-cr1,len(text2)-cr2
print "cr    ",cr1,cr2</t>
<t tx="EKR.20040424091411">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
g.es("equal (raw mode)",f1.read()==f2.read())
f1.close() ; f2.close()

f1 = open(p1) ; f2 = open(p2)
g.es("equal (text mode)",f1.read()==f2.read())
f1.close() ; f2.close()</t>
<t tx="EKR.20040427092657">@ignore

root line 1

@others

root after at-others

&lt;&lt; ref &gt;&gt;
</t>
<t tx="EKR.20040427092657.1">node 1 line 1

&lt;&lt; node 1 ref &gt;&gt;

node 1 last line</t>
<t tx="EKR.20040427092657.2">ref line 1

@others</t>
<t tx="EKR.20040428145741">node 1 ref line 1

@others</t>
<t tx="EKR.20040428145741.1"></t>
<t tx="EKR.20040428145741.2"></t>
<t tx="EKR.20040428145826"></t>
<t tx="EKR.20040428145826.1"></t>
<t tx="EKR.20040428150018">text of organizer node</t>
<t tx="EKR.20040430160416.1">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="EKR.20040430160416.2">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="EKR.20040430160416.3">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="EKR.20040430160416.4">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="EKR.20040430160416.5">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="EKR.20040430160416.6">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="EKR.20040430160416.7">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="EKR.20040430160416.8">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="EKR.20040430160416.9">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="EKR.20040430160416.10">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="EKR.20040430160416.11">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="EKR.20040430160416.12">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="EKR.20040430160416.13">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="EKR.20040430160416.14">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="EKR.20040430162649.1"></t>
<t tx="EKR.20040430162649.2"></t>
<t tx="EKR.20040430162649.3">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.4">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.5">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.6">@ignore

Ä á Û</t>
<t tx="EKR.20040430162649.7">@encoding iso-8859-1</t>
<t tx="EKR.20040430162649.8"></t>
<t tx="EKR.20040430162649.9"></t>
<t tx="EKR.20040430162649.10">@encoding cp1252
@others</t>
<t tx="EKR.20040430162649.11">aÖb</t>
<t tx="EKR.20040430162649.12">@ignore</t>
<t tx="EKR.20040430162649.13">@language perlpod
@path c:\prog\test</t>
<t tx="EKR.20040430162649.14">@root perlpod.txt
@ Multi-line
doc part
&lt;&lt;ref&gt;&gt;</t>
<t tx="EKR.20040430162649.15">@ doc part2
@c
code line1
code line2
@ more doc part</t>
<t tx="EKR.20040430162649.16">@comment REM_</t>
<t tx="EKR.20040430162649.17">test 6</t>
<t tx="EKR.20040430162649.19">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
ths continues */

More plain text.</t>
<t tx="EKR.20040430162649.20">@ atFile.directiveKind is return miscDirective on _any_ line that starts with @</t>
<t tx="EKR.20040430162649.21">@ignore

line 1
@line 2
    @line 3
line 4</t>
<t tx="EKR.20040430162649.22">@nocolor
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
    
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
     a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="EKR.20040430162649.23">@ignore</t>
<t tx="EKR.20040430162649.24">enabling: *
Exception in Tkinter callback
Traceback (most recent call last):
  File "c:\python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "leoFrame.py", line 1368, in OnTangle
    self.commands.tangleCommands.tangle()
  File "leoTangle.py", line 507, in tangle
    self.tangleTree(v,report_errors)
  File "leoTangle.py", line 644, in tangleTree
    self.tanglePass1(v) # sets self.v
  File "leoTangle.py", line 589, in tanglePass1
    self.skip_body(v)
  File "leoTangle.py", line 1062, in skip_body
    self.st_enter_root_name(old_root_name,code,doc)
  File "leoTangle.py", line 2040, in st_enter_root_name
    assert(code)
AssertionError
</t>
<t tx="EKR.20040430162649.25">@root a.txt
@ 

@root a.txt 
some text 
@ </t>
<t tx="EKR.20040504083716">@language python

import leoGlobals as g
import shutil

testing = True

sourcedir=r"c:/prog/test/perfectImport"
targetdir=r"c:/prog/test/perfectImport/leo"
s1 = g.os_path_join(sourcedir,"leoAtFile.py")
t1 = g.os_path_join(targetdir,"leoAtFile.py")
files = [(s1,t1)]

@others

print ; print '-' * 20

sync(files) # push or pull, depending on date.
</t>
<t tx="EKR.20040504083716.39">def sync(files):
    
    """Do a pull or a push, depending on the date of the files."""
    
    none, push, pull = 'None', 'push', 'pull'
    mu = g.mulderUpdateAlgorithm()

    for sourcefilename, targetfilename in files:
        &lt;&lt; compute sourcetime and targettime &gt;&gt;
        &lt;&lt; compute operation &gt;&gt;
        if operation == push:
            if testing: print push, sourcefilename, targetfilename
            strippedLines = mu.removeSentinelsFromFile(sourcefilename)
            mu.write_if_changed(strippedLines,sourcefilename,targetfilename)
            mu.copy_time(sourcefilename,targetfilename)
        elif operation == pull:
            if testing: print pull, sourcefilename, targetfilename
            if sourcetime:
                mu.propagateDiffsToSentinelsFile(sourcefilename,targetfilename)
                mu.copy_time(targetfilename,sourcefilename)
            else:
                shutil.copy2(targetfilename,sourcefilename)</t>
<t tx="EKR.20040504083716.44"># This is some basic testing.

@ignore</t>
<t tx="EKR.20040504083716.45">@others</t>
<t tx="EKR.20040504083716.47">class sentinel_test(TestCase):
    @others</t>
<t tx="EKR.20040504083716.48">def setUp(self):
    self.prefix = ["#@+leo-ver=4\n",
"#@+node:@file sentinel.py\n",
"#@@language python\n"]
    self.postfix = ["#@-node:@file sentinel.py\n",
"#@-leo\n"]
</t>
<t tx="EKR.20040504083716.49">def setup_inputfile(self, input):
    classname = self.__class__.__name__
    self.input_filename = os.path.join('test/s_%s.txt' % classname)
    self.output_filename = os.path.join('test/d_%s.txt' % classname)
    outfile = file(self.input_filename, "w")
    for line in input:
        outfile.write(line)
    outfile.close()
    
    
 
</t>
<t tx="EKR.20040504083716.50">def setup_configfile(self):
    self.configfilename = "test/sentinel.cfg"
    outfile = file(self.configfilename, "w")
    outfile.write("[sentinel]\n")
    outfile.write("\ns1=%s\n" % self.input_filename)
    outfile.write("\nd1=%s\n" % self.output_filename)
    outfile.close()

</t>
<t tx="EKR.20040504083716.51"></t>
<t tx="EKR.20040504083716.52">class insert_test(sentinel_test):
    @others</t>
<t tx="EKR.20040504083716.53">def setUp(self):
    sentinel_test.setUp(self)
    self.setup_inputfile(self.prefix + 
["Proof of concept implementation of sentinel free Leo files.\n",
"We try to insert a line after here\n",
"This should be after the inserted line\n",
"This should be the last line in the file\n"]
 + self.postfix)

    # here are the same lines, without sentinels
    self.lines = ["Proof of concept implementation of sentinel free Leo files.\n",
     "We try to insert a line after here\n",
     "This should be after the inserted line\n",
     "This should be the last line in the file\n"]
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.54">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert one line in the sentinel free output.
    lines = self.lines
    lines[2:2] = ["This is an inserted line\n"]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.55"></t>
<t tx="EKR.20040504083716.56">class replace_test(sentinel_test):
    """
    Replace a single line.
    """
    @others</t>
<t tx="EKR.20040504083716.57">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
     "Proof of concept implementation of sentinel free Leo files.\n",
     "This line should be replaced\n",
     "This should be the last line in the file\n"]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.58">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert one line in the sentinel free output.
    lines = self.lines
    lines[2:2] = ["This is a replaced line\n"]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.59">class replace_test2(sentinel_test):
    """
    Replace two lines.
    """
    @others</t>
<t tx="EKR.20040504083716.60">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "Line 0\n",    #0
"   Line 1\n",    #1
"   Line 2.\n",   #2
"   Line 3.\n",   #3
"   Line 4\n",    #4
"\n", #5
" We have two subclasses:\n", #6
"   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #7
"   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #8
"\n", #9
" Line 10\n", #10
" Line 11\n" #11
]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.61">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert two lines in the sentinel free output.
    lines = self.lines
    lines[7:9] = ["   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #7
                      "   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.\n", #8
                     ]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.62">class replace_test3(sentinel_test):
    """
    Replace the lines of a whole node.
    """
    @others</t>
<t tx="EKR.20040504083716.63">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "#@+node:main\n",
    "node 1: line 1\n", # 1
    "node 1: line 2\n", # 2
    "#@-node:main\n",
    "#@-others\n",
    "node 2: line 3\n", # 3
    "node 2: line 4\n", # 4
    "#@-node:@file sentinel.py\n",
    ]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.64">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    filtered_lines = sentinel.push_filter_lines(self.lines)[0]
    assert file(self.output_filename).readlines() == filtered_lines
    
    # then insert one line in the sentinel free output.
    filtered_lines [2:4] = [   "These lines should be totally different\n",
    "and be replaced across sentinel blocks,\n",

                     ]
    outfile = file(self.output_filename, "w")
    for line in filtered_lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == filtered_lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.65">class replace_test4(sentinel_test):
    """
    Replace the lines of a whole node.
    """
    @others</t>
<t tx="EKR.20040504083716.66">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "#@+node:main\n",
    "node 1: line 1\n", # 1
    "node 1: line 2\n", # 2
    "#@-node:main\n",
    "#@-others\n",
    "node 2: line 3\n", # 3
    "node 2: line 4\n", # 4
    "#@-node:@file sentinel.py\n",
    ]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.67">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    filtered_lines = sentinel.push_filter_lines(self.lines)[0]
    assert file(self.output_filename).readlines() == filtered_lines
    
    # then insert one line in the sentinel free output.
    filtered_lines [1:3] = [   "These lines should be totally different\n",
    "and be replaced across sentinel blocks,\n",

                     ]
    outfile = file(self.output_filename, "w")
    for line in filtered_lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == filtered_lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.68">@doc
these are tests representing errors which I encountered during the development of the code.</t>
<t tx="EKR.20040504083716.69">class regression_test_1(sentinel_test):
    """
    Replace a single line.
    """
    @others</t>
<t tx="EKR.20040504083716.70">def setUp(self):
    self.lines = [
"#@+leo-ver=4\n",
"#@+node:@file driver.py\n",
"#@@language python\n",
"#@+others\n",
"#@+node:imports\n",
"# Analyse an IA64 assembly file:\n",
"#   1. Identify basic blocks.\n",
"#   2. Track the contents of registers symbolically.\n",
"import os, sys, cmp_globals\n",
"\n",
"#@-node:imports\n",
"#@+node:process_file\n",
"def process_file(infile, pyname_full, configfile, firststep, laststep):\n",
"   \n",
"      proc()\n",
"#@nonl\n",
"#@-node:process_file\n",
"#@-others\n",
"#@-node:@file driver.py\n",
"#@-leo\n"
]
    self.setup_inputfile(self.lines)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.71">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == sentinel.push_filter_lines(self.lines)[0]
        
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # Now check that the source has not been changed.
    assert file(self.input_filename).readlines() == self.lines   
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.72">if __name__ == '__main__':
    #fileName = os.path.join(os.getcwd(),"testing.ini")
    #config = ConfigParser.ConfigParser()
    #config.read(fileName)
    #main = "Main"
    #leodir = config.get(main, "leodir")
    #test_to_run = config.get(main, "test_to_run")
    test_to_run = 'all'
    
    if os.path.exists("test"):
        shutil.rmtree("test")
    os.mkdir("test")
    suite = TestSuite()
    if test_to_run == 'all':
        for testclass in (
            insert_test,
            replace_test,
            replace_test2,
            replace_test3,
            regression_test_1,         
        ):
            suite.addTest(testclass())
    else:
        suite.addTest(globals()[test_to_run]())
    testrunner = TextTestRunner()
    testrunner.run(suite)
 </t>
<t tx="EKR.20040504083716.73">@ignore</t>
<t tx="EKR.20040504083716.74">[Main]
test_to_run = all
# use all to run all tests.

cleanup = True
# Set to True if you want all files deleted.

leodir = C:/bwm/ftptoot/Cleo-4.1-beta-5</t>
<t tx="EKR.20040504083716.75"></t>
<t tx="EKR.20040504083716.76"></t>
<t tx="EKR.20040504083716.77"></t>
<t tx="EKR.20040504083716.78"></t>
<t tx="EKR.20040504153320">sourcetime = targettime = None

if g.os_path_exists(sourcefilename):
    sourcetime = g.os_path_getmtime(sourcefilename)

if g.os_path_exists(targetfilename):
    targettime = g.os_path_getmtime(targetfilename)</t>
<t tx="EKR.20040504153320.1">operation = None
if sourcetime:
    if targettime:
        if sourcetime &gt; targettime:
            operation = push
        elif sourcetime &lt; targettime:
            operation = pull
    else:
        operation = push
elif targettime:
    operation = pull</t>
<t tx="EKR.20040517074600.8">import leoGlobals as g
import leoTest

u = leoTest.testUtils()
nodes = 0 ; lines = 0
c = g.top()
c.clearAllVisited()
v = u.findNodeAnywhere(c,"Plugins &amp; scripts")
after = v.nodeAfterTree()
trace(v,after)
while v and v != after:
    if not v.t.isVisited():
        v.t.setVisited()
        nodes += 1
        lines += len(splitLines(v.bodyString()))
    v = v.threadNext()
    
pages = ((nodes * 10) + lines) / 50
print "nodes,lines,pages",nodes,lines,pages
g.es("nodes,lines,pages",nodes,lines,pages)</t>
<t tx="EKR.20040517074600.9"></t>
<t tx="EKR.20040517074600.10">import leoGlobals as g
config = g.app.config

font = config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        tag = "body")
        
print font

c = top() ; body = c.frame.body.bodyCtrl

print body

# body.configure(font=font)</t>
<t tx="EKR.20040517074600.11">import leoGlobals as g
import tkFont

@others

c = g.top()

# Body pane.
fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
print "body:",fn,name,size,slant,weight

if 0:

    # Log pane.
    fn = c.frame.log.getFontConfig()
    font = tkFont.Font(font=fn)
    name,size,slant,weight = getFontSettings(font)
    g.es("log:" + name + "," + `size` + "," + slant + "," + weight)
    
    # Tree pane.
    font = c.frame.tree.getFont()
    name,size,slant,weight = getFontSettings(font)
    g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="EKR.20040517074600.12">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="EKR.20040517074600.13">import leoGlobals as g

font = g.app.config.defaultFont

print font.cget("family"), font.cget("weight")</t>
<t tx="EKR.20040520104329"></t>
<t tx="EKR.20040523112430"></t>
<t tx="EKR.20040523112430.1"></t>
<t tx="EKR.20040523112430.2"></t>
<t tx="EKR.20040523112430.3"></t>
<t tx="EKR.20040523112430.4"></t>
<t tx="EKR.20040523112430.5"></t>
<t tx="EKR.20040523112430.6"></t>
<t tx="EKR.20040523112430.7"></t>
<t tx="EKR.20040523112430.8"></t>
<t tx="EKR.20040524050419">line 1
@others
&lt;&lt; defined in grandchild &gt;&gt;
last line</t>
<t tx="EKR.20040524050419.1">Organizer line</t>
<t tx="EKR.20040524050419.2">grandChild line</t>
<t tx="EKR.20040524050438"></t>
<t tx="EKR.20040525083635">@others</t>
<t tx="EKR.20040525083635.1"></t>
<t tx="EKR.20040526094831">import leoGlobals as g

def redoBletch(self):
    g.trace()
    
def undoBletch(self):
    g.trace()
    
c = g.top() ; u = c.undoer
p = c.currentPosition()

if 0:
    # bad functions
    u.registerUndoHandlers("Bletch","abc","xyz")
else:
    u.registerUndoHandlers("Bletch",undoBletch,redoBletch)
    
# "Execute" the Bletch command :-)  The Edit command should contain "Undo Bletch"
u.setUndoParams("Bletch",p)

# Selecting "Undo Bletch" will enable "Redo Bletch", etc.</t>
<t tx="EKR.20040526193608">import leoGlobals as g
import binascii
import pickle

d = { "a":True }

print '-' * 40

s = pickle.dumps(d,bin=True)
s2 = binascii.hexlify(s)
print `s`,s2

s3 = binascii.unhexlify(s2)
d2 = cPickle.loads(s3)

print `d2`
print d == d2, d is d2</t>
<t tx="EKR.20040526200017">import leoGlobals as g

c = g.top() ; p = c.currentPosition()


d = { "a":True }

if 1:
    # Warning: executing this in the a2 code base will cause any save operation to fail.
    p.v.unknownAttributes = { "myPlugin" : d }
    
print repr(p.v.unknownAttributes)</t>
<t tx="EKR.20040527072047"></t>
<t tx="EKR.20040527072047.1"></t>
<t tx="EKR.20040527073459"></t>
<t tx="EKR.20040527074524"></t>
<t tx="EKR.20040527074524.1"></t>
<t tx="EKR.20040527074524.2"></t>
<t tx="EKR.20040527083449.1">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="EKR.20040527083449.2">if 0:
    for v in current.vnodes_iter(): print v
    for v in current.unique_vnodes_iter(): print v

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print v
    for t in root.tnodes_iter(): print t

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print v
    for t in child.tnodes_iter(): print t</t>
<t tx="EKR.20040527154402">line 1

&lt;&lt; sec &gt;&gt;
sec line 1
sec line 2

last line</t>
<t tx="EKR.20040528130659">d</t>
<t tx="EKR.20040528152529">import leoNodes
import leoGlobals as g

c = g.top()
current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print v
    for v in vList2: print v

if 0:
    print len(allList),len(vList1),len(vList2)

&lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="EKR.20040529092739">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
    print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

if 0: # all nodes
    for v in c.all_vnodes_iter(): print v
    for t in c.all_tnodes_iter(): print t
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print v
    for t in c.all_unique_tnodes_iter(): print t</t>
<t tx="EKR.20040529093047">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"</t>
<t tx="EKR.20040529093047.1">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="EKR.20040529104307">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    # print "consistency tests pass"

except AssertionError:
    print tag
    print "list1"
    for v in list1: print v
    print "list2"
    for v in list2: print v
    raise</t>
<t tx="EKR.20040529105640"></t>
<t tx="EKR.20040531110157">@ignore</t>
<t tx="EKR.20040602101648">import leoGlobals as g
import leoPlugins

def onEnd (tag,keys):
    print "onEnd",tag,keys
    
count = 0
    
def onIdle (tag,keys):
    global count ; count += 1
    if count % 10 == 0:
        print "onIdle",count,keys.get("c")

leoPlugins.registerHandler("end1", onEnd)
print "onEnd registered as end1 hook"

leoPlugins.registerHandler("idle", onIdle)
print "onIdle registered as idle hook"</t>
<t tx="EKR.20040603064545">import leoGlobals as g

c = g.top()

for p in c.all_positions_iter():
    print p.v.t.fileIndex</t>
<t tx="EKR.20040603103118">@language html

b = "cd"
d
</t>
<t tx="EKR.20040603174633">import leoGlobals as g
c = g.top()
print c.frame.bodyCtrl.focus()</t>
<t tx="EKR.20040604082113">@tabwidth -4

    
    a   b   c
a   b   c   d
aa  b   c   d
aaa b   c   d
end</t>
<t tx="EKR.20040604170105">import leoGlobals as g
import os

c = g.top()

print os.getcwd()
name = g.os_path_join("test","removeSentTest.txt")
c.importCommands.removeSentinelsCommand(name)</t>
<t tx="EKR.20040605200750">string.join

__add__

'a'.__add__


def test(a,b): pass

v.copyTree(self,root)</t>
<t tx="EKR.20040606204316">@ignore</t>
<t tx="EKR.20040606204316.1"></t>
<t tx="EKR.20040608092841">@tabwidth -4

    a
    b</t>
<t tx="EKR.20040608095146">@language python
@tabwidth -4</t>
<t tx="EKR.20040608095146.1">@ignore
@language html

&lt;!--- Get all records from the database that match this users credentials ---&gt;
&lt;cfquery name="qLoginVerify" datasource="xxxx"&gt;
SELECT user_name, user_pass, course_dir
FROM login
WHERE user_name = '#user_name#'
AND user_pass = '#user_pass#'
AND course_dir = '#course_dir#'
&lt;/cfquery&gt;

&lt;cfif qLoginVerify.RecordCount&gt;
&lt;!--- This user has logged in correctly; 
change the value of the session.allowin value ---&gt;
&lt;cfset session.allowin = session.directoryshort&gt;
&lt;/cfif&gt;

&lt;!--- now redirect to "index.cfm", which will go to login if problem ---&gt;

&lt;cflocation url="#session.location#"&gt;
</t>
<t tx="EKR.20040610092248">@killcolor

Note: Previously, one could crash Leo by pasting a large text into a headline.  Leo now truncates that text, and furthermore Leo no longer makes all headline text into one gigantic line.  Therefore, we don't have to test Tk's ability to handle super-long lines.

The test:  Copy the following and paste it into a headline.  Leo should give 2 truncation messages:

- Truncating headline to one line.
- Truncating headline to 250 characters.

About a year ago I found the website at www.literateprogamming.com and was immediately convinced that the basic idea of Literate Programming is an important breakthrough. At the time I was working on a contract trying to decipher a true masterpiece of over-engineering, and if at any time during the construction of this masterpiece the perpetrators had been required to explain themselves in English, my client would have saved millions of dollars.

I never did try CWEB or NOWEB though, because on the literate programming site I read about a tool named “Leo” that combined outlines with Literate Programming techniques. Since I’ve always found outlining tools very useful I downloaded and tried this. I found that using this tool completely changed my programming practice and brought out all of the power inherent in the original Literate Programming idea as I understood it.</t>
<t tx="EKR.20040610131858"></t>
<t tx="EKR.20040610131858.1">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

print p.v.t.fileIndex,p.v.t</t>
<t tx="EKR.20040610132739">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="1" tnodes="1" max_tnode_index="1"/&gt;
&lt;vnodes&gt;
&lt;v t="EKR.20040610131858.1" a="TV"&gt;&lt;vh&gt;a&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="EKR.20040610131858.1"&gt;import leoGlobals as g

c = g.top() ; p = c.currentPosition()

print p.v.t.fileIndex&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="EKR.20040610143643"></t>
<t tx="EKR.20040610192622">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

import compiler

next = p.next()
s = next.bodyString()
headline = next.headString()

try:
    val = compiler.parse(s)
    # print val
    g.es("Syntax OK: %s" % headline,color="blue")
except SyntaxError:
    g.es("Syntax error: %s" % headline,color="blue")</t>
<t tx="EKR.20040610192622.1">import string

string.join(a,b]
</t>
<t tx="EKR.20040610194209">import leoGlobals as g
import tabnanny

@others

# print '-' * 20

c = g.top()
p = c.currentPosition()
next = p.next()
s = next.bodyString()
headline = next.headString()

checkString(s,headline)</t>
<t tx="EKR.20040610194209.1">@tabwidth 4

# Tabnanny _only_ checks errors involving tabs.
# It does _not_ check other indentation errors.
# It does _not_ check syntax.

    a = 5
	b = 6 #Contains tab.
    c = 3</t>
<t tx="EKR.20040610195543">def checkString (s,headline):

    """Check indentation using tabnanny.process_tokens."""

    # This code is based on tabnanny.check.
    
    import tokenize

    try:
        # readline = g.readLinesGenerator(s).next
        readline = g.readLinesClass(s).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError, msg:

        g.es("Token error in %s" % headline,color="red")
        g.es(str(msg))
        return

    except tabnanny.NannyNag, nag:

        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()

        g.es("Indentation error in %s, line %d" % (headline, badline),color="red")
        g.es(message)
        g.es("offending line:\n%s" % repr(str(line))[1:-1])
        return
        
    except:
        g.trace("unexpected exception")
        return
        
    g.es("Indentation OK: %s" % headline,color="blue")
</t>
<t tx="EKR.20040610195543.1">@ignore
@language python
&lt;&lt; tabnanny declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="EKR.20040610195543.2">#! /usr/bin/env python

"""The Tab Nanny despises ambiguous indentation.  She knows no mercy.

tabnanny -- Detection of ambiguous indentation

For the time being this module is intended to be called as a script.
However it is possible to import it into an IDE and use the function
check() described below.

Warning: The API provided by this module is likely to change in future
releases; such changes may not be backward compatible.
"""

# Released to the public domain, by Tim Peters, 15 April 1998.

# XXX Note: this is now a standard library module.
# XXX The API needs to undergo changes however; the current code is too
# XXX script-like.  This will be addressed later.

__version__ = "6"

import os
import sys
import getopt
import tokenize
if not hasattr(tokenize, 'NL'):
    raise ValueError("tokenize.NL doesn't exist -- tokenize module too old")

__all__ = ["check", "NannyNag", "process_tokens"]

verbose = 0
filename_only = 0</t>
<t tx="EKR.20040610195543.3">def errprint(*args):
    sep = ""
    for arg in args:
        sys.stderr.write(sep + str(arg))
        sep = " "
    sys.stderr.write("\n")
</t>
<t tx="EKR.20040610195543.4">def main():
    global verbose, filename_only
    try:
        opts, args = getopt.getopt(sys.argv[1:], "qv")
    except getopt.error, msg:
        errprint(msg)
        return
    for o, a in opts:
        if o == '-q':
            filename_only = filename_only + 1
        if o == '-v':
            verbose = verbose + 1
    if not args:
        errprint("Usage:", sys.argv[0], "[-v] file_or_directory ...")
        return
    for arg in args:
        check(arg)</t>
<t tx="EKR.20040610195543.5">
class NannyNag(Exception):
    """
    Raised by tokeneater() if detecting an ambiguous indent.
    Captured and handled in check().
    """
    @others
</t>
<t tx="EKR.20040610195543.6">def __init__(self, lineno, msg, line):
    self.lineno, self.msg, self.line = lineno, msg, line
</t>
<t tx="EKR.20040610195543.7">def get_lineno(self):
    return self.lineno
</t>
<t tx="EKR.20040610195543.8">def get_msg(self):
    return self.msg
</t>
<t tx="EKR.20040610195543.9">def get_line(self):
    return self.line
</t>
<t tx="EKR.20040610195543.10">def check(file):
    """check(file_or_dir)

    If file_or_dir is a directory and not a symbolic link, then recursively
    descend the directory tree named by file_or_dir, checking all .py files
    along the way. If file_or_dir is an ordinary Python source file, it is
    checked for whitespace related problems. The diagnostic messages are
    written to standard output using the print statement.
    """

    if os.path.isdir(file) and not os.path.islink(file):
        if verbose:
            print "%s: listing directory" % `file`
        names = os.listdir(file)
        for name in names:
            fullname = os.path.join(file, name)
            if (os.path.isdir(fullname) and
                not os.path.islink(fullname) or
                os.path.normcase(name[-3:]) == ".py"):
                check(fullname)
        return

    try:
        f = open(file)
    except IOError, msg:
        errprint("%s: I/O Error: %s" % (`file`, str(msg)))
        return

    if verbose &gt; 1:
        print "checking", `file`, "..."

    try:
        process_tokens(tokenize.generate_tokens(f.readline))

    except tokenize.TokenError, msg:
        errprint("%s: Token Error: %s" % (`file`, str(msg)))
        return

    except NannyNag, nag:
        badline = nag.get_lineno()
        line = nag.get_line()
        if verbose:
            print "%s: *** Line %d: trouble in tab city! ***" % (
                `file`, badline)
            print "offending line:", `line`
            print nag.get_msg()
        else:
            if ' ' in file: file = '"' + file + '"'
            if filename_only: print file
            else: print file, badline, `line`
        return

    if verbose:
        print "%s: Clean bill of health." % `file`
</t>
<t tx="EKR.20040610195543.11">
class Whitespace:
    &lt;&lt; class Whitespace declarations &gt;&gt;
    @others
</t>
<t tx="EKR.20040610195543.12"># the characters used for space and tab
S, T = ' \t'

# members:
#   raw
#       the original string
#   n
#       the number of leading whitespace characters in raw
#   nt
#       the number of tabs in raw[:n]
#   norm
#       the normal form as a pair (count, trailing), where:
#       count
#           a tuple such that raw[:n] contains count[i]
#           instances of S * i + T
#       trailing
#           the number of trailing spaces in raw[:n]
#       It's A Theorem that m.indent_level(t) ==
#       n.indent_level(t) for all t &gt;= 1 iff m.norm == n.norm.
#   is_simple
#       True iff raw[:n] is of the form (T*)(S*)

</t>
<t tx="EKR.20040610195543.13">def __init__(self, ws):
    self.raw  = ws
    S, T = Whitespace.S, Whitespace.T
    count = []
    b = n = nt = 0
    for ch in self.raw:
        if ch == S:
            n = n + 1
            b = b + 1
        elif ch == T:
            n = n + 1
            nt = nt + 1
            if b &gt;= len(count):
                count = count + [0] * (b - len(count) + 1)
            count[b] = count[b] + 1
            b = 0
        else:
            break
    self.n    = n
    self.nt   = nt
    self.norm = tuple(count), b
    self.is_simple = len(count) &lt;= 1
</t>
<t tx="EKR.20040610195543.14"># return length of longest contiguous run of spaces (whether or not
# preceding a tab)
def longest_run_of_spaces(self):
    count, trailing = self.norm
    return max(len(count)-1, trailing)
</t>
<t tx="EKR.20040610195543.15">def indent_level(self, tabsize):
    # count, il = self.norm
    # for i in range(len(count)):
    #    if count[i]:
    #        il = il + (i/tabsize + 1)*tabsize * count[i]
    # return il

    # quicker:
    # il = trailing + sum (i/ts + 1)*ts*count[i] =
    # trailing + ts * sum (i/ts + 1)*count[i] =
    # trailing + ts * sum i/ts*count[i] + count[i] =
    # trailing + ts * [(sum i/ts*count[i]) + (sum count[i])] =
    # trailing + ts * [(sum i/ts*count[i]) + num_tabs]
    # and note that i/ts*count[i] is 0 when i &lt; ts

    count, trailing = self.norm
    il = 0
    for i in range(tabsize, len(count)):
        il = il + i/tabsize * count[i]
    return trailing + tabsize * (il + self.nt)
</t>
<t tx="EKR.20040610195543.16"># return True iff self.indent_level(t) == other.indent_level(t)
# for all t &gt;= 1
def equal(self, other):
    return self.norm == other.norm
</t>
<t tx="EKR.20040610195543.17"># return a list of tuples (ts, i1, i2) such that
# i1 == self.indent_level(ts) != other.indent_level(ts) == i2.
# Intended to be used after not self.equal(other) is known, in which
# case it will return at least one witnessing tab size.
def not_equal_witness(self, other):
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    a = []
    for ts in range(1, n+1):
        if self.indent_level(ts) != other.indent_level(ts):
            a.append( (ts,
                       self.indent_level(ts),
                       other.indent_level(ts)) )
    return a
</t>
<t tx="EKR.20040610195543.18"># Return True iff self.indent_level(t) &lt; other.indent_level(t)
# for all t &gt;= 1.
# The algorithm is due to Vincent Broman.
# Easy to prove it's correct.
# XXXpost that.
# Trivial to prove n is sharp (consider T vs ST).
# Unknown whether there's a faster general way.  I suspected so at
# first, but no longer.
# For the special (but common!) case where M and N are both of the
# form (T*)(S*), M.less(N) iff M.len() &lt; N.len() and
# M.num_tabs() &lt;= N.num_tabs(). Proof is easy but kinda long-winded.
# XXXwrite that up.
# Note that M is of the form (T*)(S*) iff len(M.norm[0]) &lt;= 1.
def less(self, other):
    if self.n &gt;= other.n:
        return False
    if self.is_simple and other.is_simple:
        return self.nt &lt;= other.nt
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    # the self.n &gt;= other.n test already did it for ts=1
    for ts in range(2, n+1):
        if self.indent_level(ts) &gt;= other.indent_level(ts):
            return False
    return True
</t>
<t tx="EKR.20040610195543.19"># return a list of tuples (ts, i1, i2) such that
# i1 == self.indent_level(ts) &gt;= other.indent_level(ts) == i2.
# Intended to be used after not self.less(other) is known, in which
# case it will return at least one witnessing tab size.
def not_less_witness(self, other):
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    a = []
    for ts in range(1, n+1):
        if self.indent_level(ts) &gt;= other.indent_level(ts):
            a.append( (ts,
                       self.indent_level(ts),
                       other.indent_level(ts)) )
    return a
</t>
<t tx="EKR.20040610195543.20">def format_witnesses(w):
    firsts = map(lambda tup: str(tup[0]), w)
    prefix = "at tab size"
    if len(w) &gt; 1:
        prefix = prefix + "s"
    return prefix + " " + ', '.join(firsts)
</t>
<t tx="EKR.20040610195543.21">def process_tokens(tokens):
    INDENT = tokenize.INDENT
    DEDENT = tokenize.DEDENT
    NEWLINE = tokenize.NEWLINE
    JUNK = tokenize.COMMENT, tokenize.NL
    indents = [Whitespace("")]
    check_equal = 0

    for (type, token, start, end, line) in tokens:
        if type == NEWLINE:
            # a program statement, or ENDMARKER, will eventually follow,
            # after some (possibly empty) run of tokens of the form
            #     (NL | COMMENT)* (INDENT | DEDENT+)?
            # If an INDENT appears, setting check_equal is wrong, and will
            # be undone when we see the INDENT.
            check_equal = 1

        elif type == INDENT:
            check_equal = 0
            thisguy = Whitespace(token)
            if not indents[-1].less(thisguy):
                witness = indents[-1].not_less_witness(thisguy)
                msg = "indent not greater e.g. " + format_witnesses(witness)
                raise NannyNag(start[0], msg, line)
            indents.append(thisguy)

        elif type == DEDENT:
            # there's nothing we need to check here!  what's important is
            # that when the run of DEDENTs ends, the indentation of the
            # program statement (or ENDMARKER) that triggered the run is
            # equal to what's left at the top of the indents stack

            # Ouch!  This assert triggers if the last line of the source
            # is indented *and* lacks a newline -- then DEDENTs pop out
            # of thin air.
            # assert check_equal  # else no earlier NEWLINE, or an earlier INDENT
            check_equal = 1

            del indents[-1]

        elif check_equal and type not in JUNK:
            # this is the first "real token" following a NEWLINE, so it
            # must be the first token of the next program statement, or an
            # ENDMARKER; the "line" argument exposes the leading whitespace
            # for this statement; in the case of ENDMARKER, line is an empty
            # string, so will properly match the empty string with which the
            # "indents" stack was seeded
            check_equal = 0
            thisguy = Whitespace(line)
            if not indents[-1].equal(thisguy):
                witness = indents[-1].not_equal_witness(thisguy)
                msg = "indent not equal e.g. " + format_witnesses(witness)
                raise NannyNag(start[0], msg, line)
</t>
<t tx="EKR.20040610201236">@

To do:
    
- Specify which nodes to check.
- Check only Python code.</t>
<t tx="EKR.20040610201941">@

To do:
    
- Specify which nodes to check.
- Check only Python code.</t>
<t tx="EKR.20040611083703"># This kind of code is used in the prototypes of new commands.

from __future__ import generators

import leoGlobals as g

@others

lines = "a\nb\nc\nd"

if 1: # Both work
    readline = g.readLinesGenerator(lines).next
else:
    readline = g.readLinesClass(lines).next

print '-' * 20

if 1: # Both work
    for s in g.readLinesGenerator(lines):
        print s,
else:
    while 1:
        s = readline()
        if s: print s,
        else: break
    
print ; print '-' * 20</t>
<t tx="EKR.20040612095237">@ignore
@language python
@tabwidth -4</t>
<t tx="EKR.20040612150543"># Test
@others
# Last</t>
<t tx="EKR.20040612215136">a = 1
print "hello"
c = b
</t>
<t tx="EKR.20040613162717">import leoGlobals as g

path = r"c:\prog\leoScripts(before).txt"
path = r"c:\prog\leoScripts(after).txt"

print g.top().currentPosition()

try:
    f = open(path,"rb")
    s = f.read()
    f.close()
    
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
        
    g.es("cr %d, nl %d %s" % (cr,nl,path))

except IOError:
    print "can not open",path</t>
<t tx="EKR.20040615070332"># "LPT1:", "PRN:" and "PRN" all freeze

s = 'stuff\n'
port = 'USB002'

try:
    f = file(port,'w')
    f.write(s)
    f.flush()
    f.close()
    print "done"
except IOError:
    print "Can not open",port</t>
<t tx="EKR.20040615144735"></t>
<t tx="EKR.20040615144810">d</t>
<t tx="EKR.20040619133116"></t>
<t tx="EKR.20040622074004">@ignore</t>
<t tx="EKR.20040622074004.1"></t>
<t tx="EKR.20040622074004.2">node b, line 1 (changed 12)</t>
<t tx="EKR.20040622074004.3"></t>
<t tx="EKR.20040622102618"></t>
<t tx="EKR.20040623200709.75"></t>
<t tx="EKR.20040623200709.76">def makePluginsSuite(verbose=False,*args,**keys):
    
    """Create an plugins test for every .py file in the plugins directory."""
    
    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(file) for file in files]
    files.sort()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    for file in files:
        test = pluginTestCase(file,verbose)
        suite.addTest(test)

    return suite
</t>
<t tx="EKR.20040623200709.77">class pluginTestCase(unittest.TestCase):
    
    """Unit tests for one Leo plugin."""
    
    @others</t>
<t tx="EKR.20040623200709.78">def __init__ (self,fileName,verbose):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.fileName = fileName
    self.oldGui = None
    self.verbose = verbose</t>
<t tx="EKR.20040623200709.79">def pluginTest (self):
    
    # Duplicate the import logic in leoPlugins.py.
    
    fileName = g.toUnicode(self.fileName,g.app.tkEncoding)
    path = g.os_path_join(g.app.loadDir,"..","plugins")
    
    if self.verbose:
        g.trace(str(g.shortFileName(fileName)))

    module = g.importFromPath(fileName,path)
    assert(module)
    
    # Run any unit tests in the module itself.
    if hasattr(module,"unitTest"):
        
        if self.verbose:
            g.trace("Executing unitTest in %s..." % str(g.shortFileName(fileName)))

        module.unitTest()</t>
<t tx="EKR.20040623200709.80">def runTest(self):

    self.pluginTest()</t>
<t tx="EKR.20040623200709.81">def setUp(self,*args,**keys):

    self.oldGui = g.app.gui
    # g.app.gui = leoTkinterGui.tkinterGui()</t>
<t tx="EKR.20040623200709.82">def shortDescription (self):
    
    return "pluginTestCase: " + self.fileName</t>
<t tx="EKR.20040623200709.83">def tearDown (self):

    g.app.gui = self.oldGui</t>
<t tx="EKR.20040623223148.11">def replaceOutline (self,c,outline1,outline2):
    
    """Replace outline1 by a copy of outline 2,
    
    retaining the headline of outline1."""

    u = self
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete(copy)</t>
<t tx="EKR.20040625110032">@ignore

@others</t>
<t tx="EKR.20040625110032.1"></t>
<t tx="EKR.20040625110032.2"># @language html

@comment &lt;!-- --&gt;</t>
<t tx="EKR.20040625110032.3"></t>
<t tx="EKR.20040626212434"></t>
<t tx="EKR.20040626212434.1">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

mincolor,maxcolor=125,225

for n in xrange(5000):
    x,y = rand(0,900),rand(0,500)
    w = rand(1,10) ; h = w * r.uniform(0.5,1.5)
    color = "#%02x%02x%02x" % (rand(0,maxcolor/2),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    kind = rand(1,3)
    sign = rand(-1,1) # rand(0,2)-1
    if kind == 1:
        canvas.create_rectangle(x,y,x+w,y+h,fill=color,width=0)
    elif kind == 2:
        canvas.create_oval(x,y,x+w,y+h,fill=color,width=0)
    else:
        canvas.create_line(x,y,x+sign*5*w,y+5*h,fill=color)
    if 0: # Redrawing slows things down a lot.
        if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626212434.2">import leoGlobals as g
import Tkinter as Tk
import random as r

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top, height = "5i", width = "9i")
canvas.pack() ; top.update()
rand = r.randint

x,y = 10,10
mincolor,maxcolor=125,225

for n in xrange(2000):
    x2,y2 = rand(0,900),rand(0,500)
    color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    width = "%fm" % r.uniform(0.1,0.6)
    canvas.create_line(x,y,x2,y2,fill=color,width=width)
    extent = rand(180,270)
    canvas.create_arc(x,y,x2,y2,outline=color,width=width,style="arc",extent=extent)
    x,y = x2,y2
    # if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626213007">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

# Paul Klee
mincolor,maxcolor=125,225
xmax,ymax = 800,400
stipples = [None,"gray75"] # "gray12","gray25","gray50",]
h=w=90
for x in xrange(10,xmax,w):
    for y in xrange(10,ymax,h):
        color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
        range = h/6
        stipple = stipples[rand(0,len(stipples)-1)]
        dx = r.uniform(0.0,range) - range/2
        dy = r.uniform(0.0,range) - range/2
        canvas.create_rectangle(x+dx,y+dy,x+dx+w,y+dy+h,fill=color,width=0,stipple=stipple)</t>
<t tx="EKR.20040627100615">import leoGlobals as g

g.app.config.redirect_execute_script_output_to_log_pane = False

# Syntax error
print '

import leoGlobals as g
print g.app.config.redirect_execute_script_output_to_log_pane</t>
<t tx="EKR.20040627103732">@ignore</t>
<t tx="EKR.20040627103801"></t>
<t tx="EKR.20040627103902" lineYOffset="4b032e" icons="5d7100287d7101285504747970657102550466696c65710355047870616471044b02550577686572657105550a6265666f726549636f6e71066803582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286802680368084afdffffff6803582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6805550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e"></t>
<t tx="EKR.20040627121836">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

next = p.next()

t = next.v.t
v = next.v

for s in t.__dict__:
    print s,getattr(t,s)</t>
<t tx="EKR.20040627150213">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

@others

mincolor,maxcolor=125,225
xmax,ymax = 300,300
h=w=1
i = r.uniform(2.0,4.0)
j = r.uniform(-5.0,5.0)
power = r.uniform(1.1,1.2)
    #(1.5,1.7)
for n in xrange(1):
    i += 0.5
    j += 0.5
    power += 0.01
    print "i,j,power:",i,j,power
    c = complex(i,j)
    for format,m in (
        #("#%02x%02x%02x",256),
        #("#%03x%03x%03x",256*8),
        ("#%04x%04x%04x",256*256),
    ):
        for x in xrange(0,xmax,1):
            for y in xrange(0,ymax,1):
                n = complex(x,y)
                z = pow(c*n,power)
                n1 = int(z.real*m) ; n2 = int(z.imag*m)
                color = format % (n1%m,n2%m,abs(n1-n2)%m)
                # canvas.create_rectangle(w*x,h*y,w*x+w,h*y+h,fill=color,width=0)
                canvas.create_line(x,y,x+1,y+1,fill=color,width=1)
        top.update()
print "done"</t>
<t tx="ekr.20040302091705">import leoGlobals as g

class position:
    def __init__(self):
        self.v = "a"
    def move(self):
        self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040303063549.2">@ Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth and language formatting directives
@c</t>
<t tx="ekr.20040303063549.3">@language plain
@pagewidth 40
@tabwidth 8

Wrap a long line, no trailing newline.</t>
<t tx="ekr.20040303063549.4">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040303063549.5">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040303063549.6">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040303063549.7">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040303063549.8">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040303063549.9">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040303063549.10">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.11">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.12">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040303063549.13">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040303063549.14">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040303063549.15">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040303063549.16">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.17">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.18">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040303063549.19">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.20">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.21">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040303063549.22">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.23">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.24">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040303063549.25">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.26">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.27">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040303063549.28">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.29">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.30">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040303063549.31">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20040303063549.32">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.33">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Mutliple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040303063549.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.35">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.36">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040303063549.37">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.38">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.39">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040303063549.40">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.41">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.42">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040303063549.43">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.44">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.77"></t>
<t tx="ekr.20040303063549.78"></t>
<t tx="ekr.20040303063549.79">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040303063549.80"></t>
<t tx="ekr.20040303063549.81">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040303063549.82"></t>
<t tx="ekr.20040303063549.83">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040303063549.84"></t>
<t tx="ekr.20040303063549.85">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040303063549.86"></t>
<t tx="ekr.20040303063549.87">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040303063549.88"></t>
<t tx="ekr.20040303063549.89">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.90"></t>
<t tx="ekr.20040303063549.91"></t>
<t tx="ekr.20040303063549.92">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.93"></t>
<t tx="ekr.20040303063549.94">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.95"></t>
<t tx="ekr.20040303063549.96">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040303063549.97"></t>
<t tx="ekr.20040303063549.98">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040303063549.99"></t>
<t tx="ekr.20040303063549.100">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040303063549.101"></t>
<t tx="ekr.20040303063549.102"></t>
<t tx="ekr.20040303063549.107"></t>
<t tx="ekr.20040303063549.108"></t>
<t tx="ekr.20040303063549.109"></t>
<t tx="ekr.20040303063549.110"></t>
<t tx="ekr.20040303063549.111"></t>
<t tx="ekr.20040303063549.112"></t>
<t tx="ekr.20040303063549.113"></t>
<t tx="ekr.20040303063549.114"></t>
<t tx="ekr.20040303063549.115"></t>
<t tx="ekr.20040303063549.116"></t>
<t tx="ekr.20040303063549.117"></t>
<t tx="ekr.20040303080938"></t>
<t tx="ekr.20040303080938.1"></t>
<t tx="ekr.20040309095121"></t>
<t tx="ekr.20040309111054">import leoGlobals as g
import leoNodes

c = g.top()
position = leoNodes.position

@others

current = pos = c.currentPosition()
child1 = current.firstChild()
child2 = child1.firstChild()

if 0:
    print '-'*10, "parents"
    for p in child2.parents_iter(): print p
if 0:
    print '-'*10, "subtree"
    for p in pos.subtree_iter(): print p
if 0:
    print '-'*10, "children"
    for p in child1.children_iter(): print p
if 0:
    print '-'*10, "siblings"
    for p in pos.siblings_iter(): print p
if 1:
    print '-'*10, "all nodes"
    for p in pos.allNodes_iter():
        print p.isCloned(),p
</t>
<t tx="ekr.20040309111102"></t>
<t tx="ekr.20040309111102.1"></t>
<t tx="ekr.20040309111102.2"></t>
<t tx="ekr.20040309111102.3"></t>
<t tx="ekr.20040309111102.4"></t>
<t tx="ekr.20040309111102.5"></t>
<t tx="ekr.20040309111102.6"></t>
<t tx="ekr.20040309111102.7"></t>
<t tx="ekr.20040309111102.8"></t>
<t tx="ekr.20040309111102.9"></t>
<t tx="ekr.20040309111102.10"></t>
<t tx="ekr.20040309111232"></t>
<t tx="ekr.20040310145919">import leoGlobals as g
c = g.top()

c.frame.body.colorizer.python_keywords.append("as")</t>
<t tx="ekr.20040311090054">import leoGlobals as g
import leoNodes

c = g.top() ; root = c.rootPosition()

for p in root.allNodes_iter():
    print p.v.t.fileIndex</t>
<t tx="ekr.20040311125054">import leoGlobals as g
c = g.top()
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
    assert(p.t == p.v.t)</t>
<t tx="ekr.20040312021734"></t>
<t tx="ekr.20040312021734.1">import leoGlobals as g

c = g.top()

count = 0
for p in c.rootPosition().allNodes_iter():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20040312101720"></t>
<t tx="ekr.20040315025315">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315025315.1">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.subtree_iter()
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)</t>
<t tx="ekr.20040315025315.2">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040315025315.3">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.bodyString() ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040315030123">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

p = p.firstChild()
assert(p.headString()=="File Conversion")
p.convertTreeToString()</t>
<t tx="ekr.20040315210314"></t>
<t tx="ekr.20040315210314.1"></t>
<t tx="ekr.20040315210314.2">@nocolor

- Used iterators in test utils.
- Used "import leoGlobals as g" style.</t>
<t tx="ekr.20040317101155" lineYOffset="4b032e" icons="5d7100287d710128550577686572657102550a6265666f726549636f6e710355047870616471044b025504747970657105550466696c6571066806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286805680668084afdffffff6806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6802550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e">import leoGlobals as g

c = g.top()

p = c.currentPosition()
p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

&lt;&lt; define event callbacks &gt;&gt;

path = r"c:\prog\leoCVS\leo\Icons"
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
    "type" : "file", "file" : icon1,
    "where" : "beforeIcon",
    "yoffset" : -3,
    # "yoffset" : 5, "ypad" : -5,
    # "height" : 40, # automatically adjust headline y position.
    "xpad": 2
}

# Classes and functions can only be pickled if they are at the top level of a module.
    #"onClick" : onClick,
    #"onRightClick" : onRightClick,
    #"onDoubleClick" : onDoubleClick }

d2 = {
    "type" : "file", "file" : icon2,
    "where" : "beforeHeadline",
    "yoffset" : -3,
    "xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()
</t>
<t tx="ekr.20040317173327">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0
            
c.redraw()</t>
<t tx="ekr.20040317185041">def onClick(p=p):
    
    g.trace(p)

def onRightClick(p=p):
    
    g.trace(p)

def onDoubleClick(p=p):
    
    g.trace(p)</t>
<t tx="ekr.20040318091620">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if hasattr(p.v.t,"unknownAttributes"):
        print "deleting unknownAttributes:",p
        delattr(p.v.t,"unknownAttributes")
            
c.redraw()</t>
<t tx="ekr.20040318102920"># The actual test is in a child node.</t>
<t tx="ekr.20040318102920.1"></t>
<t tx="ekr.20040318102920.2">import leoGlobals as g
c = g.top()

try:
    for p in c.allNodes_iter():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            if p.v._parent: parents1 = p.v._parent.t.vnodeList
            else:           parents1 = []
            parents2 = p.v.directParents()
        
        assert len(parents1) == len(parents2), "length mismatch: %s, %s" % (p,p.v._parent)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print "parents1"
    for parent in parents1: print parent
    print "parents2"
    for parent in parents2: print parent
    raise</t>
<t tx="ekr.20040319111213">from leoPlugins import *
from leoGlobals import *
from leoNodes import *
import Tkinter
import re
import sys

@others

fhp = None
fhp_entry = None
    
if 1:
    addMenu("none",None)
else:
    hooks = choose(sys.platform == 'win32',
        ('open2',"new"),
        ('start2','open2',"new"))
        
    print "hi"
        
    registerHandler(hooks,addMenu)

    __version__ = ".1"
    plugin_signon(__name__)
</t>
<t tx="ekr.20040319111213.1">@nocolor

@ This is what it does:

1. Under Outline it puts an Option called 'FilterHoist'
2. Selecting the option pops up an ugly little window.  On it is a section where
you can type in text.  You can close the window with the close button.  You
can activate the functionality with the Filter Button.
3. Filtering will walk the Leo tree, looking for a text match from the Text
field with the Nodes bodyString.
4. After finding some nodes it creates a new node at the root.  Then it clones
the matching nodes under that new node.  A Hoist operation is performed on the
new node.  This gives a view of all matching nodes.

I put this together because I wanted a find that was based in terms of Leo's
nodes.  Find as it is bounces you around the Tree(it bothers me).  This brings
the nodes to you and presents them.  As it is I may work further on this if
people like the idea.  It's possible I might migrate it to the NodeRoundup plugin
to.

You need 2.3 python; it uses generators in it's find method.

That was one motivation for writing this thing, using a generator vs. Recursive
approach to tree walking.</t>
<t tx="ekr.20040319111213.2">def OLDfilter(c,e):

    v = c.rootVnode()
    
    nodes = []
    while v:
        nodes.append(v)
        v = v.next()
    
    regex = re.compile(e.get())
    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        ticker = c.rootVnode().insertAfter(t)
        for z in nodes:
            for x in search(z,regex):
                clone = x.clone( x )
                clone.moveToNthChildOf(ticker,0)
        c.setCurrentVnode(ticker)
        ticker.moveToRoot(c.rootVnode())
    c.endUpdate()
    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040319111213.3">def OLDsearch(vn,regex):

    sn = vn 
    while vn != None:
        if regex.search( vn.t.bodyString ) : yield vn
        nc = vn.numberOfChildren()
        if nc == 0:
            i = vn.childIndex()
            p = vn.parent()
            if p == None: 
                vn = None
                continue
            if i == 0:
                while 1:
                    if p == sn :
                        vn = None
                        break
                    vn = p.back() 
                    if vn == None:
                        p = p.parent()
                        continue
                    break
                continue                                                        
            vn = p.nthChild( i - 1)
            continue
        vn = vn.nthChild( nc - 1 )
</t>
<t tx="ekr.20040319111213.4">def filterHoist(c):

    global fhp
    global e
    
    if fhp is None:

        fhp = Tkinter.Toplevel()
        fhp.title('FilterHoist')

        fhp_entry = e = Tkinter.Entry(fhp)
        e.pack(side="top",fill="both")

        def closeCallback(fhp=fhp):
            fhp.withdraw()
            
        def filterCallback(c=c,entry=e):
            filter(c,entry)

        b1 = Tkinter.Button(fhp,text='Close',command=closeCallback)
        b2 = Tkinter.Button(fhp,text='Filter',command=filterCallback)
        b1.pack(side="left")
        b2.pack(side="right")

    fhp.geometry('200x200+250+250') 
    fhp.deiconify()
    fhp_entry.focus_set()
</t>
<t tx="ekr.20040319111213.5">def addMenu(tag,keywords):
    
    c = top()
    
    trace()
    
    def callback(c=c):
        filterHoist(c)
    
    table = ("FilterHoist",None,callback),

    c.frame.menu.createMenuItemsFromTable("Outline",table)</t>
<t tx="ekr.20040319142202"></t>
<t tx="ekr.20040319142708">def filter(c,e):
    
    pat = re.compile(e.get())

    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        newRoot = c.rootVnode().insertAfter(t)
        p = c.rootVnode()
        while p:
            if pat.search(p.bodyString()):
                clone = p.clone(p)
                clone.moveToLastChildOf(newRoot)
            p = p.threadNext()
        newRoot.moveToRoot(c.rootVnode())
        c.setCurrentVnode(newRoot)
    c.endUpdate()

    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040322120331">import leoGlobals as g
c = g.top()

print '-'*20
for p in c.allNodes_iter():
    if hasattr(p.v.t,"tnodeList"):
        print p,p.v.t.tnodeList</t>
<t tx="ekr.20040323075614">import leoGlobals as g

class test_iter_class:
    def __init__ (self):
        self.vals = ("a","b","c")
        self.n = 0
    def __iter__(self):
        return self
    def next(self):
        if self.n &lt; len(self.vals):
            val = self.vals[self.n]
            self.n += 1
            return val
        else:
            raise StopIteration
            
def test_iter(): return test_iter_class()
        
vals = [val for val in test_iter()]

print vals
</t>
<t tx="ekr.20040323080317">import leoGlobals as g
c = g.top()

print '-'*20

# These are equivalent.
positions1 = [p for p in c.allNodes_iter(copy=True)]
positions2 = [p.copy() for p in c.allNodes_iter()]

assert(len(positions1) == len(positions2))
for i in xrange(len(positions1)):
    assert(positions1[i] == positions2[i])

if 0:
    for p in positions1:
        print p
print "done"</t>
<t tx="ekr.20040323082119">import leoGlobals as g
c = g.top()

print '-'*20

positions = [p.copy() for p in c.allNodes_iter()]

tnodes = {} ; vnodes = []
for p in c.allNodes_iter():
    t = p.v.t
    if tnodes.get(t) is None:
        tnodes[t]=t
        vnodes.append(p.v)
        
print len(positions),len(vnodes)

for v in vnodes:
    print v</t>
<t tx="ekr.20040323085406">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isAnyAtFileNode():
        print p
        
print "done"</t>
<t tx="ekr.20040323085933">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isDirty():
        vnodes = p.findAllPotentiallyDirtyNodes()
        print '-'*5, p
        for v in vnodes:
            print v

print "done"</t>
<t tx="ekr.20040323090541">import leoGlobals as g
c = g.top()
try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert len(parents) == len(vparents), "length mismatch: %s,%s" % (p,child)
                for parent in parents:
                    assert parent in vparents, "not in vparents: %s,%s" % (p,child)
                for parent in vparents:
                    assert parent in parents, "not in parents: %s,%s" % (p,child)
except AssertionError:
    print "parents..."
    for parent in parents: print parent
    print "vparents..."
    for parent in vparents: print parent
    raise # for unittest.</t>
<t tx="ekr.20040323162303">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040325082811">import leoGlobals as g

g.es("v",g.top().currentPosition())
g.es(1,2)</t>
<t tx="ekr.20040325130503">stack1 = ["a","b","c"]
stack2 = ["a","b","c"]
stack3 = ["a","b","d"]
stack4 = ["a","b"]
print stack1 == stack2
print stack1 == stack3
print stack1 == stack4</t>
<t tx="ekr.20040325140133">import leoGlobals as g
c = g.top() ; p = c.currentPosition()

print p.v.headString()
print p.childIndex()
print p.v.headString()</t>
<t tx="ekr.20040325155043">import timeit

s1 = '''\
class test(object):
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s2 = '''\
class test:
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s3 = '''\
import leoNodes
p1 = leoNodes.position(None,[])
p2 = leoNodes.position(None,[])'''

for s in (s1,s2,s3):
    t1 = timeit.Timer(stmt='p1==p2',setup=s).timeit()
    t2 = timeit.Timer(stmt='p1.equal(p2)',setup=s).timeit()
    print "%2.2f,%2.2f,%0.2f" % (t1,t2,t1/t2)
</t>
<t tx="ekr.20040327105955">import os

path = r"c:\prog\test\unittest\createdFile.txt"

s = r"c:\python23\python c:\prog\LeoCVS\leo\src\leo.py -script c:\prog\test\unittest\batchTest.py"

if os.path.exists(path):
    print ; print "@test batch mode: deleting",path
    os.remove(path)

os.system(s)
assert(os.path.exists(path))
</t>
<t tx="ekr.20040327114250">@ignore

# A file to be executed in batch mode as part of unit testing.

@language python
@tabwidth -4

path = r"c:\prog\test\unittest\createdFile.txt"
f = None
try:
    f = open(path,"w")
    f.write("This is a test")
finally:
    if f: f.close()</t>
<t tx="ekr.20040330095252">import leoGlobals as g
c = g.top()
t = c.frame.log.logCtrl
print t
t.delete("1.0","end")</t>
<t tx="ekr.20040330103006">@ignore
@language c

oblk[1] = b64[((iblk[0] &amp; 0x03) &lt;&lt; 4) |
((iblk[1] &amp; 0xF0) &gt;&gt; 4)];
oblk[2] = b64[((iblk[1] &amp; 0x0F) &lt;&lt; 2) |
((iblk[2] &amp; 0xC0) &gt;&gt; 6)];
</t>
<t tx="ekr.20040402043516">@ a doc
part.
@c

"""A script to reformat non-leading whitespace."""

import leoGlobals as g

import tokenize,token

@others

c = g.top()

print '-'*50

if 1:
    # Just print the present position.
    prettyPrintNode(c.currentPosition())
else:
    # Print all top-level nodes.
    for p in c.rootPosition().self_and_siblings_iter():
        prettyPrintNode(p)
        
print
print '-'*50</t>
<t tx="ekr.20040402064301">class prettyPrinter:
    
    @others</t>
<t tx="ekr.20040402064301.1">def __init__ (self,p):
    
    self.line = 0
    self.lines = []
    self.col = 0
    self.array = []
    self.parenLevel = 0
    self.bracketLevel = 0
    self.p = p</t>
<t tx="ekr.20040402072335">def put (self,s,strip=True):
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # We aren't stripping all leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20040402074431">def putNormalToken (self,token5tuple):

    a = self.array
    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4 ; line = str(t5)
    name = token.tok_name[t1].lower()
    val = str(t2)
    startLine = self.line != srow
    self.line = srow

    if startLine:
        ws = line[0:scol]
        if ws: a.append(ws)

    if name in ("nl","newline","endmarker"):
        if name in ("nl","newline"):
            a.append('\n')
        # else: a.append("&lt;END NODE&gt;")
        self.lines.append(''.join(self.array))
        self.array = []
    elif name == "op":
        self.putOperator(val)
    elif name == "name":
        a.append("%s " % val)
    elif name in ("comment","string","number"):
        a.append(val)
    elif name == "errortoken":
        if val == '@' and startLine:
            # Preserve whitespace after leading @.
            i = g.skip_ws(line,1)
            a.append(line[0:i])
        else:
            a.append(val)
    elif name == "indent":
        a.append(val)
    elif name == "dedent":
        pass
    else:
        print "unknown: %s" % (name)</t>
<t tx="ekr.20040402074431.1">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4 ; line = str(t5)
    name = token.tok_name[t1].lower()
    val = str(t2)

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20040402080311">def putToken (self,token5tuple):
    
    if 1:
        self.putNormalToken(token5tuple)
    else:
        self.dumpToken(token5tuple)</t>
<t tx="ekr.20040402081135">def putOperator (self,val):
    
    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel &gt; 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel &gt; 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)</t>
<t tx="ekr.20040402084155">def prettyPrintNode(p):

    s = p.bodyString()
    if not s: return
    
    print '-'*10, p.headString()

    pp = prettyPrinter(p)
    
    readlines = g.readLinesGenerator(s).next

    for token5tuple in tokenize.generate_tokens(readlines):
        pp.putToken(token5tuple)
        
    lines = pp.get()
    
    # Note: we could replace p's body text here.

    if 1:
        print ''.join(lines), # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20040402093822">def get (self):
    
    return self.lines</t>
<t tx="ekr.20040409140301"></t>
<t tx="ekr.20040409140301.1"></t>
<t tx="ekr.20040409140301.2"></t>
<t tx="ekr.20040409140301.3"></t>
<t tx="ekr.20040409140343"></t>
<t tx="ekr.20040409140343.1"></t>
<t tx="ekr.20040409142028"></t>
<t tx="ekr.20040409142028.1"></t>
<t tx="ekr.20040409142108"></t>
<t tx="ekr.20040409142108.1"></t>
<t tx="ekr.20040414082806"></t>
<t tx="ekr.20040419105536">@ignore
@language perl

@others</t>
<t tx="ekr.20040419105536.1">line 1</t>
<t tx="ekr.20040419105536.2">line 2</t>
<t tx="ekr.20040701065412">@others</t>
<t tx="ekr.20040701065412.1">marked node</t>
<t tx="ekr.20040701065412.2"></t>
<t tx="ekr.20040701065412.3"></t>
<t tx="ekr.20040701065412.4"></t>
<t tx="ekr.20040701065412.5"></t>
<t tx="ekr.20040701065424"></t>
<t tx="ekr.20040701065424.1"></t>
<t tx="ekr.20040701081330">@ignore</t>
<t tx="ekr.20040704104554">@ignore</t>
<t tx="ekr.20040704104554.1">@language html
@language python
</t>
<t tx="ekr.20040704104554.2">@language python
@language html</t>
<t tx="ekr.20040705191805">@ignore

import leoGlobals as g
import leoNodes

c = g.top()
p = c.currentPosition()

print '-' * 20
format = "%18s"
for child in p.children_iter():
    print ; print child.headString()
    print format % "isAnyAtFileNode",   child.isAnyAtFileNode()
    print format % "anyAtFileNodeName", child.anyAtFileNodeName()
    print format % "isAtFileNode",      child.isAtFileNode()
    print format % "isAtNoSentFileNode",child.isAtNoSentFileNode()
    print format % "isAtNorefFileNode", child.isAtNorefFileNode()
    print format % "isAtAsisFileNode",  child.isAtAsisFileNode()
    print format % "isAtThinFileNode",  child.isAtThinFileNode()</t>
<t tx="ekr.20040705191805.1"></t>
<t tx="ekr.20040705191805.2"></t>
<t tx="ekr.20040705192522"></t>
<t tx="ekr.20040705192522.1"></t>
<t tx="ekr.20040705192522.2"></t>
<t tx="ekr.20040705192522.3"></t>
<t tx="ekr.20040705192522.4"></t>
<t tx="ekr.20040705192522.5"></t>
<t tx="ekr.20040705192522.6"></t>
<t tx="ekr.20040705192610"></t>
<t tx="ekr.20040705192610.1"></t>
<t tx="ekr.20040705212227"></t>
<t tx="ekr.20040706071823"># This works, and doesn't seem convenient for Leo's importers.

import leoGlobals as g

try:
    import parser
    import pprint
    path = r"c:\prog\test\importIndentTest.py"
    f = open(path)
    s = f.read()
    f.close()
    ast = parser.suite(s)
    tup = ast.totuple()
    print `ast`
    pprint.pprint(tup)
except:
    import traceback
    traceback.print_exc()</t>
<t tx="ekr.20040707071542.1">import leoTest
reload(leoTest)

leoTest.doTests(all=True)</t>
<t tx="ekr.20040707081532.1">import leoTest
reload(leoTest)

leoTest.doTests(all=False)</t>
<t tx="ekr.20040707083523"># Run all child tests...

import leoGlobals as g

c = g.top() ; p1 = c.currentPosition()
changed = c.isChanged()

for child in c.currentPosition().children_iter():
    
    grandChild = child.firstChild()
    if grandChild:
        c.selectVnode(grandChild) # Sets body text.
        val = c.frame.body.colorizer.colorize(grandChild,incremental=False)
        print "colorizing", grandChild.headString()
        assert val=="ok", "colorizer test failed: %s" % grandChild.headString()
        
c.setChanged(changed) # Restore changed state.
c.selectVnode(p1) # N.B. Restore the selected node.</t>
<t tx="ekr.20040707083523.1">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040707083523.2">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040707083523.3">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040707083523.4">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20040707083523.5">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040707083523.6">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20040707083523.7">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040707083523.8">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040707083523.9">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040707083523.10">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040707083523.11">@ignore
@ doc
@c
@language c
    @others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040707083523.12">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20040707083523.13">@language python

"""python
string"""d

'this\
is'''</t>
<t tx="ekr.20040707083523.14">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
    
def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20040707083523.15">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20040707083523.16">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040707083523.17"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20040707083523.18"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

import leoGlobals as g ; print g.app().loadDir</t>
<t tx="ekr.20040707083523.19"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

import leoGlobals as g ; print g.app().loadDir
</t>
<t tx="ekr.20040707083523.20"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="ekr.20040707090019">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090300">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090300.1">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.1">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.2">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.3">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.4">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.5">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.6">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.7">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.8">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.9">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.10">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.11">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.12">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.13">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.14">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.15">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707091428"></t>
<t tx="ekr.20040707091428.1"></t>
<t tx="ekr.20040707091428.5">import leoGlobals as g
c = g.top()
p = c.currentPosition()
    
assert(p == p.copy())
assert(p != p.threadNext())</t>
<t tx="ekr.20040707091428.6">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040707091428.8">import leoGlobals as g
c = g.top()

for copy in (True,False):
    p2 = c.rootPosition()
    for p in c.allNodes_iter(copy=copy):
        assert p==p2, "%s != %s" % (p,p2)
        p2.moveToThreadNext()
        
    assert not p2, repr(p2)
</t>
<t tx="ekr.20040707091428.9">import leoGlobals as g
c = g.top()

for copy in (True,False):
    for p in c.allNodes_iter(copy=copy):
        
        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToNext()

    assert not p2, repr(p2)</t>
<t tx="ekr.20040707091428.10">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)
        
    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())</t>
<t tx="ekr.20040707091428.11">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040707091428.12">import leoGlobals as g
c = g.top()

for copy in (True,False):

    for p in c.allNodes_iter():
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToParent()

        assert not p2, repr(p2)</t>
<t tx="ekr.20040707091428.13"># Test consistency of p.parent, p.next, p.back and p.firstChild.

import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))
        
    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())
        
    if p.hasBack():
        assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040707091428.14">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040707091428.15">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned():
        parents = p.v.t.vnodeList
        for child in p.children_iter():
            vparents = child.v.directParents()
            assert(len(parents) == len(vparents))
            for parent in parents:
                assert(parent in vparents)
            for parent in vparents:
                assert(parent in parents)</t>
<t tx="ekr.20040707091428.16">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))
            
    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))</t>
<t tx="ekr.20040707091428.17">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))
            
    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))</t>
<t tx="ekr.20040707091428.18">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))
            
    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040707091428.19">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    vnodeList = p.v.t.vnodeList

    for v in vnodeList:

        assert(v.t == p.v.t)
        if p.v.isCloned():
            assert(v.isCloned())
            assert(len(vnodeList) &gt; 1)
        else:
            assert(not v.isCloned())
            assert(len(vnodeList) == 1)</t>
<t tx="ekr.20040707093334"></t>
<t tx="ekr.20040707104245"></t>
<t tx="ekr.20040707110818"></t>
<t tx="ekr.20040707140849.1"></t>
<t tx="ekr.20040707140849.10"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeEditBodySuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040707140849.19"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = unittest.makeSuite(findCommandTestCase,'test')

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040707140849.21">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20040707140849.22">def setUp(self,*args,**keys):
    
    self.u = u = leoTest.testUtils()
    self.c = c = g.top()
    self.find_p = u.findNodeAnywhere(c,"findTests")
    
    assert(self.find_p)
</t>
<t tx="ekr.20040707140849.23">def testFindCommand (self):
    
    pass</t>
<t tx="ekr.20040707140849.24">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20040707140849.25">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20040707140849.26"></t>
<t tx="ekr.20040707140849.35"></t>
<t tx="ekr.20040707140849.39">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040707140849.40">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","src","LeoPy.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040707140849.41">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","plugins","leoPlugins.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040707140849.42">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040707140849.43"></t>
<t tx="ekr.20040707140849.44">def makeOutlineSuite(parentHeadline):
    
    """Create an outline test for every descendant of testParentHeadline.."""
    
    c = g.top() ; v = c.currentVnode()
    u = leoTest.testUtils()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    parent = u.findNodeAnywhere(c,parentHeadline)
    
    for child in parent.children_iter(copy=True):
        before = u.findNodeInTree(child,"before")
        after  = u.findNodeInTree(child,"after")
        ref    = u.findNodeInTree(child,"ref")
        if before and after and ref:
            test = outlineTestCase(c,child,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040707140849.45">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20040707140849.46">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.u = leoTest.testUtils()

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref</t>
<t tx="ekr.20040707140849.47">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert move, "no move node"
    
    c.selectVnode(move)
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()

    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))</t>
<t tx="ekr.20040707140849.48">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20040707140849.49">def setUp(self,*args,**keys):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert self.u.compareOutlines(self.before,self.ref,compareHeadlines=False),\
        "compare failed"
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20040707140849.50">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()</t>
<t tx="ekr.20040707140849.51"># To do: create separate unit tests for each plugin...

import leoGlobals as g
import glob

@others
 
path = g.os_path_join(g.app.loadDir,"..","plugins")
files = glob.glob(g.os_path_join(path,"*.py"))
files = [g.os_path_abspath(file) for file in files]
files.sort()

oldGui = g.app.gui
try:
    ok = True
    for file in files:
        g.trace(file)
        doPluginTest(path,file,verbose=True)
except:
    g.es_exception()
    ok = False

g.app.gui = oldGui
if not ok: raise</t>
<t tx="ekr.20040707140849.79"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeReformatParagraphSuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040707141957.3">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.4">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.5">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@nonl
#@-node:@@file
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040707141957.6">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.7">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20040707141957.8">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20040707141957.9">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.10">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20040707141957.11">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20040707141957.12">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.13">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.14">#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:@@thin
Line 1

#@@last
#@nonl
#@-node:ekr.20040707141957.13:@@thin
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040707150427"></t>
<t tx="ekr.20040707151028">def doPluginTest (path,fileName,verbose=False):
    
    # Duplicate the import logic in leoPlugins.py.
    
    fileName = g.toUnicode(fileName,g.app.tkEncoding)

    if verbose:
        g.trace(str(fileName))

    module = g.importFromPath(fileName,path)
    if not module:
        print "Warning: can not import %s", g.shortFileName(fileName)
        return
    
    # Run any unit tests in the module itself.
    if hasattr(module,"unitTest"):
        if verbose:
            g.trace("Executing unitTest in %s..." % \
                str(g.shortFileName(fileName)))
        module.unitTest()</t>
<t tx="ekr.20040708080620">@nocolor

Changed made by EKR on 7/8/04.

- Created @suite node to call makeReformatParagraphSuite

- Used makeSuite(reformatParagraphTestCase,'test') in makeReformatParagraphSuite instead of list of tests.

- modified setUp to handle these new conventions.
    - Search for reformatParagraphsTests anywhere in the tree
    - Created tempNode inside reformatParagraphsTests tree.</t>
<t tx="ekr.20040708080620.1"></t>
<t tx="ekr.20040708113527">@ The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
@c</t>
<t tx="ekr.20040708113527.1"></t>
<t tx="ekr.20040708113527.2">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040708113527.3">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040708113527.4">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040708113527.5"></t>
<t tx="ekr.20040708113527.6">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040708113527.7">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040708113527.8">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040708113527.9"></t>
<t tx="ekr.20040708113527.10">before
&lt;&lt; section &gt;&gt;
sec line 1
    sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040708113527.11">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040708113527.12">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20040708113527.13">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040708113823"></t>
<t tx="ekr.20040708135624">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()


print "children", '-' * 20
children = u.findChildrenOf(p)
for child in children: print child.headString()

print "subtree", '-' * 20
descendents = u.findSubnodesOf(p)
for descendent in descendents: print descendent.headString()</t>
<t tx="ekr.20040708172357"></t>
<t tx="ekr.20040708172802">aaa</t>
<t tx="ekr.20040708173308.1"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("importTests",doImport=True)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040708173549"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g

import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("exportTests",doImport=False)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040708174345"></t>
<t tx="ekr.20040708174345.1"></t>
<t tx="ekr.20040708174955"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = makeOutlineSuite("outlineTests")

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040708175948">def shortDescription (self):
    
    return self.parent.headString()</t>
<t tx="ekr.20040708181226">import leoGlobals as g
import leoNodes

c = g.top();  p = c.currentPosition()
root1 = p.firstChild()

root2 = root1.copyTreeAfter()
root2.initHeadString("root2")
c.checkOutline()
c.redraw()
root2.doDelete(root1)
c.checkOutline()
c.redraw()</t>
<t tx="ekr.20040708181226.1"></t>
<t tx="ekr.20040708181226.2"></t>
<t tx="ekr.20040708181226.3"></t>
<t tx="ekr.20040708185414"></t>
<t tx="ekr.20040708203222"></t>
<t tx="ekr.20040708205153">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040708205640"></t>
<t tx="ekr.20040708205841">@language python
@tabwidth -4

@ignore
</t>
<t tx="ekr.20040708210045">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040708210442"></t>
<t tx="ekr.20040708210636"></t>
<t tx="ekr.20040708211223">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040708212348">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.headString()=="outline1")
assert(outline2.headString()=="outline2")

u.replaceOutline(c,outline1,outline2)
c.redraw()
c.checkOutline()</t>
<t tx="ekr.20040708213736"></t>
<t tx="ekr.20040708213736.1"></t>
<t tx="ekr.20040708214013"></t>
<t tx="ekr.20040708214013.1"></t>
<t tx="ekr.20040708214530">import leoGlobals as g

c = g.top()
errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.
assert errors == 0, "Check Outline reported %d errors" % errors</t>
<t tx="ekr.20040708215319"></t>
<t tx="ekr.20040708215633"></t>
<t tx="ekr.20040708215633.1"></t>
<t tx="ekr.20040708215633.2"></t>
<t tx="ekr.20040708215633.3"></t>
<t tx="ekr.20040710120700"></t>
<t tx="ekr.20040710125250">@nocolor

The first idea was to use Python's imp module to simulate an import from a file.  This does not work well because imp expects a file, not a StringIO object.

The second idea was to use Python's parser module.  But this returns an instance type, not a module.

A third idea would be to subclass the file type to fool the imp module.

A fourth idea would be to use the ihooks module.  Apparently this module was designed to do something like what I am trying to do!  However, there doesn't seem to be docs for it, so I have imported the code...

@color</t>
<t tx="ekr.20040710125250.2">import leoGlobals as g
import imp
import StringIO

@
load_module( name, file, filename, description) 

Load a module that was previously found by find_module() (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it is equivalent to a reload()! The name argument indicates the full module name (including the package name, if this is a submodule of a package). The file argument is an open file, and filename is the corresponding file name; these can be None and '', respectively, when the module is not being loaded from a file. The description argument is a tuple, as would be returned by get_suffixes(), describing what kind of module must be loaded. 
If the load is successful, the return value is the module object; otherwise, an exception (usually ImportError) is raised. 

Important: the caller is responsible for closing the file argument, if it was not None, even when an exception is raised. This is best done using a try ... finally statement.
@c

s = """

def foobar(): pass

"""

@ get_suffixes( ) 

Return a list of triples, each describing a particular type of module. Each triple has the form (suffix, mode, type), where suffix is a string to be appended to the module name to form the filename to search for, mode is the mode string to pass to the built-in open() function to open the file (this can be 'r' for text files or 'rb' for binary files), and type is the file type, which has one of the values PY_SOURCE, PY_COMPILED, or C_EXTENSION, described below.
@c

print '-' * 20
description = (".py","r",imp.PY_SOURCE)
theFile = StringIO.StringIO(s) # Create a file-like object
print repr(theFile)
try:
    imp.load_module("myModule",theFile,"myFileName",description)
except:
    g.es_exception()



</t>
<t tx="ekr.20040710141351">import leoGlobals as g
import leoTest
import types

specialDictNames = ('__builtins__','__doc__','__name__','__file__','__module__')

def printDoc(x,s):
    if hasattr(x,"__doc__") and x.__doc__:
        print "%4d %s" % (len(x.__doc__),s)
    else:
        print "%4s %s" % (' ',s)

print '-' * 60
print "%4d %s" % (len(leoTest.__doc__),"leoTest")

if 1:
    for s in leoTest.__dict__:
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) != types.ModuleType:
                printDoc(x,s)
                if type(x) == types.ClassType:
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print ' '*4,
                            printDoc(x2,s2)
else:
    &lt;&lt; print names sorted by type &gt;&gt;</t>
<t tx="ekr.20040710145459">for theType,typeName in (
    (types.ModuleType,"modules"),
    (types.ClassType,"classes"),
    (types.FunctionType,"functions"),
):

    print ; print "%s..." % typeName
    for s in leoTest.__dict__:
        
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) == theType:
                printDoc(x,s)
                if theType == types.ClassType:
                    print "\tmethods..."
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print "\t",
                            printDoc(x2,s2)</t>
<t tx="ekr.20040710180851">import leoGlobals as g
import doctest
import unittest
import leoTest
reload(leoTest)
c = g.top()

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
paths = leoTest.findAllAtFileNodes(c)
modules = leoTest.importAllModulesInPathList(paths)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040711044029.1">import leoGlobals as g
import leoTest
import glob
reload(leoTest)

c = g.top()

print '-' * 40

if 0:
    print "modules in test.leo..."
    paths = leoTest.findAllAtFileNodes(c)
    modules = leoTest.importAllModulesInPathList(paths)
    for module in modules:
        print module
    
if 1:
    print "modules in leo/src..."
    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    for module in modules:
        print module
        
if 0:
    directory = g.os_path_join(g.app.loadDir,"..","src")
    glob_path = g.os_path_join(directory,"leo*.py")
    files = glob.glob(glob_path)
    modules = leoTest.importAllModulesInPathList(files)
    for module in modules:
        print module</t>
<t tx="ekr.20040711060313">import leoGlobals as g
import unittest
import leoTest
reload(leoTest)
c = g.top()

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
path = g.os_path_join(g.app.loadDir,"..","src")
modules = leoTest.importAllModulesInPath(path)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040711085843">import leoGlobals as g
import compiler

c = g.top()
p = c.currentPosition()

for child in p.children_iter():
    h = child.headString()
    body = child.bodyString()
    
    try:
        val = compiler.parse(body)
        print type(val)
        print val
    except SyntaxError:
        g.es("Syntax error: %s" % h,color="blue")</t>
<t tx="ekr.20040711092603">import doctest
print doctest</t>
<t tx="ekr.20040711093916">import leoGlobals as g

if 0:

    class myFile(file):
        pass
        
    print myFile
    print issubclass(myFile,file)
    print isinstance(myFile,file)
    print super(myFile)
    print __import__
    
if 0:
    
    old_import = __import__
        
    def myImport(*args,**keys):
        print "myImport"
        global old_import
        old_import(*args,**keys)
        
    __import__ = myImport
    
mod = __import__("leoApp")
print mod</t>
<t tx="ekr.20040711095508.1">@ignore
@language python
&lt;&lt; ihooks declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040711095508.2">"""Import hook support.

Consistent use of this module will make it possible to change the
different mechanisms involved in loading modules independently.

While the built-in module imp exports interfaces to the built-in
module searching and loading algorithm, and it is possible to replace
the built-in function __import__ in order to change the semantics of
the import statement, until now it has been difficult to combine the
effect of different __import__ hacks, like loading modules from URLs
by rimport.py, or restricted execution by rexec.py.

This module defines three new concepts:

1) A "file system hooks" class provides an interface to a filesystem.

One hooks class is defined (Hooks), which uses the interface provided
by standard modules os and os.path.  It should be used as the base
class for other hooks classes.

2) A "module loader" class provides an interface to search for a
module in a search path and to load it.  It defines a method which
searches for a module in a single directory; by overriding this method
one can redefine the details of the search.  If the directory is None,
built-in and frozen modules are searched instead.

Two module loader class are defined, both implementing the search
strategy used by the built-in __import__ function: ModuleLoader uses
the imp module's find_module interface, while HookableModuleLoader
uses a file system hooks class to interact with the file system.  Both
use the imp module's load_* interfaces to actually load the module.

3) A "module importer" class provides an interface to import a
module, as well as interfaces to reload and unload a module.  It also
provides interfaces to install and uninstall itself instead of the
default __import__ and reload (and unload) functions.

One module importer class is defined (ModuleImporter), which uses a
module loader instance passed in (by default HookableModuleLoader is
instantiated).

The classes defined here should be used as base classes for extended
functionality along those lines.

If a module importer class supports dotted names, its import_module()
must return a different value depending on whether it is called on
behalf of a "from ... import ..." statement or not.  (This is caused
by the way the __import__ hook is used by the Python interpreter.)  It
would also do wise to install a different version of reload().

"""

import __builtin__
import imp
import os
import sys

__all__ = ["BasicModuleLoader","Hooks","ModuleLoader","FancyModuleLoader",
           "BasicModuleImporter","ModuleImporter","install","uninstall"]

VERBOSE = 0

from imp import C_EXTENSION, PY_SOURCE, PY_COMPILED
from imp import C_BUILTIN, PY_FROZEN, PKG_DIRECTORY
BUILTIN_MODULE = C_BUILTIN
FROZEN_MODULE = PY_FROZEN</t>
<t tx="ekr.20040711095508.3">class _Verbose:
    
	@others</t>
<t tx="ekr.20040711095508.4">def __init__(self, verbose = VERBOSE):
    self.verbose = verbose
</t>
<t tx="ekr.20040711095508.5">def get_verbose(self):
    return self.verbose
</t>
<t tx="ekr.20040711095508.6">def set_verbose(self, verbose):
    self.verbose = verbose
</t>
<t tx="ekr.20040711095508.7"># XXX The following is an experimental interface

def note(self, *args):
    if self.verbose:
        self.message(*args)
</t>
<t tx="ekr.20040711095508.8">def message(self, format, *args):
    if args:
        print format%args
    else:
        print format
</t>
<t tx="ekr.20040711095508.9">class BasicModuleLoader(_Verbose):

    """Basic module loader.

    This provides the same functionality as built-in import.  It
    doesn't deal with checking sys.modules -- all it provides is
    find_module() and a load_module(), as well as find_module_in_dir()
    which searches just one directory, and can be overridden by a
    derived class to change the module search algorithm when the basic
    dependency on sys.path is unchanged.

    The interface is a little more convenient than imp's:
    find_module(name, [path]) returns None or 'stuff', and
    load_module(name, stuff) loads the module.

    """

    @others
</t>
<t tx="ekr.20040711095508.10">def find_module(self, name, path = None):

    if path is None:
        path = [None] + self.default_path()

    for dir in path:
        stuff = self.find_module_in_dir(name, dir)
        if stuff: return stuff

    return None
</t>
<t tx="ekr.20040711095508.11">def default_path(self):

    return sys.path
</t>
<t tx="ekr.20040711095508.12">def find_module_in_dir(self, name, dir):

    if dir is None:
        return self.find_builtin_module(name)
    else:
        try:
            return imp.find_module(name, [dir])
        except ImportError:
            return None
</t>
<t tx="ekr.20040711095508.13">def find_builtin_module(self, name):

    # XXX frozen packages?
    if imp.is_builtin(name):
        return None, '', ('', '', BUILTIN_MODULE)

    if imp.is_frozen(name):
        return None, '', ('', '', FROZEN_MODULE)

    return None
</t>
<t tx="ekr.20040711095508.14">def load_module(self, name, stuff):

    file, filename, info = stuff

    try:
        return imp.load_module(name, file, filename, info)
    finally:
        if file: file.close()
</t>
<t tx="ekr.20040711095508.15">class Hooks(_Verbose):

    """Hooks into the filesystem and interpreter.

    By deriving a subclass you can redefine your filesystem interface,
    e.g. to merge it with the URL space.

    This base class behaves just like the native filesystem.

    """
    
	@others

    listdir_error = os.error</t>
<t tx="ekr.20040711095508.17">def get_suffixes(self): return imp.get_suffixes()
</t>
<t tx="ekr.20040711095508.18">def new_module(self, name): return imp.new_module(name)
</t>
<t tx="ekr.20040711095508.19">def is_builtin(self, name): return imp.is_builtin(name)
</t>
<t tx="ekr.20040711095508.20">def init_builtin(self, name): return imp.init_builtin(name)
</t>
<t tx="ekr.20040711095508.21">def is_frozen(self, name): return imp.is_frozen(name)
</t>
<t tx="ekr.20040711095508.22">def init_frozen(self, name): return imp.init_frozen(name)
</t>
<t tx="ekr.20040711095508.23">def get_frozen_object(self, name): return imp.get_frozen_object(name)
</t>
<t tx="ekr.20040711095508.24">def load_source(self, name, filename, file=None):

    return imp.load_source(name, filename, file)
</t>
<t tx="ekr.20040711095508.25">def load_compiled(self, name, filename, file=None):
    return imp.load_compiled(name, filename, file)
</t>
<t tx="ekr.20040711095508.26">def load_dynamic(self, name, filename, file=None):
    return imp.load_dynamic(name, filename, file)
</t>
<t tx="ekr.20040711095508.27">def load_package(self, name, filename, file=None):
    return imp.load_module(name, file, filename, ("", "", PKG_DIRECTORY))
</t>
<t tx="ekr.20040711095508.28">def add_module(self, name):
    d = self.modules_dict()
    if name in d: return d[name]
    d[name] = m = self.new_module(name)
    return m
</t>
<t tx="ekr.20040711095508.29">def modules_dict(self): return sys.modules
</t>
<t tx="ekr.20040711095508.30">def default_path(self): return sys.path
</t>
<t tx="ekr.20040711095508.31">def path_split(self, x): return os.path.split(x)
</t>
<t tx="ekr.20040711095508.32">def path_join(self, x, y): return os.path.join(x, y)
</t>
<t tx="ekr.20040711095508.33">def path_isabs(self, x): return os.path.isabs(x)
</t>
<t tx="ekr.20040711095508.34">def path_exists(self, x): return os.path.exists(x)
</t>
<t tx="ekr.20040711095508.35">def path_isdir(self, x): return os.path.isdir(x)
</t>
<t tx="ekr.20040711095508.36">def path_isfile(self, x): return os.path.isfile(x)
</t>
<t tx="ekr.20040711095508.37">def path_islink(self, x): return os.path.islink(x)
</t>
<t tx="ekr.20040711095508.38">def openfile(self, *x): return open(*x)

openfile_error = IOError</t>
<t tx="ekr.20040711095508.39">def listdir(self, x): return os.listdir(x)
</t>
<t tx="ekr.20040711095508.40">class ModuleLoader(BasicModuleLoader):

    """Default module loader; uses file system hooks.

    By defining suitable hooks, you might be able to load modules from
    other sources than the file system, e.g. from compressed or
    encrypted files, tar files or (if you're brave!) URLs.

    """
	@others
</t>
<t tx="ekr.20040711095508.41">def __init__(self, hooks = None, verbose = VERBOSE):
    BasicModuleLoader.__init__(self, verbose)
    self.hooks = hooks or Hooks(verbose)
</t>
<t tx="ekr.20040711095508.42">def default_path(self):

    return self.hooks.default_path()
</t>
<t tx="ekr.20040711095508.43">def modules_dict(self):

    return self.hooks.modules_dict()
</t>
<t tx="ekr.20040711095508.44">def get_hooks(self):

    return self.hooks
</t>
<t tx="ekr.20040711095508.45">def set_hooks(self, hooks):

    self.hooks = hooks
</t>
<t tx="ekr.20040711095508.46">def find_builtin_module(self, name):

    # XXX frozen packages?
    if self.hooks.is_builtin(name):
        return None, '', ('', '', BUILTIN_MODULE)

    if self.hooks.is_frozen(name):
        return None, '', ('', '', FROZEN_MODULE)

    return None
</t>
<t tx="ekr.20040711095508.47">def find_module_in_dir(self, name, dir, allow_packages=1):

    if dir is None:
        return self.find_builtin_module(name)

    if allow_packages:
        fullname = self.hooks.path_join(dir, name)
        if self.hooks.path_isdir(fullname):
            stuff = self.find_module_in_dir("__init__", fullname, 0)
            if stuff:
                file = stuff[0]
                if file: file.close()
                return None, fullname, ('', '', PKG_DIRECTORY)

    for info in self.hooks.get_suffixes():
        suff, mode, type = info
        fullname = self.hooks.path_join(dir, name+suff)
        try:
            fp = self.hooks.openfile(fullname, mode)
            return fp, fullname, info
        except self.hooks.openfile_error:
            pass

    return None
</t>
<t tx="ekr.20040711095508.48">def load_module(self, name, stuff):
    file, filename, info = stuff
    (suff, mode, type) = info
    try:
        if type == BUILTIN_MODULE:
            return self.hooks.init_builtin(name)
        if type == FROZEN_MODULE:
            return self.hooks.init_frozen(name)
        if type == C_EXTENSION:
            m = self.hooks.load_dynamic(name, filename, file)
        elif type == PY_SOURCE:
            m = self.hooks.load_source(name, filename, file)
        elif type == PY_COMPILED:
            m = self.hooks.load_compiled(name, filename, file)
        elif type == PKG_DIRECTORY:
            m = self.hooks.load_package(name, filename, file)
        else:
            raise ImportError, "Unrecognized module type (%s) for %s" % \
                  (`type`, name)
    finally:
        if file: file.close()
    m.__file__ = filename
    return m
</t>
<t tx="ekr.20040711095508.49">class FancyModuleLoader(ModuleLoader):

    """Fancy module loader -- parses and execs the code itself."""

	@others
</t>
<t tx="ekr.20040711095508.50">def load_module(self, name, stuff):
    file, filename, (suff, mode, type) = stuff
    realfilename = filename
    path = None

    if type == PKG_DIRECTORY:
        initstuff = self.find_module_in_dir("__init__", filename, 0)
        if not initstuff:
            raise ImportError, "No __init__ module in package %s" % name
        initfile, initfilename, initinfo = initstuff
        initsuff, initmode, inittype = initinfo
        if inittype not in (PY_COMPILED, PY_SOURCE):
            if initfile: initfile.close()
            raise ImportError, \
                "Bad type (%s) for __init__ module in package %s" % (
                `inittype`, name)
        path = [filename]
        file = initfile
        realfilename = initfilename
        type = inittype

    if type == FROZEN_MODULE:
        code = self.hooks.get_frozen_object(name)
    elif type == PY_COMPILED:
        import marshal
        file.seek(8)
        code = marshal.load(file)
    elif type == PY_SOURCE:
        data = file.read()
        code = compile(data, realfilename, 'exec')
    else:
        return ModuleLoader.load_module(self, name, stuff)

    m = self.hooks.add_module(name)
    if path:
        m.__path__ = path
    m.__file__ = filename
    exec code in m.__dict__
    return m</t>
<t tx="ekr.20040711095508.51">class BasicModuleImporter(_Verbose):

    """Basic module importer; uses module loader.

    This provides basic import facilities but no package imports.

    """
	@others
</t>
<t tx="ekr.20040711095508.52">def __init__(self, loader = None, verbose = VERBOSE):

    _Verbose.__init__(self, verbose)
    self.loader = loader or ModuleLoader(None, verbose)
    self.modules = self.loader.modules_dict()
</t>
<t tx="ekr.20040711095508.53">def get_loader(self):
    return self.loader
</t>
<t tx="ekr.20040711095508.54">def set_loader(self, loader):
    self.loader = loader
</t>
<t tx="ekr.20040711095508.55">def get_hooks(self):
    return self.loader.get_hooks()
</t>
<t tx="ekr.20040711095508.56">def set_hooks(self, hooks):
    return self.loader.set_hooks(hooks)
</t>
<t tx="ekr.20040711095508.57">def import_module(self, name, globals={}, locals={}, fromlist=[]):
    
    name = str(name)
    if name in self.modules:
        return self.modules[name] # Fast path

    stuff = self.loader.find_module(name)
    if not stuff:
        raise ImportError, "No module named %s" % name

    return self.loader.load_module(name, stuff)
</t>
<t tx="ekr.20040711095508.58">def reload(self, module, path = None):

    name = str(module.__name__)
    stuff = self.loader.find_module(name, path)
    if not stuff:
        raise ImportError, "Module %s not found for reload" % name
    return self.loader.load_module(name, stuff)
</t>
<t tx="ekr.20040711095508.59">def unload(self, module):

    del self.modules[str(module.__name__)]
</t>
<t tx="ekr.20040711095508.60"># XXX Should this try to clear the module's namespace?

def install(self):
    
    self.save_import_module = __builtin__.__import__
    self.save_reload = __builtin__.reload
    
    if not hasattr(__builtin__, 'unload'):
        __builtin__.unload = None
        
    self.save_unload = __builtin__.unload
    
    __builtin__.__import__ = self.import_module
    __builtin__.reload = self.reload
    __builtin__.unload = self.unload
</t>
<t tx="ekr.20040711095508.61">def uninstall(self):
    
    __builtin__.__import__ = self.save_import_module
    __builtin__.reload = self.save_reload
    __builtin__.unload = self.save_unload

    if not __builtin__.unload:
        del __builtin__.unload
</t>
<t tx="ekr.20040711095508.62">class ModuleImporter(BasicModuleImporter):

    """A module importer that supports packages."""
	@others
</t>
<t tx="ekr.20040711095508.63">def import_module(self, name, globals=None, locals=None, fromlist=None):
    parent = self.determine_parent(globals)
    q, tail = self.find_head_package(parent, str(name))
    m = self.load_tail(q, tail)
    if not fromlist:
        return q
    if hasattr(m, "__path__"):
        self.ensure_fromlist(m, fromlist)
    return m
</t>
<t tx="ekr.20040711095508.64">def determine_parent(self, globals):
    if not globals or not "__name__" in globals:
        return None
    pname = globals['__name__']
    if "__path__" in globals:
        parent = self.modules[pname]
        assert globals is parent.__dict__
        return parent
    if '.' in pname:
        i = pname.rfind('.')
        pname = pname[:i]
        parent = self.modules[pname]
        assert parent.__name__ == pname
        return parent
    return None
</t>
<t tx="ekr.20040711095508.65">def find_head_package(self, parent, name):
    if '.' in name:
        i = name.find('.')
        head = name[:i]
        tail = name[i+1:]
    else:
        head = name
        tail = ""
    if parent:
        qname = "%s.%s" % (parent.__name__, head)
    else:
        qname = head
    q = self.import_it(head, qname, parent)
    if q: return q, tail
    if parent:
        qname = head
        parent = None
        q = self.import_it(head, qname, parent)
        if q: return q, tail
    raise ImportError, "No module named " + qname
</t>
<t tx="ekr.20040711095508.66">def load_tail(self, q, tail):
    m = q
    while tail:
        i = tail.find('.')
        if i &lt; 0: i = len(tail)
        head, tail = tail[:i], tail[i+1:]
        mname = "%s.%s" % (m.__name__, head)
        m = self.import_it(head, mname, m)
        if not m:
            raise ImportError, "No module named " + mname
    return m
</t>
<t tx="ekr.20040711095508.67">def ensure_fromlist(self, m, fromlist, recursive=0):
    for sub in fromlist:
        if sub == "*":
            if not recursive:
                try:
                    all = m.__all__
                except AttributeError:
                    pass
                else:
                    self.ensure_fromlist(m, all, 1)
            continue
        if sub != "*" and not hasattr(m, sub):
            subname = "%s.%s" % (m.__name__, sub)
            submod = self.import_it(sub, subname, m)
            if not submod:
                raise ImportError, "No module named " + subname
</t>
<t tx="ekr.20040711095508.68">def import_it(self, partname, fqname, parent, force_load=0):
    if not partname:
        raise ValueError, "Empty module name"
    if not force_load:
        try:
            return self.modules[fqname]
        except KeyError:
            pass
    try:
        path = parent and parent.__path__
    except AttributeError:
        return None
    partname = str(partname)
    stuff = self.loader.find_module(partname, path)
    if not stuff:
        return None
    fqname = str(fqname)
    m = self.loader.load_module(fqname, stuff)
    if parent:
        setattr(parent, partname, m)
    return m
</t>
<t tx="ekr.20040711095508.69">def reload(self, module):
    name = str(module.__name__)
    if '.' not in name:
        return self.import_it(name, name, None, force_load=1)
    i = name.rfind('.')
    pname = name[:i]
    parent = self.modules[pname]
    return self.import_it(name[i+1:], name, parent, force_load=1)
</t>
<t tx="ekr.20040711095508.70">default_importer = None
current_importer = None

def install(importer = None):
    global current_importer
    current_importer = importer or default_importer or ModuleImporter()
    current_importer.install()
</t>
<t tx="ekr.20040711095508.71">def uninstall():
    global current_importer
    current_importer.uninstall()
</t>
<t tx="ekr.20040711100837"></t>
<t tx="ekr.20040711100837.1"></t>
<t tx="ekr.20040711100837.2"></t>
<t tx="ekr.20040711100837.3"></t>
<t tx="ekr.20040711101236"></t>
<t tx="ekr.20040711101642"></t>
<t tx="ekr.20040711101642.1"></t>
<t tx="ekr.20040711113027"></t>
<t tx="ekr.20040711113027.1">@ignore
@language c
/* Module definition and import implementation */

&lt;&lt; import #includes &gt;&gt;
&lt;&lt; import declarations &gt;&gt;
@others
</t>
<t tx="ekr.20040711113027.2">#include "Python.h"

#include "node.h"
#include "token.h"
#include "errcode.h"
#include "marshal.h"
#include "compile.h"
#include "eval.h"
#include "osdefs.h"
#include "importdl.h"

#ifdef HAVE_FCNTL_H
#include &lt;fcntl.h&gt;
#endif
</t>
<t tx="ekr.20040711113027.3">extern time_t PyOS_GetLastModificationTime(char *, FILE *);
						/* In getmtime.c */

/* Magic word to reject .pyc files generated by other Python versions.
   It should change for each incompatible change to the bytecode.

   The value of CR and LF is incorporated so if you ever read or write
   a .pyc file in text mode the magic number will be wrong; also, the
   Apple MPW compiler swaps their values, botching string constants.

   The magic numbers must be spaced apart atleast 2 values, as the
   -U interpeter flag will cause MAGIC+1 being used. They have been
   odd numbers for some time now.

   There were a variety of old schemes for setting the magic number.
   The current working scheme is to increment the previous value by
   10.

   Known values:
       Python 1.5:   20121
       Python 1.5.1: 20121
       Python 1.5.2: 20121
       Python 2.0:   50823
       Python 2.0.1: 50823
       Python 2.1:   60202
       Python 2.1.1: 60202
       Python 2.1.2: 60202
       Python 2.2:   60717
       Python 2.3a0: 62011
       Python 2.3a0: 62021
       Python 2.3a0: 62011 (!)
       Python 2.4a0: 62041
*/
#define MAGIC (62041 | ((long)'\r'&lt;&lt;16) | ((long)'\n'&lt;&lt;24))

/* Magic word as global; note that _PyImport_Init() can change the
   value of this global to accommodate for alterations of how the
   compiler works which are enabled by command line switches. */
static long pyc_magic = MAGIC;

/* See _PyImport_FixupExtension() below */
static PyObject *extensions = NULL;

/* This table is defined in config.c: */
extern struct _inittab _PyImport_Inittab[];

struct _inittab *PyImport_Inittab = _PyImport_Inittab;

/* these tables define the module suffixes that Python recognizes */
struct filedescr * _PyImport_Filetab = NULL;

#ifdef RISCOS
    static const struct filedescr _PyImport_StandardFiletab[] = {
        {"/py", "U", PY_SOURCE},
        {"/pyc", "rb", PY_COMPILED},
        {0, 0}
    };
#else
    static const struct filedescr _PyImport_StandardFiletab[] = {
        {".py", "U", PY_SOURCE},
    #ifdef MS_WINDOWS
        {".pyw", "U", PY_SOURCE},
    #endif
        {".pyc", "rb", PY_COMPILED},
        {0, 0}
    };
#endif</t>
<t tx="ekr.20040711113027.4">/* Initialize things */

void
_PyImport_Init(void)
{
	const struct filedescr *scan;
	struct filedescr *filetab;
	int countD = 0;
	int countS = 0;

	/* prepare _PyImport_Filetab: copy entries from
	   _PyImport_DynLoadFiletab and _PyImport_StandardFiletab.
	 */
	for (scan = _PyImport_DynLoadFiletab; scan-&gt;suffix != NULL; ++scan)
		++countD;
	for (scan = _PyImport_StandardFiletab; scan-&gt;suffix != NULL; ++scan)
		++countS;
	filetab = PyMem_NEW(struct filedescr, countD + countS + 1);
	memcpy(filetab, _PyImport_DynLoadFiletab,
	       countD * sizeof(struct filedescr));
	memcpy(filetab + countD, _PyImport_StandardFiletab,
	       countS * sizeof(struct filedescr));
	filetab[countD + countS].suffix = NULL;

	_PyImport_Filetab = filetab;

	if (Py_OptimizeFlag) {
		/* Replace ".pyc" with ".pyo" in _PyImport_Filetab */
		for (; filetab-&gt;suffix != NULL; filetab++) {
#ifndef RISCOS
			if (strcmp(filetab-&gt;suffix, ".pyc") == 0)
				filetab-&gt;suffix = ".pyo";
#else
			if (strcmp(filetab-&gt;suffix, "/pyc") == 0)
				filetab-&gt;suffix = "/pyo";
#endif
		}
	}

	if (Py_UnicodeFlag) {
		/* Fix the pyc_magic so that byte compiled code created
		   using the all-Unicode method doesn't interfere with
		   code created in normal operation mode. */
		pyc_magic = MAGIC + 1;
	}
}
</t>
<t tx="ekr.20040711113027.5">
void
_PyImportHooks_Init(void)
{
	PyObject *v, *path_hooks = NULL, *zimpimport;
	int err = 0;

	/* adding sys.path_hooks and sys.path_importer_cache, setting up
	   zipimport */

	if (Py_VerboseFlag)
		PySys_WriteStderr("# installing zipimport hook\n");

	v = PyList_New(0);
	if (v == NULL)
		goto error;
	err = PySys_SetObject("meta_path", v);
	Py_DECREF(v);
	if (err)
		goto error;
	v = PyDict_New();
	if (v == NULL)
		goto error;
	err = PySys_SetObject("path_importer_cache", v);
	Py_DECREF(v);
	if (err)
		goto error;
	path_hooks = PyList_New(0);
	if (path_hooks == NULL)
		goto error;
	err = PySys_SetObject("path_hooks", path_hooks);
	if (err) {
  error:
		PyErr_Print();
		Py_FatalError("initializing sys.meta_path, sys.path_hooks or "
			      "path_importer_cache failed");
	}
	zimpimport = PyImport_ImportModule("zipimport");
	if (zimpimport == NULL) {
		PyErr_Clear(); /* No zip import module -- okay */
		if (Py_VerboseFlag)
			PySys_WriteStderr("# can't import zipimport\n");
	}
	else {
		PyObject *zipimporter = PyObject_GetAttrString(zimpimport,
							       "zipimporter");
		Py_DECREF(zimpimport);
		if (zipimporter == NULL) {
			PyErr_Clear(); /* No zipimporter object -- okay */
			if (Py_VerboseFlag)
				PySys_WriteStderr(
				    "# can't import zipimport.zipimporter\n");
		}
		else {
			/* sys.path_hooks.append(zipimporter) */
			err = PyList_Append(path_hooks, zipimporter);
			Py_DECREF(zipimporter);
			if (err)
				goto error;
			if (Py_VerboseFlag)
				PySys_WriteStderr(
					"# installed zipimport hook\n");
		}
	}
	Py_DECREF(path_hooks);
}
</t>
<t tx="ekr.20040711113027.6">
void
_PyImport_Fini(void)
{
	Py_XDECREF(extensions);
	extensions = NULL;
	PyMem_DEL(_PyImport_Filetab);
	_PyImport_Filetab = NULL;
}
</t>
<t tx="ekr.20040711113027.7">@ Locking primitives to prevent parallel imports of the same module  in different threads to return with a partially loaded module.  These calls are serialized by the global interpreter lock.
@c

#ifdef WITH_THREAD

#include "pythread.h"

static PyThread_type_lock import_lock = 0;
static long import_lock_thread = -1;
static int import_lock_level = 0;

static void
lock_import(void)
{
	long me = PyThread_get_thread_ident();
	if (me == -1)
		return; /* Too bad */
	if (import_lock == NULL)
		import_lock = PyThread_allocate_lock();
	if (import_lock_thread == me) {
		import_lock_level++;
		return;
	}
	if (import_lock_thread != -1 || !PyThread_acquire_lock(import_lock, 0))
	{
		PyThreadState *tstate = PyEval_SaveThread();
		PyThread_acquire_lock(import_lock, 1);
		PyEval_RestoreThread(tstate);
	}
	import_lock_thread = me;
	import_lock_level = 1;
}
</t>
<t tx="ekr.20040711113027.8">
static int
unlock_import(void)
{
	long me = PyThread_get_thread_ident();
	if (me == -1)
		return 0; /* Too bad */
	if (import_lock_thread != me)
		return -1;
	import_lock_level--;
	if (import_lock_level == 0) {
		import_lock_thread = -1;
		PyThread_release_lock(import_lock);
	}
	return 1;
}
</t>
<t tx="ekr.20040711113027.9">
#else

#define lock_import()
#define unlock_import() 0

#endif

static PyObject *
imp_lock_held(PyObject *self, PyObject *noargs)
{
#ifdef WITH_THREAD
	return PyBool_FromLong(import_lock_thread != -1);
#else
	return PyBool_FromLong(0);
#endif
}
</t>
<t tx="ekr.20040711113027.10">
static PyObject *
imp_acquire_lock(PyObject *self, PyObject *noargs)
{
#ifdef WITH_THREAD
	lock_import();
#endif
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20040711113027.11">
static PyObject *
imp_release_lock(PyObject *self, PyObject *noargs)
{
#ifdef WITH_THREAD
	if (unlock_import() &lt; 0) {
		PyErr_SetString(PyExc_RuntimeError,
				"not holding the import lock");
		return NULL;
	}
#endif
	Py_INCREF(Py_None);
	return Py_None;
}
</t>
<t tx="ekr.20040711113027.12">@ Helper for sys
@c

PyObject *
PyImport_GetModuleDict(void)
{
	PyInterpreterState *interp = PyThreadState_GET()-&gt;interp;
	if (interp-&gt;modules == NULL)
		Py_FatalError("PyImport_GetModuleDict: no module dictionary!");
	return interp-&gt;modules;
}
</t>
<t tx="ekr.20040711113027.13">@ List of names to clear in sys
@c

static char* sys_deletes[] = {
	"path", "argv", "ps1", "ps2", "exitfunc",
	"exc_type", "exc_value", "exc_traceback",
	"last_type", "last_value", "last_traceback",
	"path_hooks", "path_importer_cache", "meta_path",
	NULL
};

static char* sys_files[] = {
	"stdin", "__stdin__",
	"stdout", "__stdout__",
	"stderr", "__stderr__",
	NULL
};


/* Un-initialize things, as good as we can */

void
PyImport_Cleanup(void)
{
	int pos, ndone;
	char *name;
	PyObject *key, *value, *dict;
	PyInterpreterState *interp = PyThreadState_GET()-&gt;interp;
	PyObject *modules = interp-&gt;modules;

	if (modules == NULL)
		return; /* Already done */

	/* Delete some special variables first.  These are common
	   places where user values hide and people complain when their
	   destructors fail.  Since the modules containing them are
	   deleted *last* of all, they would come too late in the normal
	   destruction order.  Sigh. */

	value = PyDict_GetItemString(modules, "__builtin__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		dict = PyModule_GetDict(value);
		if (Py_VerboseFlag)
			PySys_WriteStderr("# clear __builtin__._\n");
		PyDict_SetItemString(dict, "_", Py_None);
	}
	value = PyDict_GetItemString(modules, "sys");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		char **p;
		PyObject *v;
		dict = PyModule_GetDict(value);
		for (p = sys_deletes; *p != NULL; p++) {
			if (Py_VerboseFlag)
				PySys_WriteStderr("# clear sys.%s\n", *p);
			PyDict_SetItemString(dict, *p, Py_None);
		}
		for (p = sys_files; *p != NULL; p+=2) {
			if (Py_VerboseFlag)
				PySys_WriteStderr("# restore sys.%s\n", *p);
			v = PyDict_GetItemString(dict, *(p+1));
			if (v == NULL)
				v = Py_None;
			PyDict_SetItemString(dict, *p, v);
		}
	}

	/* First, delete __main__ */
	value = PyDict_GetItemString(modules, "__main__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup __main__\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "__main__", Py_None);
	}

	/* The special treatment of __builtin__ here is because even
	   when it's not referenced as a module, its dictionary is
	   referenced by almost every module's __builtins__.  Since
	   deleting a module clears its dictionary (even if there are
	   references left to it), we need to delete the __builtin__
	   module last.  Likewise, we don't delete sys until the very
	   end because it is implicitly referenced (e.g. by print).

	   Also note that we 'delete' modules by replacing their entry
	   in the modules dict with None, rather than really deleting
	   them; this avoids a rehash of the modules dictionary and
	   also marks them as "non existent" so they won't be
	   re-imported. */

	/* Next, repeatedly delete modules with a reference count of
	   one (skipping __builtin__ and sys) and delete them */
	do {
		ndone = 0;
		pos = 0;
		while (PyDict_Next(modules, &amp;pos, &amp;key, &amp;value)) {
			if (value-&gt;ob_refcnt != 1)
				continue;
			if (PyString_Check(key) &amp;&amp; PyModule_Check(value)) {
				name = PyString_AS_STRING(key);
				if (strcmp(name, "__builtin__") == 0)
					continue;
				if (strcmp(name, "sys") == 0)
					continue;
				if (Py_VerboseFlag)
					PySys_WriteStderr(
						"# cleanup[1] %s\n", name);
				_PyModule_Clear(value);
				PyDict_SetItem(modules, key, Py_None);
				ndone++;
			}
		}
	} while (ndone &gt; 0);

	/* Next, delete all modules (still skipping __builtin__ and sys) */
	pos = 0;
	while (PyDict_Next(modules, &amp;pos, &amp;key, &amp;value)) {
		if (PyString_Check(key) &amp;&amp; PyModule_Check(value)) {
			name = PyString_AS_STRING(key);
			if (strcmp(name, "__builtin__") == 0)
				continue;
			if (strcmp(name, "sys") == 0)
				continue;
			if (Py_VerboseFlag)
				PySys_WriteStderr("# cleanup[2] %s\n", name);
			_PyModule_Clear(value);
			PyDict_SetItem(modules, key, Py_None);
		}
	}

	/* Next, delete sys and __builtin__ (in that order) */
	value = PyDict_GetItemString(modules, "sys");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup sys\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "sys", Py_None);
	}
	value = PyDict_GetItemString(modules, "__builtin__");
	if (value != NULL &amp;&amp; PyModule_Check(value)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# cleanup __builtin__\n");
		_PyModule_Clear(value);
		PyDict_SetItemString(modules, "__builtin__", Py_None);
	}

	/* Finally, clear and delete the modules directory */
	PyDict_Clear(modules);
	interp-&gt;modules = NULL;
	Py_DECREF(modules);
}
</t>
<t tx="ekr.20040711113027.14">@ Helper for pythonrun.c -- return magic number
@c

long
PyImport_GetMagicNumber(void)
{
	return pyc_magic;
}
</t>
<t tx="ekr.20040711113027.15">@ Magic for extension modules (built-in as well as dynamically  loaded). To prevent initializing an extension module more than  once, we keep a static dictionary 'extensions' keyed by module name  (for built-in modules) or by filename (for dynamically loaded  modules), containing these modules. A copy of the module's  dictionary is stored by calling _PyImport_FixupExtension()  immediately after the module initialization function succeeds. A  copy can be retrieved from there by calling  _PyImport_FindExtension().
@c

PyObject *
_PyImport_FixupExtension(char *name, char *filename)
{
	PyObject *modules, *mod, *dict, *copy;
	if (extensions == NULL) {
		extensions = PyDict_New();
		if (extensions == NULL)
			return NULL;
	}
	modules = PyImport_GetModuleDict();
	mod = PyDict_GetItemString(modules, name);
	if (mod == NULL || !PyModule_Check(mod)) {
		PyErr_Format(PyExc_SystemError,
		  "_PyImport_FixupExtension: module %.200s not loaded", name);
		return NULL;
	}
	dict = PyModule_GetDict(mod);
	if (dict == NULL)
		return NULL;
	copy = PyDict_Copy(dict);
	if (copy == NULL)
		return NULL;
	PyDict_SetItemString(extensions, filename, copy);
	Py_DECREF(copy);
	return copy;
}
</t>
<t tx="ekr.20040711113027.16">
PyObject *
_PyImport_FindExtension(char *name, char *filename)
{
	PyObject *dict, *mod, *mdict;
	if (extensions == NULL)
		return NULL;
	dict = PyDict_GetItemString(extensions, filename);
	if (dict == NULL)
		return NULL;
	mod = PyImport_AddModule(name);
	if (mod == NULL)
		return NULL;
	mdict = PyModule_GetDict(mod);
	if (mdict == NULL)
		return NULL;
	if (PyDict_Update(mdict, dict))
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # previously loaded (%s)\n",
			name, filename);
	return mod;
}
</t>
<t tx="ekr.20040711113027.17">@ Get the module object corresponding to a module name.  First check the modules dictionary if there's one there,  if not, create a new one and insert it in the modules dictionary.  Because the former action is most common, THIS DOES NOT RETURN A  'NEW' REFERENCE!
@c

PyObject *
PyImport_AddModule(char *name)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m;

	if ((m = PyDict_GetItemString(modules, name)) != NULL &amp;&amp;
	    PyModule_Check(m))
		return m;
	m = PyModule_New(name);
	if (m == NULL)
		return NULL;
	if (PyDict_SetItemString(modules, name, m) != 0) {
		Py_DECREF(m);
		return NULL;
	}
	Py_DECREF(m); /* Yes, it still exists, in modules! */

	return m;
}
</t>
<t tx="ekr.20040711113027.18">@ Execute a code object in a module and return the module object  WITH INCREMENTED REFERENCE COUNT
@c

PyObject *
PyImport_ExecCodeModule(char *name, PyObject *co)
{
	return PyImport_ExecCodeModuleEx(name, co, (char *)NULL);
}
</t>
<t tx="ekr.20040711113027.19">
PyObject *
PyImport_ExecCodeModuleEx(char *name, PyObject *co, char *pathname)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m, *d, *v;

	m = PyImport_AddModule(name);
	if (m == NULL)
		return NULL;
	/* If the module is being reloaded, we get the old module back
	   and re-use its dict to exec the new code. */
	d = PyModule_GetDict(m);
	if (PyDict_GetItemString(d, "__builtins__") == NULL) {
		if (PyDict_SetItemString(d, "__builtins__",
					 PyEval_GetBuiltins()) != 0)
			return NULL;
	}
	/* Remember the filename as the __file__ attribute */
	v = NULL;
	if (pathname != NULL) {
		v = PyString_FromString(pathname);
		if (v == NULL)
			PyErr_Clear();
	}
	if (v == NULL) {
		v = ((PyCodeObject *)co)-&gt;co_filename;
		Py_INCREF(v);
	}
	if (PyDict_SetItemString(d, "__file__", v) != 0)
		PyErr_Clear(); /* Not important enough to report */
	Py_DECREF(v);

	v = PyEval_EvalCode((PyCodeObject *)co, d, d);
	if (v == NULL)
		return NULL;
	Py_DECREF(v);

	if ((m = PyDict_GetItemString(modules, name)) == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Loaded module %.200s not found in sys.modules",
			     name);
		return NULL;
	}

	Py_INCREF(m);

	return m;
}
</t>
<t tx="ekr.20040711113027.20">@ Given a pathname for a Python source file, fill a buffer with the  pathname for the corresponding compiled file. Return the pathname  for the compiled file, or NULL if there's no space in the buffer.  Doesn't set an exception.
@c

static char *
make_compiled_pathname(char *pathname, char *buf, size_t buflen)
{
	size_t len = strlen(pathname);
	if (len+2 &gt; buflen)
		return NULL;

#ifdef MS_WINDOWS
	/* Treat .pyw as if it were .py.  The case of ".pyw" must match
	   that used in _PyImport_StandardFiletab. */
	if (len &gt;= 4 &amp;&amp; strcmp(&amp;pathname[len-4], ".pyw") == 0)
		--len;	/* pretend 'w' isn't there */
#endif
	memcpy(buf, pathname, len);
	buf[len] = Py_OptimizeFlag ? 'o' : 'c';
	buf[len+1] = '\0';

	return buf;
}
</t>
<t tx="ekr.20040711113027.21">@ Given a pathname for a Python source file, its time of last  modification, and a pathname for a compiled file, check whether the  compiled file represents the same version of the source. If so,  return a FILE pointer for the compiled file, positioned just after  the header; if not, return NULL.  Doesn't set an exception.
@c

static FILE *
check_compiled_module(char *pathname, long mtime, char *cpathname)
{
	FILE *fp;
	long magic;
	long pyc_mtime;

	fp = fopen(cpathname, "rb");
	if (fp == NULL)
		return NULL;
	magic = PyMarshal_ReadLongFromFile(fp);
	if (magic != pyc_magic) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# %s has bad magic\n", cpathname);
		fclose(fp);
		return NULL;
	}
	pyc_mtime = PyMarshal_ReadLongFromFile(fp);
	if (pyc_mtime != mtime) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# %s has bad mtime\n", cpathname);
		fclose(fp);
		return NULL;
	}
	if (Py_VerboseFlag)
		PySys_WriteStderr("# %s matches %s\n", cpathname, pathname);
	return fp;
}
</t>
<t tx="ekr.20040711113027.22">@ Read a code object from a file and check it for validity
@c

static PyCodeObject *
read_compiled_module(char *cpathname, FILE *fp)
{
	PyObject *co;

	co = PyMarshal_ReadLastObjectFromFile(fp);
	if (co == NULL)
		return NULL;
	if (!PyCode_Check(co)) {
		PyErr_Format(PyExc_ImportError,
			     "Non-code object in %.200s", cpathname);
		Py_DECREF(co);
		return NULL;
	}
	return (PyCodeObject *)co;
}
</t>
<t tx="ekr.20040711113027.23">@ Load a module from a compiled file, execute it, and return its  module object WITH INCREMENTED REFERENCE COUNT
@c

static PyObject *
load_compiled_module(char *name, char *cpathname, FILE *fp)
{
	long magic;
	PyCodeObject *co;
	PyObject *m;

	magic = PyMarshal_ReadLongFromFile(fp);
	if (magic != pyc_magic) {
		PyErr_Format(PyExc_ImportError,
			     "Bad magic number in %.200s", cpathname);
		return NULL;
	}
	(void) PyMarshal_ReadLongFromFile(fp);
	co = read_compiled_module(cpathname, fp);
	if (co == NULL)
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # precompiled from %s\n",
			name, cpathname);
	m = PyImport_ExecCodeModuleEx(name, (PyObject *)co, cpathname);
	Py_DECREF(co);

	return m;
}
</t>
<t tx="ekr.20040711113027.24">@ Parse a source file and return the corresponding code object
@c

static PyCodeObject *
parse_source_module(char *pathname, FILE *fp)
{
	PyCodeObject *co;
	node *n;

	n = PyParser_SimpleParseFile(fp, pathname, Py_file_input);
	if (n == NULL)
		return NULL;
	co = PyNode_Compile(n, pathname);
	PyNode_Free(n);

	return co;
}
</t>
<t tx="ekr.20040711113027.25">@ Helper to open a bytecode file for writing in exclusive mode
@c

static FILE *
open_exclusive(char *filename)
{
#if defined(O_EXCL)&amp;&amp;defined(O_CREAT)&amp;&amp;defined(O_WRONLY)&amp;&amp;defined(O_TRUNC)
	/* Use O_EXCL to avoid a race condition when another process tries to
	   write the same file.  When that happens, our open() call fails,
	   which is just fine (since it's only a cache).
	   XXX If the file exists and is writable but the directory is not
	   writable, the file will never be written.  Oh well.
	*/
	int fd;
	(void) unlink(filename);
	fd = open(filename, O_EXCL|O_CREAT|O_WRONLY|O_TRUNC
#ifdef O_BINARY
				|O_BINARY   /* necessary for Windows */
#endif
#ifdef __VMS
                        , 0666, "ctxt=bin", "shr=nil");
#else
                        , 0666);
#endif
	if (fd &lt; 0)
		return NULL;
	return fdopen(fd, "wb");
#else
	/* Best we can do -- on Windows this can't happen anyway */
	return fopen(filename, "wb");
#endif
}
</t>
<t tx="ekr.20040711113027.26">@ Write a compiled module to a file, placing the time of last  modification of its source into the header.  Errors are ignored, if a write error occurs an attempt is made to  remove the file.
@c

static void
write_compiled_module(PyCodeObject *co, char *cpathname, long mtime)
{
	FILE *fp;

	fp = open_exclusive(cpathname);
	if (fp == NULL) {
		if (Py_VerboseFlag)
			PySys_WriteStderr(
				"# can't create %s\n", cpathname);
		return;
	}
	PyMarshal_WriteLongToFile(pyc_magic, fp, Py_MARSHAL_VERSION);
	/* First write a 0 for mtime */
	PyMarshal_WriteLongToFile(0L, fp, Py_MARSHAL_VERSION);
	PyMarshal_WriteObjectToFile((PyObject *)co, fp, Py_MARSHAL_VERSION);
	if (fflush(fp) != 0 || ferror(fp)) {
		if (Py_VerboseFlag)
			PySys_WriteStderr("# can't write %s\n", cpathname);
		/* Don't keep partial file */
		fclose(fp);
		(void) unlink(cpathname);
		return;
	}
	/* Now write the true mtime */
	fseek(fp, 4L, 0);
	PyMarshal_WriteLongToFile(mtime, fp, Py_MARSHAL_VERSION);
	fflush(fp);
	fclose(fp);
	if (Py_VerboseFlag)
		PySys_WriteStderr("# wrote %s\n", cpathname);
}
</t>
<t tx="ekr.20040711113027.27">@ Load a source module from a given file and return its module  object WITH INCREMENTED REFERENCE COUNT. If there's a matching  byte-compiled file, use that instead.
@c

static PyObject *
load_source_module(char *name, char *pathname, FILE *fp)
{
	time_t mtime;
	FILE *fpc;
	char buf[MAXPATHLEN+1];
	char *cpathname;
	PyCodeObject *co;
	PyObject *m;

	mtime = PyOS_GetLastModificationTime(pathname, fp);
	if (mtime == (time_t)(-1))
		return NULL;
#if SIZEOF_TIME_T &gt; 4
	/* Python's .pyc timestamp handling presumes that the timestamp fits
	   in 4 bytes. This will be fine until sometime in the year 2038,
	   when a 4-byte signed time_t will overflow.
	 */
	if (mtime &gt;&gt; 32) {
		PyErr_SetString(PyExc_OverflowError,
			"modification time overflows a 4 byte field");
		return NULL;
	}
#endif
	cpathname = make_compiled_pathname(pathname, buf,
					   (size_t)MAXPATHLEN + 1);
	if (cpathname != NULL &amp;&amp;
	    (fpc = check_compiled_module(pathname, mtime, cpathname))) {
		co = read_compiled_module(cpathname, fpc);
		fclose(fpc);
		if (co == NULL)
			return NULL;
		if (Py_VerboseFlag)
			PySys_WriteStderr("import %s # precompiled from %s\n",
				name, cpathname);
		pathname = cpathname;
	}
	else {
		co = parse_source_module(pathname, fp);
		if (co == NULL)
			return NULL;
		if (Py_VerboseFlag)
			PySys_WriteStderr("import %s # from %s\n",
				name, pathname);
		write_compiled_module(co, cpathname, mtime);
	}
	m = PyImport_ExecCodeModuleEx(name, (PyObject *)co, pathname);
	Py_DECREF(co);

	return m;
}
</t>
<t tx="ekr.20040711113027.28">@ Forward
@c

static PyObject *load_module(char *, FILE *, char *, int, PyObject *);
static struct filedescr *find_module(char *, char *, PyObject *,
				     char *, size_t, FILE **, PyObject **);
static struct _frozen *find_frozen(char *name);

/* Load a package and return its module object WITH INCREMENTED
   REFERENCE COUNT */

static PyObject *
load_package(char *name, char *pathname)
{
	PyObject *m, *d, *file, *path;
	int err;
	char buf[MAXPATHLEN+1];
	FILE *fp = NULL;
	struct filedescr *fdp;

	m = PyImport_AddModule(name);
	if (m == NULL)
		return NULL;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # directory %s\n",
			name, pathname);
	d = PyModule_GetDict(m);
	file = PyString_FromString(pathname);
	if (file == NULL)
		return NULL;
	path = Py_BuildValue("[O]", file);
	if (path == NULL) {
		Py_DECREF(file);
		return NULL;
	}
	err = PyDict_SetItemString(d, "__file__", file);
	if (err == 0)
		err = PyDict_SetItemString(d, "__path__", path);
	if (err != 0) {
		m = NULL;
		goto cleanup;
	}
	buf[0] = '\0';
	fdp = find_module(name, "__init__", path, buf, sizeof(buf), &amp;fp, NULL);
	if (fdp == NULL) {
		if (PyErr_ExceptionMatches(PyExc_ImportError)) {
			PyErr_Clear();
			Py_INCREF(m);
		}
		else
			m = NULL;
		goto cleanup;
	}
	m = load_module(name, fp, buf, fdp-&gt;type, NULL);
	if (fp != NULL)
		fclose(fp);
  cleanup:
	Py_XDECREF(path);
	Py_XDECREF(file);
	return m;
}
</t>
<t tx="ekr.20040711113027.29">@ Helper to test for built-in module
@c

static int
is_builtin(char *name)
{
	int i;
	for (i = 0; PyImport_Inittab[i].name != NULL; i++) {
		if (strcmp(name, PyImport_Inittab[i].name) == 0) {
			if (PyImport_Inittab[i].initfunc == NULL)
				return -1;
			else
				return 1;
		}
	}
	return 0;
}
</t>
<t tx="ekr.20040711113027.30">@ Return an importer object for a sys.path/pkg.__path__ item 'p',  possibly by fetching it from the path_importer_cache dict. If it  wasn't yet cached, traverse path_hooks until it a hook is found  that can handle the path item. Return None if no hook could;  this tells our caller it should fall back to the builtin  import mechanism. Cache the result in path_importer_cache.  Returns a borrowed reference.
@c

static PyObject *
get_path_importer(PyObject *path_importer_cache, PyObject *path_hooks,
		  PyObject *p)
{
	PyObject *importer;
	int j, nhooks;

	/* These conditions are the caller's responsibility: */
	assert(PyList_Check(path_hooks));
	assert(PyDict_Check(path_importer_cache));

	nhooks = PyList_Size(path_hooks);
	if (nhooks &lt; 0)
		return NULL; /* Shouldn't happen */

	importer = PyDict_GetItem(path_importer_cache, p);
	if (importer != NULL)
		return importer;

	/* set path_importer_cache[p] to None to avoid recursion */
	if (PyDict_SetItem(path_importer_cache, p, Py_None) != 0)
		return NULL;

	for (j = 0; j &lt; nhooks; j++) {
		PyObject *hook = PyList_GetItem(path_hooks, j);
		if (hook == NULL)
			return NULL;
		importer = PyObject_CallFunction(hook, "O", p);
		if (importer != NULL)
			break;

		if (!PyErr_ExceptionMatches(PyExc_ImportError)) {
			return NULL;
		}
		PyErr_Clear();
	}
	if (importer == NULL)
		importer = Py_None;
	else if (importer != Py_None) {
		int err = PyDict_SetItem(path_importer_cache, p, importer);
		Py_DECREF(importer);
		if (err != 0)
			return NULL;
	}
	return importer;
}
</t>
<t tx="ekr.20040711113027.31">@ Search the path (default sys.path) for a module. Return the  corresponding filedescr struct, and (via return arguments) the  pathname and an open file. Return NULL if the module is not found.
@c

#ifdef MS_COREDLL
extern FILE *PyWin_FindRegisteredModule(const char *, struct filedescr **,
					char *, int);
#endif

static int case_ok(char *, int, int, char *);
static int find_init_module(char *); /* Forward */
static struct filedescr importhookdescr = {"", "", IMP_HOOK};

static struct filedescr *
find_module(char *fullname, char *subname, PyObject *path, char *buf,
	    size_t buflen, FILE **p_fp, PyObject **p_loader)
{
	int i, npath;
	size_t len, namelen;
	struct filedescr *fdp = NULL;
	char *filemode;
	FILE *fp = NULL;
	PyObject *path_hooks, *path_importer_cache;
#ifndef RISCOS
	struct stat statbuf;
#endif
	static struct filedescr fd_frozen = {"", "", PY_FROZEN};
	static struct filedescr fd_builtin = {"", "", C_BUILTIN};
	static struct filedescr fd_package = {"", "", PKG_DIRECTORY};
	char name[MAXPATHLEN+1];
#if defined(PYOS_OS2)
	size_t saved_len;
	size_t saved_namelen;
	char *saved_buf = NULL;
#endif
	if (p_loader != NULL)
		*p_loader = NULL;

	if (strlen(subname) &gt; MAXPATHLEN) {
		PyErr_SetString(PyExc_OverflowError,
				"module name is too long");
		return NULL;
	}
	strcpy(name, subname);

	/* sys.meta_path import hook */
	if (p_loader != NULL) {
		PyObject *meta_path;

		meta_path = PySys_GetObject("meta_path");
		if (meta_path == NULL || !PyList_Check(meta_path)) {
			PyErr_SetString(PyExc_ImportError,
					"sys.meta_path must be a list of "
					"import hooks");
			return NULL;
		}
		Py_INCREF(meta_path);  /* zap guard */
		npath = PyList_Size(meta_path);
		for (i = 0; i &lt; npath; i++) {
			PyObject *loader;
			PyObject *hook = PyList_GetItem(meta_path, i);
			loader = PyObject_CallMethod(hook, "find_module",
						     "sO", fullname,
						     path != NULL ?
						     path : Py_None);
			if (loader == NULL) {
				Py_DECREF(meta_path);
				return NULL;  /* true error */
			}
			if (loader != Py_None) {
				/* a loader was found */
				*p_loader = loader;
				Py_DECREF(meta_path);
				return &amp;importhookdescr;
			}
			Py_DECREF(loader);
		}
		Py_DECREF(meta_path);
	}

	if (path != NULL &amp;&amp; PyString_Check(path)) {
		/* The only type of submodule allowed inside a "frozen"
		   package are other frozen modules or packages. */
		if (PyString_Size(path) + 1 + strlen(name) &gt;= (size_t)buflen) {
			PyErr_SetString(PyExc_ImportError,
					"full frozen module name too long");
			return NULL;
		}
		strcpy(buf, PyString_AsString(path));
		strcat(buf, ".");
		strcat(buf, name);
		strcpy(name, buf);
		if (find_frozen(name) != NULL) {
			strcpy(buf, name);
			return &amp;fd_frozen;
		}
		PyErr_Format(PyExc_ImportError,
			     "No frozen submodule named %.200s", name);
		return NULL;
	}
	if (path == NULL) {
		if (is_builtin(name)) {
			strcpy(buf, name);
			return &amp;fd_builtin;
		}
		if ((find_frozen(name)) != NULL) {
			strcpy(buf, name);
			return &amp;fd_frozen;
		}

#ifdef MS_COREDLL
		fp = PyWin_FindRegisteredModule(name, &amp;fdp, buf, buflen);
		if (fp != NULL) {
			*p_fp = fp;
			return fdp;
		}
#endif
		path = PySys_GetObject("path");
	}
	if (path == NULL || !PyList_Check(path)) {
		PyErr_SetString(PyExc_ImportError,
				"sys.path must be a list of directory names");
		return NULL;
	}

	path_hooks = PySys_GetObject("path_hooks");
	if (path_hooks == NULL || !PyList_Check(path_hooks)) {
		PyErr_SetString(PyExc_ImportError,
				"sys.path_hooks must be a list of "
				"import hooks");
		return NULL;
	}
	path_importer_cache = PySys_GetObject("path_importer_cache");
	if (path_importer_cache == NULL ||
	    !PyDict_Check(path_importer_cache)) {
		PyErr_SetString(PyExc_ImportError,
				"sys.path_importer_cache must be a dict");
		return NULL;
	}

	npath = PyList_Size(path);
	namelen = strlen(name);
	for (i = 0; i &lt; npath; i++) {
		PyObject *copy = NULL;
		PyObject *v = PyList_GetItem(path, i);
#ifdef Py_USING_UNICODE
		if (PyUnicode_Check(v)) {
			copy = PyUnicode_Encode(PyUnicode_AS_UNICODE(v),
				PyUnicode_GET_SIZE(v), Py_FileSystemDefaultEncoding, NULL);
			if (copy == NULL)
				return NULL;
			v = copy;
		}
		else
#endif
		if (!PyString_Check(v))
			continue;
		len = PyString_Size(v);
		if (len + 2 + namelen + MAXSUFFIXSIZE &gt;= buflen) {
			Py_XDECREF(copy);
			continue; /* Too long */
		}
		strcpy(buf, PyString_AsString(v));
		if (strlen(buf) != len) {
			Py_XDECREF(copy);
			continue; /* v contains '\0' */
		}

		/* sys.path_hooks import hook */
		if (p_loader != NULL) {
			PyObject *importer;

			importer = get_path_importer(path_importer_cache,
						     path_hooks, v);
			if (importer == NULL)
				return NULL;
			/* Note: importer is a borrowed reference */
			if (importer != Py_None) {
				PyObject *loader;
				loader = PyObject_CallMethod(importer,
							     "find_module",
							     "s", fullname);
				if (loader == NULL)
					return NULL;  /* error */
				if (loader != Py_None) {
					/* a loader was found */
					*p_loader = loader;
					return &amp;importhookdescr;
				}
				Py_DECREF(loader);
			}
			/* no hook was successful, use builtin import */
		}

		if (len &gt; 0 &amp;&amp; buf[len-1] != SEP
#ifdef ALTSEP
		    &amp;&amp; buf[len-1] != ALTSEP
#endif
		    )
			buf[len++] = SEP;
		strcpy(buf+len, name);
		len += namelen;

		/* Check for package import (buf holds a directory name,
		   and there's an __init__ module in that directory */
#ifdef HAVE_STAT
		if (stat(buf, &amp;statbuf) == 0 &amp;&amp;         /* it exists */
		    S_ISDIR(statbuf.st_mode) &amp;&amp;         /* it's a directory */
		    find_init_module(buf) &amp;&amp;            /* it has __init__.py */
		    case_ok(buf, len, namelen, name)) { /* and case matches */
			Py_XDECREF(copy);
			return &amp;fd_package;
		}
#else
		/* XXX How are you going to test for directories? */
#ifdef RISCOS
		if (isdir(buf) &amp;&amp;
		    find_init_module(buf) &amp;&amp;
		    case_ok(buf, len, namelen, name)) {
			Py_XDECREF(copy);
			return &amp;fd_package;
		}
#endif
#endif
#if defined(PYOS_OS2)
		/* take a snapshot of the module spec for restoration
		 * after the 8 character DLL hackery
		 */
		saved_buf = strdup(buf);
		saved_len = len;
		saved_namelen = namelen;
#endif /* PYOS_OS2 */
		for (fdp = _PyImport_Filetab; fdp-&gt;suffix != NULL; fdp++) {
#if defined(PYOS_OS2)
			/* OS/2 limits DLLs to 8 character names (w/o
			   extension)
			 * so if the name is longer than that and its a
			 * dynamically loaded module we're going to try,
			 * truncate the name before trying
			 */
			if (strlen(subname) &gt; 8) {
				/* is this an attempt to load a C extension? */
				const struct filedescr *scan;
				scan = _PyImport_DynLoadFiletab;
				while (scan-&gt;suffix != NULL) {
					if (!strcmp(scan-&gt;suffix, fdp-&gt;suffix))
						break;
					else
						scan++;
				}
				if (scan-&gt;suffix != NULL) {
					/* yes, so truncate the name */
					namelen = 8;
					len -= strlen(subname) - namelen;
					buf[len] = '\0';
				}
			}
#endif /* PYOS_OS2 */
			strcpy(buf+len, fdp-&gt;suffix);
			if (Py_VerboseFlag &gt; 1)
				PySys_WriteStderr("# trying %s\n", buf);
			filemode = fdp-&gt;mode;
			if (filemode[0] == 'U') 
				filemode = "r" PY_STDIOTEXTMODE;
			fp = fopen(buf, filemode);
			if (fp != NULL) {
				if (case_ok(buf, len, namelen, name))
					break;
				else {	 /* continue search */
					fclose(fp);
					fp = NULL;
				}
			}
#if defined(PYOS_OS2)
			/* restore the saved snapshot */
			strcpy(buf, saved_buf);
			len = saved_len;
			namelen = saved_namelen;
#endif
		}
#if defined(PYOS_OS2)
		/* don't need/want the module name snapshot anymore */
		if (saved_buf)
		{
			free(saved_buf);
			saved_buf = NULL;
		}
#endif
		Py_XDECREF(copy);
		if (fp != NULL)
			break;
	}
	if (fp == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "No module named %.200s", name);
		return NULL;
	}
	*p_fp = fp;
	return fdp;
}
</t>
<t tx="ekr.20040711113027.32">@ case_ok(char* buf, int len, int namelen, char* name) * The arguments here are tricky, best shown by example: *  /a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0 *  ^           ^          ^  ^ *  |--------------------- buf ---------------------| *  |------------------- len ------------------| *              |------ name -------| *              |----- namelen -----| * buf is the full path, but len only counts up to (&amp; exclusive of) the * extension. name is the module name, also exclusive of extension. * * We've already done a successful stat() or fopen() on buf, so know that * there's some match, possibly case-insensitive. * * case_ok() is to return 1 if there's a case-sensitive match for * name, else 0. case_ok() is also to return 1 if envar PYTHONCASEOK * exists. * * case_ok() is used to implement case-sensitive import semantics even * on platforms with case-insensitive filesystems. It's trivial to implement * for case-sensitive filesystems. It's pretty much a cross-platform * nightmare for systems with case-insensitive filesystems.
First we may need a pile of platform-specific header files; the sequence * of #if's here should match the sequence in the body of case_ok().
@c

#if defined(MS_WINDOWS) || defined(__CYGWIN__)
#include &lt;windows.h&gt;
#ifdef __CYGWIN__
#include &lt;sys/cygwin.h&gt;
#endif

#elif defined(DJGPP)
#include &lt;dir.h&gt;

#elif defined(__MACH__) &amp;&amp; defined(__APPLE__) &amp;&amp; defined(HAVE_DIRENT_H)
#include &lt;sys/types.h&gt;
#include &lt;dirent.h&gt;

#elif defined(PYOS_OS2)
#define INCL_DOS
#define INCL_DOSERRORS
#define INCL_NOPMAPI
#include &lt;os2.h&gt;

#elif defined(RISCOS)
#include "oslib/osfscontrol.h"
#endif

static int
case_ok(char *buf, int len, int namelen, char *name)
{
/* Pick a platform-specific implementation; the sequence of #if's here should
 * match the sequence just above.
 */

/* MS_WINDOWS || __CYGWIN__ */
#if defined(MS_WINDOWS) || defined(__CYGWIN__)
	WIN32_FIND_DATA data;
	HANDLE h;
#ifdef __CYGWIN__
	char tempbuf[MAX_PATH];
#endif

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

#ifdef __CYGWIN__
	cygwin32_conv_to_win32_path(buf, tempbuf);
	h = FindFirstFile(tempbuf, &amp;data);
#else
	h = FindFirstFile(buf, &amp;data);
#endif
	if (h == INVALID_HANDLE_VALUE) {
		PyErr_Format(PyExc_NameError,
		  "Can't find file for module %.100s\n(filename %.300s)",
		  name, buf);
		return 0;
	}
	FindClose(h);
	return strncmp(data.cFileName, name, namelen) == 0;

/* DJGPP */
#elif defined(DJGPP)
	struct ffblk ffblk;
	int done;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	done = findfirst(buf, &amp;ffblk, FA_ARCH|FA_RDONLY|FA_HIDDEN|FA_DIREC);
	if (done) {
		PyErr_Format(PyExc_NameError,
		  "Can't find file for module %.100s\n(filename %.300s)",
		  name, buf);
		return 0;
	}
	return strncmp(ffblk.ff_name, name, namelen) == 0;

/* new-fangled macintosh (macosx) */
#elif defined(__MACH__) &amp;&amp; defined(__APPLE__) &amp;&amp; defined(HAVE_DIRENT_H)
	DIR *dirp;
	struct dirent *dp;
	char dirname[MAXPATHLEN + 1];
	const int dirlen = len - namelen - 1; /* don't want trailing SEP */

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	/* Copy the dir component into dirname; substitute "." if empty */
	if (dirlen &lt;= 0) {
		dirname[0] = '.';
		dirname[1] = '\0';
	}
	else {
		assert(dirlen &lt;= MAXPATHLEN);
		memcpy(dirname, buf, dirlen);
		dirname[dirlen] = '\0';
	}
	/* Open the directory and search the entries for an exact match. */
	dirp = opendir(dirname);
	if (dirp) {
		char *nameWithExt = buf + len - namelen;
		while ((dp = readdir(dirp)) != NULL) {
			const int thislen =
#ifdef _DIRENT_HAVE_D_NAMELEN
						dp-&gt;d_namlen;
#else
						strlen(dp-&gt;d_name);
#endif
			if (thislen &gt;= namelen &amp;&amp;
			    strcmp(dp-&gt;d_name, nameWithExt) == 0) {
				(void)closedir(dirp);
				return 1; /* Found */
			}
		}
		(void)closedir(dirp);
	}
	return 0 ; /* Not found */

/* RISC OS */
#elif defined(RISCOS)
	char canon[MAXPATHLEN+1]; /* buffer for the canonical form of the path */
	char buf2[MAXPATHLEN+2];
	char *nameWithExt = buf+len-namelen;
	int canonlen;
	os_error *e;

	if (Py_GETENV("PYTHONCASEOK") != NULL)
		return 1;

	/* workaround:
	   append wildcard, otherwise case of filename wouldn't be touched */
	strcpy(buf2, buf);
	strcat(buf2, "*");

	e = xosfscontrol_canonicalise_path(buf2,canon,0,0,MAXPATHLEN+1,&amp;canonlen);
	canonlen = MAXPATHLEN+1-canonlen;
	if (e || canonlen&lt;=0 || canonlen&gt;(MAXPATHLEN+1) )
		return 0;
	if (strcmp(nameWithExt, canon+canonlen-strlen(nameWithExt))==0)
		return 1; /* match */

	return 0;

/* OS/2 */
#elif defined(PYOS_OS2)
	HDIR hdir = 1;
	ULONG srchcnt = 1;
	FILEFINDBUF3 ffbuf;
	APIRET rc;

	if (getenv("PYTHONCASEOK") != NULL)
		return 1;

	rc = DosFindFirst(buf,
			  &amp;hdir,
			  FILE_READONLY | FILE_HIDDEN | FILE_SYSTEM | FILE_DIRECTORY,
			  &amp;ffbuf, sizeof(ffbuf),
			  &amp;srchcnt,
			  FIL_STANDARD);
	if (rc != NO_ERROR)
		return 0;
	return strncmp(ffbuf.achName, name, namelen) == 0;

/* assuming it's a case-sensitive filesystem, so there's nothing to do! */
#else
	return 1;

#endif
}
</t>
<t tx="ekr.20040711113027.33">#ifdef HAVE_STAT
/* Helper to look for __init__.py or __init__.py[co] in potential package */
static int
find_init_module(char *buf)
{
	const size_t save_len = strlen(buf);
	size_t i = save_len;
	char *pname;  /* pointer to start of __init__ */
	struct stat statbuf;

/*	For calling case_ok(buf, len, namelen, name):
 *	/a/b/c/d/e/f/g/h/i/j/k/some_long_module_name.py\0
 *	^                      ^                   ^    ^
 *	|--------------------- buf ---------------------|
 *	|------------------- len ------------------|
 *	                       |------ name -------|
 *	                       |----- namelen -----|
 */
	if (save_len + 13 &gt;= MAXPATHLEN)
		return 0;
	buf[i++] = SEP;
	pname = buf + i;
	strcpy(pname, "__init__.py");
	if (stat(buf, &amp;statbuf) == 0) {
		if (case_ok(buf,
			    save_len + 9,	/* len("/__init__") */
		            8,   		/* len("__init__") */
		            pname)) {
			buf[save_len] = '\0';
			return 1;
		}
	}
	i += strlen(pname);
	strcpy(buf+i, Py_OptimizeFlag ? "o" : "c");
	if (stat(buf, &amp;statbuf) == 0) {
		if (case_ok(buf,
			    save_len + 9,	/* len("/__init__") */
		            8,   		/* len("__init__") */
		            pname)) {
			buf[save_len] = '\0';
			return 1;
		}
	}
	buf[save_len] = '\0';
	return 0;
}

#else

#ifdef RISCOS
static int
find_init_module(buf)
	char *buf;
{
	int save_len = strlen(buf);
	int i = save_len;

	if (save_len + 13 &gt;= MAXPATHLEN)
		return 0;
	buf[i++] = SEP;
	strcpy(buf+i, "__init__/py");
	if (isfile(buf)) {
		buf[save_len] = '\0';
		return 1;
	}

	if (Py_OptimizeFlag)
		strcpy(buf+i, "o");
	else
		strcpy(buf+i, "c");
	if (isfile(buf)) {
		buf[save_len] = '\0';
		return 1;
	}
	buf[save_len] = '\0';
	return 0;
}

#endif /*RISCOS*/

#endif /* HAVE_STAT */
</t>
<t tx="ekr.20040711113027.35">static int init_builtin(char *); /* Forward */

/* Load an external module using the default search path and return
   its module object WITH INCREMENTED REFERENCE COUNT */

static PyObject *
load_module(char *name, FILE *fp, char *buf, int type, PyObject *loader)
{
	PyObject *modules;
	PyObject *m;
	int err;

	/* First check that there's an open file (if we need one)  */
	switch (type) {
	case PY_SOURCE:
	case PY_COMPILED:
		if (fp == NULL) {
			PyErr_Format(PyExc_ValueError,
			   "file object required for import (type code %d)",
				     type);
			return NULL;
		}
	}

	switch (type) {

	case PY_SOURCE:
		m = load_source_module(name, buf, fp);
		break;

	case PY_COMPILED:
		m = load_compiled_module(name, buf, fp);
		break;

#ifdef HAVE_DYNAMIC_LOADING
	case C_EXTENSION:
		m = _PyImport_LoadDynamicModule(name, buf, fp);
		break;
#endif

	case PKG_DIRECTORY:
		m = load_package(name, buf);
		break;

	case C_BUILTIN:
	case PY_FROZEN:
		if (buf != NULL &amp;&amp; buf[0] != '\0')
			name = buf;
		if (type == C_BUILTIN)
			err = init_builtin(name);
		else
			err = PyImport_ImportFrozenModule(name);
		if (err &lt; 0)
			return NULL;
		if (err == 0) {
			PyErr_Format(PyExc_ImportError,
				     "Purported %s module %.200s not found",
				     type == C_BUILTIN ?
						"builtin" : "frozen",
				     name);
			return NULL;
		}
		modules = PyImport_GetModuleDict();
		m = PyDict_GetItemString(modules, name);
		if (m == NULL) {
			PyErr_Format(
				PyExc_ImportError,
				"%s module %.200s not properly initialized",
				type == C_BUILTIN ?
					"builtin" : "frozen",
				name);
			return NULL;
		}
		Py_INCREF(m);
		break;

	case IMP_HOOK: {
		if (loader == NULL) {
			PyErr_SetString(PyExc_ImportError,
					"import hook without loader");
			return NULL;
		}
		m = PyObject_CallMethod(loader, "load_module", "s", name);
		break;
	}

	default:
		PyErr_Format(PyExc_ImportError,
			     "Don't know how to import %.200s (type code %d)",
			      name, type);
		m = NULL;

	}

	return m;
}
</t>
<t tx="ekr.20040711113027.36">@ Initialize a built-in module.  Return 1 for succes, 0 if the module is not found, and -1 with  an exception set if the initialization failed.
@c

static int
init_builtin(char *name)
{
	struct _inittab *p;

	if (_PyImport_FindExtension(name, name) != NULL)
		return 1;

	for (p = PyImport_Inittab; p-&gt;name != NULL; p++) {
		if (strcmp(name, p-&gt;name) == 0) {
			if (p-&gt;initfunc == NULL) {
				PyErr_Format(PyExc_ImportError,
				    "Cannot re-init internal module %.200s",
				    name);
				return -1;
			}
			if (Py_VerboseFlag)
				PySys_WriteStderr("import %s # builtin\n", name);
			(*p-&gt;initfunc)();
			if (PyErr_Occurred())
				return -1;
			if (_PyImport_FixupExtension(name, name) == NULL)
				return -1;
			return 1;
		}
	}
	return 0;
}
</t>
<t tx="ekr.20040711113027.37">@ Frozen modules
@c

static struct _frozen *
find_frozen(char *name)
{
	struct _frozen *p;

	for (p = PyImport_FrozenModules; ; p++) {
		if (p-&gt;name == NULL)
			return NULL;
		if (strcmp(p-&gt;name, name) == 0)
			break;
	}
	return p;
}
</t>
<t tx="ekr.20040711113027.38">
static PyObject *
get_frozen_object(char *name)
{
	struct _frozen *p = find_frozen(name);
	int size;

	if (p == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "No such frozen object named %.200s",
			     name);
		return NULL;
	}
	if (p-&gt;code == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Excluded frozen object named %.200s",
			     name);
		return NULL;
	}
	size = p-&gt;size;
	if (size &lt; 0)
		size = -size;
	return PyMarshal_ReadObjectFromString((char *)p-&gt;code, size);
}
</t>
<t tx="ekr.20040711113027.39">@ Initialize a frozen module.  Return 1 for succes, 0 if the module is not found, and -1 with  an exception set if the initialization failed.  This function is also used from frozenmain.c
@c

int
PyImport_ImportFrozenModule(char *name)
{
	struct _frozen *p = find_frozen(name);
	PyObject *co;
	PyObject *m;
	int ispackage;
	int size;

	if (p == NULL)
		return 0;
	if (p-&gt;code == NULL) {
		PyErr_Format(PyExc_ImportError,
			     "Excluded frozen object named %.200s",
			     name);
		return -1;
	}
	size = p-&gt;size;
	ispackage = (size &lt; 0);
	if (ispackage)
		size = -size;
	if (Py_VerboseFlag)
		PySys_WriteStderr("import %s # frozen%s\n",
			name, ispackage ? " package" : "");
	co = PyMarshal_ReadObjectFromString((char *)p-&gt;code, size);
	if (co == NULL)
		return -1;
	if (!PyCode_Check(co)) {
		Py_DECREF(co);
		PyErr_Format(PyExc_TypeError,
			     "frozen object %.200s is not a code object",
			     name);
		return -1;
	}
	if (ispackage) {
		/* Set __path__ to the package name */
		PyObject *d, *s;
		int err;
		m = PyImport_AddModule(name);
		if (m == NULL)
			return -1;
		d = PyModule_GetDict(m);
		s = PyString_InternFromString(name);
		if (s == NULL)
			return -1;
		err = PyDict_SetItemString(d, "__path__", s);
		Py_DECREF(s);
		if (err != 0)
			return err;
	}
	m = PyImport_ExecCodeModuleEx(name, co, "&lt;frozen&gt;");
	Py_DECREF(co);
	if (m == NULL)
		return -1;
	Py_DECREF(m);
	return 1;
}
</t>
<t tx="ekr.20040711113027.40">@ Import a module, either built-in, frozen, or external, and return  its module object WITH INCREMENTED REFERENCE COUNT
@c

PyObject *
PyImport_ImportModule(char *name)
{
	PyObject *pname;
	PyObject *result;

	pname = PyString_FromString(name);
	if (pname == NULL)
		return NULL;
	result = PyImport_Import(pname);
	Py_DECREF(pname);
	return result;
}
</t>
<t tx="ekr.20040711113027.41">@ Forward declarations for helper routines
@c

static PyObject *get_parent(PyObject *globals, char *buf, int *p_buflen);
static PyObject *load_next(PyObject *mod, PyObject *altmod,
			   char **p_name, char *buf, int *p_buflen);
static int mark_miss(char *name);
static int ensure_fromlist(PyObject *mod, PyObject *fromlist,
			   char *buf, int buflen, int recursive);
static PyObject * import_submodule(PyObject *mod, char *name, char *fullname);

/* The Magnum Opus of dotted-name import :-) */

static PyObject *
import_module_ex(char *name, PyObject *globals, PyObject *locals,
		 PyObject *fromlist)
{
	char buf[MAXPATHLEN+1];
	int buflen = 0;
	PyObject *parent, *head, *next, *tail;

	parent = get_parent(globals, buf, &amp;buflen);
	if (parent == NULL)
		return NULL;

	head = load_next(parent, Py_None, &amp;name, buf, &amp;buflen);
	if (head == NULL)
		return NULL;

	tail = head;
	Py_INCREF(tail);
	while (name) {
		next = load_next(tail, tail, &amp;name, buf, &amp;buflen);
		Py_DECREF(tail);
		if (next == NULL) {
			Py_DECREF(head);
			return NULL;
		}
		tail = next;
	}

	if (fromlist != NULL) {
		if (fromlist == Py_None || !PyObject_IsTrue(fromlist))
			fromlist = NULL;
	}

	if (fromlist == NULL) {
		Py_DECREF(tail);
		return head;
	}

	Py_DECREF(head);
	if (!ensure_fromlist(tail, fromlist, buf, buflen, 0)) {
		Py_DECREF(tail);
		return NULL;
	}

	return tail;
}
</t>
<t tx="ekr.20040711113027.42">
PyObject *
PyImport_ImportModuleEx(char *name, PyObject *globals, PyObject *locals,
			PyObject *fromlist)
{
	PyObject *result;
	lock_import();
	result = import_module_ex(name, globals, locals, fromlist);
	if (unlock_import() &lt; 0) {
		Py_XDECREF(result);
		PyErr_SetString(PyExc_RuntimeError,
				"not holding the import lock");
		return NULL;
	}
	return result;
}
</t>
<t tx="ekr.20040711113027.43">@ Return the package that an import is being performed in. If globals comes  from the module foo.bar.bat (not itself a package), this returns the  sys.modules entry for foo.bar. If globals is from a package's __init__.py,  the package's entry in sys.modules is returned.   The *name* of the returned package is returned in buf, with the length of  the name in *p_buflen.   If globals doesn't come from a package or a module in a package, or a  corresponding entry is not found in sys.modules, Py_None is returned.
@c

static PyObject *
get_parent(PyObject *globals, char *buf, int *p_buflen)
{
	static PyObject *namestr = NULL;
	static PyObject *pathstr = NULL;
	PyObject *modname, *modpath, *modules, *parent;

	if (globals == NULL || !PyDict_Check(globals))
		return Py_None;

	if (namestr == NULL) {
		namestr = PyString_InternFromString("__name__");
		if (namestr == NULL)
			return NULL;
	}
	if (pathstr == NULL) {
		pathstr = PyString_InternFromString("__path__");
		if (pathstr == NULL)
			return NULL;
	}

	*buf = '\0';
	*p_buflen = 0;
	modname = PyDict_GetItem(globals, namestr);
	if (modname == NULL || !PyString_Check(modname))
		return Py_None;

	modpath = PyDict_GetItem(globals, pathstr);
	if (modpath != NULL) {
		int len = PyString_GET_SIZE(modname);
		if (len &gt; MAXPATHLEN) {
			PyErr_SetString(PyExc_ValueError,
					"Module name too long");
			return NULL;
		}
		strcpy(buf, PyString_AS_STRING(modname));
		*p_buflen = len;
	}
	else {
		char *start = PyString_AS_STRING(modname);
		char *lastdot = strrchr(start, '.');
		size_t len;
		if (lastdot == NULL)
			return Py_None;
		len = lastdot - start;
		if (len &gt;= MAXPATHLEN) {
			PyErr_SetString(PyExc_ValueError,
					"Module name too long");
			return NULL;
		}
		strncpy(buf, start, len);
		buf[len] = '\0';
		*p_buflen = len;
	}

	modules = PyImport_GetModuleDict();
	parent = PyDict_GetItemString(modules, buf);
	if (parent == NULL)
		parent = Py_None;
	return parent;
	/* We expect, but can't guarantee, if parent != None, that:
	   - parent.__name__ == buf
	   - parent.__dict__ is globals
	   If this is violated...  Who cares? */
}
</t>
<t tx="ekr.20040711113027.44">@ altmod is either None or same as mod
@c

static PyObject *
load_next(PyObject *mod, PyObject *altmod, char **p_name, char *buf,
	  int *p_buflen)
{
	char *name = *p_name;
	char *dot = strchr(name, '.');
	size_t len;
	char *p;
	PyObject *result;

	if (dot == NULL) {
		*p_name = NULL;
		len = strlen(name);
	}
	else {
		*p_name = dot+1;
		len = dot-name;
	}
	if (len == 0) {
		PyErr_SetString(PyExc_ValueError,
				"Empty module name");
		return NULL;
	}

	p = buf + *p_buflen;
	if (p != buf)
		*p++ = '.';
	if (p+len-buf &gt;= MAXPATHLEN) {
		PyErr_SetString(PyExc_ValueError,
				"Module name too long");
		return NULL;
	}
	strncpy(p, name, len);
	p[len] = '\0';
	*p_buflen = p+len-buf;

	result = import_submodule(mod, p, buf);
	if (result == Py_None &amp;&amp; altmod != mod) {
		Py_DECREF(result);
		/* Here, altmod must be None and mod must not be None */
		result = import_submodule(altmod, p, p);
		if (result != NULL &amp;&amp; result != Py_None) {
			if (mark_miss(buf) != 0) {
				Py_DECREF(result);
				return NULL;
			}
			strncpy(buf, name, len);
			buf[len] = '\0';
			*p_buflen = len;
		}
	}
	if (result == NULL)
		return NULL;

	if (result == Py_None) {
		Py_DECREF(result);
		PyErr_Format(PyExc_ImportError,
			     "No module named %.200s", name);
		return NULL;
	}

	return result;
}
</t>
<t tx="ekr.20040711113027.45">
static int
mark_miss(char *name)
{
	PyObject *modules = PyImport_GetModuleDict();
	return PyDict_SetItemString(modules, name, Py_None);
}
</t>
<t tx="ekr.20040711113027.46">
static int
ensure_fromlist(PyObject *mod, PyObject *fromlist, char *buf, int buflen,
		int recursive)
{
	int i;

	if (!PyObject_HasAttrString(mod, "__path__"))
		return 1;

	for (i = 0; ; i++) {
		PyObject *item = PySequence_GetItem(fromlist, i);
		int hasit;
		if (item == NULL) {
			if (PyErr_ExceptionMatches(PyExc_IndexError)) {
				PyErr_Clear();
				return 1;
			}
			return 0;
		}
		if (!PyString_Check(item)) {
			PyErr_SetString(PyExc_TypeError,
					"Item in ``from list'' not a string");
			Py_DECREF(item);
			return 0;
		}
		if (PyString_AS_STRING(item)[0] == '*') {
			PyObject *all;
			Py_DECREF(item);
			/* See if the package defines __all__ */
			if (recursive)
				continue; /* Avoid endless recursion */
			all = PyObject_GetAttrString(mod, "__all__");
			if (all == NULL)
				PyErr_Clear();
			else {
				int ret = ensure_fromlist(mod, all, buf, buflen, 1);
				Py_DECREF(all);
				if (!ret)
					return 0;
			}
			continue;
		}
		hasit = PyObject_HasAttr(mod, item);
		if (!hasit) {
			char *subname = PyString_AS_STRING(item);
			PyObject *submod;
			char *p;
			if (buflen + strlen(subname) &gt;= MAXPATHLEN) {
				PyErr_SetString(PyExc_ValueError,
						"Module name too long");
				Py_DECREF(item);
				return 0;
			}
			p = buf + buflen;
			*p++ = '.';
			strcpy(p, subname);
			submod = import_submodule(mod, subname, buf);
			Py_XDECREF(submod);
			if (submod == NULL) {
				Py_DECREF(item);
				return 0;
			}
		}
		Py_DECREF(item);
	}

	/* NOTREACHED */
}
</t>
<t tx="ekr.20040711113027.47">
static int
add_submodule(PyObject *mod, PyObject *submod, char *fullname, char *subname,
	      PyObject *modules)
{
	if (mod == Py_None)
		return 1;
	/* Irrespective of the success of this load, make a
	   reference to it in the parent package module.  A copy gets
	   saved in the modules dictionary under the full name, so get a
	   reference from there, if need be.  (The exception is when the
	   load failed with a SyntaxError -- then there's no trace in
	   sys.modules.  In that case, of course, do nothing extra.) */
	if (submod == NULL) {
		submod = PyDict_GetItemString(modules, fullname);
		if (submod == NULL)
			return 1;
	}
	if (PyModule_Check(mod)) {
		/* We can't use setattr here since it can give a
		 * spurious warning if the submodule name shadows a
		 * builtin name */
		PyObject *dict = PyModule_GetDict(mod);
		if (!dict)
			return 0;
		if (PyDict_SetItemString(dict, subname, submod) &lt; 0)
			return 0;
	}
	else {
		if (PyObject_SetAttrString(mod, subname, submod) &lt; 0)
			return 0;
	}
	return 1;
}
</t>
<t tx="ekr.20040711113027.48">
static PyObject *
import_submodule(PyObject *mod, char *subname, char *fullname)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *m = NULL;

	/* Require:
	   if mod == None: subname == fullname
	   else: mod.__name__ + "." + subname == fullname
	*/

	if ((m = PyDict_GetItemString(modules, fullname)) != NULL) {
		Py_INCREF(m);
	}
	else {
		PyObject *path, *loader = NULL;
		char buf[MAXPATHLEN+1];
		struct filedescr *fdp;
		FILE *fp = NULL;

		if (mod == Py_None)
			path = NULL;
		else {
			path = PyObject_GetAttrString(mod, "__path__");
			if (path == NULL) {
				PyErr_Clear();
				Py_INCREF(Py_None);
				return Py_None;
			}
		}

		buf[0] = '\0';
		fdp = find_module(fullname, subname, path, buf, MAXPATHLEN+1,
				  &amp;fp, &amp;loader);
		Py_XDECREF(path);
		if (fdp == NULL) {
			if (!PyErr_ExceptionMatches(PyExc_ImportError))
				return NULL;
			PyErr_Clear();
			Py_INCREF(Py_None);
			return Py_None;
		}
		m = load_module(fullname, fp, buf, fdp-&gt;type, loader);
		Py_XDECREF(loader);
		if (fp)
			fclose(fp);
		if (!add_submodule(mod, m, fullname, subname, modules)) {
			Py_XDECREF(m);
			m = NULL;
		}
	}

	return m;
}
</t>
<t tx="ekr.20040711113027.49">@ Re-import a module of any kind and return its module object, WITH  INCREMENTED REFERENCE COUNT
@c

PyObject *
PyImport_ReloadModule(PyObject *m)
{
	PyObject *modules = PyImport_GetModuleDict();
	PyObject *path = NULL;
	char *name, *subname;
	char buf[MAXPATHLEN+1];
	struct filedescr *fdp;
	FILE *fp = NULL;

	if (m == NULL || !PyModule_Check(m)) {
		PyErr_SetString(PyExc_TypeError,
				"reload() argument must be module");
		return NULL;
	}
	name = PyModule_GetName(m);
	if (name == NULL)
		return NULL;
	if (m != PyDict_GetItemString(modules, name)) {
		PyErr_Format(PyExc_ImportError,
			     "reload(): module %.200s not in sys.modules",
			     name);
		return NULL;
	}
	subname = strrchr(name, '.');
	if (subname == NULL)
		subname = name;
	else {
		PyObject *parentname, *parent;
		parentname = PyString_FromStringAndSize(name, (subname-name));
		if (parentname == NULL)
			return NULL;
		parent = PyDict_GetItem(modules, parentname);
		Py_DECREF(parentname);
		if (parent == NULL) {
			PyErr_Format(PyExc_ImportError,
			    "reload(): parent %.200s not in sys.modules",
			    name);
			return NULL;
		}
		subname++;
		path = PyObject_GetAttrString(parent, "__path__");
		if (path == NULL)
			PyErr_Clear();
	}
	buf[0] = '\0';
	fdp = find_module(name, subname, path, buf, MAXPATHLEN+1, &amp;fp, NULL);
	Py_XDECREF(path);
	if (fdp == NULL)
		return NULL;
	m = load_module(name, fp, buf, fdp-&gt;type, NULL);
	if (fp)
		fclose(fp);
	return m;
}
</t>
<t tx="ekr.20040711113027.50">@ Higher-level import emulator which emulates the "import" statement  more accurately -- it invokes the __import__() function from the  builtins of the current globals. This means that the import is  done using whatever import hooks are installed in the current  environment, e.g. by "rexec".  A dummy list ["__doc__"] is passed as the 4th argument so that  e.g. PyImport_Import(PyString_FromString("win32com.client.gencache"))  will return &lt;module "gencache"&gt; instead of &lt;module "win32com"&gt;.
@c

PyObject *
PyImport_Import(PyObject *module_name)
{
	static PyObject *silly_list = NULL;
	static PyObject *builtins_str = NULL;
	static PyObject *import_str = NULL;
	PyObject *globals = NULL;
	PyObject *import = NULL;
	PyObject *builtins = NULL;
	PyObject *r = NULL;

	/* Initialize constant string objects */
	if (silly_list == NULL) {
		import_str = PyString_InternFromString("__import__");
		if (import_str == NULL)
			return NULL;
		builtins_str = PyString_InternFromString("__builtins__");
		if (builtins_str == NULL)
			return NULL;
		silly_list = Py_BuildValue("[s]", "__doc__");
		if (silly_list == NULL)
			return NULL;
	}

	/* Get the builtins from current globals */
	globals = PyEval_GetGlobals();
	if (globals != NULL) {
	        Py_INCREF(globals);
		builtins = PyObject_GetItem(globals, builtins_str);
		if (builtins == NULL)
			goto err;
	}
	else {
		/* No globals -- use standard builtins, and fake globals */
		PyErr_Clear();

		builtins = PyImport_ImportModuleEx("__builtin__",
						   NULL, NULL, NULL);
		if (builtins == NULL)
			return NULL;
		globals = Py_BuildValue("{OO}", builtins_str, builtins);
		if (globals == NULL)
			goto err;
	}

	/* Get the __import__ function from the builtins */
	if (PyDict_Check(builtins)) {
		import = PyObject_GetItem(builtins, import_str);
		if (import == NULL)
			PyErr_SetObject(PyExc_KeyError, import_str);
	}
	else
		import = PyObject_GetAttr(builtins, import_str);
	if (import == NULL)
		goto err;

	/* Call the _import__ function with the proper argument list */
	r = PyObject_CallFunction(import, "OOOO",
				  module_name, globals, globals, silly_list);

  err:
	Py_XDECREF(globals);
	Py_XDECREF(builtins);
	Py_XDECREF(import);

	return r;
}
</t>
<t tx="ekr.20040711113027.51">@ Module 'imp' provides Python access to the primitives used for  importing modules.
@c

static PyObject *
imp_get_magic(PyObject *self, PyObject *noargs)
{
	char buf[4];

	buf[0] = (char) ((pyc_magic &gt;&gt;  0) &amp; 0xff);
	buf[1] = (char) ((pyc_magic &gt;&gt;  8) &amp; 0xff);
	buf[2] = (char) ((pyc_magic &gt;&gt; 16) &amp; 0xff);
	buf[3] = (char) ((pyc_magic &gt;&gt; 24) &amp; 0xff);

	return PyString_FromStringAndSize(buf, 4);
}
</t>
<t tx="ekr.20040711113027.52">
static PyObject *
imp_get_suffixes(PyObject *self, PyObject *noargs)
{
	PyObject *list;
	struct filedescr *fdp;

	list = PyList_New(0);
	if (list == NULL)
		return NULL;
	for (fdp = _PyImport_Filetab; fdp-&gt;suffix != NULL; fdp++) {
		PyObject *item = Py_BuildValue("ssi",
				       fdp-&gt;suffix, fdp-&gt;mode, fdp-&gt;type);
		if (item == NULL) {
			Py_DECREF(list);
			return NULL;
		}
		if (PyList_Append(list, item) &lt; 0) {
			Py_DECREF(list);
			Py_DECREF(item);
			return NULL;
		}
		Py_DECREF(item);
	}
	return list;
}
</t>
<t tx="ekr.20040711113027.53">
static PyObject *
call_find_module(char *name, PyObject *path)
{
	extern int fclose(FILE *);
	PyObject *fob, *ret;
	struct filedescr *fdp;
	char pathname[MAXPATHLEN+1];
	FILE *fp = NULL;

	pathname[0] = '\0';
	if (path == Py_None)
		path = NULL;
	fdp = find_module(NULL, name, path, pathname, MAXPATHLEN+1, &amp;fp, NULL);
	if (fdp == NULL)
		return NULL;
	if (fp != NULL) {
		fob = PyFile_FromFile(fp, pathname, fdp-&gt;mode, fclose);
		if (fob == NULL) {
			fclose(fp);
			return NULL;
		}
	}
	else {
		fob = Py_None;
		Py_INCREF(fob);
	}
	ret = Py_BuildValue("Os(ssi)",
		      fob, pathname, fdp-&gt;suffix, fdp-&gt;mode, fdp-&gt;type);
	Py_DECREF(fob);
	return ret;
}
</t>
<t tx="ekr.20040711113027.54">
static PyObject *
imp_find_module(PyObject *self, PyObject *args)
{
	char *name;
	PyObject *path = NULL;
	if (!PyArg_ParseTuple(args, "s|O:find_module", &amp;name, &amp;path))
		return NULL;
	return call_find_module(name, path);
}
</t>
<t tx="ekr.20040711113027.55">
static PyObject *
imp_init_builtin(PyObject *self, PyObject *args)
{
	char *name;
	int ret;
	PyObject *m;
	if (!PyArg_ParseTuple(args, "s:init_builtin", &amp;name))
		return NULL;
	ret = init_builtin(name);
	if (ret &lt; 0)
		return NULL;
	if (ret == 0) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	m = PyImport_AddModule(name);
	Py_XINCREF(m);
	return m;
}
</t>
<t tx="ekr.20040711113027.56">
static PyObject *
imp_init_frozen(PyObject *self, PyObject *args)
{
	char *name;
	int ret;
	PyObject *m;
	if (!PyArg_ParseTuple(args, "s:init_frozen", &amp;name))
		return NULL;
	ret = PyImport_ImportFrozenModule(name);
	if (ret &lt; 0)
		return NULL;
	if (ret == 0) {
		Py_INCREF(Py_None);
		return Py_None;
	}
	m = PyImport_AddModule(name);
	Py_XINCREF(m);
	return m;
}
</t>
<t tx="ekr.20040711113027.57">
static PyObject *
imp_get_frozen_object(PyObject *self, PyObject *args)
{
	char *name;

	if (!PyArg_ParseTuple(args, "s:get_frozen_object", &amp;name))
		return NULL;
	return get_frozen_object(name);
}
</t>
<t tx="ekr.20040711113027.58">
static PyObject *
imp_is_builtin(PyObject *self, PyObject *args)
{
	char *name;
	if (!PyArg_ParseTuple(args, "s:is_builtin", &amp;name))
		return NULL;
	return PyInt_FromLong(is_builtin(name));
}
</t>
<t tx="ekr.20040711113027.59">
static PyObject *
imp_is_frozen(PyObject *self, PyObject *args)
{
	char *name;
	struct _frozen *p;
	if (!PyArg_ParseTuple(args, "s:is_frozen", &amp;name))
		return NULL;
	p = find_frozen(name);
	return PyBool_FromLong((long) (p == NULL ? 0 : p-&gt;size));
}
</t>
<t tx="ekr.20040711113027.60">static FILE *
get_file(char *pathname, PyObject *fob, char *mode)
{
	FILE *fp;
	if (fob == NULL) {
		if (mode[0] == 'U') 
			mode = "r" PY_STDIOTEXTMODE;
		fp = fopen(pathname, mode);
		if (fp == NULL)
			PyErr_SetFromErrno(PyExc_IOError);
	}
	else {
		fp = PyFile_AsFile(fob);
		if (fp == NULL)
			PyErr_SetString(PyExc_ValueError,
					"bad/closed file object");
	}
	return fp;
}
</t>
<t tx="ekr.20040711113027.61">static PyObject *
imp_load_compiled(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp;
	if (!PyArg_ParseTuple(args, "ss|O!:load_compiled", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	fp = get_file(pathname, fob, "rb");
	if (fp == NULL)
		return NULL;
	m = load_compiled_module(name, pathname, fp);
	if (fob == NULL)
		fclose(fp);
	return m;
}
</t>
<t tx="ekr.20040711113027.62">
#ifdef HAVE_DYNAMIC_LOADING

static PyObject *
imp_load_dynamic(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp = NULL;
	if (!PyArg_ParseTuple(args, "ss|O!:load_dynamic", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	if (fob) {
		fp = get_file(pathname, fob, "r");
		if (fp == NULL)
			return NULL;
	}
	m = _PyImport_LoadDynamicModule(name, pathname, fp);
	return m;
}

#endif /* HAVE_DYNAMIC_LOADING */</t>
<t tx="ekr.20040711113027.63">static PyObject *
imp_load_source(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	PyObject *fob = NULL;
	PyObject *m;
	FILE *fp;
	if (!PyArg_ParseTuple(args, "ss|O!:load_source", &amp;name, &amp;pathname,
			      &amp;PyFile_Type, &amp;fob))
		return NULL;
	fp = get_file(pathname, fob, "r");
	if (fp == NULL)
		return NULL;
	m = load_source_module(name, pathname, fp);
	if (fob == NULL)
		fclose(fp);
	return m;
}
</t>
<t tx="ekr.20040711113027.64">static PyObject *
imp_load_module(PyObject *self, PyObject *args)
{
	char *name;
	PyObject *fob;
	char *pathname;
	char *suffix; /* Unused */
	char *mode;
	int type;
	FILE *fp;

	if (!PyArg_ParseTuple(args, "sOs(ssi):load_module",
			      &amp;name, &amp;fob, &amp;pathname,
			      &amp;suffix, &amp;mode, &amp;type))
		return NULL;
	if (*mode) {
		/* Mode must start with 'r' or 'U' and must not contain '+'.
		   Implicit in this test is the assumption that the mode
		   may contain other modifiers like 'b' or 't'. */

		if (!(*mode == 'r' || *mode == 'U') || strchr(mode, '+')) {
			PyErr_Format(PyExc_ValueError,
				     "invalid file open mode %.200s", mode);
			return NULL;
		}
	}
	if (fob == Py_None)
		fp = NULL;
	else {
		if (!PyFile_Check(fob)) {
			PyErr_SetString(PyExc_ValueError,
				"load_module arg#2 should be a file or None");
			return NULL;
		}
		fp = get_file(pathname, fob, mode);
		if (fp == NULL)
			return NULL;
	}
	return load_module(name, fp, pathname, type, NULL);
}</t>
<t tx="ekr.20040711113027.65">
static PyObject *
imp_load_package(PyObject *self, PyObject *args)
{
	char *name;
	char *pathname;
	if (!PyArg_ParseTuple(args, "ss:load_package", &amp;name, &amp;pathname))
		return NULL;
	return load_package(name, pathname);
}
</t>
<t tx="ekr.20040711113027.66">
static PyObject *
imp_new_module(PyObject *self, PyObject *args)
{
	char *name;
	if (!PyArg_ParseTuple(args, "s:new_module", &amp;name))
		return NULL;
	return PyModule_New(name);
}
</t>
<t tx="ekr.20040711113027.67">

static int
setint(PyObject *d, char *name, int value)
{
	PyObject *v;
	int err;

	v = PyInt_FromLong((long)value);
	err = PyDict_SetItemString(d, name, v);
	Py_XDECREF(v);
	return err;
}</t>
<t tx="ekr.20040711113027.68">PyMODINIT_FUNC
initimp(void)
{
	PyObject *m, *d;

	m = Py_InitModule4("imp", imp_methods, doc_imp,
			   NULL, PYTHON_API_VERSION);
	d = PyModule_GetDict(m);

	if (setint(d, "SEARCH_ERROR", SEARCH_ERROR) &lt; 0) goto failure;
	if (setint(d, "PY_SOURCE", PY_SOURCE) &lt; 0) goto failure;
	if (setint(d, "PY_COMPILED", PY_COMPILED) &lt; 0) goto failure;
	if (setint(d, "C_EXTENSION", C_EXTENSION) &lt; 0) goto failure;
	if (setint(d, "PY_RESOURCE", PY_RESOURCE) &lt; 0) goto failure;
	if (setint(d, "PKG_DIRECTORY", PKG_DIRECTORY) &lt; 0) goto failure;
	if (setint(d, "C_BUILTIN", C_BUILTIN) &lt; 0) goto failure;
	if (setint(d, "PY_FROZEN", PY_FROZEN) &lt; 0) goto failure;
	if (setint(d, "PY_CODERESOURCE", PY_CODERESOURCE) &lt; 0) goto failure;
	if (setint(d, "IMP_HOOK", IMP_HOOK) &lt; 0) goto failure;

  failure:
	;
}</t>
<t tx="ekr.20040711113027.69">@ API for embedding applications that want to add their own entries  to the table of built-in modules. This should normally be called  *before* Py_Initialize(). When the table resize fails, -1 is  returned and the existing table is unchanged.   After a similar function by Just van Rossum.
@c

int
PyImport_ExtendInittab(struct _inittab *newtab)
{
	static struct _inittab *our_copy = NULL;
	struct _inittab *p;
	int i, n;

	/* Count the number of entries in both tables */
	for (n = 0; newtab[n].name != NULL; n++)
		;
	if (n == 0)
		return 0; /* Nothing to do */
	for (i = 0; PyImport_Inittab[i].name != NULL; i++)
		;

	/* Allocate new memory for the combined table */
	p = our_copy;
	PyMem_RESIZE(p, struct _inittab, i+n+1);
	if (p == NULL)
		return -1;

	/* Copy the tables into the new memory */
	if (our_copy != PyImport_Inittab)
		memcpy(p, PyImport_Inittab, (i+1) * sizeof(struct _inittab));
	PyImport_Inittab = our_copy = p;
	memcpy(p+i, newtab, (n+1) * sizeof(struct _inittab));

	return 0;
}
</t>
<t tx="ekr.20040711113027.70">@ Shorthand to add a single entry given a name and a function
@c

int
PyImport_AppendInittab(char *name, void (*initfunc)(void))
{
	struct _inittab newtab[2];

	memset(newtab, '\0', sizeof newtab);

	newtab[0].name = name;
	newtab[0].initfunc = initfunc;

	return PyImport_ExtendInittab(newtab);
}
</t>
<t tx="ekr.20040711113356"></t>
<t tx="ekr.20040711113356.1">@ Doc strings
@c

PyDoc_STRVAR(doc_imp,
"This module provides the components needed to build your own\n\
__import__ function.  Undocumented functions are obsolete.");

PyDoc_STRVAR(doc_find_module,
"find_module(name, [path]) -&gt; (file, filename, (suffix, mode, type))\n\
Search for a module.  If path is omitted or None, search for a\n\
built-in, frozen or special module and continue search in sys.path.\n\
The module name cannot contain '.'; to search for a submodule of a\n\
package, pass the submodule name and the package's __path__.");

PyDoc_STRVAR(doc_load_module,
"load_module(name, file, filename, (suffix, mode, type)) -&gt; module\n\
Load a module, given information returned by find_module().\n\
The module name must include the full package name, if any.");

PyDoc_STRVAR(doc_get_magic,
"get_magic() -&gt; string\n\
Return the magic number for .pyc or .pyo files.");

PyDoc_STRVAR(doc_get_suffixes,
"get_suffixes() -&gt; [(suffix, mode, type), ...]\n\
Return a list of (suffix, mode, type) tuples describing the files\n\
that find_module() looks for.");

PyDoc_STRVAR(doc_new_module,
"new_module(name) -&gt; module\n\
Create a new module.  Do not enter it in sys.modules.\n\
The module name must include the full package name, if any.");

PyDoc_STRVAR(doc_lock_held,
"lock_held() -&gt; 0 or 1\n\
Return 1 if the import lock is currently held.\n\
On platforms without threads, return 0.");

PyDoc_STRVAR(doc_acquire_lock,
"acquire_lock() -&gt; None\n\
Acquires the interpreter's import lock for the current thread.\n\
This lock should be used by import hooks to ensure thread-safety\n\
when importing modules.\n\
On platforms without threads, this function does nothing.");

PyDoc_STRVAR(doc_release_lock,
"release_lock() -&gt; None\n\
Release the interpreter's import lock.\n\
On platforms without threads, this function does nothing.");
</t>
<t tx="ekr.20040711113356.2">static PyMethodDef imp_methods[] = {
	{"find_module",	 imp_find_module,  METH_VARARGS, doc_find_module},
	{"get_magic",	 imp_get_magic,	   METH_NOARGS,  doc_get_magic},
	{"get_suffixes", imp_get_suffixes, METH_NOARGS,  doc_get_suffixes},
	{"load_module",	 imp_load_module,  METH_VARARGS, doc_load_module},
	{"new_module",	 imp_new_module,   METH_VARARGS, doc_new_module},
	{"lock_held",	 imp_lock_held,	   METH_NOARGS,  doc_lock_held},
	{"acquire_lock", imp_acquire_lock, METH_NOARGS,  doc_acquire_lock},
	{"release_lock", imp_release_lock, METH_NOARGS,  doc_release_lock},
	/* The rest are obsolete */
	{"get_frozen_object",	imp_get_frozen_object,	METH_VARARGS},
	{"init_builtin",	imp_init_builtin,	METH_VARARGS},
	{"init_frozen",		imp_init_frozen,	METH_VARARGS},
	{"is_builtin",		imp_is_builtin,		METH_VARARGS},
	{"is_frozen",		imp_is_frozen,		METH_VARARGS},
	{"load_compiled",	imp_load_compiled,	METH_VARARGS},
#ifdef HAVE_DYNAMIC_LOADING
	{"load_dynamic",	imp_load_dynamic,	METH_VARARGS},
#endif
	{"load_package",	imp_load_package,	METH_VARARGS},
	{"load_source",		imp_load_source,	METH_VARARGS},
	{NULL,			NULL}		/* sentinel */
};
</t>
<t tx="ekr.20040711113846"></t>
<t tx="ekr.20040711134323">@ignore
@language python

import imp
from test.test_support import TestFailed

@others

if __name__ == "__main__":
    test_main()
</t>
<t tx="ekr.20040711134323.2">def verify_lock_state(expected):
    
    if imp.lock_held() != expected:
        raise TestFailed("expected imp.lock_held() to be %r" % expected)

</t>
<t tx="ekr.20040711134323.3">def testLock():

    LOOPS = 50

    # The import lock may already be held, e.g. if the test suite is run
    # via "import test.autotest".
    lock_held_at_start = imp.lock_held()
    verify_lock_state(lock_held_at_start)

    for i in range(LOOPS):
        imp.acquire_lock()
        verify_lock_state(True)

    for i in range(LOOPS):
        imp.release_lock()

    # The original state should be restored now.
    verify_lock_state(lock_held_at_start)

    if not lock_held_at_start:
        try:
            imp.release_lock()
        except RuntimeError:
            pass
        else:
            raise TestFailed("release_lock() without lock should raise "
                             "RuntimeError")
</t>
<t tx="ekr.20040711134323.4">def test_main():

    testLock()
</t>
</tnodes>
</leo_file>
