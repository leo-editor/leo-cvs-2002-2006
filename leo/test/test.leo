<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="4449" clone_windows="0"/>
<globals body_outline_ratio="0.414301929625">
	<global_window_position top="10" left="263" height="881" width="1011"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040303080938"><vh>Diary</vh>
<v t="ekr.20040315210314"><vh>March 2004</vh>
<v t="ekr.20040315210314.1"><vh>3/15: Created stubs for Find Commands tests</vh></v>
<v t="ekr.20040315210314.2"><vh>3/15: Convert this file to 4.2 format</vh></v>
<v t="ekr.20040309095121"><vh>3/9: created more position mini tests</vh></v>
<v t="ekr.20040303080938.1"><vh>3/3: created position tests</vh></v>
</v>
</v>
<v t="EKR.20040623202054.1"><vh>Others...</vh>
<v t="ekr.20040303071432"><vh>Mini tests, scripts &amp; experiments</vh>
<v t="ekr.20040312101720"><vh>Experiments</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
<v t="ekr.20040323075614"><vh>Test of using an iterator inside a list comprehension</vh></v>
<v t="ekr.20040323080317"><vh>Test of using c.allNodes_iter to create a list of all positions</vh></v>
<v t="ekr.20040323082119"><vh>Creating a list of distinct vnodes</vh></v>
<v t="ekr.20040325082811"><vh>Test that back quotes are not needed in es</vh></v>
<v t="ekr.20040325130503" a="M"><vh>test of list comparisons</vh></v>
<v t="ekr.20040325140133"><vh>test that childIndex doesn't mess with p</vh></v>
<v t="ekr.20040325155043"><vh>Test of __cmp__ vrs equal</vh></v>
</v>
<v t="ekr.20040312101720.1"><vh>Mini tests</vh>
<v t="ekr.20040309111054"><vh>Print iterations: do not delete</vh>
<v t="ekr.20040309111102"><vh>Clone test data</vh>
<v t="ekr.20040309111102.1"><vh>aa</vh></v>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.8"><vh>d</vh>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.9"><vh>e</vh></v>
<v t="ekr.20040309111102.10"><vh>z</vh></v>
</v>
<v t="ekr.20040309111232"><vh>last node</vh></v>
</v>
<v t="ekr.20040311125054"><vh>Test that p.t == p.v.t</vh></v>
<v t="ekr.20040310145919"><vh>Change python keywords</vh></v>
<v t="ekr.20040315030123"><vh>test convertTreeToString and allies</vh>
<v t="ekr.20040315025315"><vh>File Conversion</vh>
<v t="ekr.20040315025315.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315025315.2"><vh>moreHead</vh></v>
<v t="ekr.20040315025315.3"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20040318102920"><vh>test of consistency between parents iter and v.parents</vh>
<v t="ekr.20040318102920.1"><vh>parent</vh>
<v t="ekr.20040318102920.2"><vh>actual test</vh></v>
</v>
<v t="ekr.20040318102920.1"><vh>parent</vh>
<v t="ekr.20040318102920.2"><vh>actual test</vh></v>
</v>
</v>
<v t="ekr.20040323085406"><vh>test of isAnyAtFileNode</vh></v>
<v t="ekr.20040323090541"><vh>Check consistency of p.v.t.vnodeList, &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323085933"><vh>test of findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040323162303"><vh>Check that cloned nodes actually share subtrees</vh></v>
<v t="ekr.20040325073120"><vh>Test that isAt...FileNode works</vh>
<v t="ekr.20040325073120.1"><vh>@thinfile thinfile.txt</vh></v>
</v>
<v t="ekr.20040330103006" tnodeList="ekr.20040330103006"><vh>@file c:\prog\test\testSectionDelims.txt</vh></v>
<v t="ekr.20040327105955"><vh>test of batch mode</vh></v>
<v t="ekr.20040419105536" tnodeList="ekr.20040419105536,ekr.20040419105536.1,ekr.20040419105536.2"><vh>@file c:\prog\test\perlLineNumbersTest.txt</vh>
<v t="ekr.20040419105536.1"><vh>one</vh></v>
<v t="ekr.20040419105536.2"><vh>two</vh></v>
</v>
<v t="EKR.20040427092657"><vh>@ file-thin c:\prog\test\at-file-thin-test.txt</vh>
<v t="EKR.20040427092657.1"><vh>node 1</vh>
<v t="EKR.20040428145741"><vh>&lt;&lt; node 1 ref &gt;&gt;</vh>
<v t="EKR.20040428145741.1"><vh>child node 1</vh></v>
<v t="EKR.20040428145741.2"><vh>child node 2</vh></v>
</v>
</v>
<v t="EKR.20040427092657.2"><vh>&lt;&lt; ref &gt;&gt;</vh>
<v t="EKR.20040428150018"><vh>organizer node</vh>
<v t="EKR.20040428145826"><vh>ref child 1</vh></v>
<v t="EKR.20040428145826.1"><vh>ref child 2</vh></v>
</v>
</v>
</v>
<v t="ekr.20040414082806"><vh>Clone test</vh>
<v t="ekr.20040409140301"><vh>clone test</vh>
<v t="ekr.20040409140301.1"><vh>b</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028"><vh>sibling</vh></v>
</v>
<v t="ekr.20040409140301.3"><vh>a</vh></v>
</v>
<v t="ekr.20040409140343"><vh>d</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028.1"><vh>sibling 2</vh></v>
</v>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409140343.1"><vh>last</vh></v>
</v>
</v>
<v t="ekr.20040312021734"><vh>Scripts</vh>
<v t="ekr.20040311090054"><vh>Dump fileIndex</vh></v>
<v t="ekr.20040312021734.1"><vh>Script to clean unused tnodeLists</vh></v>
<v t="ekr.20040318091620"><vh>Clear all unknown attributes</vh></v>
<v t="ekr.20040319111213"><vh>FilterHoist script</vh>
<v t="ekr.20040319111213.1"><vh>description</vh></v>
<v t="ekr.20040319142708"><vh>filter</vh></v>
<v t="ekr.20040319142202"><vh>old code</vh>
<v t="ekr.20040319111213.2"><vh>filter</vh></v>
<v t="ekr.20040319111213.3"><vh>search</vh></v>
</v>
<v t="ekr.20040319111213.4"><vh>filterHoist</vh></v>
<v t="ekr.20040319111213.5"><vh>addMenu</vh></v>
</v>
<v t="ekr.20040322120331"><vh>script to print tnodeList's</vh></v>
<v t="ekr.20040330095252"><vh>script to clear log frame</vh></v>
<v t="EKR.20040424065452"><vh>Compare script</vh></v>
<v t="EKR.20040424091411"><vh>Compare script using text mode to ignore newlines</vh></v>
<v t="EKR.20040517074600.8"><vh>Count pages</vh></v>
<v t="EKR.20040517074600.9"><vh>Scripts to debug font problem</vh>
<v t="EKR.20040517074600.10"><vh>Show font</vh></v>
<v t="EKR.20040517074600.11"><vh>Show settings</vh>
<v t="EKR.20040517074600.12"><vh>getFontSettings</vh></v>
</v>
<v t="EKR.20040517074600.13"><vh>Print default font</vh></v>
</v>
</v>
<v t="EKR.20040531110157"><vh>at-file thin tests</vh>
<v t="EKR.20040520104329"><vh>@thin c:\prog\test\thinCloneTest.txt</vh></v>
<v t="EKR.20040524050419" tnodeList="EKR.20040524050419,EKR.20040524050419.1,EKR.20040524050419.2"><vh>@file c:\prog\test\fatGrandChildTest.txt</vh>
<v t="EKR.20040524050419.1"><vh>Organizer node</vh>
<v t="EKR.20040524050419.2"><vh>&lt;&lt; defined in grandchild &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040524050438"><vh>@thin c:\prog\test\grandChildTest.txt</vh></v>
<v t="EKR.20040525083635" tnodeList="EKR.20040525083635,EKR.20040525083635.1"><vh>@file c:\prog\test\orphanMessageTest.txt</vh>
<v t="EKR.20040525083635.1"><vh>orphan</vh></v>
</v>
</v>
</v>
<v t="EKR.20040430160416"><vh>Tests: for unit tests</vh>
<v t="EKR.20040430160416.1"><vh>jEdit modes Colorizer tests (bugs here)</vh>
<v t="EKR.20040430160416.2"><vh>tex.xml</vh>
<v t="EKR.20040430160416.3"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="EKR.20040430160416.4"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
<v t="EKR.20040430160416.5"><vh>python.xml</vh>
<v t="EKR.20040430160416.6"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="EKR.20040430160416.7"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="EKR.20040430160416.8"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="EKR.20040430160416.9"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="EKR.20040430160416.10"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="EKR.20040430160416.11"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="EKR.20040430160416.12"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="EKR.20040430160416.13"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="EKR.20040430160416.14"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040430160416.15"><vh> Colorizing Test</vh></v>
<v t="EKR.20040430162649.1"><vh>Unicode tests</vh>
<v t="EKR.20040430162649.2"><vh> Tests</vh>
<v t="EKR.20040430162649.3"><vh>@file-asis c:\prog\test\asisTest.txt</vh></v>
<v t="EKR.20040430162649.4"><vh>@file-nosent c:\prog\test\nosentTest.txt</vh></v>
<v t="EKR.20040430162649.5"><vh>@file-noref c:\prog\test\norefTest.txt</vh></v>
</v>
<v t="EKR.20040430162649.6"><vh> Tests</vh>
<v t="EKR.20040430162649.7"><vh>Import/export tests</vh>
<v t="EKR.20040430162649.8"><vh>test</vh>
<v t="EKR.20040430162649.9"><vh>NewHeadlineë</vh></v>
</v>
</v>
<v t="EKR.20040430162649.10"><vh>@file c:/prog/test/unicodeTest.doc</vh>
<v t="EKR.20040430162649.11"><vh>NewÖ</vh></v>
</v>
</v>
</v>
<v t="EKR.20040430162649.12"><vh>REM_ hack and perlpod hacks</vh>
<v t="EKR.20040430162649.13"><vh>perlpod test</vh>
<v t="EKR.20040430162649.14"><vh>perlpod test</vh>
<v t="EKR.20040430162649.15"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040430162649.16"><vh>REM test</vh>
<v t="EKR.20040430162649.17"><vh>@file c:/prog/test/remTest.txt</vh></v>
</v>
</v>
<v t="EKR.20040430162649.18"><vh>Allow @comment after @language plain</vh>
<v t="EKR.20040430162649.19"><vh>Test</vh></v>
</v>
<v t="EKR.20040430162649.20"><vh>Suppress @@ sentinel unless leading @ starts a directive</vh>
<v t="EKR.20040430162649.21"><vh>@file c:\prog\test\perltest.txt</vh></v>
</v>
<v t="EKR.20040430162649.22"><vh>Reformat Paragraph tests</vh></v>
<v t="EKR.20040430162649.23"><vh>(double @root bug)</vh>
<v t="EKR.20040430162649.24"><vh>Assert fails</vh></v>
<v t="EKR.20040430162649.25"><vh>double at-root test (assert fails)</vh></v>
</v>
<v t="EKR.20040526094831"><vh>Test of undo registration</vh></v>
<v t="EKR.20040526193608"><vh>Tests of pickle &amp; hexlify</vh></v>
<v t="EKR.20040526200017" myPlugin="7d710055016171014930310a732e"><vh>Test of unknownAttributes</vh></v>
<v t="EKR.20040529092739"><vh>Tests of c iters</vh>
<v t="EKR.20040529093047"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="EKR.20040529093047.1"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="EKR.20040528152529"><vh>Tests of p and v iters</vh>
<v t="EKR.20040527073459"><vh>child1</vh>
<v t="EKR.20040527072047"><vh>a</vh>
<v t="EKR.20040527072047.1"><vh>b</vh></v>
</v>
<v t="EKR.20040527074524"><vh>c</vh></v>
<v t="EKR.20040527072047"><vh>a</vh>
<v t="EKR.20040527072047.1"><vh>b</vh></v>
</v>
<v t="EKR.20040527074524.1"><vh>d</vh>
<v t="EKR.20040527074524.2"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040529105640"><vh>child2</vh></v>
<v t="EKR.20040529104307"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="EKR.20040527083449.1"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="EKR.20040527083449.2"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="EKR.20040527154402"><vh>Test of undo extract section</vh>
<v t="EKR.20040528130659"><vh>a</vh></v>
<v t="EKR.20040528130659"><vh>a</vh></v>
</v>
<v t="EKR.20040523112430"><vh>Cloning headlines</vh>
<v t="EKR.20040523112430.1"><vh>read me</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.8"><vh>f</vh></v>
</v>
</v>
<v t="EKR.20040608095146"><vh>Recent tests</vh>
<v t="EKR.20040504083716.44"><vh>perfect import unit tests</vh>
<v t="EKR.20040504083716.45"><vh>@   file test_sentinels.py</vh>
<v t="EKR.20040504083716.47"><vh>class sentinel_test</vh>
<v t="EKR.20040504083716.48"><vh>setUp</vh></v>
<v t="EKR.20040504083716.49"><vh>setup_inputfile</vh></v>
<v t="EKR.20040504083716.50"><vh>setup_configfile</vh></v>
</v>
<v t="EKR.20040504083716.51"><vh>insert tests</vh>
<v t="EKR.20040504083716.52"><vh>class insert_test</vh>
<v t="EKR.20040504083716.53"><vh>setUp</vh></v>
<v t="EKR.20040504083716.54"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.55"><vh>replacement tests</vh>
<v t="EKR.20040504083716.56"><vh>class replace_test</vh>
<v t="EKR.20040504083716.57"><vh>setUp</vh></v>
<v t="EKR.20040504083716.58"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.59"><vh>class replace_test2</vh>
<v t="EKR.20040504083716.60"><vh>setUp</vh></v>
<v t="EKR.20040504083716.61"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.62"><vh>class replace_test3</vh>
<v t="EKR.20040504083716.63"><vh>setUp</vh></v>
<v t="EKR.20040504083716.64"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.65"><vh>class replace_test4</vh>
<v t="EKR.20040504083716.66"><vh>setUp</vh></v>
<v t="EKR.20040504083716.67"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.68"><vh>regression tests</vh>
<v t="EKR.20040504083716.69"><vh>class regression_test_1</vh>
<v t="EKR.20040504083716.70"><vh>setUp</vh></v>
<v t="EKR.20040504083716.71"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.72"><vh>main</vh></v>
</v>
<v t="EKR.20040504083716.73"><vh>not used</vh>
<v t="EKR.20040504083716.74" tnodeList="EKR.20040504083716.74"><vh>@file testtesting.ini</vh></v>
<v t="EKR.20040504083716.75"><vh>tests to write</vh>
<v t="EKR.20040504083716.76"><vh>Insert tests.</vh></v>
<v t="EKR.20040504083716.77"><vh>deletion tests.</vh></v>
<v t="EKR.20040504083716.78"><vh>Creation of backup files.</vh></v>
</v>
</v>
</v>
<v t="EKR.20040504083716"><vh>Mulder Update script</vh>
<v t="EKR.20040504083716.39"><vh>sync</vh>
<v t="EKR.20040504153320"><vh>&lt;&lt; compute sourcetime and targettime &gt;&gt;</vh></v>
<v t="EKR.20040504153320.1"><vh>&lt;&lt; compute operation &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040602101648"><vh>Test of "end1" hook</vh></v>
<v t="ekr.20040317173327"><vh>Delete user icons</vh></v>
<v t="ekr.20040317101155"><vh>Test of user icons</vh>
<v t="ekr.20040317185041"><vh>&lt;&lt; define event callbacks &gt;&gt;</vh></v>
</v>
<v t="EKR.20040603064545"><vh>Print timestamps of all nodes</vh></v>
<v t="EKR.20040603103118"><vh>String bug in html</vh></v>
<v t="EKR.20040603143325"><vh>AssertionError test</vh></v>
<v t="EKR.20040603174633"><vh>test of focus</vh></v>
<v t="EKR.20040604082113"><vh>Test of @tabwidth</vh></v>
<v t="EKR.20040604143253"><vh>Test of Remove sentinels</vh>
<v t="EKR.20040604143253.1"><vh>@thin removeSentTest.txt</vh></v>
</v>
<v t="EKR.20040604170105"><vh>Mini test of Remove sentinels</vh></v>
<v t="EKR.20040606204316"><vh>test of @first</vh>
<v t="EKR.20040606204316.1"><vh>@thin atFirstTest.txt</vh></v>
</v>
<v t="EKR.20040605200750"><vh>autocompleter test</vh></v>
<v t="EKR.20040608092841"><vh>test of indent/undent with negative tab width</vh></v>
<v t="EKR.20040608095146.1" a="M" tnodeList="EKR.20040608095146.1"><vh>@file login_process.cfm</vh></v>
<v t="EKR.20040610092248"><vh>Test of pasting into big node</vh></v>
<v t="EKR.20040610131858"><vh>Test of Paste Node Retaining Clones</vh>
<v t="EKR.20040615144810"><vh>b</vh></v>
<v t="EKR.20040615144735"><vh>branch</vh>
<v t="EKR.20040615144810"><vh>b</vh></v>
<v t="EKR.20040610131858.1"><vh>a</vh>
<v t="EKR.20040610143643"><vh>b</vh></v>
<v t="EKR.20040610143643"><vh>b</vh></v>
</v>
<v t="EKR.20040610131858.1"><vh>a</vh>
<v t="EKR.20040610143643"><vh>b</vh></v>
<v t="EKR.20040610143643"><vh>b</vh></v>
</v>
<v t="EKR.20040610132739"><vh>copied</vh></v>
</v>
</v>
</v>
<v t="EKR.20040612095237"><vh>Prototypes of new commands</vh>
<v t="ekr.20040402043516"><vh>A pretty printer for Leo</vh>
<v t="ekr.20040402084155"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040402064301"><vh>class prettyPrinter</vh>
<v t="ekr.20040402064301.1"><vh>__init__</vh></v>
<v t="ekr.20040402093822"><vh>get</vh></v>
<v t="ekr.20040402072335"><vh>put</vh></v>
<v t="ekr.20040402081135"><vh>putOperator</vh></v>
<v t="ekr.20040402080311"><vh>putToken</vh></v>
<v t="ekr.20040402074431"><vh>putNormalToken</vh></v>
<v t="ekr.20040402074431.1"><vh>dumpToken</vh></v>
</v>
</v>
<v t="EKR.20040610201941"><vh>Check Syntax prototype</vh>
<v t="EKR.20040610192622"><vh>Check Syntax script</vh></v>
<v t="EKR.20040610192622.1"><vh>Check Syntax data</vh></v>
</v>
<v t="EKR.20040610201236"><vh>Tabnanny prototype</vh>
<v t="EKR.20040610194209"><vh>TabNanny script</vh>
<v t="EKR.20040610195543"><vh>checkString</vh></v>
</v>
<v t="EKR.20040610195543.1"><vh>tabnanny.py (reference only)</vh>
<v t="EKR.20040610195543.2"><vh>&lt;&lt; tabnanny declarations &gt;&gt;</vh></v>
<v t="EKR.20040610195543.3"><vh>errprint</vh></v>
<v t="EKR.20040610195543.4"><vh>main</vh></v>
<v t="EKR.20040610195543.5"><vh>class NannyNag</vh>
<v t="EKR.20040610195543.6"><vh>__init__</vh></v>
<v t="EKR.20040610195543.7"><vh>get_lineno</vh></v>
<v t="EKR.20040610195543.8"><vh>get_msg</vh></v>
<v t="EKR.20040610195543.9"><vh>get_line</vh></v>
</v>
<v t="EKR.20040610195543.10"><vh>check</vh></v>
<v t="EKR.20040610195543.11"><vh>class Whitespace</vh>
<v t="EKR.20040610195543.12"><vh>&lt;&lt; class Whitespace declarations &gt;&gt;</vh></v>
<v t="EKR.20040610195543.13"><vh>__init__</vh></v>
<v t="EKR.20040610195543.14"><vh>longest_run_of_spaces</vh></v>
<v t="EKR.20040610195543.15"><vh>indent_level</vh></v>
<v t="EKR.20040610195543.16"><vh>equal</vh></v>
<v t="EKR.20040610195543.17"><vh>not_equal_witness</vh></v>
<v t="EKR.20040610195543.18"><vh>less</vh></v>
<v t="EKR.20040610195543.19"><vh>not_less_witness</vh></v>
</v>
<v t="EKR.20040610195543.20"><vh>format_witnesses</vh></v>
<v t="EKR.20040610195543.21"><vh>process_tokens</vh></v>
</v>
<v t="EKR.20040610194209.1"><vh>TabNanny data</vh></v>
</v>
<v t="EKR.20040611083703"><vh>Using a generator instead of readLinesClass</vh></v>
</v>
<v t="EKR.20040612150543"><vh>Test of better error messages in Execute Script command</vh>
<v t="EKR.20040612215136"><vh>Contains error</vh></v>
</v>
<v t="EKR.20040613162717"><vh>Report newlines</vh></v>
<v t="EKR.20040615070332"><vh>Test print</vh></v>
<v t="EKR.20040622074004.1"><vh>a</vh>
<v t="EKR.20040622074004.2"><vh>b</vh></v>
<v t="EKR.20040622074004.3"><vh>c</vh></v>
</v>
<v t="EKR.20040622074004"><vh>Test of conflicting node defs</vh>
<v t="EKR.20040622102618"><vh>@thin c:\prog\test\cloneConflicts.txt</vh></v>
</v>
<v t="ekr.20040303062846.2"><vh>leoTestOLD.py</vh>
<v t="ekr.20040303062846.1"><vh>&lt;&lt; to do &gt;&gt;</vh></v>
<v t="EKR.20040619133501"><vh>&lt;&lt; leoTest imports &gt;&gt;</vh></v>
<v t="ekr.20040303062846.3"><vh> class testUtils</vh>
<v t="ekr.20040303062846.4"><vh>compareOutlines</vh></v>
<v t="EKR.20040621095514"><vh>Finding nodes...</vh>
<v t="ekr.20040303062846.5"><vh>fundChildrenOf</vh></v>
<v t="EKR.20040621095514.1"><vh>findSubnodesOf TO DO: Replace this</vh></v>
<v t="ekr.20040303062846.6"><vh>findNodeInRootTree</vh></v>
<v t="EKR.20040621095514.2"><vh>findNodeInTree</vh></v>
<v t="EKR.20040621095514.3"><vh>findNodeAnywhere</vh></v>
<v t="EKR.20040621095514.4"><vh>findUnitTestNode</vh></v>
</v>
<v t="EKR.20040621101000"><vh>numberOfClonesInOutline</vh></v>
<v t="ekr.20040303062846.7"><vh>numberOfNodesInOutline</vh></v>
<v t="ekr.20040303062846.8"><vh>replaceOutline</vh></v>
</v>
<v t="ekr.20040303062846.10"><vh> fail</vh></v>
<v t="EKR.20040623201302"><vh>atFile tests</vh>
<v t="EKR.20040623200709.17"><vh>makeAtFileSuite</vh></v>
<v t="EKR.20040621080031"><vh>class atFile</vh>
<v t="EKR.20040621080031.3"><vh>__init__</vh></v>
<v t="EKR.20040621155439"><vh>compareDerivedFiles (Not used)</vh></v>
<v t="EKR.20040621080031.4"><vh>runTest</vh></v>
<v t="EKR.20040621080031.5"><vh>setUp</vh></v>
</v>
</v>
<v t="ekr.20040327115825"><vh>Batch mode tests</vh>
<v t="ekr.20040327115832.1"><vh> makeBatchModeSuite</vh></v>
<v t="ekr.20040327115832.2"><vh>class batchModeTestCase</vh>
<v t="ekr.20040327120228"><vh>test_1</vh></v>
</v>
</v>
<v t="ekr.20040303062846.11"><vh>Colorizer tests</vh>
<v t="ekr.20040303062846.12"><vh> makeColorSuite</vh></v>
<v t="ekr.20040303062846.13"><vh>class colorTestCase</vh>
<v t="ekr.20040303062846.14"><vh>__init__</vh></v>
<v t="ekr.20040303062846.15"><vh>color</vh></v>
<v t="ekr.20040303062846.16"><vh>setUp</vh></v>
<v t="ekr.20040303062846.17"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.18"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040303062846.19"><vh>Edit body tests</vh>
<v t="ekr.20040303062846.20"><vh> makeEditBodySuite</vh></v>
<v t="ekr.20040303062846.21"><vh>class editBodyTestCase</vh>
<v t="ekr.20040303062846.22"><vh>__init__</vh></v>
<v t="ekr.20040303062846.23"><vh>editBody</vh>
<v t="EKR.20040527145121"><vh>&lt;&lt; compare new, ref trees &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303062846.24"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.25"><vh>setUp</vh></v>
<v t="ekr.20040303062846.26"><vh>runTest</vh></v>
</v>
</v>
<v t="ekr.20040315202201"><vh>Find Command tests</vh>
<v t="ekr.20040315202250"><vh> makeFindCommandSuite</vh></v>
<v t="ekr.20040315202314"><vh>class findCommandTestCase</vh>
<v t="ekr.20040315202314.1"><vh>setUp</vh></v>
<v t="ekr.20040315202347"><vh>testFindCommand</vh></v>
<v t="ekr.20040315202718"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040315202718.1"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040303062846.27"><vh>Import/Export tests</vh>
<v t="ekr.20040303062846.28"><vh>makeImportExportSuite</vh></v>
<v t="ekr.20040303062846.29"><vh>class importExportTestCase</vh>
<v t="ekr.20040303062846.30"><vh>__init__</vh></v>
<v t="ekr.20040303062846.31"><vh>importExport</vh></v>
<v t="ekr.20040303062846.32"><vh>runTest</vh></v>
<v t="ekr.20040303062846.33"><vh>setUp</vh></v>
<v t="ekr.20040303062846.34"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.35"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.36"><vh>LeoFiles tests</vh>
<v t="ekr.20040303062846.37"><vh>makeLeoFilesSuite</vh></v>
<v t="ekr.20040303062846.38"><vh>class leoFileTestCase</vh>
<v t="ekr.20040303062846.39"><vh>__init__</vh></v>
<v t="ekr.20040303062846.40"><vh>runTest</vh></v>
<v t="ekr.20040303062846.41"><vh>setUp</vh></v>
<v t="ekr.20040303062846.42"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.63"><vh>Outline tests (tests undo)</vh>
<v t="ekr.20040303062846.64"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040303062846.65"><vh>class outlineTestCase</vh>
<v t="ekr.20040303062846.66"><vh>__init__</vh></v>
<v t="ekr.20040303062846.67"><vh>outlineCommand</vh></v>
<v t="ekr.20040303062846.68"><vh>runTest</vh></v>
<v t="ekr.20040303062846.69"><vh>setUp</vh></v>
<v t="ekr.20040303062846.70"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303062846.72"><vh>Plugin tests</vh>
<v t="ekr.20040303062846.71"><vh> makePluginsSuite</vh></v>
<v t="ekr.20040303062846.73"><vh>class pluginTestCase</vh>
<v t="ekr.20040303062846.74"><vh>__init__</vh></v>
<v t="ekr.20040303062846.75"><vh>pluginTest</vh></v>
<v t="ekr.20040303062846.76"><vh>runTest</vh></v>
<v t="ekr.20040303062846.77"><vh>setUp</vh></v>
<v t="ekr.20040303062846.78"><vh>shortDescription</vh></v>
<v t="ekr.20040303062846.79"><vh>tearDown</vh></v>
</v>
</v>
<v t="ekr.20040303063644"><vh>Position tests</vh>
<v t="ekr.20040303064013"><vh> makePositionSuite</vh></v>
<v t="ekr.20040303063118"><vh>class positionTestCase</vh>
<v t="ekr.20040303063118.4"><vh>setUp</vh></v>
<v t="ekr.20040309105731"><vh>testComparisons</vh></v>
<v t="ekr.20040323163413"><vh>testThatClonesShareSubtrees</vh></v>
<v t="ekr.20040312101853"><vh>Consistency tests...</vh>
<v t="ekr.20040309101454.15"><vh>testConsistencyOfAllNodesThreadNext</vh></v>
<v t="ekr.20040309101454.17"><vh>testConsistencyOfFirstChildAndChildrenIter</vh></v>
<v t="ekr.20040309101454.13"><vh>testConsistencyOfLevel</vh></v>
<v t="ekr.20040303064020.5"><vh>testConsistencyOfNextBack</vh></v>
<v t="ekr.20040309101454.16"><vh>testConsistencyOfParentAndParentsIter</vh></v>
<v t="ekr.20040309101454.14"><vh>testConsistencyOfParentChild</vh></v>
<v t="ekr.20040303064020.7"><vh>testConsistencyOfThreadBackNext</vh></v>
<v t="ekr.20040323163643"><vh>testConsistencyOfVnodeListAndParents</vh></v>
<v t="ekr.20040303091606"><vh>testHasNextBack</vh></v>
<v t="ekr.20040303092153"><vh>testHasParentChild</vh></v>
<v t="ekr.20040303092153.1"><vh>testHasThreadNextBack</vh></v>
<v t="ekr.20040303064020.6"><vh>testVnodeList</vh></v>
</v>
</v>
</v>
<v t="ekr.20040303062846.80"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040303062846.81"><vh>makeReformatParagraphSuite</vh></v>
<v t="ekr.20040303062846.82"><vh>class reformatParagraphTestCase</vh>
<v t="ekr.20040303062846.83"><vh>setUp</vh></v>
<v t="ekr.20040303062846.84"><vh>tearDown</vh></v>
<v t="ekr.20040303062846.85"><vh>testNoTrailingNewline</vh></v>
<v t="ekr.20040303062846.86"><vh>testTrailingNewline</vh></v>
<v t="ekr.20040303062846.87"><vh>testMixedLineLengths</vh></v>
<v t="ekr.20040303062846.88"><vh>testMixedLinesWithLeadingWS</vh></v>
<v t="ekr.20040303062846.89"><vh>testNoChangeRequired</vh></v>
<v t="ekr.20040303062846.90"><vh>testHonorLeadingWS</vh></v>
<v t="ekr.20040303062846.91"><vh>testHonorLeadingWSVar1</vh></v>
<v t="ekr.20040303062846.92"><vh>testSimpleHangingIndent</vh></v>
<v t="ekr.20040303062846.93"><vh>testSimpleHangingIndentVar1</vh></v>
<v t="ekr.20040303062846.94"><vh>testSimpleHangingIndentVar2</vh></v>
<v t="ekr.20040303062846.95"><vh>testMultiParagraph</vh></v>
<v t="ekr.20040303062846.96"><vh>testMultiParagraphWithList</vh></v>
<v t="ekr.20040303062846.97"><vh>testDirectiveBreaksParagraph</vh></v>
<v t="ekr.20040303062846.98"><vh>testWithLeadingWSOnEmptyLines</vh></v>
<v t="ekr.20040303062846.99"><vh>singleParagraphTest</vh></v>
<v t="ekr.20040303062846.100"><vh>checkPosition</vh></v>
<v t="ekr.20040303062846.101"><vh>checkText</vh></v>
<v t="ekr.20040303062846.102"><vh>copyBeforeToTemp</vh></v>
<v t="ekr.20040303062846.103"><vh>getCaseDataNodes</vh></v>
<v t="ekr.20040303062846.104"><vh>getRowCol</vh></v>
</v>
</v>
</v>
<v t="EKR.20040623213443"><vh>Other atFile test cases</vh>
<v t="EKR.20040623201322.13"><vh>NOT YET test @asis plain text</vh>
<v t="EKR.20040623201322.14"><vh>@@asis</vh></v>
<v t="EKR.20040623201322.15"><vh>Output</vh></v>
</v>
<v t="EKR.20040623201322.16"><vh>NOT YET test @asis ignored references, directives</vh>
<v t="EKR.20040623201322.17"><vh>@@asis</vh></v>
<v t="EKR.20040623201322.18"><vh>output</vh></v>
</v>
</v>
<v t="EKR.20040623200709.20"><vh>compareDerivedFiles (Not used)</vh></v>
</v>
<v t="EKR.20040619133116" a="TV"><vh>Unit testing...</vh>
<v t="ekr.20040327114250" tnodeList="ekr.20040327114250"><vh>@file c:\prog\test\unittest\batchTest.py</vh></v>
<v t="EKR.20040623200709"><vh>@thin ../src/leoTest.py</vh></v>
<v t="ekr.20040303063549"><vh>Unit test scripts (Must be located here)</vh>
<v t="ekr.20040126105605"><vh>cloneTestData (not used yet)</vh>
<v t="ekr.20040302092753"><vh>aa</vh></v>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.1"><vh>d</vh>
<v t="ekr.20040126105605.2"><vh>a</vh>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040126105605.3"><vh>b</vh>
<v t="ekr.20040301191933"><vh>c</vh>
<v t="ekr.20040302092753.1"><vh>c2</vh>
<v t="ekr.20040302092753.2"><vh>c3</vh></v>
<v t="ekr.20040302092753.3"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040301191933.2"><vh>e</vh></v>
<v t="ekr.20040302092753.4"><vh>z</vh></v>
</v>
<v t="ekr.20040303063549.1"><vh>tempNode</vh></v>
<v t="EKR.20040621100553"><vh>@  file c:\prog\test\tempOutput.txt</vh></v>
<v t="EKR.20040619134504" a="M"><vh>atFileTests</vh>
<v t="EKR.20040624112329"><vh>Script to create expected output</vh></v>
<v t="EKR.20040624103339.1"><vh>testAtLast1 no newline</vh>
<v t="EKR.20040624103339.2"><vh>@@file</vh></v>
<v t="EKR.20040624103339.3"><vh>Output</vh></v>
</v>
<v t="EKR.20040623201322.4"><vh>testAtLast2 one newline</vh>
<v t="EKR.20040624111917"><vh>@@file</vh></v>
<v t="EKR.20040624111917.1"><vh>Output</vh></v>
</v>
<v t="EKR.20040623201322.7"><vh>testAtLast3 two newlines</vh>
<v t="EKR.20040624112329.1"><vh>@@file</vh></v>
<v t="EKR.20040624112329.2"><vh>Output</vh></v>
</v>
<v t="EKR.20040623201322.10"><vh>testAtLast4 @thin</vh>
<v t="EKR.20040624112329.3"><vh>@@thin</vh></v>
<v t="EKR.20040624112329.4"><vh>Output</vh></v>
</v>
</v>
<v t="ekr.20040327115825.1"><vh>batchModeTests</vh></v>
<v t="ekr.20040303063549.45"><vh>colorizerTests</vh>
<v t="ekr.20040303063549.46"><vh>Actionscript</vh></v>
<v t="ekr.20040303063549.47"><vh>C</vh></v>
<v t="ekr.20040303063549.48"><vh>C#</vh></v>
<v t="ekr.20040401104620"><vh>css</vh></v>
<v t="ekr.20040303063549.49"><vh>CWEB</vh>
<v t="ekr.20040303063549.50"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.51"><vh>elisp</vh></v>
<v t="ekr.20040303063549.52"><vh>HTML1</vh></v>
<v t="ekr.20040303063549.53"><vh>HTML2</vh></v>
<v t="ekr.20040303063549.54"><vh>LaTex</vh></v>
<v t="ekr.20040303063549.55"><vh>Mixed</vh></v>
<v t="ekr.20040303063549.56"><vh>PHP</vh></v>
<v t="ekr.20040303063549.57"><vh>Python1</vh></v>
<v t="ekr.20040303063549.58"><vh>Python2</vh></v>
<v t="ekr.20040401113911"><vh>rapidq</vh></v>
<v t="ekr.20040303063549.59"><vh>Rebol</vh></v>
<v t="ekr.20040401111417"><vh>shell</vh></v>
<v t="ekr.20040303063549.60"><vh>wikiTest1</vh></v>
<v t="ekr.20040303063549.61"><vh>wikiTest2</vh></v>
<v t="ekr.20040303063549.62"><vh>wikiTest3</vh></v>
</v>
<v t="ekr.20040303063549.63"><vh>editBodyTests</vh>
<v t="ekr.20040303063549.64"><vh>dedentBody</vh>
<v t="ekr.20040303063549.65"><vh>before</vh></v>
<v t="ekr.20040303063549.66"><vh>after</vh></v>
<v t="ekr.20040303063549.67"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.68"><vh>indentBody</vh>
<v t="ekr.20040303063549.69"><vh>before</vh></v>
<v t="ekr.20040303063549.70"><vh>after</vh></v>
<v t="ekr.20040303063549.71"><vh>selection</vh></v>
</v>
<v t="ekr.20040303063549.72"><vh>extractSection</vh>
<v t="ekr.20040303063549.73"><vh>before</vh></v>
<v t="ekr.20040303063549.74"><vh>after</vh>
<v t="ekr.20040303063549.75"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040303063549.76"><vh>selection</vh></v>
</v>
</v>
<v t="ekr.20040303063549.77"><vh>exportTests</vh>
<v t="ekr.20040303063549.78"><vh>exportHeadlines</vh>
<v t="ekr.20040303063549.79"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.80"><vh>flattenOutline</vh>
<v t="ekr.20040303063549.81"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.82"><vh>weave</vh>
<v t="ekr.20040303063549.83"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.84"><vh>outlineToNoweb</vh>
<v t="ekr.20040303063549.85"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.86"><vh>outlineToCWEB</vh>
<v t="ekr.20040303063549.87"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.88"><vh>removeSentinels</vh>
<v t="ekr.20040303063549.89"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.120"><vh>leoFileTests (revised)</vh></v>
<v t="ekr.20040315202718.2"><vh>findCommandTests</vh></v>
<v t="ekr.20040303063549.90"><vh>importTests</vh>
<v t="ekr.20040303063549.91"><vh>importAtRoot</vh>
<v t="ekr.20040303063549.92"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.93"><vh>importAtFile</vh>
<v t="ekr.20040303063549.94"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.95"><vh>importNowebFiles</vh>
<v t="ekr.20040303063549.96"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.97"><vh>importFlattenedOutline</vh>
<v t="ekr.20040303063549.98"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.99"><vh>importCWEBFiles</vh>
<v t="ekr.20040303063549.100"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.101"><vh>outlineTests</vh>
<v t="ekr.20040303063549.102"><vh>moveOutlineDown</vh>
<v t="ekr.20040303063549.103"><vh>before</vh>
<v t="ekr.20040303063549.104"><vh>a</vh></v>
<v t="ekr.20040303063549.105"><vh>move</vh></v>
<v t="ekr.20040303063549.106"><vh>b</vh></v>
</v>
<v t="ekr.20040303063549.107"><vh>after</vh>
<v t="ekr.20040303063549.108"><vh>a</vh></v>
<v t="ekr.20040303063549.109"><vh>b</vh></v>
<v t="ekr.20040303063549.110"><vh>move</vh></v>
</v>
<v t="ekr.20040303063549.111"><vh>ref</vh>
<v t="ekr.20040303063549.112"><vh>a</vh></v>
<v t="ekr.20040303063549.113"><vh>move</vh></v>
<v t="ekr.20040303063549.114"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040303063549.115"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040303063549.116"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040303063549.117"><vh>moveOutlineUp</vh></v>
</v>
<v t="ekr.20040303063549.118"><vh>pluginsTests</vh></v>
<v t="ekr.20040303063549.119"><vh>positionTests</vh></v>
<v t="ekr.20040303063549.2"><vh>reformatParagraphsTests</vh>
<v t="ekr.20040303063549.3"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040303063549.4"><vh>before</vh></v>
<v t="ekr.20040303063549.5"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.6"><vh>testTrailingNewline</vh>
<v t="ekr.20040303063549.7"><vh>before</vh></v>
<v t="ekr.20040303063549.8"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.9"><vh>testMixedLineLengths</vh>
<v t="ekr.20040303063549.10"><vh>before</vh></v>
<v t="ekr.20040303063549.11"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.12"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040303063549.13"><vh>before</vh></v>
<v t="ekr.20040303063549.14"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.15"><vh>testNoChangeRequired</vh>
<v t="ekr.20040303063549.16"><vh>before</vh></v>
<v t="ekr.20040303063549.17"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.18"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040303063549.19"><vh>before</vh></v>
<v t="ekr.20040303063549.20"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.21"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040303063549.22"><vh>before</vh></v>
<v t="ekr.20040303063549.23"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.24"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040303063549.25"><vh>before</vh></v>
<v t="ekr.20040303063549.26"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.27"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040303063549.28"><vh>before</vh></v>
<v t="ekr.20040303063549.29"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.30"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040303063549.31"><vh>before</vh></v>
<v t="ekr.20040303063549.32"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.33"><vh>testMultiParagraph</vh>
<v t="ekr.20040303063549.34"><vh>before</vh></v>
<v t="ekr.20040303063549.35"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.36"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040303063549.37"><vh>before</vh></v>
<v t="ekr.20040303063549.38"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.39"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040303063549.40"><vh>before</vh></v>
<v t="ekr.20040303063549.41"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.42"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040303063549.43"><vh>before</vh></v>
<v t="ekr.20040303063549.44"><vh>after</vh></v>
</v>
</v>
<v t="ekr.20040303063549.125"><vh>Run all tests</vh></v>
<v t="ekr.20040303080010"><vh>Run all non-file tests</vh></v>
</v>
</v>
<v t="EKR.20040624085716" tnodeList="EKR.20040624085716"><vh>@file c:\prog\test\writeMissing.txt</vh></v>
</vnodes>
<tnodes>
<t tx="EKR.20040424065452">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
lines1 = f1.readlines()
lines2 = f2.readlines()
f1.close() ; f2.close()

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
text1 = f1.read()
text2 = f2.read()
f1.close() ; f2.close()

cr1 = text1.count('\r')
cr2 = text2.count('\r')

print '-'*20
print "lines ",len(lines1),len(lines2)
print "chars ",len(text1),len(text2)
print "non-cr",len(text1)-cr1,len(text2)-cr2
print "cr    ",cr1,cr2</t>
<t tx="EKR.20040424091411">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
g.es("equal (raw mode)",f1.read()==f2.read())
f1.close() ; f2.close()

f1 = open(p1) ; f2 = open(p2)
g.es("equal (text mode)",f1.read()==f2.read())
f1.close() ; f2.close()</t>
<t tx="EKR.20040427092657">@ignore

root line 1

@others

root after at-others

&lt;&lt; ref &gt;&gt;
</t>
<t tx="EKR.20040427092657.1">node 1 line 1

&lt;&lt; node 1 ref &gt;&gt;

node 1 last line</t>
<t tx="EKR.20040427092657.2">ref line 1

@others</t>
<t tx="EKR.20040428145741">node 1 ref line 1

@others</t>
<t tx="EKR.20040428145741.1"></t>
<t tx="EKR.20040428145741.2"></t>
<t tx="EKR.20040428145826"></t>
<t tx="EKR.20040428145826.1"></t>
<t tx="EKR.20040428150018">text of organizer node</t>
<t tx="EKR.20040430160416">@language python
@tabwidth -4

@ignore
</t>
<t tx="EKR.20040430160416.1">@language html</t>
<t tx="EKR.20040430160416.2">&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="EKR.20040430160416.3">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="EKR.20040430160416.4">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="EKR.20040430160416.5">&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="EKR.20040430160416.6">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="EKR.20040430160416.7">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="EKR.20040430160416.8">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="EKR.20040430160416.9">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="EKR.20040430160416.10">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="EKR.20040430160416.11">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="EKR.20040430160416.12">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="EKR.20040430160416.13">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="EKR.20040430160416.14">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="EKR.20040430160416.15">@language python
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""

""" {picture file=../Icons/Leoapp.GIF}this """ # There are probdlems \with correct indexing following a graphic.

and if

import leoGlobals as g
print `g.app().loadDir`</t>
<t tx="EKR.20040430162649.1"></t>
<t tx="EKR.20040430162649.2"></t>
<t tx="EKR.20040430162649.3">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.4">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.5">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.6">@ignore

Ä á Û</t>
<t tx="EKR.20040430162649.7">@encoding iso-8859-1</t>
<t tx="EKR.20040430162649.8"></t>
<t tx="EKR.20040430162649.9"></t>
<t tx="EKR.20040430162649.10">@encoding cp1252
@others</t>
<t tx="EKR.20040430162649.11">aÖb</t>
<t tx="EKR.20040430162649.12">@ignore</t>
<t tx="EKR.20040430162649.13">@language perlpod
@path c:\prog\test</t>
<t tx="EKR.20040430162649.14">@root perlpod.txt
@ Multi-line
doc part
&lt;&lt;ref&gt;&gt;</t>
<t tx="EKR.20040430162649.15">@ doc part2
@c
code line1
code line2
@ more doc part</t>
<t tx="EKR.20040430162649.16">@comment REM_</t>
<t tx="EKR.20040430162649.17">test 6</t>
<t tx="EKR.20040430162649.18">@ignore</t>
<t tx="EKR.20040430162649.19">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
ths continues */

More plain text.</t>
<t tx="EKR.20040430162649.20">@ atFile.directiveKind is return miscDirective on _any_ line that starts with @</t>
<t tx="EKR.20040430162649.21">@ignore

line 1
@line 2
    @line 3
line 4</t>
<t tx="EKR.20040430162649.22">@nocolor
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
    
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
     a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="EKR.20040430162649.23">@ignore</t>
<t tx="EKR.20040430162649.24">enabling: *
Exception in Tkinter callback
Traceback (most recent call last):
  File "c:\python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "leoFrame.py", line 1368, in OnTangle
    self.commands.tangleCommands.tangle()
  File "leoTangle.py", line 507, in tangle
    self.tangleTree(v,report_errors)
  File "leoTangle.py", line 644, in tangleTree
    self.tanglePass1(v) # sets self.v
  File "leoTangle.py", line 589, in tanglePass1
    self.skip_body(v)
  File "leoTangle.py", line 1062, in skip_body
    self.st_enter_root_name(old_root_name,code,doc)
  File "leoTangle.py", line 2040, in st_enter_root_name
    assert(code)
AssertionError
</t>
<t tx="EKR.20040430162649.25">@root a.txt
@ 

@root a.txt 
some text 
@ </t>
<t tx="EKR.20040504083716">@language python

import leoGlobals as g
import shutil

testing = True

sourcedir=r"c:/prog/test/perfectImport"
targetdir=r"c:/prog/test/perfectImport/leo"
s1 = g.os_path_join(sourcedir,"leoAtFile.py")
t1 = g.os_path_join(targetdir,"leoAtFile.py")
files = [(s1,t1)]

@others

print ; print '-' * 20

sync(files) # push or pull, depending on date.
</t>
<t tx="EKR.20040504083716.39">def sync(files):
    
    """Do a pull or a push, depending on the date of the files."""
    
    none, push, pull = 'None', 'push', 'pull'
    mu = g.mulderUpdateAlgorithm()

    for sourcefilename, targetfilename in files:
        &lt;&lt; compute sourcetime and targettime &gt;&gt;
        &lt;&lt; compute operation &gt;&gt;
        if operation == push:
            if testing: print push, sourcefilename, targetfilename
            strippedLines = mu.removeSentinelsFromFile(sourcefilename)
            mu.write_if_changed(strippedLines,sourcefilename,targetfilename)
            mu.copy_time(sourcefilename,targetfilename)
        elif operation == pull:
            if testing: print pull, sourcefilename, targetfilename
            if sourcetime:
                mu.propagateDiffsToSentinelsFile(sourcefilename,targetfilename)
                mu.copy_time(targetfilename,sourcefilename)
            else:
                shutil.copy2(targetfilename,sourcefilename)</t>
<t tx="EKR.20040504083716.44"># This is some basic testing.

@ignore</t>
<t tx="EKR.20040504083716.45">@others</t>
<t tx="EKR.20040504083716.47">class sentinel_test(TestCase):
    @others</t>
<t tx="EKR.20040504083716.48">def setUp(self):
    self.prefix = ["#@+leo-ver=4\n",
"#@+node:@file sentinel.py\n",
"#@@language python\n"]
    self.postfix = ["#@-node:@file sentinel.py\n",
"#@-leo\n"]
</t>
<t tx="EKR.20040504083716.49">def setup_inputfile(self, input):
    classname = self.__class__.__name__
    self.input_filename = os.path.join('test/s_%s.txt' % classname)
    self.output_filename = os.path.join('test/d_%s.txt' % classname)
    outfile = file(self.input_filename, "w")
    for line in input:
        outfile.write(line)
    outfile.close()
    
    
 
</t>
<t tx="EKR.20040504083716.50">def setup_configfile(self):
    self.configfilename = "test/sentinel.cfg"
    outfile = file(self.configfilename, "w")
    outfile.write("[sentinel]\n")
    outfile.write("\ns1=%s\n" % self.input_filename)
    outfile.write("\nd1=%s\n" % self.output_filename)
    outfile.close()

</t>
<t tx="EKR.20040504083716.51"></t>
<t tx="EKR.20040504083716.52">class insert_test(sentinel_test):
    @others</t>
<t tx="EKR.20040504083716.53">def setUp(self):
    sentinel_test.setUp(self)
    self.setup_inputfile(self.prefix + 
["Proof of concept implementation of sentinel free Leo files.\n",
"We try to insert a line after here\n",
"This should be after the inserted line\n",
"This should be the last line in the file\n"]
 + self.postfix)

    # here are the same lines, without sentinels
    self.lines = ["Proof of concept implementation of sentinel free Leo files.\n",
     "We try to insert a line after here\n",
     "This should be after the inserted line\n",
     "This should be the last line in the file\n"]
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.54">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert one line in the sentinel free output.
    lines = self.lines
    lines[2:2] = ["This is an inserted line\n"]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.55"></t>
<t tx="EKR.20040504083716.56">class replace_test(sentinel_test):
    """
    Replace a single line.
    """
    @others</t>
<t tx="EKR.20040504083716.57">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
     "Proof of concept implementation of sentinel free Leo files.\n",
     "This line should be replaced\n",
     "This should be the last line in the file\n"]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.58">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert one line in the sentinel free output.
    lines = self.lines
    lines[2:2] = ["This is a replaced line\n"]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.59">class replace_test2(sentinel_test):
    """
    Replace two lines.
    """
    @others</t>
<t tx="EKR.20040504083716.60">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "Line 0\n",    #0
"   Line 1\n",    #1
"   Line 2.\n",   #2
"   Line 3.\n",   #3
"   Line 4\n",    #4
"\n", #5
" We have two subclasses:\n", #6
"   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #7
"   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #8
"\n", #9
" Line 10\n", #10
" Line 11\n" #11
]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.61">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert two lines in the sentinel free output.
    lines = self.lines
    lines[7:9] = ["   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #7
                      "   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.\n", #8
                     ]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.62">class replace_test3(sentinel_test):
    """
    Replace the lines of a whole node.
    """
    @others</t>
<t tx="EKR.20040504083716.63">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "#@+node:main\n",
    "node 1: line 1\n", # 1
    "node 1: line 2\n", # 2
    "#@-node:main\n",
    "#@-others\n",
    "node 2: line 3\n", # 3
    "node 2: line 4\n", # 4
    "#@-node:@file sentinel.py\n",
    ]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.64">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    filtered_lines = sentinel.push_filter_lines(self.lines)[0]
    assert file(self.output_filename).readlines() == filtered_lines
    
    # then insert one line in the sentinel free output.
    filtered_lines [2:4] = [   "These lines should be totally different\n",
    "and be replaced across sentinel blocks,\n",

                     ]
    outfile = file(self.output_filename, "w")
    for line in filtered_lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == filtered_lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.65">class replace_test4(sentinel_test):
    """
    Replace the lines of a whole node.
    """
    @others</t>
<t tx="EKR.20040504083716.66">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "#@+node:main\n",
    "node 1: line 1\n", # 1
    "node 1: line 2\n", # 2
    "#@-node:main\n",
    "#@-others\n",
    "node 2: line 3\n", # 3
    "node 2: line 4\n", # 4
    "#@-node:@file sentinel.py\n",
    ]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.67">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    filtered_lines = sentinel.push_filter_lines(self.lines)[0]
    assert file(self.output_filename).readlines() == filtered_lines
    
    # then insert one line in the sentinel free output.
    filtered_lines [1:3] = [   "These lines should be totally different\n",
    "and be replaced across sentinel blocks,\n",

                     ]
    outfile = file(self.output_filename, "w")
    for line in filtered_lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == filtered_lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.68">@doc
these are tests representing errors which I encountered during the development of the code.</t>
<t tx="EKR.20040504083716.69">class regression_test_1(sentinel_test):
    """
    Replace a single line.
    """
    @others</t>
<t tx="EKR.20040504083716.70">def setUp(self):
    self.lines = [
"#@+leo-ver=4\n",
"#@+node:@file driver.py\n",
"#@@language python\n",
"#@+others\n",
"#@+node:imports\n",
"# Analyse an IA64 assembly file:\n",
"#   1. Identify basic blocks.\n",
"#   2. Track the contents of registers symbolically.\n",
"import os, sys, cmp_globals\n",
"\n",
"#@-node:imports\n",
"#@+node:process_file\n",
"def process_file(infile, pyname_full, configfile, firststep, laststep):\n",
"   \n",
"      proc()\n",
"#@nonl\n",
"#@-node:process_file\n",
"#@-others\n",
"#@-node:@file driver.py\n",
"#@-leo\n"
]
    self.setup_inputfile(self.lines)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.71">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == sentinel.push_filter_lines(self.lines)[0]
        
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # Now check that the source has not been changed.
    assert file(self.input_filename).readlines() == self.lines   
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.72">if __name__ == '__main__':
    #fileName = os.path.join(os.getcwd(),"testing.ini")
    #config = ConfigParser.ConfigParser()
    #config.read(fileName)
    #main = "Main"
    #leodir = config.get(main, "leodir")
    #test_to_run = config.get(main, "test_to_run")
    test_to_run = 'all'
    
    if os.path.exists("test"):
        shutil.rmtree("test")
    os.mkdir("test")
    suite = TestSuite()
    if test_to_run == 'all':
        for testclass in (
            insert_test,
            replace_test,
            replace_test2,
            replace_test3,
            regression_test_1,         
        ):
            suite.addTest(testclass())
    else:
        suite.addTest(globals()[test_to_run]())
    testrunner = TextTestRunner()
    testrunner.run(suite)
 </t>
<t tx="EKR.20040504083716.73">@ignore</t>
<t tx="EKR.20040504083716.74">[Main]
test_to_run = all
# use all to run all tests.

cleanup = True
# Set to True if you want all files deleted.

leodir = C:/bwm/ftptoot/Cleo-4.1-beta-5</t>
<t tx="EKR.20040504083716.75"></t>
<t tx="EKR.20040504083716.76"></t>
<t tx="EKR.20040504083716.77"></t>
<t tx="EKR.20040504083716.78"></t>
<t tx="EKR.20040504153320">sourcetime = targettime = None

if g.os_path_exists(sourcefilename):
    sourcetime = g.os_path_getmtime(sourcefilename)

if g.os_path_exists(targetfilename):
    targettime = g.os_path_getmtime(targetfilename)</t>
<t tx="EKR.20040504153320.1">operation = None
if sourcetime:
    if targettime:
        if sourcetime &gt; targettime:
            operation = push
        elif sourcetime &lt; targettime:
            operation = pull
    else:
        operation = push
elif targettime:
    operation = pull</t>
<t tx="EKR.20040517074600.8">import leoGlobals as g
import leoTest

u = leoTest.testUtils()
nodes = 0 ; lines = 0
c = g.top()
c.clearAllVisited()
v = u.findNodeAnywhere(c,"Plugins &amp; scripts")
after = v.nodeAfterTree()
trace(v,after)
while v and v != after:
    if not v.t.isVisited():
        v.t.setVisited()
        nodes += 1
        lines += len(splitLines(v.bodyString()))
    v = v.threadNext()
    
pages = ((nodes * 10) + lines) / 50
print "nodes,lines,pages",nodes,lines,pages
g.es("nodes,lines,pages",nodes,lines,pages)</t>
<t tx="EKR.20040517074600.9"></t>
<t tx="EKR.20040517074600.10">import leoGlobals as g
config = g.app.config

font = config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        tag = "body")
        
print font

c = top() ; body = c.frame.body.bodyCtrl

print body

# body.configure(font=font)</t>
<t tx="EKR.20040517074600.11">import leoGlobals as g
import tkFont

@others

c = g.top()

# Body pane.
fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
print "body:",fn,name,size,slant,weight

if 0:

    # Log pane.
    fn = c.frame.log.getFontConfig()
    font = tkFont.Font(font=fn)
    name,size,slant,weight = getFontSettings(font)
    g.es("log:" + name + "," + `size` + "," + slant + "," + weight)
    
    # Tree pane.
    font = c.frame.tree.getFont()
    name,size,slant,weight = getFontSettings(font)
    g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="EKR.20040517074600.12">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="EKR.20040517074600.13">import leoGlobals as g

font = g.app.config.defaultFont

print font.cget("family"), font.cget("weight")</t>
<t tx="EKR.20040523112430"></t>
<t tx="EKR.20040523112430.1"></t>
<t tx="EKR.20040523112430.2"></t>
<t tx="EKR.20040523112430.3"></t>
<t tx="EKR.20040523112430.4"></t>
<t tx="EKR.20040523112430.5"></t>
<t tx="EKR.20040523112430.6"></t>
<t tx="EKR.20040523112430.7"></t>
<t tx="EKR.20040523112430.8"></t>
<t tx="EKR.20040524050419">line 1
@others
&lt;&lt; defined in grandchild &gt;&gt;
last line</t>
<t tx="EKR.20040524050419.1">Organizer line</t>
<t tx="EKR.20040524050419.2">grandChild line</t>
<t tx="EKR.20040525083635">@others</t>
<t tx="EKR.20040525083635.1"></t>
<t tx="EKR.20040526094831">import leoGlobals as g

def redoBletch(self):
    g.trace()
    
def undoBletch(self):
    g.trace()
    
c = g.top() ; u = c.undoer
p = c.currentPosition()

if 0:
    # bad functions
    u.registerUndoHandlers("Bletch","abc","xyz")
else:
    u.registerUndoHandlers("Bletch",undoBletch,redoBletch)
    
# "Execute" the Bletch command :-)  The Edit command should contain "Undo Bletch"
u.setUndoParams("Bletch",p)

# Selecting "Undo Bletch" will enable "Redo Bletch", etc.</t>
<t tx="EKR.20040526193608">import leoGlobals as g
import binascii
import pickle

d = { "a":True }

print '-' * 40

s = pickle.dumps(d,bin=True)
s2 = binascii.hexlify(s)
print `s`,s2

s3 = binascii.unhexlify(s2)
d2 = cPickle.loads(s3)

print `d2`
print d == d2, d is d2</t>
<t tx="EKR.20040526200017">import leoGlobals as g

c = g.top() ; p = c.currentPosition()


d = { "a":True }

if 1:
    # Warning: executing this in the a2 code base will cause any save operation to fail.
    p.v.unknownAttributes = { "myPlugin" : d }
    
print repr(p.v.unknownAttributes)</t>
<t tx="EKR.20040527072047"></t>
<t tx="EKR.20040527072047.1"></t>
<t tx="EKR.20040527073459"></t>
<t tx="EKR.20040527074524"></t>
<t tx="EKR.20040527074524.1"></t>
<t tx="EKR.20040527074524.2"></t>
<t tx="EKR.20040527083449.1">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
print "duplicate tests pass"</t>
<t tx="EKR.20040527083449.2">if 0:
    for v in current.vnodes_iter(): print v
    for v in current.unique_vnodes_iter(): print v

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print v
    for t in root.tnodes_iter(): print t

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print v
    for t in child.tnodes_iter(): print t</t>
<t tx="EKR.20040527145121">temp_v = self.temp_v ; after = self.after

# Compare the computed result to the reference result.
new_text = temp_v.bodyString().rstrip()
ref_text = after.bodyString().rstrip()

if new_text != ref_text:
    print ; print "test failed", commandName
    g.trace("new",new_text)
    g.trace("ref",ref_text)
    
assert(new_text == ref_text)

# Compare subtrees.

assert(temp_v.numberOfChildren() == after.numberOfChildren())

ref_child = after.firstChild()
new_child = temp_v.firstChild()

while new_child:
    new_text = new_child.bodyString().rstrip()
    ref_text = ref_child.bodyString().rstrip()

    if new_text != ref_text:
        print ; print "test failed", commandName
        g.trace("new",new_text)
        g.trace("ref",ref_text)
    
    assert(new_text == ref_text)
    
    new_child = new_child.next()
    ref_child = ref_child.next()</t>
<t tx="EKR.20040527154402">line 1

&lt;&lt; sec &gt;&gt;
sec line 1
sec line 2

last line</t>
<t tx="EKR.20040528130659">d</t>
<t tx="EKR.20040528152529">import leoNodes
import leoGlobals as g

c = g.top()
current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print v
    for v in vList2: print v

print len(allList),len(vList1),len(vList2)

&lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;

&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="EKR.20040529092739">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

if 0: # all nodes
    for v in c.all_vnodes_iter(): print v
    for t in c.all_tnodes_iter(): print t
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print v
    for t in c.all_unique_tnodes_iter(): print t</t>
<t tx="EKR.20040529093047">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

print "coverage tests pass"</t>
<t tx="EKR.20040529093047.1">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
print "duplicate tests pass"</t>
<t tx="EKR.20040529104307">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    print "consistency tests pass"

except AssertionError:
    print tag
    print "list1"
    for v in list1: print v
    print "list2"
    for v in list2: print v</t>
<t tx="EKR.20040529105640"></t>
<t tx="EKR.20040531110157">@ignore</t>
<t tx="EKR.20040602101648">import leoGlobals as g
import leoPlugins

def onEnd (tag,keys):
    print "onEnd",tag,keys
    
count = 0
    
def onIdle (tag,keys):
    global count ; count += 1
    if count % 10 == 0:
        print "onIdle",count,keys.get("c")

leoPlugins.registerHandler("end1", onEnd)
print "onEnd registered as end1 hook"

leoPlugins.registerHandler("idle", onIdle)
print "onIdle registered as idle hook"</t>
<t tx="EKR.20040603064545">import leoGlobals as g

c = g.top()

for p in c.all_positions_iter():
    print p.v.t.fileIndex</t>
<t tx="EKR.20040603103118">@language html

b = "cd"
d
</t>
<t tx="EKR.20040603143325">try:
    assert(0)
except (AttributeError, AssertionError):
    print "caught"
</t>
<t tx="EKR.20040603174633">import leoGlobals as g
c = g.top()
print c.frame.bodyCtrl.focus()</t>
<t tx="EKR.20040604082113">@tabwidth -4

    
    a   b   c
a   b   c   d
aa  b   c   d
aaa b   c   d
end</t>
<t tx="EKR.20040604143253"></t>
<t tx="EKR.20040604170105">import leoGlobals as g
import os

c = g.top()

print os.getcwd()
name = g.os_path_join("test","removeSentTest.txt")
c.importCommands.removeSentinelsCommand(name)</t>
<t tx="EKR.20040605200750">string.join

__add__

'a'.__add__


def test(a,b): pass

v.copyTree(self,root)</t>
<t tx="EKR.20040606204316"></t>
<t tx="EKR.20040608092841">@tabwidth -4

    a
    b</t>
<t tx="EKR.20040608095146">@language python
@tabwidth -4</t>
<t tx="EKR.20040608095146.1">@ignore
@language html

&lt;!--- Get all records from the database that match this users credentials ---&gt;
&lt;cfquery name="qLoginVerify" datasource="xxxx"&gt;
SELECT user_name, user_pass, course_dir
FROM login
WHERE user_name = '#user_name#'
AND user_pass = '#user_pass#'
AND course_dir = '#course_dir#'
&lt;/cfquery&gt;

&lt;cfif qLoginVerify.RecordCount&gt;
&lt;!--- This user has logged in correctly; 
change the value of the session.allowin value ---&gt;
&lt;cfset session.allowin = session.directoryshort&gt;
&lt;/cfif&gt;

&lt;!--- now redirect to "index.cfm", which will go to login if problem ---&gt;

&lt;cflocation url="#session.location#"&gt;
</t>
<t tx="EKR.20040610092248">@killcolor

Note: Previously, one could crash Leo by pasting a large text into a headline.  Leo now truncates that text, and furthermore Leo no longer makes all headline text into one gigantic line.  Therefore, we don't have to test Tk's ability to handle super-long lines.

The test:  Copy the following and paste it into a headline.  Leo should give 2 truncation messages:

- Truncating headline to one line.
- Truncating headline to 250 characters.

About a year ago I found the website at www.literateprogamming.com and was immediately convinced that the basic idea of Literate Programming is an important breakthrough. At the time I was working on a contract trying to decipher a true masterpiece of over-engineering, and if at any time during the construction of this masterpiece the perpetrators had been required to explain themselves in English, my client would have saved millions of dollars.

I never did try CWEB or NOWEB though, because on the literate programming site I read about a tool named “Leo” that combined outlines with Literate Programming techniques. Since I’ve always found outlining tools very useful I downloaded and tried this. I found that using this tool completely changed my programming practice and brought out all of the power inherent in the original Literate Programming idea as I understood it.</t>
<t tx="EKR.20040610131858"></t>
<t tx="EKR.20040610131858.1">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

print p.v.t.fileIndex,p.v.t</t>
<t tx="EKR.20040610132739">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="1" tnodes="1" max_tnode_index="1"/&gt;
&lt;vnodes&gt;
&lt;v t="EKR.20040610131858.1" a="TV"&gt;&lt;vh&gt;a&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="EKR.20040610131858.1"&gt;import leoGlobals as g

c = g.top() ; p = c.currentPosition()

print p.v.t.fileIndex&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="EKR.20040610143643"></t>
<t tx="EKR.20040610192622">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

import compiler

next = p.next()
s = next.bodyString()

try:
    val = compiler.parse(s)
    # print val
    g.es("Parsed OK",color="blue")
except SyntaxError:
    g.es("Syntax error",color="blue")</t>
<t tx="EKR.20040610192622.1">import string

string.join(a,b]
</t>
<t tx="EKR.20040610194209">import leoGlobals as g
import tabnanny

@others

# print '-' * 20

c = g.top()
p = c.currentPosition()
next = p.next()
s = next.bodyString()
headline = next.headString()

checkString(s,headline)</t>
<t tx="EKR.20040610194209.1">    a = 5 # 4 spaces
    b = 6 # a tab.</t>
<t tx="EKR.20040610195543">def checkString (s,headline):

    """Check indentation using tabnanny.process_tokens."""

    # This code is based on tabnanny.check.
    
    import tokenize

    try:
        readline = g.readLinesGenerator(s).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError, msg:

        g.es("Token error in %s" % headline,color="red")
        g.es(str(msg))
        return

    except tabnanny.NannyNag, nag:

        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()

        g.es("Indentation error in %s, line %d" % (headline, badline),color="red")
        g.es(message)
        g.es("offending line:\n%s" % repr(str(line))[1:-1])
        return
        
    g.es("Indentation is good",color="blue")
</t>
<t tx="EKR.20040610195543.1">@ignore
@language python
&lt;&lt; tabnanny declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="EKR.20040610195543.2">#! /usr/bin/env python

"""The Tab Nanny despises ambiguous indentation.  She knows no mercy.

tabnanny -- Detection of ambiguous indentation

For the time being this module is intended to be called as a script.
However it is possible to import it into an IDE and use the function
check() described below.

Warning: The API provided by this module is likely to change in future
releases; such changes may not be backward compatible.
"""

# Released to the public domain, by Tim Peters, 15 April 1998.

# XXX Note: this is now a standard library module.
# XXX The API needs to undergo changes however; the current code is too
# XXX script-like.  This will be addressed later.

__version__ = "6"

import os
import sys
import getopt
import tokenize
if not hasattr(tokenize, 'NL'):
    raise ValueError("tokenize.NL doesn't exist -- tokenize module too old")

__all__ = ["check", "NannyNag", "process_tokens"]

verbose = 0
filename_only = 0</t>
<t tx="EKR.20040610195543.3">def errprint(*args):
    sep = ""
    for arg in args:
        sys.stderr.write(sep + str(arg))
        sep = " "
    sys.stderr.write("\n")
</t>
<t tx="EKR.20040610195543.4">def main():
    global verbose, filename_only
    try:
        opts, args = getopt.getopt(sys.argv[1:], "qv")
    except getopt.error, msg:
        errprint(msg)
        return
    for o, a in opts:
        if o == '-q':
            filename_only = filename_only + 1
        if o == '-v':
            verbose = verbose + 1
    if not args:
        errprint("Usage:", sys.argv[0], "[-v] file_or_directory ...")
        return
    for arg in args:
        check(arg)</t>
<t tx="EKR.20040610195543.5">
class NannyNag(Exception):
    """
    Raised by tokeneater() if detecting an ambiguous indent.
    Captured and handled in check().
    """
    @others
</t>
<t tx="EKR.20040610195543.6">def __init__(self, lineno, msg, line):
    self.lineno, self.msg, self.line = lineno, msg, line
</t>
<t tx="EKR.20040610195543.7">def get_lineno(self):
    return self.lineno
</t>
<t tx="EKR.20040610195543.8">def get_msg(self):
    return self.msg
</t>
<t tx="EKR.20040610195543.9">def get_line(self):
    return self.line
</t>
<t tx="EKR.20040610195543.10">def check(file):
    """check(file_or_dir)

    If file_or_dir is a directory and not a symbolic link, then recursively
    descend the directory tree named by file_or_dir, checking all .py files
    along the way. If file_or_dir is an ordinary Python source file, it is
    checked for whitespace related problems. The diagnostic messages are
    written to standard output using the print statement.
    """

    if os.path.isdir(file) and not os.path.islink(file):
        if verbose:
            print "%s: listing directory" % `file`
        names = os.listdir(file)
        for name in names:
            fullname = os.path.join(file, name)
            if (os.path.isdir(fullname) and
                not os.path.islink(fullname) or
                os.path.normcase(name[-3:]) == ".py"):
                check(fullname)
        return

    try:
        f = open(file)
    except IOError, msg:
        errprint("%s: I/O Error: %s" % (`file`, str(msg)))
        return

    if verbose &gt; 1:
        print "checking", `file`, "..."

    try:
        process_tokens(tokenize.generate_tokens(f.readline))

    except tokenize.TokenError, msg:
        errprint("%s: Token Error: %s" % (`file`, str(msg)))
        return

    except NannyNag, nag:
        badline = nag.get_lineno()
        line = nag.get_line()
        if verbose:
            print "%s: *** Line %d: trouble in tab city! ***" % (
                `file`, badline)
            print "offending line:", `line`
            print nag.get_msg()
        else:
            if ' ' in file: file = '"' + file + '"'
            if filename_only: print file
            else: print file, badline, `line`
        return

    if verbose:
        print "%s: Clean bill of health." % `file`
</t>
<t tx="EKR.20040610195543.11">
class Whitespace:
    &lt;&lt; class Whitespace declarations &gt;&gt;
    @others
</t>
<t tx="EKR.20040610195543.12"># the characters used for space and tab
S, T = ' \t'

# members:
#   raw
#       the original string
#   n
#       the number of leading whitespace characters in raw
#   nt
#       the number of tabs in raw[:n]
#   norm
#       the normal form as a pair (count, trailing), where:
#       count
#           a tuple such that raw[:n] contains count[i]
#           instances of S * i + T
#       trailing
#           the number of trailing spaces in raw[:n]
#       It's A Theorem that m.indent_level(t) ==
#       n.indent_level(t) for all t &gt;= 1 iff m.norm == n.norm.
#   is_simple
#       True iff raw[:n] is of the form (T*)(S*)

</t>
<t tx="EKR.20040610195543.13">def __init__(self, ws):
    self.raw  = ws
    S, T = Whitespace.S, Whitespace.T
    count = []
    b = n = nt = 0
    for ch in self.raw:
        if ch == S:
            n = n + 1
            b = b + 1
        elif ch == T:
            n = n + 1
            nt = nt + 1
            if b &gt;= len(count):
                count = count + [0] * (b - len(count) + 1)
            count[b] = count[b] + 1
            b = 0
        else:
            break
    self.n    = n
    self.nt   = nt
    self.norm = tuple(count), b
    self.is_simple = len(count) &lt;= 1
</t>
<t tx="EKR.20040610195543.14"># return length of longest contiguous run of spaces (whether or not
# preceding a tab)
def longest_run_of_spaces(self):
    count, trailing = self.norm
    return max(len(count)-1, trailing)
</t>
<t tx="EKR.20040610195543.15">def indent_level(self, tabsize):
    # count, il = self.norm
    # for i in range(len(count)):
    #    if count[i]:
    #        il = il + (i/tabsize + 1)*tabsize * count[i]
    # return il

    # quicker:
    # il = trailing + sum (i/ts + 1)*ts*count[i] =
    # trailing + ts * sum (i/ts + 1)*count[i] =
    # trailing + ts * sum i/ts*count[i] + count[i] =
    # trailing + ts * [(sum i/ts*count[i]) + (sum count[i])] =
    # trailing + ts * [(sum i/ts*count[i]) + num_tabs]
    # and note that i/ts*count[i] is 0 when i &lt; ts

    count, trailing = self.norm
    il = 0
    for i in range(tabsize, len(count)):
        il = il + i/tabsize * count[i]
    return trailing + tabsize * (il + self.nt)
</t>
<t tx="EKR.20040610195543.16"># return True iff self.indent_level(t) == other.indent_level(t)
# for all t &gt;= 1
def equal(self, other):
    return self.norm == other.norm
</t>
<t tx="EKR.20040610195543.17"># return a list of tuples (ts, i1, i2) such that
# i1 == self.indent_level(ts) != other.indent_level(ts) == i2.
# Intended to be used after not self.equal(other) is known, in which
# case it will return at least one witnessing tab size.
def not_equal_witness(self, other):
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    a = []
    for ts in range(1, n+1):
        if self.indent_level(ts) != other.indent_level(ts):
            a.append( (ts,
                       self.indent_level(ts),
                       other.indent_level(ts)) )
    return a
</t>
<t tx="EKR.20040610195543.18"># Return True iff self.indent_level(t) &lt; other.indent_level(t)
# for all t &gt;= 1.
# The algorithm is due to Vincent Broman.
# Easy to prove it's correct.
# XXXpost that.
# Trivial to prove n is sharp (consider T vs ST).
# Unknown whether there's a faster general way.  I suspected so at
# first, but no longer.
# For the special (but common!) case where M and N are both of the
# form (T*)(S*), M.less(N) iff M.len() &lt; N.len() and
# M.num_tabs() &lt;= N.num_tabs(). Proof is easy but kinda long-winded.
# XXXwrite that up.
# Note that M is of the form (T*)(S*) iff len(M.norm[0]) &lt;= 1.
def less(self, other):
    if self.n &gt;= other.n:
        return False
    if self.is_simple and other.is_simple:
        return self.nt &lt;= other.nt
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    # the self.n &gt;= other.n test already did it for ts=1
    for ts in range(2, n+1):
        if self.indent_level(ts) &gt;= other.indent_level(ts):
            return False
    return True
</t>
<t tx="EKR.20040610195543.19"># return a list of tuples (ts, i1, i2) such that
# i1 == self.indent_level(ts) &gt;= other.indent_level(ts) == i2.
# Intended to be used after not self.less(other) is known, in which
# case it will return at least one witnessing tab size.
def not_less_witness(self, other):
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    a = []
    for ts in range(1, n+1):
        if self.indent_level(ts) &gt;= other.indent_level(ts):
            a.append( (ts,
                       self.indent_level(ts),
                       other.indent_level(ts)) )
    return a
</t>
<t tx="EKR.20040610195543.20">def format_witnesses(w):
    firsts = map(lambda tup: str(tup[0]), w)
    prefix = "at tab size"
    if len(w) &gt; 1:
        prefix = prefix + "s"
    return prefix + " " + ', '.join(firsts)
</t>
<t tx="EKR.20040610195543.21">def process_tokens(tokens):
    INDENT = tokenize.INDENT
    DEDENT = tokenize.DEDENT
    NEWLINE = tokenize.NEWLINE
    JUNK = tokenize.COMMENT, tokenize.NL
    indents = [Whitespace("")]
    check_equal = 0

    for (type, token, start, end, line) in tokens:
        if type == NEWLINE:
            # a program statement, or ENDMARKER, will eventually follow,
            # after some (possibly empty) run of tokens of the form
            #     (NL | COMMENT)* (INDENT | DEDENT+)?
            # If an INDENT appears, setting check_equal is wrong, and will
            # be undone when we see the INDENT.
            check_equal = 1

        elif type == INDENT:
            check_equal = 0
            thisguy = Whitespace(token)
            if not indents[-1].less(thisguy):
                witness = indents[-1].not_less_witness(thisguy)
                msg = "indent not greater e.g. " + format_witnesses(witness)
                raise NannyNag(start[0], msg, line)
            indents.append(thisguy)

        elif type == DEDENT:
            # there's nothing we need to check here!  what's important is
            # that when the run of DEDENTs ends, the indentation of the
            # program statement (or ENDMARKER) that triggered the run is
            # equal to what's left at the top of the indents stack

            # Ouch!  This assert triggers if the last line of the source
            # is indented *and* lacks a newline -- then DEDENTs pop out
            # of thin air.
            # assert check_equal  # else no earlier NEWLINE, or an earlier INDENT
            check_equal = 1

            del indents[-1]

        elif check_equal and type not in JUNK:
            # this is the first "real token" following a NEWLINE, so it
            # must be the first token of the next program statement, or an
            # ENDMARKER; the "line" argument exposes the leading whitespace
            # for this statement; in the case of ENDMARKER, line is an empty
            # string, so will properly match the empty string with which the
            # "indents" stack was seeded
            check_equal = 0
            thisguy = Whitespace(line)
            if not indents[-1].equal(thisguy):
                witness = indents[-1].not_equal_witness(thisguy)
                msg = "indent not equal e.g. " + format_witnesses(witness)
                raise NannyNag(start[0], msg, line)
</t>
<t tx="EKR.20040610201236">@

To do:
    
- Specify which nodes to check.
- Check only Python code.
- use g.readLinesClass or similar code in existing Python module.</t>
<t tx="EKR.20040610201941">@

To do:
    
- Specify which nodes to check.
- Check only Python code.
- use g.readLinesClass or similar code in existing Python module.</t>
<t tx="EKR.20040611083703">from __future__ import generators

import leoGlobals as g

@others

lines = "a\nb\nc\nd"

if 1: # Both work
    readline = g.readLinesGenerator(lines).next
else:
    readline = g.readLinesClass(lines).next

print '-' * 20

if 1: # Both work
    for s in g.readLinesGenerator(lines):
        print s,
else:
    while 1:
        s = readline()
        if s: print s,
        else: break
    
print ; print '-' * 20</t>
<t tx="EKR.20040612095237">@language python
@tabwidth -4</t>
<t tx="EKR.20040612150543"># Test
@others
# Last</t>
<t tx="EKR.20040612215136">a = 1
print "hello"
c = b
</t>
<t tx="EKR.20040613162717">import leoGlobals as g

path = r"c:\prog\leoScripts(before).txt"
path = r"c:\prog\leoScripts(after).txt"

print g.top().currentPosition()

try:
    f = open(path,"rb")
    s = f.read()
    f.close()
    
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
        
    g.es("cr %d, nl %d %s" % (cr,nl,path))

except IOError:
    print "can not open",path</t>
<t tx="EKR.20040615070332"># "LPT1:", "PRN:" and "PRN" all freeze

s = 'stuff\n'
port = 'USB002'

try:
    f = file(port,'w')
    f.write(s)
    f.flush()
    f.close()
    print "done"
except IOError:
    print "Can not open",port</t>
<t tx="EKR.20040615144735"></t>
<t tx="EKR.20040615144810">d</t>
<t tx="EKR.20040619133116"></t>
<t tx="EKR.20040619133501">
import leoGlobals as g

import leoColor
import leoCommands
import leoFrame
import leoGui
import leoNodes
import leoTkinterGui

import glob
import os
import sys
import unittest</t>
<t tx="EKR.20040619134504">import unittest
import leoTest
import leoGlobals as g
reload(leoTest)

# We need real nodes to pass to the tests.
suite = leoTest.makeLeoFilesSuite("atFileTests")
unittest.TextTestRunner().run(suite)</t>
<t tx="EKR.20040621080031">class atFileTestCase(unittest.TestCase):
    
    """Data-driven unit tests to test .leo files."""
    
    @others</t>
<t tx="EKR.20040621080031.3">def __init__ (self,c,atatNode,outputNode):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.atatNode = atatNode.copy()
    self.outputNode = outputNode.copy()
    self.type = None</t>
<t tx="EKR.20040621080031.4">def runTest(self):
    
    """Run a test of @file, @thin, etc."""

    at = self.c.atFileCommands
    root = self.atatNode
    
    thinFile = self.type == "thin"
    nosentinels = self.type in ("asis","nosent")
    
    assert (self.type in ("file","thin","nosent","noref","asis"))
    
    if self.type == "asis":
        assert 0, "asis not ready yet"
        pass # Not ready yet.
        at.asisWrite(p,toString=toString)
        result = "asis tests not ready yet"
    else:
        at.write(root,thinFile=thinFile,nosentinels=nosentinels,toString=True)
        result = g.toUnicode(at.new_df.stringOutput,"ascii")

    expected = self.outputNode.bodyString()
    
    if result == expected:
        if 0:
            print len(result),len(expected)
            print "result file == expected file"
    else:
        print ; print '-' * 20
        print "result..."
        for line in g.splitLines(result):
            print "%3d" % len(line),repr(line)
        print '-' * 20
        print "expected..."
        for line in g.splitLines(expected):
            print "%3d" % len(line),repr(line)
        print '-' * 20
    
    assert result==expected, "expected does not match result."</t>
<t tx="EKR.20040621080031.5">def setUp(self):
    
    h = self.atatNode.headString().strip().lower()
    assert(g.match(h,0,"@@"))

    self.type = None ;  i = 2
    for type in ("file","thin","nosent","noref","asis"):
        if g.match(h,i,type):
            self.type = type
            break</t>
<t tx="EKR.20040621095514"></t>
<t tx="EKR.20040621095514.1">def findSubnodesOf (self,headline):
    
    u = self ; c = g.top() ; v = c.currentVnode()
    
    root = u.findRootNode(v)
    parent = u.findNodeInTree(root,headline)
    
    v = parent.firstChild()
    vList = []
    after = parent.nodeAfterTree()
    while v and v != after:
        vList.append(v)
        v = v.threadNext()

    return vList</t>
<t tx="EKR.20040621095514.2">def findNodeInTree(self,p,headline):

    """Search for a node in p's tree matching the given headline."""
    
    c = p.c
    for p in p.subtree_iter():
        if p.headString().strip().lower() == headline.strip().lower():
            return p
    return c.nullPosition()</t>
<t tx="EKR.20040621095514.3">def findNodeAnywhere(self,c,headline):
    
    for p in c.allNodes_iter():
        if p.headString().strip() == headline.strip():
            return p.copy()
    return c.nullPosition()</t>
<t tx="EKR.20040621095514.4">def findUnitTestNode (self,unitTestName):
    
    c = g.top() ; root = c.rootPosition()
    
    for p in root.self_and_siblings_iter():
        h = p.headString().lower()
        if g.match(h,0,"unit testing"):
            break

    if p:
        for p in p.children_iter():
            h = p.headString()
            if g.match(h,0,"Unit test scripts"):
                break
                
    if p:
        for p in p.children_iter():
            h = p.headString()
            if g.match(h,0,unitTestName):
                return p

    return c.nullPosition()</t>
<t tx="EKR.20040621100553">Line 1

@last last line 1: no newline</t>
<t tx="EKR.20040621101000">def numberOfClonesInOutline (self):
    
    """Returns the number of cloned nodes in an outline"""

    c = g.top() ; n = 0
    for p in c.allNodes_iter():
        if v.isCloned():
            n += 1
    return n</t>
<t tx="EKR.20040621155439">def compareDerivedFiles (self,result,expected):
    
    lines1 = g.splitLines(result)
    lines2 = g.splitLines(expected)
    
    kinds = ("@file","@thin","@nosent","@noref","@asis")
    
    if len(lines1) != len(lines2):
        print "length mismatch"
        return False
        
    for i in xrange(len(lines1)):
        line1 = lines1[i]
        line2 = lines2[i]
        if line1 == line2:
            continue
        for kind in kinds:
            found = False
            if (
                line1.find("node:@%s" % kind) &gt; -1 and
                line2.find("node:%s" % kind) &gt; -1
            ):
                found = True ; break
        if found: continue
        else: return False

    return True</t>
<t tx="EKR.20040622074004"></t>
<t tx="EKR.20040622074004.1"></t>
<t tx="EKR.20040622074004.2">node b, line 1 (changed 6)</t>
<t tx="EKR.20040622074004.3"></t>
<t tx="EKR.20040623200709.17">@

For each @@thin, @@file, @noref, @nosent, @asis node found under test_xxx, do the following:
    - Simulate the write to a file.
    - Compare the results with the contents of the output node.
@c

def makeAtFileSuite(testParentHeadline,unused=None):
    
    """Create a .leo file test for every descendant of testParentHeadline.."""
    
    u = testUtils() ; c = g.top() ; current = c.currentPosition()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    p = u.findUnitTestNode("atFileTests")
    for child in p.children_iter():
        h = child.headString().strip()
        if g.match(h,0,"test"):
            output = u.findNodeInTree(child,"output")
            assert(output)
            for child2 in child.children_iter():
                h2 = child2.headString().strip()
                if g.match(h2,0,"@@"):
                    test = atFileTestCase(c,child2,output)
                    suite.addTest(test)
    return suite
</t>
<t tx="EKR.20040623200709.20">def compareDerivedFiles (self,result,expected):
    
    lines1 = g.splitLines(result)
    lines2 = g.splitLines(expected)
    
    kinds = ("@file","@thin","@nosent","@noref","@asis")
    
    if len(lines1) != len(lines2):
        print "length mismatch"
        return False
        
    for i in xrange(len(lines1)):
        line1 = lines1[i]
        line2 = lines2[i]
        if line1 == line2:
            continue
        for kind in kinds:
            found = False
            if (
                line1.find("node:@%s" % kind) &gt; -1 and
                line2.find("node:%s" % kind) &gt; -1
            ):
                found = True ; break
        if found: continue
        else: return False

    return True</t>
<t tx="EKR.20040623201302"></t>
<t tx="EKR.20040623201322.4"></t>
<t tx="EKR.20040623201322.7"></t>
<t tx="EKR.20040623201322.10"></t>
<t tx="EKR.20040623201322.13"></t>
<t tx="EKR.20040623201322.14">line 1
line 2 no newline</t>
<t tx="EKR.20040623201322.15">line 1
line 2 no newline</t>
<t tx="EKR.20040623201322.16"></t>
<t tx="EKR.20040623201322.17">@color
last line
</t>
<t tx="EKR.20040623201322.18">last line
</t>
<t tx="EKR.20040623202054.1"></t>
<t tx="EKR.20040623213443"></t>
<t tx="EKR.20040624085716">test</t>
<t tx="EKR.20040624103339.1"></t>
<t tx="EKR.20040624103339.2">Line 1

@last last line 1: no newline</t>
<t tx="EKR.20040624103339.3">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@nonl
#@-node:@@file
#@-leo
last line 1: no newline</t>
<t tx="EKR.20040624111917">Line 1

@last last line 1: newline
</t>
<t tx="EKR.20040624111917.1">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: newline
</t>
<t tx="EKR.20040624112329"></t>
<t tx="EKR.20040624112329.1">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="EKR.20040624112329.2">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="EKR.20040624112329.3">Line 1

@last last line 1: no newline</t>
<t tx="EKR.20040624112329.4">#@+leo-ver=4-thin
#@+node:EKR.20040624112329.3:@@thin
Line 1

#@@last
#@nonl
#@-node:EKR.20040624112329.3:@@thin
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040126105605"></t>
<t tx="ekr.20040126105605.2"></t>
<t tx="ekr.20040126105605.3"></t>
<t tx="ekr.20040301191933"></t>
<t tx="ekr.20040301191933.1"></t>
<t tx="ekr.20040301191933.2"></t>
<t tx="ekr.20040302091705">import leoGlobals as g

class position:
    def __init__(self):
        self.v = "a"
    def move(self):
        self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040302092753"></t>
<t tx="ekr.20040302092753.1"></t>
<t tx="ekr.20040302092753.2"></t>
<t tx="ekr.20040302092753.3"></t>
<t tx="ekr.20040302092753.4"></t>
<t tx="ekr.20040303062846.1">@

- Have log classes increment a count.
    Can be used to ensure that messages did or did not occcur.

- Have the nullGui create a nullUndoer by default
    But allow the possibility of leaving the full undoer in place.</t>
<t tx="ekr.20040303062846.2">"""

Classes used for Leo's unit testing.

Run the unit tests in test.leo using the Execute Script command.

"""

@language python
@tabwidth -4

&lt;&lt; to do &gt;&gt;
&lt;&lt; leoTest imports &gt;&gt;

@others</t>
<t tx="ekr.20040303062846.3">class testUtils:
    
    """Common utility routines used by unit tests."""

    @others</t>
<t tx="ekr.20040303062846.4">def compareOutlines (self,root1,root2):
    
    """Compares two outlines, making sure that their topologies,
    content and join lists are equivent"""
    
    v1,v2 = root1,root2
    after1 = v1.nodeAfterTree()
    after2 = v2.nodeAfterTree()
    v1 = v1.firstChild()
    v2 = v2.firstChild()
    ok = True
    while v2 and v1 != after1 and v2 != after2:
        ok = (
            v1.numberOfChildren() == v2.numberOfChildren() and
            v1.headString() == v2.headString() and
            v1.bodyString() == v2.bodyString() and
            v1.isCloned()   == v2.isCloned()
        )
        if not ok: break
        v1 = v1.threadNext()
        v2 = v2.threadNext()

    ok = ok and ((not v1 and not v2) or (v1 == after1 and v2 == after2))
    if not ok:
        g.trace(v1,v2)
    return ok</t>
<t tx="ekr.20040303062846.5">def findChildrenOf (self,headline):
    
    u = self ; c = g.top() ; v = c.currentPosition()
    
    root = u.findRootNode(v)
    parent = u.findNodeInTree(root,headline)
    
    v = parent.firstChild()
    vList = []
    while v:
        vList.append(v)
        v = v.next()
    return vList</t>
<t tx="ekr.20040303062846.6">def findRootNode (self,p):

    """Return the root of p's tree."""

    while p and p.hasParent():
        p.moveToParent()
    return p</t>
<t tx="ekr.20040303062846.7">def numberOfNodesInOutline (self):
    
    """Returns the total number of nodes in an outline"""
    
    c = g.top() ; n = 0
    for p in c.allNodes_iter():
        n += 1
    return n
    
</t>
<t tx="ekr.20040303062846.8">def replaceOutline (self,c,outline1,outline2):
    
    u = self
    
    """Replace outline1 by a copy of outline 2 if not equal."""
    
    g.trace()
    
    copy = outline2.copyTreeWithNewTnodes()
    copy.linkAfter(outline1)
    outline1.doDelete(newVnode=copy)</t>
<t tx="ekr.20040303062846.10">def fail ():
    
    """Mark a unit test as having failed."""
    
    g.app.unitTestDict["fail"] = g.callerName(2)</t>
<t tx="ekr.20040303062846.11"></t>
<t tx="ekr.20040303062846.12">def makeColorSuite(testParentHeadline,tempHeadline):
    
    """Create a colorizer test for every descendant of testParentHeadline.."""
    
    u = testUtils() ; c = g.top() ; v = c.currentVnode()
    root = u.findRootNode(v)
    temp_v = u.findNodeInTree(root,tempHeadline)
    vList = u.findSubnodesOf(testParentHeadline)
    
    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    for v in vList:
        test = colorTestCase(c,v,temp_v)
        suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040303062846.13">class colorTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's colorizer."""
    
    @others</t>
<t tx="ekr.20040303062846.14">def __init__ (self,c,v,temp_v):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.v = v
    self.temp_v = temp_v
    
    self.old_v = c.currentVnode()</t>
<t tx="ekr.20040303062846.15">def color (self):
    
    c = self.c
    val = c.frame.body.colorizer.colorize(self.temp_v,incremental=False)
    assert(val=="ok")</t>
<t tx="ekr.20040303062846.16">def setUp(self,*args,**keys):

    # g.trace(args,keys)

    # Initialize the text in the temp node.
    text = self.v.bodyString()
    self.c.selectVnode(self.temp_v)
    self.temp_v.setTnodeText(text,g.app.tkEncoding)
    self.c.frame.body.setSelectionAreas(None,text,None)</t>
<t tx="ekr.20040303062846.17">def tearDown (self):
    
    self.temp_v.setTnodeText("",g.app.tkEncoding)
    self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.18">def runTest(self):

    self.color()</t>
<t tx="ekr.20040303062846.19"></t>
<t tx="ekr.20040303062846.20">def makeEditBodySuite(testParentHeadline,tempHeadline):
    
    """Create an Edit Body test for every descendant of testParentHeadline.."""
    
    u = testUtils() ; c = g.top() ; v = c.currentVnode()
    root = u.findRootNode(v)
    temp_v = u.findNodeInTree(root,tempHeadline)
    vList = u.findChildrenOf(testParentHeadline)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    for v in vList:
        before = u.findNodeInTree(v,"before")
        after  = u.findNodeInTree(v,"after")
        sel    = u.findNodeInTree(v,"selection")
        ins    = u.findNodeInTree(v,"insert")
        if before and after:
            test = editBodyTestCase(c,v,before,after,sel,ins,temp_v)
            suite.addTest(test)
        else:
            print 'missing "before" or "after" for', v.headString()

    return suite
</t>
<t tx="ekr.20040303062846.21">class editBodyTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's edit body commands."""
    
    @others</t>
<t tx="ekr.20040303062846.22">def __init__ (self,c,parent,before,after,sel,ins,temp_v):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.parent = parent
    self.before = before
    self.after  = after
    self.sel    = sel # Two lines giving the selection range in tk coordinates.
    self.ins    = ins # One line giveing the insert point in tk coordinate.
    self.temp_v = temp_v
    
    self.old_v = c.currentVnode()
    
    self.wasChanged = c.changed
    
    self.u = testUtils()</t>
<t tx="ekr.20040303062846.23">def editBody (self):
    
    c = self.c ; u = self.u

    # Compute the result in temp_v.bodyString()
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()
    
    if 1:
        assert(u.compareOutlines(self.temp_v,self.after))
        c.undoer.undo()
        assert(u.compareOutlines(self.temp_v,self.before))
        c.undoer.redo()
        assert(u.compareOutlines(self.temp_v,self.after))
        c.undoer.undo()
        assert(u.compareOutlines(self.temp_v,self.before))
    else:
        &lt;&lt; compare new, ref trees &gt;&gt;</t>
<t tx="ekr.20040303062846.24">def tearDown (self):
    
    c = self.c ; temp_v = self.temp_v
    
    temp_v.setTnodeText("",g.app.tkEncoding)
    temp_v.clearDirty()
    
    if not self.wasChanged:
        c.setChanged (False)
        
    # Delete all children of temp node.
    while temp_v.firstChild():
        temp_v.firstChild().doDelete(temp_v)

    c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.25"># Warning: this is Tk-specific code.

def setUp(self,*args,**keys):
    
    c = self.c ; temp_v = self.temp_v
    
    # Delete all children of temp node.
    while temp_v.firstChild():
        temp_v.firstChild().doDelete(temp_v)

    text = self.before.bodyString()
    
    temp_v.setTnodeText(text,g.app.tkEncoding)
    c.selectVnode(self.temp_v)
    
    t = c.frame.body.bodyCtrl
    if self.sel:
        s = str(self.sel.bodyString()) # Can't be unicode.
        lines = s.split('\n')
        g.app.gui.setTextSelection(t,lines[0],lines[1])

    if self.ins:
        s = str(self.ins.bodyString()) # Can't be unicode.
        lines = s.split('\n')
        g.trace(lines)
        g.app.gui.setInsertPoint(t,lines[0])
        
    if not self.sel and not self.ins:
        g.app.gui.setInsertPoint(t,"1.0")
        g.app.gui.setTextSelection(t,"1.0","1.0")</t>
<t tx="ekr.20040303062846.26">def runTest(self):

    self.editBody()</t>
<t tx="ekr.20040303062846.27"></t>
<t tx="ekr.20040303062846.28">def makeImportExportSuite(testParentHeadline,tempHeadline):
    
    """Create an Import/Export test for every descendant of testParentHeadline.."""
    
    u = testUtils() ; c = g.top() ; v = c.currentVnode()
    root = u.findRootNode(v)
    temp_v = u.findNodeInTree(root,tempHeadline)
    vList = u.findChildrenOf(testParentHeadline)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    for v in vList:
        dialog = u.findNodeInTree(v,"dialog")
        test = importExportTestCase(c,v,dialog,temp_v)
        suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040303062846.29">class importExportTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's edit body commands."""
    
    @others</t>
<t tx="ekr.20040303062846.30">def __init__ (self,c,v,dialog,temp_v):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.c = c
    self.dialog = dialog
    self.v = v
    self.temp_v = temp_v
    
    self.gui = None
    self.wasChanged = c.changed
    self.fileName = ""

    self.old_v = c.currentVnode()

</t>
<t tx="ekr.20040303062846.31">def importExport (self):
    
    c = self.c ; v = self.v
    
    g.app.unitTestDict = {}

    commandName = v.headString()
    command = getattr(c,commandName) # Will fail if command does not exist.
    command()

    failedMethod = g.app.unitTestDict.get("fail")
    self.failIf(failedMethod,failedMethod)</t>
<t tx="ekr.20040303062846.32">def runTest(self):
    
    # """Import Export Test Case"""

    self.importExport()</t>
<t tx="ekr.20040303062846.33">def setUp(self,*args,**keys):
    
    c = self.c ; temp_v = self.temp_v ; d = self.dialog
    
    temp_v.setTnodeText('',g.app.tkEncoding)

    # Create a node under temp_v.
    child = temp_v.insertAsLastChild()
    assert(child)
    child.setHeadString("import test: " + self.v.headString())
    c.selectVnode(child)

    assert(d)
    s = d.bodyString()
    lines = s.split('\n')
    name = lines[0]
    val = lines[1]
    self.fileName = val
    dict = {name: val}
    self.gui = leoGui.unitTestGui(dict,trace=False)
    
    </t>
<t tx="ekr.20040303062846.34">def shortDescription (self):
    
    try:
        return "ImportExportTestCase: %s %s" % (self.v.headString(),self.fileName)
    except:
        return "ImportExportTestCase"</t>
<t tx="ekr.20040303062846.35">def tearDown (self):
    
    c = self.c ; temp_v = self.temp_v
    
    if self.gui:
        self.gui.destroySelf()
        self.gui = None
    
    temp_v.setTnodeText("",g.app.tkEncoding)
    temp_v.clearDirty()
    
    if not self.wasChanged:
        c.setChanged (False)
        
    if 1: # Delete all children of temp node.
        while temp_v.firstChild():
            temp_v.firstChild().doDelete(temp_v)

    c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.36"></t>
<t tx="ekr.20040303062846.37">def makeLeoFilesSuite(testParentHeadline,unused=None):
    
    """Create a .leo file test for every descendant of testParentHeadline.."""
    
    u = testUtils() ; c = g.top()
    
    vList = u.findChildrenOf(testParentHeadline)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    for v in vList:
        test = leoFileTestCase(c,v.headString().strip())
        suite.addTest(test)

    return suite

</t>
<t tx="ekr.20040303062846.38">class leoFileTestCase(unittest.TestCase):
    
    """Data-driven unit tests to test .leo files."""
    
    @others</t>
<t tx="ekr.20040303062846.39">def __init__ (self,c,fileName):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.old_c = c
    self.c = None # set by setUp.
    self.fileName = fileName
    self.gui = None # set by setUp
    self.openFrames = g.app.windowList[:]</t>
<t tx="ekr.20040303062846.40">def runTest(self):
    
    """Run the Check Outline command."""

    errors = self.c.checkOutline(verbose=False,unittest=True)
    assert(errors == 0)</t>
<t tx="ekr.20040303062846.41">def setUp(self):

    """Open the .leo file."""
    

    c = self.old_c ; fileName = self.fileName
    assert(g.os_path_exists(fileName))
    
    self.oldGui = g.app.gui
    # g.app.gui = leoGui.nullGui("nullGui")

    ok, frame = g.openWithFileName(fileName,c,enableLog=False)
    assert(ok)
    self.c = frame.c</t>
<t tx="ekr.20040303062846.42">def tearDown (self):

    """Close the .leo file if it was not already open."""

    frame = self.c.frame
    if frame not in self.openFrames:
        g.app.closeLeoWindow(frame)

    g.app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.63"></t>
<t tx="ekr.20040303062846.64">def makeOutlineSuite(testParentHeadline,unused=None):
    
    """Create an outline test for every descendant of testParentHeadline.."""
    
    u = testUtils() ; c = g.top() ; v = c.currentVnode()
    
    vList = u.findChildrenOf(testParentHeadline)

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    for v in vList:
        before = u.findNodeInTree(v,"before")
        after  = u.findNodeInTree(v,"after")
        ref    = u.findNodeInTree(v,"ref")
        if before and after and ref:
            test = outlineTestCase(c,v,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040303062846.65">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20040303062846.66">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref
    
    self.old_v = c.currentVnode()
    
    self.u = testUtils()</t>
<t tx="ekr.20040303062846.67">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert(move)
    
    c.selectVnode(move)
    
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()

    assert(u.compareOutlines(self.before,self.after))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref))</t>
<t tx="ekr.20040303062846.68">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20040303062846.69">def setUp(self,*args,**keys):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert(self.u.compareOutlines(self.before,self.ref))
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20040303062846.70">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()

    self.c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.71">def makePluginsSuite(verbose=False,*args,**keys):
    
    """Create an plugins test for every .py file in the plugins directory."""
    
    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(file) for file in files]
    files.sort()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    for file in files:
        test = pluginTestCase(file,verbose)
        suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040303062846.72"></t>
<t tx="ekr.20040303062846.73">class pluginTestCase(unittest.TestCase):
    
    """Unit tests for one Leo plugin."""
    
    @others</t>
<t tx="ekr.20040303062846.74">def __init__ (self,fileName,verbose):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.fileName = fileName
    self.oldGui = None
    self.verbose = verbose</t>
<t tx="ekr.20040303062846.75">def pluginTest (self):
    
    # Duplicate the import logic in leoPlugins.py.
    
    fileName = g.toUnicode(self.fileName,g.app.tkEncoding)
    path = g.os_path_join(g.app.loadDir,"..","plugins")
    
    if self.verbose:
        g.trace(str(g.shortFileName(fileName)))

    module = g.importFromPath(fileName,path)
    assert(module)
    
    # Run any unit tests in the module itself.
    if hasattr(module,"unitTest"):
        
        if self.verbose:
            g.trace("Executing unitTest in %s..." % str(g.shortFileName(fileName)))

        module.unitTest()</t>
<t tx="ekr.20040303062846.76">def runTest(self):

    self.pluginTest()</t>
<t tx="ekr.20040303062846.77">def setUp(self,*args,**keys):

    self.oldGui = g.app.gui
    # g.app.gui = leoTkinterGui.tkinterGui()</t>
<t tx="ekr.20040303062846.78">def shortDescription (self):
    
    return "pluginTestCase: " + self.fileName</t>
<t tx="ekr.20040303062846.79">def tearDown (self):

    g.app.gui = self.oldGui</t>
<t tx="ekr.20040303062846.80"># DTHEIN 2004.01.11: Added unit tests for reformatParagraph</t>
<t tx="ekr.20040303062846.81"># DTHEIN 2004.01.11: Added method
def makeReformatParagraphSuite(*args,**keys):
    
    """makeReformatParagraphSuite() -&gt; suite
    
    Create a Reformat Paragraph test for each of the 
    unit tests in the reformatParagraphTestCase class."""
    
    suite = unittest.TestSuite()
    suite.addTest(reformatParagraphTestCase("testNoTrailingNewline"))
    suite.addTest(reformatParagraphTestCase("testTrailingNewline"))
    suite.addTest(reformatParagraphTestCase("testMixedLineLengths"))
    suite.addTest(reformatParagraphTestCase("testMixedLinesWithLeadingWS"))
    suite.addTest(reformatParagraphTestCase("testNoChangeRequired"))
    suite.addTest(reformatParagraphTestCase("testHonorLeadingWS"))
    suite.addTest(reformatParagraphTestCase("testHonorLeadingWSVar1"))
    suite.addTest(reformatParagraphTestCase("testSimpleHangingIndent"))
    suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar1"))
    suite.addTest(reformatParagraphTestCase("testSimpleHangingIndentVar2"))
    suite.addTest(reformatParagraphTestCase("testMultiParagraph"))
    suite.addTest(reformatParagraphTestCase("testMultiParagraphWithList"))
    suite.addTest(reformatParagraphTestCase("testDirectiveBreaksParagraph"))
    suite.addTest(reformatParagraphTestCase("testWithLeadingWSOnEmptyLines"))
    return suite
    #	suite = reformatParagraphTestCase().suite();
    #return suite</t>
<t tx="ekr.20040303062846.82"># DTHEIN 2004.01.11: Added class
class reformatParagraphTestCase(unittest.TestCase):
    
    """Unit tests for Leo's reformat paragraph command."""
    
    @others</t>
<t tx="ekr.20040303062846.83"># DTHEIN 2004.01.11: Added method
def setUp(self):

    self.u = testUtils()
    self.c = g.top()
    self.current_v = self.c.currentVnode()
    self.old_v = self.c.currentVnode()
    root = self.u.findRootNode(self.current_v)
    self.temp_v = self.u.findNodeInTree(root,"tempNode")
    assert(self.temp_v)
    self.tempChild_v = None
    self.dataParent_v = self.u.findNodeInTree(root,"reformatParagraphsTests")
    assert(self.dataParent_v)
    self.before_v = None
    self.after_v = None
    self.case_v = None
    self.wasChanged = self.c.changed
    


</t>
<t tx="ekr.20040303062846.84"># DTHEIN 2004.01.11: Added method
def tearDown(self):
    
    # local variables for class fields, for ease
    # of reading and ease of typeing.
    #	
    c = self.c ; temp_v = self.temp_v
    
    # clear the temp node and mark it unchanged
    #
    temp_v.setTnodeText("",g.app.tkEncoding)
    temp_v.clearDirty()
    
    if not self.wasChanged:
        c.setChanged (False)
        
    # Delete all children of temp node.
    #
    while temp_v.firstChild():
        temp_v.firstChild().doDelete(temp_v)

    # make the original node the current node
    #
    c.selectVnode(self.old_v)</t>
<t tx="ekr.20040303062846.85"># DTHEIN 2004.01.11: Added method
def testNoTrailingNewline(self):
    
    self.singleParagraphTest("testNoTrailingNewline",2,24)
</t>
<t tx="ekr.20040303062846.86"># DTHEIN 2004.01.11: Added method
def testTrailingNewline(self):
    
    self.singleParagraphTest("testTrailingNewline",3,0)
</t>
<t tx="ekr.20040303062846.87"># DTHEIN 2004.01.11: Added method
def testMixedLineLengths(self):
    
    self.singleParagraphTest("testMixedLineLengths",4,10)
</t>
<t tx="ekr.20040303062846.88"># DTHEIN 2004.01.11: Added method
def testMixedLinesWithLeadingWS(self):
    
    self.singleParagraphTest("testMixedLinesWithLeadingWS",4,12)
</t>
<t tx="ekr.20040303062846.89"># DTHEIN 2004.01.11: Added method
def testNoChangeRequired(self):
    
    self.singleParagraphTest("testNoChangeRequired",1,28)
</t>
<t tx="ekr.20040303062846.90"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWS(self):
    
    self.singleParagraphTest("testHonorLeadingWS",5,16)
</t>
<t tx="ekr.20040303062846.91"># DTHEIN 2004.01.11: Added method
def testHonorLeadingWSVar1(self):
    
    self.singleParagraphTest("testHonorLeadingWSVar1",5,16)
</t>
<t tx="ekr.20040303062846.92"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndent(self):
    
    self.singleParagraphTest("testSimpleHangingIndent",5,8)
</t>
<t tx="ekr.20040303062846.93"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar1(self):
    
    self.singleParagraphTest("testSimpleHangingIndentVar1",5,8)
</t>
<t tx="ekr.20040303062846.94"># DTHEIN 2004.01.11: Added method
def testSimpleHangingIndentVar2(self):
    
    self.singleParagraphTest("testSimpleHangingIndentVar2",5,8)
</t>
<t tx="ekr.20040303062846.95"># DTHEIN 2004.01.11: Added method
def testMultiParagraph(self):
    
    # Locate the test data
    #
    self.getCaseDataNodes("testMultiParagraph")
    
    # Setup the temp node
    #
    self.copyBeforeToTemp()
    
    # reformat the paragraph and check insertion cursor position
    #
    self.c.reformatParagraph()
    self.checkPosition(13,0)
    
    # Keep going, in the same manner
    #
    self.c.reformatParagraph()
    self.checkPosition(25,0)
    self.c.reformatParagraph()
    self.checkPosition(32,11)
    
    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20040303062846.96"># DTHEIN 2004.01.11: Added method
def testMultiParagraphWithList(self):
    
    # Locate the test data
    #
    self.getCaseDataNodes("testMultiParagraphWithList")
    
    # Setup the temp node
    #
    self.copyBeforeToTemp()
    
    # reformat the paragraph and check insertion cursor position
    #
    self.c.reformatParagraph()
    self.checkPosition(4,0)
    
    # Keep going, in the same manner
    #
    self.c.reformatParagraph()
    self.checkPosition(7,0)
    self.c.reformatParagraph()
    self.checkPosition(10,0)
    self.c.reformatParagraph()
    self.checkPosition(13,0)
    self.c.reformatParagraph()
    self.checkPosition(14,18)
    
    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20040303062846.97"># DTHEIN 2004.01.11: Added method
def testDirectiveBreaksParagraph(self):
    
    # Locate the test data
    #
    self.getCaseDataNodes("testDirectiveBreaksParagraph")
    
    # Setup the temp node
    #
    self.copyBeforeToTemp()
    
    # reformat the paragraph and check insertion cursor position
    #
    self.c.reformatParagraph()
    self.checkPosition(13,0) # at next paragraph
    
    # Keep going, in the same manner
    #
    self.c.reformatParagraph()
    self.checkPosition(25,0) # at next paragraph

    self.c.reformatParagraph()
    self.checkPosition(32,11)
    
    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20040303062846.98"># DTHEIN 2004.01.11: Added method
def testWithLeadingWSOnEmptyLines(self):
    
    # Locate the test data
    #
    self.getCaseDataNodes("testWithLeadingWSOnEmptyLines")
    
    # Setup the temp node
    #
    self.copyBeforeToTemp()
    
    # reformat the paragraph and check insertion cursor position
    #
    self.c.reformatParagraph()
    self.checkPosition(4,0)
    
    # Keep going, in the same manner
    #
    self.c.reformatParagraph()
    self.checkPosition(7,0)
    self.c.reformatParagraph()
    self.checkPosition(10,0)
    self.c.reformatParagraph()
    self.checkPosition(13,0)
    self.c.reformatParagraph()
    self.checkPosition(14,18)
    
    # Compare the computed result to the reference result.
    self.checkText()
</t>
<t tx="ekr.20040303062846.99"># DTHEIN 2004.01.11: Added method
def singleParagraphTest(self,caseName,finalRow,finalCol):
    
    # Locate the test data
    #
    self.getCaseDataNodes(caseName)
    
    # Setup the temp node
    #
    self.copyBeforeToTemp()
    
    # reformat the paragraph
    #
    self.c.reformatParagraph()
    
    # Compare the computed result to the reference result.
    self.checkText()
    self.checkPosition(finalRow,finalCol)

</t>
<t tx="ekr.20040303062846.100"># DTHEIN 2004.01.11: Added method
def checkPosition(self,expRow,expCol):

    row,col = self.getRowCol()
    self.failUnlessEqual(expCol,col,
        "Current position is (" + str(row) + "," + str(col) 
        + ");  expected cursor to be at column " + str(expCol) + ".")
    self.failUnlessEqual(expRow,row,
        "Current position is (" + str(row) + "," + str(col) 
        + ");  expected cursor to be at line " + str(expRow) + ".")
</t>
<t tx="ekr.20040303062846.101"># DTHEIN 2004.01.11: Added method
def checkText(self):

    new_text = self.tempChild_v.bodyString()
    ref_text = self.after_v.bodyString()
    newLines = new_text.splitlines(1)
    refLines = ref_text.splitlines(1)
    newLinesCount = len(newLines)
    refLinesCount = len(refLines)
    for i in range(min(newLinesCount,refLinesCount)):
        self.failUnlessEqual(newLines[i],refLines[i],
            "Mismatch on line " + str(i) + "."
            + "\nExpected text: " + `refLines[i]`
            + "\n  Actual text: "	+ `newLines[i]`)
    self.failUnlessEqual(newLinesCount,refLinesCount,
        "Expected " + str(refLinesCount) + " lines, but "
        + "received " + str(newLinesCount) + " lines.")</t>
<t tx="ekr.20040303062846.102"># DTHEIN 2004.01.11: Added method
# Warning: this is Tk-specific code.
#
def copyBeforeToTemp(self):

    # local variables for class fields, for ease
    # of reading and ease of typeing.
    #	
    c = self.c ; temp_v = self.temp_v

    # Delete all children of temp node.
    #
    while temp_v.firstChild():
        temp_v.firstChild().doDelete(temp_v)

    # Copy the test case node text to the temp node
    #
    text = self.case_v.bodyString()
    temp_v.setTnodeText(text,g.app.tkEncoding)
    
    # create the child node that holds the text
    #
    t = leoNodes.tnode(headString="tempChildNode")
    self.tempChild_v = self.temp_v.insertAsNthChild(0,t)

    # copy the before text to the temp text
    #
    text = self.before_v.bodyString()
    self.tempChild_v.setTnodeText(text,g.app.tkEncoding)
    
    # make the temp child node current, and put the
    # cursor at the beginning
    #
    c.selectVnode(self.tempChild_v)
    c.frame.body.setInsertPointToStartOfLine( 0 )
    c.frame.body.setTextSelection(None,None)
    #g.app.gui.setInsertPoint(t,"1.0")
    #g.app.gui.setTextSelection(t,"1.0","1.0")
</t>
<t tx="ekr.20040303062846.103"># DTHEIN 2004.01.11: Added method
def getCaseDataNodes(self,caseNodeName):

    self.case_v = self.u.findNodeInTree(self.dataParent_v,caseNodeName)
    self.before_v = self.u.findNodeInTree(self.case_v,"before")
    self.after_v  = self.u.findNodeInTree(self.case_v,"after")
</t>
<t tx="ekr.20040303062846.104"># DTHEIN 2004.01.11: Added method
def getRowCol(self):
    
    # local variables for class fields, for ease
    # of reading and ease of typeing.
    #	
    c = self.c ; body = c.frame.body.bodyCtrl ; gui = g.app.gui
    tab_width = c.frame.tab_width

    # Get the Tkinter row col position of the insert cursor
    #	
    index = body.index("insert")
    row,col = gui.getindex(body,index)
    
    # Adjust col position for tabs
    #
    if col &gt; 0:
        s = body.get("%d.0" % (row),index)
        s = g.toUnicode(s,g.app.tkEncoding)
        col = g.computeWidth(s,tab_width)

    return (row,col)
</t>
<t tx="ekr.20040303063118">class positionTestCase(unittest.TestCase):
    
    """Unit tests for Leo's position class."""
    
    @others</t>
<t tx="ekr.20040303063118.4">def setUp(self,*args,**keys):
    
    import leoGlobals as g
    
    self.c = c = g.top()

    self.verbose = True
    
    self.root = c.rootPosition()</t>
<t tx="ekr.20040303063549"></t>
<t tx="ekr.20040303063549.1"></t>
<t tx="ekr.20040303063549.2">@ 
# DTHEIN 2004.01.11: Added script

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth
and language formatting directives
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("reformatParagraphsTests")
p.c.selectVnode(p)

suite = leoTest.makeReformatParagraphSuite()
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.3">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, no trailing newline.
</t>
<t tx="ekr.20040303063549.4">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040303063549.5">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040303063549.6">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040303063549.7">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040303063549.8">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040303063549.9">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040303063549.10">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.11">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.12">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040303063549.13">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040303063549.14">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040303063549.15">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040303063549.16">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.17">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.18">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040303063549.19">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.20">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.21">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040303063549.22">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.23">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.24">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040303063549.25">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.26">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.27">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040303063549.28">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.29">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.30">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040303063549.31">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20040303063549.32">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.33">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Mutliple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040303063549.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.35">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.36">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040303063549.37">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.38">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.39">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040303063549.40">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.41">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.42">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040303063549.43">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.44">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.45">import unittest
import leoTest
reload(leoTest)

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("colorizerTests")
p.c.selectVnode(p)

suite = leoTest.makeColorSuite("colorizerTests","tempNode")
unittest.TextTestRunner().run(suite)

# This works because there is _no_ @others here.</t>
<t tx="ekr.20040303063549.46">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040303063549.47">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040303063549.48">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040303063549.49">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040303063549.50">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20040303063549.51">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040303063549.52">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040303063549.53">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040303063549.54">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040303063549.55">@ignore
@ doc
@c
@language c
    @others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040303063549.56">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20040303063549.57">@language python

"""python
string"""d

'this\
is'''</t>
<t tx="ekr.20040303063549.58">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
    
def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20040303063549.59">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040303063549.60"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

import leoGlobals as g ; print g.app().loadDir</t>
<t tx="ekr.20040303063549.61"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

import leoGlobals as g ; print g.app().loadDir
</t>
<t tx="ekr.20040303063549.62"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="ekr.20040303063549.63">@ The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
@c

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("editBodyTests")
p.c.selectVnode(p)

suite = leoTest.makeEditBodySuite("editBodyTests","tempNode")
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.64"></t>
<t tx="ekr.20040303063549.65">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040303063549.66">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.67">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.68"></t>
<t tx="ekr.20040303063549.69">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040303063549.70">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040303063549.71">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040303063549.72"></t>
<t tx="ekr.20040303063549.73">before
&lt;&lt; section &gt;&gt;
sec line 1
    sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040303063549.74">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040303063549.75">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20040303063549.76">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040303063549.77">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("exportTests")
p.c.selectVnode(p)

suite = leoTest.makeImportExportSuite("exportTests","tempNode")
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.78"></t>
<t tx="ekr.20040303063549.79">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040303063549.80"></t>
<t tx="ekr.20040303063549.81">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040303063549.82"></t>
<t tx="ekr.20040303063549.83">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040303063549.84"></t>
<t tx="ekr.20040303063549.85">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040303063549.86"></t>
<t tx="ekr.20040303063549.87">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040303063549.88"></t>
<t tx="ekr.20040303063549.89">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.90"># To do: at present this creates a copy of this node as the next sib of tempNode!

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("importTests")
p.c.selectVnode(p)

suite = leoTest.makeImportExportSuite("importTests","tempNode")
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.91"></t>
<t tx="ekr.20040303063549.92">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.93"></t>
<t tx="ekr.20040303063549.94">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.95"></t>
<t tx="ekr.20040303063549.96">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040303063549.97"></t>
<t tx="ekr.20040303063549.98">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040303063549.99"></t>
<t tx="ekr.20040303063549.100">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040303063549.101">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("outlineTests")
p.c.selectVnode(p)

suite = leoTest.makeOutlineSuite("outlineTests")
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.102"></t>
<t tx="ekr.20040303063549.103"></t>
<t tx="ekr.20040303063549.104"></t>
<t tx="ekr.20040303063549.105"></t>
<t tx="ekr.20040303063549.106"></t>
<t tx="ekr.20040303063549.107"></t>
<t tx="ekr.20040303063549.108"></t>
<t tx="ekr.20040303063549.109"></t>
<t tx="ekr.20040303063549.110"></t>
<t tx="ekr.20040303063549.111"></t>
<t tx="ekr.20040303063549.112"></t>
<t tx="ekr.20040303063549.113"></t>
<t tx="ekr.20040303063549.114"></t>
<t tx="ekr.20040303063549.115"></t>
<t tx="ekr.20040303063549.116"></t>
<t tx="ekr.20040303063549.117"></t>
<t tx="ekr.20040303063549.118">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("pluginsTests")
p.c.selectVnode(p)

# NOTE: this enables all widgets: there may be problems with doing this that are not real errors.

suite = leoTest.makePluginsSuite(verbose=0)
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.119">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("positionTests")
p.c.selectVnode(p)

suite = leoTest.makePositionSuite(all=1)
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.120">import unittest
import leoTest
reload(leoTest)

if 1: # Run test cases by name.

    suite = unittest.TestSuite()
    for name in ("test1","test2","test3","test4"):
        test = leoTest.leoFileTests(name)
        suite.addTest(test)

else: # Run all test cases.

    suite = unittest.makeSuite(leoTest.leoFileTests)

unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040303063549.125">import leoGlobals as g
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("Run all tests")
p.c.selectVnode(p)

mainSuite = unittest.makeSuite(unittest.TestCase)

for f,arg in (
    (leoTest.makeBatchModeSuite,None),
    (leoTest.makeColorSuite,"colorizerTests"),
    (leoTest.makeEditBodySuite,"editBodyTests"),
    (leoTest.makeImportExportSuite,"exportTests"),
    (leoTest.makeImportExportSuite,"importTests"),
    (leoTest.makeOutlineSuite,"outlineTests"),
    (leoTest.makeLeoFilesSuite,"leoFileTests"),
    (leoTest.makePositionSuite,None),
    (leoTest.makeReformatParagraphSuite,None)
    # 
    # These tests presently have problem with the gui when run with other tests...
    # (leoTest.makePluginsSuite,False) # verbose
):
    suite = f(arg,"tempNode")
    mainSuite.addTest(suite)
    
unittest.TextTestRunner().run(mainSuite)</t>
<t tx="ekr.20040303063644"></t>
<t tx="ekr.20040303064013">def makePositionSuite(arg=None,all=True,verbose=False):
    
    if all: # Include everything.
    
        suite = unittest.makeSuite(positionTestCase,'test')
        
    else: # Include listed testss.

        names = (
            "testFullTraverse",
            "testParentChildLinks",
            "testNextBack",
            "testVnodeList",
            "testThreadBackNext",
            "testParentChildLevel")
        
        suite = unittest.makeSuite(unittest.TestCase)
        for name in names:
            suite.addTest(positionTestCase(name))

    return suite</t>
<t tx="ekr.20040303064020.5">def testConsistencyOfNextBack (self):
    
    """Test consistency of p.next and p.back."""

    for p in self.root.allNodes_iter():
        
        back = p.back()
        next = p.next()
        if back: assert(back.getNext() == p)
        if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040303064020.6">def testVnodeList (self):
    
    for p in self.root.allNodes_iter():

        vnodeList = p.v.t.vnodeList
    
        for v in vnodeList:

            assert(v.t == p.v.t)
            if p.v.isCloned():
                assert(v.isCloned())
                assert(len(vnodeList) &gt; 1)
            else:
                assert(not v.isCloned())
                assert(len(vnodeList) == 1)</t>
<t tx="ekr.20040303064020.7">def testConsistencyOfThreadBackNext (self):

    for p in self.root.allNodes_iter():

        threadBack = p.threadBack()
        threadNext = p.threadNext()

        if threadBack:
            assert(p == threadBack.getThreadNext())
    
        if threadNext:
            assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040303071432">@language python
@tabwidth -4</t>
<t tx="ekr.20040303080010">import leoGlobals as g
import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("Run all non-file tests")
p.c.selectVnode(p)

mainSuite = unittest.makeSuite(unittest.TestCase)

for f,arg in (
    (leoTest.makeBatchModeSuite,"dummy"),
    (leoTest.makeColorSuite,"colorizerTests"),
    (leoTest.makeEditBodySuite,"editBodyTests"),
    (leoTest.makePositionSuite,None),
    (leoTest.makeReformatParagraphSuite,None),
    (leoTest.makeOutlineSuite,"outlineTests")
    # These tests presently have problem with the gui when run with other tests...
    # (leoTest.makePluginsSuite,False)
):
    suite = f(arg,"tempNode")
    mainSuite.addTest(suite)

unittest.TextTestRunner().run(mainSuite)</t>
<t tx="ekr.20040303080938"></t>
<t tx="ekr.20040303080938.1"></t>
<t tx="ekr.20040303091606">def testHasNextBack (self):
    
    for p in self.root.allNodes_iter():

        back = p.back()
        next = p.next()

        assert(
            (back and p.hasBack()) or
            (not back and not p.hasBack()))
                
        assert(
            (next and p.hasNext()) or
            (not next and not p.hasNext()))</t>
<t tx="ekr.20040303092153">def testHasParentChild (self):
    
    for p in self.root.allNodes_iter():

        child = p.firstChild()
        parent = p.parent()

        assert(
            (child and p.hasFirstChild()) or
            (not child and not p.hasFirstChild()))
                
        assert(
            (parent and p.hasParent()) or
            (not parent and not p.hasParent()))</t>
<t tx="ekr.20040303092153.1">def testHasThreadNextBack(self):

    for p in self.root.allNodes_iter():

        threadBack = p.getThreadBack()
        threadNext = p.getThreadNext()

        assert(
            (threadBack and p.hasThreadBack()) or
            (not threadBack and not p.hasThreadBack()))
                
        assert(
            (threadNext and p.hasThreadNext()) or
            (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040309095121"></t>
<t tx="ekr.20040309101454.13">def testConsistencyOfLevel (self):
    
    """Test consistency of p.level."""

    for p in self.root.allNodes_iter():
        
        if p.hasParent():
            assert(p.parent().level() == p.level() - 1)
    
        if p.hasChildren():
            assert(p.firstChild().level() == p.level() + 1)
            
        if p.hasNext():
            assert(p.next().level() == p.level())
    
        if p.hasBack():
            assert(p.back().level() == p.level())
</t>
<t tx="ekr.20040309101454.14">def testConsistencyOfParentChild (self):
    
    """Test consistency of p.parent, p.next, p.back and p.firstChild."""
    
    root = self.c.rootPosition()

    for p in root.allNodes_iter():
        
        if p.hasParent():
            n = p.childIndex()
            assert(p == p.parent().moveToNthChild(n))
            
        for child in p.children_iter():
            assert(p == child.parent())
    
        if p.hasNext():
            assert(p.next().parent() == p.parent())
            
        if p.hasBack():
            assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040309101454.15">def testConsistencyOfAllNodesThreadNextWithCopy(self):
    self.doConsistencyOfAllNodesThreadNext(True)
    
def testConsistencyOfAllNodesThreadNext(self):
    self.doConsistencyOfAllNodesThreadNext(False)

def doConsistencyOfAllNodesThreadNext (self,copy):
    
    """Test consistency of p.moveToThreadNext and p.allNodes_iter."""

    root = self.c.rootPosition()
    p2 = root.copy()

    for p in root.allNodes_iter(copy=copy):

        if p != p2: print p,p2
        assert(p==p2)
        p2.moveToThreadNext()
        
    if p2: print p2
    assert(not p2)
</t>
<t tx="ekr.20040309101454.16">def testConsistencyOfParentAndParentsIterWithCopy(self):
    self.doConsistencyOfParentAndParentsIter(True)
    
def testConsistencyOfParentAndParentsIter(self):
    self.doConsistencyOfParentAndParentsIter(False)

def doConsistencyOfParentAndParentsIter (self,copy):
    
    """Test consistency of p.parent and p.parents_iter."""

    root = self.c.rootPosition()

    for p in root.allNodes_iter():
        
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            
            if p3 != p2: print p3,p2
            assert(p3==p2)
            p2.moveToParent()
    
        if p2: print p2
        assert(not p2)</t>
<t tx="ekr.20040309101454.17">def testConsistencyOfFirstChildAndChildrenIterWithCopy(self):
    self.doConsistencyOfFirstChildAndChildrenIter(True)
    
def testConsistencyOfFirstChildAndChildrenIter(self):
    self.doConsistencyOfFirstChildAndChildrenIter(False)

def doConsistencyOfFirstChildAndChildrenIter (self,copy):
    
    """Test consistency of p.moveToFirstChild/Next and p.children_iter."""

    root = self.c.rootPosition()

    for p in root.allNodes_iter(copy=copy):
        
        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            
            if p3 != p2: print p3,p2
            assert(p3==p2)
            p2.moveToNext()

    if p2: print p2
    assert(not p2)</t>
<t tx="ekr.20040309105731">def testComparisons (self):
    
    p = self.root
    assert(p == p.copy())
    assert(p != p.threadNext())</t>
<t tx="ekr.20040309111054">import leoGlobals as g
import leoNodes

c = g.top()
position = leoNodes.position

@others

current = pos = c.currentPosition()
child1 = current.firstChild()
child2 = child1.firstChild()

if 0:
    print '-'*10, "parents"
    for p in child2.parents_iter(): print p
if 0:
    print '-'*10, "subtree"
    for p in pos.subtree_iter(): print p
if 0:
    print '-'*10, "children"
    for p in child1.children_iter(): print p
if 0:
    print '-'*10, "siblings"
    for p in pos.siblings_iter(): print p
if 1:
    print '-'*10, "all nodes"
    for p in pos.allNodes_iter():
        print p.isCloned(),p
</t>
<t tx="ekr.20040309111102"></t>
<t tx="ekr.20040309111102.1"></t>
<t tx="ekr.20040309111102.2"></t>
<t tx="ekr.20040309111102.3"></t>
<t tx="ekr.20040309111102.4"></t>
<t tx="ekr.20040309111102.5"></t>
<t tx="ekr.20040309111102.6"></t>
<t tx="ekr.20040309111102.7"></t>
<t tx="ekr.20040309111102.8"></t>
<t tx="ekr.20040309111102.9"></t>
<t tx="ekr.20040309111102.10"></t>
<t tx="ekr.20040309111232"></t>
<t tx="ekr.20040310145919">import leoGlobals as g
c = g.top()
c.frame.body.colorizer.python_keywords.append("as")</t>
<t tx="ekr.20040311090054">import leoGlobals as g
import leoNodes

c = g.top() ; root = c.rootPosition()

for p in root.allNodes_iter():
    print p.v.t.fileIndex</t>
<t tx="ekr.20040311125054">import leoGlobals as g
c = g.top()
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
    assert(p.t == p.v.t)
    
print "done"</t>
<t tx="ekr.20040312021734"></t>
<t tx="ekr.20040312021734.1">import leoGlobals as g

c = g.top()

count = 0
for p in c.rootPosition().allNodes_iter():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20040312101720"></t>
<t tx="ekr.20040312101720.1"></t>
<t tx="ekr.20040312101853"></t>
<t tx="ekr.20040315025315">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315025315.1">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.subtree_iter()
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)</t>
<t tx="ekr.20040315025315.2">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040315025315.3">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.bodyString() ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040315030123">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

p = p.firstChild()
assert(p.headString()=="File Conversion")
print p.convertTreeToString()</t>
<t tx="ekr.20040315202201"></t>
<t tx="ekr.20040315202250">def makeFindCommandSuite(arg=None,all=True,verbose=False):
    
    return unittest.makeSuite(findCommandTestCase,'test')</t>
<t tx="ekr.20040315202314">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20040315202314.1">def setUp(self,*args,**keys):
    
    import leoGlobals as g
    
    u = testUtils()
    
    self.c = c = g.top()

    self.verbose = True
    
    self.root = c.rootPosition()
    
    self.find_p = u.findNodeAnywhere(c,"findTests")
    
    assert(self.find_p)
    
    c.selectPosition(self.find_p)
</t>
<t tx="ekr.20040315202347">def testFindCommand (self):
    
    g.trace(self.find_p)</t>
<t tx="ekr.20040315202718">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20040315202718.1">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20040315202718.2">import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("fileCommandTests")
p.c.selectVnode(p)

suite = leoTest.makeFindCommandSuite()
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040315210314"></t>
<t tx="ekr.20040315210314.1"></t>
<t tx="ekr.20040315210314.2">@nocolor

- Used iterators in test utils.
- Used "import leoGlobals as g" style.</t>
<t tx="ekr.20040317101155" lineYOffset="4b032e" icons="5d7100287d710128550577686572657102550a6265666f726549636f6e710355047870616471044b025504747970657105550466696c6571066806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286805680668084afdffffff6806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6802550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e">import leoGlobals as g

c = g.top()

p = c.currentPosition()
p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

&lt;&lt; define event callbacks &gt;&gt;

path = r"c:\prog\leoCVS\leo\Icons"
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
    "type" : "file", "file" : icon1,
    "where" : "beforeIcon",
    "yoffset" : -3,
    # "yoffset" : 5, "ypad" : -5,
    # "height" : 40, # automatically adjust headline y position.
    "xpad": 2
}

# Classes and functions can only be pickled if they are at the top level of a module.
    #"onClick" : onClick,
    #"onRightClick" : onRightClick,
    #"onDoubleClick" : onDoubleClick }

d2 = {
    "type" : "file", "file" : icon2,
    "where" : "beforeHeadline",
    "yoffset" : -3,
    "xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()
</t>
<t tx="ekr.20040317173327">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0
            
c.redraw()</t>
<t tx="ekr.20040317185041">def onClick(p=p):
    
    g.trace(p)

def onRightClick(p=p):
    
    g.trace(p)

def onDoubleClick(p=p):
    
    g.trace(p)</t>
<t tx="ekr.20040318091620">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if hasattr(p.v.t,"unknownAttributes"):
        print "deleting unknownAttributes:",p
        delattr(p.v.t,"unknownAttributes")
            
c.redraw()</t>
<t tx="ekr.20040318102920"># The actual test is in a child node.</t>
<t tx="ekr.20040318102920.1"></t>
<t tx="ekr.20040318102920.2">import leoGlobals as g
c = g.top()

print '-'*20

count = 0 ; ok = True
for p in c.allNodes_iter():
# for p in [c.currentPosition()]:
    count += 1
    if 0: # Check all ancestors.  This is tricky and doesn't work yet.
        parents1 = [parent.v for parent in p.parents_iter()]
        parents2 = []
        parent2 = p.v.directParents()
        while parent2:
            v = parent2[0]
            parents2.append(v)
            parent2 = v.directParents()
    else:
        if p.v._parent: parents1 = p.v._parent.t.vnodeList
        else:           parents1 = []
        parents2 = p.v.directParents()
    
    if len(parents1) != len(parents2):
        print "length mismatch",p,p.v._parent
        ok = False
    for parent in parents1:
        if parent not in parents2:
            print "not in parent2",p,parent
            ok = False
    for parent in parents2:
        if parent not in parents1:
            print "not in parents1",p,parent
            ok = False
    if not ok:
        print "parents1"
        for parent in parents1: print parent
        print "parents2"
        for parent in parents2: print parent
        break
    
print "%d vnodes checked" % count</t>
<t tx="ekr.20040319111213">from leoPlugins import *
from leoGlobals import *
from leoNodes import *
import Tkinter
import re
import sys

@others

fhp = None
fhp_entry = None
    
if 1:
    addMenu("none",None)
else:
    hooks = choose(sys.platform == 'win32',
        ('open2',"new"),
        ('start2','open2',"new"))
        
    print "hi"
        
    registerHandler(hooks,addMenu)

    __version__ = ".1"
    plugin_signon(__name__)
</t>
<t tx="ekr.20040319111213.1">@nocolor

@ This is what it does:

1. Under Outline it puts an Option called 'FilterHoist'
2. Selecting the option pops up an ugly little window.  On it is a section where
you can type in text.  You can close the window with the close button.  You
can activate the functionality with the Filter Button.
3. Filtering will walk the Leo tree, looking for a text match from the Text
field with the Nodes bodyString.
4. After finding some nodes it creates a new node at the root.  Then it clones
the matching nodes under that new node.  A Hoist operation is performed on the
new node.  This gives a view of all matching nodes.

I put this together because I wanted a find that was based in terms of Leo's
nodes.  Find as it is bounces you around the Tree(it bothers me).  This brings
the nodes to you and presents them.  As it is I may work further on this if
people like the idea.  It's possible I might migrate it to the NodeRoundup plugin
to.

You need 2.3 python; it uses generators in it's find method.

That was one motivation for writing this thing, using a generator vs. Recursive
approach to tree walking.</t>
<t tx="ekr.20040319111213.2">def OLDfilter(c,e):

    v = c.rootVnode()
    
    nodes = []
    while v:
        nodes.append(v)
        v = v.next()
    
    regex = re.compile(e.get())
    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        ticker = c.rootVnode().insertAfter(t)
        for z in nodes:
            for x in search(z,regex):
                clone = x.clone( x )
                clone.moveToNthChildOf(ticker,0)
        c.setCurrentVnode(ticker)
        ticker.moveToRoot(c.rootVnode())
    c.endUpdate()
    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040319111213.3">def OLDsearch(vn,regex):

    sn = vn 
    while vn != None:
        if regex.search( vn.t.bodyString ) : yield vn
        nc = vn.numberOfChildren()
        if nc == 0:
            i = vn.childIndex()
            p = vn.parent()
            if p == None: 
                vn = None
                continue
            if i == 0:
                while 1:
                    if p == sn :
                        vn = None
                        break
                    vn = p.back() 
                    if vn == None:
                        p = p.parent()
                        continue
                    break
                continue                                                        
            vn = p.nthChild( i - 1)
            continue
        vn = vn.nthChild( nc - 1 )
</t>
<t tx="ekr.20040319111213.4">def filterHoist(c):

    global fhp
    global e
    
    if fhp is None:

        fhp = Tkinter.Toplevel()
        fhp.title('FilterHoist')

        fhp_entry = e = Tkinter.Entry(fhp)
        e.pack(side="top",fill="both")

        def closeCallback(fhp=fhp):
            fhp.withdraw()
            
        def filterCallback(c=c,entry=e):
            filter(c,entry)

        b1 = Tkinter.Button(fhp,text='Close',command=closeCallback)
        b2 = Tkinter.Button(fhp,text='Filter',command=filterCallback)
        b1.pack(side="left")
        b2.pack(side="right")

    fhp.geometry('200x200+250+250') 
    fhp.deiconify()
    fhp_entry.focus_set()
</t>
<t tx="ekr.20040319111213.5">def addMenu(tag,keywords):
    
    c = top()
    
    trace()
    
    def callback(c=c):
        filterHoist(c)
    
    table = ("FilterHoist",None,callback),

    c.frame.menu.createMenuItemsFromTable("Outline",table)</t>
<t tx="ekr.20040319142202"></t>
<t tx="ekr.20040319142708">def filter(c,e):
    
    pat = re.compile(e.get())

    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        newRoot = c.rootVnode().insertAfter(t)
        p = c.rootVnode()
        while p:
            if pat.search(p.bodyString()):
                clone = p.clone(p)
                clone.moveToLastChildOf(newRoot)
            p = p.threadNext()
        newRoot.moveToRoot(c.rootVnode())
        c.setCurrentVnode(newRoot)
    c.endUpdate()

    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040322120331">import leoGlobals as g
c = g.top()

print '-'*20
for p in c.allNodes_iter():
    if hasattr(p.v.t,"tnodeList"):
        print p,p.v.t.tnodeList</t>
<t tx="ekr.20040323075614">import leoGlobals as g

class test_iter_class:
    def __init__ (self):
        self.vals = ("a","b","c")
        self.n = 0
    def __iter__(self):
        return self
    def next(self):
        if self.n &lt; len(self.vals):
            val = self.vals[self.n]
            self.n += 1
            return val
        else:
            raise StopIteration
            
def test_iter(): return test_iter_class()
        
vals = [val for val in test_iter()]

print vals
</t>
<t tx="ekr.20040323080317">import leoGlobals as g
c = g.top()

print '-'*20

# These are equivalent.
positions1 = [p for p in c.allNodes_iter(copy=True)]
positions2 = [p.copy() for p in c.allNodes_iter()]

assert(len(positions1) == len(positions2))
for i in xrange(len(positions1)):
    assert(positions1[i] == positions2[i])

if 0:
    for p in positions1:
        print p
print "done"</t>
<t tx="ekr.20040323082119">import leoGlobals as g
c = g.top()

print '-'*20

positions = [p.copy() for p in c.allNodes_iter()]

tnodes = {} ; vnodes = []
for p in c.allNodes_iter():
    t = p.v.t
    if tnodes.get(t) is None:
        tnodes[t]=t
        vnodes.append(p.v)
        
print len(positions),len(vnodes)

for v in vnodes:
    print v</t>
<t tx="ekr.20040323085406">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isAnyAtFileNode():
        print p
        
print "done"</t>
<t tx="ekr.20040323085933">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isDirty():
        vnodes = p.findAllPotentiallyDirtyNodes()
        print '-'*5, p
        for v in vnodes:
            print v

print "done"</t>
<t tx="ekr.20040323090541">import leoGlobals as g

c = g.top()

print '-'*20
ok = True ; count = 0
for p in c.allNodes_iter():
    if p.isCloned():
        count += 1
        parents = p.v.t.vnodeList
        for child in p.children_iter():
            vparents = child.v.directParents()
            if len(parents) != len(vparents):
                    print "length mismatch",p,child,
                    ok = False
            for parent in parents:
                if parent not in vparents:
                    print "not in vparents",p,child
                    ok = False
            for parent in vparents:
                if parent not in parents:
                    print "not in parents",p,child
                    ok = False
            if not ok:
                print "parents"
                for parent in parents: print parent
                print "vparents"
                for parent in vparents: print parent
                break
        if not ok: break
    if not ok: break
s = "checked %d cloned positions" % count
print s ; g.es(s)
</t>
<t tx="ekr.20040323162303">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))
            
print "done"</t>
<t tx="ekr.20040323163413">def testThatClonesShareSubtrees (self):
    
    """Test that cloned nodes actually share subtrees."""

    for p in self.root.allNodes_iter():
        if p.isCloned() and p.hasChildren():
            childv = p.firstChild().v
            assert(childv == p.v.t._firstChild)
            assert(id(childv) == id(p.v.t._firstChild))
            for v in p.v.t.vnodeList:
                assert(v.t._firstChild == childv)
                assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040323163643">def testConsistencyOfVnodeListAndParents (self):

    for p in self.root.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert(len(parents) == len(vparents))
                for parent in parents:
                    assert(parent in vparents)
                for parent in vparents:
                    assert(parent in parents)</t>
<t tx="ekr.20040325073120">@ignore</t>
<t tx="ekr.20040325082811">import leoGlobals as g

g.es("v",g.top().currentPosition())
g.es(1,2)</t>
<t tx="ekr.20040325130503">stack1 = ["a","b","c"]
stack2 = ["a","b","c"]
stack3 = ["a","b","d"]
stack4 = ["a","b"]
print stack1 == stack2
print stack1 == stack3
print stack1 == stack4</t>
<t tx="ekr.20040325140133">import leoGlobals as g
c = g.top() ; p = c.currentPosition()

print p.v.headString()
print p.childIndex()
print p.v.headString()</t>
<t tx="ekr.20040325155043">import timeit

s1 = '''\
class test(object):
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s2 = '''\
class test:
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s3 = '''\
import leoNodes
p1 = leoNodes.position(None,[])
p2 = leoNodes.position(None,[])'''

for s in (s1,s2,s3):
    t1 = timeit.Timer(stmt='p1==p2',setup=s).timeit()
    t2 = timeit.Timer(stmt='p1.equal(p2)',setup=s).timeit()
    print "%2.2f,%2.2f,%0.2f" % (t1,t2,t1/t2)
</t>
<t tx="ekr.20040327105955">import os

path = r"c:\prog\test\unittest\createdFile.txt"

s = r"c:\python23\python c:\prog\LeoCVS\leo\src\leo.py -script c:\prog\test\unittest\batchTest.py"

print '-'*10
if os.path.exists(path):
    print "deleting",path
    os.remove(path)

os.system(s)

assert(os.path.exists(path))
print "done"</t>
<t tx="ekr.20040327114250"># A file to be executed in batch mode as part of unit testing.

@language python
@tabwidth -4

path = r"c:\prog\test\unittest\createdFile.txt"
f = None
try:
    f = open(path,"w")
    f.write("This is a test")
finally:
    if f: f.close()</t>
<t tx="ekr.20040327115825"></t>
<t tx="ekr.20040327115825.1">@color

import unittest
import leoTest
reload(leoTest) # Allows us to rerun this script when leoTest.py changes.

# Make sure this is the selected node.
u = leoTest.testUtils()
p = u.findUnitTestNode("batchModeTests")
p.c.selectVnode(p)

suite = leoTest.makeBatchModeSuite()
unittest.TextTestRunner().run(suite)</t>
<t tx="ekr.20040327115832.1">def makeBatchModeSuite (*args,**keys):
    
    """Create a colorizer test for every descendant of testParentHeadline.."""
    
    return unittest.makeSuite(batchModeTestCase,'test')</t>
<t tx="ekr.20040327115832.2">class batchModeTestCase(unittest.TestCase):
    
    """unit tests for batch mode (--script)."""
    
    @others</t>
<t tx="ekr.20040327120228">def test_1 (self):

    path = r"c:\prog\test\unittest\createdFile.txt"
    
    s = r"c:\python23\python c:\prog\LeoCVS\leo\src\leo.py -script c:\prog\test\unittest\batchTest.py"
    
    if os.path.exists(path):
        os.remove(path)
    
    os.system(s)
    
    assert(os.path.exists(path))</t>
<t tx="ekr.20040330095252">import leoGlobals as g
c = g.top()
t = c.frame.log.logCtrl
print t
t.delete("1.0","end")</t>
<t tx="ekr.20040330103006">@ignore
@language c

oblk[1] = b64[((iblk[0] &amp; 0x03) &lt;&lt; 4) |
((iblk[1] &amp; 0xF0) &gt;&gt; 4)];
oblk[2] = b64[((iblk[1] &amp; 0x0F) &lt;&lt; 2) |
((iblk[2] &amp; 0xC0) &gt;&gt; 6)];
</t>
<t tx="ekr.20040401104620">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20040401111417"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20040401113911">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20040402043516">@ a doc
part.
@c

"""A script to reformat non-leading whitespace."""

import leoGlobals as g

import tokenize,token

@others

c = g.top()

print '-'*50

if 1:
    # Just print the present position.
    prettyPrintNode(c.currentPosition())
else:
    # Print all top-level nodes.
    for p in c.rootPosition().self_and_siblings_iter():
        prettyPrintNode(p)
        
print
print '-'*50</t>
<t tx="ekr.20040402064301">class prettyPrinter:
    
    @others</t>
<t tx="ekr.20040402064301.1">def __init__ (self,p):
    
    self.line = 0
    self.lines = []
    self.col = 0
    self.array = []
    self.parenLevel = 0
    self.bracketLevel = 0
    self.p = p</t>
<t tx="ekr.20040402072335">def put (self,s,strip=True):
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # We aren't stripping all leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20040402074431">def putNormalToken (self,token5tuple):

    a = self.array
    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4 ; line = str(t5)
    name = token.tok_name[t1].lower()
    val = str(t2)
    startLine = self.line != srow
    self.line = srow

    if startLine:
        ws = line[0:scol]
        if ws: a.append(ws)

    if name in ("nl","newline","endmarker"):
        if name in ("nl","newline"):
            a.append('\n')
        # else: a.append("&lt;END NODE&gt;")
        self.lines.append(''.join(self.array))
        self.array = []
    elif name == "op":
        self.putOperator(val)
    elif name == "name":
        a.append("%s " % val)
    elif name in ("comment","string","number"):
        a.append(val)
    elif name == "errortoken":
        if val == '@' and startLine:
            # Preserve whitespace after leading @.
            i = g.skip_ws(line,1)
            a.append(line[0:i])
        else:
            a.append(val)
    elif name == "indent":
        a.append(val)
    elif name == "dedent":
        pass
    else:
        print "unknown: %s" % (name)</t>
<t tx="ekr.20040402074431.1">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4 ; line = str(t5)
    name = token.tok_name[t1].lower()
    val = str(t2)

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20040402080311">def putToken (self,token5tuple):
    
    if 1:
        self.putNormalToken(token5tuple)
    else:
        self.dumpToken(token5tuple)</t>
<t tx="ekr.20040402081135">def putOperator (self,val):
    
    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel &gt; 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel &gt; 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)</t>
<t tx="ekr.20040402084155">def prettyPrintNode(p):

    s = p.bodyString()
    if not s: return
    
    print '-'*10, p.headString()

    pp = prettyPrinter(p)
    
    readlines = g.readLinesGenerator(s).next

    for token5tuple in tokenize.generate_tokens(readlines):
        pp.putToken(token5tuple)
        
    lines = pp.get()
    
    # Note: we could replace p's body text here.

    if 1:
        print ''.join(lines), # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20040402093822">def get (self):
    
    return self.lines</t>
<t tx="ekr.20040409140301"></t>
<t tx="ekr.20040409140301.1"></t>
<t tx="ekr.20040409140301.2"></t>
<t tx="ekr.20040409140301.3"></t>
<t tx="ekr.20040409140343"></t>
<t tx="ekr.20040409140343.1"></t>
<t tx="ekr.20040409142028"></t>
<t tx="ekr.20040409142028.1"></t>
<t tx="ekr.20040409142108"></t>
<t tx="ekr.20040409142108.1"></t>
<t tx="ekr.20040414082806"></t>
<t tx="ekr.20040419105536">@ignore
@language perl

@others</t>
<t tx="ekr.20040419105536.1">line 1</t>
<t tx="ekr.20040419105536.2">line 2</t>
</tnodes>
</leo_file>
