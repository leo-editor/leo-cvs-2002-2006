<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet ekr_stylesheet?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="7869" clone_windows="0"/>
<globals body_outline_ratio="0.593037214886">
	<global_window_position top="62" left="184" height="833" width="959"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences/>
<find_panel_settings/>
<vnodes>
<v t="ekr.20041001211817" a="TV" annotate="7d71002e"><vh>Buttons &amp; settings</vh>
<v t="ekr.20051020124457"><vh>Disabled buttons</vh>
<v t="ekr.20041230121429"><vh>@@ button pydoc</vh></v>
<v t="ekr.20050210180937"><vh>@@ button jython</vh></v>
<v t="ekr.20050704170739"><vh>@@button Ipython</vh></v>
<v t="ekr.20050821072028"><vh>@@button Lines Up</vh>
<v t="ekr.20050821072028.1"><vh>moveLinesUp</vh></v>
</v>
<v t="ekr.20050821081021"><vh>@@button Lines Down</vh>
<v t="ekr.20050821081021.1" a="M"><vh>moveLinesDown</vh></v>
</v>
<v t="ekr.20050930124917"><vh>@@button outlineToClipboard</vh></v>
</v>
<v t="ekr.20041001194357"><vh>@button Unit Test</vh></v>
<v t="ekr.20051025070722"><vh>@button Beautify</vh></v>
<v t="ekr.20051105114247"><vh>@button scripts.leo</vh></v>
<v t="ekr.20051025091355"><vh>@button Spell</vh></v>
<v t="ekr.20050911112310"><vh>@button Save</vh></v>
</v>
<v t="ekr.20051104081824"><vh>Tests</vh>
<v t="ekr.20051017093427"><vh>Test of remove-blank-lines</vh></v>
<v t="ekr.20051103112555"><vh>Test of event_generate</vh></v>
<v t="ekr.20051104052708"><vh>Test of executing a function by name</vh></v>
<v t="ekr.20051107115327"><vh>Move to root</vh></v>
<v t="ekr.20051109023647"><vh>New tabbed log</vh></v>
<v t="ekr.20051108102719"><vh>Test backward search</vh>
<v t="ekr.20051108102719.1"><vh>a</vh></v>
<v t="ekr.20051108102719.2"><vh>b</vh></v>
<v t="ekr.20051108102719.3"><vh>c</vh></v>
<v t="ekr.20051108111341"><vh>test</vh></v>
</v>
</v>
<v t="ekr.20051111114555"><vh>Subprocess tests</vh>
<v t="ekr.20051112134206.1"><vh>subprocess.py (For study, but not very helpful)</vh>
<v t="ekr.20051112134206.2"><vh>&lt;&lt; about this module &gt;&gt;</vh></v>
<v t="ekr.20051112134206.3"><vh>&lt;&lt;imports &gt;&gt;</vh></v>
<v t="ekr.20051112135040"><vh>&lt;&lt; globals &gt;&gt;</vh></v>
<v t="ekr.20051112134206.8"><vh>_cleanup</vh></v>
<v t="ekr.20051112134206.9"><vh>call</vh></v>
<v t="ekr.20051112134206.10"><vh>list2cmdline</vh></v>
<v t="ekr.20051112134206.11"><vh>class Popen</vh>
<v t="ekr.20051112134206.12"><vh>__init__</vh></v>
<v t="ekr.20051112134206.13"><vh>_translate_newlines</vh></v>
<v t="ekr.20051112135040.2" a="E"><vh>&lt;&lt; Windows methods &gt;&gt;</vh>
<v t="ekr.20051112134206.14"><vh>_get_handles</vh></v>
<v t="ekr.20051112135040.3"><vh>_make_inheritable</vh></v>
<v t="ekr.20051112135040.4"><vh>_find_w9xpopen</vh></v>
<v t="ekr.20051112135040.5"><vh>_execute_child</vh></v>
<v t="ekr.20051112135040.6"><vh>poll</vh></v>
<v t="ekr.20051112135040.7"><vh>wait</vh></v>
<v t="ekr.20051112135040.8"><vh>_readerthread</vh></v>
<v t="ekr.20051112135040.9"><vh>communicate</vh></v>
</v>
<v t="ekr.20051112135040.12"><vh>&lt;&lt; POSIX methods &gt;&gt;</vh>
<v t="ekr.20051112134206.15"><vh>_get_handles</vh></v>
<v t="ekr.20051112135040.13"><vh>_set_cloexec_flag</vh></v>
<v t="ekr.20051112135040.14"><vh>_close_fds</vh></v>
<v t="ekr.20051112135040.15"><vh>_execute_child</vh></v>
<v t="ekr.20051112135040.16"><vh>_handle_exitstatus</vh></v>
<v t="ekr.20051112135040.17"><vh>poll</vh></v>
<v t="ekr.20051112135040.18"><vh>wait</vh></v>
<v t="ekr.20051112135040.19"><vh>communicate</vh></v>
</v>
</v>
<v t="ekr.20051112134206.16"><vh>_demo_posix</vh></v>
<v t="ekr.20051112134206.17"><vh>_demo_windows</vh></v>
</v>
<v t="ekr.20051111143349.29"><vh>class debugCommandsClass (not used yet)</vh>
<v t="ekr.20051111143349.30"><vh> ctor</vh></v>
<v t="ekr.20051111143349.31"><vh>getPublicCommands (debugCommandsClass)</vh></v>
<v t="ekr.20051111143349.33"><vh>openDebugTab</vh></v>
<v t="ekr.20051111143349.20"><vh>hideTab</vh></v>
</v>
<v t="ekr.20051111114555.1"><vh>@thin leoDebugger.py</vh></v>
<v t="ekr.20051111114555.2"><vh>@button dbProc</vh>
<v t="ekr.20051111145211.1"><vh>openDebugTab</vh></v>
<v t="ekr.20051111143349.1" a="E"><vh>class debugTab</vh>
<v t="ekr.20051111143349.2"><vh>Birth &amp; death</vh>
<v t="ekr.20051111143349.3" a="E"><vh>__init__</vh>
<v t="ekr.20051111143349.7"><vh>&lt;&lt; Create the outer frames &gt;&gt;</vh></v>
<v t="ekr.20051111143922"><vh>&lt;&lt; create buttons &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20051111143349.16" a="E"><vh>callbacks</vh>
<v t="ekr.20051111145134"><vh>askButtonCallback</vh></v>
<v t="ekr.20051111145134.1"><vh>killButtonCallback</vh></v>
<v t="ekr.20051111145134.2"><vh>runButtonCallback</vh></v>
<v t="ekr.20051111145134.3"><vh>tellButtonCallback</vh></v>
</v>
<v t="ekr.20051111151132"><vh>get &amp; send</vh></v>
<v t="ekr.20051111162912"><vh>nonBlockingRead</vh></v>
<v t="ekr.20051111153206"><vh>stdinClass (not used)</vh></v>
</v>
</v>
</v>
<v t="ekr.20051113055640" a="E"><vh>Find bug</vh>
<v t="ekr.20051113055640.1"><vh>Report</vh></v>
<v t="ekr.20051113055640.2"><vh>This is a sample node</vh></v>
<v t="ekr.20051113055640.3" a="E"><vh>@thin findBug.txt</vh></v>
</v>
</vnodes>
<tnodes>
<t tx="ekr.20041001194357"># You can run all tests by selecting the Unit Test headline.

import leoTest

leoTest.doTests(all=False)</t>
<t tx="ekr.20041001211817"></t>
<t tx="ekr.20041230121429">import os, sys, threading

python = sys.executable
pythonDir,junk = g.os_path_split(python)
pydoc = g.os_path_join(pythonDir,'Lib','pydoc.py')
command = '%s %s -g' % (python,pydoc)

# Execute the command in a separate thread.
def go():
    os.system(command)
    
threading.Thread(target=go).start()</t>
<t tx="ekr.20050210180937"># **** Change these as needed ***
import os, sys

tempFileName = g.os_path_abspath(
    g.os_path_join(g.app.testDir,'jythonScript.py'))

if sys.platform == 'win32':
    jython = r'C:\Jython-21\jython.bat'
    command = '%s "%s"' % (jython,tempFileName) 
else:
    jython = r'cd ~/jython-2.1 ; ./jython'
    command = '%s "%s" &amp;' % (jython,tempFileName)

script = g.getScript(c,p).strip()
if not script:
    s = "no script in %s" % p.headString()
    g.es(s) ; print s
else:
    f = file(tempFileName,'w')
    f.write(script + '\n')
    f.close()
    print command
    os.system(command)
</t>
<t tx="ekr.20050704170739">from IPython.Shell import IPShellEmbed

ipshell = IPShellEmbed()
ipshell()</t>
<t tx="ekr.20050821072028"># Move selected text of the body up one line.

@others

moveLinesUp(c,p)</t>
<t tx="ekr.20050821072028.1">def moveLinesUp(c,p):
    
    undoType = 'Move Lines Up'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not head or not lines: return
    # A slight adjustment: lines doesn't end in '\n'.
    head = g.splitLines(head)
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines up.
    lines.append(head[-1])
    head = head[:-1]
    # Convert back to strings.
    head = ''.join(head)
    lines = ''.join(lines)[:-1] # Undo the adjustment above.
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)-1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)-1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050821081021"># Move selected text of the body down one line.

@others

moveLinesDown(c,p)</t>
<t tx="ekr.20050821081021.1">def moveLinesDown(c,p):
    
    undoType = 'Move Lines Down'
    head,lines,tail,oldSel,oldYview = c.getBodyLines()
    if not tail or not lines: return
    tail = g.splitLines(tail)[1:]
    lines = '\n'.join(lines) + '\n'
    lines = g.splitLines(lines)
    # Move the lines down.
    lines.insert(0,tail[0])
    tail = tail[1:]
    if not tail: lines.insert(1,'\n')
    # Convert back to strings.
    tail = ''.join(tail)
    lines = ''.join(lines)
    # Adjust selection.
    sel1,sel2 = oldSel
    row,col = sel1.split('.') ; sel1 = '%d.%s' % (int(row)+1,col)
    row,col = sel2.split('.') ; sel2 = '%d.%s' % (int(row)+1,col)
    newSel = sel1,sel2
    c.updateBodyPane(head,lines,tail,undoType,newSel,oldYview)</t>
<t tx="ekr.20050911112310">c.save()
c.redraw_now() # Must be done here.</t>
<t tx="ekr.20050930124917">result = []
firstLevel = p.level()

for p in p.self_and_subtree_iter():
    head = p.moreHead(firstLevel)
    head = g.toEncodedString(head,'ascii',reportErrors=True)
    result.append(head)
    body = p.moreBody() # Inserts escapes for '+' and '-' characters.
    if body:
        body = g.toEncodedString(body,'ascii',reportErrors=True)
        result.append(body)

result = '\n'.join(result) + '\n'
# print result
w = c.frame.body.bodyCtrl
w.clipboard_clear()
w.clipboard_append(result)</t>
<t tx="ekr.20051017093427">a
 
b

c
d

e

This is a test of navigation.</t>
<t tx="ekr.20051020124457"></t>
<t tx="ekr.20051025070722">c.prettyPrintPythonNode()</t>
<t tx="ekr.20051025091355">c.spellCommands.openSpellTab()
</t>
<t tx="ekr.20051103112555">#w = event and event.widget
k = c.keyHandler

commandName = 'open-find-tab'
w = c.frame.body.bodyCtrl
    
shortcut = k.getShortcutForCommandName(commandName)
bind_shortcut, menu_shortcut = c.frame.menu.canonicalizeShortcut(shortcut)

g.trace(repr(shortcut),repr(bind_shortcut))
    
# w.event_generate('&lt;Key&gt;',keysym=bind_shortcut)</t>
<t tx="ekr.20051104052708">c.executeMinibufferCommand('open-outline')</t>
<t tx="ekr.20051104081824"></t>
<t tx="ekr.20051105114247">name = "scripts.leo"
fileName = g.os_path_join(g.app.loadDir,"..","scripts",name)
ok,frame = g.openWithFileName(fileName,c)
if not ok:
    g.es("not found: %s" % name)</t>
<t tx="ekr.20051107115327">root = c.rootPosition()
if p != root:
    p.moveToRoot(root)
    c.redraw_now()</t>
<t tx="ekr.20051108102719"></t>
<t tx="ekr.20051108102719.1">alpha</t>
<t tx="ekr.20051108102719.2">beta</t>
<t tx="ekr.20051108102719.3">gamma</t>
<t tx="ekr.20051108111341">test a test</t>
<t tx="ekr.20051109023647"># import TabWindow as TabbedLog
# tw = TabbedLog.getPane('abc', c)

import Tknotebook
Tknotebook.test()</t>
<t tx="ekr.20051111114555"></t>
<t tx="ekr.20051111114555.2"># Simulation of debugger process

import subprocess
import sys
import time
import Tkinter as Tk

@others

openDebugTab(c)</t>
<t tx="ekr.20051111143349.1">class debugTab:

    """A class that implements Leo's tkinter debug tab."""

    @others</t>
<t tx="ekr.20051111143349.2"></t>
<t tx="ekr.20051111143349.3">def __init__(self,c,parentFrame):

    self.c = c
    self.db = None

    &lt;&lt; Create the outer frames &gt;&gt;
    &lt;&lt; create buttons &gt;&gt;
    </t>
<t tx="ekr.20051111143349.7">configName = 'log_pane_Debug_tab_background_color'
bg = c.config.getColor(configName) or 'MistyRose1'

parentFrame.configure(background=bg)

self.top = Tk.Frame(parentFrame,background=bg)
self.frame = Tk.Frame(self.top,background=bg)
self.outerFrame = outer = Tk.Frame(self.frame,background=bg)

self.top.pack   (side='top',expand=0,fill='x',pady=5)
    # Don't expand, so the frame goes to the top.

self.frame.pack (side="top",expand=1,fill='x')
outer.pack      (side='top',expand=1,fill='x',padx=2,pady=2,)</t>
<t tx="ekr.20051111143349.16"></t>
<t tx="ekr.20051111143349.20">def hideTab (self,event=None):
    
    c = self.c
    c.frame.log.selectTab('Log')
    c.frame.bodyWantsFocus()</t>
<t tx="ekr.20051111143349.29">if 0:
    class debugCommandsClass (baseEditCommandsClass):
    
        '''Implements debug commands.'''
    
        @others</t>
<t tx="ekr.20051111143349.30">def __init__ (self,c):

    baseEditCommandsClass.__init__(self,c) # init the base class.
    
    self.debugTabHandler = None</t>
<t tx="ekr.20051111143349.31">def getPublicCommands (self):
    
    return {
        # The new find tab replaces the find dialog.
        'hide-find-tab':    self.hideDebugTab,
        'open-debug-tab':   self.openDebugTab,
    }</t>
<t tx="ekr.20051111143349.33">def openDebugTab (self,event=None):

    c = self.c ; log = c.frame.log ; tabName = 'Debug'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        self.debugTabHandler = debugTab(c,f)</t>
<t tx="ekr.20051111143922">buttons  = Tk.Frame(outer,background=bg)
buttons.pack(side='top',expand=1)

width = 10

for text,callback in (
    ('Run', self.runButtonCallback),
    ('Kill',self.killButtonCallback),
    ('Ask', self.askButtonCallback),
    ('Tell',self.tellButtonCallback),
):
    w = Tk.Button(buttons,text=text,command=callback)
    w.configure(width=width)
    w.pack(side='left',anchor='w',pady=2,padx=2)</t>
<t tx="ekr.20051111145134">def askButtonCallback (self,event=None):

    __pychecker__ = '--no-argsused'

    self.send('ask')
    print 'ask returns', self.get()

    return 'break'</t>
<t tx="ekr.20051111145134.1">def killButtonCallback (self,event=None):

    __pychecker__ = '--no-argsused'

    self.send('kill')

    if self.db:
        self.db.wait()
        self.db = None
        print ; print 'done!'

    return 'break'</t>
<t tx="ekr.20051111145134.2">def runButtonCallback (self,event=None):

    __pychecker__ = '--no-argsused'

    g.trace()

    dbPath = g.os_path_join('..','test','leoDebugger.py')
    args = [r"c:\python24\python", dbPath]
    pipe = subprocess.PIPE
    
    if self.db:
        g.trace('already running')
    else:
        self.db = subprocess.Popen(args,
            stdin=pipe,
            stdout=pipe, ## sys.stdout
            stderr=sys.stderr,
        )
        # stdout, stderr = self.db.communicate(s)

    return 'break'
</t>
<t tx="ekr.20051111145134.3">def tellButtonCallback(self,event=None):
    
    __pychecker__ = '--no-argsused'
    
    self.send('tell')

    return 'break'</t>
<t tx="ekr.20051111145211.1">def openDebugTab (c):

    log = c.frame.log ; tabName = 'Debug'

    if log.frameDict.get(tabName):
        log.selectTab(tabName)
    else:
        log.selectTab(tabName)
        f = log.frameDict.get(tabName)
        t = log.textDict.get(tabName)
        t.pack_forget()
        debugTab(c,f)</t>
<t tx="ekr.20051111151132">if 0: # Communicate waits for the process to terminate!
    stdout, stderr = self.db.communicate(s)

def get(self):
    
    if self.db:
        # Busy waiting:
        while 1:
            time.sleep(0.4)
            s = self.nonBlockingRead(self.db.stdout)
            if s:
                return s
            else:
                g.trace('waiting for ask')
    else:
        g.trace('not running')
        return ''

def send(self,s):

    if self.db:
       self.db.stdin.write(s)
    else:
        g.trace('not running')</t>
<t tx="ekr.20051111153206">class stdinClass:
    
    '''A class for controlled stdin.'''
    
    def __init__ (self):
        self.s = ''
        
    def write (self,s):
        self.s = s
        
    def readline(self):
        s = self.s
        self.s = ''
        return s</t>
<t tx="ekr.20051111162912">def nonBlockingRead(self,f):
    
    f.seek(0,0) ; p1 = f.tell() # p1 is present position.
    f.seek(0,2) ; p2 = f.tell() # p2 is end position.

    if p2 &gt; p1:
        f.seek(p1,0) # Restore point
        s = f.read(p2-p1)
        f.seek(0,2) # Move to the end.
    else:
        s = ''

    return s</t>
<t tx="ekr.20051112134206.1">@language python
@tabwidth -4

&lt;&lt; about this module &gt;&gt;
&lt;&lt; imports &gt;&gt;
&lt;&lt; globals &gt;&gt;

@others

if __name__ == "__main__":
    if mswindows:
        _demo_windows()
    else:
        _demo_posix()
</t>
<t tx="ekr.20051112134206.2"># subprocess - Subprocesses with accessible I/O streams
#
# For more information about this module, see PEP 324.
#
# Copyright (c) 2003-2004 by Peter Astrand &lt;astrand@lysator.liu.se&gt;
#
# By obtaining, using, and/or copying this software and/or its
# associated documentation, you agree that you have read, understood,
# and will comply with the following terms and conditions:
#
# Permission to use, copy, modify, and distribute this software and
# its associated documentation for any purpose and without fee is
# hereby granted, provided that the above copyright notice appears in
# all copies, and that both that copyright notice and this permission
# notice appear in supporting documentation, and that the name of the
# author not be used in advertising or publicity pertaining to
# distribution of the software without specific, written prior
# permission.
#
# THE AUTHOR DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,
# INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS.
# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, INDIRECT OR
# CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS
# OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT,
# NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION
# WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

r"""subprocess - Subprocesses with accessible I/O streams

This module allows you to spawn processes, connect to their
input/output/error pipes, and obtain their return codes.  This module
intends to replace several other, older modules and functions, like:

os.system
os.spawn*
os.popen*
popen2.*
commands.*

Information about how the subprocess module can be used to replace these
modules and functions can be found below.



Using the subprocess module
===========================
This module defines one class called Popen:

class Popen(args, bufsize=0, executable=None,
            stdin=None, stdout=None, stderr=None,
            preexec_fn=None, close_fds=False, shell=False,
            cwd=None, env=None, universal_newlines=False,
            startupinfo=None, creationflags=0):


Arguments are:

args should be a string, or a sequence of program arguments.  The
program to execute is normally the first item in the args sequence or
string, but can be explicitly set by using the executable argument.

On UNIX, with shell=False (default): In this case, the Popen class
uses os.execvp() to execute the child program.  args should normally
be a sequence.  A string will be treated as a sequence with the string
as the only item (the program to execute).

On UNIX, with shell=True: If args is a string, it specifies the
command string to execute through the shell.  If args is a sequence,
the first item specifies the command string, and any additional items
will be treated as additional shell arguments.

On Windows: the Popen class uses CreateProcess() to execute the child
program, which operates on strings.  If args is a sequence, it will be
converted to a string using the list2cmdline method.  Please note that
not all MS Windows applications interpret the command line the same
way: The list2cmdline is designed for applications using the same
rules as the MS C runtime.

bufsize, if given, has the same meaning as the corresponding argument
to the built-in open() function: 0 means unbuffered, 1 means line
buffered, any other positive value means use a buffer of
(approximately) that size.  A negative bufsize means to use the system
default, which usually means fully buffered.  The default value for
bufsize is 0 (unbuffered).

stdin, stdout and stderr specify the executed programs' standard
input, standard output and standard error file handles, respectively.
Valid values are PIPE, an existing file descriptor (a positive
integer), an existing file object, and None.  PIPE indicates that a
new pipe to the child should be created.  With None, no redirection
will occur; the child's file handles will be inherited from the
parent.  Additionally, stderr can be STDOUT, which indicates that the
stderr data from the applications should be captured into the same
file handle as for stdout.

If preexec_fn is set to a callable object, this object will be called
in the child process just before the child is executed.

If close_fds is true, all file descriptors except 0, 1 and 2 will be
closed before the child process is executed.

if shell is true, the specified command will be executed through the
shell.

If cwd is not None, the current directory will be changed to cwd
before the child is executed.

If env is not None, it defines the environment variables for the new
process.

If universal_newlines is true, the file objects stdout and stderr are
opened as a text files, but lines may be terminated by any of '\n',
the Unix end-of-line convention, '\r', the Macintosh convention or
'\r\n', the Windows convention.  All of these external representations
are seen as '\n' by the Python program.  Note: This feature is only
available if Python is built with universal newline support (the
default).  Also, the newlines attribute of the file objects stdout,
stdin and stderr are not updated by the communicate() method.

The startupinfo and creationflags, if given, will be passed to the
underlying CreateProcess() function.  They can specify things such as
appearance of the main window and priority for the new process.
(Windows only)


This module also defines two shortcut functions:

call(*args, **kwargs):
    Run command with arguments.  Wait for command to complete, then
    return the returncode attribute.

    The arguments are the same as for the Popen constructor.  Example:

    retcode = call(["ls", "-l"])


Exceptions
----------
Exceptions raised in the child process, before the new program has
started to execute, will be re-raised in the parent.  Additionally,
the exception object will have one extra attribute called
'child_traceback', which is a string containing traceback information
from the childs point of view.

The most common exception raised is OSError.  This occurs, for
example, when trying to execute a non-existent file.  Applications
should prepare for OSErrors.

A ValueError will be raised if Popen is called with invalid arguments.


Security
--------
Unlike some other popen functions, this implementation will never call
/bin/sh implicitly.  This means that all characters, including shell
metacharacters, can safely be passed to child processes.


Popen objects
=============
Instances of the Popen class have the following methods:

poll()
    Check if child process has terminated.  Returns returncode
    attribute.

wait()
    Wait for child process to terminate.  Returns returncode attribute.

communicate(input=None)
    Interact with process: Send data to stdin.  Read data from stdout
    and stderr, until end-of-file is reached.  Wait for process to
    terminate.  The optional stdin argument should be a string to be
    sent to the child process, or None, if no data should be sent to
    the child.

    communicate() returns a tuple (stdout, stderr).

    Note: The data read is buffered in memory, so do not use this
    method if the data size is large or unlimited.

The following attributes are also available:

stdin
    If the stdin argument is PIPE, this attribute is a file object
    that provides input to the child process.  Otherwise, it is None.

stdout
    If the stdout argument is PIPE, this attribute is a file object
    that provides output from the child process.  Otherwise, it is
    None.

stderr
    If the stderr argument is PIPE, this attribute is file object that
    provides error output from the child process.  Otherwise, it is
    None.

pid
    The process ID of the child process.

returncode
    The child return code.  A None value indicates that the process
    hasn't terminated yet.  A negative value -N indicates that the
    child was terminated by signal N (UNIX only).


Replacing older functions with the subprocess module
====================================================
In this section, "a ==&gt; b" means that b can be used as a replacement
for a.

Note: All functions in this section fail (more or less) silently if
the executed program cannot be found; this module raises an OSError
exception.

In the following examples, we assume that the subprocess module is
imported with "from subprocess import *".


Replacing /bin/sh shell backquote
---------------------------------
output=`mycmd myarg`
==&gt;
output = Popen(["mycmd", "myarg"], stdout=PIPE).communicate()[0]


Replacing shell pipe line
-------------------------
output=`dmesg | grep hda`
==&gt;
p1 = Popen(["dmesg"], stdout=PIPE)
p2 = Popen(["grep", "hda"], stdin=p1.stdout)
output = p2.communicate()[0]


Replacing os.system()
---------------------
sts = os.system("mycmd" + " myarg")
==&gt;
p = Popen("mycmd" + " myarg", shell=True)
sts = os.waitpid(p.pid, 0)

Note:

* Calling the program through the shell is usually not required.

* It's easier to look at the returncode attribute than the
  exitstatus.

A more real-world example would look like this:

try:
    retcode = call("mycmd" + " myarg", shell=True)
    if retcode &lt; 0:
        print &gt;&gt;sys.stderr, "Child was terminated by signal", -retcode
    else:
        print &gt;&gt;sys.stderr, "Child returned", retcode
except OSError, e:
    print &gt;&gt;sys.stderr, "Execution failed:", e


Replacing os.spawn*
-------------------
P_NOWAIT example:

pid = os.spawnlp(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg")
==&gt;
pid = Popen(["/bin/mycmd", "myarg"]).pid


P_WAIT example:

retcode = os.spawnlp(os.P_WAIT, "/bin/mycmd", "mycmd", "myarg")
==&gt;
retcode = call(["/bin/mycmd", "myarg"])


Vector example:

os.spawnvp(os.P_NOWAIT, path, args)
==&gt;
Popen([path] + args[1:])


Environment example:

os.spawnlpe(os.P_NOWAIT, "/bin/mycmd", "mycmd", "myarg", env)
==&gt;
Popen(["/bin/mycmd", "myarg"], env={"PATH": "/usr/bin"})


Replacing os.popen*
-------------------
pipe = os.popen(cmd, mode='r', bufsize)
==&gt;
pipe = Popen(cmd, shell=True, bufsize=bufsize, stdout=PIPE).stdout

pipe = os.popen(cmd, mode='w', bufsize)
==&gt;
pipe = Popen(cmd, shell=True, bufsize=bufsize, stdin=PIPE).stdin


(child_stdin, child_stdout) = os.popen2(cmd, mode, bufsize)
==&gt;
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdin, child_stdout) = (p.stdin, p.stdout)


(child_stdin,
 child_stdout,
 child_stderr) = os.popen3(cmd, mode, bufsize)
==&gt;
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, stderr=PIPE, close_fds=True)
(child_stdin,
 child_stdout,
 child_stderr) = (p.stdin, p.stdout, p.stderr)


(child_stdin, child_stdout_and_stderr) = os.popen4(cmd, mode, bufsize)
==&gt;
p = Popen(cmd, shell=True, bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, stderr=STDOUT, close_fds=True)
(child_stdin, child_stdout_and_stderr) = (p.stdin, p.stdout)


Replacing popen2.*
------------------
Note: If the cmd argument to popen2 functions is a string, the command
is executed through /bin/sh.  If it is a list, the command is directly
executed.

(child_stdout, child_stdin) = popen2.popen2("somestring", bufsize, mode)
==&gt;
p = Popen(["somestring"], shell=True, bufsize=bufsize
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdout, child_stdin) = (p.stdout, p.stdin)


(child_stdout, child_stdin) = popen2.popen2(["mycmd", "myarg"], bufsize, mode)
==&gt;
p = Popen(["mycmd", "myarg"], bufsize=bufsize,
          stdin=PIPE, stdout=PIPE, close_fds=True)
(child_stdout, child_stdin) = (p.stdout, p.stdin)

The popen2.Popen3 and popen3.Popen4 basically works as subprocess.Popen,
except that:

* subprocess.Popen raises an exception if the execution fails
* the capturestderr argument is replaced with the stderr argument.
* stdin=PIPE and stdout=PIPE must be specified.
* popen2 closes all filedescriptors by default, but you have to specify
  close_fds=True with subprocess.Popen.
"""</t>
<t tx="ekr.20051112134206.3">import sys
mswindows = (sys.platform == "win32")

import os
import types
import traceback

if mswindows:
    import threading
    import msvcrt
    if 0: # &lt;-- change this to use pywin32 instead of the _subprocess driver
        import pywintypes
        from win32api import GetStdHandle, STD_INPUT_HANDLE, \
                             STD_OUTPUT_HANDLE, STD_ERROR_HANDLE
        from win32api import GetCurrentProcess, DuplicateHandle, \
                             GetModuleFileName, GetVersion
        from win32con import DUPLICATE_SAME_ACCESS, SW_HIDE
        from win32pipe import CreatePipe
        from win32process import CreateProcess, STARTUPINFO, \
                                 GetExitCodeProcess, STARTF_USESTDHANDLES, \
                                 STARTF_USESHOWWINDOW, CREATE_NEW_CONSOLE
        from win32event import WaitForSingleObject, INFINITE, WAIT_OBJECT_0
    else:
        from _subprocess import *
        
        class STARTUPINFO:
            dwFlags = 0
            hStdInput = None
            hStdOutput = None
            hStdError = None
        class pywintypes:
            error = IOError
else:
    import select
    import errno
    import fcntl
    import pickle</t>
<t tx="ekr.20051112134206.8">def _cleanup():

    for inst in _active[:]:
        inst.poll()
</t>
<t tx="ekr.20051112134206.9">PIPE = -1
STDOUT = -2

def call(*args, **kwargs):
    """Run command with arguments.  Wait for command to complete, then
    return the returncode attribute.

    The arguments are the same as for the Popen constructor.  Example:

    retcode = call(["ls", "-l"])
    """
    return Popen(*args, **kwargs).wait()</t>
<t tx="ekr.20051112134206.10">def list2cmdline(seq):
    """
    Translate a sequence of arguments into a command line
    string, using the same rules as the MS C runtime:

    1) Arguments are delimited by white space, which is either a
       space or a tab.

    2) A string surrounded by double quotation marks is
       interpreted as a single argument, regardless of white space
       contained within.  A quoted string can be embedded in an
       argument.

    3) A double quotation mark preceded by a backslash is
       interpreted as a literal double quotation mark.

    4) Backslashes are interpreted literally, unless they
       immediately precede a double quotation mark.

    5) If backslashes immediately precede a double quotation mark,
       every pair of backslashes is interpreted as a literal
       backslash.  If the number of backslashes is odd, the last
       backslash escapes the next double quotation mark as
       described in rule 3.
    """

    # See
    # http://msdn.microsoft.com/library/en-us/vccelng/htm/progs_12.asp
    result = []
    needquote = False
    for arg in seq:
        bs_buf = []

        # Add a space to separate this argument from the others
        if result:
            result.append(' ')

        needquote = (" " in arg) or ("\t" in arg)
        if needquote:
            result.append('"')

        for c in arg:
            if c == '\\':
                # Don't know if we need to double yet.
                bs_buf.append(c)
            elif c == '"':
                # Double backspaces.
                result.append('\\' * len(bs_buf)*2)
                bs_buf = []
                result.append('\\"')
            else:
                # Normal char
                if bs_buf:
                    result.extend(bs_buf)
                    bs_buf = []
                result.append(c)

        # Add remaining backspaces, if any.
        if bs_buf:
            result.extend(bs_buf)

        if needquote:
            result.append('"')

    return ''.join(result)
</t>
<t tx="ekr.20051112134206.11">class Popen(object):
    
	@others

    if mswindows:
        &lt;&lt; Windows methods &gt;&gt;
    else:
        &lt;&lt; POSIX methods &gt;&gt;</t>
<t tx="ekr.20051112134206.12">def __init__(self, args, bufsize=0, executable=None,
             stdin=None, stdout=None, stderr=None,
             preexec_fn=None, close_fds=False, shell=False,
             cwd=None, env=None, universal_newlines=False,
             startupinfo=None, creationflags=0):
    """Create new Popen instance."""
    _cleanup()

    if mswindows:
        if preexec_fn is not None:
            raise ValueError("preexec_fn is not supported on Windows "
                             "platforms")
        if close_fds:
            raise ValueError("close_fds is not supported on Windows "
                             "platforms")
    else:
        # POSIX
        if startupinfo is not None:
            raise ValueError("startupinfo is only supported on Windows "
                             "platforms")
        if creationflags != 0:
            raise ValueError("creationflags is only supported on Windows "
                             "platforms")

    self.stdin = None
    self.stdout = None
    self.stderr = None
    self.pid = None
    self.returncode = None
    self.universal_newlines = universal_newlines

    # Input and output objects. The general principle is like
    # this:
    #
    # Parent                   Child
    # ------                   -----
    # p2cwrite   ---stdin---&gt;  p2cread
    # c2pread    &lt;--stdout---  c2pwrite
    # errread    &lt;--stderr---  errwrite
    #
    # On POSIX, the child objects are file descriptors.  On
    # Windows, these are Windows file handles.  The parent objects
    # are file descriptors on both platforms.  The parent objects
    # are None when not using PIPEs. The child objects are None
    # when not redirecting.

    (p2cread, p2cwrite,
     c2pread, c2pwrite,
     errread, errwrite) = self._get_handles(stdin, stdout, stderr)

    self._execute_child(args, executable, preexec_fn, close_fds,
                        cwd, env, universal_newlines,
                        startupinfo, creationflags, shell,
                        p2cread, p2cwrite,
                        c2pread, c2pwrite,
                        errread, errwrite)

    if p2cwrite:
        self.stdin = os.fdopen(p2cwrite, 'wb', bufsize)
    if c2pread:
        if universal_newlines:
            self.stdout = os.fdopen(c2pread, 'rU', bufsize)
        else:
            self.stdout = os.fdopen(c2pread, 'rb', bufsize)
    if errread:
        if universal_newlines:
            self.stderr = os.fdopen(errread, 'rU', bufsize)
        else:
            self.stderr = os.fdopen(errread, 'rb', bufsize)

    _active.append(self)
</t>
<t tx="ekr.20051112134206.13">def _translate_newlines(self, data):
    
    data = data.replace("\r\n", "\n")
    data = data.replace("\r", "\n")
    return data
</t>
<t tx="ekr.20051112134206.14">def _get_handles(self, stdin, stdout, stderr):
    """Construct and return tupel with IO objects:
    p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
    """
    if stdin == None and stdout == None and stderr == None:
        return (None, None, None, None, None, None)

    p2cread, p2cwrite = None, None
    c2pread, c2pwrite = None, None
    errread, errwrite = None, None

    if stdin == None:
        p2cread = GetStdHandle(STD_INPUT_HANDLE)
    elif stdin == PIPE:
        p2cread, p2cwrite = CreatePipe(None, 0)
        # Detach and turn into fd
        p2cwrite = p2cwrite.Detach()
        p2cwrite = msvcrt.open_osfhandle(p2cwrite, 0)
    elif type(stdin) == types.IntType:
        p2cread = msvcrt.get_osfhandle(stdin)
    else:
        # Assuming file-like object
        p2cread = msvcrt.get_osfhandle(stdin.fileno())
    p2cread = self._make_inheritable(p2cread)

    if stdout == None:
        c2pwrite = GetStdHandle(STD_OUTPUT_HANDLE)
    elif stdout == PIPE:
        c2pread, c2pwrite = CreatePipe(None, 0)
        # Detach and turn into fd
        c2pread = c2pread.Detach()
        c2pread = msvcrt.open_osfhandle(c2pread, 0)
    elif type(stdout) == types.IntType:
        c2pwrite = msvcrt.get_osfhandle(stdout)
    else:
        # Assuming file-like object
        c2pwrite = msvcrt.get_osfhandle(stdout.fileno())
    c2pwrite = self._make_inheritable(c2pwrite)

    if stderr == None:
        errwrite = GetStdHandle(STD_ERROR_HANDLE)
    elif stderr == PIPE:
        errread, errwrite = CreatePipe(None, 0)
        # Detach and turn into fd
        errread = errread.Detach()
        errread = msvcrt.open_osfhandle(errread, 0)
    elif stderr == STDOUT:
        errwrite = c2pwrite
    elif type(stderr) == types.IntType:
        errwrite = msvcrt.get_osfhandle(stderr)
    else:
        # Assuming file-like object
        errwrite = msvcrt.get_osfhandle(stderr.fileno())
    errwrite = self._make_inheritable(errwrite)

    return (p2cread, p2cwrite,
            c2pread, c2pwrite,
            errread, errwrite)</t>
<t tx="ekr.20051112134206.15">def _get_handles(self, stdin, stdout, stderr):
    """Construct and return tupel with IO objects:
    p2cread, p2cwrite, c2pread, c2pwrite, errread, errwrite
    """
    p2cread, p2cwrite = None, None
    c2pread, c2pwrite = None, None
    errread, errwrite = None, None

    if stdin == None:
        pass
    elif stdin == PIPE:
        p2cread, p2cwrite = os.pipe()
    elif type(stdin) == types.IntType:
        p2cread = stdin
    else:
        # Assuming file-like object
        p2cread = stdin.fileno()

    if stdout == None:
        pass
    elif stdout == PIPE:
        c2pread, c2pwrite = os.pipe()
    elif type(stdout) == types.IntType:
        c2pwrite = stdout
    else:
        # Assuming file-like object
        c2pwrite = stdout.fileno()

    if stderr == None:
        pass
    elif stderr == PIPE:
        errread, errwrite = os.pipe()
    elif stderr == STDOUT:
        errwrite = c2pwrite
    elif type(stderr) == types.IntType:
        errwrite = stderr
    else:
        # Assuming file-like object
        errwrite = stderr.fileno()

    return (p2cread, p2cwrite,
            c2pread, c2pwrite,
            errread, errwrite)</t>
<t tx="ekr.20051112134206.16">def _demo_posix():
    #
    # Example 1: Simple redirection: Get process list
    #
    plist = Popen(["ps"], stdout=PIPE).communicate()[0]
    print "Process list:"
    print plist

    #
    # Example 2: Change uid before executing child
    #
    if os.getuid() == 0:
        p = Popen(["id"], preexec_fn=lambda: os.setuid(100))
        p.wait()

    #
    # Example 3: Connecting several subprocesses
    #
    print "Looking for 'hda'..."
    p1 = Popen(["dmesg"], stdout=PIPE)
    p2 = Popen(["grep", "hda"], stdin=p1.stdout, stdout=PIPE)
    print repr(p2.communicate()[0])

    #
    # Example 4: Catch execution error
    #
    print
    print "Trying a weird file..."
    try:
        print Popen(["/this/path/does/not/exist"]).communicate()
    except OSError, e:
        if e.errno == errno.ENOENT:
            print "The file didn't exist.  I thought so..."
            print "Child traceback:"
            print e.child_traceback
        else:
            print "Error", e.errno
    else:
        print &gt;&gt;sys.stderr, "Gosh.  No error."
</t>
<t tx="ekr.20051112134206.17">def _demo_windows():
    #
    # Example 1: Connecting several subprocesses
    #
    print "Looking for 'PROMPT' in set output..."
    p1 = Popen("set", stdout=PIPE, shell=True)
    p2 = Popen('find "PROMPT"', stdin=p1.stdout, stdout=PIPE)
    print repr(p2.communicate()[0])

    #
    # Example 2: Simple execution of program
    #
    print "Executing calc..."
    p = Popen("calc")
    p.wait()
</t>
<t tx="ekr.20051112135040">__all__ = ["Popen", "PIPE", "STDOUT", "call"]

try:
    MAXFD = os.sysconf("SC_OPEN_MAX")
except:
    MAXFD = 256

# True/False does not exist on 2.2.0
try:
    False
except NameError:
    False = 0
    True = 1

_active = []</t>
<t tx="ekr.20051112135040.2">@others</t>
<t tx="ekr.20051112135040.3">def _make_inheritable(self, handle):
    
    """Return a duplicate of handle, which is inheritable"""

    return DuplicateHandle(GetCurrentProcess(), handle,
                           GetCurrentProcess(), 0, 1,
                           DUPLICATE_SAME_ACCESS)</t>
<t tx="ekr.20051112135040.4">def _find_w9xpopen(self):
    
    """Find and return absolut path to w9xpopen.exe"""

    w9xpopen = os.path.join(os.path.dirname(GetModuleFileName(0)),
                            "w9xpopen.exe")
    if not os.path.exists(w9xpopen):
        # Eeek - file-not-found - possibly an embedding
        # situation - see if we can locate it in sys.exec_prefix
        w9xpopen = os.path.join(os.path.dirname(sys.exec_prefix),
                                "w9xpopen.exe")
        if not os.path.exists(w9xpopen):
            raise RuntimeError("Cannot locate w9xpopen.exe, which is "
                               "needed for Popen to work with your "
                               "shell or platform.")
    return w9xpopen</t>
<t tx="ekr.20051112135040.5">def _execute_child(self, args, executable, preexec_fn, close_fds,
                   cwd, env, universal_newlines,
                   startupinfo, creationflags, shell,
                   p2cread, p2cwrite,
                   c2pread, c2pwrite,
                   errread, errwrite):
    """Execute program (MS Windows version)"""

    if not isinstance(args, types.StringTypes):
        args = list2cmdline(args)

    # Process startup details
    default_startupinfo = STARTUPINFO()
    if startupinfo == None:
        startupinfo = default_startupinfo
    if not None in (p2cread, c2pwrite, errwrite):
        startupinfo.dwFlags |= STARTF_USESTDHANDLES
        startupinfo.hStdInput = p2cread
        startupinfo.hStdOutput = c2pwrite
        startupinfo.hStdError = errwrite

    if shell:
        default_startupinfo.dwFlags |= STARTF_USESHOWWINDOW
        default_startupinfo.wShowWindow = SW_HIDE
        comspec = os.environ.get("COMSPEC", "cmd.exe")
        args = comspec + " /c " + args
        if (GetVersion() &gt;= 0x80000000L or
                os.path.basename(comspec).lower() == "command.com"):
            # Win9x, or using command.com on NT. We need to
            # use the w9xpopen intermediate program. For more
            # information, see KB Q150956
            # (http://web.archive.org/web/20011105084002/http://support.microsoft.com/support/kb/articles/Q150/9/56.asp)
            w9xpopen = self._find_w9xpopen()
            args = '"%s" %s' % (w9xpopen, args)
            # Not passing CREATE_NEW_CONSOLE has been known to
            # cause random failures on win9x.  Specifically a
            # dialog: "Your program accessed mem currently in
            # use at xxx" and a hopeful warning about the
            # stability of your system.  Cost is Ctrl+C wont
            # kill children.
            creationflags |= CREATE_NEW_CONSOLE

    # Start the process
    try:
        hp, ht, pid, tid = CreateProcess(executable, args,
                                 # no special security
                                 None, None,
                                 # must inherit handles to pass std
                                 # handles
                                 1,
                                 creationflags,
                                 env,
                                 cwd,
                                 startupinfo)
    except pywintypes.error, e:
        # Translate pywintypes.error to WindowsError, which is
        # a subclass of OSError.  FIXME: We should really
        # translate errno using _sys_errlist (or simliar), but
        # how can this be done from Python?
        raise WindowsError(*e.args)

    # Retain the process handle, but close the thread handle
    self._handle = hp
    self.pid = pid
    ht.Close()

    # Child is launched. Close the parent's copy of those pipe
    # handles that only the child should have open.  You need
    # to make sure that no handles to the write end of the
    # output pipe are maintained in this process or else the
    # pipe will not close when the child process exits and the
    # ReadFile will hang.
    if p2cread != None:
        p2cread.Close()
    if c2pwrite != None:
        c2pwrite.Close()
    if errwrite != None:
        errwrite.Close()</t>
<t tx="ekr.20051112135040.6">def poll(self):
    """Check if child process has terminated.  Returns returncode
    attribute."""
    if self.returncode == None:
        if WaitForSingleObject(self._handle, 0) == WAIT_OBJECT_0:
            self.returncode = GetExitCodeProcess(self._handle)
            _active.remove(self)
    return self.returncode</t>
<t tx="ekr.20051112135040.7">def wait(self):
    """Wait for child process to terminate.  Returns returncode
    attribute."""
    if self.returncode == None:
        obj = WaitForSingleObject(self._handle, INFINITE)
        self.returncode = GetExitCodeProcess(self._handle)
        _active.remove(self)
    return self.returncode</t>
<t tx="ekr.20051112135040.8">def _readerthread(self, fh, buffer):

    buffer.append(fh.read())
</t>
<t tx="ekr.20051112135040.9">def communicate(self, input=None):
    """Interact with process: Send data to stdin.  Read data from
    stdout and stderr, until end-of-file is reached.  Wait for
    process to terminate.  The optional input argument should be a
    string to be sent to the child process, or None, if no data
    should be sent to the child.

    communicate() returns a tuple (stdout, stderr)."""
    stdout = None # Return
    stderr = None # Return

    if self.stdout:
        stdout = []
        stdout_thread = threading.Thread(target=self._readerthread,
                                         args=(self.stdout, stdout))
        stdout_thread.setDaemon(True)
        stdout_thread.start()
    if self.stderr:
        stderr = []
        stderr_thread = threading.Thread(target=self._readerthread,
                                         args=(self.stderr, stderr))
        stderr_thread.setDaemon(True)
        stderr_thread.start()

    if self.stdin:
        if input != None:
            self.stdin.write(input)
        self.stdin.close()

    if self.stdout:
        stdout_thread.join()
    if self.stderr:
        stderr_thread.join()

    # All data exchanged.  Translate lists into strings.
    if stdout != None:
        stdout = stdout[0]
    if stderr != None:
        stderr = stderr[0]

    # Translate newlines, if requested.  We cannot let the file
    # object do the translation: It is based on stdio, which is
    # impossible to combine with select (unless forcing no
    # buffering).
    if self.universal_newlines and hasattr(open, 'newlines'):
        if stdout:
            stdout = self._translate_newlines(stdout)
        if stderr:
            stderr = self._translate_newlines(stderr)

    self.wait()
    return (stdout, stderr)</t>
<t tx="ekr.20051112135040.12">@others</t>
<t tx="ekr.20051112135040.13">def _set_cloexec_flag(self, fd):
    try:
        cloexec_flag = fcntl.FD_CLOEXEC
    except AttributeError:
        cloexec_flag = 1

    old = fcntl.fcntl(fd, fcntl.F_GETFD)
    fcntl.fcntl(fd, fcntl.F_SETFD, old | cloexec_flag)</t>
<t tx="ekr.20051112135040.14">def _close_fds(self, but):
    for i in range(3, MAXFD):
        if i == but:
            continue
        try:
            os.close(i)
        except:
            pass</t>
<t tx="ekr.20051112135040.15">def _execute_child(self, args, executable, preexec_fn, close_fds,
                   cwd, env, universal_newlines,
                   startupinfo, creationflags, shell,
                   p2cread, p2cwrite,
                   c2pread, c2pwrite,
                   errread, errwrite):
    """Execute program (POSIX version)"""

    if isinstance(args, types.StringTypes):
        args = [args]

    if shell:
        args = ["/bin/sh", "-c"] + args

    if executable == None:
        executable = args[0]

    # For transferring possible exec failure from child to parent
    # The first char specifies the exception type: 0 means
    # OSError, 1 means some other error.
    errpipe_read, errpipe_write = os.pipe()
    self._set_cloexec_flag(errpipe_write)

    self.pid = os.fork()
    if self.pid == 0:
        # Child
        try:
            # Close parent's pipe ends
            if p2cwrite:
                os.close(p2cwrite)
            if c2pread:
                os.close(c2pread)
            if errread:
                os.close(errread)
            os.close(errpipe_read)

            # Dup fds for child
            if p2cread:
                os.dup2(p2cread, 0)
            if c2pwrite:
                os.dup2(c2pwrite, 1)
            if errwrite:
                os.dup2(errwrite, 2)

            # Close pipe fds.  Make sure we doesn't close the same
            # fd more than once.
            if p2cread:
                os.close(p2cread)
            if c2pwrite and c2pwrite not in (p2cread,):
                os.close(c2pwrite)
            if errwrite and errwrite not in (p2cread, c2pwrite):
                os.close(errwrite)

            # Close all other fds, if asked for
            if close_fds:
                self._close_fds(but=errpipe_write)

            if cwd != None:
                os.chdir(cwd)

            if preexec_fn:
                apply(preexec_fn)

            if env == None:
                os.execvp(executable, args)
            else:
                os.execvpe(executable, args, env)

        except:
            exc_type, exc_value, tb = sys.exc_info()
            # Save the traceback and attach it to the exception object
            exc_lines = traceback.format_exception(exc_type,
                                                   exc_value,
                                                   tb)
            exc_value.child_traceback = ''.join(exc_lines)
            os.write(errpipe_write, pickle.dumps(exc_value))

        # This exitcode won't be reported to applications, so it
        # really doesn't matter what we return.
        os._exit(255)

    # Parent
    os.close(errpipe_write)
    if p2cread and p2cwrite:
        os.close(p2cread)
    if c2pwrite and c2pread:
        os.close(c2pwrite)
    if errwrite and errread:
        os.close(errwrite)

    # Wait for exec to fail or succeed; possibly raising exception
    data = os.read(errpipe_read, 1048576) # Exceptions limited to 1 MB
    os.close(errpipe_read)
    if data != "":
        child_exception = pickle.loads(data)
        raise child_exception</t>
<t tx="ekr.20051112135040.16">def _handle_exitstatus(self, sts):
    if os.WIFSIGNALED(sts):
        self.returncode = -os.WTERMSIG(sts)
    elif os.WIFEXITED(sts):
        self.returncode = os.WEXITSTATUS(sts)
    else:
        # Should never happen
        raise RuntimeError("Unknown child exit status!")

    _active.remove(self)</t>
<t tx="ekr.20051112135040.17">def poll(self):
    """Check if child process has terminated.  Returns returncode
    attribute."""
    if self.returncode == None:
        try:
            pid, sts = os.waitpid(self.pid, os.WNOHANG)
            if pid == self.pid:
                self._handle_exitstatus(sts)
        except os.error:
            pass
    return self.returncode</t>
<t tx="ekr.20051112135040.18">def wait(self):
    """Wait for child process to terminate.  Returns returncode
    attribute."""
    if self.returncode == None:
        pid, sts = os.waitpid(self.pid, 0)
        self._handle_exitstatus(sts)
    return self.returncode</t>
<t tx="ekr.20051112135040.19">def communicate(self, input=None):
    """Interact with process: Send data to stdin.  Read data from
    stdout and stderr, until end-of-file is reached.  Wait for
    process to terminate.  The optional input argument should be a
    string to be sent to the child process, or None, if no data
    should be sent to the child.

    communicate() returns a tuple (stdout, stderr)."""
    read_set = []
    write_set = []
    stdout = None # Return
    stderr = None # Return

    if self.stdin:
        # Flush stdio buffer.  This might block, if the user has
        # been writing to .stdin in an uncontrolled fashion.
        self.stdin.flush()
        if input:
            write_set.append(self.stdin)
        else:
            self.stdin.close()
    if self.stdout:
        read_set.append(self.stdout)
        stdout = []
    if self.stderr:
        read_set.append(self.stderr)
        stderr = []

    while read_set or write_set:
        rlist, wlist, xlist = select.select(read_set, write_set, [])

        if self.stdin in wlist:
            # When select has indicated that the file is writable,
            # we can write up to PIPE_BUF bytes without risk
            # blocking.  POSIX defines PIPE_BUF &gt;= 512
            bytes_written = os.write(self.stdin.fileno(), input[:512])
            input = input[bytes_written:]
            if not input:
                self.stdin.close()
                write_set.remove(self.stdin)

        if self.stdout in rlist:
            data = os.read(self.stdout.fileno(), 1024)
            if data == "":
                self.stdout.close()
                read_set.remove(self.stdout)
            stdout.append(data)

        if self.stderr in rlist:
            data = os.read(self.stderr.fileno(), 1024)
            if data == "":
                self.stderr.close()
                read_set.remove(self.stderr)
            stderr.append(data)

    # All data exchanged.  Translate lists into strings.
    if stdout != None:
        stdout = ''.join(stdout)
    if stderr != None:
        stderr = ''.join(stderr)

    # Translate newlines, if requested.  We cannot let the file
    # object do the translation: It is based on stdio, which is
    # impossible to combine with select (unless forcing no
    # buffering).
    if self.universal_newlines and hasattr(open, 'newlines'):
        if stdout:
            stdout = self._translate_newlines(stdout)
        if stderr:
            stderr = self._translate_newlines(stderr)

    self.wait()
    return (stdout, stderr)</t>
<t tx="ekr.20051113055640"></t>
<t tx="ekr.20051113055640.1">@nocolor
https://sourceforge.net/forum/message.php?msg_id=3425131
By: yarkot

OK - This is _STILL_ happening w 4.4a3, and on a different (windows) computer,
with a clean installed system, and with a different underlying Python.

So that YOU can reproduce (or not) your self:

Here is the process:

Create a test leo file, with 3 nodes (reproduced as best I can here w/o being
able to paste clippings):

-----

[ ] This is a sample node
[-] @thin sample.txt
    [ ] Test node

-----

@thin contains:
-------------
@
@c
@others
---------------

Enable the "find"tab;

[ ] Test   node contains this:

---------------
This is a test.
This is the first test line;
This is just some line.
This is the second test line.
------------------------

Go to "@thin" node;  
enter "test" as search string in find tab;
Click "FIND" button once (we'll keep that line);
Click "FIND" a second time (delete this entire line);

Now contents of "Test" node is:
----------------
This is a test.
This is just some line.
This is the second test line.
----------------

and the cursor is at the front of "some line" (the middle line);

Now Click "FIND" again in the find tab;  NOW the contents of "Test" node is:
------------------
This is a test.
This is the first test line;
This is just some line.
This is the second test line.
----------------
With find causing "test" on the second line to be selected ("FIND" resurrected
this line "from somewhere") .

This is w/ Python 2.4.2 (same behavior was w/ 2.3.5 w/ Leo 4.4.a2, on a different
computer).

Both are windows XP machines.</t>
<t tx="ekr.20051113055640.2"></t>
</tnodes>
</leo_file>
