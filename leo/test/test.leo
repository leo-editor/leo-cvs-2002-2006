<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="5438" clone_windows="0"/>
<globals body_outline_ratio="0.372304199773">
	<global_window_position top="32" left="333" height="881" width="856"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences>
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="ekr.20040303080938"><vh>Diary</vh>
<v t="ekr.20040315210314"><vh>March 2004</vh>
<v t="ekr.20040315210314.1"><vh>3/15: Created stubs for Find Commands tests</vh></v>
<v t="ekr.20040315210314.2"><vh>3/15: Convert this file to 4.2 format</vh></v>
<v t="ekr.20040309095121"><vh>3/9: created more position mini tests</vh></v>
<v t="ekr.20040303080938.1"><vh>3/3: created position tests</vh></v>
</v>
</v>
<v t="EKR.20040626212434"><vh>Drawing experiments</vh>
<v t="EKR.20040626212434.1"><vh>Rectangles &amp; ovals</vh></v>
<v t="EKR.20040626212434.2"><vh>Lines &amp; arcs</vh></v>
<v t="EKR.20040626213007"><vh>Paul Klee</vh></v>
<v t="EKR.20040627150213"><vh>Complex functions</vh></v>
</v>
<v t="ekr.20040312021734"><vh>Scripts</vh>
<v t="ekr.20040311090054"><vh>Dump fileIndex</vh></v>
<v t="ekr.20040312021734.1"><vh>Script to clean unused tnodeLists</vh></v>
<v t="ekr.20040318091620"><vh>Clear all unknown attributes</vh></v>
<v t="ekr.20040319111213"><vh>FilterHoist script</vh>
<v t="ekr.20040319111213.1"><vh>description</vh></v>
<v t="ekr.20040319142708"><vh>filter</vh></v>
<v t="ekr.20040319142202"><vh>old code</vh>
<v t="ekr.20040319111213.2"><vh>filter</vh></v>
<v t="ekr.20040319111213.3"><vh>search</vh></v>
</v>
<v t="ekr.20040319111213.4"><vh>filterHoist</vh></v>
<v t="ekr.20040319111213.5"><vh>addMenu</vh></v>
</v>
<v t="ekr.20040322120331"><vh>script to print tnodeList's</vh></v>
<v t="ekr.20040330095252"><vh>script to clear log frame</vh></v>
<v t="EKR.20040424065452"><vh>Compare script</vh></v>
<v t="EKR.20040424091411"><vh>Compare script using text mode to ignore newlines</vh></v>
<v t="EKR.20040517074600.8"><vh>Count pages</vh></v>
<v t="EKR.20040517074600.9"><vh>Scripts to debug font problem</vh>
<v t="EKR.20040517074600.10"><vh>Show font</vh></v>
<v t="EKR.20040517074600.11"><vh>Show settings</vh>
<v t="EKR.20040517074600.12"><vh>getFontSettings</vh></v>
</v>
<v t="EKR.20040517074600.13"><vh>Print default font</vh></v>
</v>
<v t="EKR.20040613162717"><vh>Report newlines</vh></v>
<v t="ekr.20040706071823"><vh>test of Python's parser module</vh></v>
</v>
<v t="ekr.20040708215319"><vh>To do...</vh>
<v t="EKR.20040608095146"><vh>Perfect import stuff...</vh>
<v t="EKR.20040504083716.44"><vh>perfect import unit tests</vh>
<v t="EKR.20040504083716.45"><vh>@   file test_sentinels.py</vh>
<v t="EKR.20040504083716.47"><vh>class sentinel_test</vh>
<v t="EKR.20040504083716.48"><vh>setUp</vh></v>
<v t="EKR.20040504083716.49"><vh>setup_inputfile</vh></v>
<v t="EKR.20040504083716.50"><vh>setup_configfile</vh></v>
</v>
<v t="EKR.20040504083716.51"><vh>insert tests</vh>
<v t="EKR.20040504083716.52"><vh>class insert_test</vh>
<v t="EKR.20040504083716.53"><vh>setUp</vh></v>
<v t="EKR.20040504083716.54"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.55"><vh>replacement tests</vh>
<v t="EKR.20040504083716.56"><vh>class replace_test</vh>
<v t="EKR.20040504083716.57"><vh>setUp</vh></v>
<v t="EKR.20040504083716.58"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.59"><vh>class replace_test2</vh>
<v t="EKR.20040504083716.60"><vh>setUp</vh></v>
<v t="EKR.20040504083716.61"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.62"><vh>class replace_test3</vh>
<v t="EKR.20040504083716.63"><vh>setUp</vh></v>
<v t="EKR.20040504083716.64"><vh>runTest</vh></v>
</v>
<v t="EKR.20040504083716.65"><vh>class replace_test4</vh>
<v t="EKR.20040504083716.66"><vh>setUp</vh></v>
<v t="EKR.20040504083716.67"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.68"><vh>regression tests</vh>
<v t="EKR.20040504083716.69"><vh>class regression_test_1</vh>
<v t="EKR.20040504083716.70"><vh>setUp</vh></v>
<v t="EKR.20040504083716.71"><vh>runTest</vh></v>
</v>
</v>
<v t="EKR.20040504083716.72"><vh>main</vh></v>
</v>
<v t="EKR.20040504083716.73"><vh>not used</vh>
<v t="EKR.20040504083716.74"><vh>@file testtesting.ini</vh></v>
<v t="EKR.20040504083716.75"><vh>tests to write</vh>
<v t="EKR.20040504083716.76"><vh>Insert tests.</vh></v>
<v t="EKR.20040504083716.77"><vh>deletion tests.</vh></v>
<v t="EKR.20040504083716.78"><vh>Creation of backup files.</vh></v>
</v>
</v>
</v>
<v t="EKR.20040504083716"><vh>Mulder Update script</vh>
<v t="EKR.20040504083716.39"><vh>sync</vh>
<v t="EKR.20040504153320"><vh>&lt;&lt; compute sourcetime and targettime &gt;&gt;</vh></v>
<v t="EKR.20040504153320.1"><vh>&lt;&lt; compute operation &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="EKR.20040612095237" a="M"><vh>Prototypes of new commands</vh>
<v t="ekr.20040402043516"><vh>A pretty printer for Leo</vh>
<v t="ekr.20040402084155"><vh>prettyPrintNode</vh></v>
<v t="ekr.20040402064301"><vh>class prettyPrinter</vh>
<v t="ekr.20040402064301.1"><vh>__init__</vh></v>
<v t="ekr.20040402093822"><vh>get</vh></v>
<v t="ekr.20040402072335"><vh>put</vh></v>
<v t="ekr.20040402081135"><vh>putOperator</vh></v>
<v t="ekr.20040402080311"><vh>putToken</vh></v>
<v t="ekr.20040402074431"><vh>putNormalToken</vh></v>
<v t="ekr.20040402074431.1"><vh>dumpToken</vh></v>
</v>
</v>
<v t="EKR.20040610201941"><vh>Check Syntax prototype</vh>
<v t="EKR.20040610192622"><vh>Check Syntax script</vh></v>
<v t="EKR.20040610192622.1"><vh>Check Syntax data</vh></v>
</v>
<v t="EKR.20040610201236"><vh>Tabnanny prototype</vh>
<v t="EKR.20040610194209"><vh>TabNanny script</vh>
<v t="EKR.20040610195543"><vh>checkString</vh></v>
</v>
<v t="EKR.20040610195543.1"><vh>tabnanny.py (reference only) (good)</vh>
<v t="EKR.20040610195543.2"><vh>&lt;&lt; tabnanny declarations &gt;&gt;</vh></v>
<v t="EKR.20040610195543.3"><vh>errprint</vh></v>
<v t="EKR.20040610195543.4"><vh>main</vh></v>
<v t="EKR.20040610195543.5"><vh>class NannyNag</vh>
<v t="EKR.20040610195543.6"><vh>__init__</vh></v>
<v t="EKR.20040610195543.7"><vh>get_lineno</vh></v>
<v t="EKR.20040610195543.8"><vh>get_msg</vh></v>
<v t="EKR.20040610195543.9"><vh>get_line</vh></v>
</v>
<v t="EKR.20040610195543.10"><vh>check</vh></v>
<v t="EKR.20040610195543.11"><vh>class Whitespace</vh>
<v t="EKR.20040610195543.12"><vh>&lt;&lt; class Whitespace declarations &gt;&gt;</vh></v>
<v t="EKR.20040610195543.13"><vh>__init__</vh></v>
<v t="EKR.20040610195543.14"><vh>longest_run_of_spaces</vh></v>
<v t="EKR.20040610195543.15"><vh>indent_level</vh></v>
<v t="EKR.20040610195543.16"><vh>equal</vh></v>
<v t="EKR.20040610195543.17"><vh>not_equal_witness</vh></v>
<v t="EKR.20040610195543.18"><vh>less</vh></v>
<v t="EKR.20040610195543.19"><vh>not_less_witness</vh></v>
</v>
<v t="EKR.20040610195543.20"><vh>format_witnesses</vh></v>
<v t="EKR.20040610195543.21"><vh>process_tokens</vh></v>
</v>
<v t="EKR.20040610194209.1"><vh>TabNanny data (bad)</vh></v>
</v>
</v>
</v>
<v t="EKR.20040619133116" a="TV"><vh>Unit testing...</vh>
<v t="ekr.20040327114250" tnodeList="ekr.20040327114250"><vh>@file c:\prog\test\unittest\batchTest.py</vh></v>
<v t="EKR.20040623200709"><vh>@thin ../src/leoTest.py</vh></v>
<v t="ekr.20040707091428"><vh>Unit Tests</vh>
<v t="ekr.20040710120700"><vh>File Tests</vh>
<v t="ekr.20040707140849.35"><vh>Test Leo files...</vh>
<v t="ekr.20040707140849.39"><vh>@test test.leo</vh></v>
<v t="ekr.20040707140849.40"><vh>@test LeoPy.leo</vh></v>
<v t="ekr.20040707140849.41"><vh>@test leoPlugins.leo</vh></v>
<v t="ekr.20040707140849.42"><vh>@test LeoDocs.leo</vh></v>
</v>
<v t="ekr.20040707140849.26"><vh>Import/Export tests</vh>
<v t="ekr.20040708173308.1"><vh>@suite Import tests</vh></v>
<v t="ekr.20040708173549"><vh>@suite Export tests</vh></v>
<v t="ekr.20040303063549.90"><vh>importTests</vh>
<v t="ekr.20040708174345"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.91"><vh>importAtRoot</vh>
<v t="ekr.20040303063549.92"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.93"><vh>importAtFile</vh>
<v t="ekr.20040303063549.94"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.95"><vh>importNowebFiles</vh>
<v t="ekr.20040303063549.96"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.97"><vh>importFlattenedOutline</vh>
<v t="ekr.20040303063549.98"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.99"><vh>importCWEBFiles</vh>
<v t="ekr.20040303063549.100"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.88"><vh>removeSentinels</vh>
<v t="ekr.20040303063549.89"><vh>dialog</vh></v>
</v>
</v>
<v t="ekr.20040303063549.77"><vh>exportTests</vh>
<v t="ekr.20040708174345.1"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.78"><vh>exportHeadlines</vh>
<v t="ekr.20040303063549.79"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.80"><vh>flattenOutline</vh>
<v t="ekr.20040303063549.81"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.82"><vh>weave</vh>
<v t="ekr.20040303063549.83"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.84"><vh>outlineToNoweb</vh>
<v t="ekr.20040303063549.85"><vh>dialog</vh></v>
</v>
<v t="ekr.20040303063549.86"><vh>outlineToCWEB</vh>
<v t="ekr.20040303063549.87"><vh>dialog</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040708205640"><vh>Non-file tests</vh>
<v t="ekr.20040707140849.10"><vh>@suite Edit body tests</vh>
<v t="ekr.20040708113527"><vh>editBodyTests</vh>
<v t="ekr.20040708113823"><vh>tempNode</vh></v>
<v t="ekr.20040708113527.9"><vh>extractSection</vh>
<v t="ekr.20040708113527.10"><vh>before</vh></v>
<v t="ekr.20040708113527.11"><vh>after</vh>
<v t="ekr.20040708113527.12"><vh>&lt;&lt; section &gt;&gt;</vh></v>
</v>
<v t="ekr.20040708113527.13"><vh>selection</vh></v>
</v>
<v t="ekr.20040708113527.5"><vh>indentBody</vh>
<v t="ekr.20040708113527.6"><vh>before</vh></v>
<v t="ekr.20040708113527.7"><vh>after</vh></v>
<v t="ekr.20040708113527.8"><vh>selection</vh></v>
</v>
<v t="ekr.20040708113527.1"><vh>dedentBody</vh>
<v t="ekr.20040708113527.2"><vh>before</vh></v>
<v t="ekr.20040708113527.3"><vh>after</vh></v>
<v t="ekr.20040708113527.4"><vh>selection</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707140849.79"><vh>@suite Reformat Paragraph Tests</vh>
<v t="ekr.20040708080620"><vh>What I did</vh></v>
<v t="ekr.20040303063549.2"><vh>Reformat Paragraph tests</vh>
<v t="ekr.20040708080620.1"><vh>tempNode</vh></v>
<v t="ekr.20040303063549.3"><vh>testNoTrailingNewline</vh>
<v t="ekr.20040303063549.4"><vh>before</vh></v>
<v t="ekr.20040303063549.5"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.6"><vh>testTrailingNewline</vh>
<v t="ekr.20040303063549.7"><vh>before</vh></v>
<v t="ekr.20040303063549.8"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.9"><vh>testMixedLineLengths</vh>
<v t="ekr.20040303063549.10"><vh>before</vh></v>
<v t="ekr.20040303063549.11"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.12"><vh>testMixedLinesWithLeadingWS</vh>
<v t="ekr.20040303063549.13"><vh>before</vh></v>
<v t="ekr.20040303063549.14"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.15"><vh>testNoChangeRequired</vh>
<v t="ekr.20040303063549.16"><vh>before</vh></v>
<v t="ekr.20040303063549.17"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.18"><vh>testHonorLeadingWS</vh>
<v t="ekr.20040303063549.19"><vh>before</vh></v>
<v t="ekr.20040303063549.20"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.21"><vh>testHonorLeadingWSVar1</vh>
<v t="ekr.20040303063549.22"><vh>before</vh></v>
<v t="ekr.20040303063549.23"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.24"><vh>testSimpleHangingIndent</vh>
<v t="ekr.20040303063549.25"><vh>before</vh></v>
<v t="ekr.20040303063549.26"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.27"><vh>testSimpleHangingIndentVar1</vh>
<v t="ekr.20040303063549.28"><vh>before</vh></v>
<v t="ekr.20040303063549.29"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.30"><vh>testSimpleHangingIndentVar2</vh>
<v t="ekr.20040303063549.31"><vh>before</vh></v>
<v t="ekr.20040303063549.32"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.33"><vh>testMultiParagraph</vh>
<v t="ekr.20040303063549.34"><vh>before</vh></v>
<v t="ekr.20040303063549.35"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.36"><vh>testMultiParagraphWithList</vh>
<v t="ekr.20040303063549.37"><vh>before</vh></v>
<v t="ekr.20040303063549.38"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.39"><vh>testDirectiveBreaksParagraph</vh>
<v t="ekr.20040303063549.40"><vh>before</vh></v>
<v t="ekr.20040303063549.41"><vh>after</vh></v>
</v>
<v t="ekr.20040303063549.42"><vh>testWithLeadingWSOnEmptyLines</vh>
<v t="ekr.20040303063549.43"><vh>before</vh></v>
<v t="ekr.20040303063549.44"><vh>after</vh></v>
</v>
</v>
</v>
<v t="EKR.20040529092739"><vh>@test c iters</vh>
<v t="EKR.20040529093047"><vh>&lt;&lt; coverage tests &gt;&gt;</vh></v>
<v t="EKR.20040529093047.1"><vh>&lt;&lt; duplicate tests &gt;&gt;</vh></v>
</v>
<v t="ekr.20040707140849.1"><vh>atFileTests...</vh>
<v t="ekr.20040707141957.3"><vh>@test @file no newline</vh>
<v t="ekr.20040707141957.4"><vh>@@file</vh></v>
<v t="ekr.20040707141957.5"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.6"><vh>@test @file one newline</vh>
<v t="ekr.20040707141957.7"><vh>@@file</vh></v>
<v t="ekr.20040707141957.8"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.9"><vh>@test @file two newlines</vh>
<v t="ekr.20040707141957.10"><vh>@@file</vh></v>
<v t="ekr.20040707141957.11"><vh>Output</vh></v>
</v>
<v t="ekr.20040707141957.12"><vh>@test @thin</vh>
<v t="ekr.20040707141957.13"><vh>@@thin</vh></v>
<v t="ekr.20040707141957.14"><vh>Output</vh></v>
</v>
</v>
<v t="ekr.20040707083523"><vh>Colorizer tests...</vh>
<v t="ekr.20040708210045"><vh>@test @comment after @language plain</vh>
<v t="EKR.20040430162649.19"><vh>Test</vh></v>
</v>
<v t="ekr.20040707090019"><vh>@test colorizer Actionscript</vh>
<v t="ekr.20040707083523.1"><vh>Actionscript</vh></v>
</v>
<v t="ekr.20040707090300"><vh>@test colorizer C</vh>
<v t="ekr.20040707083523.2"><vh>C</vh></v>
</v>
<v t="ekr.20040707090300.1"><vh>@test colorizer C#</vh>
<v t="ekr.20040707083523.3"><vh>C#</vh></v>
</v>
<v t="ekr.20040707090647"><vh>@test colorizer css</vh>
<v t="ekr.20040707083523.4"><vh>css</vh></v>
</v>
<v t="ekr.20040707090647.1"><vh>@test colorizer CWEB</vh>
<v t="ekr.20040707083523.5"><vh>CWEB</vh>
<v t="ekr.20040707083523.6"><vh>&lt;&lt; section ref &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040707090647.2"><vh>@test colorizer elisp</vh>
<v t="ekr.20040707083523.7"><vh>elisp</vh></v>
</v>
<v t="ekr.20040708211223"><vh>@test colorizer HTML string bug</vh>
<v t="EKR.20040603103118"><vh>String bug in html</vh></v>
</v>
<v t="ekr.20040707090647.3"><vh>@test colorizer HTML1</vh>
<v t="ekr.20040707083523.8"><vh>HTML1</vh></v>
</v>
<v t="ekr.20040707090647.4"><vh>@test colorizer HTML2</vh>
<v t="ekr.20040707083523.9"><vh>HTML2</vh></v>
</v>
<v t="ekr.20040707090647.5"><vh>@test colorizer LaTex</vh>
<v t="ekr.20040707083523.10"><vh>LaTex</vh></v>
</v>
<v t="ekr.20040707090647.6"><vh>@test colorizer mixed</vh>
<v t="ekr.20040707083523.11"><vh>Mixed</vh></v>
</v>
<v t="ekr.20040707090647.7"><vh>@test colorizer PHP</vh>
<v t="ekr.20040707083523.12"><vh>PHP</vh></v>
</v>
<v t="EKR.20040430160416.1"><vh>@test colorizer python.xml (jEdit)</vh>
<v t="EKR.20040430160416.5"><vh>python.xml</vh>
<v t="EKR.20040430160416.6"><vh>&lt;&lt; remarks &gt;&gt;</vh></v>
<v t="EKR.20040430160416.7"><vh>&lt;&lt; comments &gt;&gt;</vh></v>
<v t="EKR.20040430160416.8"><vh>&lt;&lt; literals &gt;&gt;</vh></v>
<v t="EKR.20040430160416.9"><vh>&lt;&lt; operators &gt;&gt;</vh></v>
<v t="EKR.20040430160416.10"><vh>&lt;&lt; keywords &gt;&gt;</vh>
<v t="EKR.20040430160416.11"><vh>&lt;&lt; reserved words &gt;&gt;</vh></v>
<v t="EKR.20040430160416.12"><vh>&lt;&lt; builtins &gt;&gt;</vh></v>
<v t="EKR.20040430160416.13"><vh>&lt;&lt; exceptions &gt;&gt;</vh></v>
<v t="EKR.20040430160416.14"><vh>&lt;&lt; types &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707090647.8"><vh>@test colorizer Python1</vh>
<v t="ekr.20040707083523.13"><vh>Python1</vh></v>
</v>
<v t="ekr.20040707090647.9"><vh>@test colorizer Python2</vh>
<v t="ekr.20040707083523.14"><vh>Python2</vh></v>
</v>
<v t="ekr.20040707090647.10"><vh>@test colorizer rapidq</vh>
<v t="ekr.20040707083523.15"><vh>rapidq</vh></v>
</v>
<v t="ekr.20040707090647.11"><vh>@test colorizer Rebol</vh>
<v t="ekr.20040707083523.16"><vh>Rebol</vh></v>
</v>
<v t="ekr.20040707090647.12"><vh>@test colorizer shell</vh>
<v t="ekr.20040707083523.17"><vh>shell</vh></v>
</v>
<v t="ekr.20040708205153"><vh>@test colorizer tex.xml (jEdit)</vh>
<v t="EKR.20040430160416.2"><vh>tex.xml</vh>
<v t="EKR.20040430160416.3"><vh>&lt;&lt; general rules &gt;&gt;</vh></v>
<v t="EKR.20040430160416.4"><vh>&lt;&lt; math rules &gt;&gt;</vh></v>
</v>
</v>
<v t="ekr.20040707090647.13"><vh>@test colorizer wikiTest1</vh>
<v t="ekr.20040707083523.18"><vh>wikiTest1</vh></v>
</v>
<v t="ekr.20040707090647.14"><vh>@test colorizer wikiTest2</vh>
<v t="ekr.20040707083523.19"><vh>wikiTest2</vh></v>
</v>
<v t="ekr.20040707090647.15"><vh>@test colorizer wikiTest3</vh>
<v t="ekr.20040707083523.20"><vh>wikiTest3</vh></v>
</v>
</v>
<v t="ekr.20040707093334"><vh>Mini tests...</vh>
<v t="ekr.20040311125054"><vh>@test p.t == p.v.t</vh></v>
<v t="ekr.20040310145919"><vh>@test python keywords</vh></v>
<v t="ekr.20040315030123"><vh>@test convertTreeToString and allies</vh>
<v t="ekr.20040315025315"><vh>File Conversion</vh>
<v t="ekr.20040315025315.1"><vh>convertTreeToString</vh></v>
<v t="ekr.20040315025315.2"><vh>moreHead</vh></v>
<v t="ekr.20040315025315.3"><vh>moreBody</vh></v>
</v>
</v>
<v t="ekr.20040318102920"><vh>inner @test: Test consistency between parents iter and v.parents</vh>
<v t="ekr.20040318102920.1"><vh>parent</vh>
<v t="ekr.20040318102920.2"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
<v t="ekr.20040318102920.1"><vh>parent</vh>
<v t="ekr.20040318102920.2"><vh>@test consistency between parents iter and v.parents</vh></v>
</v>
</v>
<v t="ekr.20040323090541"><vh>@test consistency of p.v.t.vnodeList &amp; v.parents for cloned nodes</vh></v>
<v t="ekr.20040323162303"><vh>@test that cloned nodes actually share subtrees</vh></v>
<v t="ekr.20040327105955"><vh>@test batch mode</vh></v>
</v>
<v t="ekr.20040707091428.1"><vh>Position tests...</vh>
<v t="EKR.20040528152529"><vh>@test p.iters and v.iters</vh>
<v t="EKR.20040527073459"><vh>child1</vh>
<v t="EKR.20040527072047"><vh>a</vh>
<v t="EKR.20040527072047.1"><vh>b</vh></v>
</v>
<v t="EKR.20040527074524"><vh>c</vh></v>
<v t="EKR.20040527072047"><vh>a</vh>
<v t="EKR.20040527072047.1"><vh>b</vh></v>
</v>
<v t="EKR.20040527074524.1"><vh>d</vh>
<v t="EKR.20040527074524.2"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040529105640"><vh>child2</vh></v>
<v t="EKR.20040529104307"><vh>&lt;&lt; tests of consistency of p and v iters &gt;&gt;</vh></v>
<v t="EKR.20040527083449.1"><vh>&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;</vh></v>
<v t="EKR.20040527083449.2"><vh>&lt;&lt; print nodes returned by iterators &gt;&gt;</vh></v>
</v>
<v t="ekr.20040707091428.5"><vh>@test p.comparisons</vh></v>
<v t="ekr.20040707091428.6"><vh>@test that clones share subtrees</vh></v>
<v t="ekr.20040707091428.8"><vh>@test consistency of c.allNodes_iter() and p.ThreadNext()</vh></v>
<v t="ekr.20040707091428.9"><vh>@test consistency of firstChild &amp; children_iter()</vh></v>
<v t="ekr.20040707091428.10"><vh>@test consistency of level</vh></v>
<v t="ekr.20040707091428.11"><vh>@test consistency of back/next links</vh></v>
<v t="ekr.20040707091428.12"><vh>@test consistency of parent &amp; parents_iter()</vh></v>
<v t="ekr.20040707091428.13"><vh>@test consistency of parent/child links</vh></v>
<v t="ekr.20040707091428.14"><vh>@test consistency of threadBack/Next links</vh></v>
<v t="ekr.20040707091428.15"><vh>@test consistency of tnodeListAndParents</vh></v>
<v t="ekr.20040707091428.16"><vh>@test hasNextBack</vh></v>
<v t="ekr.20040707091428.17"><vh>@test hasParentChild</vh></v>
<v t="ekr.20040707091428.18"><vh>@test hasThreadNextBack</vh></v>
<v t="ekr.20040707091428.19"><vh>@test vnode list</vh></v>
</v>
</v>
<v t="ekr.20040707150427"><vh>Unfinished tests...</vh>
<v t="ekr.20040707140849.43"><vh>Outline tests (Sometimes fails)</vh>
<v t="ekr.20040708181226"><vh>test of p.copyTreeAfter and p.copyTreeFromSelfTo</vh>
<v t="ekr.20040708181226.1"><vh>root1</vh>
<v t="ekr.20040708181226.2"><vh>a</vh>
<v t="ekr.20040708185414"><vh>c</vh>
<v t="ekr.20040708203222"><vh>d</vh></v>
</v>
</v>
<v t="ekr.20040708181226.3"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040708212348"><vh>Manual test of testUtils.replaceOutline</vh>
<v t="ekr.20040708214013"><vh>outline1</vh>
<v t="ekr.20040708214013.1"><vh>a</vh></v>
</v>
<v t="ekr.20040708213736"><vh>outline2</vh>
<v t="ekr.20040708213736.1"><vh>b</vh></v>
</v>
</v>
<v t="EKR.20040623223148.11"><vh>testUtils.replaceOutline</vh></v>
<v t="ekr.20040708174955" a="M"><vh>@@ suite Outline/Undo tests</vh>
<v t="ekr.20040707140849.44"><vh> makeOutlineSuite</vh></v>
<v t="ekr.20040707140849.45"><vh>class outlineTestCase</vh>
<v t="ekr.20040707140849.46"><vh>__init__</vh></v>
<v t="ekr.20040707140849.47"><vh>outlineCommand</vh></v>
<v t="ekr.20040707140849.48"><vh>runTest</vh></v>
<v t="ekr.20040707140849.49"><vh>setUp</vh></v>
<v t="ekr.20040707140849.50"><vh>tearDown</vh></v>
<v t="ekr.20040708175948"><vh>shortDescription</vh></v>
</v>
</v>
<v t="ekr.20040303063549.101"><vh>outlineTests</vh>
<v t="ekr.20040303063549.102"><vh>moveOutlineDown</vh>
<v t="ekr.20040708215633"><vh>before</vh>
<v t="ekr.20040708215633.1"><vh>a</vh></v>
<v t="ekr.20040708215633.2"><vh>move</vh></v>
<v t="ekr.20040708215633.3"><vh>b</vh></v>
</v>
<v t="ekr.20040303063549.107"><vh>after</vh>
<v t="ekr.20040303063549.108"><vh>a</vh></v>
<v t="ekr.20040303063549.109"><vh>b</vh></v>
<v t="ekr.20040303063549.110"><vh>move</vh></v>
</v>
<v t="ekr.20040303063549.111"><vh>ref</vh>
<v t="ekr.20040303063549.112"><vh>a</vh></v>
<v t="ekr.20040303063549.113"><vh>move</vh></v>
<v t="ekr.20040303063549.114"><vh>b</vh></v>
</v>
</v>
<v t="ekr.20040303063549.115"><vh>moveOutlineLeft</vh></v>
<v t="ekr.20040303063549.116"><vh>moveOutlineRight</vh></v>
<v t="ekr.20040303063549.117"><vh>moveOutlineUp</vh></v>
</v>
</v>
<v t="ekr.20040708172357"><vh>Find Command tests...(Not finished)</vh>
<v t="ekr.20040707140849.19"><vh>@suite Find sommands tests</vh>
<v t="ekr.20040707140849.21"><vh>class findCommandTestCase</vh>
<v t="ekr.20040707140849.22"><vh>setUp</vh></v>
<v t="ekr.20040707140849.23"><vh>testFindCommand</vh></v>
<v t="ekr.20040707140849.24"><vh>testFindWordCommand</vh></v>
<v t="ekr.20040707140849.25"><vh>testFindIgnoreCaseCommand</vh></v>
</v>
</v>
<v t="ekr.20040708172802"><vh>findTests</vh></v>
</v>
<v t="ekr.20040707140849.51"><vh>test plugins (Not ready yet)</vh>
<v t="ekr.20040707151028"><vh>doPluginTest</vh></v>
</v>
<v t="EKR.20040623200709.75"><vh>OLD Plugin tests</vh>
<v t="EKR.20040623200709.76"><vh> makePluginsSuite</vh></v>
<v t="EKR.20040623200709.77"><vh>class pluginTestCase</vh>
<v t="EKR.20040623200709.78"><vh>__init__</vh></v>
<v t="EKR.20040623200709.79"><vh>pluginTest</vh></v>
<v t="EKR.20040623200709.80"><vh>runTest</vh></v>
<v t="EKR.20040623200709.81"><vh>setUp</vh></v>
<v t="EKR.20040623200709.82"><vh>shortDescription</vh></v>
<v t="EKR.20040623200709.83"><vh>tearDown</vh></v>
</v>
</v>
</v>
<v t="ekr.20040708214530"><vh>@test CheckOutline</vh></v>
<v t="ekr.20040710180851"><vh>Redundant: @suite run all doctests in @file nodes</vh></v>
<v t="ekr.20040711060313"><vh>@suite run all doctests in leo*.py</vh></v>
</v>
<v t="ekr.20040708205841"><vh>Other tests...</vh>
<v t="ekr.20040414082806"><vh>Clone test</vh>
<v t="ekr.20040409140301"><vh>clone test</vh>
<v t="ekr.20040409140301.1"><vh>b</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028"><vh>sibling</vh></v>
</v>
<v t="ekr.20040409140301.3"><vh>a</vh></v>
</v>
<v t="ekr.20040409140343"><vh>d</vh>
<v t="ekr.20040409140301.2"><vh>c</vh>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409142108.1"><vh>secondChild</vh></v>
</v>
<v t="ekr.20040409142028.1"><vh>sibling 2</vh></v>
</v>
<v t="ekr.20040409142108"><vh>firstChild</vh></v>
<v t="ekr.20040409140343.1"><vh>last</vh></v>
</v>
<v t="EKR.20040523112430"><vh>Cloning headlines</vh>
<v t="EKR.20040523112430.1"><vh>read me</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.7"><vh>a</vh>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.2"><vh>b</vh>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
<v t="EKR.20040523112430.3"><vh>c</vh>
<v t="EKR.20040523112430.4"><vh>d</vh></v>
<v t="EKR.20040523112430.5"><vh>e</vh></v>
</v>
</v>
<v t="EKR.20040523112430.6"><vh>g</vh></v>
</v>
<v t="EKR.20040523112430.8"><vh>f</vh></v>
</v>
<v t="ekr.20040312101720"><vh>Experiments</vh>
<v t="ekr.20040302091705"><vh>Test of moving positions</vh></v>
<v t="ekr.20040323075614"><vh>Test of using an iterator inside a list comprehension</vh></v>
<v t="ekr.20040323080317"><vh>Test of using c.allNodes_iter to create a list of all positions</vh></v>
<v t="ekr.20040323082119"><vh>Creating a list of distinct vnodes</vh></v>
<v t="ekr.20040325082811"><vh>Test that back quotes are not needed in es</vh></v>
<v t="ekr.20040325130503" a="M"><vh>test of list comparisons</vh></v>
<v t="ekr.20040325140133"><vh>test that childIndex doesn't mess with p</vh></v>
<v t="ekr.20040325155043"><vh>Test of __cmp__ vrs equal</vh></v>
<v t="EKR.20040615070332"><vh>Test print</vh></v>
</v>
<v t="ekr.20040707110818"><vh>File Tests...</vh>
<v t="EKR.20040430162649.23"><vh>(double @root bug)</vh>
<v t="EKR.20040430162649.24"><vh>Assert fails</vh></v>
<v t="EKR.20040430162649.25"><vh>double at-root test (assert fails)</vh></v>
</v>
<v t="EKR.20040427092657"><vh>@ file-thin c:\prog\test\at-file-thin-test.txt</vh>
<v t="EKR.20040427092657.1"><vh>node 1</vh>
<v t="EKR.20040428145741"><vh>&lt;&lt; node 1 ref &gt;&gt;</vh>
<v t="EKR.20040428145741.1"><vh>child node 1</vh></v>
<v t="EKR.20040428145741.2"><vh>child node 2</vh></v>
</v>
</v>
<v t="EKR.20040427092657.2"><vh>&lt;&lt; ref &gt;&gt;</vh>
<v t="EKR.20040428150018"><vh>organizer node</vh>
<v t="EKR.20040428145826"><vh>ref child 1</vh></v>
<v t="EKR.20040428145826.1"><vh>ref child 2</vh></v>
</v>
</v>
</v>
<v t="EKR.20040625110032"><vh>@ thin c:\prog\test\mixedCommentDelims.txt</vh>
<v t="EKR.20040625110032.1"><vh>node 1</vh></v>
<v t="EKR.20040625110032.2"><vh>node 2</vh>
<v t="EKR.20040625110032.3"><vh>Node 3</vh></v>
</v>
</v>
<v t="ekr.20040419105536"><vh>@file c:\prog\test\perlLineNumbersTest.txt</vh>
<v t="ekr.20040419105536.1"><vh>one</vh></v>
<v t="ekr.20040419105536.2"><vh>two</vh></v>
</v>
<v t="ekr.20040330103006"><vh>@file c:\prog\test\testSectionDelims.txt</vh></v>
<v t="EKR.20040608095146.1"><vh>@file login_process.cfm</vh></v>
<v t="EKR.20040531110157"><vh>at-file thin tests</vh>
<v t="EKR.20040520104329"><vh>@thin c:\prog\test\thinCloneTest.txt</vh></v>
<v t="EKR.20040524050419"><vh>@file c:\prog\test\fatGrandChildTest.txt</vh>
<v t="EKR.20040524050419.1"><vh>Organizer node</vh>
<v t="EKR.20040524050419.2"><vh>&lt;&lt; defined in grandchild &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040524050438"><vh>@thin c:\prog\test\grandChildTest.txt</vh></v>
<v t="EKR.20040525083635"><vh>@file c:\prog\test\orphanMessageTest.txt</vh>
<v t="EKR.20040525083635.1"><vh>orphan</vh></v>
</v>
</v>
<v t="EKR.20040430162649.12"><vh>REM_ hack and perlpod hacks</vh>
<v t="EKR.20040430162649.13"><vh>perlpod test</vh>
<v t="EKR.20040430162649.14"><vh>perlpod test</vh>
<v t="EKR.20040430162649.15"><vh>&lt;&lt; ref &gt;&gt;</vh></v>
</v>
</v>
<v t="EKR.20040430162649.16"><vh>REM test</vh>
<v t="EKR.20040430162649.17"><vh>@file c:/prog/test/remTest.txt</vh></v>
</v>
</v>
<v t="EKR.20040430162649.20"><vh>Suppress @@ sentinel unless leading @ starts a directive</vh>
<v t="EKR.20040430162649.21"><vh>@file c:\prog\test\perltest.txt</vh></v>
</v>
<v t="ekr.20040704104554"><vh>Test mixed @language directives in a single node</vh>
<v t="ekr.20040704104554.1"><vh>Mixed script</vh></v>
<v t="ekr.20040704104554.2"><vh>@thin c:\prog\test\mixedLanguages.txt</vh></v>
</v>
<v t="EKR.20040606204316"><vh>Test of @first</vh>
<v t="EKR.20040606204316.1"><vh>@thin atFirstTest.txt</vh></v>
</v>
<v t="EKR.20040622074004"><vh>Test of conflicting node defs</vh>
<v t="EKR.20040622074004.1"><vh>a</vh>
<v t="EKR.20040622074004.2" a="M"><vh>b</vh></v>
<v t="EKR.20040622074004.3"><vh>c</vh></v>
</v>
<v t="EKR.20040622102618"><vh>@thin c:\prog\test\cloneConflicts.txt</vh></v>
</v>
<v t="ekr.20040701081330"><vh>Test of decendent attributes</vh>
<v t="ekr.20040701065412"><vh>@ thin c:\prog\test\attribTest.txt</vh>
<v t="ekr.20040701065412.1" a="M"><vh>Marked</vh></v>
<v t="ekr.20040701065412.2"><vh>Expanded</vh>
<v t="ekr.20040701065412.3"><vh>child</vh></v>
</v>
<v t="ekr.20040701065412.4" a="M"><vh>Marked and expanded</vh>
<v t="ekr.20040701065412.5"><vh>child2</vh></v>
</v>
<v t="ekr.20040701065424"><vh>Neither Expanded or marked</vh>
<v t="ekr.20040701065424.1"><vh>child</vh></v>
</v>
</v>
</v>
<v t="EKR.20040627103732"><vh>Test of writing descendent uA's</vh>
<v t="EKR.20040627121836"><vh>print all tnode attributes</vh></v>
<v t="EKR.20040627103902"><vh>Test of user icons</vh></v>
<v t="EKR.20040627103801"><vh>@thin c:\prog\test\uaTest.txt</vh></v>
</v>
</v>
<v t="ekr.20040708210442"><vh>Manual tests...</vh>
<v t="EKR.20040605200750"><vh>autocompleter test</vh></v>
<v t="EKR.20040430162649.22"><vh>Other Reformat Paragraph tests</vh></v>
<v t="EKR.20040604082113"><vh>Test of @tabwidth</vh></v>
<v t="EKR.20040608092841"><vh>test of indent/undent with negative tab width</vh></v>
<v t="EKR.20040610131858"><vh>Test of Paste Node Retaining Clones</vh>
<v t="EKR.20040615144810"><vh>b</vh></v>
<v t="EKR.20040615144735"><vh>branch</vh>
<v t="EKR.20040615144810"><vh>b</vh></v>
<v t="EKR.20040610131858.1"><vh>a</vh>
<v t="EKR.20040610143643"><vh>b</vh></v>
<v t="EKR.20040610143643"><vh>b</vh></v>
</v>
<v t="EKR.20040610131858.1"><vh>a</vh>
<v t="EKR.20040610143643"><vh>b</vh></v>
<v t="EKR.20040610143643"><vh>b</vh></v>
</v>
<v t="EKR.20040610132739"><vh>copied</vh></v>
</v>
</v>
<v t="EKR.20040610092248"><vh>Test of pasting into big node</vh></v>
<v t="EKR.20040527154402"><vh>Test of undo extract section</vh>
<v t="EKR.20040528130659"><vh>a</vh></v>
<v t="EKR.20040528130659"><vh>a</vh></v>
</v>
<v t="EKR.20040604170105"><vh>Test of Remove sentinels</vh></v>
</v>
<v t="ekr.20040707104245"><vh>Printing tests...</vh>
<v t="ekr.20040323085933"><vh>Print findAllPotentiallyDirtyNodes</vh></v>
<v t="ekr.20040309111054"><vh>Print iterations: do not delete</vh>
<v t="ekr.20040309111102"><vh>Clone test data</vh>
<v t="ekr.20040309111102.1"><vh>aa</vh></v>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.8"><vh>d</vh>
<v t="ekr.20040309111102.2"><vh>a</vh>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
<v t="ekr.20040309111102.3"><vh>b</vh>
<v t="ekr.20040309111102.4"><vh>c</vh>
<v t="ekr.20040309111102.5"><vh>c2</vh>
<v t="ekr.20040309111102.6"><vh>c3</vh></v>
<v t="ekr.20040309111102.7"><vh>c4</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="ekr.20040309111102.9"><vh>e</vh></v>
<v t="ekr.20040309111102.10"><vh>z</vh></v>
</v>
<v t="ekr.20040309111232"><vh>last node</vh></v>
</v>
<v t="ekr.20040705191805"><vh>Print abbreviations</vh>
<v t="ekr.20040705212227"><vh>@file file</vh></v>
<v t="ekr.20040705192522" a="M"><vh>@silentfile silentfile</vh></v>
<v t="ekr.20040705192522.1"><vh>@file-asis file-asis</vh></v>
<v t="ekr.20040705192522.2"><vh>@asis asis</vh></v>
<v t="ekr.20040705192522.3" a="M"><vh>@nosentinelsfile nosentinelsfile</vh></v>
<v t="ekr.20040705191805.1"><vh>@file-nosent file-nosent</vh></v>
<v t="ekr.20040705191805.2"><vh>@nosent nosent</vh></v>
<v t="ekr.20040705192610" a="M"><vh>@rawfile rawfile</vh></v>
<v t="ekr.20040705192522.4"><vh>@file-noref file-noref</vh></v>
<v t="ekr.20040705192522.5"><vh>@noref noref</vh></v>
<v t="ekr.20040705192522.6"><vh>@file-thin file-thin</vh></v>
<v t="ekr.20040705192610.1"><vh>@thin thin</vh></v>
</v>
<v t="ekr.20040323085406"><vh>Print isAnyAtFileNode</vh></v>
<v t="ekr.20040708135624"><vh>Print fundChildrenOf and </vh></v>
<v t="EKR.20040526193608"><vh>Tests of pickle &amp; hexlify</vh></v>
<v t="EKR.20040526094831"><vh>Test of undo registration</vh></v>
<v t="EKR.20040526200017" myPlugin="7d710055016171014930310a732e"><vh>Test of unknownAttributes</vh></v>
<v t="EKR.20040602101648"><vh>Test of "end1" hook</vh></v>
<v t="EKR.20040603064545"><vh>Print timestamps of all nodes</vh></v>
<v t="EKR.20040603174633"><vh>test of focus</vh></v>
<v t="EKR.20040611083703"><vh>Using a generator instead of readLinesClass</vh></v>
<v t="EKR.20040612150543"><vh>Test of better error messages in Execute Script command</vh>
<v t="EKR.20040612215136"><vh>Contains error</vh></v>
</v>
<v t="EKR.20040627100615"><vh>Test of error messages when redirecting output</vh></v>
</v>
<v t="EKR.20040430162649.1"><vh>Unicode tests</vh>
<v t="EKR.20040430162649.2"><vh> Tests</vh>
<v t="EKR.20040430162649.3"><vh>@file-asis c:\prog\test\asisTest.txt</vh></v>
<v t="EKR.20040430162649.4"><vh>@file-nosent c:\prog\test\nosentTest.txt</vh></v>
<v t="EKR.20040430162649.5"><vh>@file-noref c:\prog\test\norefTest.txt</vh></v>
</v>
<v t="EKR.20040430162649.6"><vh> Tests</vh>
<v t="EKR.20040430162649.7"><vh>Import/export tests</vh>
<v t="EKR.20040430162649.8"><vh>test</vh>
<v t="EKR.20040430162649.9"><vh>NewHeadlineë</vh></v>
</v>
</v>
<v t="EKR.20040430162649.10"><vh>@file c:/prog/test/unicodeTest.doc</vh>
<v t="EKR.20040430162649.11"><vh>NewÖ</vh></v>
</v>
</v>
</v>
<v t="ekr.20040708210636"><vh>User Icon tests... (disrupts representation of outline)</vh>
<v t="ekr.20040317173327"><vh>Delete user icons</vh></v>
<v t="ekr.20040317101155"><vh>Test of user icons</vh>
<v t="ekr.20040317185041"><vh>&lt;&lt; define event callbacks &gt;&gt;</vh></v>
</v>
</v>
</v>
<v t="ekr.20040707071542.1"><vh>Do all @tests</vh></v>
<v t="ekr.20040707081532.1" a="E"><vh>Do @test</vh></v>
</v>
<v t="ekr.20040709094228"><vh>select drag problems</vh></v>
<v t="ekr.20040710125250"><vh>import from string</vh>
<v t="ekr.20040710125250.1"><vh>Notes</vh></v>
<v t="ekr.20040710125250.2"><vh>@test import from string</vh></v>
</v>
<v t="ekr.20040710140454"><vh>doctest</vh>
<v t="ekr.20040710140534"><vh>Python23/Lib/doctest.py</vh>
<v t="ekr.20040710140534.1"><vh>&lt;&lt; doctest declarations &gt;&gt;</vh></v>
<v t="ekr.20040710140534.2"><vh>_extract_examples</vh></v>
<v t="ekr.20040710140534.3"><vh>class _SpoofOut</vh>
<v t="ekr.20040710140534.4"><vh>__init__</vh></v>
<v t="ekr.20040710140534.5"><vh>write</vh></v>
<v t="ekr.20040710140534.6"><vh>get</vh></v>
<v t="ekr.20040710140534.7"><vh>clear</vh></v>
<v t="ekr.20040710140534.8"><vh>flush</vh></v>
</v>
<v t="ekr.20040710140534.9"><vh>_tag_out</vh></v>
<v t="ekr.20040710140534.10"><vh>_run_examples_inner</vh></v>
<v t="ekr.20040710140534.11"><vh>_extract_future_flags</vh></v>
<v t="ekr.20040710140534.12"><vh>_run_examples</vh></v>
<v t="ekr.20040710140534.13"><vh>run_docstring_examples</vh></v>
<v t="ekr.20040710140534.14"><vh>is_private</vh></v>
<v t="ekr.20040710140534.15"><vh>_from_module</vh></v>
<v t="ekr.20040710140534.16"><vh>class Tester</vh>
<v t="ekr.20040710140534.17"><vh>__init__</vh></v>
<v t="ekr.20040710140534.18"><vh>runstring</vh></v>
<v t="ekr.20040710140534.19"><vh>rundoc</vh></v>
<v t="ekr.20040710140534.20"><vh>rundict</vh></v>
<v t="ekr.20040710140534.21"><vh>run__test__</vh></v>
<v t="ekr.20040710140534.22"><vh>summarize</vh></v>
<v t="ekr.20040710140534.23"><vh>merge</vh></v>
<v t="ekr.20040710140534.24"><vh>__record_outcome</vh></v>
<v t="ekr.20040710140534.25"><vh>__runone</vh></v>
</v>
<v t="ekr.20040710140534.26" a="M"><vh>testmod</vh></v>
<v t="ekr.20040710140534.27"><vh>_normalize_module</vh></v>
<v t="ekr.20040710140534.28"><vh>_get_doctest</vh></v>
<v t="ekr.20040710140534.29"><vh>_extract_doctests</vh></v>
<v t="ekr.20040710140534.30"><vh>_find_tests</vh></v>
<v t="ekr.20040710140534.31"><vh>_utest</vh></v>
<v t="ekr.20040710140534.32"><vh>class DocTestTestFailure</vh></v>
<v t="ekr.20040710140534.33"><vh>DocTestSuite</vh></v>
<v t="ekr.20040710140534.34"><vh>_expect</vh></v>
<v t="ekr.20040710140534.35"><vh>testsource</vh></v>
<v t="ekr.20040710140534.36"><vh>debug</vh></v>
<v t="ekr.20040710140534.37"><vh>class _TestClass</vh>
<v t="ekr.20040710140534.38"><vh>__init__</vh></v>
<v t="ekr.20040710140534.39"><vh>square</vh></v>
<v t="ekr.20040710140534.40"><vh>get</vh></v>
</v>
<v t="ekr.20040710140534.41"><vh>_test</vh></v>
</v>
</v>
<v t="ekr.20040710141351"><vh>print all docstrings from a module</vh>
<v t="ekr.20040710145459"><vh>&lt;&lt; print names sorted by type &gt;&gt;</vh></v>
</v>
<v t="ekr.20040711044029.1"><vh>test new docutils stull</vh></v>
</vnodes>
<tnodes>
<t tx="EKR.20040424065452">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
lines1 = f1.readlines()
lines2 = f2.readlines()
f1.close() ; f2.close()

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
text1 = f1.read()
text2 = f2.read()
f1.close() ; f2.close()

cr1 = text1.count('\r')
cr2 = text2.count('\r')

print '-'*20
print "lines ",len(lines1),len(lines2)
print "chars ",len(text1),len(text2)
print "non-cr",len(text1)-cr1,len(text2)-cr2
print "cr    ",cr1,cr2</t>
<t tx="EKR.20040424091411">import leoGlobals as g
p1 = r"c:\prog\leoMenu(1).py"
p2 = r"c:\prog\leoMenu(2).py"

f1 = open(p1,"rb") ; f2 = open(p2,"rb")
g.es("equal (raw mode)",f1.read()==f2.read())
f1.close() ; f2.close()

f1 = open(p1) ; f2 = open(p2)
g.es("equal (text mode)",f1.read()==f2.read())
f1.close() ; f2.close()</t>
<t tx="EKR.20040427092657">@ignore

root line 1

@others

root after at-others

&lt;&lt; ref &gt;&gt;
</t>
<t tx="EKR.20040427092657.1">node 1 line 1

&lt;&lt; node 1 ref &gt;&gt;

node 1 last line</t>
<t tx="EKR.20040427092657.2">ref line 1

@others</t>
<t tx="EKR.20040428145741">node 1 ref line 1

@others</t>
<t tx="EKR.20040428145741.1"></t>
<t tx="EKR.20040428145741.2"></t>
<t tx="EKR.20040428145826"></t>
<t tx="EKR.20040428145826.1"></t>
<t tx="EKR.20040428150018">text of organizer node</t>
<t tx="EKR.20040430160416.1">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="EKR.20040430160416.2">@language html

&lt;!-- ekr uses the MARK_FOLLOWING to mark _anything_ after \ --&gt;

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="%" /&gt;
    &lt;/PROPS&gt;

    &lt;RULES&gt;
        &lt;&lt; general rules &gt;&gt;
    &lt;/RULES&gt;

    &lt;RULES SET="MATH" DEFAULT="MARKUP"&gt;
        &lt;&lt; math rules &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="EKR.20040430160416.3">&lt;!-- $$...$$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$$&lt;/BEGIN&gt;
    &lt;END&gt;$$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- $...$ --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;$&lt;/BEGIN&gt;
    &lt;END&gt;$&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- \[...\] (LaTeX math mode) --&gt;
&lt;SPAN TYPE="MARKUP" DELEGATE="MATH"&gt;
    &lt;BEGIN&gt;\[&lt;/BEGIN&gt;
    &lt;END&gt;\]&lt;/END&gt;
&lt;/SPAN&gt;

&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD1"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD1"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="OPERATOR"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;]&lt;/SEQ&gt;</t>
<t tx="EKR.20040430160416.4">&lt;!-- some commands must be handled specially --&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\$&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\\&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD3"&gt;\%&lt;/SEQ&gt;

&lt;!-- \... commands --&gt;
&lt;MARK_FOLLOWING TYPE="KEYWORD3"&gt;\&lt;/MARK_FOLLOWING&gt;

&lt;!-- word separators --&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;)&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;(&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;{&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;}&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;[&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;]&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;~&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;.&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;,&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;;&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;?&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;:&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;'&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;"&lt;/SEQ&gt;
&lt;SEQ TYPE="KEYWORD2"&gt;`&lt;/SEQ&gt;

&lt;!-- comments --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;%&lt;/EOL_SPAN&gt;</t>
<t tx="EKR.20040430160416.5">@language html

&lt;?xml version="1.0"?&gt;

&lt;!DOCTYPE MODE SYSTEM "xmode.dtd"&gt;
&lt;&lt; remarks &gt;&gt;

&lt;MODE&gt;
    &lt;PROPS&gt;
        &lt;PROPERTY NAME="indentPrevLine" VALUE="\s*.{3,}:\s*(#.*)?" /&gt;
        &lt;PROPERTY NAME="lineComment" VALUE="#" /&gt;
    &lt;/PROPS&gt;
    &lt;RULES ESCAPE="\" IGNORE_CASE="FALSE" HIGHLIGHT_DIGITS="TRUE"&gt;
        &lt;&lt; comments &gt;&gt;
        &lt;&lt; literals &gt;&gt;
        &lt;&lt; operators &gt;&gt;
        &lt;MARK_PREVIOUS TYPE="FUNCTION" EXCLUDE_MATCH="TRUE"&gt;(&lt;/MARK_PREVIOUS&gt;
        &lt;&lt; keywords &gt;&gt;
    &lt;/RULES&gt;
&lt;/MODE&gt;</t>
<t tx="EKR.20040430160416.6">&lt;!-- Python mode, by Slava Pestov. Based on PythonTokenMarker by --&gt;
&lt;!-- Jonathan Revusky --&gt;

&lt;!-- Modified 19-Jul-00 by Ivan Frohne to: --&gt;
&lt;!--  (a) implement 'indentOnEnter'; --&gt;
&lt;!--  (b) indent next line automatically after control structures followed --&gt;
&lt;!--	  by ':'; --&gt;
&lt;!--  (c) make """ or ''' multiline quotes TYPE LITERAL2; --&gt;
&lt;!--  (d) add TYPE FUNCTION identified by a following '(' --&gt;
&lt;!--  (e) eliminate the '?' SEQ TYPE ('?' has no meaning in Python); --&gt;
&lt;!--  (f) change the TYPE of 'and', 'or', and 'not' to KEYWORD1; and --&gt;
&lt;!--  (g) add all builtin functions, builtin exceptions, --&gt;
&lt;!--	  builtin type methods, File object methods, and special type --&gt;
&lt;!--	  attributes as TYPE KEYWORD3. --&gt;</t>
<t tx="EKR.20040430160416.7">&lt;!-- Comment --&gt;
&lt;EOL_SPAN TYPE="COMMENT1"&gt;#&lt;/EOL_SPAN&gt;

&lt;!-- Triple-quotes --&gt;
&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;"""&lt;/BEGIN&gt;
    &lt;END&gt;"""&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL2"&gt;
    &lt;BEGIN&gt;'''&lt;/BEGIN&gt;
    &lt;END&gt;'''&lt;/END&gt;
&lt;/SPAN&gt;</t>
<t tx="EKR.20040430160416.8">&lt;!-- Standard literals --&gt;
&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;"&lt;/BEGIN&gt;
    &lt;END&gt;"&lt;/END&gt;
&lt;/SPAN&gt;

&lt;SPAN TYPE="LITERAL1"&gt;
    &lt;BEGIN&gt;'&lt;/BEGIN&gt;
    &lt;END&gt;'&lt;/END&gt;
&lt;/SPAN&gt;
</t>
<t tx="EKR.20040430160416.9">&lt;SEQ TYPE="OPERATOR"&gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;!&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;=&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;+&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;-&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;/&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;*&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;gt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;lt;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;%&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;&amp;amp;&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;|&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;^&lt;/SEQ&gt;
&lt;SEQ TYPE="OPERATOR"&gt;~&lt;/SEQ&gt;</t>
<t tx="EKR.20040430160416.10">&lt;KEYWORDS&gt;
    &lt;&lt; reserved words &gt;&gt;
    &lt;&lt; builtins &gt;&gt;
    &lt;&lt; exceptions &gt;&gt;
    &lt;&lt; types &gt;&gt;
&lt;/KEYWORDS&gt;</t>
<t tx="EKR.20040430160416.11">&lt;!--  Reserved Words  --&gt;
&lt;KEYWORD1&gt;and&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;as&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;assert&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;break&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;class&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;continue&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;def&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;del&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;elif&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;else&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;except&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;exec&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;finally&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;for&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;from&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;global&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;if&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;import&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;in&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;is&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;lambda&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;not&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;or&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;pass&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;print&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;raise&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;return&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;try&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;while&lt;/KEYWORD1&gt;
&lt;KEYWORD1&gt;yield&lt;/KEYWORD1&gt;</t>
<t tx="EKR.20040430160416.12">&lt;!-- builtins --&gt;
&lt;KEYWORD2&gt;abs&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;apply&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;bool&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;buffer&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;callable&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;chr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;classmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;cmp&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;coerce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;compile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;complex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;delattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dict&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;dir&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;divmod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;eval&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;execfile&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;file&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;filter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;float&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;getattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;globals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hasattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hash&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;hex&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;id&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;int&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;intern&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;isinstance&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;issubclass&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;iter&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;len&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;list&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;locals&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;long&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;map&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;max&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;min&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;object&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;oct&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;open&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;ord&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;pow&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;property&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;range&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;raw_input&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reduce&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;reload&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;repr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;round&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;setattr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;slice&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;staticmethod&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;str&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;super&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;tuple&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;type&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unichr&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;unicode&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;vars&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;xrange&lt;/KEYWORD2&gt;
&lt;KEYWORD2&gt;zip&lt;/KEYWORD2&gt;</t>
<t tx="EKR.20040430160416.13">&lt;!-- exceptions --&gt;
&lt;KEYWORD3&gt;ArithmeticError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AssertionError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;AttributeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DeprecationWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EOFError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EnvironmentError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Exception&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatingPointError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IOError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ImportError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndentationError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IndexError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;KeyboardInterrupt&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LookupError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MemoryError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NameError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplemented&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NotImplementedError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OSError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;OverflowWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ReferenceError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;RuntimeWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StandardError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StopIteration&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SyntaxWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SystemExit&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TabError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundLocalError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UserWarning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ValueError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;Warning&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;WindowsError&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ZeroDivisionError&lt;/KEYWORD3&gt;</t>
<t tx="EKR.20040430160416.14">&lt;!-- types (from types module) --&gt;
&lt;KEYWORD3&gt;BufferType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinFunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;BuiltinMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ClassType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;CodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ComplexType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictProxyType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;DictionaryType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;EllipsisType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FileType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FloatType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FrameType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;FunctionType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;GeneratorType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;InstanceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;IntType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LambdaType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ListType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;LongType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;MethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ModuleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;NoneType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;ObjectType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;SliceType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;StringTypes&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TracebackType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TupleType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;TypeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnboundMethodType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;UnicodeType&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;XRangeType&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;False&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;None&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;True&lt;/KEYWORD3&gt;

&lt;KEYWORD3&gt;__abs__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__add__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__all__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__author__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__bases__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__builtins__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__call__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__class__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__cmp__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__coerce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__contains__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__debug__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__del__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__delslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__dict__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__div__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__divmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__doc__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__eq__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__file__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__float__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__floordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__future__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ge__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getattribute__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__getslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__gt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hash__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__hex__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iadd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__import__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__imul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__init__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__int__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__invert__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__iter__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__le__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__len__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__long__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__lt__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__members__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__metaclass__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mro__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__mul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__name__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ne__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__neg__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__new__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__nonzero__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__oct__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__or__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__path__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pos__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__pow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__radd__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rdivmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__reduce__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__repr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rfloordiv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rlshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmod__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rmul__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__ror__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rpow__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rrshift__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rsub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rtruediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__rxor__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setattr__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setitem__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__setslice__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__self__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__slots__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__str__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__sub__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__truediv__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__version__&lt;/KEYWORD3&gt;
&lt;KEYWORD3&gt;__xor__&lt;/KEYWORD3&gt;</t>
<t tx="EKR.20040430162649.1"></t>
<t tx="EKR.20040430162649.2"></t>
<t tx="EKR.20040430162649.3">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.4">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.5">@nocolor

I tried to write out text containing characters like:
ä ö ü Ä Ö Ü ß ø ó
with @file-asis and get:

UnicodeError: ASCII encoding error: ordinal not in range(128)

@file (without option) works fine.</t>
<t tx="EKR.20040430162649.6">@ignore

Ä á Û</t>
<t tx="EKR.20040430162649.7">@encoding iso-8859-1</t>
<t tx="EKR.20040430162649.8"></t>
<t tx="EKR.20040430162649.9"></t>
<t tx="EKR.20040430162649.10">@encoding cp1252
@others</t>
<t tx="EKR.20040430162649.11">aÖb</t>
<t tx="EKR.20040430162649.12">@ignore</t>
<t tx="EKR.20040430162649.13">@language perlpod
@path c:\prog\test</t>
<t tx="EKR.20040430162649.14">@root perlpod.txt
@ Multi-line
doc part
&lt;&lt;ref&gt;&gt;</t>
<t tx="EKR.20040430162649.15">@ doc part2
@c
code line1
code line2
@ more doc part</t>
<t tx="EKR.20040430162649.16">@comment REM_</t>
<t tx="EKR.20040430162649.17">test 6</t>
<t tx="EKR.20040430162649.19">@language plain
@comment # /* */

This is plain text.

# This is a comment.

More plain text.

/* A block comment
ths continues */

More plain text.</t>
<t tx="EKR.20040430162649.20">@ atFile.directiveKind is return miscDirective on _any_ line that starts with @</t>
<t tx="EKR.20040430162649.21">@ignore

line 1
@line 2
    @line 3
line 4</t>
<t tx="EKR.20040430162649.22">@nocolor
@pagewidth 40

A one-line paragraph one two three four five six seven eight nine ten...

An @rawfile tree is a tree whose root headline starts with
@rawfile &lt;filename&gt;. Similarly, an @silentfile tree is a
tree whose root headline starts with an @silentfile
&lt;filename&gt; directive.

    Leo creates derived files from @rawfile and @silentfile trees by writing the body text of all nodes of the tree in outline order.  Leo writes the body text _as is_, without recognizing section definitions, without expanding section references, and without treating directives specially in any way.  In particular, Leo copies all directives, including @space or @c directives, to the derived file as text. Exception: Leo recognizes the @ignore directive in @rawfile or @silentfile nodes, so you may use the @ignore directive as usual to prevent Leo from writing @rawfile and @silentfile trees.

There are several difference between @rawfile and @silentfile trees:
    
  This
  is
  a
  test.

  1. This is the first line and it is really really really long. And it has
     a hanging indentation.
     and another line.

  2. This is a lllllllllllllllllllllllllllllllllllloooooooooooooooooong
     next item.
     And it too has a hanging indentation.

  3. This is an exxxxxxxxxxxxxxxxxxxxxxxxtrrrrrrrrrrrrrrreeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeemlylong
     word.
And it too has a hanging indentation.</t>
<t tx="EKR.20040430162649.23">@ignore</t>
<t tx="EKR.20040430162649.24">enabling: *
Exception in Tkinter callback
Traceback (most recent call last):
  File "c:\python22\lib\lib-tk\Tkinter.py", line 1292, in __call__
    return apply(self.func, args)
  File "leoFrame.py", line 1368, in OnTangle
    self.commands.tangleCommands.tangle()
  File "leoTangle.py", line 507, in tangle
    self.tangleTree(v,report_errors)
  File "leoTangle.py", line 644, in tangleTree
    self.tanglePass1(v) # sets self.v
  File "leoTangle.py", line 589, in tanglePass1
    self.skip_body(v)
  File "leoTangle.py", line 1062, in skip_body
    self.st_enter_root_name(old_root_name,code,doc)
  File "leoTangle.py", line 2040, in st_enter_root_name
    assert(code)
AssertionError
</t>
<t tx="EKR.20040430162649.25">@root a.txt
@ 

@root a.txt 
some text 
@ </t>
<t tx="EKR.20040504083716">@language python

import leoGlobals as g
import shutil

testing = True

sourcedir=r"c:/prog/test/perfectImport"
targetdir=r"c:/prog/test/perfectImport/leo"
s1 = g.os_path_join(sourcedir,"leoAtFile.py")
t1 = g.os_path_join(targetdir,"leoAtFile.py")
files = [(s1,t1)]

@others

print ; print '-' * 20

sync(files) # push or pull, depending on date.
</t>
<t tx="EKR.20040504083716.39">def sync(files):
    
    """Do a pull or a push, depending on the date of the files."""
    
    none, push, pull = 'None', 'push', 'pull'
    mu = g.mulderUpdateAlgorithm()

    for sourcefilename, targetfilename in files:
        &lt;&lt; compute sourcetime and targettime &gt;&gt;
        &lt;&lt; compute operation &gt;&gt;
        if operation == push:
            if testing: print push, sourcefilename, targetfilename
            strippedLines = mu.removeSentinelsFromFile(sourcefilename)
            mu.write_if_changed(strippedLines,sourcefilename,targetfilename)
            mu.copy_time(sourcefilename,targetfilename)
        elif operation == pull:
            if testing: print pull, sourcefilename, targetfilename
            if sourcetime:
                mu.propagateDiffsToSentinelsFile(sourcefilename,targetfilename)
                mu.copy_time(targetfilename,sourcefilename)
            else:
                shutil.copy2(targetfilename,sourcefilename)</t>
<t tx="EKR.20040504083716.44"># This is some basic testing.

@ignore</t>
<t tx="EKR.20040504083716.45">@others</t>
<t tx="EKR.20040504083716.47">class sentinel_test(TestCase):
    @others</t>
<t tx="EKR.20040504083716.48">def setUp(self):
    self.prefix = ["#@+leo-ver=4\n",
"#@+node:@file sentinel.py\n",
"#@@language python\n"]
    self.postfix = ["#@-node:@file sentinel.py\n",
"#@-leo\n"]
</t>
<t tx="EKR.20040504083716.49">def setup_inputfile(self, input):
    classname = self.__class__.__name__
    self.input_filename = os.path.join('test/s_%s.txt' % classname)
    self.output_filename = os.path.join('test/d_%s.txt' % classname)
    outfile = file(self.input_filename, "w")
    for line in input:
        outfile.write(line)
    outfile.close()
    
    
 
</t>
<t tx="EKR.20040504083716.50">def setup_configfile(self):
    self.configfilename = "test/sentinel.cfg"
    outfile = file(self.configfilename, "w")
    outfile.write("[sentinel]\n")
    outfile.write("\ns1=%s\n" % self.input_filename)
    outfile.write("\nd1=%s\n" % self.output_filename)
    outfile.close()

</t>
<t tx="EKR.20040504083716.51"></t>
<t tx="EKR.20040504083716.52">class insert_test(sentinel_test):
    @others</t>
<t tx="EKR.20040504083716.53">def setUp(self):
    sentinel_test.setUp(self)
    self.setup_inputfile(self.prefix + 
["Proof of concept implementation of sentinel free Leo files.\n",
"We try to insert a line after here\n",
"This should be after the inserted line\n",
"This should be the last line in the file\n"]
 + self.postfix)

    # here are the same lines, without sentinels
    self.lines = ["Proof of concept implementation of sentinel free Leo files.\n",
     "We try to insert a line after here\n",
     "This should be after the inserted line\n",
     "This should be the last line in the file\n"]
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.54">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert one line in the sentinel free output.
    lines = self.lines
    lines[2:2] = ["This is an inserted line\n"]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.55"></t>
<t tx="EKR.20040504083716.56">class replace_test(sentinel_test):
    """
    Replace a single line.
    """
    @others</t>
<t tx="EKR.20040504083716.57">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
     "Proof of concept implementation of sentinel free Leo files.\n",
     "This line should be replaced\n",
     "This should be the last line in the file\n"]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.58">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert one line in the sentinel free output.
    lines = self.lines
    lines[2:2] = ["This is a replaced line\n"]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.59">class replace_test2(sentinel_test):
    """
    Replace two lines.
    """
    @others</t>
<t tx="EKR.20040504083716.60">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "Line 0\n",    #0
"   Line 1\n",    #1
"   Line 2.\n",   #2
"   Line 3.\n",   #3
"   Line 4\n",    #4
"\n", #5
" We have two subclasses:\n", #6
"   single_clss represents a (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #7
"   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #8
"\n", #9
" Line 10\n", #10
" Line 11\n" #11
]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.61">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == self.lines
    
    # then insert two lines in the sentinel free output.
    lines = self.lines
    lines[7:9] = ["   single_class represents a (condition, register) =&gt; (expression_number, linenumber) mapping.\n", #7
                      "   set_class represents a set of (condition, register) =&gt; (expression_number, linenumber) mappings.\n", #8
                     ]
    outfile = file(self.output_filename, "w")
    for line in lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.62">class replace_test3(sentinel_test):
    """
    Replace the lines of a whole node.
    """
    @others</t>
<t tx="EKR.20040504083716.63">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "#@+node:main\n",
    "node 1: line 1\n", # 1
    "node 1: line 2\n", # 2
    "#@-node:main\n",
    "#@-others\n",
    "node 2: line 3\n", # 3
    "node 2: line 4\n", # 4
    "#@-node:@file sentinel.py\n",
    ]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.64">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    filtered_lines = sentinel.push_filter_lines(self.lines)[0]
    assert file(self.output_filename).readlines() == filtered_lines
    
    # then insert one line in the sentinel free output.
    filtered_lines [2:4] = [   "These lines should be totally different\n",
    "and be replaced across sentinel blocks,\n",

                     ]
    outfile = file(self.output_filename, "w")
    for line in filtered_lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == filtered_lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.65">class replace_test4(sentinel_test):
    """
    Replace the lines of a whole node.
    """
    @others</t>
<t tx="EKR.20040504083716.66">def setUp(self):
    sentinel_test.setUp(self)
    self.lines = [
    "#@+node:main\n",
    "node 1: line 1\n", # 1
    "node 1: line 2\n", # 2
    "#@-node:main\n",
    "#@-others\n",
    "node 2: line 3\n", # 3
    "node 2: line 4\n", # 4
    "#@-node:@file sentinel.py\n",
    ]
    self.setup_inputfile(self.prefix + self.lines + self.postfix)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.67">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    filtered_lines = sentinel.push_filter_lines(self.lines)[0]
    assert file(self.output_filename).readlines() == filtered_lines
    
    # then insert one line in the sentinel free output.
    filtered_lines [1:3] = [   "These lines should be totally different\n",
    "and be replaced across sentinel blocks,\n",

                     ]
    outfile = file(self.output_filename, "w")
    for line in filtered_lines:
        outfile.write(line)
    outfile.close()
    
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # re-generate the output.
    sentinel.main(self.configfilename, "push")
    
    # and check for equality.
    assert file(self.output_filename).readlines() == filtered_lines
    
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.68">@doc
these are tests representing errors which I encountered during the development of the code.</t>
<t tx="EKR.20040504083716.69">class regression_test_1(sentinel_test):
    """
    Replace a single line.
    """
    @others</t>
<t tx="EKR.20040504083716.70">def setUp(self):
    self.lines = [
"#@+leo-ver=4\n",
"#@+node:@file driver.py\n",
"#@@language python\n",
"#@+others\n",
"#@+node:imports\n",
"# Analyse an IA64 assembly file:\n",
"#   1. Identify basic blocks.\n",
"#   2. Track the contents of registers symbolically.\n",
"import os, sys, cmp_globals\n",
"\n",
"#@-node:imports\n",
"#@+node:process_file\n",
"def process_file(infile, pyname_full, configfile, firststep, laststep):\n",
"   \n",
"      proc()\n",
"#@nonl\n",
"#@-node:process_file\n",
"#@-others\n",
"#@-node:@file driver.py\n",
"#@-leo\n"
]
    self.setup_inputfile(self.lines)

    # here are the same lines, without sentinels
    self.setup_configfile()
</t>
<t tx="EKR.20040504083716.71">def runTest(self):
    """
    
    Insert a line in a file without sentinels of a file derived of a file with sentinels, and make sure that this line is inserted in the proper place.
    
    """
    
    # First, produce the sentinel free output.
    sentinel.main(self.configfilename, "push")
    
    # Verify this first step.
    assert os.path.exists(self.output_filename)
    assert file(self.output_filename).readlines() == sentinel.push_filter_lines(self.lines)[0]
        
    # get the sources back.
    sentinel.main(self.configfilename, "pull")
    
    # Now check that the source has not been changed.
    assert file(self.input_filename).readlines() == self.lines   
    
    
    
    
    



</t>
<t tx="EKR.20040504083716.72">if __name__ == '__main__':
    #fileName = os.path.join(os.getcwd(),"testing.ini")
    #config = ConfigParser.ConfigParser()
    #config.read(fileName)
    #main = "Main"
    #leodir = config.get(main, "leodir")
    #test_to_run = config.get(main, "test_to_run")
    test_to_run = 'all'
    
    if os.path.exists("test"):
        shutil.rmtree("test")
    os.mkdir("test")
    suite = TestSuite()
    if test_to_run == 'all':
        for testclass in (
            insert_test,
            replace_test,
            replace_test2,
            replace_test3,
            regression_test_1,         
        ):
            suite.addTest(testclass())
    else:
        suite.addTest(globals()[test_to_run]())
    testrunner = TextTestRunner()
    testrunner.run(suite)
 </t>
<t tx="EKR.20040504083716.73">@ignore</t>
<t tx="EKR.20040504083716.74">[Main]
test_to_run = all
# use all to run all tests.

cleanup = True
# Set to True if you want all files deleted.

leodir = C:/bwm/ftptoot/Cleo-4.1-beta-5</t>
<t tx="EKR.20040504083716.75"></t>
<t tx="EKR.20040504083716.76"></t>
<t tx="EKR.20040504083716.77"></t>
<t tx="EKR.20040504083716.78"></t>
<t tx="EKR.20040504153320">sourcetime = targettime = None

if g.os_path_exists(sourcefilename):
    sourcetime = g.os_path_getmtime(sourcefilename)

if g.os_path_exists(targetfilename):
    targettime = g.os_path_getmtime(targetfilename)</t>
<t tx="EKR.20040504153320.1">operation = None
if sourcetime:
    if targettime:
        if sourcetime &gt; targettime:
            operation = push
        elif sourcetime &lt; targettime:
            operation = pull
    else:
        operation = push
elif targettime:
    operation = pull</t>
<t tx="EKR.20040517074600.8">import leoGlobals as g
import leoTest

u = leoTest.testUtils()
nodes = 0 ; lines = 0
c = g.top()
c.clearAllVisited()
v = u.findNodeAnywhere(c,"Plugins &amp; scripts")
after = v.nodeAfterTree()
trace(v,after)
while v and v != after:
    if not v.t.isVisited():
        v.t.setVisited()
        nodes += 1
        lines += len(splitLines(v.bodyString()))
    v = v.threadNext()
    
pages = ((nodes * 10) + lines) / 50
print "nodes,lines,pages",nodes,lines,pages
g.es("nodes,lines,pages",nodes,lines,pages)</t>
<t tx="EKR.20040517074600.9"></t>
<t tx="EKR.20040517074600.10">import leoGlobals as g
config = g.app.config

font = config.getFontFromParams(
        "body_text_font_family", "body_text_font_size",
        "body_text_font_slant",  "body_text_font_weight",
        tag = "body")
        
print font

c = top() ; body = c.frame.body.bodyCtrl

print body

# body.configure(font=font)</t>
<t tx="EKR.20040517074600.11">import leoGlobals as g
import tkFont

@others

c = g.top()

# Body pane.
fn = c.frame.body.cget("font")
font = tkFont.Font(font=fn)
name,size,slant,weight = getFontSettings(font)
print "body:",fn,name,size,slant,weight

if 0:

    # Log pane.
    fn = c.frame.log.getFontConfig()
    font = tkFont.Font(font=fn)
    name,size,slant,weight = getFontSettings(font)
    g.es("log:" + name + "," + `size` + "," + slant + "," + weight)
    
    # Tree pane.
    font = c.frame.tree.getFont()
    name,size,slant,weight = getFontSettings(font)
    g.es("head:" + name + "," + `size` + "," + slant + "," + weight)</t>
<t tx="EKR.20040517074600.12">def getFontSettings (font):

    name   = font.cget("family")
    size   = font.cget("size")
    slant  = font.cget("slant")
    weight = font.cget("weight")

    return name, size, slant, weight</t>
<t tx="EKR.20040517074600.13">import leoGlobals as g

font = g.app.config.defaultFont

print font.cget("family"), font.cget("weight")</t>
<t tx="EKR.20040520104329"></t>
<t tx="EKR.20040523112430"></t>
<t tx="EKR.20040523112430.1"></t>
<t tx="EKR.20040523112430.2"></t>
<t tx="EKR.20040523112430.3"></t>
<t tx="EKR.20040523112430.4"></t>
<t tx="EKR.20040523112430.5"></t>
<t tx="EKR.20040523112430.6"></t>
<t tx="EKR.20040523112430.7"></t>
<t tx="EKR.20040523112430.8"></t>
<t tx="EKR.20040524050419">line 1
@others
&lt;&lt; defined in grandchild &gt;&gt;
last line</t>
<t tx="EKR.20040524050419.1">Organizer line</t>
<t tx="EKR.20040524050419.2">grandChild line</t>
<t tx="EKR.20040524050438"></t>
<t tx="EKR.20040525083635">@others</t>
<t tx="EKR.20040525083635.1"></t>
<t tx="EKR.20040526094831">import leoGlobals as g

def redoBletch(self):
    g.trace()
    
def undoBletch(self):
    g.trace()
    
c = g.top() ; u = c.undoer
p = c.currentPosition()

if 0:
    # bad functions
    u.registerUndoHandlers("Bletch","abc","xyz")
else:
    u.registerUndoHandlers("Bletch",undoBletch,redoBletch)
    
# "Execute" the Bletch command :-)  The Edit command should contain "Undo Bletch"
u.setUndoParams("Bletch",p)

# Selecting "Undo Bletch" will enable "Redo Bletch", etc.</t>
<t tx="EKR.20040526193608">import leoGlobals as g
import binascii
import pickle

d = { "a":True }

print '-' * 40

s = pickle.dumps(d,bin=True)
s2 = binascii.hexlify(s)
print `s`,s2

s3 = binascii.unhexlify(s2)
d2 = cPickle.loads(s3)

print `d2`
print d == d2, d is d2</t>
<t tx="EKR.20040526200017">import leoGlobals as g

c = g.top() ; p = c.currentPosition()


d = { "a":True }

if 1:
    # Warning: executing this in the a2 code base will cause any save operation to fail.
    p.v.unknownAttributes = { "myPlugin" : d }
    
print repr(p.v.unknownAttributes)</t>
<t tx="EKR.20040527072047"></t>
<t tx="EKR.20040527072047.1"></t>
<t tx="EKR.20040527073459"></t>
<t tx="EKR.20040527074524"></t>
<t tx="EKR.20040527074524.1"></t>
<t tx="EKR.20040527074524.2"></t>
<t tx="EKR.20040527083449.1">nodes = []
for v in current.unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in current.unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="EKR.20040527083449.2">if 0:
    for v in current.vnodes_iter(): print v
    for v in current.unique_vnodes_iter(): print v

if 0: # subtree of root node:
    root = c.rootPosition()
    for v in root.vnodes_iter(): print v
    for t in root.tnodes_iter(): print t

if 0: # child1's tree.  child2 should not be included.
    for v in child.vnodes_iter(): print v
    for t in child.tnodes_iter(): print t</t>
<t tx="EKR.20040527154402">line 1

&lt;&lt; sec &gt;&gt;
sec line 1
sec line 2

last line</t>
<t tx="EKR.20040528130659">d</t>
<t tx="EKR.20040528152529">import leoNodes
import leoGlobals as g

c = g.top()
current = c.currentPosition()
child = current.firstChild()

allList = [p.v for p in c.all_positions_iter()]
vList1 = [v for v in current.vnodes_iter()]
vList2 = [v for v in current.unique_vnodes_iter()]

if 0:
    for v in vList1: print v
    for v in vList2: print v

if 0:
    print len(allList),len(vList1),len(vList2)

&lt;&lt; tests of consistency of p and v iters &gt;&gt;
&lt;&lt; tests that node iterators return no duplicate nodes &gt;&gt;
&lt;&lt; print nodes returned by iterators &gt;&gt;</t>
<t tx="EKR.20040529092739">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

&lt;&lt; coverage tests &gt;&gt;
&lt;&lt; duplicate tests &gt;&gt;

if 0:
    print "vnodes",len([v for v in c.all_vnodes_iter()]),len([v for v in c.all_unique_vnodes_iter()])
    print "tnodes",len([t for t in c.all_tnodes_iter()]),len([t for t in c.all_unique_tnodes_iter()])

if 0: # all nodes
    for v in c.all_vnodes_iter(): print v
    for t in c.all_tnodes_iter(): print t
        
if 0: # unique nodes
    for v in c.all_unique_vnodes_iter(): print v
    for t in c.all_unique_tnodes_iter(): print t</t>
<t tx="EKR.20040529093047">v1 = [p.v for p in c.all_positions_iter()]
v2 = [v for v in c.all_vnodes_iter()]
for v in v2: assert(v in v1)
for v in v1: assert(v in v2)

t1 = [p.v.t for p in c.all_positions_iter()]
t2 = [t for t in c.all_tnodes_iter()]
for t in t2: assert(t in t1)
for t in t1: assert(t in t2)

# print "coverage tests pass"</t>
<t tx="EKR.20040529093047.1">nodes = []
for v in c.all_unique_vnodes_iter():
    assert v not in nodes
    nodes.append(v)
    
nodes = []
for t in c.all_unique_tnodes_iter():
    assert t not in nodes
    nodes.append(t)
    
# print "duplicate tests pass"</t>
<t tx="EKR.20040529104307">try:
    tag = "test1"
    list1 = [v for v in current.vnodes_iter()]
    list2 = [v for v in current.v.self_and_subtree_iter()]
    assert(list1==list2)
    
    tag = "test2"
    list1 = [p.v for p in c.all_positions_iter()]
    list2 = [v   for v in c.all_vnodes_iter()]
    assert(list1==list2)
    
    # print "consistency tests pass"

except AssertionError:
    print tag
    print "list1"
    for v in list1: print v
    print "list2"
    for v in list2: print v
    raise</t>
<t tx="EKR.20040529105640"></t>
<t tx="EKR.20040531110157">@ignore</t>
<t tx="EKR.20040602101648">import leoGlobals as g
import leoPlugins

def onEnd (tag,keys):
    print "onEnd",tag,keys
    
count = 0
    
def onIdle (tag,keys):
    global count ; count += 1
    if count % 10 == 0:
        print "onIdle",count,keys.get("c")

leoPlugins.registerHandler("end1", onEnd)
print "onEnd registered as end1 hook"

leoPlugins.registerHandler("idle", onIdle)
print "onIdle registered as idle hook"</t>
<t tx="EKR.20040603064545">import leoGlobals as g

c = g.top()

for p in c.all_positions_iter():
    print p.v.t.fileIndex</t>
<t tx="EKR.20040603103118">@language html

b = "cd"
d
</t>
<t tx="EKR.20040603174633">import leoGlobals as g
c = g.top()
print c.frame.bodyCtrl.focus()</t>
<t tx="EKR.20040604082113">@tabwidth -4

    
    a   b   c
a   b   c   d
aa  b   c   d
aaa b   c   d
end</t>
<t tx="EKR.20040604170105">import leoGlobals as g
import os

c = g.top()

print os.getcwd()
name = g.os_path_join("test","removeSentTest.txt")
c.importCommands.removeSentinelsCommand(name)</t>
<t tx="EKR.20040605200750">string.join

__add__

'a'.__add__


def test(a,b): pass

v.copyTree(self,root)</t>
<t tx="EKR.20040606204316">@ignore</t>
<t tx="EKR.20040606204316.1"></t>
<t tx="EKR.20040608092841">@tabwidth -4

    a
    b</t>
<t tx="EKR.20040608095146">@language python
@tabwidth -4</t>
<t tx="EKR.20040608095146.1">@ignore
@language html

&lt;!--- Get all records from the database that match this users credentials ---&gt;
&lt;cfquery name="qLoginVerify" datasource="xxxx"&gt;
SELECT user_name, user_pass, course_dir
FROM login
WHERE user_name = '#user_name#'
AND user_pass = '#user_pass#'
AND course_dir = '#course_dir#'
&lt;/cfquery&gt;

&lt;cfif qLoginVerify.RecordCount&gt;
&lt;!--- This user has logged in correctly; 
change the value of the session.allowin value ---&gt;
&lt;cfset session.allowin = session.directoryshort&gt;
&lt;/cfif&gt;

&lt;!--- now redirect to "index.cfm", which will go to login if problem ---&gt;

&lt;cflocation url="#session.location#"&gt;
</t>
<t tx="EKR.20040610092248">@killcolor

Note: Previously, one could crash Leo by pasting a large text into a headline.  Leo now truncates that text, and furthermore Leo no longer makes all headline text into one gigantic line.  Therefore, we don't have to test Tk's ability to handle super-long lines.

The test:  Copy the following and paste it into a headline.  Leo should give 2 truncation messages:

- Truncating headline to one line.
- Truncating headline to 250 characters.

About a year ago I found the website at www.literateprogamming.com and was immediately convinced that the basic idea of Literate Programming is an important breakthrough. At the time I was working on a contract trying to decipher a true masterpiece of over-engineering, and if at any time during the construction of this masterpiece the perpetrators had been required to explain themselves in English, my client would have saved millions of dollars.

I never did try CWEB or NOWEB though, because on the literate programming site I read about a tool named “Leo” that combined outlines with Literate Programming techniques. Since I’ve always found outlining tools very useful I downloaded and tried this. I found that using this tool completely changed my programming practice and brought out all of the power inherent in the original Literate Programming idea as I understood it.</t>
<t tx="EKR.20040610131858"></t>
<t tx="EKR.20040610131858.1">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

print p.v.t.fileIndex,p.v.t</t>
<t tx="EKR.20040610132739">&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;leo_file&gt;
&lt;leo_header file_format="1" tnodes="1" max_tnode_index="1"/&gt;
&lt;vnodes&gt;
&lt;v t="EKR.20040610131858.1" a="TV"&gt;&lt;vh&gt;a&lt;/vh&gt;&lt;/v&gt;
&lt;/vnodes&gt;
&lt;tnodes&gt;
&lt;t tx="EKR.20040610131858.1"&gt;import leoGlobals as g

c = g.top() ; p = c.currentPosition()

print p.v.t.fileIndex&lt;/t&gt;
&lt;/tnodes&gt;
&lt;/leo_file&gt;
</t>
<t tx="EKR.20040610143643"></t>
<t tx="EKR.20040610192622">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

import compiler

next = p.next()
s = next.bodyString()
headline = next.headString()

try:
    val = compiler.parse(s)
    # print val
    g.es("Syntax OK: %s" % headline,color="blue")
except SyntaxError:
    g.es("Syntax error: %s" % headline,color="blue")</t>
<t tx="EKR.20040610192622.1">import string

string.join(a,b]
</t>
<t tx="EKR.20040610194209">import leoGlobals as g
import tabnanny

@others

# print '-' * 20

c = g.top()
p = c.currentPosition()
next = p.next()
s = next.bodyString()
headline = next.headString()

checkString(s,headline)</t>
<t tx="EKR.20040610194209.1">@tabwidth 4

# Tabnanny _only_ checks errors involving tabs.
# It does _not_ check other indentation errors.
# It does _not_ check syntax.

    a = 5
	b = 6 #Contains tab.
    c = 3</t>
<t tx="EKR.20040610195543">def checkString (s,headline):

    """Check indentation using tabnanny.process_tokens."""

    # This code is based on tabnanny.check.
    
    import tokenize

    try:
        # readline = g.readLinesGenerator(s).next
        readline = g.readLinesClass(s).next
        tabnanny.process_tokens(tokenize.generate_tokens(readline))

    except tokenize.TokenError, msg:

        g.es("Token error in %s" % headline,color="red")
        g.es(str(msg))
        return

    except tabnanny.NannyNag, nag:

        badline = nag.get_lineno()
        line    = nag.get_line()
        message = nag.get_msg()

        g.es("Indentation error in %s, line %d" % (headline, badline),color="red")
        g.es(message)
        g.es("offending line:\n%s" % repr(str(line))[1:-1])
        return
        
    except:
        g.trace("unexpected exception")
        return
        
    g.es("Indentation OK: %s" % headline,color="blue")
</t>
<t tx="EKR.20040610195543.1">@ignore
@language python
&lt;&lt; tabnanny declarations &gt;&gt;
@others

if __name__ == '__main__':
    main()
</t>
<t tx="EKR.20040610195543.2">#! /usr/bin/env python

"""The Tab Nanny despises ambiguous indentation.  She knows no mercy.

tabnanny -- Detection of ambiguous indentation

For the time being this module is intended to be called as a script.
However it is possible to import it into an IDE and use the function
check() described below.

Warning: The API provided by this module is likely to change in future
releases; such changes may not be backward compatible.
"""

# Released to the public domain, by Tim Peters, 15 April 1998.

# XXX Note: this is now a standard library module.
# XXX The API needs to undergo changes however; the current code is too
# XXX script-like.  This will be addressed later.

__version__ = "6"

import os
import sys
import getopt
import tokenize
if not hasattr(tokenize, 'NL'):
    raise ValueError("tokenize.NL doesn't exist -- tokenize module too old")

__all__ = ["check", "NannyNag", "process_tokens"]

verbose = 0
filename_only = 0</t>
<t tx="EKR.20040610195543.3">def errprint(*args):
    sep = ""
    for arg in args:
        sys.stderr.write(sep + str(arg))
        sep = " "
    sys.stderr.write("\n")
</t>
<t tx="EKR.20040610195543.4">def main():
    global verbose, filename_only
    try:
        opts, args = getopt.getopt(sys.argv[1:], "qv")
    except getopt.error, msg:
        errprint(msg)
        return
    for o, a in opts:
        if o == '-q':
            filename_only = filename_only + 1
        if o == '-v':
            verbose = verbose + 1
    if not args:
        errprint("Usage:", sys.argv[0], "[-v] file_or_directory ...")
        return
    for arg in args:
        check(arg)</t>
<t tx="EKR.20040610195543.5">
class NannyNag(Exception):
    """
    Raised by tokeneater() if detecting an ambiguous indent.
    Captured and handled in check().
    """
    @others
</t>
<t tx="EKR.20040610195543.6">def __init__(self, lineno, msg, line):
    self.lineno, self.msg, self.line = lineno, msg, line
</t>
<t tx="EKR.20040610195543.7">def get_lineno(self):
    return self.lineno
</t>
<t tx="EKR.20040610195543.8">def get_msg(self):
    return self.msg
</t>
<t tx="EKR.20040610195543.9">def get_line(self):
    return self.line
</t>
<t tx="EKR.20040610195543.10">def check(file):
    """check(file_or_dir)

    If file_or_dir is a directory and not a symbolic link, then recursively
    descend the directory tree named by file_or_dir, checking all .py files
    along the way. If file_or_dir is an ordinary Python source file, it is
    checked for whitespace related problems. The diagnostic messages are
    written to standard output using the print statement.
    """

    if os.path.isdir(file) and not os.path.islink(file):
        if verbose:
            print "%s: listing directory" % `file`
        names = os.listdir(file)
        for name in names:
            fullname = os.path.join(file, name)
            if (os.path.isdir(fullname) and
                not os.path.islink(fullname) or
                os.path.normcase(name[-3:]) == ".py"):
                check(fullname)
        return

    try:
        f = open(file)
    except IOError, msg:
        errprint("%s: I/O Error: %s" % (`file`, str(msg)))
        return

    if verbose &gt; 1:
        print "checking", `file`, "..."

    try:
        process_tokens(tokenize.generate_tokens(f.readline))

    except tokenize.TokenError, msg:
        errprint("%s: Token Error: %s" % (`file`, str(msg)))
        return

    except NannyNag, nag:
        badline = nag.get_lineno()
        line = nag.get_line()
        if verbose:
            print "%s: *** Line %d: trouble in tab city! ***" % (
                `file`, badline)
            print "offending line:", `line`
            print nag.get_msg()
        else:
            if ' ' in file: file = '"' + file + '"'
            if filename_only: print file
            else: print file, badline, `line`
        return

    if verbose:
        print "%s: Clean bill of health." % `file`
</t>
<t tx="EKR.20040610195543.11">
class Whitespace:
    &lt;&lt; class Whitespace declarations &gt;&gt;
    @others
</t>
<t tx="EKR.20040610195543.12"># the characters used for space and tab
S, T = ' \t'

# members:
#   raw
#       the original string
#   n
#       the number of leading whitespace characters in raw
#   nt
#       the number of tabs in raw[:n]
#   norm
#       the normal form as a pair (count, trailing), where:
#       count
#           a tuple such that raw[:n] contains count[i]
#           instances of S * i + T
#       trailing
#           the number of trailing spaces in raw[:n]
#       It's A Theorem that m.indent_level(t) ==
#       n.indent_level(t) for all t &gt;= 1 iff m.norm == n.norm.
#   is_simple
#       True iff raw[:n] is of the form (T*)(S*)

</t>
<t tx="EKR.20040610195543.13">def __init__(self, ws):
    self.raw  = ws
    S, T = Whitespace.S, Whitespace.T
    count = []
    b = n = nt = 0
    for ch in self.raw:
        if ch == S:
            n = n + 1
            b = b + 1
        elif ch == T:
            n = n + 1
            nt = nt + 1
            if b &gt;= len(count):
                count = count + [0] * (b - len(count) + 1)
            count[b] = count[b] + 1
            b = 0
        else:
            break
    self.n    = n
    self.nt   = nt
    self.norm = tuple(count), b
    self.is_simple = len(count) &lt;= 1
</t>
<t tx="EKR.20040610195543.14"># return length of longest contiguous run of spaces (whether or not
# preceding a tab)
def longest_run_of_spaces(self):
    count, trailing = self.norm
    return max(len(count)-1, trailing)
</t>
<t tx="EKR.20040610195543.15">def indent_level(self, tabsize):
    # count, il = self.norm
    # for i in range(len(count)):
    #    if count[i]:
    #        il = il + (i/tabsize + 1)*tabsize * count[i]
    # return il

    # quicker:
    # il = trailing + sum (i/ts + 1)*ts*count[i] =
    # trailing + ts * sum (i/ts + 1)*count[i] =
    # trailing + ts * sum i/ts*count[i] + count[i] =
    # trailing + ts * [(sum i/ts*count[i]) + (sum count[i])] =
    # trailing + ts * [(sum i/ts*count[i]) + num_tabs]
    # and note that i/ts*count[i] is 0 when i &lt; ts

    count, trailing = self.norm
    il = 0
    for i in range(tabsize, len(count)):
        il = il + i/tabsize * count[i]
    return trailing + tabsize * (il + self.nt)
</t>
<t tx="EKR.20040610195543.16"># return True iff self.indent_level(t) == other.indent_level(t)
# for all t &gt;= 1
def equal(self, other):
    return self.norm == other.norm
</t>
<t tx="EKR.20040610195543.17"># return a list of tuples (ts, i1, i2) such that
# i1 == self.indent_level(ts) != other.indent_level(ts) == i2.
# Intended to be used after not self.equal(other) is known, in which
# case it will return at least one witnessing tab size.
def not_equal_witness(self, other):
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    a = []
    for ts in range(1, n+1):
        if self.indent_level(ts) != other.indent_level(ts):
            a.append( (ts,
                       self.indent_level(ts),
                       other.indent_level(ts)) )
    return a
</t>
<t tx="EKR.20040610195543.18"># Return True iff self.indent_level(t) &lt; other.indent_level(t)
# for all t &gt;= 1.
# The algorithm is due to Vincent Broman.
# Easy to prove it's correct.
# XXXpost that.
# Trivial to prove n is sharp (consider T vs ST).
# Unknown whether there's a faster general way.  I suspected so at
# first, but no longer.
# For the special (but common!) case where M and N are both of the
# form (T*)(S*), M.less(N) iff M.len() &lt; N.len() and
# M.num_tabs() &lt;= N.num_tabs(). Proof is easy but kinda long-winded.
# XXXwrite that up.
# Note that M is of the form (T*)(S*) iff len(M.norm[0]) &lt;= 1.
def less(self, other):
    if self.n &gt;= other.n:
        return False
    if self.is_simple and other.is_simple:
        return self.nt &lt;= other.nt
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    # the self.n &gt;= other.n test already did it for ts=1
    for ts in range(2, n+1):
        if self.indent_level(ts) &gt;= other.indent_level(ts):
            return False
    return True
</t>
<t tx="EKR.20040610195543.19"># return a list of tuples (ts, i1, i2) such that
# i1 == self.indent_level(ts) &gt;= other.indent_level(ts) == i2.
# Intended to be used after not self.less(other) is known, in which
# case it will return at least one witnessing tab size.
def not_less_witness(self, other):
    n = max(self.longest_run_of_spaces(),
            other.longest_run_of_spaces()) + 1
    a = []
    for ts in range(1, n+1):
        if self.indent_level(ts) &gt;= other.indent_level(ts):
            a.append( (ts,
                       self.indent_level(ts),
                       other.indent_level(ts)) )
    return a
</t>
<t tx="EKR.20040610195543.20">def format_witnesses(w):
    firsts = map(lambda tup: str(tup[0]), w)
    prefix = "at tab size"
    if len(w) &gt; 1:
        prefix = prefix + "s"
    return prefix + " " + ', '.join(firsts)
</t>
<t tx="EKR.20040610195543.21">def process_tokens(tokens):
    INDENT = tokenize.INDENT
    DEDENT = tokenize.DEDENT
    NEWLINE = tokenize.NEWLINE
    JUNK = tokenize.COMMENT, tokenize.NL
    indents = [Whitespace("")]
    check_equal = 0

    for (type, token, start, end, line) in tokens:
        if type == NEWLINE:
            # a program statement, or ENDMARKER, will eventually follow,
            # after some (possibly empty) run of tokens of the form
            #     (NL | COMMENT)* (INDENT | DEDENT+)?
            # If an INDENT appears, setting check_equal is wrong, and will
            # be undone when we see the INDENT.
            check_equal = 1

        elif type == INDENT:
            check_equal = 0
            thisguy = Whitespace(token)
            if not indents[-1].less(thisguy):
                witness = indents[-1].not_less_witness(thisguy)
                msg = "indent not greater e.g. " + format_witnesses(witness)
                raise NannyNag(start[0], msg, line)
            indents.append(thisguy)

        elif type == DEDENT:
            # there's nothing we need to check here!  what's important is
            # that when the run of DEDENTs ends, the indentation of the
            # program statement (or ENDMARKER) that triggered the run is
            # equal to what's left at the top of the indents stack

            # Ouch!  This assert triggers if the last line of the source
            # is indented *and* lacks a newline -- then DEDENTs pop out
            # of thin air.
            # assert check_equal  # else no earlier NEWLINE, or an earlier INDENT
            check_equal = 1

            del indents[-1]

        elif check_equal and type not in JUNK:
            # this is the first "real token" following a NEWLINE, so it
            # must be the first token of the next program statement, or an
            # ENDMARKER; the "line" argument exposes the leading whitespace
            # for this statement; in the case of ENDMARKER, line is an empty
            # string, so will properly match the empty string with which the
            # "indents" stack was seeded
            check_equal = 0
            thisguy = Whitespace(line)
            if not indents[-1].equal(thisguy):
                witness = indents[-1].not_equal_witness(thisguy)
                msg = "indent not equal e.g. " + format_witnesses(witness)
                raise NannyNag(start[0], msg, line)
</t>
<t tx="EKR.20040610201236">@

To do:
    
- Specify which nodes to check.
- Check only Python code.
- use g.readLinesClass or similar code in existing Python module.</t>
<t tx="EKR.20040610201941">@

To do:
    
- Specify which nodes to check.
- Check only Python code.
- use g.readLinesClass or similar code in existing Python module.</t>
<t tx="EKR.20040611083703"># This kind of code is used in the prototypes of new commands.

from __future__ import generators

import leoGlobals as g

@others

lines = "a\nb\nc\nd"

if 1: # Both work
    readline = g.readLinesGenerator(lines).next
else:
    readline = g.readLinesClass(lines).next

print '-' * 20

if 1: # Both work
    for s in g.readLinesGenerator(lines):
        print s,
else:
    while 1:
        s = readline()
        if s: print s,
        else: break
    
print ; print '-' * 20</t>
<t tx="EKR.20040612095237">@language python
@tabwidth -4</t>
<t tx="EKR.20040612150543"># Test
@others
# Last</t>
<t tx="EKR.20040612215136">a = 1
print "hello"
c = b
</t>
<t tx="EKR.20040613162717">import leoGlobals as g

path = r"c:\prog\leoScripts(before).txt"
path = r"c:\prog\leoScripts(after).txt"

print g.top().currentPosition()

try:
    f = open(path,"rb")
    s = f.read()
    f.close()
    
    cr = 0 ; nl = 0
    for ch in s:
        if ch == '\r': cr += 1
        if ch == '\n': nl += 1
        
    g.es("cr %d, nl %d %s" % (cr,nl,path))

except IOError:
    print "can not open",path</t>
<t tx="EKR.20040615070332"># "LPT1:", "PRN:" and "PRN" all freeze

s = 'stuff\n'
port = 'USB002'

try:
    f = file(port,'w')
    f.write(s)
    f.flush()
    f.close()
    print "done"
except IOError:
    print "Can not open",port</t>
<t tx="EKR.20040615144735"></t>
<t tx="EKR.20040615144810">d</t>
<t tx="EKR.20040619133116"></t>
<t tx="EKR.20040622074004">@ignore</t>
<t tx="EKR.20040622074004.1"></t>
<t tx="EKR.20040622074004.2">node b, line 1 (changed 12)</t>
<t tx="EKR.20040622074004.3"></t>
<t tx="EKR.20040622102618"></t>
<t tx="EKR.20040623200709.75"></t>
<t tx="EKR.20040623200709.76">def makePluginsSuite(verbose=False,*args,**keys):
    
    """Create an plugins test for every .py file in the plugins directory."""
    
    plugins_path = g.os_path_join(g.app.loadDir,"..","plugins")
    
    files = glob.glob(g.os_path_join(plugins_path,"*.py"))
    files = [g.os_path_abspath(file) for file in files]
    files.sort()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    for file in files:
        test = pluginTestCase(file,verbose)
        suite.addTest(test)

    return suite
</t>
<t tx="EKR.20040623200709.77">class pluginTestCase(unittest.TestCase):
    
    """Unit tests for one Leo plugin."""
    
    @others</t>
<t tx="EKR.20040623200709.78">def __init__ (self,fileName,verbose):
    
    # Init the base class.
    unittest.TestCase.__init__(self)

    self.fileName = fileName
    self.oldGui = None
    self.verbose = verbose</t>
<t tx="EKR.20040623200709.79">def pluginTest (self):
    
    # Duplicate the import logic in leoPlugins.py.
    
    fileName = g.toUnicode(self.fileName,g.app.tkEncoding)
    path = g.os_path_join(g.app.loadDir,"..","plugins")
    
    if self.verbose:
        g.trace(str(g.shortFileName(fileName)))

    module = g.importFromPath(fileName,path)
    assert(module)
    
    # Run any unit tests in the module itself.
    if hasattr(module,"unitTest"):
        
        if self.verbose:
            g.trace("Executing unitTest in %s..." % str(g.shortFileName(fileName)))

        module.unitTest()</t>
<t tx="EKR.20040623200709.80">def runTest(self):

    self.pluginTest()</t>
<t tx="EKR.20040623200709.81">def setUp(self,*args,**keys):

    self.oldGui = g.app.gui
    # g.app.gui = leoTkinterGui.tkinterGui()</t>
<t tx="EKR.20040623200709.82">def shortDescription (self):
    
    return "pluginTestCase: " + self.fileName</t>
<t tx="EKR.20040623200709.83">def tearDown (self):

    g.app.gui = self.oldGui</t>
<t tx="EKR.20040623223148.11">def replaceOutline (self,c,outline1,outline2):
    
    """Replace outline1 by a copy of outline 2,
    
    retaining the headline of outline1."""

    u = self
    h = outline1.headString()
    copy = outline2.copyTreeAfter()
    copy.initHeadString(h)
    copy.unlink()
    copy.linkAfter(outline1)
    outline1.doDelete(copy)</t>
<t tx="EKR.20040625110032">@ignore

@others</t>
<t tx="EKR.20040625110032.1"></t>
<t tx="EKR.20040625110032.2"># @language html

@comment &lt;!-- --&gt;</t>
<t tx="EKR.20040625110032.3"></t>
<t tx="EKR.20040626212434"></t>
<t tx="EKR.20040626212434.1">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

mincolor,maxcolor=125,225

for n in xrange(5000):
    x,y = rand(0,900),rand(0,500)
    w = rand(1,10) ; h = w * r.uniform(0.5,1.5)
    color = "#%02x%02x%02x" % (rand(0,maxcolor/2),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    kind = rand(1,3)
    sign = rand(-1,1) # rand(0,2)-1
    if kind == 1:
        canvas.create_rectangle(x,y,x+w,y+h,fill=color,width=0)
    elif kind == 2:
        canvas.create_oval(x,y,x+w,y+h,fill=color,width=0)
    else:
        canvas.create_line(x,y,x+sign*5*w,y+5*h,fill=color)
    if 0: # Redrawing slows things down a lot.
        if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626212434.2">import leoGlobals as g
import Tkinter as Tk
import random as r

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top, height = "5i", width = "9i")
canvas.pack() ; top.update()
rand = r.randint

x,y = 10,10
mincolor,maxcolor=125,225

for n in xrange(2000):
    x2,y2 = rand(0,900),rand(0,500)
    color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
    width = "%fm" % r.uniform(0.1,0.6)
    canvas.create_line(x,y,x2,y2,fill=color,width=width)
    extent = rand(180,270)
    canvas.create_arc(x,y,x2,y2,outline=color,width=width,style="arc",extent=extent)
    x,y = x2,y2
    # if (n % 1000) == 0: top.update()</t>
<t tx="EKR.20040626213007">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

# Paul Klee
mincolor,maxcolor=125,225
xmax,ymax = 800,400
stipples = [None,"gray75"] # "gray12","gray25","gray50",]
h=w=90
for x in xrange(10,xmax,w):
    for y in xrange(10,ymax,h):
        color = "#%02x%02x%02x" % (rand(mincolor,maxcolor),rand(mincolor,maxcolor),rand(mincolor,maxcolor))
        range = h/6
        stipple = stipples[rand(0,len(stipples)-1)]
        dx = r.uniform(0.0,range) - range/2
        dy = r.uniform(0.0,range) - range/2
        canvas.create_rectangle(x+dx,y+dy,x+dx+w,y+dy+h,fill=color,width=0,stipple=stipple)</t>
<t tx="EKR.20040627100615">import leoGlobals as g

g.app.config.redirect_execute_script_output_to_log_pane = False

# Syntax error
print '

import leoGlobals as g
print g.app.config.redirect_execute_script_output_to_log_pane</t>
<t tx="EKR.20040627103732">@ignore</t>
<t tx="EKR.20040627103801"></t>
<t tx="EKR.20040627103902" lineYOffset="4b032e" icons="5d7100287d710128550577686572657102550a6265666f726549636f6e710355047870616471044b025504747970657105550466696c6571066806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286805680668084afdffffff6806582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6802550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e"></t>
<t tx="EKR.20040627121836">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

next = p.next()

t = next.v.t
v = next.v

for s in t.__dict__:
    print s,getattr(t,s)</t>
<t tx="EKR.20040627150213">import leoGlobals as g
import Tkinter as Tk
import random as r ; rand = r.randint

top = Tk.Toplevel(None) ; top.title("Drawing")
canvas = Tk.Canvas(top,height="5i",width="9i") # ,background="white")
canvas.pack() ; top.update()

@others

mincolor,maxcolor=125,225
xmax,ymax = 300,300
h=w=1
i = r.uniform(2.0,4.0)
j = r.uniform(-5.0,5.0)
power = r.uniform(1.1,1.2)
    #(1.5,1.7)
for n in xrange(1):
    i += 0.5
    j += 0.5
    power += 0.01
    print "i,j,power:",i,j,power
    c = complex(i,j)
    for format,m in (
        #("#%02x%02x%02x",256),
        #("#%03x%03x%03x",256*8),
        ("#%04x%04x%04x",256*256),
    ):
        for x in xrange(0,xmax,1):
            for y in xrange(0,ymax,1):
                n = complex(x,y)
                z = pow(c*n,power)
                n1 = int(z.real*m) ; n2 = int(z.imag*m)
                color = format % (n1%m,n2%m,abs(n1-n2)%m)
                # canvas.create_rectangle(w*x,h*y,w*x+w,h*y+h,fill=color,width=0)
                canvas.create_line(x,y,x+1,y+1,fill=color,width=1)
        top.update()
print "done"</t>
<t tx="ekr.20040302091705">import leoGlobals as g

class position:
    def __init__(self):
        self.v = "a"
    def move(self):
        self.v = "b"

p = position()
v = p.v
print "before", v, p.v, v is p.v
p.move()
print "after ", v, p.v, v is p.v</t>
<t tx="ekr.20040303063549.2">@ Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node

The parent to before and after nodes will contain pagewidth and language formatting directives
@c</t>
<t tx="ekr.20040303063549.3">@language plain
@pagewidth 40
@tabwidth 8

Wrap a long line, no trailing newline.</t>
<t tx="ekr.20040303063549.4">This line is over forty characters long, at least it seems to be.</t>
<t tx="ekr.20040303063549.5">This line is over forty characters long,
at least it seems to be.</t>
<t tx="ekr.20040303063549.6">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line, with trailing newline.
</t>
<t tx="ekr.20040303063549.7">This line is over forty characters long, at least it seems to be.
</t>
<t tx="ekr.20040303063549.8">This line is over forty characters long,
at least it seems to be.
</t>
<t tx="ekr.20040303063549.9">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a long line and some short ones.</t>
<t tx="ekr.20040303063549.10">This line is over forty characters long, at least it seems to be.
This is shorter, 
but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.11">This line is over forty characters long,
at least it seems to be. This is
shorter, but should be part of the same
paragraph.</t>
<t tx="ekr.20040303063549.12">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Wrap a paragraph with interior lines that have leading white space.</t>
<t tx="ekr.20040303063549.13">This line is over forty characters long, at least it seems to be.
  This indented line should be merged into the same
paragraph.</t>
<t tx="ekr.20040303063549.14">This line is over forty characters long,
  at least it seems to be. This indented
  line should be merged into the same
  paragraph.</t>
<t tx="ekr.20040303063549.15">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

No wrapping required, so don't change a thing.</t>
<t tx="ekr.20040303063549.16">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.17">This line is under 40 chars.</t>
<t tx="ekr.20040303063549.18">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first line's leading whitespace.</t>
<t tx="ekr.20040303063549.19">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
but should be part of the same
paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.20">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.21">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Honor the first and second line's leading whitespace.</t>
<t tx="ekr.20040303063549.22">   This line is over forty characters long, at least it seems to be.
   This is shorter, 
     but should be part of the same
     paragraph.  And this is indented 3 characters.</t>
<t tx="ekr.20040303063549.23">   This line is over forty characters
   long, at least it seems to be. This
   is shorter, but should be part of the
   same paragraph. And this is indented
   3 characters.</t>
<t tx="ekr.20040303063549.24">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation.</t>
<t tx="ekr.20040303063549.25">Honor this line that has a hanging indentation, please.  Hanging
  indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.26">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.27">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation with other indentation beyond line 2.</t>
<t tx="ekr.20040303063549.28">Honor this line that has
  a hanging indentation, please.  Hanging
    indentation is valuable for lists of all kinds.  But it is tricky to get right.</t>
<t tx="ekr.20040303063549.29">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.30">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Single paragraph, hanging indentation, short lines, extraneous indentation, and last line uses a tab for whitespace.</t>
<t tx="ekr.20040303063549.31">Honor this line that 
  has a hanging indentation, 
  please.  Hanging
   indentation is valuable
    for lists of all kinds.  But 
    it is tricky to get right.</t>
<t tx="ekr.20040303063549.32">Honor this line that has a hanging
  indentation, please. Hanging
  indentation is valuable for lists of
  all kinds. But it is tricky to get
  right.</t>
<t tx="ekr.20040303063549.33">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Mutliple long lined paragraphs.  Cursor should move to next paragraph after formatting a paragraph.</t>
<t tx="ekr.20040303063549.34">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.

Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.

StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.35">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.

Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.

StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.36">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

A regular paragraph, plus a numbered list of several items, plus a final regular paragraph.  Cursor should move to next paragraph after formatting a paragraph.
</t>
<t tx="ekr.20040303063549.37">This paragraph leads of this test.  It is the "lead"
paragraph.

  1. This is item 
     number 1.  It is the first item in the list.

  2. This is item 
     number 2.  It is the second item in the list.

  3. This is item 
     number 3.  It is the third item in the list.

This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.38">This paragraph leads of this test. It is
the "lead" paragraph.

  1. This is item number 1. It is the
     first item in the list.

  2. This is item number 2. It is the
     second item in the list.

  3. This is item number 3. It is the
     third item in the list.

This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.39">@language plain
@pagewidth 40
@tabwidth 8

# DTHEIN 2004.01.11: Added test case data

Test to make sure that reformatting treats directives as a new paragraph and doesn't wrap directive lines.
</t>
<t tx="ekr.20040303063549.40">Americans live in the most severe weather-prone country on Earth. Each year, Americans cope with an average of 10,000 thunderstorms, 2,500 floods, 1,000 tornadoes, as well as an average of 6 deadly hurricanes. Potentially deadly weather impacts every American. Communities can now rely on the National Weather Service’s StormReady program to help them guard against the ravages of Mother Nature.
@unknownDirective
Some 90% of all presidentially declared disasters are weather related, leading to around 500 deaths per year and nearly $14 billion in damage. StormReady, a program started in 1999 in Tulsa, OK, helps arm America's communities with the communication and safety skills needed to save lives and property– before and during the event. StormReady helps community leaders and emergency managers strengthen local safety programs.
@unknownDirective
StormReady communities are better prepared to save lives from the onslaught of severe weather through better planning, education, and awareness. No community is storm proof, but StormReady can help communities save lives. Does StormReady make a difference?</t>
<t tx="ekr.20040303063549.41">Americans live in the most severe
weather-prone country on Earth. Each
year, Americans cope with an average of
10,000 thunderstorms, 2,500 floods,
1,000 tornadoes, as well as an average
of 6 deadly hurricanes. Potentially
deadly weather impacts every American.
Communities can now rely on the National
Weather Service’s StormReady program to
help them guard against the ravages of
Mother Nature.
@unknownDirective
Some 90% of all presidentially declared
disasters are weather related, leading
to around 500 deaths per year and nearly
$14 billion in damage. StormReady, a
program started in 1999 in Tulsa, OK,
helps arm America's communities with the
communication and safety skills needed
to save lives and property– before and
during the event. StormReady helps
community leaders and emergency managers
strengthen local safety programs.
@unknownDirective
StormReady communities are better
prepared to save lives from the
onslaught of severe weather through
better planning, education, and
awareness. No community is storm proof,
but StormReady can help communities save
lives. Does StormReady make a
difference?</t>
<t tx="ekr.20040303063549.42">@language plain
@pagewidth 40
@tabwidth 8

Ran into a problem with the wrapping
eating blank lines that delimit
paragraphs if those blank lines have any
leading whitespace. This test is to make
sure that still works.

If you "show invisibles" you'll see the
leading whitespace in the blank lines --
which is different from the
"testMultiParagraphWithList" test.</t>
<t tx="ekr.20040303063549.43">This paragraph leads of this test.  It is the "lead"
paragraph.
  
  1. This is item 
     number 1.  It is the first item in the list.
  
  2. This is item 
     number 2.  It is the second item in the list.
  
  3. This is item 
     number 3.  It is the third item in the list.
  
This paragraph ends the test.  It is the "final"
paragraph.</t>
<t tx="ekr.20040303063549.44">This paragraph leads of this test. It is
the "lead" paragraph.
  
  1. This is item number 1. It is the
     first item in the list.
  
  2. This is item number 2. It is the
     second item in the list.
  
  3. This is item number 3. It is the
     third item in the list.
  
This paragraph ends the test. It is the
"final" paragraph.</t>
<t tx="ekr.20040303063549.77"></t>
<t tx="ekr.20040303063549.78"></t>
<t tx="ekr.20040303063549.79">saveFileDialog
c:\\prog\\test\\unittest\\output\\exportHeadlines.txt</t>
<t tx="ekr.20040303063549.80"></t>
<t tx="ekr.20040303063549.81">saveFileDialog
c:\\prog\\test\\unittest\\output\\flattenOutline.txt</t>
<t tx="ekr.20040303063549.82"></t>
<t tx="ekr.20040303063549.83">saveFileDialog
c:\\prog\\test\\unittest\\output\\weave.txt</t>
<t tx="ekr.20040303063549.84"></t>
<t tx="ekr.20040303063549.85">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToNoweb.txt</t>
<t tx="ekr.20040303063549.86"></t>
<t tx="ekr.20040303063549.87">saveFileDialog
c:\\prog\\test\\unittest\\output\\outlineToCweb.txt</t>
<t tx="ekr.20040303063549.88"></t>
<t tx="ekr.20040303063549.89">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.90"></t>
<t tx="ekr.20040303063549.91"></t>
<t tx="ekr.20040303063549.92">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.93"></t>
<t tx="ekr.20040303063549.94">openFileDialog
c:\\prog\\test\\unittest\\input\\leoAtFile.py</t>
<t tx="ekr.20040303063549.95"></t>
<t tx="ekr.20040303063549.96">openFileDialog
c:\\prog\\test\\unittest\\input\\noweave.nw.txt</t>
<t tx="ekr.20040303063549.97"></t>
<t tx="ekr.20040303063549.98">openFileDialog
c:\\prog\\test\\unittest\\input\\flat.txt</t>
<t tx="ekr.20040303063549.99"></t>
<t tx="ekr.20040303063549.100">openFileDialog
c:\\prog\\test\\unittest\\input\\cweave.w</t>
<t tx="ekr.20040303063549.101"></t>
<t tx="ekr.20040303063549.102"></t>
<t tx="ekr.20040303063549.107"></t>
<t tx="ekr.20040303063549.108"></t>
<t tx="ekr.20040303063549.109"></t>
<t tx="ekr.20040303063549.110"></t>
<t tx="ekr.20040303063549.111"></t>
<t tx="ekr.20040303063549.112"></t>
<t tx="ekr.20040303063549.113"></t>
<t tx="ekr.20040303063549.114"></t>
<t tx="ekr.20040303063549.115"></t>
<t tx="ekr.20040303063549.116"></t>
<t tx="ekr.20040303063549.117"></t>
<t tx="ekr.20040303080938"></t>
<t tx="ekr.20040303080938.1"></t>
<t tx="ekr.20040309095121"></t>
<t tx="ekr.20040309111054">import leoGlobals as g
import leoNodes

c = g.top()
position = leoNodes.position

@others

current = pos = c.currentPosition()
child1 = current.firstChild()
child2 = child1.firstChild()

if 0:
    print '-'*10, "parents"
    for p in child2.parents_iter(): print p
if 0:
    print '-'*10, "subtree"
    for p in pos.subtree_iter(): print p
if 0:
    print '-'*10, "children"
    for p in child1.children_iter(): print p
if 0:
    print '-'*10, "siblings"
    for p in pos.siblings_iter(): print p
if 1:
    print '-'*10, "all nodes"
    for p in pos.allNodes_iter():
        print p.isCloned(),p
</t>
<t tx="ekr.20040309111102"></t>
<t tx="ekr.20040309111102.1"></t>
<t tx="ekr.20040309111102.2"></t>
<t tx="ekr.20040309111102.3"></t>
<t tx="ekr.20040309111102.4"></t>
<t tx="ekr.20040309111102.5"></t>
<t tx="ekr.20040309111102.6"></t>
<t tx="ekr.20040309111102.7"></t>
<t tx="ekr.20040309111102.8"></t>
<t tx="ekr.20040309111102.9"></t>
<t tx="ekr.20040309111102.10"></t>
<t tx="ekr.20040309111232"></t>
<t tx="ekr.20040310145919">import leoGlobals as g
c = g.top()

c.frame.body.colorizer.python_keywords.append("as")</t>
<t tx="ekr.20040311090054">import leoGlobals as g
import leoNodes

c = g.top() ; root = c.rootPosition()

for p in root.allNodes_iter():
    print p.v.t.fileIndex</t>
<t tx="ekr.20040311125054">import leoGlobals as g
c = g.top()
root = c.rootPosition()

# NOTE: p.__getattr__ must be enabled for this test to work.

for p in root.allNodes_iter():
    assert(p.t == p.v.t)</t>
<t tx="ekr.20040312021734"></t>
<t tx="ekr.20040312021734.1">import leoGlobals as g

c = g.top()

count = 0
for p in c.rootPosition().allNodes_iter():
    count += 1
    # Empty tnodeLists are not errors because they never get written to the .leo file.
    v = p.v
    if hasattr(v,"tnodeList") and len(v.tnodeList) &gt; 0 and not v.isAnyAtFileNode():
        g.es("deleting tnodeList for " + `v`,color="blue")
        delattr(v,"tnodeList")
        c.setChanged(True)

s = "%d nodes" % count
print s ; g.es(s)</t>
<t tx="ekr.20040312101720"></t>
<t tx="ekr.20040315025315">@
- convertTreeToString and moreHead can't be vnode methods because they uses level().
- moreBody could be anywhere: it may as well be a postion method.
</t>
<t tx="ekr.20040315025315.1">def convertTreeToString (self):
    
    """Convert a positions  suboutline to a string in MORE format."""

    p = self ; level1 = p.level()
    
    array = []
    for p in p.subtree_iter()
        array.append(p.moreHead(level1)+'\n')
        body = p.moreBody()
        if body:
            array.append(body +'\n')

    return ''.join(array)</t>
<t tx="ekr.20040315025315.2">def moreHead (self, firstLevel,useVerticalBar=False):
    
    """Return the headline string in MORE format."""

    p = self

    level = self.level() - firstLevel
    plusMinus = g.choose(p.hasChildren(), "+", "-")
    
    return "%s%s %s" % ('\t'*level,plusMinus,p.headString())</t>
<t tx="ekr.20040315025315.3">@ 
    + test line
    - test line
    \ test line
    test line +
    test line -
    test line \
    More lines...
@c

def moreBody (self):

    """Returns the body string in MORE format.  
    
    Inserts a backslash before any leading plus, minus or backslash."""

    p = self ; list = []
    
    # Only escape the first non-blank character of the line.
    s =  p.bodyString() ; result = []
    lines = string.split(s,'\n')
    for s in lines:
        i = g.skip_ws(s,0)
        if i &lt; len(s):
            ch = s[i]
            if ch == '+' or ch == '-' or ch == '\\':
                s = s[:i] + '\\' + s[i:]
        result.append(s)
    return string.join(result,'\n')
</t>
<t tx="ekr.20040315030123">import leoGlobals as g

c = g.top() ; p = c.currentPosition()

p = p.firstChild()
assert(p.headString()=="File Conversion")
p.convertTreeToString()</t>
<t tx="ekr.20040315210314"></t>
<t tx="ekr.20040315210314.1"></t>
<t tx="ekr.20040315210314.2">@nocolor

- Used iterators in test utils.
- Used "import leoGlobals as g" style.</t>
<t tx="ekr.20040317101155" lineYOffset="4b032e" icons="5d7100287d7101285504747970657102550466696c65710355047870616471044b02550577686572657105550a6265666f726549636f6e71066803582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c6c745f6172726f775f656e61626c65642e67696671075507796f666673657471084afdffffff757d7109286802680368084afdffffff6803582d000000633a5c70726f675c6c656f4356535c6c656f5c49636f6e735c72745f6172726f775f656e61626c65642e676966710a68044afeffffff6805550e6265666f7265486561646c696e65710b5507786f6666736574710c4b0275652e">import leoGlobals as g

c = g.top()

p = c.currentPosition()
p.v.t.unknownAttributes = {}
a = p.v.t.unknownAttributes

&lt;&lt; define event callbacks &gt;&gt;

path = r"c:\prog\leoCVS\leo\Icons"
icon1 = g.os_path_join(path,"lt_arrow_enabled.gif")
icon2 = g.os_path_join(path,"rt_arrow_enabled.gif")

d1 = {
    "type" : "file", "file" : icon1,
    "where" : "beforeIcon",
    "yoffset" : -3,
    # "yoffset" : 5, "ypad" : -5,
    # "height" : 40, # automatically adjust headline y position.
    "xpad": 2
}

# Classes and functions can only be pickled if they are at the top level of a module.
    #"onClick" : onClick,
    #"onRightClick" : onRightClick,
    #"onDoubleClick" : onDoubleClick }

d2 = {
    "type" : "file", "file" : icon2,
    "where" : "beforeHeadline",
    "yoffset" : -3,
    "xoffset" : 2, "xpad" : -2 }

a["icons"] = [d1,d2] # [d1,d2]
a["lineYOffset"] = 3

c.redraw()
</t>
<t tx="ekr.20040317173327">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    
    if hasattr(p.v.t,"unknownAttributes"):
        a = p.v.t.unknownAttributes
        iconsList = a.get("icons")
        if dict:
            a["icons"] = []
            a["lineYOffset"] = 0
            
c.redraw()</t>
<t tx="ekr.20040317185041">def onClick(p=p):
    
    g.trace(p)

def onRightClick(p=p):
    
    g.trace(p)

def onDoubleClick(p=p):
    
    g.trace(p)</t>
<t tx="ekr.20040318091620">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if hasattr(p.v.t,"unknownAttributes"):
        print "deleting unknownAttributes:",p
        delattr(p.v.t,"unknownAttributes")
            
c.redraw()</t>
<t tx="ekr.20040318102920"># The actual test is in a child node.</t>
<t tx="ekr.20040318102920.1"></t>
<t tx="ekr.20040318102920.2">import leoGlobals as g
c = g.top()

try:
    for p in c.allNodes_iter():
        if 0: # Check all ancestors.  This is tricky and doesn't work yet.
            parents1 = [parent.v for parent in p.parents_iter()]
            parents2 = []
            parent2 = p.v.directParents()
            while parent2:
                v = parent2[0]
                parents2.append(v)
                parent2 = v.directParents()
        else:
            if p.v._parent: parents1 = p.v._parent.t.vnodeList
            else:           parents1 = []
            parents2 = p.v.directParents()
        
        assert len(parents1) == len(parents2), "length mismatch: %s, %s" % (p,p.v._parent)
        for parent in parents1:
            assert parent in parents2, "%s not in %s" % (parent,parent1)
        for parent in parents2:
            assert parent in parents1, "%s not in %s" % (parent,parent2)

except AssertionError:
    print "parents1"
    for parent in parents1: print parent
    print "parents2"
    for parent in parents2: print parent
    raise</t>
<t tx="ekr.20040319111213">from leoPlugins import *
from leoGlobals import *
from leoNodes import *
import Tkinter
import re
import sys

@others

fhp = None
fhp_entry = None
    
if 1:
    addMenu("none",None)
else:
    hooks = choose(sys.platform == 'win32',
        ('open2',"new"),
        ('start2','open2',"new"))
        
    print "hi"
        
    registerHandler(hooks,addMenu)

    __version__ = ".1"
    plugin_signon(__name__)
</t>
<t tx="ekr.20040319111213.1">@nocolor

@ This is what it does:

1. Under Outline it puts an Option called 'FilterHoist'
2. Selecting the option pops up an ugly little window.  On it is a section where
you can type in text.  You can close the window with the close button.  You
can activate the functionality with the Filter Button.
3. Filtering will walk the Leo tree, looking for a text match from the Text
field with the Nodes bodyString.
4. After finding some nodes it creates a new node at the root.  Then it clones
the matching nodes under that new node.  A Hoist operation is performed on the
new node.  This gives a view of all matching nodes.

I put this together because I wanted a find that was based in terms of Leo's
nodes.  Find as it is bounces you around the Tree(it bothers me).  This brings
the nodes to you and presents them.  As it is I may work further on this if
people like the idea.  It's possible I might migrate it to the NodeRoundup plugin
to.

You need 2.3 python; it uses generators in it's find method.

That was one motivation for writing this thing, using a generator vs. Recursive
approach to tree walking.</t>
<t tx="ekr.20040319111213.2">def OLDfilter(c,e):

    v = c.rootVnode()
    
    nodes = []
    while v:
        nodes.append(v)
        v = v.next()
    
    regex = re.compile(e.get())
    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        ticker = c.rootVnode().insertAfter(t)
        for z in nodes:
            for x in search(z,regex):
                clone = x.clone( x )
                clone.moveToNthChildOf(ticker,0)
        c.setCurrentVnode(ticker)
        ticker.moveToRoot(c.rootVnode())
    c.endUpdate()
    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040319111213.3">def OLDsearch(vn,regex):

    sn = vn 
    while vn != None:
        if regex.search( vn.t.bodyString ) : yield vn
        nc = vn.numberOfChildren()
        if nc == 0:
            i = vn.childIndex()
            p = vn.parent()
            if p == None: 
                vn = None
                continue
            if i == 0:
                while 1:
                    if p == sn :
                        vn = None
                        break
                    vn = p.back() 
                    if vn == None:
                        p = p.parent()
                        continue
                    break
                continue                                                        
            vn = p.nthChild( i - 1)
            continue
        vn = vn.nthChild( nc - 1 )
</t>
<t tx="ekr.20040319111213.4">def filterHoist(c):

    global fhp
    global e
    
    if fhp is None:

        fhp = Tkinter.Toplevel()
        fhp.title('FilterHoist')

        fhp_entry = e = Tkinter.Entry(fhp)
        e.pack(side="top",fill="both")

        def closeCallback(fhp=fhp):
            fhp.withdraw()
            
        def filterCallback(c=c,entry=e):
            filter(c,entry)

        b1 = Tkinter.Button(fhp,text='Close',command=closeCallback)
        b2 = Tkinter.Button(fhp,text='Filter',command=filterCallback)
        b1.pack(side="left")
        b2.pack(side="right")

    fhp.geometry('200x200+250+250') 
    fhp.deiconify()
    fhp_entry.focus_set()
</t>
<t tx="ekr.20040319111213.5">def addMenu(tag,keywords):
    
    c = top()
    
    trace()
    
    def callback(c=c):
        filterHoist(c)
    
    table = ("FilterHoist",None,callback),

    c.frame.menu.createMenuItemsFromTable("Outline",table)</t>
<t tx="ekr.20040319142202"></t>
<t tx="ekr.20040319142708">def filter(c,e):
    
    pat = re.compile(e.get())

    c.beginUpdate()
    if 1: # update...
        t = tnode('','A Filtered Hoist')
        newRoot = c.rootVnode().insertAfter(t)
        p = c.rootVnode()
        while p:
            if pat.search(p.bodyString()):
                clone = p.clone(p)
                clone.moveToLastChildOf(newRoot)
            p = p.threadNext()
        newRoot.moveToRoot(c.rootVnode())
        c.setCurrentVnode(newRoot)
    c.endUpdate()

    c.hoist()
    fhp.withdraw()
</t>
<t tx="ekr.20040322120331">import leoGlobals as g
c = g.top()

print '-'*20
for p in c.allNodes_iter():
    if hasattr(p.v.t,"tnodeList"):
        print p,p.v.t.tnodeList</t>
<t tx="ekr.20040323075614">import leoGlobals as g

class test_iter_class:
    def __init__ (self):
        self.vals = ("a","b","c")
        self.n = 0
    def __iter__(self):
        return self
    def next(self):
        if self.n &lt; len(self.vals):
            val = self.vals[self.n]
            self.n += 1
            return val
        else:
            raise StopIteration
            
def test_iter(): return test_iter_class()
        
vals = [val for val in test_iter()]

print vals
</t>
<t tx="ekr.20040323080317">import leoGlobals as g
c = g.top()

print '-'*20

# These are equivalent.
positions1 = [p for p in c.allNodes_iter(copy=True)]
positions2 = [p.copy() for p in c.allNodes_iter()]

assert(len(positions1) == len(positions2))
for i in xrange(len(positions1)):
    assert(positions1[i] == positions2[i])

if 0:
    for p in positions1:
        print p
print "done"</t>
<t tx="ekr.20040323082119">import leoGlobals as g
c = g.top()

print '-'*20

positions = [p.copy() for p in c.allNodes_iter()]

tnodes = {} ; vnodes = []
for p in c.allNodes_iter():
    t = p.v.t
    if tnodes.get(t) is None:
        tnodes[t]=t
        vnodes.append(p.v)
        
print len(positions),len(vnodes)

for v in vnodes:
    print v</t>
<t tx="ekr.20040323085406">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isAnyAtFileNode():
        print p
        
print "done"</t>
<t tx="ekr.20040323085933">import leoGlobals as g

c = g.top()

print '-'*20

for p in c.allNodes_iter():
    if p.isDirty():
        vnodes = p.findAllPotentiallyDirtyNodes()
        print '-'*5, p
        for v in vnodes:
            print v

print "done"</t>
<t tx="ekr.20040323090541">import leoGlobals as g
c = g.top()
try:
    for p in c.allNodes_iter():
        if p.isCloned():
            parents = p.v.t.vnodeList
            for child in p.children_iter():
                vparents = child.v.directParents()
                assert len(parents) == len(vparents), "length mismatch: %s,%s" % (p,child)
                for parent in parents:
                    assert parent in vparents, "not in vparents: %s,%s" % (p,child)
                for parent in vparents:
                    assert parent in parents, "not in parents: %s,%s" % (p,child)
except AssertionError:
    print "parents..."
    for parent in parents: print parent
    print "vparents..."
    for parent in vparents: print parent
    raise # for unittest.</t>
<t tx="ekr.20040323162303">import leoGlobals as g

c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040325082811">import leoGlobals as g

g.es("v",g.top().currentPosition())
g.es(1,2)</t>
<t tx="ekr.20040325130503">stack1 = ["a","b","c"]
stack2 = ["a","b","c"]
stack3 = ["a","b","d"]
stack4 = ["a","b"]
print stack1 == stack2
print stack1 == stack3
print stack1 == stack4</t>
<t tx="ekr.20040325140133">import leoGlobals as g
c = g.top() ; p = c.currentPosition()

print p.v.headString()
print p.childIndex()
print p.v.headString()</t>
<t tx="ekr.20040325155043">import timeit

s1 = '''\
class test(object):
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s2 = '''\
class test:
    def __cmp__(self,p2):   return 0
    def equal(self,p2):     return 0
p1 = test() ; p2 = test()'''

s3 = '''\
import leoNodes
p1 = leoNodes.position(None,[])
p2 = leoNodes.position(None,[])'''

for s in (s1,s2,s3):
    t1 = timeit.Timer(stmt='p1==p2',setup=s).timeit()
    t2 = timeit.Timer(stmt='p1.equal(p2)',setup=s).timeit()
    print "%2.2f,%2.2f,%0.2f" % (t1,t2,t1/t2)
</t>
<t tx="ekr.20040327105955">import os

path = r"c:\prog\test\unittest\createdFile.txt"

s = r"c:\python23\python c:\prog\LeoCVS\leo\src\leo.py -script c:\prog\test\unittest\batchTest.py"

if os.path.exists(path):
    print ; print "@test batch mode: deleting",path
    os.remove(path)

os.system(s)
assert(os.path.exists(path))
</t>
<t tx="ekr.20040327114250">@ignore

# A file to be executed in batch mode as part of unit testing.

@language python
@tabwidth -4

path = r"c:\prog\test\unittest\createdFile.txt"
f = None
try:
    f = open(path,"w")
    f.write("This is a test")
finally:
    if f: f.close()</t>
<t tx="ekr.20040330095252">import leoGlobals as g
c = g.top()
t = c.frame.log.logCtrl
print t
t.delete("1.0","end")</t>
<t tx="ekr.20040330103006">@ignore
@language c

oblk[1] = b64[((iblk[0] &amp; 0x03) &lt;&lt; 4) |
((iblk[1] &amp; 0xF0) &gt;&gt; 4)];
oblk[2] = b64[((iblk[1] &amp; 0x0F) &lt;&lt; 2) |
((iblk[2] &amp; 0xC0) &gt;&gt; 6)];
</t>
<t tx="ekr.20040402043516">@ a doc
part.
@c

"""A script to reformat non-leading whitespace."""

import leoGlobals as g

import tokenize,token

@others

c = g.top()

print '-'*50

if 1:
    # Just print the present position.
    prettyPrintNode(c.currentPosition())
else:
    # Print all top-level nodes.
    for p in c.rootPosition().self_and_siblings_iter():
        prettyPrintNode(p)
        
print
print '-'*50</t>
<t tx="ekr.20040402064301">class prettyPrinter:
    
    @others</t>
<t tx="ekr.20040402064301.1">def __init__ (self,p):
    
    self.line = 0
    self.lines = []
    self.col = 0
    self.array = []
    self.parenLevel = 0
    self.bracketLevel = 0
    self.p = p</t>
<t tx="ekr.20040402072335">def put (self,s,strip=True):
    
    if self.array and strip:
        prev = self.array[-1]
        if len(self.array) == 1:
            if prev.rstrip():
                # We aren't stripping all leading whitespace.
                self.array[-1] = prev.rstrip()
        else:
            # The previous entry isn't leading whitespace.
            self.array[-1] = prev.rstrip()

    self.array.append(s)</t>
<t tx="ekr.20040402074431">def putNormalToken (self,token5tuple):

    a = self.array
    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4 ; line = str(t5)
    name = token.tok_name[t1].lower()
    val = str(t2)
    startLine = self.line != srow
    self.line = srow

    if startLine:
        ws = line[0:scol]
        if ws: a.append(ws)

    if name in ("nl","newline","endmarker"):
        if name in ("nl","newline"):
            a.append('\n')
        # else: a.append("&lt;END NODE&gt;")
        self.lines.append(''.join(self.array))
        self.array = []
    elif name == "op":
        self.putOperator(val)
    elif name == "name":
        a.append("%s " % val)
    elif name in ("comment","string","number"):
        a.append(val)
    elif name == "errortoken":
        if val == '@' and startLine:
            # Preserve whitespace after leading @.
            i = g.skip_ws(line,1)
            a.append(line[0:i])
        else:
            a.append(val)
    elif name == "indent":
        a.append(val)
    elif name == "dedent":
        pass
    else:
        print "unknown: %s" % (name)</t>
<t tx="ekr.20040402074431.1">def dumpToken (self,token5tuple):

    t1,t2,t3,t4,t5 = token5tuple
    srow,scol = t3 ; erow,ecol = t4 ; line = str(t5)
    name = token.tok_name[t1].lower()
    val = str(t2)

    startLine = self.line != srow
    if startLine:
        print "----- line",srow,repr(line)
    self.line = srow

    print "%10s (%2d,%2d) %-8s" % (name,scol,ecol,repr(val))</t>
<t tx="ekr.20040402080311">def putToken (self,token5tuple):
    
    if 1:
        self.putNormalToken(token5tuple)
    else:
        self.dumpToken(token5tuple)</t>
<t tx="ekr.20040402081135">def putOperator (self,val):
    
    if val == '(':
        self.parenLevel += 1
        self.put(val)
    elif val == ')':
        self.parenLevel -= 1
        self.put(val)
    elif val == '=':
        if self.parenLevel &gt; 0: self.put('=')
        else:                   self.put(' = ')
    elif val == ',':
        if self.parenLevel &gt; 0: self.put(',')
        else:                   self.put(', ')
    elif val == ';':
        self.put(" ; ")
    else:
        self.put(val)</t>
<t tx="ekr.20040402084155">def prettyPrintNode(p):

    s = p.bodyString()
    if not s: return
    
    print '-'*10, p.headString()

    pp = prettyPrinter(p)
    
    readlines = g.readLinesGenerator(s).next

    for token5tuple in tokenize.generate_tokens(readlines):
        pp.putToken(token5tuple)
        
    lines = pp.get()
    
    # Note: we could replace p's body text here.

    if 1:
        print ''.join(lines), # Don't add a trailing newline!
    else:
        for i in xrange(len(lines)):
            print "%3d" % i, repr(lines[i])</t>
<t tx="ekr.20040402093822">def get (self):
    
    return self.lines</t>
<t tx="ekr.20040409140301"></t>
<t tx="ekr.20040409140301.1"></t>
<t tx="ekr.20040409140301.2"></t>
<t tx="ekr.20040409140301.3"></t>
<t tx="ekr.20040409140343"></t>
<t tx="ekr.20040409140343.1"></t>
<t tx="ekr.20040409142028"></t>
<t tx="ekr.20040409142028.1"></t>
<t tx="ekr.20040409142108"></t>
<t tx="ekr.20040409142108.1"></t>
<t tx="ekr.20040414082806"></t>
<t tx="ekr.20040419105536">@ignore
@language perl

@others</t>
<t tx="ekr.20040419105536.1">line 1</t>
<t tx="ekr.20040419105536.2">line 2</t>
<t tx="ekr.20040701065412">@others</t>
<t tx="ekr.20040701065412.1">marked node</t>
<t tx="ekr.20040701065412.2"></t>
<t tx="ekr.20040701065412.3"></t>
<t tx="ekr.20040701065412.4"></t>
<t tx="ekr.20040701065412.5"></t>
<t tx="ekr.20040701065424"></t>
<t tx="ekr.20040701065424.1"></t>
<t tx="ekr.20040701081330">@ignore</t>
<t tx="ekr.20040704104554">@ignore</t>
<t tx="ekr.20040704104554.1">@language html
@language python
</t>
<t tx="ekr.20040704104554.2">@language python
@language html</t>
<t tx="ekr.20040705191805">@ignore

import leoGlobals as g
import leoNodes

c = g.top()
p = c.currentPosition()

print '-' * 20
format = "%18s"
for child in p.children_iter():
    print ; print child.headString()
    print format % "isAnyAtFileNode",   child.isAnyAtFileNode()
    print format % "anyAtFileNodeName", child.anyAtFileNodeName()
    print format % "isAtFileNode",      child.isAtFileNode()
    print format % "isAtNoSentFileNode",child.isAtNoSentFileNode()
    print format % "isAtNorefFileNode", child.isAtNorefFileNode()
    print format % "isAtAsisFileNode",  child.isAtAsisFileNode()
    print format % "isAtThinFileNode",  child.isAtThinFileNode()</t>
<t tx="ekr.20040705191805.1"></t>
<t tx="ekr.20040705191805.2"></t>
<t tx="ekr.20040705192522"></t>
<t tx="ekr.20040705192522.1"></t>
<t tx="ekr.20040705192522.2"></t>
<t tx="ekr.20040705192522.3"></t>
<t tx="ekr.20040705192522.4"></t>
<t tx="ekr.20040705192522.5"></t>
<t tx="ekr.20040705192522.6"></t>
<t tx="ekr.20040705192610"></t>
<t tx="ekr.20040705192610.1"></t>
<t tx="ekr.20040705212227"></t>
<t tx="ekr.20040706071823"># This works, and doesn't seem convenient for Leo's importers.

import leoGlobals as g

try:
    import parser
    import pprint
    path = r"c:\prog\test\importIndentTest.py"
    f = open(path)
    s = f.read()
    f.close()
    ast = parser.suite(s)
    tup = ast.totuple()
    print `ast`
    pprint.pprint(tup)
except:
    import traceback
    traceback.print_exc()</t>
<t tx="ekr.20040707071542.1">import leoTest
reload(leoTest)

leoTest.doTests(all=True)</t>
<t tx="ekr.20040707081532.1">import leoTest
reload(leoTest)

leoTest.doTests(all=False)</t>
<t tx="ekr.20040707083523"># Run all child tests...

import leoGlobals as g

c = g.top() ; p1 = c.currentPosition()
changed = c.isChanged()

for child in c.currentPosition().children_iter():
    
    grandChild = child.firstChild()
    if grandChild:
        c.selectVnode(grandChild) # Sets body text.
        val = c.frame.body.colorizer.colorize(grandChild,incremental=False)
        print "colorizing", grandChild.headString()
        assert val=="ok", "colorizer test failed: %s" % grandChild.headString()
        
c.setChanged(changed) # Restore changed state.
c.selectVnode(p1) # N.B. Restore the selected node.</t>
<t tx="ekr.20040707083523.1">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="ekr.20040707083523.2">@language c
@comment /* */

@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="ekr.20040707083523.3">@language csharp
@ comment
@c

/* block
comment */

// test

id // not a keyword

abstract as 
base bool break byte 
case catch char checked class const continue 
decimal default delegate do double 
else enum event explicit extern 
false finally fixed float for foreach 
get goto 
if implicit in int interface internal is 
lock long 
namespace new null 
object operator out override 
params partial private protected public 
readonly ref return 
sbyte sealed set short sizeof stackalloc 
static string struct switch 
this throw true try typeof 
uint ulong unchecked unsafe ushort using 
value virtual void volatile 
where while
yield</t>
<t tx="ekr.20040707083523.4">@language css
/* New in 4.2. */

/*html tags*/
address, applet, area, a, base, basefont,
big, blockquote, body, br, b, caption, center,
cite, code, dd, dfn, dir, div, dl, dt, em, font,
form, h1, h2, h3, h4, h5, h6, head, hr, html, img,
input, isindex, i, kbd, link, li, link, map, menu,
meta, ol, option, param, pre, p, samp,
select, small, span, strike, strong, style, sub, sup,
table, td, textarea, th, title, tr, tt, ul, u, var,
/*units*/
mm, cm, in, pt, pc, em, ex, px,
/*colors*/
aqua, black, blue, fuchsia, gray, green, lime, maroon, navy, olive, purple, red, silver, teal, yellow, white,
/*important directive*/
!important,
/*font rules*/
font, font-family, font-style, font-variant, font-weight, font-size,
/*font values*/
cursive, fantasy, monospace, normal, italic, oblique, small-caps,
bold, bolder, lighter, medium, larger, smaller,
serif, sans-serif,
/*background rules*/
background, background-color, background-image, background-repeat, background-attachment, background-position,
/*background values*/
contained, none, top, center, bottom, left, right, scroll, fixed,
repeat, repeat-x, repeat-y, no-repeat,
/*text rules*/
word-spacing, letter-spacing, text-decoration, vertical-align, text-transform, text-align, text-indent, text-transform, text-shadow, unicode-bidi, line-height,
/*text values*/
normal, none, underline, overline, blink, sub, super, middle, top, text-top, text-bottom,
capitalize, uppercase, lowercase, none, left, right, center, justify,
line-through,
/*box rules*/
margin, margin-top, margin-bottom, margin-left, margin-right,
margin, padding-top, padding-bottom, padding-left, padding-right,
border, border-width, border-style, border-top, border-top-width, border-top-style, border-bottom, border-bottom-width, border-bottom-style, border-left, border-left-width, border-left-style, border-right, border-right-width, border-right-style, border-color,
/*box values*/
width, height, float, clear,
auto, thin, medium, thick, left, right, none, both,
none, dotted, dashed, solid, double, groove, ridge, inset, outset,
/*display rules*/
display, white-space, 
min-width, max-width, min-height, max-height,
outline-color, outline-style, outline-width,
/*display values*/
run-in, inline-block, list-item, block, inline, none, normal, pre, nowrap, table-cell, table-row, table-row-group, table-header-group, inline-table, table-column, table-column-group, table-cell, table-caption
/*list rules*/
list-style, list-style-type, list-style-image, list-style-position,
/*list values*/
disc, circle, square, decimal, decimal-leading-zero, none,
lower-roman, upper-roman, lower-alpha, upper-alpha, lower-latin, upper-latin,
/*table rules*/
border-collapse, caption-side,
/*table-values*/
empty-cells, table-layout,
/*misc values/rules*/
counter-increment, counter-reset,
marker-offset, z-index,
cursor, direction, marks, quotes,
clip, content, orphans, overflow, visibility,
/*aural rules*/
pitch, range, pitch-during, cue-after, pause-after, cue-before, pause-before, speak-header, speak-numeral, speak-punctuation, speed-rate, play-during, voice-family,
/*aural values*/
stress, azimuth, elevation, pitch, richness, volume,
page-break, page-after, page-inside</t>
<t tx="ekr.20040707083523.5">@language cweb

% This is limbo in cweb mode... It should be in \LaTeX mode, not \c mode.
% The following should not be colorized: class,if,else.

@* this is a _cweb_ comment.  Code is written in \c.
"strings" should not be colorized.
It should be colored in \LaTeX mode.
The following are not keywords in latex mode: if, else, etc.
Noweb section referencs are _valid_ in cweb comments!
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;
@c

and this is C code. // It is colored in \LaTeX mode by default.
/* This is a C block comment.  It may also be colored in restricted \LaTeX mode. */

// Section refs are valid in code too, of course.
&lt;&lt; section ref &gt;&gt;
&lt;&lt; missing ref &gt;&gt;

\LaTeX and \c should not be colored.
if else, while, do // C keywords.</t>
<t tx="ekr.20040707083523.6">&lt;&lt; section def &gt;&gt;=

    my \c code goes here // This is \LaTeX text
    /* This is also \LaTeX text */</t>
<t tx="ekr.20040707083523.7">@language elisp

; Maybe...
error princ 

; More typical of other lisps...
and apply
car cdr cons cond
defconst defun defvar 
eq equal eval
gt ge
if 
let le lt
mapcar 
ne nil 
or not 
prog progn 
set setq 
t type-of 
unless 
when while</t>
<t tx="ekr.20040707083523.8">@language html

&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;</t>
<t tx="ekr.20040707083523.9">@language html

&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;"""</t>
<t tx="ekr.20040707083523.10">@language latex

% This is a \LaTeX mode comment.

This is a test of \LaTeX mode.

@ blah blah blah
@c

\c and \LaTeX are latex keywords.

This is a keyword \% not the start of a comment.

More keywords: \@ and \( and \) and \{ and \}</t>
<t tx="ekr.20040707083523.11">@ignore
@ doc
@c
@language c
    @others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="ekr.20040707083523.12">@language php
@ doc
This is a doc part.
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
&lt;?PHP and or array() ?&gt;</t>
<t tx="ekr.20040707083523.13">@language python

"""python
string"""d

'this\
is'''</t>
<t tx="ekr.20040707083523.14">"""This creates a free-floating copy of v's tree for undo.
The copied trees must use different tnodes than the original."""
    
def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
    # Copy the headline and icon values v.copyNode(root,v)
    # Copy the rest of tree.
    v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="ekr.20040707083523.15">' New in 4.2.
@language rapidq
' a comment.

$APPTYPE,$DEFINE,$ELSE,$ENDIF,$ESCAPECHARS,$IFDEF,$IFNDEF,
$INCLUDE,$MACRO,$OPTIMIZE,$OPTION,$RESOURCE,$TYPECHECK,$UNDEF,
ABS,ACOS,ALIAS,AND,AS,ASC,ASIN,ATAN,ATN,BIN$,BIND,BYTE,
CALL,CALLBACK,CALLFUNC,CASE,CEIL,CHDIR,CHDRIVE,CHR$,CINT,
CLNG,CLS,CODEPTR,COMMAND$,COMMANDCOUNT,CONSOLE,CONST,CONSTRUCTOR,
CONVBASE$,COS,CREATE,CSRLIN,CURDIR$,DATA,DATE$,DEC,DECLARE,
DEFBYTE,DEFDBL,DEFDWORD,DEFINT,DEFLNG,DEFSHORT,DEFSNG,DEFSTR,
DEFWORD,DELETE$,DIM,DIR$,DIREXISTS,DO,DOEVENTS,DOUBLE,DWORD,
ELSE,ELSEIF,END,ENVIRON,ENVIRON$,EVENT,EXIT,EXP,EXTENDS,
EXTRACTRESOURCE,FIELD$,FILEEXISTS,FIX,FLOOR,FOR,FORMAT$,FRAC,
FUNCTION,FUNCTIONI,GET$,GOSUB,GOTO,HEX$,IF,INC,INITARRAY,
INKEY$,INP,INPUT,INPUT$,INPUTHANDLE,INSERT$,INSTR,INT,INTEGER,
INV,IS,ISCONSOLE,KILL,KILLMESSAGE,LBOUND,LCASE$,LEFT$,LEN,
LFLUSH,LIB,LIBRARYINST,LOCATE,LOG,LONG,LOOP,LPRINT,LTRIM$,
MEMCMP,MESSAGEBOX,MESSAGEDLG,MID$,MKDIR,MOD,MOUSEX,MOUSEY,
NEXT,NOT,OFF,ON,OR,OUT,OUTPUTHANDLE,PARAMSTR$,PARAMSTRCOUNT,
PARAMVAL,PARAMVALCOUNT,PCOPY,PEEK,PLAYWAV,POKE,POS,POSTMESSAGE,
PRINT,PROPERTY,QUICKSORT,RANDOMIZE,REDIM,RENAME,REPLACE$,
REPLACESUBSTR$,RESOURCE,RESOURCECOUNT,RESTORE,RESULT,RETURN,
REVERSE$,RGB,RIGHT$,RINSTR,RMDIR,RND,ROUND,RTRIM$,RUN,
SCREEN,SELECT,SENDER,SENDMESSAGE,SETCONSOLETITLE,SGN,SHELL,
SHL,SHORT,SHOWMESSAGE,SHR,SIN,SINGLE,SIZEOF,SLEEP,SOUND,
SPACE$,SQR,STACK,STATIC,STEP,STR$,STRF$,STRING,STRING$,
SUB,SUBI,SWAP,TALLY,TAN,THEN,TIME$,TIMER,TO,TYPE,UBOUND,
UCASE$,UNLOADLIBRARY,UNTIL,VAL,VARIANT,VARPTR,VARPTR$,VARTYPE,
WEND,WHILE,WITH,WORD,XOR</t>
<t tx="ekr.20040707083523.16">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="ekr.20040707083523.17"># New in 4.2.

@language shell

# comment
$# not a comment
break
case,continue,
do,done
elif,else,esac
fi,for
if,in
return,
then
until
while,

cd,chdir,eval,exec,
exit,kill,newgrp,pwd,read,readonly,
shift,test,trap,ulimit,
umask,wait</t>
<t tx="ekr.20040707083523.18"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki
@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

import leoGlobals as g ; print g.app().loadDir</t>
<t tx="ekr.20040707083523.19"># both color_markup &amp; add_directives plugins must be enabled.
@markup wiki

""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

import leoGlobals as g ; print g.app().loadDir
</t>
<t tx="ekr.20040707083523.20"># both color_markup &amp; add_directives plugins must be enabled.

@markup wiki

""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="ekr.20040707090019">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090300">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090300.1">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.1">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.2">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.3">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.4">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.5">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.6">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.7">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.8">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.9">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.10">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.11">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.12">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.13">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.14">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707090647.15">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040707091428"></t>
<t tx="ekr.20040707091428.1"></t>
<t tx="ekr.20040707091428.5">import leoGlobals as g
c = g.top()
p = c.currentPosition()
    
assert(p == p.copy())
assert(p != p.threadNext())</t>
<t tx="ekr.20040707091428.6">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned() and p.hasChildren():
        childv = p.firstChild().v
        assert(childv == p.v.t._firstChild)
        assert(id(childv) == id(p.v.t._firstChild))
        for v in p.v.t.vnodeList:
            assert(v.t._firstChild == childv)
            assert(id(v.t._firstChild) == id(childv))</t>
<t tx="ekr.20040707091428.8">import leoGlobals as g
c = g.top()

for copy in (True,False):
    p2 = c.rootPosition()
    for p in c.allNodes_iter(copy=copy):
        assert p==p2, "%s != %s" % (p,p2)
        p2.moveToThreadNext()
        
    assert not p2, repr(p2)
</t>
<t tx="ekr.20040707091428.9">import leoGlobals as g
c = g.top()

for copy in (True,False):
    for p in c.allNodes_iter(copy=copy):
        
        p2 = p.firstChild()
        for p3 in p.children_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToNext()

    assert not p2, repr(p2)</t>
<t tx="ekr.20040707091428.10">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        assert(p.parent().level() == p.level() - 1)

    if p.hasChildren():
        assert(p.firstChild().level() == p.level() + 1)
        
    if p.hasNext():
        assert(p.next().level() == p.level())

    if p.hasBack():
        assert(p.back().level() == p.level())</t>
<t tx="ekr.20040707091428.11">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    back = p.back()
    next = p.next()
    if back: assert(back.getNext() == p)
    if next: assert(next.getBack() == p)</t>
<t tx="ekr.20040707091428.12">import leoGlobals as g
c = g.top()

for copy in (True,False):

    for p in c.allNodes_iter():
        p2 = p.parent()
        for p3 in p.parents_iter(copy=copy):
            assert p3==p2, "%s != %s" % (p3,p2)
            p2.moveToParent()

        assert not p2, repr(p2)</t>
<t tx="ekr.20040707091428.13"># Test consistency of p.parent, p.next, p.back and p.firstChild.

import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    
    if p.hasParent():
        n = p.childIndex()
        assert(p == p.parent().moveToNthChild(n))
        
    for child in p.children_iter():
        assert(p == child.parent())

    if p.hasNext():
        assert(p.next().parent() == p.parent())
        
    if p.hasBack():
        assert(p.back().parent() == p.parent())</t>
<t tx="ekr.20040707091428.14">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.threadBack()
    threadNext = p.threadNext()

    if threadBack:
        assert(p == threadBack.getThreadNext())

    if threadNext:
        assert(p == threadNext.getThreadBack())</t>
<t tx="ekr.20040707091428.15">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():
    if p.isCloned():
        parents = p.v.t.vnodeList
        for child in p.children_iter():
            vparents = child.v.directParents()
            assert(len(parents) == len(vparents))
            for parent in parents:
                assert(parent in vparents)
            for parent in vparents:
                assert(parent in parents)</t>
<t tx="ekr.20040707091428.16">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    back = p.back()
    next = p.next()

    assert(
        (back and p.hasBack()) or
        (not back and not p.hasBack()))
            
    assert(
        (next and p.hasNext()) or
        (not next and not p.hasNext()))</t>
<t tx="ekr.20040707091428.17">import leoGlobals as g
c = g.top()
    
for p in c.allNodes_iter():

    child = p.firstChild()
    parent = p.parent()

    assert(
        (child and p.hasFirstChild()) or
        (not child and not p.hasFirstChild()))
            
    assert(
        (parent and p.hasParent()) or
        (not parent and not p.hasParent()))</t>
<t tx="ekr.20040707091428.18">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    threadBack = p.getThreadBack()
    threadNext = p.getThreadNext()

    assert(
        (threadBack and p.hasThreadBack()) or
        (not threadBack and not p.hasThreadBack()))
            
    assert(
        (threadNext and p.hasThreadNext()) or
        (not threadNext and not p.hasThreadNext()))</t>
<t tx="ekr.20040707091428.19">import leoGlobals as g
c = g.top()

for p in c.allNodes_iter():

    vnodeList = p.v.t.vnodeList

    for v in vnodeList:

        assert(v.t == p.v.t)
        if p.v.isCloned():
            assert(v.isCloned())
            assert(len(vnodeList) &gt; 1)
        else:
            assert(not v.isCloned())
            assert(len(vnodeList) == 1)</t>
<t tx="ekr.20040707093334"></t>
<t tx="ekr.20040707104245"></t>
<t tx="ekr.20040707110818"></t>
<t tx="ekr.20040707140849.1"></t>
<t tx="ekr.20040707140849.10"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeEditBodySuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040707140849.19"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = unittest.makeSuite(findCommandTestCase,'test')

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040707140849.21">class findCommandTestCase(unittest.TestCase):
    
    """Unit tests for Leo's find commands."""
    
    @others</t>
<t tx="ekr.20040707140849.22">def setUp(self,*args,**keys):
    
    self.u = u = leoTest.testUtils()
    self.c = c = g.top()
    self.find_p = u.findNodeAnywhere(c,"findTests")
    
    assert(self.find_p)
</t>
<t tx="ekr.20040707140849.23">def testFindCommand (self):
    
    pass</t>
<t tx="ekr.20040707140849.24">def testFindWordCommand (self):
    
    pass</t>
<t tx="ekr.20040707140849.25">def testFindIgnoreCaseCommand (self):
    
    pass</t>
<t tx="ekr.20040707140849.26"></t>
<t tx="ekr.20040707140849.35"></t>
<t tx="ekr.20040707140849.39">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","test","test.leo")
leoTest.runLeoTest(path,verbose=False,full=True)
</t>
<t tx="ekr.20040707140849.40">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","src","LeoPy.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040707140849.41">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","plugins","leoPlugins.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040707140849.42">import leoGlobals as g
import leoTest
reload(leoTest)

path = g.os_path_join(g.app.loadDir,"..","doc","LeoDocs.leo")
leoTest.runLeoTest(path)
</t>
<t tx="ekr.20040707140849.43"></t>
<t tx="ekr.20040707140849.44">def makeOutlineSuite(parentHeadline):
    
    """Create an outline test for every descendant of testParentHeadline.."""
    
    c = g.top() ; v = c.currentVnode()
    u = leoTest.testUtils()

    # Create the suite and add all test cases.
    suite = unittest.makeSuite(unittest.TestCase)
    
    parent = u.findNodeAnywhere(c,parentHeadline)
    
    for child in parent.children_iter(copy=True):
        before = u.findNodeInTree(child,"before")
        after  = u.findNodeInTree(child,"after")
        ref    = u.findNodeInTree(child,"ref")
        if before and after and ref:
            test = outlineTestCase(c,child,before,after,ref)
            suite.addTest(test)

    return suite
</t>
<t tx="ekr.20040707140849.45">class outlineTestCase(unittest.TestCase):
    
    """Data-driven unit tests for Leo's outline commands."""
    
    @others</t>
<t tx="ekr.20040707140849.46">def __init__ (self,c,parent,before,after,ref):
    
    # Init the base class.
    unittest.TestCase.__init__(self)
    
    self.u = leoTest.testUtils()

    self.c = c
    self.parent = parent
    self.before = before
    self.after = after
    self.ref    = ref</t>
<t tx="ekr.20040707140849.47">def outlineCommand (self):
    
    c = self.c ; u = self.u ; tree = c.frame.tree
    
    move = u.findNodeInTree(self.before,"move")
    assert move, "no move node"
    
    c.selectVnode(move)
    commandName = self.parent.headString()
    command = getattr(c,commandName)
    command()

    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))
    c.undoer.redo()
    assert(u.compareOutlines(self.before,self.after,compareHeadlines=False))
    c.undoer.undo()
    assert(u.compareOutlines(self.before,self.ref,compareHeadlines=False))</t>
<t tx="ekr.20040707140849.48">def runTest(self):

    self.outlineCommand()</t>
<t tx="ekr.20040707140849.49">def setUp(self,*args,**keys):

    assert(self.before)
    assert(self.after)
    assert(self.ref)
    assert self.u.compareOutlines(self.before,self.ref,compareHeadlines=False),\
        "compare failed"
    
    # Batch mode bugs: meaning of move may depend on visibility.
    self.parent.parent().expand()
    self.parent.expand()
    self.before.expand()
    self.after.expand()</t>
<t tx="ekr.20040707140849.50">def tearDown (self):

    c = self.c ; u = self.u

    if not u.compareOutlines(self.before,self.ref):
        u.replaceOutline(c,self.before,self.ref)

    self.before.contract()
    self.after.contract()
    self.parent.contract()
    self.parent.parent().contract()</t>
<t tx="ekr.20040707140849.51"># To do: create separate unit tests for each plugin...

import leoGlobals as g
import glob

@others
 
path = g.os_path_join(g.app.loadDir,"..","plugins")
files = glob.glob(g.os_path_join(path,"*.py"))
files = [g.os_path_abspath(file) for file in files]
files.sort()

oldGui = g.app.gui
try:
    ok = True
    for file in files:
        g.trace(file)
        doPluginTest(path,file,verbose=True)
except:
    g.es_exception()
    ok = False

g.app.gui = oldGui
if not ok: raise</t>
<t tx="ekr.20040707140849.79"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import leoTest ; reload(leoTest)

suite = leoTest.makeReformatParagraphSuite()

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040707141957.3">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.4">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.5">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@nonl
#@-node:@@file
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040707141957.6">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.7">Line 1

@last last line 1: newline
</t>
<t tx="ekr.20040707141957.8">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: newline
</t>
<t tx="ekr.20040707141957.9">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.10">Line 1

@last last line 1: two trailing newlines
</t>
<t tx="ekr.20040707141957.11">#@+leo-ver=4
#@+node:@@file
Line 1

#@@last
#@-node:@@file
#@-leo
last line 1: two trailing newlines
</t>
<t tx="ekr.20040707141957.12">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()

leoTest.runAtFileTest(c,p)</t>
<t tx="ekr.20040707141957.13">Line 1

@last last line 1: no newline</t>
<t tx="ekr.20040707141957.14">#@+leo-ver=4-thin
#@+node:ekr.20040707141957.13:@@thin
Line 1

#@@last
#@nonl
#@-node:ekr.20040707141957.13:@@thin
#@-leo
last line 1: no newline</t>
<t tx="ekr.20040707150427"></t>
<t tx="ekr.20040707151028">def doPluginTest (path,fileName,verbose=False):
    
    # Duplicate the import logic in leoPlugins.py.
    
    fileName = g.toUnicode(fileName,g.app.tkEncoding)

    if verbose:
        g.trace(str(fileName))

    module = g.importFromPath(fileName,path)
    if not module:
        print "Warning: can not import %s", g.shortFileName(fileName)
        return
    
    # Run any unit tests in the module itself.
    if hasattr(module,"unitTest"):
        if verbose:
            g.trace("Executing unitTest in %s..." % \
                str(g.shortFileName(fileName)))
        module.unitTest()</t>
<t tx="ekr.20040708080620">@nocolor

Changed made by EKR on 7/8/04.

- Created @suite node to call makeReformatParagraphSuite

- Used makeSuite(reformatParagraphTestCase,'test') in makeReformatParagraphSuite instead of list of tests.

- modified setUp to handle these new conventions.
    - Search for reformatParagraphsTests anywhere in the tree
    - Created tempNode inside reformatParagraphsTests tree.</t>
<t tx="ekr.20040708080620.1"></t>
<t tx="ekr.20040708113527">@ The names of child nodes are the names of commander methods to be called to do the test.

Each child node will in turn have two or more children:
    
- a "before" node
- an "after" node
- an optional selection node containing two lines giving the selection range in Tk coordinates.
- An optional insert node containing one line giving the insert point in Tk coordinates.
@c</t>
<t tx="ekr.20040708113527.1"></t>
<t tx="ekr.20040708113527.2">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040708113527.3">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040708113527.4">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040708113527.5"></t>
<t tx="ekr.20040708113527.6">line 1
line 2
line 3
line 4</t>
<t tx="ekr.20040708113527.7">line 1
    line 2
    line 3
line 4</t>
<t tx="ekr.20040708113527.8">2.0
3.0 lineend - 1c</t>
<t tx="ekr.20040708113527.9"></t>
<t tx="ekr.20040708113527.10">before
&lt;&lt; section &gt;&gt;
sec line 1
    sec line 2 indented
sec line 3
after</t>
<t tx="ekr.20040708113527.11">before
&lt;&lt; section &gt;&gt;
after</t>
<t tx="ekr.20040708113527.12">sec line 1
    sec line 2 indented
sec line 3</t>
<t tx="ekr.20040708113527.13">2.0
5.0 lineend -1c</t>
<t tx="ekr.20040708113823"></t>
<t tx="ekr.20040708135624">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()


print "children", '-' * 20
children = u.findChildrenOf(p)
for child in children: print child.headString()

print "subtree", '-' * 20
descendents = u.findSubnodesOf(p)
for descendent in descendents: print descendent.headString()</t>
<t tx="ekr.20040708172357"></t>
<t tx="ekr.20040708172802">aaa</t>
<t tx="ekr.20040708173308.1"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("importTests",doImport=True)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040708173549"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g

import unittest
import leoTest ; reload(leoTest)

@others

suite = leoTest.makeImportExportSuite("exportTests",doImport=False)

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040708174345"></t>
<t tx="ekr.20040708174345.1"></t>
<t tx="ekr.20040708174955"># Create unit tests in g.app.scriptDict["suite"]

import leoGlobals as g
import unittest
import leoTest ; reload(leoTest)

@others

suite = makeOutlineSuite("outlineTests")

g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040708175948">def shortDescription (self):
    
    return self.parent.headString()</t>
<t tx="ekr.20040708181226">import leoGlobals as g
import leoNodes

c = g.top();  p = c.currentPosition()
root1 = p.firstChild()

root2 = root1.copyTreeAfter()
root2.initHeadString("root2")
c.checkOutline()
c.redraw()
root2.doDelete(root1)
c.checkOutline()
c.redraw()</t>
<t tx="ekr.20040708181226.1"></t>
<t tx="ekr.20040708181226.2"></t>
<t tx="ekr.20040708181226.3"></t>
<t tx="ekr.20040708185414"></t>
<t tx="ekr.20040708203222"></t>
<t tx="ekr.20040708205153">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040708205640"></t>
<t tx="ekr.20040708205841">@language python
@tabwidth -4

@ignore
</t>
<t tx="ekr.20040708210045">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040708210442"></t>
<t tx="ekr.20040708210636"></t>
<t tx="ekr.20040708211223">import leoGlobals as g

c = g.top()
p = c.currentPosition().firstChild()

c.selectVnode(p) # Sets body text.
val = c.frame.body.colorizer.colorize(p,incremental=False)

assert val=="ok", "colorizer test failed: %s" % p.headString()</t>
<t tx="ekr.20040708212348">import leoGlobals as g
import leoTest
reload(leoTest)

c = g.top() ; p = c.currentPosition()
u = leoTest.testUtils()

outline1 = p.firstChild()
outline2 = outline1.next()
assert(outline1.headString()=="outline1")
assert(outline2.headString()=="outline2")

u.replaceOutline(c,outline1,outline2)
c.redraw()
c.checkOutline()</t>
<t tx="ekr.20040708213736"></t>
<t tx="ekr.20040708213736.1"></t>
<t tx="ekr.20040708214013"></t>
<t tx="ekr.20040708214013.1"></t>
<t tx="ekr.20040708214530">import leoGlobals as g

c = g.top()
errors = c.checkOutline(verbose=False,unittest=True,full=True) # Run full check.
assert errors == 0, "Check Outline reported %d errors" % errors</t>
<t tx="ekr.20040708215319"></t>
<t tx="ekr.20040708215633"></t>
<t tx="ekr.20040708215633.1"></t>
<t tx="ekr.20040708215633.2"></t>
<t tx="ekr.20040708215633.3"></t>
<t tx="ekr.20040709094228">a bcdef.hij
lmn</t>
<t tx="ekr.20040710120700"></t>
<t tx="ekr.20040710125250"></t>
<t tx="ekr.20040710125250.1">@killcolor

The idea is to use Python's imp module to simulate an import from a file.</t>
<t tx="ekr.20040710125250.2">import leoGlobals as g
import imp
import StringIO

@
load_module( name, file, filename, description) 

Load a module that was previously found by find_module() (or by an otherwise conducted search yielding compatible results). This function does more than importing the module: if the module was already imported, it is equivalent to a reload()! The name argument indicates the full module name (including the package name, if this is a submodule of a package). The file argument is an open file, and filename is the corresponding file name; these can be None and '', respectively, when the module is not being loaded from a file. The description argument is a tuple, as would be returned by get_suffixes(), describing what kind of module must be loaded. 
If the load is successful, the return value is the module object; otherwise, an exception (usually ImportError) is raised. 

Important: the caller is responsible for closing the file argument, if it was not None, even when an exception is raised. This is best done using a try ... finally statement.
@c

s = """

def foobar(): pass

"""

@ get_suffixes( ) 

Return a list of triples, each describing a particular type of module. Each triple has the form (suffix, mode, type), where suffix is a string to be appended to the module name to form the filename to search for, mode is the mode string to pass to the built-in open() function to open the file (this can be 'r' for text files or 'rb' for binary files), and type is the file type, which has one of the values PY_SOURCE, PY_COMPILED, or C_EXTENSION, described below.
@c

print '-' * 20
description = (".py","r",imp.PY_SOURCE)
theFile = StringIO.StringIO(s) # Create a file-like object
print repr(theFile)
try:
    imp.load_module("myModule",theFile,"myFileName",description)
except:
    g.es_exception()



</t>
<t tx="ekr.20040710140454"></t>
<t tx="ekr.20040710140534">
@language python
&lt;&lt; doctest declarations &gt;&gt;
@others

if __name__ == "__main__":
    _test()
</t>
<t tx="ekr.20040710140534.1"># Module doctest.
# Released to the public domain 16-Jan-2001,
# by Tim Peters (tim.one@home.com).

# Provided as-is; use at your own risk; no warranty; no promises; enjoy!

"""Module doctest -- a framework for running examples in docstrings.

NORMAL USAGE

In normal use, end each module M with:

def _test():
    import doctest, M           # replace M with your module's name
    return doctest.testmod(M)   # ditto

if __name__ == "__main__":
    _test()

Then running the module as a script will cause the examples in the
docstrings to get executed and verified:

python M.py

This won't display anything unless an example fails, in which case the
failing example(s) and the cause(s) of the failure(s) are printed to stdout
(why not stderr? because stderr is a lame hack &lt;0.2 wink&gt;), and the final
line of output is "Test failed.".

Run it with the -v switch instead:

python M.py -v

and a detailed report of all examples tried is printed to stdout, along
with assorted summaries at the end.

You can force verbose mode by passing "verbose=1" to testmod, or prohibit
it by passing "verbose=0".  In either of those cases, sys.argv is not
examined by testmod.

In any case, testmod returns a 2-tuple of ints (f, t), where f is the
number of docstring examples that failed and t is the total number of
docstring examples attempted.


WHICH DOCSTRINGS ARE EXAMINED?

+ M.__doc__.

+ f.__doc__ for all functions f in M.__dict__.values(), except those
  defined in other modules.

+ C.__doc__ for all classes C in M.__dict__.values(), except those
  defined in other modules.

+ If M.__test__ exists and "is true", it must be a dict, and
  each entry maps a (string) name to a function object, class object, or
  string.  Function and class object docstrings found from M.__test__
  are searched even if the name is private, and strings are searched
  directly as if they were docstrings.  In output, a key K in M.__test__
  appears with name
      &lt;name of M&gt;.__test__.K

Any classes found are recursively searched similarly, to test docstrings in
their contained methods and nested classes.  All names reached from
M.__test__ are searched.

Optionally, functions with private names can be skipped (unless listed in
M.__test__) by supplying a function to the "isprivate" argument that will
identify private functions.  For convenience, one such function is
supplied.  docttest.is_private considers a name to be private if it begins
with an underscore (like "_my_func") but doesn't both begin and end with
(at least) two underscores (like "__init__").  By supplying this function
or your own "isprivate" function to testmod, the behavior can be customized.

If you want to test docstrings in objects with private names too, stuff
them into an M.__test__ dict, or see ADVANCED USAGE below (e.g., pass your
own isprivate function to Tester's constructor, or call the rundoc method
of a Tester instance).

WHAT'S THE EXECUTION CONTEXT?

By default, each time testmod finds a docstring to test, it uses a *copy*
of M's globals (so that running tests on a module doesn't change the
module's real globals, and so that one test in M can't leave behind crumbs
that accidentally allow another test to work).  This means examples can
freely use any names defined at top-level in M.  It also means that sloppy
imports (see above) can cause examples in external docstrings to use
globals inappropriate for them.

You can force use of your own dict as the execution context by passing
"globs=your_dict" to testmod instead.  Presumably this would be a copy of
M.__dict__ merged with the globals from other imported modules.


WHAT IF I WANT TO TEST A WHOLE PACKAGE?

Piece o' cake, provided the modules do their testing from docstrings.
Here's the test.py I use for the world's most elaborate Rational/
floating-base-conversion pkg (which I'll distribute some day):

from Rational import Cvt
from Rational import Format
from Rational import machprec
from Rational import Rat
from Rational import Round
from Rational import utils

modules = (Cvt,
           Format,
           machprec,
           Rat,
           Round,
           utils)

def _test():
    import doctest
    import sys
    verbose = "-v" in sys.argv
    for mod in modules:
        doctest.testmod(mod, verbose=verbose, report=0)
    doctest.master.summarize()

if __name__ == "__main__":
    _test()

IOW, it just runs testmod on all the pkg modules.  testmod remembers the
names and outcomes (# of failures, # of tries) for each item it's seen, and
passing "report=0" prevents it from printing a summary in verbose mode.
Instead, the summary is delayed until all modules have been tested, and
then "doctest.master.summarize()" forces the summary at the end.

So this is very nice in practice:  each module can be tested individually
with almost no work beyond writing up docstring examples, and collections
of modules can be tested too as a unit with no more work than the above.


WHAT ABOUT EXCEPTIONS?

No problem, as long as the only output generated by the example is the
traceback itself.  For example:

    &gt;&gt;&gt; [1, 2, 3].remove(42)
    Traceback (most recent call last):
      File "&lt;stdin&gt;", line 1, in ?
    ValueError: list.remove(x): x not in list
    &gt;&gt;&gt;

Note that only the exception type and value are compared (specifically,
only the last line in the traceback).


ADVANCED USAGE

doctest.testmod() captures the testing policy I find most useful most
often.  You may want other policies.

testmod() actually creates a local instance of class doctest.Tester, runs
appropriate methods of that class, and merges the results into global
Tester instance doctest.master.

You can create your own instances of doctest.Tester, and so build your own
policies, or even run methods of doctest.master directly.  See
doctest.Tester.__doc__ for details.


SO WHAT DOES A DOCSTRING EXAMPLE LOOK LIKE ALREADY!?

Oh ya.  It's easy!  In most cases a copy-and-paste of an interactive
console session works fine -- just make sure the leading whitespace is
rigidly consistent (you can mix tabs and spaces if you're too lazy to do it
right, but doctest is not in the business of guessing what you think a tab
means).

    &gt;&gt;&gt; # comments are ignored
    &gt;&gt;&gt; x = 12
    &gt;&gt;&gt; x
    12
    &gt;&gt;&gt; if x == 13:
    ...     print "yes"
    ... else:
    ...     print "no"
    ...     print "NO"
    ...     print "NO!!!"
    ...
    no
    NO
    NO!!!
    &gt;&gt;&gt;

Any expected output must immediately follow the final "&gt;&gt;&gt;" or "..." line
containing the code, and the expected output (if any) extends to the next
"&gt;&gt;&gt;" or all-whitespace line.  That's it.

Bummers:

+ Expected output cannot contain an all-whitespace line, since such a line
  is taken to signal the end of expected output.

+ Output to stdout is captured, but not output to stderr (exception
  tracebacks are captured via a different means).

+ If you continue a line via backslashing in an interactive session, or for
  any other reason use a backslash, you need to double the backslash in the
  docstring version.  This is simply because you're in a string, and so the
  backslash must be escaped for it to survive intact.  Like:

&gt;&gt;&gt; if "yes" == \\
...     "y" +   \\
...     "es":   # in the source code you'll see the doubled backslashes
...     print 'yes'
yes

The starting column doesn't matter:

&gt;&gt;&gt; assert "Easy!"
     &gt;&gt;&gt; import math
            &gt;&gt;&gt; math.floor(1.9)
            1.0

and as many leading whitespace characters are stripped from the expected
output as appeared in the initial "&gt;&gt;&gt;" line that triggered it.

If you execute this very file, the examples above will be found and
executed, leading to this output in verbose mode:

Running doctest.__doc__
Trying: [1, 2, 3].remove(42)
Expecting:
Traceback (most recent call last):
  File "&lt;stdin&gt;", line 1, in ?
ValueError: list.remove(x): x not in list
ok
Trying: x = 12
Expecting: nothing
ok
Trying: x
Expecting: 12
ok
Trying:
if x == 13:
    print "yes"
else:
    print "no"
    print "NO"
    print "NO!!!"
Expecting:
no
NO
NO!!!
ok
... and a bunch more like that, with this summary at the end:

5 items had no tests:
    doctest.Tester.__init__
    doctest.Tester.run__test__
    doctest.Tester.summarize
    doctest.run_docstring_examples
    doctest.testmod
12 items passed all tests:
   8 tests in doctest
   6 tests in doctest.Tester
  10 tests in doctest.Tester.merge
  14 tests in doctest.Tester.rundict
   3 tests in doctest.Tester.rundoc
   3 tests in doctest.Tester.runstring
   2 tests in doctest.__test__._TestClass
   2 tests in doctest.__test__._TestClass.__init__
   2 tests in doctest.__test__._TestClass.get
   1 tests in doctest.__test__._TestClass.square
   2 tests in doctest.__test__.string
   7 tests in doctest.is_private
60 tests in 17 items.
60 passed and 0 failed.
Test passed.
"""

__all__ = [
    'testmod',
    'run_docstring_examples',
    'is_private',
    'Tester',
    'DocTestTestFailure',
    'DocTestSuite',
    'testsource',
    'debug',
    'master',
]

import __future__

import re
PS1 = "&gt;&gt;&gt;"
PS2 = "..."
_isPS1 = re.compile(r"(\s*)" + re.escape(PS1)).match
_isPS2 = re.compile(r"(\s*)" + re.escape(PS2)).match
_isEmpty = re.compile(r"\s*$").match
_isComment = re.compile(r"\s*#").match
del re

from types import StringTypes as _StringTypes

from inspect import isclass    as _isclass
from inspect import isfunction as _isfunction
from inspect import ismethod as _ismethod
from inspect import ismodule   as _ismodule
from inspect import classify_class_attrs as _classify_class_attrs

# Option constants.
DONT_ACCEPT_TRUE_FOR_1 = 1 &lt;&lt; 0

# Extract interactive examples from a string.  Return a list of triples,
# (source, outcome, lineno).  "source" is the source code, and ends
# with a newline iff the source spans more than one line.  "outcome" is
# the expected output if any, else an empty string.  When not empty,
# outcome always ends with a newline.  "lineno" is the line number,
# 0-based wrt the start of the string, of the first source line.

</t>
<t tx="ekr.20040710140534.2">def _extract_examples(s):
    isPS1, isPS2 = _isPS1, _isPS2
    isEmpty, isComment = _isEmpty, _isComment
    examples = []
    lines = s.split("\n")
    i, n = 0, len(lines)
    while i &lt; n:
        line = lines[i]
        i = i + 1
        m = isPS1(line)
        if m is None:
            continue
        j = m.end(0)  # beyond the prompt
        if isEmpty(line, j) or isComment(line, j):
            # a bare prompt or comment -- not interesting
            continue
        lineno = i - 1
        if line[j] != " ":
            raise ValueError("line " + `lineno` + " of docstring lacks "
                "blank after " + PS1 + ": " + line)
        j = j + 1
        blanks = m.group(1)
        nblanks = len(blanks)
        # suck up this and following PS2 lines
        source = []
        while 1:
            source.append(line[j:])
            line = lines[i]
            m = isPS2(line)
            if m:
                if m.group(1) != blanks:
                    raise ValueError("inconsistent leading whitespace "
                        "in line " + `i` + " of docstring: " + line)
                i = i + 1
            else:
                break
        if len(source) == 1:
            source = source[0]
        else:
            # get rid of useless null line from trailing empty "..."
            if source[-1] == "":
                del source[-1]
            source = "\n".join(source) + "\n"
        # suck up response
        if isPS1(line) or isEmpty(line):
            expect = ""
        else:
            expect = []
            while 1:
                if line[:nblanks] != blanks:
                    raise ValueError("inconsistent leading whitespace "
                        "in line " + `i` + " of docstring: " + line)
                expect.append(line[nblanks:])
                i = i + 1
                line = lines[i]
                if isPS1(line) or isEmpty(line):
                    break
            expect = "\n".join(expect) + "\n"
        examples.append( (source, expect, lineno) )
    return examples
</t>
<t tx="ekr.20040710140534.3">
# Capture stdout when running examples.

class _SpoofOut:
	@others
</t>
<t tx="ekr.20040710140534.4">def __init__(self):
    self.clear()
</t>
<t tx="ekr.20040710140534.5">def write(self, s):
    self.buf.append(s)
</t>
<t tx="ekr.20040710140534.6">def get(self):
    guts = "".join(self.buf)
    # If anything at all was written, make sure there's a trailing
    # newline.  There's no way for the expected output to indicate
    # that a trailing newline is missing.
    if guts and not guts.endswith("\n"):
        guts = guts + "\n"
    # Prevent softspace from screwing up the next test case, in
    # case they used print with a trailing comma in an example.
    if hasattr(self, "softspace"):
        del self.softspace
    return guts
</t>
<t tx="ekr.20040710140534.7">def clear(self):
    self.buf = []
    if hasattr(self, "softspace"):
        del self.softspace
</t>
<t tx="ekr.20040710140534.8">def flush(self):
    # JPython calls flush
    pass
</t>
<t tx="ekr.20040710140534.9"># Display some tag-and-msg pairs nicely, keeping the tag and its msg
# on the same line when that makes sense.

def _tag_out(printer, *tag_msg_pairs):
    for tag, msg in tag_msg_pairs:
        printer(tag + ":")
        msg_has_nl = msg[-1:] == "\n"
        msg_has_two_nl = msg_has_nl and \
                        msg.find("\n") &lt; len(msg) - 1
        if len(tag) + len(msg) &lt; 76 and not msg_has_two_nl:
            printer(" ")
        else:
            printer("\n")
        printer(msg)
        if not msg_has_nl:
            printer("\n")
</t>
<t tx="ekr.20040710140534.10"># Run list of examples, in context globs.  "out" can be used to display
# stuff to "the real" stdout, and fakeout is an instance of _SpoofOut
# that captures the examples' std output.  Return (#failures, #tries).

def _run_examples_inner(out, fakeout, examples, globs, verbose, name,
                        compileflags, optionflags):
    import sys, traceback
    OK, BOOM, FAIL = range(3)
    NADA = "nothing"
    stderr = _SpoofOut()
    failures = 0
    for source, want, lineno in examples:
        if verbose:
            _tag_out(out, ("Trying", source),
                          ("Expecting", want or NADA))
        fakeout.clear()
        try:
            exec compile(source, "&lt;string&gt;", "single",
                         compileflags, 1) in globs
            got = fakeout.get()
            state = OK
        except KeyboardInterrupt:
            raise
        except:
            # See whether the exception was expected.
            if want.find("Traceback (innermost last):\n") == 0 or \
               want.find("Traceback (most recent call last):\n") == 0:
                # Only compare exception type and value - the rest of
                # the traceback isn't necessary.
                want = want.split('\n')[-2] + '\n'
                exc_type, exc_val = sys.exc_info()[:2]
                got = traceback.format_exception_only(exc_type, exc_val)[-1]
                state = OK
            else:
                # unexpected exception
                stderr.clear()
                traceback.print_exc(file=stderr)
                state = BOOM

        if state == OK:
            if (got == want or
                (not (optionflags &amp; DONT_ACCEPT_TRUE_FOR_1) and
                 (got, want) in (("True\n", "1\n"), ("False\n", "0\n"))
                )
               ):
                if verbose:
                    out("ok\n")
                continue
            state = FAIL

        assert state in (FAIL, BOOM)
        failures = failures + 1
        out("*" * 65 + "\n")
        _tag_out(out, ("Failure in example", source))
        out("from line #" + `lineno` + " of " + name + "\n")
        if state == FAIL:
            _tag_out(out, ("Expected", want or NADA), ("Got", got))
        else:
            assert state == BOOM
            _tag_out(out, ("Exception raised", stderr.get()))

    return failures, len(examples)
</t>
<t tx="ekr.20040710140534.11"># Get the future-flags associated with the future features that have been
# imported into globs.

def _extract_future_flags(globs):
    flags = 0
    for fname in __future__.all_feature_names:
        feature = globs.get(fname, None)
        if feature is getattr(__future__, fname):
            flags |= feature.compiler_flag
    return flags
</t>
<t tx="ekr.20040710140534.12"># Run list of examples, in a shallow copy of context (dict) globs.
# Return (#failures, #tries).

def _run_examples(examples, globs, verbose, name, compileflags,
                  optionflags):
    import sys
    saveout = sys.stdout
    globs = globs.copy()
    try:
        sys.stdout = fakeout = _SpoofOut()
        x = _run_examples_inner(saveout.write, fakeout, examples,
                                globs, verbose, name, compileflags,
                                optionflags)
    finally:
        sys.stdout = saveout
        # While Python gc can clean up most cycles on its own, it doesn't
        # chase frame objects.  This is especially irksome when running
        # generator tests that raise exceptions, because a named generator-
        # iterator gets an entry in globs, and the generator-iterator
        # object's frame's traceback info points back to globs.  This is
        # easy to break just by clearing the namespace.  This can also
        # help to break other kinds of cycles, and even for cycles that
        # gc can break itself it's better to break them ASAP.
        globs.clear()
    return x
</t>
<t tx="ekr.20040710140534.13">def run_docstring_examples(f, globs, verbose=0, name="NoName",
                           compileflags=None, optionflags=0):
    """f, globs, verbose=0, name="NoName" -&gt; run examples from f.__doc__.

    Use (a shallow copy of) dict globs as the globals for execution.
    Return (#failures, #tries).

    If optional arg verbose is true, print stuff even if there are no
    failures.
    Use string name in failure msgs.
    """

    try:
        doc = f.__doc__
        if not doc:
            # docstring empty or None
            return 0, 0
        # just in case CT invents a doc object that has to be forced
        # to look like a string &lt;0.9 wink&gt;
        doc = str(doc)
    except KeyboardInterrupt:
        raise
    except:
        return 0, 0

    e = _extract_examples(doc)
    if not e:
        return 0, 0
    if compileflags is None:
        compileflags = _extract_future_flags(globs)
    return _run_examples(e, globs, verbose, name, compileflags, optionflags)
</t>
<t tx="ekr.20040710140534.14">def is_private(prefix, base):
    """prefix, base -&gt; true iff name prefix + "." + base is "private".

    Prefix may be an empty string, and base does not contain a period.
    Prefix is ignored (although functions you write conforming to this
    protocol may make use of it).
    Return true iff base begins with an (at least one) underscore, but
    does not both begin and end with (at least) two underscores.

    &gt;&gt;&gt; is_private("a.b", "my_func")
    False
    &gt;&gt;&gt; is_private("____", "_my_func")
    True
    &gt;&gt;&gt; is_private("someclass", "__init__")
    False
    &gt;&gt;&gt; is_private("sometypo", "__init_")
    True
    &gt;&gt;&gt; is_private("x.y.z", "_")
    True
    &gt;&gt;&gt; is_private("_x.y.z", "__")
    False
    &gt;&gt;&gt; is_private("", "")  # senseless but consistent
    False
    """

    return base[:1] == "_" and not base[:2] == "__" == base[-2:]
</t>
<t tx="ekr.20040710140534.15"># Determine if a class of function was defined in the given module.

def _from_module(module, object):
    if _isfunction(object):
        return module.__dict__ is object.func_globals
    if _isclass(object):
        return module.__name__ == object.__module__
    raise ValueError("object must be a class or function")
</t>
<t tx="ekr.20040710140534.16">
class Tester:
    """Class Tester -- runs docstring examples and accumulates stats.

In normal use, function doctest.testmod() hides all this from you,
so use that if you can.  Create your own instances of Tester to do
fancier things.

Methods:
    runstring(s, name)
        Search string s for examples to run; use name for logging.
        Return (#failures, #tries).

    rundoc(object, name=None)
        Search object.__doc__ for examples to run; use name (or
        object.__name__) for logging.  Return (#failures, #tries).

    rundict(d, name, module=None)
        Search for examples in docstrings in all of d.values(); use name
        for logging.  Exclude functions and classes not defined in module
        if specified.  Return (#failures, #tries).

    run__test__(d, name)
        Treat dict d like module.__test__.  Return (#failures, #tries).

    summarize(verbose=None)
        Display summary of testing results, to stdout.  Return
        (#failures, #tries).

    merge(other)
        Merge in the test results from Tester instance "other".

&gt;&gt;&gt; from doctest import Tester
&gt;&gt;&gt; t = Tester(globs={'x': 42}, verbose=0)
&gt;&gt;&gt; t.runstring(r'''
...      &gt;&gt;&gt; x = x * 2
...      &gt;&gt;&gt; print x
...      42
... ''', 'XYZ')
*****************************************************************
Failure in example: print x
from line #2 of XYZ
Expected: 42
Got: 84
(1, 2)
&gt;&gt;&gt; t.runstring("&gt;&gt;&gt; x = x * 2\\n&gt;&gt;&gt; print x\\n84\\n", 'example2')
(0, 2)
&gt;&gt;&gt; t.summarize()
*****************************************************************
1 items had failures:
   1 of   2 in XYZ
***Test Failed*** 1 failures.
(1, 4)
&gt;&gt;&gt; t.summarize(verbose=1)
1 items passed all tests:
   2 tests in example2
*****************************************************************
1 items had failures:
   1 of   2 in XYZ
4 tests in 2 items.
3 passed and 1 failed.
***Test Failed*** 1 failures.
(1, 4)
&gt;&gt;&gt;
"""
	@others
</t>
<t tx="ekr.20040710140534.17">def __init__(self, mod=None, globs=None, verbose=None,
             isprivate=None, optionflags=0):
    """mod=None, globs=None, verbose=None, isprivate=None,
optionflags=0

See doctest.__doc__ for an overview.

Optional keyword arg "mod" is a module, whose globals are used for
executing examples.  If not specified, globs must be specified.

Optional keyword arg "globs" gives a dict to be used as the globals
when executing examples; if not specified, use the globals from
module mod.

In either case, a copy of the dict is used for each docstring
examined.

Optional keyword arg "verbose" prints lots of stuff if true, only
failures if false; by default, it's true iff "-v" is in sys.argv.

Optional keyword arg "isprivate" specifies a function used to determine
whether a name is private.  The default function is to assume that
no functions are private.  The "isprivate" arg may be set to
doctest.is_private in order to skip over functions marked as private
using an underscore naming convention; see its docs for details.

See doctest.testmod docs for the meaning of optionflags.
"""

    if mod is None and globs is None:
        raise TypeError("Tester.__init__: must specify mod or globs")
    if mod is not None and not _ismodule(mod):
        raise TypeError("Tester.__init__: mod must be a module; " +
                        `mod`)
    if globs is None:
        globs = mod.__dict__
    self.globs = globs

    if verbose is None:
        import sys
        verbose = "-v" in sys.argv
    self.verbose = verbose

    # By default, assume that nothing is private
    if isprivate is None:
        isprivate = lambda prefix, base:  0
    self.isprivate = isprivate

    self.optionflags = optionflags

    self.name2ft = {}   # map name to (#failures, #trials) pair

    self.compileflags = _extract_future_flags(globs)
</t>
<t tx="ekr.20040710140534.18">def runstring(self, s, name):
    """
    s, name -&gt; search string s for examples to run, logging as name.

    Use string name as the key for logging the outcome.
    Return (#failures, #examples).

    &gt;&gt;&gt; t = Tester(globs={}, verbose=1)
    &gt;&gt;&gt; test = r'''
    ...    # just an example
    ...    &gt;&gt;&gt; x = 1 + 2
    ...    &gt;&gt;&gt; x
    ...    3
    ... '''
    &gt;&gt;&gt; t.runstring(test, "Example")
    Running string Example
    Trying: x = 1 + 2
    Expecting: nothing
    ok
    Trying: x
    Expecting: 3
    ok
    0 of 2 examples failed in string Example
    (0, 2)
    """

    if self.verbose:
        print "Running string", name
    f = t = 0
    e = _extract_examples(s)
    if e:
        f, t = _run_examples(e, self.globs, self.verbose, name,
                             self.compileflags, self.optionflags)
    if self.verbose:
        print f, "of", t, "examples failed in string", name
    self.__record_outcome(name, f, t)
    return f, t
</t>
<t tx="ekr.20040710140534.19">def rundoc(self, object, name=None):
    """
    object, name=None -&gt; search object.__doc__ for examples to run.

    Use optional string name as the key for logging the outcome;
    by default use object.__name__.
    Return (#failures, #examples).
    If object is a class object, search recursively for method
    docstrings too.
    object.__doc__ is examined regardless of name, but if object is
    a class, whether private names reached from object are searched
    depends on the constructor's "isprivate" argument.

    &gt;&gt;&gt; t = Tester(globs={}, verbose=0)
    &gt;&gt;&gt; def _f():
    ...     '''Trivial docstring example.
    ...     &gt;&gt;&gt; assert 2 == 2
    ...     '''
    ...     return 32
    ...
    &gt;&gt;&gt; t.rundoc(_f)  # expect 0 failures in 1 example
    (0, 1)
    """

    if name is None:
        try:
            name = object.__name__
        except AttributeError:
            raise ValueError("Tester.rundoc: name must be given "
                "when object.__name__ doesn't exist; " + `object`)
    if self.verbose:
        print "Running", name + ".__doc__"
    f, t = run_docstring_examples(object, self.globs, self.verbose, name,
                                  self.compileflags, self.optionflags)
    if self.verbose:
        print f, "of", t, "examples failed in", name + ".__doc__"
    self.__record_outcome(name, f, t)
    if _isclass(object):
        # In 2.2, class and static methods complicate life.  Build
        # a dict "that works", by hook or by crook.
        d = {}
        for tag, kind, homecls, value in _classify_class_attrs(object):

            if homecls is not object:
                # Only look at names defined immediately by the class.
                continue

            elif self.isprivate(name, tag):
                continue

            elif kind == "method":
                # value is already a function
                d[tag] = value

            elif kind == "static method":
                # value isn't a function, but getattr reveals one
                d[tag] = getattr(object, tag)

            elif kind == "class method":
                # Hmm.  A classmethod object doesn't seem to reveal
                # enough.  But getattr turns it into a bound method,
                # and from there .im_func retrieves the underlying
                # function.
                d[tag] = getattr(object, tag).im_func

            elif kind == "property":
                # The methods implementing the property have their
                # own docstrings -- but the property may have one too.
                if value.__doc__ is not None:
                    d[tag] = str(value.__doc__)

            elif kind == "data":
                # Grab nested classes.
                if _isclass(value):
                    d[tag] = value

            else:
                raise ValueError("teach doctest about %r" % kind)

        f2, t2 = self.run__test__(d, name)
        f += f2
        t += t2

    return f, t
</t>
<t tx="ekr.20040710140534.20">def rundict(self, d, name, module=None):
    """
    d, name, module=None -&gt; search for docstring examples in d.values().

    For k, v in d.items() such that v is a function or class,
    do self.rundoc(v, name + "." + k).  Whether this includes
    objects with private names depends on the constructor's
    "isprivate" argument.  If module is specified, functions and
    classes that are not defined in module are excluded.
    Return aggregate (#failures, #examples).

    Build and populate two modules with sample functions to test that
    exclusion of external functions and classes works.

    &gt;&gt;&gt; import new
    &gt;&gt;&gt; m1 = new.module('_m1')
    &gt;&gt;&gt; m2 = new.module('_m2')
    &gt;&gt;&gt; test_data = \"""
    ... def _f():
    ...     '''&gt;&gt;&gt; assert 1 == 1
    ...     '''
    ... def g():
    ...    '''&gt;&gt;&gt; assert 2 != 1
    ...    '''
    ... class H:
    ...    '''&gt;&gt;&gt; assert 2 &gt; 1
    ...    '''
    ...    def bar(self):
    ...        '''&gt;&gt;&gt; assert 1 &lt; 2
    ...        '''
    ... \"""
    &gt;&gt;&gt; exec test_data in m1.__dict__
    &gt;&gt;&gt; exec test_data in m2.__dict__
    &gt;&gt;&gt; m1.__dict__.update({"f2": m2._f, "g2": m2.g, "h2": m2.H})

    Tests that objects outside m1 are excluded:

    &gt;&gt;&gt; t = Tester(globs={}, verbose=0, isprivate=is_private)
    &gt;&gt;&gt; t.rundict(m1.__dict__, "rundict_test", m1)  # _f, f2 and g2 and h2 skipped
    (0, 3)

    Again, but with the default isprivate function allowing _f:

    &gt;&gt;&gt; t = Tester(globs={}, verbose=0)
    &gt;&gt;&gt; t.rundict(m1.__dict__, "rundict_test_pvt", m1)  # Only f2, g2 and h2 skipped
    (0, 4)

    And once more, not excluding stuff outside m1:

    &gt;&gt;&gt; t = Tester(globs={}, verbose=0)
    &gt;&gt;&gt; t.rundict(m1.__dict__, "rundict_test_pvt")  # None are skipped.
    (0, 8)

    The exclusion of objects from outside the designated module is
    meant to be invoked automagically by testmod.

    &gt;&gt;&gt; testmod(m1, isprivate=is_private)
    (0, 3)

    """

    if not hasattr(d, "items"):
        raise TypeError("Tester.rundict: d must support .items(); " +
                        `d`)
    f = t = 0
    # Run the tests by alpha order of names, for consistency in
    # verbose-mode output.
    names = d.keys()
    names.sort()
    for thisname in names:
        value = d[thisname]
        if _isfunction(value) or _isclass(value):
            if module and not _from_module(module, value):
                continue
            f2, t2 = self.__runone(value, name + "." + thisname)
            f = f + f2
            t = t + t2
    return f, t
</t>
<t tx="ekr.20040710140534.21">def run__test__(self, d, name):
    """d, name -&gt; Treat dict d like module.__test__.

    Return (#failures, #tries).
    See testmod.__doc__ for details.
    """

    failures = tries = 0
    prefix = name + "."
    savepvt = self.isprivate
    try:
        self.isprivate = lambda *args: 0
        # Run the tests by alpha order of names, for consistency in
        # verbose-mode output.
        keys = d.keys()
        keys.sort()
        for k in keys:
            v = d[k]
            thisname = prefix + k
            if type(v) in _StringTypes:
                f, t = self.runstring(v, thisname)
            elif _isfunction(v) or _isclass(v) or _ismethod(v):
                f, t = self.rundoc(v, thisname)
            else:
                raise TypeError("Tester.run__test__: values in "
                        "dict must be strings, functions, methods, "
                        "or classes; " + `v`)
            failures = failures + f
            tries = tries + t
    finally:
        self.isprivate = savepvt
    return failures, tries
</t>
<t tx="ekr.20040710140534.22">def summarize(self, verbose=None):
    """
    verbose=None -&gt; summarize results, return (#failures, #tests).

    Print summary of test results to stdout.
    Optional arg 'verbose' controls how wordy this is.  By
    default, use the verbose setting established by the
    constructor.
    """

    if verbose is None:
        verbose = self.verbose
    notests = []
    passed = []
    failed = []
    totalt = totalf = 0
    for x in self.name2ft.items():
        name, (f, t) = x
        assert f &lt;= t
        totalt = totalt + t
        totalf = totalf + f
        if t == 0:
            notests.append(name)
        elif f == 0:
            passed.append( (name, t) )
        else:
            failed.append(x)
    if verbose:
        if notests:
            print len(notests), "items had no tests:"
            notests.sort()
            for thing in notests:
                print "   ", thing
        if passed:
            print len(passed), "items passed all tests:"
            passed.sort()
            for thing, count in passed:
                print " %3d tests in %s" % (count, thing)
    if failed:
        print "*" * 65
        print len(failed), "items had failures:"
        failed.sort()
        for thing, (f, t) in failed:
            print " %3d of %3d in %s" % (f, t, thing)
    if verbose:
        print totalt, "tests in", len(self.name2ft), "items."
        print totalt - totalf, "passed and", totalf, "failed."
    if totalf:
        print "***Test Failed***", totalf, "failures."
    elif verbose:
        print "Test passed."
    return totalf, totalt
</t>
<t tx="ekr.20040710140534.23">def merge(self, other):
    """
    other -&gt; merge in test results from the other Tester instance.

    If self and other both have a test result for something
    with the same name, the (#failures, #tests) results are
    summed, and a warning is printed to stdout.

    &gt;&gt;&gt; from doctest import Tester
    &gt;&gt;&gt; t1 = Tester(globs={}, verbose=0)
    &gt;&gt;&gt; t1.runstring('''
    ... &gt;&gt;&gt; x = 12
    ... &gt;&gt;&gt; print x
    ... 12
    ... ''', "t1example")
    (0, 2)
    &gt;&gt;&gt;
    &gt;&gt;&gt; t2 = Tester(globs={}, verbose=0)
    &gt;&gt;&gt; t2.runstring('''
    ... &gt;&gt;&gt; x = 13
    ... &gt;&gt;&gt; print x
    ... 13
    ... ''', "t2example")
    (0, 2)
    &gt;&gt;&gt; common = "&gt;&gt;&gt; assert 1 + 2 == 3\\n"
    &gt;&gt;&gt; t1.runstring(common, "common")
    (0, 1)
    &gt;&gt;&gt; t2.runstring(common, "common")
    (0, 1)
    &gt;&gt;&gt; t1.merge(t2)
    *** Tester.merge: 'common' in both testers; summing outcomes.
    &gt;&gt;&gt; t1.summarize(1)
    3 items passed all tests:
       2 tests in common
       2 tests in t1example
       2 tests in t2example
    6 tests in 3 items.
    6 passed and 0 failed.
    Test passed.
    (0, 6)
    &gt;&gt;&gt;
    """

    d = self.name2ft
    for name, (f, t) in other.name2ft.items():
        if name in d:
            print "*** Tester.merge: '" + name + "' in both" \
                " testers; summing outcomes."
            f2, t2 = d[name]
            f = f + f2
            t = t + t2
        d[name] = f, t
</t>
<t tx="ekr.20040710140534.24">def __record_outcome(self, name, f, t):
    if name in self.name2ft:
        print "*** Warning: '" + name + "' was tested before;", \
            "summing outcomes."
        f2, t2 = self.name2ft[name]
        f = f + f2
        t = t + t2
    self.name2ft[name] = f, t
</t>
<t tx="ekr.20040710140534.25">def __runone(self, target, name):
    if "." in name:
        i = name.rindex(".")
        prefix, base = name[:i], name[i+1:]
    else:
        prefix, base = "", base
    if self.isprivate(prefix, base):
        return 0, 0
    return self.rundoc(target, name)
</t>
<t tx="ekr.20040710140534.26">master = None

def testmod(m=None, name=None, globs=None, verbose=None, isprivate=None,
               report=True, optionflags=0):
    """m=None, name=None, globs=None, verbose=None, isprivate=None,
       report=True, optionflags=0

    Test examples in docstrings in functions and classes reachable
    from module m (or the current module if m is not supplied), starting
    with m.__doc__.  Unless isprivate is specified, private names
    are not skipped.

    Also test examples reachable from dict m.__test__ if it exists and is
    not None.  m.__dict__ maps names to functions, classes and strings;
    function and class docstrings are tested even if the name is private;
    strings are tested directly, as if they were docstrings.

    Return (#failures, #tests).

    See doctest.__doc__ for an overview.

    Optional keyword arg "name" gives the name of the module; by default
    use m.__name__.

    Optional keyword arg "globs" gives a dict to be used as the globals
    when executing examples; by default, use m.__dict__.  A copy of this
    dict is actually used for each docstring, so that each docstring's
    examples start with a clean slate.

    Optional keyword arg "verbose" prints lots of stuff if true, prints
    only failures if false; by default, it's true iff "-v" is in sys.argv.

    Optional keyword arg "isprivate" specifies a function used to
    determine whether a name is private.  The default function is
    treat all functions as public.  Optionally, "isprivate" can be
    set to doctest.is_private to skip over functions marked as private
    using the underscore naming convention; see its docs for details.

    Optional keyword arg "report" prints a summary at the end when true,
    else prints nothing at the end.  In verbose mode, the summary is
    detailed, else very brief (in fact, empty if all tests passed).

    Optional keyword arg "optionflags" or's together module constants,
    and defaults to 0.  This is new in 2.3.  Possible values:

        DONT_ACCEPT_TRUE_FOR_1
            By default, if an expected output block contains just "1",
            an actual output block containing just "True" is considered
            to be a match, and similarly for "0" versus "False".  When
            DONT_ACCEPT_TRUE_FOR_1 is specified, neither substitution
            is allowed.

    Advanced tomfoolery:  testmod runs methods of a local instance of
    class doctest.Tester, then merges the results into (or creates)
    global Tester instance doctest.master.  Methods of doctest.master
    can be called directly too, if you want to do something unusual.
    Passing report=0 to testmod is especially useful then, to delay
    displaying a summary.  Invoke doctest.master.summarize(verbose)
    when you're done fiddling.
    """

    global master

    if m is None:
        import sys
        # DWA - m will still be None if this wasn't invoked from the command
        # line, in which case the following TypeError is about as good an error
        # as we should expect
        m = sys.modules.get('__main__')

    if not _ismodule(m):
        raise TypeError("testmod: module required; " + `m`)
    if name is None:
        name = m.__name__
    tester = Tester(m, globs=globs, verbose=verbose, isprivate=isprivate,
                    optionflags=optionflags)
    failures, tries = tester.rundoc(m, name)
    f, t = tester.rundict(m.__dict__, name, m)
    failures += f
    tries += t
    if hasattr(m, "__test__"):
        testdict = m.__test__
        if testdict:
            if not hasattr(testdict, "items"):
                raise TypeError("testmod: module.__test__ must support "
                                ".items(); " + `testdict`)
            f, t = tester.run__test__(testdict, name + ".__test__")
            failures += f
            tries += t
    if report:
        tester.summarize()
    if master is None:
        master = tester
    else:
        master.merge(tester)
    return failures, tries
</t>
<t tx="ekr.20040710140534.27">###########################################################################
# Various doctest extensions, to make using doctest with unittest
# easier, and to help debugging when a doctest goes wrong.  Original
# code by Jim Fulton.

# Utilities.

# If module is None, return the calling module (the module that called
# the routine that called _normalize_module -- this normally won't be
# doctest!).  If module is a string, it should be the (possibly dotted)
# name of a module, and the (rightmost) module object is returned.  Else
# module is returned untouched; the intent appears to be that module is
# already a module object in this case (although this isn't checked).

def _normalize_module(module):
    import sys

    if module is None:
        # Get our caller's caller's module.
        module = sys._getframe(2).f_globals['__name__']
        module = sys.modules[module]

    elif isinstance(module, (str, unicode)):
        # The ["*"] at the end is a mostly meaningless incantation with
        # a crucial property:  if, e.g., module is 'a.b.c', it convinces
        # __import__ to return c instead of a.
        module = __import__(module, globals(), locals(), ["*"])

    return module
</t>
<t tx="ekr.20040710140534.28"># tests is a list of (testname, docstring, filename, lineno) tuples.
# If object has a __doc__ attr, and the __doc__ attr looks like it
# contains a doctest (specifically, if it contains an instance of '&gt;&gt;&gt;'),
# then tuple
#     prefix + name, object.__doc__, filename, lineno
# is appended to tests.  Else tests is left alone.
# There is no return value.

def _get_doctest(name, object, tests, prefix, filename='', lineno=''):
    doc = getattr(object, '__doc__', '')
    if isinstance(doc, basestring) and '&gt;&gt;&gt;' in doc:
        tests.append((prefix + name, doc, filename, lineno))
</t>
<t tx="ekr.20040710140534.29"># tests is a list of (testname, docstring, filename, lineno) tuples.
# docstrings containing doctests are appended to tests (if any are found).
# items is a dict, like a module or class dict, mapping strings to objects.
# mdict is the global dict of a "home" module -- only objects belonging
# to this module are searched for docstrings.  module is the module to
# which mdict belongs.
# prefix is a string to be prepended to an object's name when adding a
# tuple to tests.
# The objects (values) in items are examined (recursively), and doctests
# belonging to functions and classes in the home module are appended to
# tests.
# minlineno is a gimmick to try to guess the file-relative line number
# at which a doctest probably begins.

def _extract_doctests(items, module, mdict, tests, prefix, minlineno=0):

    for name, object in items:
        # Only interested in named objects.
        if not hasattr(object, '__name__'):
            continue

        elif hasattr(object, 'func_globals'):
            # Looks like a function.
            if object.func_globals is not mdict:
                # Non-local function.
                continue
            code = getattr(object, 'func_code', None)
            filename = getattr(code, 'co_filename', '')
            lineno = getattr(code, 'co_firstlineno', -1) + 1
            if minlineno:
                minlineno = min(lineno, minlineno)
            else:
                minlineno = lineno
            _get_doctest(name, object, tests, prefix, filename, lineno)

        elif hasattr(object, "__module__"):
            # Maybe a class-like thing, in which case we care.
            if object.__module__ != module.__name__:
                # Not the same module.
                continue
            if not (hasattr(object, '__dict__')
                    and hasattr(object, '__bases__')):
                # Not a class.
                continue

            lineno = _extract_doctests(object.__dict__.items(),
                                       module,
                                       mdict,
                                       tests,
                                       prefix + name + ".")
            # XXX "-3" is unclear.
            _get_doctest(name, object, tests, prefix,
                         lineno="%s (or above)" % (lineno - 3))

    return minlineno
</t>
<t tx="ekr.20040710140534.30"># Find all the doctests belonging to the module object.
# Return a list of
#     (testname, docstring, filename, lineno)
# tuples.

def _find_tests(module, prefix=None):
    if prefix is None:
        prefix = module.__name__
    mdict = module.__dict__
    tests = []
    # Get the module-level doctest (if any).
    _get_doctest(prefix, module, tests, '', lineno="1 (or above)")
    # Recursively search the module __dict__ for doctests.
    if prefix:
        prefix += "."
    _extract_doctests(mdict.items(), module, mdict, tests, prefix)
    return tests
</t>
<t tx="ekr.20040710140534.31"># unittest helpers.

# A function passed to unittest, for unittest to drive.
# tester is doctest Tester instance.  doc is the docstring whose
# doctests are to be run.

def _utest(tester, name, doc, filename, lineno):
    import sys
    from StringIO import StringIO

    old = sys.stdout
    sys.stdout = new = StringIO()
    try:
        failures, tries = tester.runstring(doc, name)
    finally:
        sys.stdout = old

    if failures:
        msg = new.getvalue()
        lname = '.'.join(name.split('.')[-1:])
        if not lineno:
            lineno = "0 (don't know line number)"
        # Don't change this format!  It was designed so that Emacs can
        # parse it naturally.
        raise DocTestTestFailure('Failed doctest test for %s\n'
                                 '  File "%s", line %s, in %s\n\n%s' %
                                 (name, filename, lineno, lname, msg))
</t>
<t tx="ekr.20040710140534.32">
class DocTestTestFailure(Exception):
    """A doctest test failed"""
</t>
<t tx="ekr.20040710140534.33">def DocTestSuite(module=None):
    """Convert doctest tests for a module to a unittest TestSuite.

    The returned TestSuite is to be run by the unittest framework, and
    runs each doctest in the module.  If any of the doctests fail,
    then the synthesized unit test fails, and an error is raised showing
    the name of the file containing the test and a (sometimes approximate)
    line number.

    The optional module argument provides the module to be tested.  It
    can be a module object or a (possibly dotted) module name.  If not
    specified, the module calling DocTestSuite() is used.

    Example (although note that unittest supplies many ways to use the
    TestSuite returned; see the unittest docs):

        import unittest
        import doctest
        import my_module_with_doctests

        suite = doctest.DocTestSuite(my_module_with_doctests)
        runner = unittest.TextTestRunner()
        runner.run(suite)
    """

    import unittest

    module = _normalize_module(module)
    tests = _find_tests(module)
    if not tests:
        raise ValueError(module, "has no tests")

    tests.sort()
    suite = unittest.TestSuite()
    tester = Tester(module)
    for name, doc, filename, lineno in tests:
        if not filename:
            filename = module.__file__
            if filename.endswith(".pyc"):
                filename = filename[:-1]
            elif filename.endswith(".pyo"):
                filename = filename[:-1]
        def runit(name=name, doc=doc, filename=filename, lineno=lineno):
            _utest(tester, name, doc, filename, lineno)
        suite.addTest(unittest.FunctionTestCase(
                                    runit,
                                    description="doctest of " + name))
    return suite
</t>
<t tx="ekr.20040710140534.34"># Debugging support.

def _expect(expect):
    # Return the expected output (if any), formatted as a Python
    # comment block.
    if expect:
        expect = "\n# ".join(expect.split("\n"))
        expect = "\n# Expect:\n# %s" % expect
    return expect
</t>
<t tx="ekr.20040710140534.35">def testsource(module, name):
    """Extract the doctest examples from a docstring.

    Provide the module (or dotted name of the module) containing the
    tests to be extracted, and the name (within the module) of the object
    with the docstring containing the tests to be extracted.

    The doctest examples are returned as a string containing Python
    code.  The expected output blocks in the examples are converted
    to Python comments.
    """

    module = _normalize_module(module)
    tests = _find_tests(module, "")
    test = [doc for (tname, doc, dummy, dummy) in tests
                if tname == name]
    if not test:
        raise ValueError(name, "not found in tests")
    test = test[0]
    examples = [source + _expect(expect)
                for source, expect, dummy in _extract_examples(test)]
    return '\n'.join(examples)
</t>
<t tx="ekr.20040710140534.36">def debug(module, name):
    """Debug a single docstring containing doctests.

    Provide the module (or dotted name of the module) containing the
    docstring to be debugged, and the name (within the module) of the
    object with the docstring to be debugged.

    The doctest examples are extracted (see function testsource()),
    and written to a temp file.  The Python debugger (pdb) is then
    invoked on that file.
    """

    import os
    import pdb
    import tempfile

    module = _normalize_module(module)
    testsrc = testsource(module, name)
    srcfilename = tempfile.mktemp("doctestdebug.py")
    f = file(srcfilename, 'w')
    f.write(testsrc)
    f.close()

    globs = {}
    globs.update(module.__dict__)
    try:
        # Note that %r is vital here.  '%s' instead can, e.g., cause
        # backslashes to get treated as metacharacters on Windows.
        pdb.run("execfile(%r)" % srcfilename, globs, globs)
    finally:
        os.remove(srcfilename)
</t>
<t tx="ekr.20040710140534.37">


class _TestClass:
    """
    A pointless class, for sanity-checking of docstring testing.

    Methods:
        square()
        get()

    &gt;&gt;&gt; _TestClass(13).get() + _TestClass(-12).get()
    1
    &gt;&gt;&gt; hex(_TestClass(13).square().get())
    '0xa9'
    """
	@others
</t>
<t tx="ekr.20040710140534.38">def __init__(self, val):
    """val -&gt; _TestClass object with associated value val.

    &gt;&gt;&gt; t = _TestClass(123)
    &gt;&gt;&gt; print t.get()
    123
    """

    self.val = val
</t>
<t tx="ekr.20040710140534.39">def square(self):
    """square() -&gt; square TestClass's associated value

    &gt;&gt;&gt; _TestClass(13).square().get()
    169
    """

    self.val = self.val ** 2
    return self
</t>
<t tx="ekr.20040710140534.40">def get(self):
    """get() -&gt; return TestClass's associated value.

    &gt;&gt;&gt; x = _TestClass(-42)
    &gt;&gt;&gt; print x.get()
    -42
    """

    return self.val
</t>
<t tx="ekr.20040710140534.41">__test__ = {"_TestClass": _TestClass,
            "string": r"""
                      Example of a string object, searched as-is.
                      &gt;&gt;&gt; x = 1; y = 2
                      &gt;&gt;&gt; x + y, x * y
                      (3, 2)
                      """,
            "bool-int equivalence": r"""
                                    In 2.2, boolean expressions displayed
                                    0 or 1.  By default, we still accept
                                    them.  This can be disabled by passing
                                    DONT_ACCEPT_TRUE_FOR_1 to the new
                                    optionflags argument.
                                    &gt;&gt;&gt; 4 == 4
                                    1
                                    &gt;&gt;&gt; 4 == 4
                                    True
                                    &gt;&gt;&gt; 4 &gt; 4
                                    0
                                    &gt;&gt;&gt; 4 &gt; 4
                                    False
                                    """,
           }

def _test():
    import doctest
    return doctest.testmod(doctest)
</t>
<t tx="ekr.20040710141351">import leoGlobals as g
import leoTest
import types

specialDictNames = ('__builtins__','__doc__','__name__','__file__','__module__')

def printDoc(x,s):
    if hasattr(x,"__doc__") and x.__doc__:
        print "%4d %s" % (len(x.__doc__),s)
    else:
        print "%4s %s" % (' ',s)

print '-' * 60
print "%4d %s" % (len(leoTest.__doc__),"leoTest")

if 1:
    for s in leoTest.__dict__:
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) != types.ModuleType:
                printDoc(x,s)
                if type(x) == types.ClassType:
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print ' '*4,
                            printDoc(x2,s2)
else:
    &lt;&lt; print names sorted by type &gt;&gt;</t>
<t tx="ekr.20040710145459">for theType,typeName in (
    (types.ModuleType,"modules"),
    (types.ClassType,"classes"),
    (types.FunctionType,"functions"),
):

    print ; print "%s..." % typeName
    for s in leoTest.__dict__:
        
        if s not in specialDictNames:
            x = getattr(leoTest,s)
            if type(x) == theType:
                printDoc(x,s)
                if theType == types.ClassType:
                    print "\tmethods..."
                    for s2 in x.__dict__:
                        x2 = getattr(x,s2)
                        if s2 not in specialDictNames:
                            print "\t",
                            printDoc(x2,s2)</t>
<t tx="ekr.20040710180851">import leoGlobals as g
import doctest
import unittest
import leoTest
reload(leoTest)
c = g.top()

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
paths = leoTest.findAllAtFileNodes(c)
modules = leoTest.importAllModulesInPathList(paths)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
<t tx="ekr.20040711044029.1">import leoGlobals as g
import leoTest
import glob
reload(leoTest)

c = g.top()

print '-' * 40

if 0:
    print "modules in test.leo..."
    paths = leoTest.findAllAtFileNodes(c)
    modules = leoTest.importAllModulesInPathList(paths)
    for module in modules:
        print module
    
if 1:
    print "modules in leo/src..."
    path = g.os_path_join(g.app.loadDir,"..","src")
    modules = leoTest.importAllModulesInPath(path)
    for module in modules:
        print module
        
if 0:
    directory = g.os_path_join(g.app.loadDir,"..","src")
    glob_path = g.os_path_join(directory,"leo*.py")
    files = glob.glob(glob_path)
    modules = leoTest.importAllModulesInPathList(files)
    for module in modules:
        print module</t>
<t tx="ekr.20040711060313">import leoGlobals as g
import doctest
import unittest
import leoTest
reload(leoTest)
c = g.top()

createUnitTest = True

if createUnitTest:
    suite = unittest.makeSuite(unittest.TestCase)
else:
    suite = None
    
path = g.os_path_join(g.app.loadDir,"..","src")
modules = leoTest.importAllModulesInPath(path)

if createUnitTest:
    suite = leoTest.createUnitTestsFromDoctests(modules)
else:
    for module in modules:
        doctest.testmod(module,verbose=True,report=False)
                            
if suite:
    g.app.scriptDict['suite'] = suite</t>
</tnodes>
</leo_file>
