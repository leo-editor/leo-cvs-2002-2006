<?xml version="1.0" encoding="UTF-8"?>
<leo_file>
<leo_header file_format="2" tnodes="0" max_tnode_index="133" clone_windows="0"/>
<globals body_outline_ratio="0.5">
	<global_window_position top="44" left="274" height="835" width="981"/>
	<global_log_window_position top="0" left="0" height="0" width="0"/>
</globals>
<preferences allow_rich_text="0">
</preferences>
<find_panel_settings>
	<find_string></find_string>
	<change_string></change_string>
</find_panel_settings>
<vnodes>
<v t="T1"><vh>Distribution checklist</vh></v>
<v t="T2"><vh>Distribution scripts</vh></v>
<v t="T3"><vh>Notes</vh>
<v t="T4"><vh>Quote from Alex Martelli</vh></v>
<v t="T5"><vh>Singleton sequences</vh></v>
<v t="T6"><vh>How to get screenshots</vh></v>
</v>
<v t="T7"><vh>Previous tests</vh>
<v t="T8"><vh> Colorizer tests</vh>
<v t="T9"><vh>(colorizing bug)</vh>
<v t="T10"><vh>report</vh></v>
<v t="T11"><vh>@file c:\prog\test\Enroll SerNum.c</vh>
<v t="T12"><vh>&lt;&lt; Defines &gt;&gt;</vh></v>
<v t="T13"><vh>&lt;&lt; Head &gt;&gt;</vh></v>
</v>
</v>
<v t="T14"><vh>(Fixed syntax coloring bugs when language/comments change)</vh>
<v t="T15"><vh>Test</vh></v>
</v>
<v t="T16"><vh>(html syntax coloring)</vh>
<v t="T17"><vh>test</vh></v>
</v>
<v t="T18"><vh>(Incremental Syntax Coloring)</vh>
<v t="T19"><vh> Tests</vh>
<v t="T20"><vh> Long text for tests</vh></v>
<v t="T21"><vh>Dave Hein</vh>
<v t="T22"><vh>Test</vh></v>
</v>
<v t="T23"><vh>Dave Hein2</vh>
<v t="T24"><vh>NewHeadline</vh></v>
</v>
<v t="T25"><vh>Long test</vh></v>
<v t="T26"><vh>problems</vh></v>
</v>
</v>
<v t="T27"><vh>php test</vh></v>
<v t="T28"><vh>tests</vh></v>
<v t="T29"><vh>wiki tests</vh>
<v t="T30"><vh>test 1</vh></v>
<v t="T31"><vh>test 2</vh></v>
<v t="T32"><vh>test 3</vh></v>
</v>
</v>
<v t="T33"><vh>@encoding test</vh>
<v t="T34"><vh>@file c:\prog\test\encodingTest.txt</vh>
<v t="T35"><vh>Umlaut in headline ë</vh></v>
</v>
</v>
<v t="T36"><vh>@file c:\prog\test\tab_test.txt</vh></v>
<v t="T37"><vh>@image Icons/Leoapp.GIF</vh></v>
<v t="T38"><vh>@url file:///C:/prog/test/sortText.leo</vh></v>
<v t="T39"><vh>Actionscript keywords</vh></v>
<v t="T40"><vh>alloc tests</vh></v>
<v t="T41"><vh>Assignment tests</vh></v>
<v t="T42"><vh>clone tests</vh>
<v t="T43" a="C"><vh>A</vh>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
</v>
<v t="T47" a="C"><vh>New root</vh>
<v t="T43" a="C"><vh>A</vh>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
</v>
</v>
<v t="T47" a="C"><vh>New root</vh>
<v t="T43" a="C"><vh>A</vh>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
<v t="T44" a="C"><vh>B</vh>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
<v t="T45" a="C"><vh>C</vh>
<v t="T46"><vh>D</vh></v>
</v>
</v>
</v>
</v>
</v>
<v t="T48"><vh>Copy/Clones test</vh>
<v t="T49" a="C"><vh>a Å</vh>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
</v>
<v t="T49" a="C"><vh>a Å</vh>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
<v t="T50" a="C"><vh>b</vh>
<v t="T51"><vh>c</vh></v>
</v>
</v>
</v>
<v t="T52"><vh>Dialog tests</vh>
<v t="T53"><vh>Test askOk</vh></v>
<v t="T54"><vh>Test aboutLeo</vh></v>
<v t="T55"><vh>Test askLeoID</vh></v>
<v t="T56"><vh>Test askOkCancelNumber</vh></v>
<v t="T57"><vh>Test askOkCancel</vh></v>
<v t="T58"><vh>Test askYesNo</vh></v>
<v t="T59"><vh>Test askYesNoCancel</vh></v>
</v>
<v t="T60"><vh>Go to line number test</vh>
<v t="T61"><vh>@file c:\prog\test\goToLineNumber.txt</vh>
<v t="T62"><vh>__init__</vh></v>
<v t="T63"><vh>__init__</vh></v>
</v>
</v>
<v t="T64"><vh>Icon bar</vh>
<v t="T65"><vh>add some buttons</vh></v>
<v t="T66"><vh>add all gif files</vh></v>
<v t="T67"><vh>clear</vh></v>
<v t="T68"><vh>hide</vh></v>
<v t="T69"><vh>configure</vh></v>
<v t="T70"><vh>show (puts at bottom)</vh></v>
</v>
<v t="T71"><vh>Ignore</vh>
<v t="T72"><vh>@lineending and @encoding tests</vh></v>
<v t="T73"><vh>@file test.py</vh>
<v t="T74"><vh>Outer</vh>
<v t="T75"><vh>A2</vh></v>
<v t="T76"><vh>B</vh></v>
</v>
</v>
<v t="T77"><vh>Check clones links</vh></v>
</v>
<v t="T78"><vh>Leo Unit Tests</vh></v>
<v t="T79"><vh>Line break problems</vh>
<v t="T80"><vh>Error</vh>
<v t="T81"><vh>@nosentinelsfile c:\prog\test\lineBreakError.txt</vh>
<v t="T82"><vh>functions</vh>
<v t="T83"><vh>objects</vh>
<v t="T84" a="M"><vh>class shape</vh>
<v t="T85"><vh>&lt;&lt; class shape declarations &gt;&gt;</vh></v>
</v>
</v>
</v>
</v>
</v>
</v>
<v t="T86"><vh>New import</vh></v>
<v t="T87"><vh>Overriding core classes</vh></v>
<v t="T88"><vh>Read @file nodes</vh>
<v t="T89"><vh>@file c:\prog\test\atFileTest.txt</vh>
<v t="T90"><vh>Node 1</vh></v>
</v>
</v>
<v t="T91"><vh>Rebol keywords (- ? ~ ! recognized as a part of a keyword)</vh></v>
<v t="T92"><vh>reformatParagraph test</vh></v>
<v t="T93"><vh>Spell test </vh>
<v t="T94"><vh>node two</vh></v>
<v t="T95"><vh>node two no misspellings</vh></v>
</v>
<v t="T96"><vh>Status line</vh>
<v t="T97"><vh>put message</vh></v>
<v t="T98"><vh>clear</vh></v>
<v t="T99"><vh>tab width tests</vh>
<v t="T100"><vh>2</vh></v>
<v t="T101"><vh>4</vh></v>
<v t="T102"><vh>6</vh></v>
<v t="T103"><vh>8</vh></v>
</v>
</v>
<v t="T104"><vh>Test of recent sections &amp; clones</vh>
<v t="T105" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T106" a="C"><vh>hyper link test</vh>
<v t="T105" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T107"><vh>&lt;&lt; section b &gt;&gt;</vh></v>
</v>
<v t="T106" a="C"><vh>hyper link test</vh>
<v t="T105" a="C"><vh>&lt;&lt; section a &gt;&gt;</vh></v>
<v t="T107"><vh>&lt;&lt; section b &gt;&gt;</vh></v>
</v>
</v>
<v t="T108"><vh>timeit (in 2.3b1)</vh></v>
<v t="T109"><vh>Trailing newline in body</vh></v>
<v t="T110"><vh>Undo replace tests</vh>
<v t="T111" a="CE"><vh>B</vh>
<v t="T112"><vh>C</vh></v>
<v t="T113"><vh>C2</vh></v>
</v>
<v t="T114" a="CE"><vh>A</vh>
<v t="T111" a="CE"><vh>B</vh>
<v t="T112"><vh>C</vh></v>
<v t="T113"><vh>C2</vh></v>
</v>
</v>
<v t="T114" a="CE"><vh>A</vh>
<v t="T111" a="CE"><vh>B</vh>
<v t="T112"><vh>C</vh></v>
<v t="T113"><vh>C2</vh></v>
</v>
</v>
</v>
<v t="T115"><vh>Undo typing tests</vh></v>
<v t="T116"><vh>Use xml.sax</vh></v>
<v t="T117"><vh>v.__repr__ and v.__str___</vh></v>
<v t="T118"><vh>Write Missing @file nodes test</vh>
<v t="T119"><vh>@file ../test/missing_test.txt</vh></v>
</v>
<v t="T120"><vh>wx Leo</vh></v>
</v>
<v t="T121"><vh>wrap test</vh>
<v t="T122" a="E"><vh>@file c:\prog\test\wrap_test.txt</vh>
<v t="T123"><vh>wrap node</vh></v>
<v t="T124"><vh>nowrap node</vh></v>
</v>
</v>
<v t="T125"><vh>@file c:\prog\test\docTest.txt</vh></v>
<v t="T126" a="E"><vh>Test file</vh>
<v t="T127" a="C"><vh>&lt;&lt; ref &gt;&gt; (this should remained cloned)</vh></v>
<v t="T128" a="EV"><vh>@file c:\prog\test\gnxText.txt</vh>
<v t="T127" a="C"><vh>&lt;&lt; ref &gt;&gt; (this should remained cloned)</vh></v>
<v t="T129"><vh>&lt;&lt; ref2 &gt;&gt;</vh></v>
<v t="T130" a="E"><vh>Organizer node</vh>
<v t="T131"><vh>node 1</vh></v>
<v t="T132"><vh>empty node</vh></v>
</v>
<v t="T133"><vh>Node 2</vh></v>
</v>
</v>
</vnodes>
<tnodes>
<t tx="T1">@color

# **** Run this from test.leo ****

# Run pychecker from idle.
if 1:
	import pychecker.checker
	import leo
@nocolor
Documentation
	- Update readme.txt
	- Update LeoDocs.leo
	- Update web site.
Version numbers
	- Update version number in Help menu.
	- Update version number in setup.py (@ignore'd!!)
@color

if 1: # Save all files and tangle leoConfig.leo
	from leoGlobals import importFromPath
	preSetup = importFromPath("preSetup","c:\prog\leoCvs\leo")
	preSetup.setup()

if 1: # Replace config settings and create .zip file.
	import os
	os.system(r"c:\python22\python c:\prog\leoCvs\leo\setup.py sdist --formats=zip")

@nocolor
Create and test leosetup.exe.
	- Create leosetup.exe by right-clicking leo.nsi and choosing "compile with NSI (bz2)"
	- Test created leosetup.exe file.
	- test the files created in c:\program files\leo
Create Release on SourceForge
Uploads
    - Upload leodocs.zip
	- Upload leosetup.exe
	- Upload leo-x-y.zip
	- Upload sbook.chm if it has been changed.
Announcements
	- Announce to SourceForge itself. USE ANNOUNCEMENT FORMAT, not readme format.
	- Announce to Leo's SourceForce site.
	- Announce to comp.lang.python
	- Announce to comp.programming.literate</t>
<t tx="T2">@color

# These scripts are now intended to be run only from here.

if 1: # Save all files and tangle leoConfig.leo
	from leoGlobals import importFromPath
	preSetup = importFromPath("preSetup","c:\prog\leoCvs\leo")
	preSetup.setup()

if 1: # Replace config settings and create .zip file.
	import os
	os.system(r"c:\python22\python c:\prog\leoCvs\leo\setup.py sdist --formats=zip")</t>
<t tx="T3"></t>
<t tx="T4">@nocolor

Personally, I nominate timeit.py as THE outstanding enhancement of Python 2.3
-- I love many of the others (the performance improvement in particular), but
timeit.py is the one I find myself using all of the time -- seems to provide an
innocuous way for programmers' typical obsession with performance and
micro-optimization to discharge itself harmlessly, cleansing their souls to
choose idioms on the basis of clarity, maintainability and readability, as of
course SHOULD be done :-)</t>
<t tx="T5"># Empty tuples are constructed by an empty pair of parentheses.
# tuple with one item is constructed by following a value with a comma.
# Examples:

# empty = ()
# singleton = 'hello',    # &lt;-- note trailing comma

s = "abc",

for i in s:
	print `i`
	
s = {"x":1, "y":2},

for i in s:
	print `i`</t>
<t tx="T6">import ImageGrab,os # requires PIL 1.1.3 or later

path = os.path.join(app().loadDir,"../","test","screenshot.gif")

ImageGrab.grab().save(path)
</t>
<t tx="T7">@ignore</t>
<t tx="T8"></t>
<t tx="T9"></t>
<t tx="T10">@nocolor

Read and respond to this message at: 
http://sourceforge.net/forum/message.php?msg_id=1719215
By: nobody

Ok, it seems to be in the code I copied in. I tried it with a second Node, and
don't have the trouble.

Console Mode gives the following:

Traceback (most recent call last):
File "d:\language\literate programming\Leo\leoColor.py", line 830,
in colorizeAnyLanguage
    i,state = func(s,i,n)

File "d:\language\literate programming\Leo\leoColor.py", line 934,
in continueBlockComment
    j = string.find(s,self.block_comment_end,i)

File "D:\LANGUAGE\PYTHON\lib\string.py", line 174, in find
    return s.find(*args)

TypeError: expected a character buffer object

The line, "#define WIPEOUT 0 /* " seems to be the problem child -- if I move
the start-of-comment marker to the next line, the error message goes away; however,
the lines between the '/*' and '*/' are NOT comment-colored...

--Rich
</t>
<t tx="T11">@language c
@comment /* */
@path .
@ignore

&lt;&lt; Defines &gt;&gt;
&lt;&lt; Head &gt;&gt;</t>
<t tx="T12">@
@c

#define WIPEOUT 0 /* 
                   * Causes database card number &amp; flags to be set to zero. 
                   * This is so I don't need an infinite supply of cards!
                   */
// Not colored (because of @language /* */)
#include "equ.h"
#include "cmn.h"
#include "ramdef.h"
#include "eeprom.h"
#include &lt;hpc_ram.h&gt;
#include &lt;rlydef.h&gt;</t>
<t tx="T13"></t>
<t tx="T14">@ Enabling or disabling @language or @comment now recolors entire text.</t>
<t tx="T15">@language c
 @comment /* */

/* comment */
# test</t>
<t tx="T16">@language html
@
To do:

done: use self.tag routine everywhere.
done: convert index to be a method.
done: create self.line_index ivar.  Use it in self.index().
done: remove n param from most routines, especially calls to self.add_tag!
done: complete test of syntax coloring.

- add @language html when importing html file.
</t>
<t tx="T17">@color
@ignore
&lt;HTML&gt;
&lt;!-- Author: Edward K. Ream, edream@tds.net --&gt;
&lt;HEAD&gt;
  &lt;META NAME="GENERATOR" CONTENT="Microsoft FrontPage 4.0"&gt;
  &lt;TITLE&gt; Leo's Home Page &lt;/TITLE&gt;
  &lt;META NAME="description" CONTENT="This page describes Leo.
Leo adds powerful outlines to the noweb and CWEB literate programming languages."&gt;
  &lt;META NAME="keywords" CONTENT="LEO, LITERATE PROGRAMMING, OUTLINES, CWEB,
NOWEB, OUTLINES, EDWARD K. REAM, DONALD E. KNUTH, SILVIO LEVY, OPEN SOFTWARE"&gt;
&lt;/HEAD&gt;
&lt;!-- Last Modified: May 12, 2002 --&gt;
&lt;BODY BGCOLOR="#fffbdc"&gt;

&lt;H1 ALIGN=CENTER&gt;&lt;a NAME="top"&gt;&lt;/a&gt;&lt;IMG SRC="Blank.gif" width=
"32" height="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;IMG SRC="leo.gif" 
WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;a href="leo_TOC.html#top"&gt;&lt;IMG SRC=
"arrow_rt.gif" WIDTH="32" HEIGHT="32" ALIGN="BOTTOM" NATURALSIZEFLAG="3"&gt;&lt;/a&gt; &amp;nbsp;&lt;/H1&gt;

&lt;H1 ALIGN=CENTER&gt; Leo's Home Page&lt;/H1&gt;

&lt;p align="center"&gt;&lt;a href="http://www.python.org/"&gt;&lt;img border="0" src="PythonPowered.gif" width="110" height="44"&gt; &lt;/a&gt; &lt;A HREF="http://sourceforge.net/"&gt;&lt;IMG SRC="http://sourceforge.net/sflogo.php?group_id=3458&amp;type=1" NATURALSIZEFLAG="0" ALT="SourceForge Logo"&gt;&lt;/A&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;
&lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo at SourceForge&lt;/A&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoCodeGray.gif" width="77" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;
&lt;a href="icons.html"&gt;&lt;img border="0" src="LeoProse.gif" width="81" height="42"&gt;&lt;/a&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;

&lt;H3&gt;&lt;A NAME="anchor127554"&gt;&lt;/A&gt;Summary&lt;/H3&gt;

&lt;UL&gt;
  &lt;LI&gt;Leo is a &lt;i&gt; programmer's editor&lt;/i&gt;  and a flexible &lt;i&gt;browser&lt;/i&gt; for
    projects, programs, classes or data. Leo clarifies design, coding, debugging, testing
  and maintenance.
  &lt;LI&gt;Leo is an &lt;i&gt;outlining editor&lt;/i&gt;. Outlines clarify the big picture while
    providing unlimited space for details.
  &lt;LI&gt;Leo
    is a &lt;a HREF="http://www.literateprogramming.com/"&gt;&lt;i&gt;literate
    programming&lt;/i&gt;&lt;/a&gt; tool, compatible with &lt;A HREF="http://www.eecs.harvard.edu/~nr/noweb/"&gt;noweb&lt;/A&gt;
    and &lt;a HREF="http://www-cs-faculty.stanford.edu/~knuth/cweb.html"&gt;CWEB&lt;/a&gt;.
    Leo enhances any text-based
programming language, from assembly language and C to Java, Python and XML.
  &lt;LI&gt;Leo is also a &lt;i&gt;data organizer&lt;/i&gt;. A single Leo outline can generate complex
    data spanning many different files.&amp;nbsp; Leo has been used to manage web sites.
  &lt;LI&gt;Leo is a &lt;i&gt; project manager&lt;/i&gt;. Leo provides multiple views
of a project within a single outline. Leo naturally represents tasks that remain
    up-to-date.
  &lt;LI&gt;Leo is fully &lt;i&gt; scriptable&lt;/i&gt; using &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
  and saves its files in &lt;A HREF="http://www.w3.org/XML/"&gt;XML&lt;/A&gt; format.
  &lt;LI&gt;Leo is &lt;i&gt;portable&lt;/i&gt;.&amp;nbsp; Leo.py is 100% pure Python and will run on
    any platform supporting &lt;A HREF="http://www.python.org/"&gt;Python&lt;/A&gt;
    and &lt;a href="http://tcl.activestate.com/"&gt;Tk/tcl&lt;/a&gt;, including Windows,
    Linux and MacOS X.&amp;nbsp; Leo.exe runs on any Windows platform.
  &lt;LI&gt;Leo is &lt;a href="http://www.opensource.org/"&gt; &lt;i&gt; Open Software&lt;/i&gt;&lt;/a&gt;, distributed under
    the &lt;a href="http://www.python.org/doc/Copyright.html"&gt; Python License&lt;/a&gt;.
&lt;/UL&gt;

&lt;H3&gt;More Information and downloads&lt;/H3&gt;

&lt;ul&gt;
  &lt;LI&gt;An excellent &lt;a href="http://www.3dtree.com/ev/e/sbooks/leo/sbframetoc_ie.htm"&gt;online
    tutorial&lt;/a&gt; and &lt;A HREF="http://www.jserv.com/jk_orr/xml/leo.htm"&gt;Leo resource
  page&lt;/A&gt;, both written by &lt;a href="http://www.jserv.com/jk_orr"&gt;Joe Orr&lt;/a&gt;.
  &lt;LI&gt;My brother's &lt;a href="SpeedReam.html"&gt;slashdot
    article about Leo&lt;/a&gt;, the best description about why Leo is special.
  &lt;LI&gt;&lt;A HREF="testimonials.html#anchor104391"&gt;What people are saying about Leo&lt;/A&gt;
  &lt;LI&gt;&lt;A HREF="leo_TOC.html#anchor964914"&gt;Complete users guide&lt;/A&gt;
    and
    &lt;A HREF="intro.html#anchor887874"&gt;tutorial introduction&lt;/A&gt;  with
  screen shots.
  &lt;li&gt;&lt;a href="FAQ.html"&gt;FAQ&lt;/a&gt; and &lt;a href="http://sourceforge.net/forum/?group_id=3458"&gt;help and discussion
    forums&lt;/a&gt;, preferable to &lt;A HREF="mailto:edream@tds.net"&gt;email&lt;/A&gt; so others may join
    in.&lt;/li&gt;
  &lt;li&gt;&lt;a href="icons.html"&gt;Icons&lt;/a&gt; for bragging about Leo.&lt;/li&gt;
&lt;/ul&gt;

&lt;a href="http://sourceforge.net/project/showfiles.php?group_id=3458"&gt;Download
    Leo&lt;/a&gt; from &lt;A HREF="http://sourceforge.net/project/?group_id=3458"&gt;Leo's SourceForge
site&lt;/A&gt;.

&lt;P ALIGN=left&gt;Leo's author is &lt;A HREF="http://personalpages.tds.net/~edream/index.html"&gt;Edward
  K. Ream&lt;/A&gt; email: &lt;A HREF="mailto:edream@tds.net"&gt;edream@tds.net&lt;/A&gt; voice: (608) 231-0766

&lt;HR ALIGN=LEFT&gt;

&lt;p align="center"&gt;

&lt;IMG SRC="Blank.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="34" height="34"&gt;&lt;IMG SRC="leo.gif" ALIGN="left" NATURALSIZEFLAG=
"3" width="32" height="32"&gt;&lt;a HREF="leo_TOC.html"&gt;&lt;IMG SRC="arrow_rt.gif" WIDTH="32"
HEIGHT="32" ALIGN="left" NATURALSIZEFLAG="3"&gt;

&lt;/BODY&gt;
&lt;/HTML&gt;
</t>
<t tx="T18">@ignore

@

We need both incremental and full syntax coloring...

We must do a _full_ recoloring when selecting any node, even for two cloned nodes, because the nodes may have different contexts.

Furthermore, at present undo must always do a full recoloring because setBodyStringOrPane just replaces the old text with the new, and that destroys all the coloring tags.  The only possible solution would be to do an "incremental update" in setBodyStringOrPane.  It would also be good to do that in tree.select.

The present code _is_ faster than the old code because it avoids redundant drawing.</t>
<t tx="T19"></t>
<t tx="T20"># This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)
        # Copy the headline and icon values v.copyNode(root,v)
        # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result
    
# This creates a free-floating copy of v's tree for undo.
# The copied trees must use different tnodes than the original.

def copyTree(self,root):

    c = self
    # Create the root vnode.
    result = v = leoNodes.vnode(c,root.t)

	# Copy the headline and icon values
    v.copyNode(root,v)
    # Copy the rest of tree.
        v.copyTree(root,v)
    # Replace all tnodes in v by copies.
    assert(v.nodeAfterTree() == None)
    while v:
        v.t = leoNodes.tnode(0, v.t.bodyString)
        v = v.threadNext()
    return result</t>
<t tx="T21">@language c</t>
<t tx="T22">@
This is just a test
@c
aprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

"/* testing */"
@#
bprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
cprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
dprocedure(
	a,
	b )
	{
	printf( "Hello, world\n" );
	return 0;
}

@#
int main()
{
  return 0
}</t>
<t tx="T23">Here's another issue

Create a @file node[snip]

You should see the &lt;!-- test --&gt; in 'red' (comment color).

Now backspace over 'html' in the language directive and type 'xml'.  

The bug is that XML is not a valid Leo language but the comment is still 'red'.
If you go to another node and come back it changes back to black type.  Now
change the language back to 'html'.  It doesn't recolorize and the comment remains
black.

This is a nit, really.
</t>
<t tx="T24">@language html
&lt;? xml version="1.0"&gt;
&lt;!-- test --&gt;
&lt;project name="Converter" default="dist"&gt;
&lt;/project&gt;</t>
<t tx="T25">def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:		
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()
def colorizeAnyLanguage (self,v,body,language,flag):
	
	try:
		self.incremental = 1
		&lt;&lt; initialize ivars &amp; tags &gt;&gt;
		if self.incremental:
			&lt;&lt; incrementally color the text &gt;&gt;
		else:
			self.removeAllTags()
			n = 1 # The Tk line number for indices, as in n.i
			for s in lines:
				state = self.colorizeLine(s,n,state)
				n += 1		
	except:
		es_exception()


</t>
<t tx="T26">"""python
string"""d

'this\
is</t>
<t tx="T27">@language php
@ doc
@c

and or
array
array()
this is a test.
__CLASS__
&lt;?php and or array() ?&gt;
</t>
<t tx="T28">@ignore
@ doc
@c
@language c
	@others

abc
for # comment
# pp
@q comment @&gt; after
// comment
&lt;!-- comment --&gt; after
/* java comment */
{ pascal comment }
% latex comment
xor php keyword
fblocked tcl keyword
synchronized java keyword
\acute latex keyword
alarm perl keyword

# Python single-line comment
// C single-line comment
xx /* C block comment */ yy
xxx """ triple string """ zzz
a 'string' b
c "string" d
// C keywords
switch, case
</t>
<t tx="T29">@markup wiki</t>
<t tx="T30">@language python

""" {picture file=../Icons/Leoapp.GIF}this """ # Problems with correct indexing following a graphic.

""" {picture file=../Icons/Leoapp.GIF}this """ # two copies work.

abc

""" {picture file=../Icons/Leodoc.GIF} """ # xyz


""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

# Test

""" ''' """ ''' """'''  # Leo handles the common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ff00ff:some text~~more text""

and if

from leoGlobals import * ; print app().loadDir</t>
<t tx="T31">""" continued
string"""

@ ''ab'' __xxx__ ''wx'' __xyz__  __''bolditalic''__ and ''__italicbold__''
@c

# /* ''ab'' __xxx__ ''wx'' __xyz__ */

__abc__ 

# Test

""" ''' """ ''' """'''  # Leo handles the __b__ common cases correctly.

''' ''ab'' __xxx__ ''wx'' __xyz__ ''' # No wiki markup in ''' strings.

""" ''ab'' __xxx__ ''wx'' __xyz__ """

# ''ab'' __xxx__ ''wx'' __xyz__

""" ''y'' """

""" text~~#ee00ff:some text~~more text"""



and if

from leoGlobals import * ; print app().loadDir
</t>
<t tx="T32">""" text~~red:some text~~more text"""

""" text~~#ee0ff:some text~~more text"""</t>
<t tx="T33">@encoding iso-8859-1</t>
<t tx="T34">@others

This is an umlaute ë</t>
<t tx="T35"></t>
<t tx="T36">----*---*---*---*---*---*
	.	.	.	.	.	
                        
.   ..  ... ....    .   
        .   ..</t>
<t tx="T37"></t>
<t tx="T38"></t>
<t tx="T39">@language actionscript

break
call, continue
delete, do
else
false, for, function
goto
if, in
new, null
return
true, typeof
undefined
var, void, while, with
#include
catch, constructor
prototype
this, try
_parent, _root, __proto__
// Jeeze hasn't anyone ever heard of namespaces??
ASnative, abs, acos, appendChild, asfunction, asin, atan, atan2, attachMovie, attachSound, attributes
BACKSPACE
CAPSLOCK, CONTROL, ceil, charAt, charCodeAt, childNodes, chr, cloneNode, close, concat, connect, cos, createElement, createTextNode
DELETEKEY, DOWN, docTypeDecl, duplicateMovieClip
END, ENTER, ESCAPE, enterFrame, entry, equal, eval, evaluate, exp
firstChild, floor, fromCharCode, fscommand, getAscii
getBeginIndex, getBounds, getBytesLoaded, getBytesTotal, getCaretIndex, getCode, getDate, getDay, getEndIndex, getFocus, getFullYear, getHours, getMilliseconds, getMinutes, getMonth, getPan, getProperty, getRGB, getSeconds, getTime, getTimer, getTimezoneOffset, getTransform, getURL, getUTCDate, getUTCDay, getUTCFullYear, getUTCHours, getUTCMilliseconds, getUTCMinutes, getUTCMonth, getUTCSeconds, getVersion, getVolume, getYear, globalToLocal, gotoAndPlay, gotoAndStop
HOME, haschildNodes, hide, hitTest
INSERT, Infinity, ifFrameLoaded, ignoreWhite, indexOf, insertBefore, int, isDown, isFinite, isNaN, isToggled
join
keycode, keyDown, keyUp
LEFT, LN10, LN2, LOG10E, LOG2E, lastChild, lastIndexOf, length, load, loaded, loadMovie, loadMovieNum, loadVariables, loadVariablesNum, localToGlobal, log
MAX_VALUE, MIN_VALUE, max, maxscroll, mbchr, mblength, mbord, mbsubstring, min, 
NEGATIVE_INFINITY, NaN, newline, nextFrame, nextScene, nextSibling, nodeName, nodeType, nodeValue
on, onClipEvent, onClose, onConnect, onData, onLoad, onXML, ord
PGDN, PGUP, PI, POSITIVE_INFINITY, parentNode, parseFloat, parseInt, parseXML, play, pop, pow, press, prevFrame, previousSibling, prevScene, print, printAsBitmap, printAsBitmapNum, printNum, push
RIGHT, random, release, removeMovieClip, removeNode, reverse, round
SPACE, SQRT1_2, SQRT2, scroll, send, sendAndLoad, set, setDate, setFocus, setFullYear, setHours, setMilliseconds, setMinutes, setMonth, setPan, setProperty, setRGB, setSeconds, setSelection, setTime, setTransform, setUTCDate, setUTCFullYear, setUTCHours, setUTCMilliseconds, setUTCMinutes, setUTCMonth, setUTCSeconds, setVolume, setYear, shift, show, sin, slice, sort, start, startDrag, status, stop, stopAllSounds, stopDrag, substr, substring, swapDepths, splice, split, sqrt
TAB, tan, targetPath, tellTarget, toggleHighQuality, toLowerCase, toString, toUpperCase, trace
UP, UTC, unescape, unloadMovie, unLoadMovieNum, unshift, updateAfterEvent
valueOf
xmlDecl, _alpha
_currentframe
_droptarget
_focusrect, _framesloaded
_height, _highquality
_name
_quality
_rotation
_soundbuftime
_target, _totalframes
_url
_visible
_width
_x, _xmouse, _xscale
_y, _ymouse, _yscale
and, add, eq, ge, gt, le, lt, ne, not, or, Array, Boolean, Color, Date, Key, Math, MovieClip, Mouse, Number, Object, Selection, Sound, String, XML, XMLSocket</t>
<t tx="T40">import gc,Tkinter

# gc.set_debug(gc.DEBUG_STATS)

lastObjectCount = 0

def printGarbage(s):
	global lastObjectCount
	n  = len(gc.garbage)
	n2 = len(gc.get_objects())
	fmt = "%8s garbage: %d, objects:%+6d =%6d"
	print fmt % (s,n,n2-lastObjectCount,n2)
	lastObjectCount = n2

gc.collect()
printGarbage("start 1")
# Create a canvas widget for experimentation.
top = Tkinter.Tk()
frame = Tkinter.Frame(top) ; frame.pack()
canvas = Tkinter.Canvas(frame) ; canvas.pack()
# Allocate and (try to) deallocate widgets in the canvas.
x,y = 10,10
printGarbage("start 2")
for i in xrange(5):
	t = Tkinter.Text(canvas)
	canvas.create_window(x,y,window=t)
	y += 40
	printGarbage(" loop 1")
	t.destroy()
	canvas.delete("all")
	gc.collect() # Nuts...
	printGarbage(" loop 2")
# See when objects are really freed.
top.destroy()
printGarbage("end 1") # Huh ???
gc.collect()
printGarbage("end 2")
top = frame = canvas = None
gc.collect()
printGarbage("end 3")</t>
<t tx="T41"># The output of this is 5 5 6
# This shows that o2 is merely an alias for o.

class obj:
	def __init__(self,n):
		self.n = n

o = obj(5) ; print o.n,
o2  = o    ; print o2.n,
o.n = 6    ; print o2.n</t>
<t tx="T42"># The following corrupts the outline: extract section (in B), undo.
</t>
<t tx="T43"></t>
<t tx="T44"># The following used to corrupt the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
line 2

after
</t>
<t tx="T45"></t>
<t tx="T46"></t>
<t tx="T47"></t>
<t tx="T48"></t>
<t tx="T49"></t>
<t tx="T50"></t>
<t tx="T51"></t>
<t tx="T52"></t>
<t tx="T53">from leoGlobals import *
import leoDialog

if 1: # passed
	print leoDialog.askOk(
		"My Test Dialog",
		"Please hit return to test this dialog.",
		text="whoopee",
		resizeable=false).run(modal=true)
	
if 1: # passed
	message = "leo.py requires Python 2.1 or higher"
	print leoDialog.askOk("Python version error",message=message,text="Exit").run(modal=true)
	
if 1: # passed
	fileName = "xyzzy"
	print leoDialog.askOk("Read-only ouline",
		"Warning: the outline: " + fileName + " is read-only.").run(modal=true)</t>
<t tx="T54">from leoGlobals import *
import leoDialog

ver = "version 3.14159 "
build = "-3.8" 
version = "leo.py 4.0 alpha 2, Build " + build + ", June 13, 2003\n\n"
copyright = (
	"Copyright 1999-2003 by Edward K. Ream\n" +
	"All Rights Reserved\n" +
	"Leo is distributed under the Python License")
url = "http://webpages.charter.net/edreamleo/front.html"
email = "edreamleo@charter.net"

leoDialog.aboutLeo(version,copyright,url,email).run(modal=false)</t>
<t tx="T55">import leoDialog

print leoDialog.askLeoID().run(modal=1)</t>
<t tx="T56">import leoDialog

print leoDialog.askOkCancelNumber("Enter Line Number","Line number:").run(modal=1)
</t>
<t tx="T57">import leoDialog

print leoDialog.askOkCancel("Proceed?",
	"Read @file Nodes is not undoable.\nProceed?").run(modal=1)</t>
<t tx="T58">import leoDialog

if 1: # passed
	message = "Replace changed outline with external changes?"
	print leoDialog.askYesNo("Conflict!",message).run(modal=1)
	
if 1: # passed
	print leoDialog.askYesNo("Revert",
		"Revert to previous version of xyzzy?").run(modal=1)
		
if 1: # passed
	print leoDialog.askYesNo(
		"Download Tutorial?",
		"Download tutorial (sbooks.chm) from SourceForge?").run(modal=1)</t>
<t tx="T59">import leoDialog

if 1: # passed
	print leoDialog.askYesNoCancel("Confirm",
		'Save changes to xyzzy before crashing?').run(modal=1)
		
if 1: # passed
	message = (
		"Conflicting changes in outline and temp file\n\n" +
		"Do you want to use the code in the outline or the temp file?\n\n")
	
	print leoDialog.askYesNoCancel(
		"Conflict!", message,
		yesMessage = "Outline",
		noMessage = "File",
		defaultButton = "Cancel").run(modal=1)</t>
<t tx="T60"></t>
<t tx="T61">@others</t>
<t tx="T62">def __init__ (self):
	
	pass # line 9</t>
<t tx="T63">def __init__ (self):
	
	pass # line 16</t>
<t tx="T64"></t>
<t tx="T65">from leoGlobals import *

top().frame.addIconButton(imagefile="../Icons/Leoapp.gif")

top().frame.addIconButton(text="hi")

top().frame.addIconButton(imagefile="../Icons/Leodoc.gif")</t>
<t tx="T66">from leoGlobals import *
import glob,os

f = top().frame

pattern = "c:/prog/leoCVS/leo/Icons/*.gif"
files = glob.glob(pattern)
files.sort()

f.clearIconBar()
for file in files:
	f.addIconButton(imagefile=file,bg="lightBlue")</t>
<t tx="T67">from leoGlobals import *

top().frame.clearIconBar()</t>
<t tx="T68">from leoGlobals import *

top().frame.hideIconBar()</t>
<t tx="T69">from leoGlobals import *

top().frame.iconFrame.configure(height="15m")</t>
<t tx="T70">from leoGlobals import *

top().frame.showIconBar()</t>
<t tx="T71">@ignore</t>
<t tx="T72">@lineending nl         (the default, Linux)
@lineending cr         (Mac)
@lineending crlf       (Windows)
@lineending lf          (same as nl, not recommended)
@lineending platform (same as platform value for output_newline setting in leoConfig.txt)

@encoding utf-8</t>
<t tx="T73"># Test file for cut/paste operations.

@others</t>
<t tx="T74"></t>
<t tx="T75">node A Text</t>
<t tx="T76">node B text</t>
<t tx="T77">from leoGlobals import *

checkClones2Links(verbose=true)</t>
<t tx="T78">import unittest
import leoTest
reload(leoTest)

colorSuite = unittest.makeSuite(leoTest.colorTests)

if 1:
	suite = colorSuite
else:
	suite = unittest.TestSuite()
	suite.addTest(leoTest.colorTests("testC"))
	# suite.addTest(leoTest.colorSuite)

runner = unittest.TextTestRunner()
runner.run(suite)</t>
<t tx="T79"></t>
<t tx="T80">@ EKR: the doc string in class shape is improperly indented.
@c

@language Python
@tabwidth -4</t>
<t tx="T81">@first #!/usr/bin/python

@others
</t>
<t tx="T82">@others
</t>
<t tx="T83">@others
</t>
<t tx="T84">class shape(object):
  	&lt;&lt; class shape declarations &gt;&gt;
  	# after decls</t>
<t tx="T85">"""Parent class of all shapes."""
pass
</t>
<t tx="T86"># This shows that Python programs _could_ use .xpy files (xml files containing Leo/Python code).

from leoGlobals import *
import imp
import sys

old_import = __import__ # Get the global function

def leo_import(name,old_import,globals=None, locals=None, fromlist=None):
	try:
		mod = sys.modules.get(name)
		if mod:
			es("Leo import: module exists: " + name, color="blue")
		else:
			mod = old_import(name,globals,locals,fromlist)
			es("Leo import: " + name,color="blue")
	except ImportError:
		es("Leo import: not found: " + name,color="blue")
		mod = None
	return mod
		
m = leo_import("leoTest",__import__)
es(m,color="red")</t>
<t tx="T87">import leoFrame
print "%d leoFrame instances" % leoFrame.LeoFrame.instances</t>
<t tx="T88">@ignore</t>
<t tx="T89">@nocolor
This is a test file
@others</t>
<t tx="T90">Node one text.  changed 2.</t>
<t tx="T91">@language rebol

; a comment
about abs absolute add alert alias all alter and and~ any append arccosine arcsine arctangent array ask at  
back bind boot-prefs break browse build-port build-tag  
call caret-to-offset catch center-face change change-dir charset checksum choose clean-path clear clear-fields close comment complement compose compress confirm continue-post context copy cosine create-request crypt cvs-date cvs-version  
debase decode-cgi decode-url decompress deflag-face dehex delete demo desktop detab dh-compute-key dh-generate-key dh-make-key difference dirize disarm dispatch divide do do-boot do-events do-face do-face-alt does dsa-generate-key dsa-make-key dsa-make-signature dsa-verify-signature  
echo editor either else emailer enbase entab exclude exit exp extract 
fifth find find-key-face find-window flag-face first flash focus for forall foreach forever form forskip fourth free func function  
get get-modes get-net-info get-style  
halt has head help hide hide-popup  
if import-email in inform input insert insert-event-func intersect 
join 
last launch launch-thru layout license list-dir load load-image load-prefs load-thru log-10 log-2 log-e loop lowercase  
make make-dir make-face max maximum maximum-of min minimum minimum-of mold multiply  
negate net-error next not now  
offset-to-caret open open-events or or~ 
parse parse-email-addrs parse-header parse-header-date parse-xml path-thru pick poke power prin print probe protect protect-system  
q query quit  
random read read-io read-net read-thru reboot recycle reduce reform rejoin remainder remold remove remove-event-func rename repeat repend replace request request-color request-date request-download request-file request-list request-pass request-text resend return reverse rsa-encrypt rsa-generate-key rsa-make-key 
save save-prefs save-user scroll-para second secure select send send-and-check set set-modes set-font set-net set-para set-style set-user set-user-name show show-popup sine size-text skip sort source split-path square-root stylize subtract switch  
tail tangent textinfo third throw throw-on-error to to-binary to-bitset to-block to-char to-date to-decimal to-email to-event to-file to-get-word to-hash to-hex to-idate to-image to-integer to-issue to-list to-lit-path to-lit-word to-local-file to-logic to-money to-none to-pair to-paren to-path to-rebol-file to-refinement to-set-path to-set-word to-string to-tag to-time to-tuple to-url to-word trace trim try  
unfocus union unique uninstall unprotect unset until unview update upgrade uppercase usage use  
vbug view view-install view-prefs  
wait what what-dir while write write-io  
xor xor~  
action! any-block! any-function! any-string! any-type! any-word!  
binary! bitset! block!  
char!  
datatype! date! decimal! 
email! error! event!  
file! function!  
get-word!  
hash!  
image! integer! issue!  
library! list! lit-path! lit-word! logic!  
money!  
native! none! number!  
object! op!  
pair! paren! path! port!  
refinement! routine!  
series! set-path! set-word! string! struct! symbol!  
tag! time! tuple!  
unset! url!  
word!  
any-block? any-function? any-string? any-type? any-word?  
binary? bitset? block?  
char? connected? crypt-strength? 
datatype? date? decimal? dir?  
email? empty? equal? error? even? event? exists? exists-key?
file? flag-face? found? function?  
get-word? greater-or-equal? greater?  
hash? head?  
image? in-window? index? info? input? inside? integer? issue?  
length? lesser-or-equal? lesser? library? link-app? link? list? lit-path? lit-word? logic?  
modified? money?  
native? negative? none? not-equal? number?  
object? odd? offset? op? outside?  
pair? paren? path? port? positive?  
refinement? routine?  
same? screen-offset? script? series? set-path? set-word? size? span? strict-equal? strict-not-equal? string? struct?  
tag? tail? time? tuple? type?  
unset? url?  
value? view? 
within? word?  
zero?</t>
<t tx="T92">@language plain
@pagewidth 72
@tabwidth 2

The intent of this tool is to provide 
an aid to memorization practice.  The 
tool is directed at memorization of 
prose or poetry, not music or 
mathematics.  It would probably not 
be useful for memorization of dialog.  The 
purpose of such memorization is 
to be able to recreate a chunk of 
text in your head or on paper, and perhaps verbally.

The steps might be as follows:</t>
<t tx="T93">a b leoDialogs leoFind leoAtFile leoFileCommands leoGlobals modal end
line tooo changed 9
</t>
<t tx="T94">this is another test.

hello there jkk this is werg
		
the cht sat on the marh
the cat was sitting phew, another day. by zz z z 
two initabc
</t>
<t tx="T95">everything good.</t>
<t tx="T96"></t>
<t tx="T97">from leoGlobals import *
f = top().frame

f.clearStatusLine()

f.putStatusLine ("Hello")

for color in ("red","blue","yellow","green","orange"):
	f.putStatusLine (" %s " % (color),color=color)

f.putStatusLine(" World")</t>
<t tx="T98">from leoGlobals import *
f = top().frame

f.clearStatusLine()
</t>
<t tx="T99"></t>
<t tx="T100">@tabwidth 2

a
	b
		c	d</t>
<t tx="T101">@tabwidth 4

a
	b
		c	d</t>
<t tx="T102">@tabwidth 6

a
	b
		c	d</t>
<t tx="T103">@tabwidth 8

a
	b
		c	d</t>
<t tx="T104"></t>
<t tx="T105">This is section a.</t>
<t tx="T106">&lt;&lt; section a &gt;&gt;</t>
<t tx="T107"></t>
<t tx="T108">import timeit</t>
<t tx="T109">ab
</t>
<t tx="T110"></t>
<t tx="T111"># The following corrupts the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
	line 2

	after
</t>
<t tx="T112"># The following corrupts the outline: extract section, undo.

&lt;&lt; test &gt;&gt;
line 1
	line 2

	after

</t>
<t tx="T113"></t>
<t tx="T114"></t>
<t tx="T115">test one</t>
<t tx="T116">from leoGlobals import *
import gc,os,time,leoNodes
from xml.sax import saxutils, make_parser
from xml.sax.xmlreader import InputSource

path = os.path.join(app().loadDir,"../","test","test2.leo")
# path = os.path.join(app().loadDir,"LeoPy.leo")
path = os.path.normpath(path)

verbose = true
tnodes = vnodes = 0
start = None

def clean(s): return toEncodedString(s,"ascii")

class trace_parse(saxutils.XMLGenerator):
	lastContent = None
	def startDocument(self):
		if 0: # Doesn't smooth things out.
			gc.collect() 
		global start ; start = time.clock()
		if verbose:
			print ; print ; print '*' * 30 + " dump " + '*' * 30 ; print
			trace()
	def endDocument(self):
		global start ; print "total time" + "%6.3f" % (time.clock()-start)
		if verbose: trace()
	def startElement(self,name,attrs):
		global vnodes,tnodes
		self.lastContent = None
		if verbose:
			name = clean(name).strip()
			self.lastName = name
			a = []
			keys = attrs.keys()
			keys.sort()
			for key in keys:
				a.append("%s=%s" % (key,attrs.getValue(key)))
			if name not in (("vh"),):
				print
			if a:
				print '&lt;%s %s&gt;' % (name, string.join(a,' ')),
			else:
				print '&lt;%s&gt;' % name,
			# if name in (("t"),): print
		if name == "v":
			vnodes += 1 ; v = leoNodes.vnode(top(),leoNodes.tnode())
		elif name == "t":
			tnodes += 1 ; t = leoNodes.tnode()
	def endElement(self,name):
		name = clean(name).strip()
		if verbose:
			if self.lastContent and name not in (("vh"),):
				print
			print '&lt;/%s&gt;' % name,
		self.lastName = name
	def characters(self,content):
		self.lastContent = content = content.replace('\r','')
		if verbose and content.strip():
			if self.lastName != "vh": print
			print clean(content),
	def ignorableWhitespace(self):                trace()
	def processingInstruction (self,target,data): trace()
	def skippedEntity(self,name):                 trace(name)
	def startElementNS(self,name,qname,attrs):    trace(name)
	def endElementNS(self,name,qname):            trace(name)
	
try:
	f = None
	try:
		print path
		if 1: # not needed, and it works.
			source = InputSource(path)
			# source.setEncoding(app().tkEncoding)
		else:
			source = f = open(path)
		parser = make_parser()
		parser.setContentHandler(trace_parse())
		parser.parse(source)
		print "vnodes,tnodes:",`vnodes`,`tnodes`
	except: es_exception()
finally:
	if f: f.close()</t>
<t tx="T117">from leoGlobals import *
c = top() ; v = c.currentVnode()
print v
print `v`</t>
<t tx="T118">@ignore</t>
<t tx="T119"></t>
<t tx="T120">import wxLeo
reload(wxLeo)</t>
<t tx="T121"></t>
<t tx="T122">@others</t>
<t tx="T123">@wrap

this should wrap aaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff</t>
<t tx="T124">@nowrap

this should NOT wrap aaaaaaaaaaaaaaaaaaa bbbbbbbbbbbbbbbbbbbbb cccccccccccccccccc ddddddddddddddddddd eeeeeeeeeeeeeeeeeeeeee ffffffffffffffffffff</t>
<t tx="T125">@ doc part
@c

doc test</t>
<t tx="T126">@ignore
@encoding iso-8859-1</t>
<t tx="T127">ref line 1
ref line 2</t>
<t tx="T128">@first first line1
@first first line2
@ This is a doc part
line 2
line 3
@c

# gnxText.txt  2

before
&lt;&lt; ref &gt;&gt; afterref
middle
	&lt;&lt; ref2 &gt;&gt;
after
	@others
beforref &lt;&lt; ref &gt;&gt;
after at-others
@last last line1
@last last line2</t>
<t tx="T129">ref2 line</t>
<t tx="T130"></t>
<t tx="T131">@ Doc part
doc part line 2
@c
	indented node 1 line 1
node 2 line 2</t>
<t tx="T132"></t>
<t tx="T133">node 2 line 1
node 2 line 2
</t>
</tnodes>
</leo_file>
